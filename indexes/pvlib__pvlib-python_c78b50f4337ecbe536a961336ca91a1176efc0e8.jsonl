{"doc_id": "benchmarks/benchmarks/detect_clearsky.py::DetectClear.setup", "file_path": "benchmarks/benchmarks/detect_clearsky.py", "class_name": "DetectClear", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/detect_clearsky.py, 类名: DetectClear\n    def setup(self, ndays):\n        self.times = pd.date_range(start='20180601', freq='1min',\n                                   periods=1440*ndays)\n        self.lat = 35.1\n        self.lon = -106.6\n        self.solar_position = solarposition.get_solarposition(\n            self.times, self.lat, self.lon)\n        clearsky_df = clearsky.simplified_solis(\n            self.solar_position['apparent_elevation'])\n        self.clearsky = clearsky_df['ghi']\n        measured_dni = clearsky_df['dni'].where(\n            (self.times.hour % 2).astype(bool), 0)\n        cos_zen = np.cos(np.deg2rad(self.solar_position['apparent_zenith']))\n        self.measured = measured_dni * cos_zen + clearsky_df['dhi']\n        self.measured *= 0.98\n        self.window_length = 10\n", "tokens": ["benchmarks", "benchmarks", "detect_clearsky", "py", "detectclear", "def", "setup", "self", "ndays", "self", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "1440", "ndays", "self", "lat", "35", "1", "self", "lon", "106", "6", "self", "solar_position", "solarposition", "get_solarposition", "self", "times", "self", "lat", "self", "lon", "clearsky_df", "clearsky", "simplified_solis", "self", "solar_position", "apparent_elevation", "self", "clearsky", "clearsky_df", "ghi", "measured_dni", "clearsky_df", "dni", "where", "self", "times", "hour", "2", "astype", "bool", "0", "cos_zen", "np", "cos", "np", "deg2rad", "self", "solar_position", "apparent_zenith", "self", "measured", "measured_dni", "cos_zen", "clearsky_df", "dhi", "self", "measured", "0", "98", "self", "window_length", "10"], "doc_len": 80}
{"doc_id": "benchmarks/benchmarks/detect_clearsky.py::DetectClear.time_detect_clearsky", "file_path": "benchmarks/benchmarks/detect_clearsky.py", "class_name": "DetectClear", "func_name": "time_detect_clearsky", "text": "文件路径: benchmarks/benchmarks/detect_clearsky.py, 类名: DetectClear\n    def time_detect_clearsky(self, ndays):\n        clearsky.detect_clearsky(\n            self.measured, self.clearsky, self.times, self.window_length\n        )\n", "tokens": ["benchmarks", "benchmarks", "detect_clearsky", "py", "detectclear", "def", "time_detect_clearsky", "self", "ndays", "clearsky", "detect_clearsky", "self", "measured", "self", "clearsky", "self", "times", "self", "window_length"], "doc_len": 19}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.setup", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def setup(self):\n        self.times = pd.date_range(start='20180601', freq='1min',\n                                   periods=14400)\n        self.days = pd.date_range(start='20180601', freq='d', periods=30)\n        self.location = location.Location(40, -80)\n        self.solar_position = self.location.get_solarposition(self.times)\n        self.clearsky_irradiance = self.location.get_clearsky(self.times)\n        self.tilt = 20\n        self.azimuth = 180\n        self.aoi = irradiance.aoi(self.tilt, self.azimuth,\n                                  self.solar_position.apparent_zenith,\n                                  self.solar_position.azimuth)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "setup", "self", "self", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "14400", "self", "days", "pd", "date_range", "start", "20180601", "freq", "d", "periods", "30", "self", "location", "location", "location", "40", "80", "self", "solar_position", "self", "location", "get_solarposition", "self", "times", "self", "clearsky_irradiance", "self", "location", "get_clearsky", "self", "times", "self", "tilt", "20", "self", "azimuth", "180", "self", "aoi", "irradiance", "aoi", "self", "tilt", "self", "azimuth", "self", "solar_position", "apparent_zenith", "self", "solar_position", "azimuth"], "doc_len": 68}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_get_extra_radiation", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_get_extra_radiation", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_get_extra_radiation(self):\n        irradiance.get_extra_radiation(self.days)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_get_extra_radiation", "self", "irradiance", "get_extra_radiation", "self", "days"], "doc_len": 12}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_aoi", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_aoi", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_aoi(self):\n        irradiance.aoi(self.tilt, self.azimuth,\n                       self.solar_position.apparent_zenith,\n                       self.solar_position.azimuth)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_aoi", "self", "irradiance", "aoi", "self", "tilt", "self", "azimuth", "self", "solar_position", "apparent_zenith", "self", "solar_position", "azimuth"], "doc_len": 20}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_aoi_projection", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_aoi_projection", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_aoi_projection(self):\n        irradiance.aoi_projection(self.tilt, self.azimuth,\n                                  self.solar_position.apparent_zenith,\n                                  self.solar_position.azimuth)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_aoi_projection", "self", "irradiance", "aoi_projection", "self", "tilt", "self", "azimuth", "self", "solar_position", "apparent_zenith", "self", "solar_position", "azimuth"], "doc_len": 20}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_get_ground_diffuse", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_get_ground_diffuse", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_get_ground_diffuse(self):\n        irradiance.get_ground_diffuse(self.tilt, self.clearsky_irradiance.ghi)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_get_ground_diffuse", "self", "irradiance", "get_ground_diffuse", "self", "tilt", "self", "clearsky_irradiance", "ghi"], "doc_len": 15}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_get_total_irradiance", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_get_total_irradiance", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_get_total_irradiance(self):\n        irradiance.get_total_irradiance(self.tilt, self.azimuth,\n                                        self.solar_position.apparent_zenith,\n                                        self.solar_position.azimuth,\n                                        self.clearsky_irradiance.dni,\n                                        self.clearsky_irradiance.ghi,\n                                        self.clearsky_irradiance.dhi)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_get_total_irradiance", "self", "irradiance", "get_total_irradiance", "self", "tilt", "self", "azimuth", "self", "solar_position", "apparent_zenith", "self", "solar_position", "azimuth", "self", "clearsky_irradiance", "dni", "self", "clearsky_irradiance", "ghi", "self", "clearsky_irradiance", "dhi"], "doc_len": 29}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_disc", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_disc", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_disc(self):\n        irradiance.disc(self.clearsky_irradiance.ghi,\n                        self.solar_position.apparent_zenith,\n                        self.times)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_disc", "self", "irradiance", "disc", "self", "clearsky_irradiance", "ghi", "self", "solar_position", "apparent_zenith", "self", "times"], "doc_len": 18}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_dirint", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_dirint", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_dirint(self):\n        irradiance.dirint(self.clearsky_irradiance.ghi,\n                          self.solar_position.apparent_zenith,\n                          self.times)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_dirint", "self", "irradiance", "dirint", "self", "clearsky_irradiance", "ghi", "self", "solar_position", "apparent_zenith", "self", "times"], "doc_len": 18}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_dirindex", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_dirindex", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_dirindex(self):\n        irradiance.dirindex(self.clearsky_irradiance.ghi,\n                            self.clearsky_irradiance.ghi,\n                            self.clearsky_irradiance.dni,\n                            self.solar_position.apparent_zenith,\n                            self.times)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_dirindex", "self", "irradiance", "dirindex", "self", "clearsky_irradiance", "ghi", "self", "clearsky_irradiance", "ghi", "self", "clearsky_irradiance", "dni", "self", "solar_position", "apparent_zenith", "self", "times"], "doc_len": 24}
{"doc_id": "benchmarks/benchmarks/irradiance.py::Irradiance.time_erbs", "file_path": "benchmarks/benchmarks/irradiance.py", "class_name": "Irradiance", "func_name": "time_erbs", "text": "文件路径: benchmarks/benchmarks/irradiance.py, 类名: Irradiance\n    def time_erbs(self):\n        irradiance.erbs(self.clearsky_irradiance.ghi,\n                        self.solar_position.apparent_zenith,\n                        self.times)\n", "tokens": ["benchmarks", "benchmarks", "irradiance", "py", "irradiance", "def", "time_erbs", "self", "irradiance", "erbs", "self", "clearsky_irradiance", "ghi", "self", "solar_position", "apparent_zenith", "self", "times"], "doc_len": 18}
{"doc_id": "benchmarks/benchmarks/location.py::set_solar_position", "file_path": "benchmarks/benchmarks/location.py", "class_name": null, "func_name": "set_solar_position", "text": "文件路径: benchmarks/benchmarks/location.py\ndef set_solar_position(obj):\n    obj.location = pvlib.location.Location(32, -110, altitude=700,\n                                           tz='Etc/GMT+7')\n    obj.times = pd.date_range(start='20180601', freq='3min',\n                              periods=1440)\n    obj.days = pd.date_range(start='20180101', freq='d', periods=365,\n                             tz=obj.location.tz)\n    obj.solar_position = obj.location.get_solarposition(obj.times)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "def", "set_solar_position", "obj", "obj", "location", "pvlib", "location", "location", "32", "110", "altitude", "700", "tz", "etc", "gmt", "7", "obj", "times", "pd", "date_range", "start", "20180601", "freq", "3min", "periods", "1440", "obj", "days", "pd", "date_range", "start", "20180101", "freq", "d", "periods", "365", "tz", "obj", "location", "tz", "obj", "solar_position", "obj", "location", "get_solarposition", "obj", "times"], "doc_len": 51}
{"doc_id": "benchmarks/benchmarks/location.py::Location.setup", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location\n    def setup(self):\n        set_solar_position(self)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location", "def", "setup", "self", "set_solar_position", "self"], "doc_len": 10}
{"doc_id": "benchmarks/benchmarks/location.py::Location.time_location_get_airmass", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location", "func_name": "time_location_get_airmass", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location\n    def time_location_get_airmass(self):\n        self.location.get_airmass(solar_position=self.solar_position)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location", "def", "time_location_get_airmass", "self", "self", "location", "get_airmass", "solar_position", "self", "solar_position"], "doc_len": 14}
{"doc_id": "benchmarks/benchmarks/location.py::Location.time_location_get_solarposition", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location", "func_name": "time_location_get_solarposition", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location\n    def time_location_get_solarposition(self):\n        self.location.get_solarposition(times=self.times)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location", "def", "time_location_get_solarposition", "self", "self", "location", "get_solarposition", "times", "self", "times"], "doc_len": 14}
{"doc_id": "benchmarks/benchmarks/location.py::Location.time_location_get_clearsky", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location", "func_name": "time_location_get_clearsky", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location\n    def time_location_get_clearsky(self):\n        self.location.get_clearsky(times=self.times,\n                                   solar_position=self.solar_position)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location", "def", "time_location_get_clearsky", "self", "self", "location", "get_clearsky", "times", "self", "times", "solar_position", "self", "solar_position"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/location.py::Location_0_6_1.setup", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location_0_6_1", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location_0_6_1\n    def setup(self):\n        if parse_version(pvlib.__version__) < parse_version('0.6.1'):\n            raise NotImplementedError\n\n        set_solar_position(self)\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location_0_6_1", "def", "setup", "self", "if", "parse_version", "pvlib", "__version__", "parse_version", "0", "6", "1", "raise", "notimplementederror", "set_solar_position", "self"], "doc_len": 20}
{"doc_id": "benchmarks/benchmarks/location.py::Location_0_6_1.time_location_get_sun_rise_set_transit_pyephem", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location_0_6_1", "func_name": "time_location_get_sun_rise_set_transit_pyephem", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location_0_6_1\n    def time_location_get_sun_rise_set_transit_pyephem(self):\n        self.location.get_sun_rise_set_transit(times=self.days,\n                                               method='pyephem')\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location_0_6_1", "def", "time_location_get_sun_rise_set_transit_pyephem", "self", "self", "location", "get_sun_rise_set_transit", "times", "self", "days", "method", "pyephem"], "doc_len": 16}
{"doc_id": "benchmarks/benchmarks/location.py::Location_0_6_1.time_location_get_sun_rise_set_transit_spa", "file_path": "benchmarks/benchmarks/location.py", "class_name": "Location_0_6_1", "func_name": "time_location_get_sun_rise_set_transit_spa", "text": "文件路径: benchmarks/benchmarks/location.py, 类名: Location_0_6_1\n    def time_location_get_sun_rise_set_transit_spa(self):\n        self.location.get_sun_rise_set_transit(times=self.days,\n                                               method='spa')\n", "tokens": ["benchmarks", "benchmarks", "location", "py", "location_0_6_1", "def", "time_location_get_sun_rise_set_transit_spa", "self", "self", "location", "get_sun_rise_set_transit", "times", "self", "days", "method", "spa"], "doc_len": 16}
{"doc_id": "benchmarks/benchmarks/scaling.py::Scaling.setup", "file_path": "benchmarks/benchmarks/scaling.py", "class_name": "Scaling", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/scaling.py, 类名: Scaling\n    def setup(self):\n        self.n = 1000\n        lat = np.array((9.99, 10, 10.01))\n        lon = np.array((4.99, 5, 5.01))\n        self.coordinates = np.array([(lati, loni) for\n                                     (lati, loni) in zip(lat, lon)])\n        self.times = pd.date_range('2019-01-01', freq='1T', periods=self.n)\n        self.positions = np.array([[0, 0], [100, 0], [100, 100], [0, 100]])\n        self.clearsky_index = pd.Series(np.random.rand(self.n),\n                                        index=self.times)\n        self.cloud_speed = 5\n        self.tmscales = np.array((1, 2, 4, 8, 16, 32, 64,\n                                 128, 256, 512, 1024, 2048, 4096))\n", "tokens": ["benchmarks", "benchmarks", "scaling", "py", "scaling", "def", "setup", "self", "self", "n", "1000", "lat", "np", "array", "9", "99", "10", "10", "01", "lon", "np", "array", "4", "99", "5", "5", "01", "self", "coordinates", "np", "array", "lati", "loni", "for", "lati", "loni", "in", "zip", "lat", "lon", "self", "times", "pd", "date_range", "2019", "01", "01", "freq", "1t", "periods", "self", "n", "self", "positions", "np", "array", "0", "0", "100", "0", "100", "100", "0", "100", "self", "clearsky_index", "pd", "series", "np", "random", "rand", "self", "n", "index", "self", "times", "self", "cloud_speed", "5", "self", "tmscales", "np", "array", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024", "2048", "4096"], "doc_len": 96}
{"doc_id": "benchmarks/benchmarks/scaling.py::Scaling.time_latlon_to_xy", "file_path": "benchmarks/benchmarks/scaling.py", "class_name": "Scaling", "func_name": "time_latlon_to_xy", "text": "文件路径: benchmarks/benchmarks/scaling.py, 类名: Scaling\n    def time_latlon_to_xy(self):\n        scaling.latlon_to_xy(self.coordinates)\n", "tokens": ["benchmarks", "benchmarks", "scaling", "py", "scaling", "def", "time_latlon_to_xy", "self", "scaling", "latlon_to_xy", "self", "coordinates"], "doc_len": 12}
{"doc_id": "benchmarks/benchmarks/scaling.py::Scaling.time__compute_wavelet", "file_path": "benchmarks/benchmarks/scaling.py", "class_name": "Scaling", "func_name": "time__compute_wavelet", "text": "文件路径: benchmarks/benchmarks/scaling.py, 类名: Scaling\n    def time__compute_wavelet(self):\n        scaling._compute_wavelet(self.clearsky_index, dt=1)\n", "tokens": ["benchmarks", "benchmarks", "scaling", "py", "scaling", "def", "time__compute_wavelet", "self", "scaling", "_compute_wavelet", "self", "clearsky_index", "dt", "1"], "doc_len": 14}
{"doc_id": "benchmarks/benchmarks/scaling.py::Scaling.time__compute_vr", "file_path": "benchmarks/benchmarks/scaling.py", "class_name": "Scaling", "func_name": "time__compute_vr", "text": "文件路径: benchmarks/benchmarks/scaling.py, 类名: Scaling\n    def time__compute_vr(self):\n        scaling._compute_vr(self.positions, self.cloud_speed, self.tmscales)\n", "tokens": ["benchmarks", "benchmarks", "scaling", "py", "scaling", "def", "time__compute_vr", "self", "scaling", "_compute_vr", "self", "positions", "self", "cloud_speed", "self", "tmscales"], "doc_len": 16}
{"doc_id": "benchmarks/benchmarks/scaling.py::Scaling.time_wvm", "file_path": "benchmarks/benchmarks/scaling.py", "class_name": "Scaling", "func_name": "time_wvm", "text": "文件路径: benchmarks/benchmarks/scaling.py, 类名: Scaling\n    def time_wvm(self):\n        scaling.wvm(self.clearsky_index, self.positions,\n                    self.cloud_speed, dt=1)\n", "tokens": ["benchmarks", "benchmarks", "scaling", "py", "scaling", "def", "time_wvm", "self", "scaling", "wvm", "self", "clearsky_index", "self", "positions", "self", "cloud_speed", "dt", "1"], "doc_len": 18}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.setup", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def setup(self, ndays):\n        self.times = pd.date_range(start='20180601', freq='1min',\n                                   periods=1440*ndays)\n        self.times_localized = self.times.tz_localize('Etc/GMT+7')\n        self.lat = 35.1\n        self.lon = -106.6\n        self.times_daily = pd.date_range(\n            start='20180601', freq='24h', periods=ndays, tz='Etc/GMT+7')\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "setup", "self", "ndays", "self", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "1440", "ndays", "self", "times_localized", "self", "times", "tz_localize", "etc", "gmt", "7", "self", "lat", "35", "1", "self", "lon", "106", "6", "self", "times_daily", "pd", "date_range", "start", "20180601", "freq", "24h", "periods", "ndays", "tz", "etc", "gmt", "7"], "doc_len": 50}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_ephemeris", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_ephemeris", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_ephemeris(self, ndays):\n        solarposition.ephemeris(self.times, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_ephemeris", "self", "ndays", "solarposition", "ephemeris", "self", "times", "self", "lat", "self", "lon"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_ephemeris_localized", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_ephemeris_localized", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_ephemeris_localized(self, ndays):\n        solarposition.ephemeris(self.times_localized, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_ephemeris_localized", "self", "ndays", "solarposition", "ephemeris", "self", "times_localized", "self", "lat", "self", "lon"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_spa_python", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_spa_python", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_spa_python(self, ndays):\n        solarposition.spa_python(self.times_localized, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_spa_python", "self", "ndays", "solarposition", "spa_python", "self", "times_localized", "self", "lat", "self", "lon"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_pyephem", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_pyephem", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_pyephem(self, ndays):\n        solarposition.pyephem(self.times_localized, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_pyephem", "self", "ndays", "solarposition", "pyephem", "self", "times_localized", "self", "lat", "self", "lon"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_sun_rise_set_transit_spa", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_sun_rise_set_transit_spa", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_sun_rise_set_transit_spa(self, ndays):\n        sun_rise_set_transit_spa(self.times_daily, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_sun_rise_set_transit_spa", "self", "ndays", "sun_rise_set_transit_spa", "self", "times_daily", "self", "lat", "self", "lon"], "doc_len": 16}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_sun_rise_set_transit_ephem", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_sun_rise_set_transit_ephem", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_sun_rise_set_transit_ephem(self, ndays):\n        solarposition.sun_rise_set_transit_ephem(\n            self.times_daily, self.lat, self.lon)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_sun_rise_set_transit_ephem", "self", "ndays", "solarposition", "sun_rise_set_transit_ephem", "self", "times_daily", "self", "lat", "self", "lon"], "doc_len": 17}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_sun_rise_set_transit_geometric_full_comparison", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_sun_rise_set_transit_geometric_full_comparison", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_sun_rise_set_transit_geometric_full_comparison(self, ndays):\n        dayofyear = self.times_daily.dayofyear\n        declination = solarposition.declination_spencer71(dayofyear)\n        equation_of_time = solarposition.equation_of_time_spencer71(dayofyear)\n        solarposition.sun_rise_set_transit_geometric(\n            self.times_daily, self.lat, self.lon, declination,\n            equation_of_time)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_sun_rise_set_transit_geometric_full_comparison", "self", "ndays", "dayofyear", "self", "times_daily", "dayofyear", "declination", "solarposition", "declination_spencer71", "dayofyear", "equation_of_time", "solarposition", "equation_of_time_spencer71", "dayofyear", "solarposition", "sun_rise_set_transit_geometric", "self", "times_daily", "self", "lat", "self", "lon", "declination", "equation_of_time"], "doc_len": 31}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPosition.time_nrel_earthsun_distance", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPosition", "func_name": "time_nrel_earthsun_distance", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPosition\n    def time_nrel_earthsun_distance(self, ndays):\n        solarposition.nrel_earthsun_distance(self.times_localized)\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarposition", "def", "time_nrel_earthsun_distance", "self", "ndays", "solarposition", "nrel_earthsun_distance", "self", "times_localized"], "doc_len": 13}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPositionCalcTime.setup", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPositionCalcTime", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPositionCalcTime\n    def setup(self):\n        # test calc_time for finding times at which sun is 3 degrees\n        # above the horizon.\n        # Tucson 2020-09-14 sunrise at 6:08 AM MST, 13:08 UTC\n        # according to google.\n        self.start = datetime.datetime(2020, 9, 14, 12)\n        self.end = datetime.datetime(2020, 9, 14, 15)\n        self.value = 0.05235987755982988\n        self.lat = 32.2\n        self.lon = -110.9\n        self.attribute = 'alt'\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarpositioncalctime", "def", "setup", "self", "test", "calc_time", "for", "finding", "times", "at", "which", "sun", "is", "3", "degrees", "above", "the", "horizon", "tucson", "2020", "09", "14", "sunrise", "at", "6", "08", "am", "mst", "13", "08", "utc", "according", "to", "google", "self", "start", "datetime", "datetime", "2020", "9", "14", "12", "self", "end", "datetime", "datetime", "2020", "9", "14", "15", "self", "value", "0", "05235987755982988", "self", "lat", "32", "2", "self", "lon", "110", "9", "self", "attribute", "alt"], "doc_len": 69}
{"doc_id": "benchmarks/benchmarks/solarposition.py::SolarPositionCalcTime.time_calc_time", "file_path": "benchmarks/benchmarks/solarposition.py", "class_name": "SolarPositionCalcTime", "func_name": "time_calc_time", "text": "文件路径: benchmarks/benchmarks/solarposition.py, 类名: SolarPositionCalcTime\n    def time_calc_time(self):\n        # datetime.datetime(2020, 9, 14, 13, 24, 13, 861913, tzinfo=<UTC>)\n        solarposition.calc_time(\n            self.start, self.end, self.lat, self.lon, self.attribute,\n            self.value\n        )\n", "tokens": ["benchmarks", "benchmarks", "solarposition", "py", "solarpositioncalctime", "def", "time_calc_time", "self", "datetime", "datetime", "2020", "9", "14", "13", "24", "13", "861913", "tzinfo", "utc", "solarposition", "calc_time", "self", "start", "self", "end", "self", "lat", "self", "lon", "self", "attribute", "self", "value"], "doc_len": 33}
{"doc_id": "benchmarks/benchmarks/solarposition_numba.py::SolarPositionNumba.setup", "file_path": "benchmarks/benchmarks/solarposition_numba.py", "class_name": "SolarPositionNumba", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/solarposition_numba.py, 类名: SolarPositionNumba\n    def setup(self, ndays):\n        self.times = pd.date_range(start='20180601', freq='1min',\n                                   periods=1440*ndays)\n        self.times_localized = self.times.tz_localize('Etc/GMT+7')\n        self.lat = 35.1\n        self.lon = -106.6\n        self.times_daily = pd.date_range(\n            start='20180601', freq='24h', periods=ndays, tz='Etc/GMT+7')\n", "tokens": ["benchmarks", "benchmarks", "solarposition_numba", "py", "solarpositionnumba", "def", "setup", "self", "ndays", "self", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "1440", "ndays", "self", "times_localized", "self", "times", "tz_localize", "etc", "gmt", "7", "self", "lat", "35", "1", "self", "lon", "106", "6", "self", "times_daily", "pd", "date_range", "start", "20180601", "freq", "24h", "periods", "ndays", "tz", "etc", "gmt", "7"], "doc_len": 50}
{"doc_id": "benchmarks/benchmarks/solarposition_numba.py::SolarPositionNumba.time_spa_python", "file_path": "benchmarks/benchmarks/solarposition_numba.py", "class_name": "SolarPositionNumba", "func_name": "time_spa_python", "text": "文件路径: benchmarks/benchmarks/solarposition_numba.py, 类名: SolarPositionNumba\n    def time_spa_python(self, ndays):\n        solarposition.spa_python(\n            self.times_localized, self.lat, self.lon, how='numba')\n", "tokens": ["benchmarks", "benchmarks", "solarposition_numba", "py", "solarpositionnumba", "def", "time_spa_python", "self", "ndays", "solarposition", "spa_python", "self", "times_localized", "self", "lat", "self", "lon", "how", "numba"], "doc_len": 19}
{"doc_id": "benchmarks/benchmarks/solarposition_numba.py::SolarPositionNumba.time_sun_rise_set_transit_spa", "file_path": "benchmarks/benchmarks/solarposition_numba.py", "class_name": "SolarPositionNumba", "func_name": "time_sun_rise_set_transit_spa", "text": "文件路径: benchmarks/benchmarks/solarposition_numba.py, 类名: SolarPositionNumba\n    def time_sun_rise_set_transit_spa(self, ndays):\n        sun_rise_set_transit_spa(\n            self.times_daily, self.lat, self.lon, how='numba')\n", "tokens": ["benchmarks", "benchmarks", "solarposition_numba", "py", "solarpositionnumba", "def", "time_sun_rise_set_transit_spa", "self", "ndays", "sun_rise_set_transit_spa", "self", "times_daily", "self", "lat", "self", "lon", "how", "numba"], "doc_len": 18}
{"doc_id": "benchmarks/benchmarks/temperature.py::set_weather_data", "file_path": "benchmarks/benchmarks/temperature.py", "class_name": null, "func_name": "set_weather_data", "text": "文件路径: benchmarks/benchmarks/temperature.py\ndef set_weather_data(obj):\n    obj.times = pd.date_range(start='20180601', freq='1min',\n                              periods=14400)\n    obj.poa = pd.Series(1000, index=obj.times)\n    obj.tamb = pd.Series(20, index=obj.times)\n    obj.wind_speed = pd.Series(2, index=obj.times)\n", "tokens": ["benchmarks", "benchmarks", "temperature", "py", "def", "set_weather_data", "obj", "obj", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "14400", "obj", "poa", "pd", "series", "1000", "index", "obj", "times", "obj", "tamb", "pd", "series", "20", "index", "obj", "times", "obj", "wind_speed", "pd", "series", "2", "index", "obj", "times"], "doc_len": 41}
{"doc_id": "benchmarks/benchmarks/temperature.py::SAPM.setup", "file_path": "benchmarks/benchmarks/temperature.py", "class_name": "SAPM", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/temperature.py, 类名: SAPM\n    def setup(self):\n        set_weather_data(self)\n        if parse_version(pvlib.__version__) >= parse_version('0.7.0'):\n            kwargs = pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS['sapm']\n            kwargs = kwargs['open_rack_glass_glass']\n            self.sapm_cell_wrapper = partial(pvlib.temperature.sapm_cell,\n                                             **kwargs)\n        else:\n            sapm_celltemp = pvlib.pvsystem.sapm_celltemp\n\n            def sapm_cell_wrapper(poa_global, temp_air, wind_speed):\n                # just swap order; model params are provided by default\n                return sapm_celltemp(poa_global, wind_speed, temp_air)\n            self.sapm_cell_wrapper = sapm_cell_wrapper\n", "tokens": ["benchmarks", "benchmarks", "temperature", "py", "sapm", "def", "setup", "self", "set_weather_data", "self", "if", "parse_version", "pvlib", "__version__", "parse_version", "0", "7", "0", "kwargs", "pvlib", "temperature", "temperature_model_parameters", "sapm", "kwargs", "kwargs", "open_rack_glass_glass", "self", "sapm_cell_wrapper", "partial", "pvlib", "temperature", "sapm_cell", "kwargs", "else", "sapm_celltemp", "pvlib", "pvsystem", "sapm_celltemp", "def", "sapm_cell_wrapper", "poa_global", "temp_air", "wind_speed", "just", "swap", "order", "model", "params", "are", "provided", "by", "default", "return", "sapm_celltemp", "poa_global", "wind_speed", "temp_air", "self", "sapm_cell_wrapper", "sapm_cell_wrapper"], "doc_len": 60}
{"doc_id": "benchmarks/benchmarks/temperature.py::SAPM.time_sapm_cell", "file_path": "benchmarks/benchmarks/temperature.py", "class_name": "SAPM", "func_name": "time_sapm_cell", "text": "文件路径: benchmarks/benchmarks/temperature.py, 类名: SAPM\n    def time_sapm_cell(self):\n        # use version-appropriate wrapper\n        self.sapm_cell_wrapper(self.poa, self.tamb, self.wind_speed)\n", "tokens": ["benchmarks", "benchmarks", "temperature", "py", "sapm", "def", "time_sapm_cell", "self", "use", "version", "appropriate", "wrapper", "self", "sapm_cell_wrapper", "self", "poa", "self", "tamb", "self", "wind_speed"], "doc_len": 20}
{"doc_id": "benchmarks/benchmarks/temperature.py::Fuentes.setup", "file_path": "benchmarks/benchmarks/temperature.py", "class_name": "Fuentes", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/temperature.py, 类名: Fuentes\n    def setup(self):\n        if parse_version(pvlib.__version__) < parse_version('0.8.0'):\n            raise NotImplementedError\n\n        set_weather_data(self)\n", "tokens": ["benchmarks", "benchmarks", "temperature", "py", "fuentes", "def", "setup", "self", "if", "parse_version", "pvlib", "__version__", "parse_version", "0", "8", "0", "raise", "notimplementederror", "set_weather_data", "self"], "doc_len": 20}
{"doc_id": "benchmarks/benchmarks/temperature.py::Fuentes.time_fuentes", "file_path": "benchmarks/benchmarks/temperature.py", "class_name": "Fuentes", "func_name": "time_fuentes", "text": "文件路径: benchmarks/benchmarks/temperature.py, 类名: Fuentes\n    def time_fuentes(self):\n        pvlib.temperature.fuentes(self.poa, self.tamb, self.wind_speed,\n                                  noct_installed=45)\n", "tokens": ["benchmarks", "benchmarks", "temperature", "py", "fuentes", "def", "time_fuentes", "self", "pvlib", "temperature", "fuentes", "self", "poa", "self", "tamb", "self", "wind_speed", "noct_installed", "45"], "doc_len": 19}
{"doc_id": "benchmarks/benchmarks/tracking.py::SingleAxis.setup", "file_path": "benchmarks/benchmarks/tracking.py", "class_name": "SingleAxis", "func_name": "setup", "text": "文件路径: benchmarks/benchmarks/tracking.py, 类名: SingleAxis\n    def setup(self):\n        self.times = pd.date_range(start='20180601', freq='1min',\n                                   periods=14400)\n        self.lat = 35.1\n        self.lon = -106.6\n        self.solar_position = solarposition.get_solarposition(self.times,\n                                                              self.lat,\n                                                              self.lon)\n", "tokens": ["benchmarks", "benchmarks", "tracking", "py", "singleaxis", "def", "setup", "self", "self", "times", "pd", "date_range", "start", "20180601", "freq", "1min", "periods", "14400", "self", "lat", "35", "1", "self", "lon", "106", "6", "self", "solar_position", "solarposition", "get_solarposition", "self", "times", "self", "lat", "self", "lon"], "doc_len": 36}
{"doc_id": "benchmarks/benchmarks/tracking.py::SingleAxis.time_singleaxis", "file_path": "benchmarks/benchmarks/tracking.py", "class_name": "SingleAxis", "func_name": "time_singleaxis", "text": "文件路径: benchmarks/benchmarks/tracking.py, 类名: SingleAxis\n    def time_singleaxis(self):\n        with np.errstate(invalid='ignore'):\n            tracking.singleaxis(self.solar_position.apparent_zenith,\n                                self.solar_position.azimuth,\n                                axis_tilt=0,\n                                axis_azimuth=0,\n                                max_angle=60,\n                                backtrack=True,\n                                gcr=0.45)\n", "tokens": ["benchmarks", "benchmarks", "tracking", "py", "singleaxis", "def", "time_singleaxis", "self", "with", "np", "errstate", "invalid", "ignore", "tracking", "singleaxis", "self", "solar_position", "apparent_zenith", "self", "solar_position", "azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "60", "backtrack", "true", "gcr", "0", "45"], "doc_len": 32}
{"doc_id": "docs/examples/irradiance-transposition/plot_ghi_transposition.py::get_irradiance", "file_path": "docs/examples/irradiance-transposition/plot_ghi_transposition.py", "class_name": null, "func_name": "get_irradiance", "text": "文件路径: docs/examples/irradiance-transposition/plot_ghi_transposition.py\ndef get_irradiance(site_location, date, tilt, surface_azimuth):\n    # Creates one day's worth of 10 min intervals\n    times = pd.date_range(date, freq='10min', periods=6*24,\n                          tz=site_location.tz)\n    # Generate clearsky data using the Ineichen model, which is the default\n    # The get_clearsky method returns a dataframe with values for GHI, DNI,\n    # and DHI\n    clearsky = site_location.get_clearsky(times)\n    # Get solar azimuth and zenith to pass to the transposition function\n    solar_position = site_location.get_solarposition(times=times)\n    # Use the get_total_irradiance function to transpose the GHI to POA\n    POA_irradiance = irradiance.get_total_irradiance(\n        surface_tilt=tilt,\n        surface_azimuth=surface_azimuth,\n        dni=clearsky['dni'],\n        ghi=clearsky['ghi'],\n        dhi=clearsky['dhi'],\n        solar_zenith=solar_position['apparent_zenith'],\n        solar_azimuth=solar_position['azimuth'])\n    # Return DataFrame with only GHI and POA\n    return pd.DataFrame({'GHI': clearsky['ghi'],\n                         'POA': POA_irradiance['poa_global']})\n", "tokens": ["docs", "examples", "irradiance", "transposition", "plot_ghi_transposition", "py", "def", "get_irradiance", "site_location", "date", "tilt", "surface_azimuth", "creates", "one", "day", "s", "worth", "of", "10", "min", "intervals", "times", "pd", "date_range", "date", "freq", "10min", "periods", "6", "24", "tz", "site_location", "tz", "generate", "clearsky", "data", "using", "the", "ineichen", "model", "which", "is", "the", "default", "the", "get_clearsky", "method", "returns", "a", "dataframe", "with", "values", "for", "ghi", "dni", "and", "dhi", "clearsky", "site_location", "get_clearsky", "times", "get", "solar", "azimuth", "and", "zenith", "to", "pass", "to", "the", "transposition", "function", "solar_position", "site_location", "get_solarposition", "times", "times", "use", "the", "get_total_irradiance", "function", "to", "transpose", "the", "ghi", "to", "poa", "poa_irradiance", "irradiance", "get_total_irradiance", "surface_tilt", "tilt", "surface_azimuth", "surface_azimuth", "dni", "clearsky", "dni", "ghi", "clearsky", "ghi", "dhi", "clearsky", "dhi", "solar_zenith", "solar_position", "apparent_zenith", "solar_azimuth", "solar_position", "azimuth", "return", "dataframe", "with", "only", "ghi", "and", "poa", "return", "pd", "dataframe", "ghi", "clearsky", "ghi", "poa", "poa_irradiance", "poa_global"], "doc_len": 125}
{"doc_id": "docs/examples/irradiance-transposition/plot_interval_transposition_error.py::transpose", "file_path": "docs/examples/irradiance-transposition/plot_interval_transposition_error.py", "class_name": null, "func_name": "transpose", "text": "文件路径: docs/examples/irradiance-transposition/plot_interval_transposition_error.py\ndef transpose(irradiance, timeshift):\n    \"\"\"\n    Transpose irradiance components to plane-of-array, incorporating\n    a timeshift in the solar position calculation.\n\n    Parameters\n    ----------\n        irradiance: DataFrame\n            Has columns dni, ghi, dhi\n        timeshift: float\n            Number of minutes to shift for solar position calculation\n    Outputs:\n        Series of POA irradiance\n    \"\"\"\n    idx = irradiance.index\n    # calculate solar position for shifted timestamps:\n    idx = idx + pd.Timedelta(timeshift, unit='min')\n    solpos = location.get_solarposition(idx)\n    # but still report the values with the original timestamps:\n    solpos.index = irradiance.index\n\n    poa_components = pvlib.irradiance.get_total_irradiance(\n        surface_tilt=20,\n        surface_azimuth=180,\n        solar_zenith=solpos['apparent_zenith'],\n        solar_azimuth=solpos['azimuth'],\n        dni=irradiance['dni'],\n        ghi=irradiance['ghi'],\n        dhi=irradiance['dhi'],\n        model='isotropic',\n    )\n    return poa_components['poa_global']\n", "tokens": ["docs", "examples", "irradiance", "transposition", "plot_interval_transposition_error", "py", "def", "transpose", "irradiance", "timeshift", "transpose", "irradiance", "components", "to", "plane", "of", "array", "incorporating", "a", "timeshift", "in", "the", "solar", "position", "calculation", "parameters", "irradiance", "dataframe", "has", "columns", "dni", "ghi", "dhi", "timeshift", "float", "number", "of", "minutes", "to", "shift", "for", "solar", "position", "calculation", "outputs", "series", "of", "poa", "irradiance", "idx", "irradiance", "index", "calculate", "solar", "position", "for", "shifted", "timestamps", "idx", "idx", "pd", "timedelta", "timeshift", "unit", "min", "solpos", "location", "get_solarposition", "idx", "but", "still", "report", "the", "values", "with", "the", "original", "timestamps", "solpos", "index", "irradiance", "index", "poa_components", "pvlib", "irradiance", "get_total_irradiance", "surface_tilt", "20", "surface_azimuth", "180", "solar_zenith", "solpos", "apparent_zenith", "solar_azimuth", "solpos", "azimuth", "dni", "irradiance", "dni", "ghi", "irradiance", "ghi", "dhi", "irradiance", "dhi", "model", "isotropic", "return", "poa_components", "poa_global"], "doc_len": 110}
{"doc_id": "docs/examples/irradiance-transposition/plot_seasonal_tilt.py::SeasonalTiltMount.get_orientation", "file_path": "docs/examples/irradiance-transposition/plot_seasonal_tilt.py", "class_name": "SeasonalTiltMount", "func_name": "get_orientation", "text": "文件路径: docs/examples/irradiance-transposition/plot_seasonal_tilt.py, 类名: SeasonalTiltMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        tilts = [self.monthly_tilts[m-1] for m in solar_zenith.index.month]\n        return pd.DataFrame({\n            'surface_tilt': tilts,\n            'surface_azimuth': self.surface_azimuth,\n        }, index=solar_zenith.index)\n", "tokens": ["docs", "examples", "irradiance", "transposition", "plot_seasonal_tilt", "py", "seasonaltiltmount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "tilts", "self", "monthly_tilts", "m", "1", "for", "m", "in", "solar_zenith", "index", "month", "return", "pd", "dataframe", "surface_tilt", "tilts", "surface_azimuth", "self", "surface_azimuth", "index", "solar_zenith", "index"], "doc_len": 34}
{"doc_id": "docs/examples/irradiance-transposition/plot_transposition_gain.py::calculate_poa", "file_path": "docs/examples/irradiance-transposition/plot_transposition_gain.py", "class_name": null, "func_name": "calculate_poa", "text": "文件路径: docs/examples/irradiance-transposition/plot_transposition_gain.py\ndef calculate_poa(tmy, solar_position, surface_tilt, surface_azimuth):\n    # Use the get_total_irradiance function to transpose the irradiance\n    # components to POA irradiance\n    poa = irradiance.get_total_irradiance(\n        surface_tilt=surface_tilt,\n        surface_azimuth=surface_azimuth,\n        dni=tmy['DNI'],\n        ghi=tmy['GHI'],\n        dhi=tmy['DHI'],\n        solar_zenith=solar_position['apparent_zenith'],\n        solar_azimuth=solar_position['azimuth'],\n        model='isotropic')\n    return poa['poa_global']  # just return the total in-plane irradiance\n", "tokens": ["docs", "examples", "irradiance", "transposition", "plot_transposition_gain", "py", "def", "calculate_poa", "tmy", "solar_position", "surface_tilt", "surface_azimuth", "use", "the", "get_total_irradiance", "function", "to", "transpose", "the", "irradiance", "components", "to", "poa", "irradiance", "poa", "irradiance", "get_total_irradiance", "surface_tilt", "surface_tilt", "surface_azimuth", "surface_azimuth", "dni", "tmy", "dni", "ghi", "tmy", "ghi", "dhi", "tmy", "dhi", "solar_zenith", "solar_position", "apparent_zenith", "solar_azimuth", "solar_position", "azimuth", "model", "isotropic", "return", "poa", "poa_global", "just", "return", "the", "total", "in", "plane", "irradiance"], "doc_len": 58}
{"doc_id": "docs/examples/iv-modeling/plot_singlediode.py::draw_arrow", "file_path": "docs/examples/iv-modeling/plot_singlediode.py", "class_name": null, "func_name": "draw_arrow", "text": "文件路径: docs/examples/iv-modeling/plot_singlediode.py\ndef draw_arrow(ax, label, x0, y0, rotation, size, direction):\n    style = direction + 'arrow'\n    bbox_props = dict(boxstyle=style, fc=(0.8, 0.9, 0.9), ec=\"b\", lw=1)\n    t = ax.text(x0, y0, label, ha=\"left\", va=\"bottom\", rotation=rotation,\n                size=size, bbox=bbox_props, zorder=-1)\n\n    bb = t.get_bbox_patch()\n    bb.set_boxstyle(style, pad=0.6)\n", "tokens": ["docs", "examples", "iv", "modeling", "plot_singlediode", "py", "def", "draw_arrow", "ax", "label", "x0", "y0", "rotation", "size", "direction", "style", "direction", "arrow", "bbox_props", "dict", "boxstyle", "style", "fc", "0", "8", "0", "9", "0", "9", "ec", "b", "lw", "1", "t", "ax", "text", "x0", "y0", "label", "ha", "left", "va", "bottom", "rotation", "rotation", "size", "size", "bbox", "bbox_props", "zorder", "1", "bb", "t", "get_bbox_patch", "bb", "set_boxstyle", "style", "pad", "0", "6"], "doc_len": 60}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::simulate_full_curve", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "simulate_full_curve", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef simulate_full_curve(parameters, Geff, Tcell, ivcurve_pnts=1000):\n    \"\"\"\n    Use De Soto and Bishop to simulate a full IV curve with both\n    forward and reverse bias regions.\n    \"\"\"\n    # adjust the reference parameters according to the operating\n    # conditions using the De Soto model:\n    sde_args = pvsystem.calcparams_desoto(\n        Geff,\n        Tcell,\n        alpha_sc=parameters['alpha_sc'],\n        a_ref=parameters['a_ref'],\n        I_L_ref=parameters['I_L_ref'],\n        I_o_ref=parameters['I_o_ref'],\n        R_sh_ref=parameters['R_sh_ref'],\n        R_s=parameters['R_s'],\n    )\n    # sde_args has values:\n    # (photocurrent, saturation_current, resistance_series,\n    # resistance_shunt, nNsVth)\n\n    # Use Bishop's method to calculate points on the IV curve with V ranging\n    # from the reverse breakdown voltage to open circuit\n    kwargs = {\n        'breakdown_factor': parameters['breakdown_factor'],\n        'breakdown_exp': parameters['breakdown_exp'],\n        'breakdown_voltage': parameters['breakdown_voltage'],\n    }\n    v_oc = singlediode.bishop88_v_from_i(\n        0.0, *sde_args, **kwargs\n    )\n    # ideally would use some intelligent log-spacing to concentrate points\n    # around the forward- and reverse-bias knees, but this is good enough:\n    vd = np.linspace(0.99*kwargs['breakdown_voltage'], v_oc, ivcurve_pnts)\n\n    ivcurve_i, ivcurve_v, _ = singlediode.bishop88(vd, *sde_args, **kwargs)\n    return pd.DataFrame({\n        'i': ivcurve_i,\n        'v': ivcurve_v,\n    })\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "simulate_full_curve", "parameters", "geff", "tcell", "ivcurve_pnts", "1000", "use", "de", "soto", "and", "bishop", "to", "simulate", "a", "full", "iv", "curve", "with", "both", "forward", "and", "reverse", "bias", "regions", "adjust", "the", "reference", "parameters", "according", "to", "the", "operating", "conditions", "using", "the", "de", "soto", "model", "sde_args", "pvsystem", "calcparams_desoto", "geff", "tcell", "alpha_sc", "parameters", "alpha_sc", "a_ref", "parameters", "a_ref", "i_l_ref", "parameters", "i_l_ref", "i_o_ref", "parameters", "i_o_ref", "r_sh_ref", "parameters", "r_sh_ref", "r_s", "parameters", "r_s", "sde_args", "has", "values", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "use", "bishop", "s", "method", "to", "calculate", "points", "on", "the", "iv", "curve", "with", "v", "ranging", "from", "the", "reverse", "breakdown", "voltage", "to", "open", "circuit", "kwargs", "breakdown_factor", "parameters", "breakdown_factor", "breakdown_exp", "parameters", "breakdown_exp", "breakdown_voltage", "parameters", "breakdown_voltage", "v_oc", "singlediode", "bishop88_v_from_i", "0", "0", "sde_args", "kwargs", "ideally", "would", "use", "some", "intelligent", "log", "spacing", "to", "concentrate", "points", "around", "the", "forward", "and", "reverse", "bias", "knees", "but", "this", "is", "good", "enough", "vd", "np", "linspace", "0", "99", "kwargs", "breakdown_voltage", "v_oc", "ivcurve_pnts", "ivcurve_i", "ivcurve_v", "_", "singlediode", "bishop88", "vd", "sde_args", "kwargs", "return", "pd", "dataframe", "i", "ivcurve_i", "v", "ivcurve_v"], "doc_len": 160}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::plot_curves", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "plot_curves", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef plot_curves(dfs, labels, title):\n    \"\"\"plot the forward- and reverse-bias portions of an IV curve\"\"\"\n    fig, axes = plt.subplots(1, 2, sharey=True, figsize=(5, 3))\n    for df, label in zip(dfs, labels):\n        df.plot('v', 'i', label=label, ax=axes[0])\n        df.plot('v', 'i', label=label, ax=axes[1])\n        axes[0].set_xlim(right=0)\n        axes[0].set_ylim([0, 25])\n        axes[1].set_xlim([0, df['v'].max()*1.5])\n    axes[0].set_ylabel('current [A]')\n    axes[0].set_xlabel('voltage [V]')\n    axes[1].set_xlabel('voltage [V]')\n    fig.suptitle(title)\n    fig.tight_layout()\n    return axes\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "plot_curves", "dfs", "labels", "title", "plot", "the", "forward", "and", "reverse", "bias", "portions", "of", "an", "iv", "curve", "fig", "axes", "plt", "subplots", "1", "2", "sharey", "true", "figsize", "5", "3", "for", "df", "label", "in", "zip", "dfs", "labels", "df", "plot", "v", "i", "label", "label", "ax", "axes", "0", "df", "plot", "v", "i", "label", "label", "ax", "axes", "1", "axes", "0", "set_xlim", "right", "0", "axes", "0", "set_ylim", "0", "25", "axes", "1", "set_xlim", "0", "df", "v", "max", "1", "5", "axes", "0", "set_ylabel", "current", "a", "axes", "0", "set_xlabel", "voltage", "v", "axes", "1", "set_xlabel", "voltage", "v", "fig", "suptitle", "title", "fig", "tight_layout", "return", "axes"], "doc_len": 98}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::interpolate", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "interpolate", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef interpolate(df, i):\n    \"\"\"convenience wrapper around scipy.interpolate.interp1d\"\"\"\n    f_interp = interp1d(np.flipud(df['i']), np.flipud(df['v']), kind='linear',\n                        fill_value='extrapolate')\n    return f_interp(i)\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "interpolate", "df", "i", "convenience", "wrapper", "around", "scipy", "interpolate", "interp1d", "f_interp", "interp1d", "np", "flipud", "df", "i", "np", "flipud", "df", "v", "kind", "linear", "fill_value", "extrapolate", "return", "f_interp", "i"], "doc_len": 32}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::combine_series", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "combine_series", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef combine_series(dfs):\n    \"\"\"\n    Combine IV curves in series by aligning currents and summing voltages.\n    The current range is based on the first curve's current range.\n    \"\"\"\n    df1 = dfs[0]\n    imin = df1['i'].min()\n    imax = df1['i'].max()\n    i = np.linspace(imin, imax, 1000)\n    v = 0\n    for df2 in dfs:\n        v_cell = interpolate(df2, i)\n        v += v_cell\n    return pd.DataFrame({'i': i, 'v': v})\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "combine_series", "dfs", "combine", "iv", "curves", "in", "series", "by", "aligning", "currents", "and", "summing", "voltages", "the", "current", "range", "is", "based", "on", "the", "first", "curve", "s", "current", "range", "df1", "dfs", "0", "imin", "df1", "i", "min", "imax", "df1", "i", "max", "i", "np", "linspace", "imin", "imax", "1000", "v", "0", "for", "df2", "in", "dfs", "v_cell", "interpolate", "df2", "i", "v", "v_cell", "return", "pd", "dataframe", "i", "i", "v", "v"], "doc_len": 67}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::simulate_module", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "simulate_module", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef simulate_module(cell_parameters, poa_direct, poa_diffuse, Tcell,\n                    shaded_fraction, cells_per_string=24, strings=3):\n    \"\"\"\n    Simulate the IV curve for a partially shaded module.\n    The shade is assumed to be coming up from the bottom of the module when in\n    portrait orientation, so it affects all substrings equally.\n    For simplicity, cell temperature is assumed to be uniform across the\n    module, regardless of variation in cell-level illumination.\n    Substrings are assumed to be \"down and back\", so the number of cells per\n    string is divided between two columns of cells.\n    \"\"\"\n    # find the number of cells per column that are in full shadow\n    nrow = cells_per_string // 2\n    nrow_full_shade = int(shaded_fraction * nrow)\n    # find the fraction of shade in the border row\n    partial_shade_fraction = 1 - (shaded_fraction * nrow - nrow_full_shade)\n\n    df_lit = simulate_full_curve(\n        cell_parameters,\n        poa_diffuse + poa_direct,\n        Tcell)\n    df_partial = simulate_full_curve(\n        cell_parameters,\n        poa_diffuse + partial_shade_fraction * poa_direct,\n        Tcell)\n    df_shaded = simulate_full_curve(\n        cell_parameters,\n        poa_diffuse,\n        Tcell)\n    # build a list of IV curves for a single column of cells (half a substring)\n    include_partial_cell = (shaded_fraction < 1)\n    half_substring_curves = (\n        [df_lit] * (nrow - nrow_full_shade - 1)\n        + ([df_partial] if include_partial_cell else [])  # noqa: W503\n        + [df_shaded] * nrow_full_shade  # noqa: W503\n    )\n    substring_curve = combine_series(half_substring_curves)\n    substring_curve['v'] *= 2  # turn half strings into whole strings\n    # bypass diode:\n    substring_curve['v'] = substring_curve['v'].clip(lower=-0.5)\n    # no need to interpolate since we're just scaling voltage directly:\n    substring_curve['v'] *= strings\n    return substring_curve\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "simulate_module", "cell_parameters", "poa_direct", "poa_diffuse", "tcell", "shaded_fraction", "cells_per_string", "24", "strings", "3", "simulate", "the", "iv", "curve", "for", "a", "partially", "shaded", "module", "the", "shade", "is", "assumed", "to", "be", "coming", "up", "from", "the", "bottom", "of", "the", "module", "when", "in", "portrait", "orientation", "so", "it", "affects", "all", "substrings", "equally", "for", "simplicity", "cell", "temperature", "is", "assumed", "to", "be", "uniform", "across", "the", "module", "regardless", "of", "variation", "in", "cell", "level", "illumination", "substrings", "are", "assumed", "to", "be", "down", "and", "back", "so", "the", "number", "of", "cells", "per", "string", "is", "divided", "between", "two", "columns", "of", "cells", "find", "the", "number", "of", "cells", "per", "column", "that", "are", "in", "full", "shadow", "nrow", "cells_per_string", "2", "nrow_full_shade", "int", "shaded_fraction", "nrow", "find", "the", "fraction", "of", "shade", "in", "the", "border", "row", "partial_shade_fraction", "1", "shaded_fraction", "nrow", "nrow_full_shade", "df_lit", "simulate_full_curve", "cell_parameters", "poa_diffuse", "poa_direct", "tcell", "df_partial", "simulate_full_curve", "cell_parameters", "poa_diffuse", "partial_shade_fraction", "poa_direct", "tcell", "df_shaded", "simulate_full_curve", "cell_parameters", "poa_diffuse", "tcell", "build", "a", "list", "of", "iv", "curves", "for", "a", "single", "column", "of", "cells", "half", "a", "substring", "include_partial_cell", "shaded_fraction", "1", "half_substring_curves", "df_lit", "nrow", "nrow_full_shade", "1", "df_partial", "if", "include_partial_cell", "else", "noqa", "w503", "df_shaded", "nrow_full_shade", "noqa", "w503", "substring_curve", "combine_series", "half_substring_curves", "substring_curve", "v", "2", "turn", "half", "strings", "into", "whole", "strings", "bypass", "diode", "substring_curve", "v", "substring_curve", "v", "clip", "lower", "0", "5", "no", "need", "to", "interpolate", "since", "we", "re", "just", "scaling", "voltage", "directly", "substring_curve", "v", "strings", "return", "substring_curve"], "doc_len": 212}
{"doc_id": "docs/examples/shading/plot_partial_module_shading_simple.py::find_pmp", "file_path": "docs/examples/shading/plot_partial_module_shading_simple.py", "class_name": null, "func_name": "find_pmp", "text": "文件路径: docs/examples/shading/plot_partial_module_shading_simple.py\ndef find_pmp(df):\n    \"\"\"simple function to find Pmp on an IV curve\"\"\"\n    return df.product(axis=1).max()\n", "tokens": ["docs", "examples", "shading", "plot_partial_module_shading_simple", "py", "def", "find_pmp", "df", "simple", "function", "to", "find", "pmp", "on", "an", "iv", "curve", "return", "df", "product", "axis", "1", "max"], "doc_len": 23}
{"doc_id": "docs/examples/solar-tracking/plot_discontinuous_tracking.py::DiscontinuousTrackerMount.get_orientation", "file_path": "docs/examples/solar-tracking/plot_discontinuous_tracking.py", "class_name": "DiscontinuousTrackerMount", "func_name": "get_orientation", "text": "文件路径: docs/examples/solar-tracking/plot_discontinuous_tracking.py, 类名: DiscontinuousTrackerMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        # Different trackers update at different rates; in this example we'll\n        # assume a relatively slow update interval of 15 minutes to make the\n        # effect more visually apparent.\n        zenith_subset = solar_zenith.resample('15min').first()\n        azimuth_subset = solar_azimuth.resample('15min').first()\n\n        tracking_data_15min = tracking.singleaxis(\n            zenith_subset, azimuth_subset,\n            self.axis_tilt, self.axis_azimuth,\n            self.max_angle, self.backtrack,\n            self.gcr, self.cross_axis_tilt\n        )\n        # propagate the 15-minute positions to 1-minute stair-stepped values:\n        tracking_data_1min = tracking_data_15min.reindex(solar_zenith.index,\n                                                         method='ffill')\n        return tracking_data_1min\n", "tokens": ["docs", "examples", "solar", "tracking", "plot_discontinuous_tracking", "py", "discontinuoustrackermount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "different", "trackers", "update", "at", "different", "rates", "in", "this", "example", "we", "ll", "assume", "a", "relatively", "slow", "update", "interval", "of", "15", "minutes", "to", "make", "the", "effect", "more", "visually", "apparent", "zenith_subset", "solar_zenith", "resample", "15min", "first", "azimuth_subset", "solar_azimuth", "resample", "15min", "first", "tracking_data_15min", "tracking", "singleaxis", "zenith_subset", "azimuth_subset", "self", "axis_tilt", "self", "axis_azimuth", "self", "max_angle", "self", "backtrack", "self", "gcr", "self", "cross_axis_tilt", "propagate", "the", "15", "minute", "positions", "to", "1", "minute", "stair", "stepped", "values", "tracking_data_1min", "tracking_data_15min", "reindex", "solar_zenith", "index", "method", "ffill", "return", "tracking_data_1min"], "doc_len": 86}
{"doc_id": "docs/examples/solar-tracking/plot_dual_axis_tracking.py::DualAxisTrackerMount.get_orientation", "file_path": "docs/examples/solar-tracking/plot_dual_axis_tracking.py", "class_name": "DualAxisTrackerMount", "func_name": "get_orientation", "text": "文件路径: docs/examples/solar-tracking/plot_dual_axis_tracking.py, 类名: DualAxisTrackerMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        # no rotation limits, no backtracking\n        return {'surface_tilt': solar_zenith, 'surface_azimuth': solar_azimuth}\n", "tokens": ["docs", "examples", "solar", "tracking", "plot_dual_axis_tracking", "py", "dualaxistrackermount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "no", "rotation", "limits", "no", "backtracking", "return", "surface_tilt", "solar_zenith", "surface_azimuth", "solar_azimuth"], "doc_len": 22}
{"doc_id": "docs/sphinx/source/conf.py::setup", "file_path": "docs/sphinx/source/conf.py", "class_name": null, "func_name": "setup", "text": "文件路径: docs/sphinx/source/conf.py\ndef setup(app):\n    # A workaround for the responsive tables always having annoying scrollbars.\n    app.add_css_file(\"no_scrollbars.css\")\n    # Override footnote callout CSS to be normal text instead of superscript\n    # In-line links to references as numbers in brackets.\n    app.add_css_file(\"reference_format.css\")\n    # Add a warning banner at the top of the page if viewing the \"latest\" docs\n    app.add_js_file(\"version-alert.js\")\n", "tokens": ["docs", "sphinx", "source", "conf", "py", "def", "setup", "app", "a", "workaround", "for", "the", "responsive", "tables", "always", "having", "annoying", "scrollbars", "app", "add_css_file", "no_scrollbars", "css", "override", "footnote", "callout", "css", "to", "be", "normal", "text", "instead", "of", "superscript", "in", "line", "links", "to", "references", "as", "numbers", "in", "brackets", "app", "add_css_file", "reference_format", "css", "add", "a", "warning", "banner", "at", "the", "top", "of", "the", "page", "if", "viewing", "the", "latest", "docs", "app", "add_js_file", "version", "alert", "js"], "doc_len": 66}
{"doc_id": "docs/sphinx/source/conf.py::get_obj_module", "file_path": "docs/sphinx/source/conf.py", "class_name": null, "func_name": "get_obj_module", "text": "文件路径: docs/sphinx/source/conf.py\ndef get_obj_module(qualname):\n    \"\"\"\n    Get a module/class/attribute and its original module by qualname.\n    Useful for looking up the original location when a function is imported\n    into an __init__.py\n\n    Examples\n    --------\n    >>> func, mod = get_obj_module(\"pvlib.iotools.read_midc\")\n    >>> mod.__name__\n    'pvlib.iotools.midc'\n    \"\"\"\n    modname = qualname\n    classname = None\n    attrname = None\n    while modname not in sys.modules:\n        attrname = classname\n        modname, classname = modname.rsplit('.', 1)\n\n    # retrieve object and find original module name\n    if classname:\n        cls = getattr(sys.modules[modname], classname)\n        modname = cls.__module__\n        obj = getattr(cls, attrname) if attrname else cls\n    else:\n        obj = None\n\n    return obj, sys.modules[modname]\n", "tokens": ["docs", "sphinx", "source", "conf", "py", "def", "get_obj_module", "qualname", "get", "a", "module", "class", "attribute", "and", "its", "original", "module", "by", "qualname", "useful", "for", "looking", "up", "the", "original", "location", "when", "a", "function", "is", "imported", "into", "an", "__init__", "py", "examples", "func", "mod", "get_obj_module", "pvlib", "iotools", "read_midc", "mod", "__name__", "pvlib", "iotools", "midc", "modname", "qualname", "classname", "none", "attrname", "none", "while", "modname", "not", "in", "sys", "modules", "attrname", "classname", "modname", "classname", "modname", "rsplit", "1", "retrieve", "object", "and", "find", "original", "module", "name", "if", "classname", "cls", "getattr", "sys", "modules", "modname", "classname", "modname", "cls", "__module__", "obj", "getattr", "cls", "attrname", "if", "attrname", "else", "cls", "else", "obj", "none", "return", "obj", "sys", "modules", "modname"], "doc_len": 100}
{"doc_id": "docs/sphinx/source/conf.py::get_linenos", "file_path": "docs/sphinx/source/conf.py", "class_name": null, "func_name": "get_linenos", "text": "文件路径: docs/sphinx/source/conf.py\ndef get_linenos(obj):\n    \"\"\"Get an object’s line numbers in its source code file\"\"\"\n    try:\n        lines, start = inspect.getsourcelines(obj)\n    except TypeError:  # obj is an attribute or None\n        return None, None\n    except OSError:  # obj listing cannot be found\n        # This happens for methods that are not explicitly defined\n        # such as the __init__ method for a dataclass\n        return None, None\n    else:\n        return start, start + len(lines) - 1\n", "tokens": ["docs", "sphinx", "source", "conf", "py", "def", "get_linenos", "obj", "get", "an", "object", "s", "line", "numbers", "in", "its", "source", "code", "file", "try", "lines", "start", "inspect", "getsourcelines", "obj", "except", "typeerror", "obj", "is", "an", "attribute", "or", "none", "return", "none", "none", "except", "oserror", "obj", "listing", "cannot", "be", "found", "this", "happens", "for", "methods", "that", "are", "not", "explicitly", "defined", "such", "as", "the", "__init__", "method", "for", "a", "dataclass", "return", "none", "none", "else", "return", "start", "start", "len", "lines", "1"], "doc_len": 70}
{"doc_id": "docs/sphinx/source/conf.py::make_github_url", "file_path": "docs/sphinx/source/conf.py", "class_name": null, "func_name": "make_github_url", "text": "文件路径: docs/sphinx/source/conf.py\ndef make_github_url(file_name):\n    \"\"\"\n    Generate the appropriate GH link for a given docs page.  This function\n    is intended for use in sphinx template files.\n\n    The target URL is built differently based on the type of page.  The pydata\n    sphinx theme has a built-in `file_name` variable that looks like\n    \"/docs/sphinx/source/api.rst\" or \"generated/pvlib.atmosphere.alt2pres.rst\"\n    \"\"\"\n\n    URL_BASE = \"https://github.com/pvlib/pvlib-python/blob/master/\"\n\n    # is it a gallery page?\n    if any(d in file_name for d in sphinx_gallery_conf['gallery_dirs']):\n        if file_name.split(\"/\")[-1] == \"index\":\n            example_file = \"README.rst\"\n        else:\n            example_file = file_name.split(\"/\")[-1].replace('.rst', '.py')\n        target_url = URL_BASE + \"docs/examples/\" + example_file\n\n    # is it an API autogen page?\n    elif \"generated\" in file_name:\n        # pagename looks like \"generated/pvlib.atmosphere.alt2pres.rst\"\n        qualname = file_name.split(\"/\")[-1].replace('.rst', '')\n        obj, module = get_obj_module(qualname)\n        path = module.__name__.replace(\".\", \"/\") + \".py\"\n        target_url = URL_BASE + path\n        # add line numbers if possible:\n        start, end = get_linenos(obj)\n        if start and end:\n            target_url += f'#L{start}-L{end}'\n\n    # Just a normal source RST page\n    else:\n        target_url = URL_BASE + \"docs/sphinx/source/\" + file_name\n\n    return target_url\n", "tokens": ["docs", "sphinx", "source", "conf", "py", "def", "make_github_url", "file_name", "generate", "the", "appropriate", "gh", "link", "for", "a", "given", "docs", "page", "this", "function", "is", "intended", "for", "use", "in", "sphinx", "template", "files", "the", "target", "url", "is", "built", "differently", "based", "on", "the", "type", "of", "page", "the", "pydata", "sphinx", "theme", "has", "a", "built", "in", "file_name", "variable", "that", "looks", "like", "docs", "sphinx", "source", "api", "rst", "or", "generated", "pvlib", "atmosphere", "alt2pres", "rst", "url_base", "https", "github", "com", "pvlib", "pvlib", "python", "blob", "master", "is", "it", "a", "gallery", "page", "if", "any", "d", "in", "file_name", "for", "d", "in", "sphinx_gallery_conf", "gallery_dirs", "if", "file_name", "split", "1", "index", "example_file", "readme", "rst", "else", "example_file", "file_name", "split", "1", "replace", "rst", "py", "target_url", "url_base", "docs", "examples", "example_file", "is", "it", "an", "api", "autogen", "page", "elif", "generated", "in", "file_name", "pagename", "looks", "like", "generated", "pvlib", "atmosphere", "alt2pres", "rst", "qualname", "file_name", "split", "1", "replace", "rst", "obj", "module", "get_obj_module", "qualname", "path", "module", "__name__", "replace", "py", "target_url", "url_base", "path", "add", "line", "numbers", "if", "possible", "start", "end", "get_linenos", "obj", "if", "start", "and", "end", "target_url", "f", "l", "start", "l", "end", "just", "a", "normal", "source", "rst", "page", "else", "target_url", "url_base", "docs", "sphinx", "source", "file_name", "return", "target_url"], "doc_len": 179}
{"doc_id": "pvlib/atmosphere.py::pres2alt", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "pres2alt", "text": "文件路径: pvlib/atmosphere.py\ndef pres2alt(pressure):\n    '''\n    Determine altitude from site pressure.\n\n    Parameters\n    ----------\n    pressure : numeric\n        Atmospheric pressure. [Pa]\n\n    Returns\n    -------\n    altitude : numeric\n        Altitude above sea level. [m]\n\n    Notes\n    ------\n    The following assumptions are made\n\n    ============================   ================\n    Parameter                      Value\n    ============================   ================\n    Base pressure                  101325 Pa\n    Temperature at zero altitude   288.15 K\n    Gravitational acceleration     9.80665 m/s^2\n    Lapse rate                     -6.5E-3 K/m\n    Gas constant for air           287.053 J/(kg K)\n    Relative Humidity              0%\n    ============================   ================\n\n    References\n    -----------\n    .. [1] \"A Quick Derivation relating altitude to air pressure\" from\n       Portland State Aerospace Society, Version 1.03, 12/22/2004.\n    '''\n\n    alt = 44331.5 - 4946.62 * pressure ** (0.190263)\n\n    return alt\n", "tokens": ["pvlib", "atmosphere", "py", "def", "pres2alt", "pressure", "determine", "altitude", "from", "site", "pressure", "parameters", "pressure", "numeric", "atmospheric", "pressure", "pa", "returns", "altitude", "numeric", "altitude", "above", "sea", "level", "m", "notes", "the", "following", "assumptions", "are", "made", "parameter", "value", "base", "pressure", "101325", "pa", "temperature", "at", "zero", "altitude", "288", "15", "k", "gravitational", "acceleration", "9", "80665", "m", "s", "2", "lapse", "rate", "6", "5e", "3", "k", "m", "gas", "constant", "for", "air", "287", "053", "j", "kg", "k", "relative", "humidity", "0", "references", "1", "a", "quick", "derivation", "relating", "altitude", "to", "air", "pressure", "from", "portland", "state", "aerospace", "society", "version", "1", "03", "12", "22", "2004", "alt", "44331", "5", "4946", "62", "pressure", "0", "190263", "return", "alt"], "doc_len": 101}
{"doc_id": "pvlib/atmosphere.py::alt2pres", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "alt2pres", "text": "文件路径: pvlib/atmosphere.py\ndef alt2pres(altitude):\n    '''\n    Determine site pressure from altitude.\n\n    Parameters\n    ----------\n    altitude : numeric\n        Altitude above sea level. [m]\n\n    Returns\n    -------\n    pressure : numeric\n        Atmospheric pressure. [Pa]\n\n    Notes\n    ------\n    The following assumptions are made\n\n    ============================   ================\n    Parameter                      Value\n    ============================   ================\n    Base pressure                  101325 Pa\n    Temperature at zero altitude   288.15 K\n    Gravitational acceleration     9.80665 m/s^2\n    Lapse rate                     -6.5E-3 K/m\n    Gas constant for air           287.053 J/(kg K)\n    Relative Humidity              0%\n    ============================   ================\n\n    References\n    -----------\n    .. [1] \"A Quick Derivation relating altitude to air pressure\" from\n       Portland State Aerospace Society, Version 1.03, 12/22/2004.\n    '''\n\n    press = 100 * ((44331.514 - altitude) / 11880.516) ** (1 / 0.1902632)\n\n    return press\n", "tokens": ["pvlib", "atmosphere", "py", "def", "alt2pres", "altitude", "determine", "site", "pressure", "from", "altitude", "parameters", "altitude", "numeric", "altitude", "above", "sea", "level", "m", "returns", "pressure", "numeric", "atmospheric", "pressure", "pa", "notes", "the", "following", "assumptions", "are", "made", "parameter", "value", "base", "pressure", "101325", "pa", "temperature", "at", "zero", "altitude", "288", "15", "k", "gravitational", "acceleration", "9", "80665", "m", "s", "2", "lapse", "rate", "6", "5e", "3", "k", "m", "gas", "constant", "for", "air", "287", "053", "j", "kg", "k", "relative", "humidity", "0", "references", "1", "a", "quick", "derivation", "relating", "altitude", "to", "air", "pressure", "from", "portland", "state", "aerospace", "society", "version", "1", "03", "12", "22", "2004", "press", "100", "44331", "514", "altitude", "11880", "516", "1", "0", "1902632", "return", "press"], "doc_len": 103}
{"doc_id": "pvlib/atmosphere.py::get_absolute_airmass", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "get_absolute_airmass", "text": "文件路径: pvlib/atmosphere.py\ndef get_absolute_airmass(airmass_relative, pressure=101325.):\n    r'''\n    Determine absolute (pressure-adjusted) airmass from relative\n    airmass and pressure.\n\n    The calculation for absolute airmass (:math:`AM_a`) is\n\n    .. math::\n        AM_a = AM_r \\frac{P}{101325}\n\n    where :math:`AM_r` is relative air mass at sea level and :math:`P` is\n    atmospheric pressure.\n\n    Parameters\n    ----------\n    airmass_relative : numeric\n        The airmass at sea level. [unitless]\n\n    pressure : numeric, default 101325\n        Atmospheric pressure. [Pa]\n\n    Returns\n    -------\n    airmass_absolute : numeric\n        Absolute (pressure-adjusted) airmass\n\n    References\n    ----------\n    .. [1] C. Gueymard, \"Critical analysis and performance assessment of\n       clear sky solar irradiance models using theoretical and measured\n       data,\" Solar Energy, vol. 51, pp. 121-138, 1993.\n    '''\n\n    airmass_absolute = airmass_relative * pressure / 101325.\n\n    return airmass_absolute\n", "tokens": ["pvlib", "atmosphere", "py", "def", "get_absolute_airmass", "airmass_relative", "pressure", "101325", "r", "determine", "absolute", "pressure", "adjusted", "airmass", "from", "relative", "airmass", "and", "pressure", "the", "calculation", "for", "absolute", "airmass", "math", "am_a", "is", "math", "am_a", "am_r", "frac", "p", "101325", "where", "math", "am_r", "is", "relative", "air", "mass", "at", "sea", "level", "and", "math", "p", "is", "atmospheric", "pressure", "parameters", "airmass_relative", "numeric", "the", "airmass", "at", "sea", "level", "unitless", "pressure", "numeric", "default", "101325", "atmospheric", "pressure", "pa", "returns", "airmass_absolute", "numeric", "absolute", "pressure", "adjusted", "airmass", "references", "1", "c", "gueymard", "critical", "analysis", "and", "performance", "assessment", "of", "clear", "sky", "solar", "irradiance", "models", "using", "theoretical", "and", "measured", "data", "solar", "energy", "vol", "51", "pp", "121", "138", "1993", "airmass_absolute", "airmass_relative", "pressure", "101325", "return", "airmass_absolute"], "doc_len": 106}
{"doc_id": "pvlib/atmosphere.py::get_relative_airmass", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "get_relative_airmass", "text": "文件路径: pvlib/atmosphere.py\ndef get_relative_airmass(zenith, model='kastenyoung1989'):\n    '''\n    Calculate relative (not pressure-adjusted) airmass at sea level.\n\n    Parameter ``model`` allows selection of different airmass models.\n\n    Parameters\n    ----------\n    zenith : numeric\n        Zenith angle of the sun. [degrees]\n\n    model : string, default 'kastenyoung1989'\n        Available models include the following:\n\n        * 'simple' - secant(apparent zenith angle) -\n          Note that this gives -Inf at zenith=90\n        * 'kasten1966' - See reference [1] -\n          requires apparent sun zenith\n        * 'youngirvine1967' - See reference [2] -\n          requires true sun zenith\n        * 'kastenyoung1989' (default) - See reference [3] -\n          requires apparent sun zenith\n        * 'gueymard1993' - See reference [4] -\n          requires apparent sun zenith\n        * 'young1994' - See reference [5] -\n          requries true sun zenith\n        * 'pickering2002' - See reference [6] -\n          requires apparent sun zenith\n\n    Returns\n    -------\n    airmass_relative : numeric\n        Relative airmass at sea level. Returns NaN values for any\n        zenith angle greater than 90 degrees. [unitless]\n\n    Notes\n    -----\n    Some models use apparent (refraction-adjusted) zenith angle while\n    other models use true (not refraction-adjusted) zenith angle. Apparent\n    zenith angles should be calculated at sea level.\n\n    References\n    ----------\n    .. [1] Fritz Kasten. \"A New Table and Approximation Formula for the\n       Relative Optical Air Mass\". Technical Report 136, Hanover, N.H.:\n       U.S. Army Material Command, CRREL.\n\n    .. [2] A. T. Young and W. M. Irvine, \"Multicolor Photoelectric\n       Photometry of the Brighter Planets,\" The Astronomical Journal, vol.\n       72, pp. 945-950, 1967.\n\n    .. [3] Fritz Kasten and Andrew Young. \"Revised optical air mass tables\n       and approximation formula\". Applied Optics 28:4735-4738\n\n    .. [4] C. Gueymard, \"Critical analysis and performance assessment of\n       clear sky solar irradiance models using theoretical and measured\n       data,\" Solar Energy, vol. 51, pp. 121-138, 1993.\n\n    .. [5] A. T. Young, \"AIR-MASS AND REFRACTION,\" Applied Optics, vol. 33,\n       pp. 1108-1110, Feb 1994.\n\n    .. [6] Keith A. Pickering. \"The Ancient Star Catalog\". DIO 12:1, 20,\n\n    .. [7] Matthew J. Reno, Clifford W. Hansen and Joshua S. Stein, \"Global\n       Horizontal Irradiance Clear Sky Models: Implementation and Analysis\"\n       Sandia Report, (2012).\n    '''\n\n    # set zenith values greater than 90 to nans\n    z = np.where(zenith > 90, np.nan, zenith)\n    zenith_rad = np.radians(z)\n\n    model = model.lower()\n\n    if 'kastenyoung1989' == model:\n        am = (1.0 / (np.cos(zenith_rad) +\n              0.50572*((6.07995 + (90 - z)) ** - 1.6364)))\n    elif 'kasten1966' == model:\n        am = 1.0 / (np.cos(zenith_rad) + 0.15*((93.885 - z) ** - 1.253))\n    elif 'simple' == model:\n        am = 1.0 / np.cos(zenith_rad)\n    elif 'pickering2002' == model:\n        am = (1.0 / (np.sin(np.radians(90 - z +\n              244.0 / (165 + 47.0 * (90 - z) ** 1.1)))))\n    elif 'youngirvine1967' == model:\n        sec_zen = 1.0 / np.cos(zenith_rad)\n        am = sec_zen * (1 - 0.0012 * (sec_zen * sec_zen - 1))\n    elif 'young1994' == model:\n        am = ((1.002432*((np.cos(zenith_rad)) ** 2) +\n              0.148386*(np.cos(zenith_rad)) + 0.0096467) /\n              (np.cos(zenith_rad) ** 3 +\n              0.149864*(np.cos(zenith_rad) ** 2) +\n              0.0102963*(np.cos(zenith_rad)) + 0.000303978))\n    elif 'gueymard1993' == model:\n        am = (1.0 / (np.cos(zenith_rad) +\n              0.00176759*(z)*((94.37515 - z) ** - 1.21563)))\n    else:\n        raise ValueError('%s is not a valid model for relativeairmass', model)\n\n    if isinstance(zenith, pd.Series):\n        am = pd.Series(am, index=zenith.index)\n\n    return am\n", "tokens": ["pvlib", "atmosphere", "py", "def", "get_relative_airmass", "zenith", "model", "kastenyoung1989", "calculate", "relative", "not", "pressure", "adjusted", "airmass", "at", "sea", "level", "parameter", "model", "allows", "selection", "of", "different", "airmass", "models", "parameters", "zenith", "numeric", "zenith", "angle", "of", "the", "sun", "degrees", "model", "string", "default", "kastenyoung1989", "available", "models", "include", "the", "following", "simple", "secant", "apparent", "zenith", "angle", "note", "that", "this", "gives", "inf", "at", "zenith", "90", "kasten1966", "see", "reference", "1", "requires", "apparent", "sun", "zenith", "youngirvine1967", "see", "reference", "2", "requires", "true", "sun", "zenith", "kastenyoung1989", "default", "see", "reference", "3", "requires", "apparent", "sun", "zenith", "gueymard1993", "see", "reference", "4", "requires", "apparent", "sun", "zenith", "young1994", "see", "reference", "5", "requries", "true", "sun", "zenith", "pickering2002", "see", "reference", "6", "requires", "apparent", "sun", "zenith", "returns", "airmass_relative", "numeric", "relative", "airmass", "at", "sea", "level", "returns", "nan", "values", "for", "any", "zenith", "angle", "greater", "than", "90", "degrees", "unitless", "notes", "some", "models", "use", "apparent", "refraction", "adjusted", "zenith", "angle", "while", "other", "models", "use", "true", "not", "refraction", "adjusted", "zenith", "angle", "apparent", "zenith", "angles", "should", "be", "calculated", "at", "sea", "level", "references", "1", "fritz", "kasten", "a", "new", "table", "and", "approximation", "formula", "for", "the", "relative", "optical", "air", "mass", "technical", "report", "136", "hanover", "n", "h", "u", "s", "army", "material", "command", "crrel", "2", "a", "t", "young", "and", "w", "m", "irvine", "multicolor", "photoelectric", "photometry", "of", "the", "brighter", "planets", "the", "astronomical", "journal", "vol", "72", "pp", "945", "950", "1967", "3", "fritz", "kasten", "and", "andrew", "young", "revised", "optical", "air", "mass", "tables", "and", "approximation", "formula", "applied", "optics", "28", "4735", "4738", "4", "c", "gueymard", "critical", "analysis", "and", "performance", "assessment", "of", "clear", "sky", "solar", "irradiance", "models", "using", "theoretical", "and", "measured", "data", "solar", "energy", "vol", "51", "pp", "121", "138", "1993", "5", "a", "t", "young", "air", "mass", "and", "refraction", "applied", "optics", "vol", "33", "pp", "1108", "1110", "feb", "1994", "6", "keith", "a", "pickering", "the", "ancient", "star", "catalog", "dio", "12", "1", "20", "7", "matthew", "j", "reno", "clifford", "w", "hansen", "and", "joshua", "s", "stein", "global", "horizontal", "irradiance", "clear", "sky", "models", "implementation", "and", "analysis", "sandia", "report", "2012", "set", "zenith", "values", "greater", "than", "90", "to", "nans", "z", "np", "where", "zenith", "90", "np", "nan", "zenith", "zenith_rad", "np", "radians", "z", "model", "model", "lower", "if", "kastenyoung1989", "model", "am", "1", "0", "np", "cos", "zenith_rad", "0", "50572", "6", "07995", "90", "z", "1", "6364", "elif", "kasten1966", "model", "am", "1", "0", "np", "cos", "zenith_rad", "0", "15", "93", "885", "z", "1", "253", "elif", "simple", "model", "am", "1", "0", "np", "cos", "zenith_rad", "elif", "pickering2002", "model", "am", "1", "0", "np", "sin", "np", "radians", "90", "z", "244", "0", "165", "47", "0", "90", "z", "1", "1", "elif", "youngirvine1967", "model", "sec_zen", "1", "0", "np", "cos", "zenith_rad", "am", "sec_zen", "1", "0", "0012", "sec_zen", "sec_zen", "1", "elif", "young1994", "model", "am", "1", "002432", "np", "cos", "zenith_rad", "2", "0", "148386", "np", "cos", "zenith_rad", "0", "0096467", "np", "cos", "zenith_rad", "3", "0", "149864", "np", "cos", "zenith_rad", "2", "0", "0102963", "np", "cos", "zenith_rad", "0", "000303978", "elif", "gueymard1993", "model", "am", "1", "0", "np", "cos", "zenith_rad", "0", "00176759", "z", "94", "37515", "z", "1", "21563", "else", "raise", "valueerror", "s", "is", "not", "a", "valid", "model", "for", "relativeairmass", "model", "if", "isinstance", "zenith", "pd", "series", "am", "pd", "series", "am", "index", "zenith", "index", "return", "am"], "doc_len": 483}
{"doc_id": "pvlib/atmosphere.py::gueymard94_pw", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "gueymard94_pw", "text": "文件路径: pvlib/atmosphere.py\ndef gueymard94_pw(temp_air, relative_humidity):\n    r\"\"\"\n    Calculates precipitable water (cm) from ambient air temperature (C)\n    and relatively humidity (%) using an empirical model. The\n    accuracy of this method is approximately 20% for moderate PW (1-3\n    cm) and less accurate otherwise.\n\n    The model was developed by expanding Eq. 1 in [2]_:\n\n    .. math::\n\n           Pw = 0.1 H_v \\rho_v\n\n    using Eq. 2 in [2]_\n\n    .. math::\n\n           \\rho_v = 216.7 R_H e_s /T\n\n    :math:`Pw` is the precipitable water (cm), :math:`H_v` is the apparent\n    water vapor scale height (km) and :math:`\\rho_v` is the surface water\n    vapor density (g/m^3). . The expression for :math:`H_v` is Eq. 4 in [2]_:\n\n    .. math::\n\n           H_v = 0.4976 + 1.5265 \\frac{T}{273.15}\n               + \\exp \\left(13.6897 \\frac{T}{273.15}\n               - 14.9188 \\left( \\frac{T}{273.15} \\right)^3 \\right)\n\n    In the expression for :math:`\\rho_v`, :math:`e_s` is the saturation water\n    vapor pressure (millibar). The expression for :math:`e_s` is Eq. 1 in [3]_\n\n    .. math::\n\n          e_s = \\exp \\left(22.330 - 49.140 \\frac{100}{T} -\n              10.922 \\left(\\frac{100}{T}\\right)^2 -\n              0.39015 \\frac{T}{100} \\right)\n\n    Parameters\n    ----------\n    temp_air : numeric\n        ambient air temperature :math:`T` at the surface. [C]\n    relative_humidity : numeric\n        relative humidity :math:`R_H` at the surface. [%]\n\n    Returns\n    -------\n    pw : numeric\n        precipitable water. [cm]\n\n    References\n    ----------\n    .. [1] W. M. Keogh and A. W. Blakers, Accurate Measurement, Using Natural\n       Sunlight, of Silicon Solar Cells, Prog. in Photovoltaics: Res.\n       and Appl. 2004, vol 12, pp. 1-19 (:doi:`10.1002/pip.517`)\n\n    .. [2] C. Gueymard, Analysis of Monthly Average Atmospheric Precipitable\n       Water and Turbidity in Canada and Northern United States,\n       Solar Energy vol 53(1), pp. 57-71, 1994.\n\n    .. [3] C. Gueymard, Assessment of the Accuracy and Computing Speed of\n       simplified saturation vapor equations using a new reference\n       dataset, J. of Applied Meteorology 1993, vol. 32(7), pp.\n       1294-1300.\n    \"\"\"\n\n    T = temp_air + 273.15  # Convert to Kelvin                  # noqa: N806\n    RH = relative_humidity                                      # noqa: N806\n\n    theta = T / 273.15\n\n    # Eq. 1 from Keogh and Blakers\n    pw = (\n        0.1 *\n        (0.4976 + 1.5265*theta + np.exp(13.6897*theta - 14.9188*(theta)**3)) *\n        (216.7*RH/(100*T)*np.exp(22.330 - 49.140*(100/T) -\n         10.922*(100/T)**2 - 0.39015*T/100)))\n\n    pw = np.maximum(pw, 0.1)\n\n    return pw\n", "tokens": ["pvlib", "atmosphere", "py", "def", "gueymard94_pw", "temp_air", "relative_humidity", "r", "calculates", "precipitable", "water", "cm", "from", "ambient", "air", "temperature", "c", "and", "relatively", "humidity", "using", "an", "empirical", "model", "the", "accuracy", "of", "this", "method", "is", "approximately", "20", "for", "moderate", "pw", "1", "3", "cm", "and", "less", "accurate", "otherwise", "the", "model", "was", "developed", "by", "expanding", "eq", "1", "in", "2", "_", "math", "pw", "0", "1", "h_v", "rho_v", "using", "eq", "2", "in", "2", "_", "math", "rho_v", "216", "7", "r_h", "e_s", "t", "math", "pw", "is", "the", "precipitable", "water", "cm", "math", "h_v", "is", "the", "apparent", "water", "vapor", "scale", "height", "km", "and", "math", "rho_v", "is", "the", "surface", "water", "vapor", "density", "g", "m", "3", "the", "expression", "for", "math", "h_v", "is", "eq", "4", "in", "2", "_", "math", "h_v", "0", "4976", "1", "5265", "frac", "t", "273", "15", "exp", "left", "13", "6897", "frac", "t", "273", "15", "14", "9188", "left", "frac", "t", "273", "15", "right", "3", "right", "in", "the", "expression", "for", "math", "rho_v", "math", "e_s", "is", "the", "saturation", "water", "vapor", "pressure", "millibar", "the", "expression", "for", "math", "e_s", "is", "eq", "1", "in", "3", "_", "math", "e_s", "exp", "left", "22", "330", "49", "140", "frac", "100", "t", "10", "922", "left", "frac", "100", "t", "right", "2", "0", "39015", "frac", "t", "100", "right", "parameters", "temp_air", "numeric", "ambient", "air", "temperature", "math", "t", "at", "the", "surface", "c", "relative_humidity", "numeric", "relative", "humidity", "math", "r_h", "at", "the", "surface", "returns", "pw", "numeric", "precipitable", "water", "cm", "references", "1", "w", "m", "keogh", "and", "a", "w", "blakers", "accurate", "measurement", "using", "natural", "sunlight", "of", "silicon", "solar", "cells", "prog", "in", "photovoltaics", "res", "and", "appl", "2004", "vol", "12", "pp", "1", "19", "doi", "10", "1002", "pip", "517", "2", "c", "gueymard", "analysis", "of", "monthly", "average", "atmospheric", "precipitable", "water", "and", "turbidity", "in", "canada", "and", "northern", "united", "states", "solar", "energy", "vol", "53", "1", "pp", "57", "71", "1994", "3", "c", "gueymard", "assessment", "of", "the", "accuracy", "and", "computing", "speed", "of", "simplified", "saturation", "vapor", "equations", "using", "a", "new", "reference", "dataset", "j", "of", "applied", "meteorology", "1993", "vol", "32", "7", "pp", "1294", "1300", "t", "temp_air", "273", "15", "convert", "to", "kelvin", "noqa", "n806", "rh", "relative_humidity", "noqa", "n806", "theta", "t", "273", "15", "eq", "1", "from", "keogh", "and", "blakers", "pw", "0", "1", "0", "4976", "1", "5265", "theta", "np", "exp", "13", "6897", "theta", "14", "9188", "theta", "3", "216", "7", "rh", "100", "t", "np", "exp", "22", "330", "49", "140", "100", "t", "10", "922", "100", "t", "2", "0", "39015", "t", "100", "pw", "np", "maximum", "pw", "0", "1", "return", "pw"], "doc_len": 381}
{"doc_id": "pvlib/atmosphere.py::first_solar_spectral_correction", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "first_solar_spectral_correction", "text": "文件路径: pvlib/atmosphere.py\ndef first_solar_spectral_correction(pw, airmass_absolute,\n                                    module_type=None, coefficients=None,\n                                    min_pw=0.1, max_pw=8):\n    r\"\"\"\n    Spectral mismatch modifier based on precipitable water and absolute\n    (pressure-adjusted) airmass.\n\n    Estimates a spectral mismatch modifier :math:`M` representing the effect on\n    module short circuit current of variation in the spectral\n    irradiance. :math:`M`  is estimated from absolute (pressure currected) air\n    mass, :math:`AM_a`, and precipitable water, :math:`Pw`, using the following\n    function:\n\n    .. math::\n\n        M = c_1 + c_2 AM_a  + c_3 Pw  + c_4 AM_a^{0.5}\n            + c_5 Pw^{0.5} + c_6 \\frac{AM_a} {Pw^{0.5}}\n\n    Default coefficients are determined for several cell types with\n    known quantum efficiency curves, by using the Simple Model of the\n    Atmospheric Radiative Transfer of Sunshine (SMARTS) [1]_. Using\n    SMARTS, spectrums are simulated with all combinations of AMa and\n    Pw where:\n\n       * :math:`0.5 \\textrm{cm} <= Pw <= 5 \\textrm{cm}`\n       * :math:`1.0 <= AM_a <= 5.0`\n       * Spectral range is limited to that of CMP11 (280 nm to 2800 nm)\n       * spectrum simulated on a plane normal to the sun\n       * All other parameters fixed at G173 standard\n\n    From these simulated spectra, M is calculated using the known\n    quantum efficiency curves. Multiple linear regression is then\n    applied to fit Eq. 1 to determine the coefficients for each module.\n\n    Based on the PVLIB Matlab function ``pvl_FSspeccorr`` by Mitchell\n    Lee and Alex Panchula of First Solar, 2016 [2]_.\n\n    Parameters\n    ----------\n    pw : array-like\n        atmospheric precipitable water. [cm]\n\n    airmass_absolute : array-like\n        absolute (pressure-adjusted) airmass. [unitless]\n\n    min_pw : float, default 0.1\n        minimum atmospheric precipitable water. Any pw value lower than min_pw\n        is set to min_pw to avoid model divergence. [cm]\n\n    max_pw : float, default 8\n        maximum atmospheric precipitable water. Any pw value higher than max_pw\n        is set to NaN to avoid model divergence. [cm]\n\n    module_type : None or string, default None\n        a string specifying a cell type. Values of 'cdte', 'monosi', 'xsi',\n        'multisi', and 'polysi' (can be lower or upper case). If provided,\n        module_type selects default coefficients for the following modules:\n\n            * 'cdte' - First Solar Series 4-2 CdTe module.\n            * 'monosi', 'xsi' - First Solar TetraSun module.\n            * 'multisi', 'polysi' - anonymous multi-crystalline silicon module.\n            * 'cigs' - anonymous copper indium gallium selenide module.\n            * 'asi' - anonymous amorphous silicon module.\n\n        The module used to calculate the spectral correction\n        coefficients corresponds to the Multi-crystalline silicon\n        Manufacturer 2 Model C from [3]_. The spectral response (SR) of CIGS\n        and a-Si modules used to derive coefficients can be found in [4]_\n\n    coefficients : None or array-like, default None\n        Allows for entry of user-defined spectral correction\n        coefficients. Coefficients must be of length 6. Derivation of\n        coefficients requires use of SMARTS and PV module quantum\n        efficiency curve. Useful for modeling PV module types which are\n        not included as defaults, or to fine tune the spectral\n        correction to a particular PV module. Note that the parameters for\n        modules with very similar quantum efficiency should be similar,\n        in most cases limiting the need for module specific coefficients.\n\n    Returns\n    -------\n    modifier: array-like\n        spectral mismatch factor (unitless) which is can be multiplied\n        with broadband irradiance reaching a module's cells to estimate\n        effective irradiance, i.e., the irradiance that is converted to\n        electrical current.\n\n    References\n    ----------\n    .. [1] Gueymard, Christian. SMARTS2: a simple model of the atmospheric\n       radiative transfer of sunshine: algorithms and performance\n       assessment. Cocoa, FL: Florida Solar Energy Center, 1995.\n    .. [2] Lee, Mitchell, and Panchula, Alex. \"Spectral Correction for\n       Photovoltaic Module Performance Based on Air Mass and Precipitable\n       Water.\" IEEE Photovoltaic Specialists Conference, Portland, 2016\n    .. [3] Marion, William F., et al. User's Manual for Data for Validating\n       Models for PV Module Performance. National Renewable Energy\n       Laboratory, 2014. http://www.nrel.gov/docs/fy14osti/61610.pdf\n    .. [4] Schweiger, M. and Hermann, W, Influence of Spectral Effects\n       on Energy Yield of Different PV Modules: Comparison of Pwat and\n       MMF Approach, TUV Rheinland Energy GmbH report 21237296.003,\n       January 2017\n    \"\"\"\n\n    # --- Screen Input Data ---\n\n    # *** Pw ***\n    # Replace Pw Values below 0.1 cm with 0.1 cm to prevent model from\n    # diverging\"\n    pw = np.atleast_1d(pw)\n    pw = pw.astype('float64')\n    if np.min(pw) < min_pw:\n        pw = np.maximum(pw, min_pw)\n        warn(f'Exceptionally low pw values replaced with {min_pw} cm to '\n             'prevent model divergence')\n\n    # Warn user about Pw data that is exceptionally high\n    if np.max(pw) > max_pw:\n        pw[pw > max_pw] = np.nan\n        warn('Exceptionally high pw values replaced by np.nan: '\n             'check input data.')\n\n    # *** AMa ***\n    # Replace Extremely High AM with AM 10 to prevent model divergence\n    # AM > 10 will only occur very close to sunset\n    if np.max(airmass_absolute) > 10:\n        airmass_absolute = np.minimum(airmass_absolute, 10)\n\n    # Warn user about AMa data that is exceptionally low\n    if np.min(airmass_absolute) < 0.58:\n        warn('Exceptionally low air mass: ' +\n             'model not intended for extra-terrestrial use')\n        # pvl_absoluteairmass(1,pvl_alt2pres(4340)) = 0.58 Elevation of\n        # Mina Pirquita, Argentian = 4340 m. Highest elevation city with\n        # population over 50,000.\n\n    _coefficients = {}\n    _coefficients['cdte'] = (\n        0.86273, -0.038948, -0.012506, 0.098871, 0.084658, -0.0042948)\n    _coefficients['monosi'] = (\n        0.85914, -0.020880, -0.0058853, 0.12029, 0.026814, -0.0017810)\n    _coefficients['xsi'] = _coefficients['monosi']\n    _coefficients['polysi'] = (\n        0.84090, -0.027539, -0.0079224, 0.13570, 0.038024, -0.0021218)\n    _coefficients['multisi'] = _coefficients['polysi']\n    _coefficients['cigs'] = (\n        0.85252, -0.022314, -0.0047216, 0.13666, 0.013342, -0.0008945)\n    _coefficients['asi'] = (\n        1.12094, -0.047620, -0.0083627, -0.10443, 0.098382, -0.0033818)\n\n    if module_type is not None and coefficients is None:\n        coefficients = _coefficients[module_type.lower()]\n    elif module_type is None and coefficients is not None:\n        pass\n    elif module_type is None and coefficients is None:\n        raise TypeError('No valid input provided, both module_type and ' +\n                        'coefficients are None')\n    else:\n        raise TypeError('Cannot resolve input, must supply only one of ' +\n                        'module_type and coefficients')\n\n    # Evaluate Spectral Shift\n    coeff = coefficients\n    ama = airmass_absolute\n    modifier = (\n        coeff[0] + coeff[1]*ama + coeff[2]*pw + coeff[3]*np.sqrt(ama) +\n        coeff[4]*np.sqrt(pw) + coeff[5]*ama/np.sqrt(pw))\n\n    return modifier\n", "tokens": ["pvlib", "atmosphere", "py", "def", "first_solar_spectral_correction", "pw", "airmass_absolute", "module_type", "none", "coefficients", "none", "min_pw", "0", "1", "max_pw", "8", "r", "spectral", "mismatch", "modifier", "based", "on", "precipitable", "water", "and", "absolute", "pressure", "adjusted", "airmass", "estimates", "a", "spectral", "mismatch", "modifier", "math", "m", "representing", "the", "effect", "on", "module", "short", "circuit", "current", "of", "variation", "in", "the", "spectral", "irradiance", "math", "m", "is", "estimated", "from", "absolute", "pressure", "currected", "air", "mass", "math", "am_a", "and", "precipitable", "water", "math", "pw", "using", "the", "following", "function", "math", "m", "c_1", "c_2", "am_a", "c_3", "pw", "c_4", "am_a", "0", "5", "c_5", "pw", "0", "5", "c_6", "frac", "am_a", "pw", "0", "5", "default", "coefficients", "are", "determined", "for", "several", "cell", "types", "with", "known", "quantum", "efficiency", "curves", "by", "using", "the", "simple", "model", "of", "the", "atmospheric", "radiative", "transfer", "of", "sunshine", "smarts", "1", "_", "using", "smarts", "spectrums", "are", "simulated", "with", "all", "combinations", "of", "ama", "and", "pw", "where", "math", "0", "5", "textrm", "cm", "pw", "5", "textrm", "cm", "math", "1", "0", "am_a", "5", "0", "spectral", "range", "is", "limited", "to", "that", "of", "cmp11", "280", "nm", "to", "2800", "nm", "spectrum", "simulated", "on", "a", "plane", "normal", "to", "the", "sun", "all", "other", "parameters", "fixed", "at", "g173", "standard", "from", "these", "simulated", "spectra", "m", "is", "calculated", "using", "the", "known", "quantum", "efficiency", "curves", "multiple", "linear", "regression", "is", "then", "applied", "to", "fit", "eq", "1", "to", "determine", "the", "coefficients", "for", "each", "module", "based", "on", "the", "pvlib", "matlab", "function", "pvl_fsspeccorr", "by", "mitchell", "lee", "and", "alex", "panchula", "of", "first", "solar", "2016", "2", "_", "parameters", "pw", "array", "like", "atmospheric", "precipitable", "water", "cm", "airmass_absolute", "array", "like", "absolute", "pressure", "adjusted", "airmass", "unitless", "min_pw", "float", "default", "0", "1", "minimum", "atmospheric", "precipitable", "water", "any", "pw", "value", "lower", "than", "min_pw", "is", "set", "to", "min_pw", "to", "avoid", "model", "divergence", "cm", "max_pw", "float", "default", "8", "maximum", "atmospheric", "precipitable", "water", "any", "pw", "value", "higher", "than", "max_pw", "is", "set", "to", "nan", "to", "avoid", "model", "divergence", "cm", "module_type", "none", "or", "string", "default", "none", "a", "string", "specifying", "a", "cell", "type", "values", "of", "cdte", "monosi", "xsi", "multisi", "and", "polysi", "can", "be", "lower", "or", "upper", "case", "if", "provided", "module_type", "selects", "default", "coefficients", "for", "the", "following", "modules", "cdte", "first", "solar", "series", "4", "2", "cdte", "module", "monosi", "xsi", "first", "solar", "tetrasun", "module", "multisi", "polysi", "anonymous", "multi", "crystalline", "silicon", "module", "cigs", "anonymous", "copper", "indium", "gallium", "selenide", "module", "asi", "anonymous", "amorphous", "silicon", "module", "the", "module", "used", "to", "calculate", "the", "spectral", "correction", "coefficients", "corresponds", "to", "the", "multi", "crystalline", "silicon", "manufacturer", "2", "model", "c", "from", "3", "_", "the", "spectral", "response", "sr", "of", "cigs", "and", "a", "si", "modules", "used", "to", "derive", "coefficients", "can", "be", "found", "in", "4", "_", "coefficients", "none", "or", "array", "like", "default", "none", "allows", "for", "entry", "of", "user", "defined", "spectral", "correction", "coefficients", "coefficients", "must", "be", "of", "length", "6", "derivation", "of", "coefficients", "requires", "use", "of", "smarts", "and", "pv", "module", "quantum", "efficiency", "curve", "useful", "for", "modeling", "pv", "module", "types", "which", "are", "not", "included", "as", "defaults", "or", "to", "fine", "tune", "the", "spectral", "correction", "to", "a", "particular", "pv", "module", "note", "that", "the", "parameters", "for", "modules", "with", "very", "similar", "quantum", "efficiency", "should", "be", "similar", "in", "most", "cases", "limiting", "the", "need", "for", "module", "specific", "coefficients", "returns", "modifier", "array", "like", "spectral", "mismatch", "factor", "unitless", "which", "is", "can", "be", "multiplied", "with", "broadband", "irradiance", "reaching", "a", "module", "s", "cells", "to", "estimate", "effective", "irradiance", "i", "e", "the", "irradiance", "that", "is", "converted", "to", "electrical", "current", "references", "1", "gueymard", "christian", "smarts2", "a", "simple", "model", "of", "the", "atmospheric", "radiative", "transfer", "of", "sunshine", "algorithms", "and", "performance", "assessment", "cocoa", "fl", "florida", "solar", "energy", "center", "1995", "2", "lee", "mitchell", "and", "panchula", "alex", "spectral", "correction", "for", "photovoltaic", "module", "performance", "based", "on", "air", "mass", "and", "precipitable", "water", "ieee", "photovoltaic", "specialists", "conference", "portland", "2016", "3", "marion", "william", "f", "et", "al", "user", "s", "manual", "for", "data", "for", "validating", "models", "for", "pv", "module", "performance", "national", "renewable", "energy", "laboratory", "2014", "http", "www", "nrel", "gov", "docs", "fy14osti", "61610", "pdf", "4", "schweiger", "m", "and", "hermann", "w", "influence", "of", "spectral", "effects", "on", "energy", "yield", "of", "different", "pv", "modules", "comparison", "of", "pwat", "and", "mmf", "approach", "tuv", "rheinland", "energy", "gmbh", "report", "21237296", "003", "january", "2017", "screen", "input", "data", "pw", "replace", "pw", "values", "below", "0", "1", "cm", "with", "0", "1", "cm", "to", "prevent", "model", "from", "diverging", "pw", "np", "atleast_1d", "pw", "pw", "pw", "astype", "float64", "if", "np", "min", "pw", "min_pw", "pw", "np", "maximum", "pw", "min_pw", "warn", "f", "exceptionally", "low", "pw", "values", "replaced", "with", "min_pw", "cm", "to", "prevent", "model", "divergence", "warn", "user", "about", "pw", "data", "that", "is", "exceptionally", "high", "if", "np", "max", "pw", "max_pw", "pw", "pw", "max_pw", "np", "nan", "warn", "exceptionally", "high", "pw", "values", "replaced", "by", "np", "nan", "check", "input", "data", "ama", "replace", "extremely", "high", "am", "with", "am", "10", "to", "prevent", "model", "divergence", "am", "10", "will", "only", "occur", "very", "close", "to", "sunset", "if", "np", "max", "airmass_absolute", "10", "airmass_absolute", "np", "minimum", "airmass_absolute", "10", "warn", "user", "about", "ama", "data", "that", "is", "exceptionally", "low", "if", "np", "min", "airmass_absolute", "0", "58", "warn", "exceptionally", "low", "air", "mass", "model", "not", "intended", "for", "extra", "terrestrial", "use", "pvl_absoluteairmass", "1", "pvl_alt2pres", "4340", "0", "58", "elevation", "of", "mina", "pirquita", "argentian", "4340", "m", "highest", "elevation", "city", "with", "population", "over", "50", "000", "_coefficients", "_coefficients", "cdte", "0", "86273", "0", "038948", "0", "012506", "0", "098871", "0", "084658", "0", "0042948", "_coefficients", "monosi", "0", "85914", "0", "020880", "0", "0058853", "0", "12029", "0", "026814", "0", "0017810", "_coefficients", "xsi", "_coefficients", "monosi", "_coefficients", "polysi", "0", "84090", "0", "027539", "0", "0079224", "0", "13570", "0", "038024", "0", "0021218", "_coefficients", "multisi", "_coefficients", "polysi", "_coefficients", "cigs", "0", "85252", "0", "022314", "0", "0047216", "0", "13666", "0", "013342", "0", "0008945", "_coefficients", "asi", "1", "12094", "0", "047620", "0", "0083627", "0", "10443", "0", "098382", "0", "0033818", "if", "module_type", "is", "not", "none", "and", "coefficients", "is", "none", "coefficients", "_coefficients", "module_type", "lower", "elif", "module_type", "is", "none", "and", "coefficients", "is", "not", "none", "pass", "elif", "module_type", "is", "none", "and", "coefficients", "is", "none", "raise", "typeerror", "no", "valid", "input", "provided", "both", "module_type", "and", "coefficients", "are", "none", "else", "raise", "typeerror", "cannot", "resolve", "input", "must", "supply", "only", "one", "of", "module_type", "and", "coefficients", "evaluate", "spectral", "shift", "coeff", "coefficients", "ama", "airmass_absolute", "modifier", "coeff", "0", "coeff", "1", "ama", "coeff", "2", "pw", "coeff", "3", "np", "sqrt", "ama", "coeff", "4", "np", "sqrt", "pw", "coeff", "5", "ama", "np", "sqrt", "pw", "return", "modifier"], "doc_len": 964}
{"doc_id": "pvlib/atmosphere.py::bird_hulstrom80_aod_bb", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "bird_hulstrom80_aod_bb", "text": "文件路径: pvlib/atmosphere.py\ndef bird_hulstrom80_aod_bb(aod380, aod500):\n    \"\"\"\n    Approximate broadband aerosol optical depth.\n\n    Bird and Hulstrom developed a correlation for broadband aerosol optical\n    depth (AOD) using two wavelengths, 380 nm and 500 nm.\n\n    Parameters\n    ----------\n    aod380 : numeric\n        AOD measured at 380 nm. [unitless]\n    aod500 : numeric\n        AOD measured at 500 nm. [unitless]\n\n    Returns\n    -------\n    aod_bb : numeric\n        Broadband AOD.  [unitless]\n\n    See also\n    --------\n    pvlib.atmosphere.kasten96_lt\n\n    References\n    ----------\n    .. [1] Bird and Hulstrom, \"Direct Insolation Models\" (1980)\n       `SERI/TR-335-344 <http://www.nrel.gov/docs/legosti/old/344.pdf>`_\n\n    .. [2] R. E. Bird and R. L. Hulstrom, \"Review, Evaluation, and Improvement\n       of Direct Irradiance Models\", Journal of Solar Energy Engineering\n       103(3), pp. 182-192 (1981)\n       :doi:`10.1115/1.3266239`\n    \"\"\"\n    # approximate broadband AOD using (Bird-Hulstrom 1980)\n    return 0.27583 * aod380 + 0.35 * aod500\n", "tokens": ["pvlib", "atmosphere", "py", "def", "bird_hulstrom80_aod_bb", "aod380", "aod500", "approximate", "broadband", "aerosol", "optical", "depth", "bird", "and", "hulstrom", "developed", "a", "correlation", "for", "broadband", "aerosol", "optical", "depth", "aod", "using", "two", "wavelengths", "380", "nm", "and", "500", "nm", "parameters", "aod380", "numeric", "aod", "measured", "at", "380", "nm", "unitless", "aod500", "numeric", "aod", "measured", "at", "500", "nm", "unitless", "returns", "aod_bb", "numeric", "broadband", "aod", "unitless", "see", "also", "pvlib", "atmosphere", "kasten96_lt", "references", "1", "bird", "and", "hulstrom", "direct", "insolation", "models", "1980", "seri", "tr", "335", "344", "http", "www", "nrel", "gov", "docs", "legosti", "old", "344", "pdf", "_", "2", "r", "e", "bird", "and", "r", "l", "hulstrom", "review", "evaluation", "and", "improvement", "of", "direct", "irradiance", "models", "journal", "of", "solar", "energy", "engineering", "103", "3", "pp", "182", "192", "1981", "doi", "10", "1115", "1", "3266239", "approximate", "broadband", "aod", "using", "bird", "hulstrom", "1980", "return", "0", "27583", "aod380", "0", "35", "aod500"], "doc_len": 129}
{"doc_id": "pvlib/atmosphere.py::kasten96_lt", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "kasten96_lt", "text": "文件路径: pvlib/atmosphere.py\ndef kasten96_lt(airmass_absolute, precipitable_water, aod_bb):\n    \"\"\"\n    Calculate Linke turbidity  using Kasten pyrheliometric formula.\n\n    Note that broadband aerosol optical depth (AOD) can be approximated by AOD\n    measured at 700 nm according to Molineaux [4] . Bird and Hulstrom offer an\n    alternate approximation using AOD measured at 380 nm and 500 nm.\n\n    Based on original implementation by Armel Oumbe.\n\n    .. warning::\n        These calculations are only valid for airmass less than 5 and\n        precipitable water less than 5 cm.\n\n    Parameters\n    ----------\n    airmass_absolute : numeric\n        Pressure-adjusted airmass. [unitless]\n    precipitable_water : numeric\n        Precipitable water. [cm]\n    aod_bb : numeric\n        broadband AOD. [unitless]\n\n    Returns\n    -------\n    lt : numeric\n        Linke turbidity. [unitless]\n\n    See also\n    --------\n    pvlib.atmosphere.bird_hulstrom80_aod_bb\n    pvlib.atmosphere.angstrom_aod_at_lambda\n\n    References\n    ----------\n    .. [1] F. Linke, \"Transmissions-Koeffizient und Trubungsfaktor\", Beitrage\n       zur Physik der Atmosphare, Vol 10, pp. 91-103 (1922)\n\n    .. [2] F. Kasten, \"A simple parameterization of the pyrheliometric formula\n       for determining the Linke turbidity factor\", Meteorologische Rundschau\n       33, pp. 124-127 (1980)\n\n    .. [3] Kasten, \"The Linke turbidity factor based on improved values of the\n       integral Rayleigh optical thickness\", Solar Energy, Vol. 56, No. 3,\n       pp. 239-244 (1996)\n       :doi:`10.1016/0038-092X(95)00114-7`\n\n    .. [4] B. Molineaux, P. Ineichen, N. O'Neill, \"Equivalence of\n       pyrheliometric and monochromatic aerosol optical depths at a single key\n       wavelength\", Applied Optics Vol. 37, issue 10, 7008-7018 (1998)\n       :doi:`10.1364/AO.37.007008`\n\n    .. [5] P. Ineichen, \"Conversion function between the Linke turbidity and\n       the atmospheric water vapor and aerosol content\", Solar Energy 82,\n       pp. 1095-1097 (2008)\n       :doi:`10.1016/j.solener.2008.04.010`\n\n    .. [6] P. Ineichen and R. Perez, \"A new airmass independent formulation for\n       the Linke Turbidity coefficient\", Solar Energy, Vol. 73, no. 3,\n       pp. 151-157 (2002)\n       :doi:`10.1016/S0038-092X(02)00045-2`\n    \"\"\"\n    # \"From numerically integrated spectral simulations done with Modtran\n    # (Berk, 1989), Molineaux (1998) obtained for the broadband optical depth\n    # of a clean and dry atmospshere (fictitious atmosphere that comprises only\n    # the effects of Rayleigh scattering and absorption by the atmosphere gases\n    # other than the water vapor) the following expression\"\n    # - P. Ineichen (2008)\n    delta_cda = -0.101 + 0.235 * airmass_absolute ** (-0.16)\n    # \"and the broadband water vapor optical depth where pwat is the integrated\n    # precipitable water vapor content of the atmosphere expressed in cm and am\n    # the optical air mass. The precision of these fits is better than 1% when\n    # compared with Modtran simulations in the range 1 < am < 5 and\n    # 0 < pwat < 5 cm at sea level\" - P. Ineichen (2008)\n    delta_w = 0.112 * airmass_absolute ** (-0.55) * precipitable_water ** 0.34\n    # broadband AOD\n    delta_a = aod_bb\n    # \"Then using the Kasten pyrheliometric formula (1980, 1996), the Linke\n    # turbidity at am = 2 can be written. The extension of the Linke turbidity\n    # coefficient to other values of air mass was published by Ineichen and\n    # Perez (2002)\" - P. Ineichen (2008)\n    lt = -(9.4 + 0.9 * airmass_absolute) * np.log(\n        np.exp(-airmass_absolute * (delta_cda + delta_w + delta_a))\n    ) / airmass_absolute\n    # filter out of extrapolated values\n    return lt\n", "tokens": ["pvlib", "atmosphere", "py", "def", "kasten96_lt", "airmass_absolute", "precipitable_water", "aod_bb", "calculate", "linke", "turbidity", "using", "kasten", "pyrheliometric", "formula", "note", "that", "broadband", "aerosol", "optical", "depth", "aod", "can", "be", "approximated", "by", "aod", "measured", "at", "700", "nm", "according", "to", "molineaux", "4", "bird", "and", "hulstrom", "offer", "an", "alternate", "approximation", "using", "aod", "measured", "at", "380", "nm", "and", "500", "nm", "based", "on", "original", "implementation", "by", "armel", "oumbe", "warning", "these", "calculations", "are", "only", "valid", "for", "airmass", "less", "than", "5", "and", "precipitable", "water", "less", "than", "5", "cm", "parameters", "airmass_absolute", "numeric", "pressure", "adjusted", "airmass", "unitless", "precipitable_water", "numeric", "precipitable", "water", "cm", "aod_bb", "numeric", "broadband", "aod", "unitless", "returns", "lt", "numeric", "linke", "turbidity", "unitless", "see", "also", "pvlib", "atmosphere", "bird_hulstrom80_aod_bb", "pvlib", "atmosphere", "angstrom_aod_at_lambda", "references", "1", "f", "linke", "transmissions", "koeffizient", "und", "trubungsfaktor", "beitrage", "zur", "physik", "der", "atmosphare", "vol", "10", "pp", "91", "103", "1922", "2", "f", "kasten", "a", "simple", "parameterization", "of", "the", "pyrheliometric", "formula", "for", "determining", "the", "linke", "turbidity", "factor", "meteorologische", "rundschau", "33", "pp", "124", "127", "1980", "3", "kasten", "the", "linke", "turbidity", "factor", "based", "on", "improved", "values", "of", "the", "integral", "rayleigh", "optical", "thickness", "solar", "energy", "vol", "56", "no", "3", "pp", "239", "244", "1996", "doi", "10", "1016", "0038", "092x", "95", "00114", "7", "4", "b", "molineaux", "p", "ineichen", "n", "o", "neill", "equivalence", "of", "pyrheliometric", "and", "monochromatic", "aerosol", "optical", "depths", "at", "a", "single", "key", "wavelength", "applied", "optics", "vol", "37", "issue", "10", "7008", "7018", "1998", "doi", "10", "1364", "ao", "37", "007008", "5", "p", "ineichen", "conversion", "function", "between", "the", "linke", "turbidity", "and", "the", "atmospheric", "water", "vapor", "and", "aerosol", "content", "solar", "energy", "82", "pp", "1095", "1097", "2008", "doi", "10", "1016", "j", "solener", "2008", "04", "010", "6", "p", "ineichen", "and", "r", "perez", "a", "new", "airmass", "independent", "formulation", "for", "the", "linke", "turbidity", "coefficient", "solar", "energy", "vol", "73", "no", "3", "pp", "151", "157", "2002", "doi", "10", "1016", "s0038", "092x", "02", "00045", "2", "from", "numerically", "integrated", "spectral", "simulations", "done", "with", "modtran", "berk", "1989", "molineaux", "1998", "obtained", "for", "the", "broadband", "optical", "depth", "of", "a", "clean", "and", "dry", "atmospshere", "fictitious", "atmosphere", "that", "comprises", "only", "the", "effects", "of", "rayleigh", "scattering", "and", "absorption", "by", "the", "atmosphere", "gases", "other", "than", "the", "water", "vapor", "the", "following", "expression", "p", "ineichen", "2008", "delta_cda", "0", "101", "0", "235", "airmass_absolute", "0", "16", "and", "the", "broadband", "water", "vapor", "optical", "depth", "where", "pwat", "is", "the", "integrated", "precipitable", "water", "vapor", "content", "of", "the", "atmosphere", "expressed", "in", "cm", "and", "am", "the", "optical", "air", "mass", "the", "precision", "of", "these", "fits", "is", "better", "than", "1", "when", "compared", "with", "modtran", "simulations", "in", "the", "range", "1", "am", "5", "and", "0", "pwat", "5", "cm", "at", "sea", "level", "p", "ineichen", "2008", "delta_w", "0", "112", "airmass_absolute", "0", "55", "precipitable_water", "0", "34", "broadband", "aod", "delta_a", "aod_bb", "then", "using", "the", "kasten", "pyrheliometric", "formula", "1980", "1996", "the", "linke", "turbidity", "at", "am", "2", "can", "be", "written", "the", "extension", "of", "the", "linke", "turbidity", "coefficient", "to", "other", "values", "of", "air", "mass", "was", "published", "by", "ineichen", "and", "perez", "2002", "p", "ineichen", "2008", "lt", "9", "4", "0", "9", "airmass_absolute", "np", "log", "np", "exp", "airmass_absolute", "delta_cda", "delta_w", "delta_a", "airmass_absolute", "filter", "out", "of", "extrapolated", "values", "return", "lt"], "doc_len": 478}
{"doc_id": "pvlib/atmosphere.py::angstrom_aod_at_lambda", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "angstrom_aod_at_lambda", "text": "文件路径: pvlib/atmosphere.py\ndef angstrom_aod_at_lambda(aod0, lambda0, alpha=1.14, lambda1=700.0):\n    r\"\"\"\n    Get AOD at specified wavelength using Angstrom turbidity model.\n\n    Parameters\n    ----------\n    aod0 : numeric\n        Aerosol optical depth (AOD) measured at wavelength ``lambda0``.\n        [unitless]\n    lambda0 : numeric\n        Wavelength corresponding to ``aod0``. [nm]\n    alpha : numeric, default 1.14\n        Angstrom :math:`\\alpha` exponent corresponding to ``aod0``. [unitless]\n    lambda1 : numeric, default 700\n        Desired wavelength. [nm]\n\n    Returns\n    -------\n    aod1 : numeric\n        AOD at desired wavelength ``lambda1``. [unitless]\n\n    See also\n    --------\n    pvlib.atmosphere.angstrom_alpha\n\n    References\n    ----------\n    .. [1] Anders Angstrom, \"On the Atmospheric Transmission of Sun Radiation\n       and On Dust in the Air\", Geografiska Annaler Vol. 11, pp. 156-166 (1929)\n       JSTOR\n       :doi:`10.2307/519399`\n\n    .. [2] Anders Angstrom, \"Techniques of Determining the Turbidity of the\n       Atmosphere\", Tellus 13:2, pp. 214-223 (1961) Taylor & Francis\n       :doi:`10.3402/tellusa.v13i2.9493` and Co-Action Publishing\n       :doi:`10.1111/j.2153-3490.1961.tb00078.x`\n    \"\"\"\n    return aod0 * ((lambda1 / lambda0) ** (-alpha))\n", "tokens": ["pvlib", "atmosphere", "py", "def", "angstrom_aod_at_lambda", "aod0", "lambda0", "alpha", "1", "14", "lambda1", "700", "0", "r", "get", "aod", "at", "specified", "wavelength", "using", "angstrom", "turbidity", "model", "parameters", "aod0", "numeric", "aerosol", "optical", "depth", "aod", "measured", "at", "wavelength", "lambda0", "unitless", "lambda0", "numeric", "wavelength", "corresponding", "to", "aod0", "nm", "alpha", "numeric", "default", "1", "14", "angstrom", "math", "alpha", "exponent", "corresponding", "to", "aod0", "unitless", "lambda1", "numeric", "default", "700", "desired", "wavelength", "nm", "returns", "aod1", "numeric", "aod", "at", "desired", "wavelength", "lambda1", "unitless", "see", "also", "pvlib", "atmosphere", "angstrom_alpha", "references", "1", "anders", "angstrom", "on", "the", "atmospheric", "transmission", "of", "sun", "radiation", "and", "on", "dust", "in", "the", "air", "geografiska", "annaler", "vol", "11", "pp", "156", "166", "1929", "jstor", "doi", "10", "2307", "519399", "2", "anders", "angstrom", "techniques", "of", "determining", "the", "turbidity", "of", "the", "atmosphere", "tellus", "13", "2", "pp", "214", "223", "1961", "taylor", "francis", "doi", "10", "3402", "tellusa", "v13i2", "9493", "and", "co", "action", "publishing", "doi", "10", "1111", "j", "2153", "3490", "1961", "tb00078", "x", "return", "aod0", "lambda1", "lambda0", "alpha"], "doc_len": 150}
{"doc_id": "pvlib/atmosphere.py::angstrom_alpha", "file_path": "pvlib/atmosphere.py", "class_name": null, "func_name": "angstrom_alpha", "text": "文件路径: pvlib/atmosphere.py\ndef angstrom_alpha(aod1, lambda1, aod2, lambda2):\n    r\"\"\"\n    Calculate Angstrom alpha exponent.\n\n    Parameters\n    ----------\n    aod1 : numeric\n        Aerosol optical depth at wavelength ``lambda1``. [unitless]\n    lambda1 : numeric\n        Wavelength corresponding to ``aod1``. [nm]\n    aod2 : numeric\n        Aerosol optical depth  at wavelength ``lambda2``. [unitless]\n    lambda2 : numeric\n        Wavelength corresponding to ``aod2``. [nm]\n\n    Returns\n    -------\n    alpha : numeric\n        Angstrom :math:`\\alpha` exponent for wavelength in\n        ``(lambda1, lambda2)``. [unitless]\n\n    See also\n    --------\n    pvlib.atmosphere.angstrom_aod_at_lambda\n    \"\"\"\n    return - np.log(aod1 / aod2) / np.log(lambda1 / lambda2)\n", "tokens": ["pvlib", "atmosphere", "py", "def", "angstrom_alpha", "aod1", "lambda1", "aod2", "lambda2", "r", "calculate", "angstrom", "alpha", "exponent", "parameters", "aod1", "numeric", "aerosol", "optical", "depth", "at", "wavelength", "lambda1", "unitless", "lambda1", "numeric", "wavelength", "corresponding", "to", "aod1", "nm", "aod2", "numeric", "aerosol", "optical", "depth", "at", "wavelength", "lambda2", "unitless", "lambda2", "numeric", "wavelength", "corresponding", "to", "aod2", "nm", "returns", "alpha", "numeric", "angstrom", "math", "alpha", "exponent", "for", "wavelength", "in", "lambda1", "lambda2", "unitless", "see", "also", "pvlib", "atmosphere", "angstrom_aod_at_lambda", "return", "np", "log", "aod1", "aod2", "np", "log", "lambda1", "lambda2"], "doc_len": 74}
{"doc_id": "pvlib/clearsky.py::ineichen", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "ineichen", "text": "文件路径: pvlib/clearsky.py\ndef ineichen(apparent_zenith, airmass_absolute, linke_turbidity,\n             altitude=0, dni_extra=1364., perez_enhancement=False):\n    '''\n    Determine clear sky GHI, DNI, and DHI from Ineichen/Perez model.\n\n    Implements the Ineichen and Perez clear sky model for global\n    horizontal irradiance (GHI), direct normal irradiance (DNI), and\n    calculates the clear-sky diffuse horizontal (DHI) component as the\n    difference between GHI and DNI*cos(zenith) as presented in [1, 2]. A\n    report on clear sky models found the Ineichen/Perez model to have\n    excellent performance with a minimal input data set [3].\n\n    Default values for monthly Linke turbidity provided by SoDa [4, 5].\n\n    Parameters\n    -----------\n    apparent_zenith : numeric\n        Refraction corrected solar zenith angle in degrees.\n\n    airmass_absolute : numeric\n        Pressure corrected airmass.\n\n    linke_turbidity : numeric\n        Linke Turbidity.\n\n    altitude : numeric, default 0\n        Altitude above sea level in meters.\n\n    dni_extra : numeric, default 1364\n        Extraterrestrial irradiance. The units of ``dni_extra``\n        determine the units of the output.\n\n    perez_enhancement : bool, default False\n        Controls if the Perez enhancement factor should be applied.\n        Setting to True may produce spurious results for times when\n        the Sun is near the horizon and the airmass is high.\n        See https://github.com/pvlib/pvlib-python/issues/435\n\n    Returns\n    -------\n    clearsky : DataFrame (if Series input) or OrderedDict of arrays\n        DataFrame/OrderedDict contains the columns/keys\n        ``'dhi', 'dni', 'ghi'``.\n\n    See also\n    --------\n    lookup_linke_turbidity\n    pvlib.location.Location.get_clearsky\n\n    References\n    ----------\n    .. [1] P. Ineichen and R. Perez, \"A New airmass independent formulation for\n       the Linke turbidity coefficient\", Solar Energy, vol 73, pp. 151-157,\n       2002.\n\n    .. [2] R. Perez et. al., \"A New Operational Model for Satellite-Derived\n       Irradiances: Description and Validation\", Solar Energy, vol 73, pp.\n       307-317, 2002.\n\n    .. [3] M. Reno, C. Hansen, and J. Stein, \"Global Horizontal Irradiance\n       Clear Sky Models: Implementation and Analysis\", Sandia National\n       Laboratories, SAND2012-2389, 2012.\n\n    .. [4] http://www.soda-is.com/eng/services/climat_free_eng.php#c5 (obtained\n       July 17, 2012).\n\n    .. [5] J. Remund, et. al., \"Worldwide Linke Turbidity Information\", Proc.\n       ISES Solar World Congress, June 2003. Goteborg, Sweden.\n    '''\n\n    # ghi is calculated using either the equations in [1] by setting\n    # perez_enhancement=False (default behavior) or using the model\n    # in [2] by setting perez_enhancement=True.\n\n    # The NaN handling is a little subtle. The AM input is likely to\n    # have NaNs that we'll want to map to 0s in the output. However, we\n    # want NaNs in other inputs to propagate through to the output. This\n    # is accomplished by judicious use and placement of np.maximum,\n    # np.minimum, and np.fmax\n\n    # use max so that nighttime values will result in 0s instead of\n    # negatives. propagates nans.\n    cos_zenith = np.maximum(tools.cosd(apparent_zenith), 0)\n\n    tl = linke_turbidity\n\n    fh1 = np.exp(-altitude/8000.)\n    fh2 = np.exp(-altitude/1250.)\n    cg1 = 5.09e-05 * altitude + 0.868\n    cg2 = 3.92e-05 * altitude + 0.0387\n\n    ghi = np.exp(-cg2*airmass_absolute*(fh1 + fh2*(tl - 1)))\n\n    # https://github.com/pvlib/pvlib-python/issues/435\n    if perez_enhancement:\n        ghi *= np.exp(0.01*airmass_absolute**1.8)\n\n    # use fmax to map airmass nans to 0s. multiply and divide by tl to\n    # reinsert tl nans\n    ghi = cg1 * dni_extra * cos_zenith * tl / tl * np.fmax(ghi, 0)\n\n    # From [1] (Following [2] leads to 0.664 + 0.16268 / fh1)\n    # See https://github.com/pvlib/pvlib-python/pull/808\n    b = 0.664 + 0.163/fh1\n    # BncI = \"normal beam clear sky radiation\"\n    bnci = b * np.exp(-0.09 * airmass_absolute * (tl - 1))\n    bnci = dni_extra * np.fmax(bnci, 0)\n\n    # \"empirical correction\" SE 73, 157 & SE 73, 312.\n    bnci_2 = ((1 - (0.1 - 0.2*np.exp(-tl))/(0.1 + 0.882/fh1)) /\n              cos_zenith)\n    bnci_2 = ghi * np.fmin(np.fmax(bnci_2, 0), 1e20)\n\n    dni = np.minimum(bnci, bnci_2)\n\n    dhi = ghi - dni*cos_zenith\n\n    irrads = OrderedDict()\n    irrads['ghi'] = ghi\n    irrads['dni'] = dni\n    irrads['dhi'] = dhi\n\n    if isinstance(dni, pd.Series):\n        irrads = pd.DataFrame.from_dict(irrads)\n\n    return irrads\n", "tokens": ["pvlib", "clearsky", "py", "def", "ineichen", "apparent_zenith", "airmass_absolute", "linke_turbidity", "altitude", "0", "dni_extra", "1364", "perez_enhancement", "false", "determine", "clear", "sky", "ghi", "dni", "and", "dhi", "from", "ineichen", "perez", "model", "implements", "the", "ineichen", "and", "perez", "clear", "sky", "model", "for", "global", "horizontal", "irradiance", "ghi", "direct", "normal", "irradiance", "dni", "and", "calculates", "the", "clear", "sky", "diffuse", "horizontal", "dhi", "component", "as", "the", "difference", "between", "ghi", "and", "dni", "cos", "zenith", "as", "presented", "in", "1", "2", "a", "report", "on", "clear", "sky", "models", "found", "the", "ineichen", "perez", "model", "to", "have", "excellent", "performance", "with", "a", "minimal", "input", "data", "set", "3", "default", "values", "for", "monthly", "linke", "turbidity", "provided", "by", "soda", "4", "5", "parameters", "apparent_zenith", "numeric", "refraction", "corrected", "solar", "zenith", "angle", "in", "degrees", "airmass_absolute", "numeric", "pressure", "corrected", "airmass", "linke_turbidity", "numeric", "linke", "turbidity", "altitude", "numeric", "default", "0", "altitude", "above", "sea", "level", "in", "meters", "dni_extra", "numeric", "default", "1364", "extraterrestrial", "irradiance", "the", "units", "of", "dni_extra", "determine", "the", "units", "of", "the", "output", "perez_enhancement", "bool", "default", "false", "controls", "if", "the", "perez", "enhancement", "factor", "should", "be", "applied", "setting", "to", "true", "may", "produce", "spurious", "results", "for", "times", "when", "the", "sun", "is", "near", "the", "horizon", "and", "the", "airmass", "is", "high", "see", "https", "github", "com", "pvlib", "pvlib", "python", "issues", "435", "returns", "clearsky", "dataframe", "if", "series", "input", "or", "ordereddict", "of", "arrays", "dataframe", "ordereddict", "contains", "the", "columns", "keys", "dhi", "dni", "ghi", "see", "also", "lookup_linke_turbidity", "pvlib", "location", "location", "get_clearsky", "references", "1", "p", "ineichen", "and", "r", "perez", "a", "new", "airmass", "independent", "formulation", "for", "the", "linke", "turbidity", "coefficient", "solar", "energy", "vol", "73", "pp", "151", "157", "2002", "2", "r", "perez", "et", "al", "a", "new", "operational", "model", "for", "satellite", "derived", "irradiances", "description", "and", "validation", "solar", "energy", "vol", "73", "pp", "307", "317", "2002", "3", "m", "reno", "c", "hansen", "and", "j", "stein", "global", "horizontal", "irradiance", "clear", "sky", "models", "implementation", "and", "analysis", "sandia", "national", "laboratories", "sand2012", "2389", "2012", "4", "http", "www", "soda", "is", "com", "eng", "services", "climat_free_eng", "php", "c5", "obtained", "july", "17", "2012", "5", "j", "remund", "et", "al", "worldwide", "linke", "turbidity", "information", "proc", "ises", "solar", "world", "congress", "june", "2003", "goteborg", "sweden", "ghi", "is", "calculated", "using", "either", "the", "equations", "in", "1", "by", "setting", "perez_enhancement", "false", "default", "behavior", "or", "using", "the", "model", "in", "2", "by", "setting", "perez_enhancement", "true", "the", "nan", "handling", "is", "a", "little", "subtle", "the", "am", "input", "is", "likely", "to", "have", "nans", "that", "we", "ll", "want", "to", "map", "to", "0s", "in", "the", "output", "however", "we", "want", "nans", "in", "other", "inputs", "to", "propagate", "through", "to", "the", "output", "this", "is", "accomplished", "by", "judicious", "use", "and", "placement", "of", "np", "maximum", "np", "minimum", "and", "np", "fmax", "use", "max", "so", "that", "nighttime", "values", "will", "result", "in", "0s", "instead", "of", "negatives", "propagates", "nans", "cos_zenith", "np", "maximum", "tools", "cosd", "apparent_zenith", "0", "tl", "linke_turbidity", "fh1", "np", "exp", "altitude", "8000", "fh2", "np", "exp", "altitude", "1250", "cg1", "5", "09e", "05", "altitude", "0", "868", "cg2", "3", "92e", "05", "altitude", "0", "0387", "ghi", "np", "exp", "cg2", "airmass_absolute", "fh1", "fh2", "tl", "1", "https", "github", "com", "pvlib", "pvlib", "python", "issues", "435", "if", "perez_enhancement", "ghi", "np", "exp", "0", "01", "airmass_absolute", "1", "8", "use", "fmax", "to", "map", "airmass", "nans", "to", "0s", "multiply", "and", "divide", "by", "tl", "to", "reinsert", "tl", "nans", "ghi", "cg1", "dni_extra", "cos_zenith", "tl", "tl", "np", "fmax", "ghi", "0", "from", "1", "following", "2", "leads", "to", "0", "664", "0", "16268", "fh1", "see", "https", "github", "com", "pvlib", "pvlib", "python", "pull", "808", "b", "0", "664", "0", "163", "fh1", "bnci", "normal", "beam", "clear", "sky", "radiation", "bnci", "b", "np", "exp", "0", "09", "airmass_absolute", "tl", "1", "bnci", "dni_extra", "np", "fmax", "bnci", "0", "empirical", "correction", "se", "73", "157", "se", "73", "312", "bnci_2", "1", "0", "1", "0", "2", "np", "exp", "tl", "0", "1", "0", "882", "fh1", "cos_zenith", "bnci_2", "ghi", "np", "fmin", "np", "fmax", "bnci_2", "0", "1e20", "dni", "np", "minimum", "bnci", "bnci_2", "dhi", "ghi", "dni", "cos_zenith", "irrads", "ordereddict", "irrads", "ghi", "ghi", "irrads", "dni", "dni", "irrads", "dhi", "dhi", "if", "isinstance", "dni", "pd", "series", "irrads", "pd", "dataframe", "from_dict", "irrads", "return", "irrads"], "doc_len": 610}
{"doc_id": "pvlib/clearsky.py::lookup_linke_turbidity", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "lookup_linke_turbidity", "text": "文件路径: pvlib/clearsky.py\ndef lookup_linke_turbidity(time, latitude, longitude, filepath=None,\n                           interp_turbidity=True):\n    \"\"\"\n    Look up the Linke Turibidity from the ``LinkeTurbidities.h5``\n    data file supplied with pvlib.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n\n    latitude : float or int\n\n    longitude : float or int\n\n    filepath : None or string, default None\n        The path to the ``.h5`` file.\n\n    interp_turbidity : bool, default True\n        If ``True``, interpolates the monthly Linke turbidity values\n        found in ``LinkeTurbidities.h5`` to daily values.\n\n    Returns\n    -------\n    turbidity : Series\n    \"\"\"\n\n    # The .h5 file 'LinkeTurbidities.h5' contains a single 2160 x 4320 x 12\n    # matrix of type uint8 called 'LinkeTurbidity'. The rows represent global\n    # latitudes from 90 to -90 degrees; the columns represent global longitudes\n    # from -180 to 180; and the depth (third dimension) represents months of\n    # the year from January (1) to December (12). To determine the Linke\n    # turbidity for a position on the Earth's surface for a given month do the\n    # following: LT = LinkeTurbidity(LatitudeIndex, LongitudeIndex, month).\n    # Note that the numbers within the matrix are 20 * Linke Turbidity,\n    # so divide the number from the file by 20 to get the\n    # turbidity.\n\n    # The nodes of the grid are 5' (1/12=0.0833[arcdeg]) apart.\n    # From Section 8 of Aerosol optical depth and Linke turbidity climatology\n    # http://www.meteonorm.com/images/uploads/downloads/ieashc36_report_TL_AOD_climatologies.pdf\n    # 1st row: 89.9583 S, 2nd row: 89.875 S\n    # 1st column: 179.9583 W, 2nd column: 179.875 W\n\n    if filepath is None:\n        pvlib_path = os.path.dirname(os.path.abspath(__file__))\n        filepath = os.path.join(pvlib_path, 'data', 'LinkeTurbidities.h5')\n\n    latitude_index = _degrees_to_index(latitude, coordinate='latitude')\n    longitude_index = _degrees_to_index(longitude, coordinate='longitude')\n\n    with h5py.File(filepath, 'r') as lt_h5_file:\n        lts = lt_h5_file['LinkeTurbidity'][latitude_index, longitude_index]\n\n    if interp_turbidity:\n        linke_turbidity = _interpolate_turbidity(lts, time)\n    else:\n        months = time.month - 1\n        linke_turbidity = pd.Series(lts[months], index=time)\n\n    linke_turbidity /= 20.\n\n    return linke_turbidity\n", "tokens": ["pvlib", "clearsky", "py", "def", "lookup_linke_turbidity", "time", "latitude", "longitude", "filepath", "none", "interp_turbidity", "true", "look", "up", "the", "linke", "turibidity", "from", "the", "linketurbidities", "h5", "data", "file", "supplied", "with", "pvlib", "parameters", "time", "pandas", "datetimeindex", "latitude", "float", "or", "int", "longitude", "float", "or", "int", "filepath", "none", "or", "string", "default", "none", "the", "path", "to", "the", "h5", "file", "interp_turbidity", "bool", "default", "true", "if", "true", "interpolates", "the", "monthly", "linke", "turbidity", "values", "found", "in", "linketurbidities", "h5", "to", "daily", "values", "returns", "turbidity", "series", "the", "h5", "file", "linketurbidities", "h5", "contains", "a", "single", "2160", "x", "4320", "x", "12", "matrix", "of", "type", "uint8", "called", "linketurbidity", "the", "rows", "represent", "global", "latitudes", "from", "90", "to", "90", "degrees", "the", "columns", "represent", "global", "longitudes", "from", "180", "to", "180", "and", "the", "depth", "third", "dimension", "represents", "months", "of", "the", "year", "from", "january", "1", "to", "december", "12", "to", "determine", "the", "linke", "turbidity", "for", "a", "position", "on", "the", "earth", "s", "surface", "for", "a", "given", "month", "do", "the", "following", "lt", "linketurbidity", "latitudeindex", "longitudeindex", "month", "note", "that", "the", "numbers", "within", "the", "matrix", "are", "20", "linke", "turbidity", "so", "divide", "the", "number", "from", "the", "file", "by", "20", "to", "get", "the", "turbidity", "the", "nodes", "of", "the", "grid", "are", "5", "1", "12", "0", "0833", "arcdeg", "apart", "from", "section", "8", "of", "aerosol", "optical", "depth", "and", "linke", "turbidity", "climatology", "http", "www", "meteonorm", "com", "images", "uploads", "downloads", "ieashc36_report_tl_aod_climatologies", "pdf", "1st", "row", "89", "9583", "s", "2nd", "row", "89", "875", "s", "1st", "column", "179", "9583", "w", "2nd", "column", "179", "875", "w", "if", "filepath", "is", "none", "pvlib_path", "os", "path", "dirname", "os", "path", "abspath", "__file__", "filepath", "os", "path", "join", "pvlib_path", "data", "linketurbidities", "h5", "latitude_index", "_degrees_to_index", "latitude", "coordinate", "latitude", "longitude_index", "_degrees_to_index", "longitude", "coordinate", "longitude", "with", "h5py", "file", "filepath", "r", "as", "lt_h5_file", "lts", "lt_h5_file", "linketurbidity", "latitude_index", "longitude_index", "if", "interp_turbidity", "linke_turbidity", "_interpolate_turbidity", "lts", "time", "else", "months", "time", "month", "1", "linke_turbidity", "pd", "series", "lts", "months", "index", "time", "linke_turbidity", "20", "return", "linke_turbidity"], "doc_len": 292}
{"doc_id": "pvlib/clearsky.py::_is_leap_year", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_is_leap_year", "text": "文件路径: pvlib/clearsky.py\ndef _is_leap_year(year):\n    \"\"\"Determine if a year is leap year.\n\n    Parameters\n    ----------\n    year : numeric\n\n    Returns\n    -------\n    isleap : array of bools\n    \"\"\"\n    isleap = ((np.mod(year, 4) == 0) &\n              ((np.mod(year, 100) != 0) | (np.mod(year, 400) == 0)))\n    return isleap\n", "tokens": ["pvlib", "clearsky", "py", "def", "_is_leap_year", "year", "determine", "if", "a", "year", "is", "leap", "year", "parameters", "year", "numeric", "returns", "isleap", "array", "of", "bools", "isleap", "np", "mod", "year", "4", "0", "np", "mod", "year", "100", "0", "np", "mod", "year", "400", "0", "return", "isleap"], "doc_len": 39}
{"doc_id": "pvlib/clearsky.py::_interpolate_turbidity", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_interpolate_turbidity", "text": "文件路径: pvlib/clearsky.py\ndef _interpolate_turbidity(lts, time):\n    \"\"\"\n    Interpolated monthly Linke turbidity onto daily values.\n\n    Parameters\n    ----------\n    lts : np.array\n        Monthly Linke turbidity values.\n    time : pd.DatetimeIndex\n        Times to be interpolated onto.\n\n    Returns\n    -------\n    linke_turbidity : pd.Series\n        The interpolated turbidity.\n    \"\"\"\n    # Data covers 1 year. Assume that data corresponds to the value at the\n    # middle of each month. This means that we need to add previous Dec and\n    # next Jan to the array so that the interpolation will work for\n    # Jan 1 - Jan 15 and Dec 16 - Dec 31.\n    lts_concat = np.concatenate([[lts[-1]], lts, [lts[0]]])\n\n    # handle leap years\n    try:\n        isleap = time.is_leap_year\n    except AttributeError:\n        year = time.year\n        isleap = _is_leap_year(year)\n\n    dayofyear = time.dayofyear\n    days_leap = _calendar_month_middles(2016)\n    days_no_leap = _calendar_month_middles(2015)\n\n    # Then we map the month value to the day of year value.\n    # Do it for both leap and non-leap years.\n    lt_leap = np.interp(dayofyear, days_leap, lts_concat)\n    lt_no_leap = np.interp(dayofyear, days_no_leap, lts_concat)\n    linke_turbidity = np.where(isleap, lt_leap, lt_no_leap)\n\n    linke_turbidity = pd.Series(linke_turbidity, index=time)\n\n    return linke_turbidity\n", "tokens": ["pvlib", "clearsky", "py", "def", "_interpolate_turbidity", "lts", "time", "interpolated", "monthly", "linke", "turbidity", "onto", "daily", "values", "parameters", "lts", "np", "array", "monthly", "linke", "turbidity", "values", "time", "pd", "datetimeindex", "times", "to", "be", "interpolated", "onto", "returns", "linke_turbidity", "pd", "series", "the", "interpolated", "turbidity", "data", "covers", "1", "year", "assume", "that", "data", "corresponds", "to", "the", "value", "at", "the", "middle", "of", "each", "month", "this", "means", "that", "we", "need", "to", "add", "previous", "dec", "and", "next", "jan", "to", "the", "array", "so", "that", "the", "interpolation", "will", "work", "for", "jan", "1", "jan", "15", "and", "dec", "16", "dec", "31", "lts_concat", "np", "concatenate", "lts", "1", "lts", "lts", "0", "handle", "leap", "years", "try", "isleap", "time", "is_leap_year", "except", "attributeerror", "year", "time", "year", "isleap", "_is_leap_year", "year", "dayofyear", "time", "dayofyear", "days_leap", "_calendar_month_middles", "2016", "days_no_leap", "_calendar_month_middles", "2015", "then", "we", "map", "the", "month", "value", "to", "the", "day", "of", "year", "value", "do", "it", "for", "both", "leap", "and", "non", "leap", "years", "lt_leap", "np", "interp", "dayofyear", "days_leap", "lts_concat", "lt_no_leap", "np", "interp", "dayofyear", "days_no_leap", "lts_concat", "linke_turbidity", "np", "where", "isleap", "lt_leap", "lt_no_leap", "linke_turbidity", "pd", "series", "linke_turbidity", "index", "time", "return", "linke_turbidity"], "doc_len": 164}
{"doc_id": "pvlib/clearsky.py::_calendar_month_middles", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calendar_month_middles", "text": "文件路径: pvlib/clearsky.py\ndef _calendar_month_middles(year):\n    \"\"\"List of middle day of each month, used by Linke turbidity lookup\"\"\"\n    # remove mdays[0] since January starts at mdays[1]\n    # make local copy of mdays since we need to change\n    # February for leap years\n    mdays = np.array(calendar.mdays[1:])\n    ydays = 365\n    # handle leap years\n    if calendar.isleap(year):\n        mdays[1] = mdays[1] + 1\n        ydays = 366\n    middles = np.concatenate(\n        [[-calendar.mdays[-1] / 2.0],  # Dec last year\n         np.cumsum(mdays) - np.array(mdays) / 2.,  # this year\n         [ydays + calendar.mdays[1] / 2.0]])  # Jan next year\n    return middles\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calendar_month_middles", "year", "list", "of", "middle", "day", "of", "each", "month", "used", "by", "linke", "turbidity", "lookup", "remove", "mdays", "0", "since", "january", "starts", "at", "mdays", "1", "make", "local", "copy", "of", "mdays", "since", "we", "need", "to", "change", "february", "for", "leap", "years", "mdays", "np", "array", "calendar", "mdays", "1", "ydays", "365", "handle", "leap", "years", "if", "calendar", "isleap", "year", "mdays", "1", "mdays", "1", "1", "ydays", "366", "middles", "np", "concatenate", "calendar", "mdays", "1", "2", "0", "dec", "last", "year", "np", "cumsum", "mdays", "np", "array", "mdays", "2", "this", "year", "ydays", "calendar", "mdays", "1", "2", "0", "jan", "next", "year", "return", "middles"], "doc_len": 94}
{"doc_id": "pvlib/clearsky.py::haurwitz", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "haurwitz", "text": "文件路径: pvlib/clearsky.py\ndef haurwitz(apparent_zenith):\n    '''\n    Determine clear sky GHI using the Haurwitz model.\n\n    Implements the Haurwitz clear sky model for global horizontal\n    irradiance (GHI) as presented in [1, 2]. A report on clear\n    sky models found the Haurwitz model to have the best performance\n    in terms of average monthly error among models which require only\n    zenith angle [3].\n\n    Parameters\n    ----------\n    apparent_zenith : Series\n        The apparent (refraction corrected) sun zenith angle\n        in degrees.\n\n    Returns\n    -------\n    ghi : DataFrame\n        The modeled global horizonal irradiance in W/m^2 provided\n        by the Haurwitz clear-sky model.\n\n    References\n    ----------\n\n    .. [1] B. Haurwitz, \"Insolation in Relation to Cloudiness and Cloud\n       Density,\" Journal of Meteorology, vol. 2, pp. 154-166, 1945.\n\n    .. [2] B. Haurwitz, \"Insolation in Relation to Cloud Type,\" Journal of\n       Meteorology, vol. 3, pp. 123-124, 1946.\n\n    .. [3] M. Reno, C. Hansen, and J. Stein, \"Global Horizontal Irradiance\n       Clear Sky Models: Implementation and Analysis\", Sandia National\n       Laboratories, SAND2012-2389, 2012.\n    '''\n\n    cos_zenith = tools.cosd(apparent_zenith.values)\n    clearsky_ghi = np.zeros_like(apparent_zenith.values)\n    cos_zen_gte_0 = cos_zenith > 0\n    clearsky_ghi[cos_zen_gte_0] = (1098.0 * cos_zenith[cos_zen_gte_0] *\n                                   np.exp(-0.059/cos_zenith[cos_zen_gte_0]))\n\n    df_out = pd.DataFrame(index=apparent_zenith.index,\n                          data=clearsky_ghi,\n                          columns=['ghi'])\n\n    return df_out\n", "tokens": ["pvlib", "clearsky", "py", "def", "haurwitz", "apparent_zenith", "determine", "clear", "sky", "ghi", "using", "the", "haurwitz", "model", "implements", "the", "haurwitz", "clear", "sky", "model", "for", "global", "horizontal", "irradiance", "ghi", "as", "presented", "in", "1", "2", "a", "report", "on", "clear", "sky", "models", "found", "the", "haurwitz", "model", "to", "have", "the", "best", "performance", "in", "terms", "of", "average", "monthly", "error", "among", "models", "which", "require", "only", "zenith", "angle", "3", "parameters", "apparent_zenith", "series", "the", "apparent", "refraction", "corrected", "sun", "zenith", "angle", "in", "degrees", "returns", "ghi", "dataframe", "the", "modeled", "global", "horizonal", "irradiance", "in", "w", "m", "2", "provided", "by", "the", "haurwitz", "clear", "sky", "model", "references", "1", "b", "haurwitz", "insolation", "in", "relation", "to", "cloudiness", "and", "cloud", "density", "journal", "of", "meteorology", "vol", "2", "pp", "154", "166", "1945", "2", "b", "haurwitz", "insolation", "in", "relation", "to", "cloud", "type", "journal", "of", "meteorology", "vol", "3", "pp", "123", "124", "1946", "3", "m", "reno", "c", "hansen", "and", "j", "stein", "global", "horizontal", "irradiance", "clear", "sky", "models", "implementation", "and", "analysis", "sandia", "national", "laboratories", "sand2012", "2389", "2012", "cos_zenith", "tools", "cosd", "apparent_zenith", "values", "clearsky_ghi", "np", "zeros_like", "apparent_zenith", "values", "cos_zen_gte_0", "cos_zenith", "0", "clearsky_ghi", "cos_zen_gte_0", "1098", "0", "cos_zenith", "cos_zen_gte_0", "np", "exp", "0", "059", "cos_zenith", "cos_zen_gte_0", "df_out", "pd", "dataframe", "index", "apparent_zenith", "index", "data", "clearsky_ghi", "columns", "ghi", "return", "df_out"], "doc_len": 189}
{"doc_id": "pvlib/clearsky.py::simplified_solis", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "simplified_solis", "text": "文件路径: pvlib/clearsky.py\ndef simplified_solis(apparent_elevation, aod700=0.1, precipitable_water=1.,\n                     pressure=101325., dni_extra=1364.):\n    \"\"\"\n    Calculate the clear sky GHI, DNI, and DHI according to the\n    simplified Solis model.\n\n    Reference [1]_ describes the accuracy of the model as being 15, 20,\n    and 18 W/m^2 for the beam, global, and diffuse components. Reference\n    [2]_ provides comparisons with other clear sky models.\n\n    Parameters\n    ----------\n    apparent_elevation : numeric\n        The apparent elevation of the sun above the horizon (deg).\n\n    aod700 : numeric, default 0.1\n        The aerosol optical depth at 700 nm (unitless).\n        Algorithm derived for values between 0 and 0.45.\n\n    precipitable_water : numeric, default 1.0\n        The precipitable water of the atmosphere (cm).\n        Algorithm derived for values between 0.2 and 10 cm.\n        Values less than 0.2 will be assumed to be equal to 0.2.\n\n    pressure : numeric, default 101325.0\n        The atmospheric pressure (Pascals).\n        Algorithm derived for altitudes between sea level and 7000 m,\n        or 101325 and 41000 Pascals.\n\n    dni_extra : numeric, default 1364.0\n        Extraterrestrial irradiance. The units of ``dni_extra``\n        determine the units of the output.\n\n    Returns\n    -------\n    clearsky : DataFrame (if Series input) or OrderedDict of arrays\n        DataFrame/OrderedDict contains the columns/keys\n        ``'dhi', 'dni', 'ghi'``.\n\n    References\n    ----------\n    .. [1] P. Ineichen, \"A broadband simplified version of the\n       Solis clear sky model,\" Solar Energy, 82, 758-762 (2008).\n\n    .. [2] P. Ineichen, \"Validation of models that estimate the clear\n       sky global and beam solar irradiance,\" Solar Energy, 132,\n       332-344 (2016).\n    \"\"\"\n\n    p = pressure\n\n    w = precipitable_water\n\n    # algorithm fails for pw < 0.2\n    w = np.maximum(w, 0.2)\n\n    # this algorithm is reasonably fast already, but it could be made\n    # faster by precalculating the powers of aod700, the log(p/p0), and\n    # the log(w) instead of repeating the calculations as needed in each\n    # function\n\n    i0p = _calc_i0p(dni_extra, w, aod700, p)\n\n    taub = _calc_taub(w, aod700, p)\n    b = _calc_b(w, aod700)\n\n    taug = _calc_taug(w, aod700, p)\n    g = _calc_g(w, aod700)\n\n    taud = _calc_taud(w, aod700, p)\n    d = _calc_d(aod700, p)\n\n    # this prevents the creation of nans at night instead of 0s\n    # it's also friendly to scalar and series inputs\n    sin_elev = np.maximum(1.e-30, np.sin(np.radians(apparent_elevation)))\n\n    dni = i0p * np.exp(-taub/sin_elev**b)\n    ghi = i0p * np.exp(-taug/sin_elev**g) * sin_elev\n    dhi = i0p * np.exp(-taud/sin_elev**d)\n\n    irrads = OrderedDict()\n    irrads['ghi'] = ghi\n    irrads['dni'] = dni\n    irrads['dhi'] = dhi\n\n    if isinstance(dni, pd.Series):\n        irrads = pd.DataFrame.from_dict(irrads)\n\n    return irrads\n", "tokens": ["pvlib", "clearsky", "py", "def", "simplified_solis", "apparent_elevation", "aod700", "0", "1", "precipitable_water", "1", "pressure", "101325", "dni_extra", "1364", "calculate", "the", "clear", "sky", "ghi", "dni", "and", "dhi", "according", "to", "the", "simplified", "solis", "model", "reference", "1", "_", "describes", "the", "accuracy", "of", "the", "model", "as", "being", "15", "20", "and", "18", "w", "m", "2", "for", "the", "beam", "global", "and", "diffuse", "components", "reference", "2", "_", "provides", "comparisons", "with", "other", "clear", "sky", "models", "parameters", "apparent_elevation", "numeric", "the", "apparent", "elevation", "of", "the", "sun", "above", "the", "horizon", "deg", "aod700", "numeric", "default", "0", "1", "the", "aerosol", "optical", "depth", "at", "700", "nm", "unitless", "algorithm", "derived", "for", "values", "between", "0", "and", "0", "45", "precipitable_water", "numeric", "default", "1", "0", "the", "precipitable", "water", "of", "the", "atmosphere", "cm", "algorithm", "derived", "for", "values", "between", "0", "2", "and", "10", "cm", "values", "less", "than", "0", "2", "will", "be", "assumed", "to", "be", "equal", "to", "0", "2", "pressure", "numeric", "default", "101325", "0", "the", "atmospheric", "pressure", "pascals", "algorithm", "derived", "for", "altitudes", "between", "sea", "level", "and", "7000", "m", "or", "101325", "and", "41000", "pascals", "dni_extra", "numeric", "default", "1364", "0", "extraterrestrial", "irradiance", "the", "units", "of", "dni_extra", "determine", "the", "units", "of", "the", "output", "returns", "clearsky", "dataframe", "if", "series", "input", "or", "ordereddict", "of", "arrays", "dataframe", "ordereddict", "contains", "the", "columns", "keys", "dhi", "dni", "ghi", "references", "1", "p", "ineichen", "a", "broadband", "simplified", "version", "of", "the", "solis", "clear", "sky", "model", "solar", "energy", "82", "758", "762", "2008", "2", "p", "ineichen", "validation", "of", "models", "that", "estimate", "the", "clear", "sky", "global", "and", "beam", "solar", "irradiance", "solar", "energy", "132", "332", "344", "2016", "p", "pressure", "w", "precipitable_water", "algorithm", "fails", "for", "pw", "0", "2", "w", "np", "maximum", "w", "0", "2", "this", "algorithm", "is", "reasonably", "fast", "already", "but", "it", "could", "be", "made", "faster", "by", "precalculating", "the", "powers", "of", "aod700", "the", "log", "p", "p0", "and", "the", "log", "w", "instead", "of", "repeating", "the", "calculations", "as", "needed", "in", "each", "function", "i0p", "_calc_i0p", "dni_extra", "w", "aod700", "p", "taub", "_calc_taub", "w", "aod700", "p", "b", "_calc_b", "w", "aod700", "taug", "_calc_taug", "w", "aod700", "p", "g", "_calc_g", "w", "aod700", "taud", "_calc_taud", "w", "aod700", "p", "d", "_calc_d", "aod700", "p", "this", "prevents", "the", "creation", "of", "nans", "at", "night", "instead", "of", "0s", "it", "s", "also", "friendly", "to", "scalar", "and", "series", "inputs", "sin_elev", "np", "maximum", "1", "e", "30", "np", "sin", "np", "radians", "apparent_elevation", "dni", "i0p", "np", "exp", "taub", "sin_elev", "b", "ghi", "i0p", "np", "exp", "taug", "sin_elev", "g", "sin_elev", "dhi", "i0p", "np", "exp", "taud", "sin_elev", "d", "irrads", "ordereddict", "irrads", "ghi", "ghi", "irrads", "dni", "dni", "irrads", "dhi", "dhi", "if", "isinstance", "dni", "pd", "series", "irrads", "pd", "dataframe", "from_dict", "irrads", "return", "irrads"], "doc_len": 398}
{"doc_id": "pvlib/clearsky.py::_calc_i0p", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_i0p", "text": "文件路径: pvlib/clearsky.py\ndef _calc_i0p(i0, w, aod700, p):\n    \"\"\"Calculate the \"enhanced extraterrestrial irradiance\".\"\"\"\n    p0 = 101325.\n    io0 = 1.08 * w**0.0051\n    i01 = 0.97 * w**0.032\n    i02 = 0.12 * w**0.56\n    i0p = i0 * (i02*aod700**2 + i01*aod700 + io0 + 0.071*np.log(p/p0))\n\n    return i0p\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_i0p", "i0", "w", "aod700", "p", "calculate", "the", "enhanced", "extraterrestrial", "irradiance", "p0", "101325", "io0", "1", "08", "w", "0", "0051", "i01", "0", "97", "w", "0", "032", "i02", "0", "12", "w", "0", "56", "i0p", "i0", "i02", "aod700", "2", "i01", "aod700", "io0", "0", "071", "np", "log", "p", "p0", "return", "i0p"], "doc_len": 50}
{"doc_id": "pvlib/clearsky.py::_calc_taub", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_taub", "text": "文件路径: pvlib/clearsky.py\ndef _calc_taub(w, aod700, p):\n    \"\"\"Calculate the taub coefficient\"\"\"\n    p0 = 101325.\n    tb1 = 1.82 + 0.056*np.log(w) + 0.0071*np.log(w)**2\n    tb0 = 0.33 + 0.045*np.log(w) + 0.0096*np.log(w)**2\n    tbp = 0.0089*w + 0.13\n\n    taub = tb1*aod700 + tb0 + tbp*np.log(p/p0)\n\n    return taub\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_taub", "w", "aod700", "p", "calculate", "the", "taub", "coefficient", "p0", "101325", "tb1", "1", "82", "0", "056", "np", "log", "w", "0", "0071", "np", "log", "w", "2", "tb0", "0", "33", "0", "045", "np", "log", "w", "0", "0096", "np", "log", "w", "2", "tbp", "0", "0089", "w", "0", "13", "taub", "tb1", "aod700", "tb0", "tbp", "np", "log", "p", "p0", "return", "taub"], "doc_len": 59}
{"doc_id": "pvlib/clearsky.py::_calc_b", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_b", "text": "文件路径: pvlib/clearsky.py\ndef _calc_b(w, aod700):\n    \"\"\"Calculate the b coefficient.\"\"\"\n\n    b1 = 0.00925*aod700**2 + 0.0148*aod700 - 0.0172\n    b0 = -0.7565*aod700**2 + 0.5057*aod700 + 0.4557\n\n    b = b1 * np.log(w) + b0\n\n    return b\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_b", "w", "aod700", "calculate", "the", "b", "coefficient", "b1", "0", "00925", "aod700", "2", "0", "0148", "aod700", "0", "0172", "b0", "0", "7565", "aod700", "2", "0", "5057", "aod700", "0", "4557", "b", "b1", "np", "log", "w", "b0", "return", "b"], "doc_len": 39}
{"doc_id": "pvlib/clearsky.py::_calc_taug", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_taug", "text": "文件路径: pvlib/clearsky.py\ndef _calc_taug(w, aod700, p):\n    \"\"\"Calculate the taug coefficient\"\"\"\n    p0 = 101325.\n    tg1 = 1.24 + 0.047*np.log(w) + 0.0061*np.log(w)**2\n    tg0 = 0.27 + 0.043*np.log(w) + 0.0090*np.log(w)**2\n    tgp = 0.0079*w + 0.1\n    taug = tg1*aod700 + tg0 + tgp*np.log(p/p0)\n\n    return taug\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_taug", "w", "aod700", "p", "calculate", "the", "taug", "coefficient", "p0", "101325", "tg1", "1", "24", "0", "047", "np", "log", "w", "0", "0061", "np", "log", "w", "2", "tg0", "0", "27", "0", "043", "np", "log", "w", "0", "0090", "np", "log", "w", "2", "tgp", "0", "0079", "w", "0", "1", "taug", "tg1", "aod700", "tg0", "tgp", "np", "log", "p", "p0", "return", "taug"], "doc_len": 59}
{"doc_id": "pvlib/clearsky.py::_calc_g", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_g", "text": "文件路径: pvlib/clearsky.py\ndef _calc_g(w, aod700):\n    \"\"\"Calculate the g coefficient.\"\"\"\n\n    g = -0.0147*np.log(w) - 0.3079*aod700**2 + 0.2846*aod700 + 0.3798\n\n    return g\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_g", "w", "aod700", "calculate", "the", "g", "coefficient", "g", "0", "0147", "np", "log", "w", "0", "3079", "aod700", "2", "0", "2846", "aod700", "0", "3798", "return", "g"], "doc_len": 28}
{"doc_id": "pvlib/clearsky.py::_calc_taud", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_taud", "text": "文件路径: pvlib/clearsky.py\ndef _calc_taud(w, aod700, p):\n    \"\"\"Calculate the taud coefficient.\"\"\"\n\n    # isscalar tests needed to ensure that the arrays will have the\n    # right shape in the tds calculation.\n    # there's probably a better way to do this.\n\n    if np.isscalar(w) and np.isscalar(aod700):\n        w = np.array([w])\n        aod700 = np.array([aod700])\n    elif np.isscalar(w):\n        w = np.full_like(aod700, w)\n    elif np.isscalar(aod700):\n        aod700 = np.full_like(w, aod700)\n\n    # set up nan-tolerant masks\n    aod700_lt_0p05 = np.full_like(aod700, False, dtype='bool')\n    np.less(aod700, 0.05, where=~np.isnan(aod700), out=aod700_lt_0p05)\n    aod700_mask = np.array([aod700_lt_0p05, ~aod700_lt_0p05], dtype=int)\n\n    # create tuples of coefficients for\n    # aod700 < 0.05, aod700 >= 0.05\n    td4 = 86*w - 13800, -0.21*w + 11.6\n    td3 = -3.11*w + 79.4, 0.27*w - 20.7\n    td2 = -0.23*w + 74.8, -0.134*w + 15.5\n    td1 = 0.092*w - 8.86, 0.0554*w - 5.71\n    td0 = 0.0042*w + 3.12, 0.0057*w + 2.94\n    tdp = -0.83*(1+aod700)**(-17.2), -0.71*(1+aod700)**(-15.0)\n\n    tds = (np.array([td0, td1, td2, td3, td4, tdp]) * aod700_mask).sum(axis=1)\n\n    p0 = 101325.\n    taud = (tds[4]*aod700**4 + tds[3]*aod700**3 + tds[2]*aod700**2 +\n            tds[1]*aod700 + tds[0] + tds[5]*np.log(p/p0))\n\n    # be polite about matching the output type to the input type(s)\n    if len(taud) == 1:\n        taud = taud[0]\n\n    return taud\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_taud", "w", "aod700", "p", "calculate", "the", "taud", "coefficient", "isscalar", "tests", "needed", "to", "ensure", "that", "the", "arrays", "will", "have", "the", "right", "shape", "in", "the", "tds", "calculation", "there", "s", "probably", "a", "better", "way", "to", "do", "this", "if", "np", "isscalar", "w", "and", "np", "isscalar", "aod700", "w", "np", "array", "w", "aod700", "np", "array", "aod700", "elif", "np", "isscalar", "w", "w", "np", "full_like", "aod700", "w", "elif", "np", "isscalar", "aod700", "aod700", "np", "full_like", "w", "aod700", "set", "up", "nan", "tolerant", "masks", "aod700_lt_0p05", "np", "full_like", "aod700", "false", "dtype", "bool", "np", "less", "aod700", "0", "05", "where", "np", "isnan", "aod700", "out", "aod700_lt_0p05", "aod700_mask", "np", "array", "aod700_lt_0p05", "aod700_lt_0p05", "dtype", "int", "create", "tuples", "of", "coefficients", "for", "aod700", "0", "05", "aod700", "0", "05", "td4", "86", "w", "13800", "0", "21", "w", "11", "6", "td3", "3", "11", "w", "79", "4", "0", "27", "w", "20", "7", "td2", "0", "23", "w", "74", "8", "0", "134", "w", "15", "5", "td1", "0", "092", "w", "8", "86", "0", "0554", "w", "5", "71", "td0", "0", "0042", "w", "3", "12", "0", "0057", "w", "2", "94", "tdp", "0", "83", "1", "aod700", "17", "2", "0", "71", "1", "aod700", "15", "0", "tds", "np", "array", "td0", "td1", "td2", "td3", "td4", "tdp", "aod700_mask", "sum", "axis", "1", "p0", "101325", "taud", "tds", "4", "aod700", "4", "tds", "3", "aod700", "3", "tds", "2", "aod700", "2", "tds", "1", "aod700", "tds", "0", "tds", "5", "np", "log", "p", "p0", "be", "polite", "about", "matching", "the", "output", "type", "to", "the", "input", "type", "s", "if", "len", "taud", "1", "taud", "taud", "0", "return", "taud"], "doc_len": 239}
{"doc_id": "pvlib/clearsky.py::_calc_d", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_d", "text": "文件路径: pvlib/clearsky.py\ndef _calc_d(aod700, p):\n    \"\"\"Calculate the d coefficient.\"\"\"\n\n    p0 = 101325.\n    dp = 1/(18 + 152*aod700)\n    d = -0.337*aod700**2 + 0.63*aod700 + 0.116 + dp*np.log(p/p0)\n\n    return d\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_d", "aod700", "p", "calculate", "the", "d", "coefficient", "p0", "101325", "dp", "1", "18", "152", "aod700", "d", "0", "337", "aod700", "2", "0", "63", "aod700", "0", "116", "dp", "np", "log", "p", "p0", "return", "d"], "doc_len": 35}
{"doc_id": "pvlib/clearsky.py::_calc_stats", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_calc_stats", "text": "文件路径: pvlib/clearsky.py\ndef _calc_stats(data, samples_per_window, sample_interval, H):\n    \"\"\" Calculates statistics for each window, used by Reno-style clear\n    sky detection functions. Does not return the line length statistic\n    which is provided by _calc_windowed_stat and _line_length.\n\n    Calculations are done on a sliding window defined by the Hankel matrix H.\n    Columns in H define the indices for each window. Each window contains\n    samples_per_window index values. The first window starts with index 0;\n    the last window ends at the last index position in data.\n\n    In the calculation of data_slope_nstd, a choice is made here where [1]_ is\n    ambiguous. data_slope_nstd is the standard deviation of slopes divided by\n    the mean GHI for each interval; see [1]_ Eq. 11. For intervals containing\n    e.g. 10 values, there are 9 slope values in the standard deviation, and the\n    mean is calculated using all 10 values. Eq. 11 in [1]_ is ambiguous if\n    the mean should be calculated using 9 points (left ends of each slope)\n    or all 10 points.\n\n    Parameters\n    ----------\n    data : Series\n    samples_per_window : int\n        Number of data points in each window\n    sample_interval : float\n        Time in minutes in each sample interval\n    H : 2D ndarray\n        Hankel matrix defining the indices for each window.\n\n    Returns\n    -------\n    data_mean : Series\n        mean of data in each window\n    data_max : Series\n        maximum of data in each window\n    data_slope_nstd : Series\n        standard deviation of difference between data points in each window\n    data_slope : Series\n        difference between successive data points\n\n    References\n    ----------\n    .. [1] Reno, M.J. and C.W. Hansen, \"Identification of periods of clear\n       sky irradiance in time series of GHI measurements\" Renewable Energy,\n       v90, p. 520-531, 2016.\n    \"\"\"\n\n    data_mean = data.values[H].mean(axis=0)\n    data_mean = _to_centered_series(data_mean, data.index, samples_per_window)\n    data_max = data.values[H].max(axis=0)\n    data_max = _to_centered_series(data_max, data.index, samples_per_window)\n    # shift to get forward difference, .diff() is backward difference instead\n    data_diff = data.diff().shift(-1)\n    data_slope = data_diff / sample_interval\n    data_slope_nstd = _slope_nstd_windowed(data_slope.values[:-1], data, H,\n                                           samples_per_window, sample_interval)\n    return data_mean, data_max, data_slope_nstd, data_slope\n", "tokens": ["pvlib", "clearsky", "py", "def", "_calc_stats", "data", "samples_per_window", "sample_interval", "h", "calculates", "statistics", "for", "each", "window", "used", "by", "reno", "style", "clear", "sky", "detection", "functions", "does", "not", "return", "the", "line", "length", "statistic", "which", "is", "provided", "by", "_calc_windowed_stat", "and", "_line_length", "calculations", "are", "done", "on", "a", "sliding", "window", "defined", "by", "the", "hankel", "matrix", "h", "columns", "in", "h", "define", "the", "indices", "for", "each", "window", "each", "window", "contains", "samples_per_window", "index", "values", "the", "first", "window", "starts", "with", "index", "0", "the", "last", "window", "ends", "at", "the", "last", "index", "position", "in", "data", "in", "the", "calculation", "of", "data_slope_nstd", "a", "choice", "is", "made", "here", "where", "1", "_", "is", "ambiguous", "data_slope_nstd", "is", "the", "standard", "deviation", "of", "slopes", "divided", "by", "the", "mean", "ghi", "for", "each", "interval", "see", "1", "_", "eq", "11", "for", "intervals", "containing", "e", "g", "10", "values", "there", "are", "9", "slope", "values", "in", "the", "standard", "deviation", "and", "the", "mean", "is", "calculated", "using", "all", "10", "values", "eq", "11", "in", "1", "_", "is", "ambiguous", "if", "the", "mean", "should", "be", "calculated", "using", "9", "points", "left", "ends", "of", "each", "slope", "or", "all", "10", "points", "parameters", "data", "series", "samples_per_window", "int", "number", "of", "data", "points", "in", "each", "window", "sample_interval", "float", "time", "in", "minutes", "in", "each", "sample", "interval", "h", "2d", "ndarray", "hankel", "matrix", "defining", "the", "indices", "for", "each", "window", "returns", "data_mean", "series", "mean", "of", "data", "in", "each", "window", "data_max", "series", "maximum", "of", "data", "in", "each", "window", "data_slope_nstd", "series", "standard", "deviation", "of", "difference", "between", "data", "points", "in", "each", "window", "data_slope", "series", "difference", "between", "successive", "data", "points", "references", "1", "reno", "m", "j", "and", "c", "w", "hansen", "identification", "of", "periods", "of", "clear", "sky", "irradiance", "in", "time", "series", "of", "ghi", "measurements", "renewable", "energy", "v90", "p", "520", "531", "2016", "data_mean", "data", "values", "h", "mean", "axis", "0", "data_mean", "_to_centered_series", "data_mean", "data", "index", "samples_per_window", "data_max", "data", "values", "h", "max", "axis", "0", "data_max", "_to_centered_series", "data_max", "data", "index", "samples_per_window", "shift", "to", "get", "forward", "difference", "diff", "is", "backward", "difference", "instead", "data_diff", "data", "diff", "shift", "1", "data_slope", "data_diff", "sample_interval", "data_slope_nstd", "_slope_nstd_windowed", "data_slope", "values", "1", "data", "h", "samples_per_window", "sample_interval", "return", "data_mean", "data_max", "data_slope_nstd", "data_slope"], "doc_len": 322}
{"doc_id": "pvlib/clearsky.py::_slope_nstd_windowed", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_slope_nstd_windowed", "text": "文件路径: pvlib/clearsky.py\ndef _slope_nstd_windowed(slopes, data, H, samples_per_window, sample_interval):\n    with np.errstate(divide='ignore', invalid='ignore'):\n        nstd = slopes[H[:-1, ]].std(ddof=1, axis=0) \\\n            / data.values[H].mean(axis=0)\n    return _to_centered_series(nstd, data.index, samples_per_window)\n", "tokens": ["pvlib", "clearsky", "py", "def", "_slope_nstd_windowed", "slopes", "data", "h", "samples_per_window", "sample_interval", "with", "np", "errstate", "divide", "ignore", "invalid", "ignore", "nstd", "slopes", "h", "1", "std", "ddof", "1", "axis", "0", "data", "values", "h", "mean", "axis", "0", "return", "_to_centered_series", "nstd", "data", "index", "samples_per_window"], "doc_len": 38}
{"doc_id": "pvlib/clearsky.py::_max_diff_windowed", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_max_diff_windowed", "text": "文件路径: pvlib/clearsky.py\ndef _max_diff_windowed(data, H, samples_per_window):\n    raw = np.diff(data)\n    raw = np.abs(raw[H[:-1, ]]).max(axis=0)\n    return _to_centered_series(raw, data.index, samples_per_window)\n", "tokens": ["pvlib", "clearsky", "py", "def", "_max_diff_windowed", "data", "h", "samples_per_window", "raw", "np", "diff", "data", "raw", "np", "abs", "raw", "h", "1", "max", "axis", "0", "return", "_to_centered_series", "raw", "data", "index", "samples_per_window"], "doc_len": 27}
{"doc_id": "pvlib/clearsky.py::_line_length_windowed", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_line_length_windowed", "text": "文件路径: pvlib/clearsky.py\ndef _line_length_windowed(data, H, samples_per_window,\n                          sample_interval):\n    raw = np.sqrt(np.diff(data)**2. + sample_interval**2.)\n    raw = np.sum(raw[H[:-1, ]], axis=0)\n    return _to_centered_series(raw, data.index, samples_per_window)\n", "tokens": ["pvlib", "clearsky", "py", "def", "_line_length_windowed", "data", "h", "samples_per_window", "sample_interval", "raw", "np", "sqrt", "np", "diff", "data", "2", "sample_interval", "2", "raw", "np", "sum", "raw", "h", "1", "axis", "0", "return", "_to_centered_series", "raw", "data", "index", "samples_per_window"], "doc_len": 32}
{"doc_id": "pvlib/clearsky.py::_to_centered_series", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_to_centered_series", "text": "文件路径: pvlib/clearsky.py\ndef _to_centered_series(vals, idx, samples_per_window):\n    vals = np.pad(vals, ((0, len(idx) - len(vals)),), mode='constant',\n                  constant_values=np.nan)\n    shift = samples_per_window // 2  # align = 'center' only\n    return pd.Series(index=idx, data=vals).shift(shift)\n", "tokens": ["pvlib", "clearsky", "py", "def", "_to_centered_series", "vals", "idx", "samples_per_window", "vals", "np", "pad", "vals", "0", "len", "idx", "len", "vals", "mode", "constant", "constant_values", "np", "nan", "shift", "samples_per_window", "2", "align", "center", "only", "return", "pd", "series", "index", "idx", "data", "vals", "shift", "shift"], "doc_len": 37}
{"doc_id": "pvlib/clearsky.py::_clear_sample_index", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "_clear_sample_index", "text": "文件路径: pvlib/clearsky.py\ndef _clear_sample_index(clear_windows, samples_per_window, align, H):\n    \"\"\"\n    Returns indices of clear samples in clear windows\n    \"\"\"\n    # H contains indices for each window, e.g. indices for the first window\n    # are in first column of H.\n    # clear_windows contains one boolean for each window and is aligned\n    # by 'align', default to center\n    # shift clear_windows.index to be aligned left (e.g. first value in the\n    # left-most position) to line up with the first column of H.\n\n    # commented if/else block for future align='left', 'right' capability\n    # if align == 'right':\n    #     shift = 1 - samples_per_window\n    # elif align == 'center':\n    #     shift = - (samples_per_window // 2)\n    # else:\n    #     shift = 0\n    shift = -(samples_per_window // 2)\n    idx = clear_windows.shift(shift)\n    # drop rows at the end corresponding to windows past the end of data\n    idx = idx.drop(clear_windows.index[1 - samples_per_window:])\n    idx = idx.astype(bool)  # shift changed type to object\n    clear_samples = np.unique(H[:, idx])\n    return clear_samples\n", "tokens": ["pvlib", "clearsky", "py", "def", "_clear_sample_index", "clear_windows", "samples_per_window", "align", "h", "returns", "indices", "of", "clear", "samples", "in", "clear", "windows", "h", "contains", "indices", "for", "each", "window", "e", "g", "indices", "for", "the", "first", "window", "are", "in", "first", "column", "of", "h", "clear_windows", "contains", "one", "boolean", "for", "each", "window", "and", "is", "aligned", "by", "align", "default", "to", "center", "shift", "clear_windows", "index", "to", "be", "aligned", "left", "e", "g", "first", "value", "in", "the", "left", "most", "position", "to", "line", "up", "with", "the", "first", "column", "of", "h", "commented", "if", "else", "block", "for", "future", "align", "left", "right", "capability", "if", "align", "right", "shift", "1", "samples_per_window", "elif", "align", "center", "shift", "samples_per_window", "2", "else", "shift", "0", "shift", "samples_per_window", "2", "idx", "clear_windows", "shift", "shift", "drop", "rows", "at", "the", "end", "corresponding", "to", "windows", "past", "the", "end", "of", "data", "idx", "idx", "drop", "clear_windows", "index", "1", "samples_per_window", "idx", "idx", "astype", "bool", "shift", "changed", "type", "to", "object", "clear_samples", "np", "unique", "h", "idx", "return", "clear_samples"], "doc_len": 144}
{"doc_id": "pvlib/clearsky.py::detect_clearsky", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "detect_clearsky", "text": "文件路径: pvlib/clearsky.py\ndef detect_clearsky(measured, clearsky, times=None, window_length=10,\n                    mean_diff=75, max_diff=75,\n                    lower_line_length=-5, upper_line_length=10,\n                    var_diff=0.005, slope_dev=8, max_iterations=20,\n                    return_components=False):\n    \"\"\"\n    Detects clear sky times according to the algorithm developed by Reno\n    and Hansen for GHI measurements. The algorithm [1]_ was designed and\n    validated for analyzing GHI time series only. Users may attempt to\n    apply it to other types of time series data using different filter\n    settings, but should be skeptical of the results.\n\n    The algorithm detects clear sky times by comparing statistics for a\n    measured time series and an expected clearsky time series.\n    Statistics are calculated using a sliding time window (e.g., 10\n    minutes). An iterative algorithm identifies clear periods, uses the\n    identified periods to estimate bias in the clearsky data, scales the\n    clearsky data and repeats.\n\n    Clear times are identified by meeting 5 criteria. Default values for\n    these thresholds are appropriate for 10 minute windows of 1 minute\n    GHI data.\n\n    Parameters\n    ----------\n    measured : array or Series\n        Time series of measured GHI. [W/m2]\n    clearsky : array or Series\n        Time series of the expected clearsky GHI. [W/m2]\n    times : DatetimeIndex or None, default None.\n        Times of measured and clearsky values. If None the index of measured\n        will be used.\n    window_length : int, default 10\n        Length of sliding time window in minutes. Must be greater than 2\n        periods.\n    mean_diff : float, default 75\n        Threshold value for agreement between mean values of measured\n        and clearsky in each interval, see Eq. 6 in [1]. [W/m2]\n    max_diff : float, default 75\n        Threshold value for agreement between maxima of measured and\n        clearsky values in each interval, see Eq. 7 in [1]. [W/m2]\n    lower_line_length : float, default -5\n        Lower limit of line length criterion from Eq. 8 in [1].\n        Criterion satisfied when lower_line_length < line length difference\n        < upper_line_length.\n    upper_line_length : float, default 10\n        Upper limit of line length criterion from Eq. 8 in [1].\n    var_diff : float, default 0.005\n        Threshold value in Hz for the agreement between normalized\n        standard deviations of rate of change in irradiance, see Eqs. 9\n        through 11 in [1].\n    slope_dev : float, default 8\n        Threshold value for agreement between the largest magnitude of\n        change in successive values, see Eqs. 12 through 14 in [1].\n    max_iterations : int, default 20\n        Maximum number of times to apply a different scaling factor to\n        the clearsky and redetermine clear_samples. Must be 1 or larger.\n    return_components : bool, default False\n        Controls if additional output should be returned. See below.\n\n    Returns\n    -------\n    clear_samples : array or Series\n        Boolean array or Series of whether or not the given time is\n        clear. Return type is the same as the input type.\n\n    components : OrderedDict, optional\n        Dict of arrays of whether or not the given time window is clear\n        for each condition. Only provided if return_components is True.\n\n    alpha : scalar, optional\n        Scaling factor applied to the clearsky_ghi to obtain the\n        detected clear_samples. Only provided if return_components is\n        True.\n\n    Raises\n    ------\n    ValueError\n        If measured is not a Series and times is not provided\n    NotImplementedError\n        If timestamps are not equally spaced\n\n    References\n    ----------\n    .. [1] Reno, M.J. and C.W. Hansen, \"Identification of periods of clear\n       sky irradiance in time series of GHI measurements\" Renewable Energy,\n       v90, p. 520-531, 2016.\n\n    Notes\n    -----\n    Initial implementation in MATLAB by Matthew Reno. Modifications for\n    computational efficiency by Joshua Patrick and Curtis Martin. Ported\n    to Python by Will Holmgren, Tony Lorenzo, and Cliff Hansen.\n\n    Differences from MATLAB version:\n\n        * no support for unequal times\n        * automatically determines sample_interval\n        * requires a reference clear sky series instead calculating one\n          from a user supplied location and UTCoffset\n        * parameters are controllable via keyword arguments\n        * option to return individual test components and clearsky scaling\n          parameter\n        * uses centered windows (Matlab function uses left-aligned windows)\n    \"\"\"\n\n    if times is None:\n        try:\n            times = measured.index\n        except AttributeError:\n            raise ValueError(\"times is required when measured is not a Series\")\n\n    # be polite about returning the same type as was input\n    ispandas = isinstance(measured, pd.Series)\n\n    # for internal use, need a Series\n    if not ispandas:\n        meas = pd.Series(measured, index=times)\n    else:\n        meas = measured\n\n    if not isinstance(clearsky, pd.Series):\n        clear = pd.Series(clearsky, index=times)\n    else:\n        clear = clearsky\n\n    sample_interval, samples_per_window = \\\n        tools._get_sample_intervals(times, window_length)\n\n    # generate matrix of integers for creating windows with indexing\n    H = hankel(np.arange(samples_per_window),\n               np.arange(samples_per_window-1, len(times)))\n\n    # calculate measurement statistics\n    meas_mean, meas_max, meas_slope_nstd, meas_slope = _calc_stats(\n        meas, samples_per_window, sample_interval, H)\n    meas_line_length = _line_length_windowed(\n        meas, H, samples_per_window, sample_interval)\n\n    # calculate clear sky statistics\n    clear_mean, clear_max, _, clear_slope = _calc_stats(\n        clear, samples_per_window, sample_interval, H)\n\n    # find a scaling factor for the clear sky time series that minimizes the\n    # RMSE between the clear times identified in the measured data and the\n    # scaled clear sky time series. Optimization to determine the scaling\n    # factor considers all identified clear times, which is different from [1]\n    # where the scaling factor was determined from clear times on days with\n    # at least 50% of the day being identified as clear.\n    alpha = 1\n    for iteration in range(max_iterations):\n        scaled_clear = alpha * clear\n        clear_line_length = _line_length_windowed(\n            scaled_clear, H, samples_per_window, sample_interval)\n\n        line_diff = meas_line_length - clear_line_length\n        slope_max_diff = _max_diff_windowed(\n            meas - scaled_clear, H, samples_per_window)\n        # evaluate comparison criteria\n        c1 = np.abs(meas_mean - alpha*clear_mean) < mean_diff\n        c2 = np.abs(meas_max - alpha*clear_max) < max_diff\n        c3 = (line_diff > lower_line_length) & (line_diff < upper_line_length)\n        c4 = meas_slope_nstd < var_diff\n        c5 = slope_max_diff < slope_dev\n        c6 = (clear_mean != 0) & ~np.isnan(clear_mean)\n        clear_windows = c1 & c2 & c3 & c4 & c5 & c6\n\n        # create array to return\n        clear_samples = np.full_like(meas, False, dtype='bool')\n        # find the samples contained in any window classified as clear\n        idx = _clear_sample_index(clear_windows, samples_per_window, 'center',\n                                  H)\n        clear_samples[idx] = True\n\n        # find a new alpha\n        previous_alpha = alpha\n        clear_meas = meas[clear_samples]\n        clear_clear = clear[clear_samples]\n\n        def rmse(alpha):\n            return np.sqrt(np.mean((clear_meas - alpha*clear_clear)**2))\n\n        alpha = minimize_scalar(rmse).x\n        if round(alpha*10000) == round(previous_alpha*10000):\n            break\n    else:\n        import warnings\n        warnings.warn('rescaling failed to converge after %s iterations'\n                      % max_iterations, RuntimeWarning)\n\n    # be polite about returning the same type as was input\n    if ispandas:\n        clear_samples = pd.Series(clear_samples, index=times)\n\n    if return_components:\n        components = OrderedDict()\n        components['mean_diff_flag'] = c1\n        components['max_diff_flag'] = c2\n        components['line_length_flag'] = c3\n        components['slope_nstd_flag'] = c4\n        components['slope_max_flag'] = c5\n        components['mean_nan_flag'] = c6\n        components['windows'] = clear_windows\n\n        components['mean_diff'] = np.abs(meas_mean - alpha * clear_mean)\n        components['max_diff'] = np.abs(meas_max - alpha * clear_max)\n        components['line_length'] = meas_line_length - clear_line_length\n        components['slope_nstd'] = meas_slope_nstd\n        components['slope_max'] = slope_max_diff\n\n        return clear_samples, components, alpha\n    else:\n        return clear_samples\n", "tokens": ["pvlib", "clearsky", "py", "def", "detect_clearsky", "measured", "clearsky", "times", "none", "window_length", "10", "mean_diff", "75", "max_diff", "75", "lower_line_length", "5", "upper_line_length", "10", "var_diff", "0", "005", "slope_dev", "8", "max_iterations", "20", "return_components", "false", "detects", "clear", "sky", "times", "according", "to", "the", "algorithm", "developed", "by", "reno", "and", "hansen", "for", "ghi", "measurements", "the", "algorithm", "1", "_", "was", "designed", "and", "validated", "for", "analyzing", "ghi", "time", "series", "only", "users", "may", "attempt", "to", "apply", "it", "to", "other", "types", "of", "time", "series", "data", "using", "different", "filter", "settings", "but", "should", "be", "skeptical", "of", "the", "results", "the", "algorithm", "detects", "clear", "sky", "times", "by", "comparing", "statistics", "for", "a", "measured", "time", "series", "and", "an", "expected", "clearsky", "time", "series", "statistics", "are", "calculated", "using", "a", "sliding", "time", "window", "e", "g", "10", "minutes", "an", "iterative", "algorithm", "identifies", "clear", "periods", "uses", "the", "identified", "periods", "to", "estimate", "bias", "in", "the", "clearsky", "data", "scales", "the", "clearsky", "data", "and", "repeats", "clear", "times", "are", "identified", "by", "meeting", "5", "criteria", "default", "values", "for", "these", "thresholds", "are", "appropriate", "for", "10", "minute", "windows", "of", "1", "minute", "ghi", "data", "parameters", "measured", "array", "or", "series", "time", "series", "of", "measured", "ghi", "w", "m2", "clearsky", "array", "or", "series", "time", "series", "of", "the", "expected", "clearsky", "ghi", "w", "m2", "times", "datetimeindex", "or", "none", "default", "none", "times", "of", "measured", "and", "clearsky", "values", "if", "none", "the", "index", "of", "measured", "will", "be", "used", "window_length", "int", "default", "10", "length", "of", "sliding", "time", "window", "in", "minutes", "must", "be", "greater", "than", "2", "periods", "mean_diff", "float", "default", "75", "threshold", "value", "for", "agreement", "between", "mean", "values", "of", "measured", "and", "clearsky", "in", "each", "interval", "see", "eq", "6", "in", "1", "w", "m2", "max_diff", "float", "default", "75", "threshold", "value", "for", "agreement", "between", "maxima", "of", "measured", "and", "clearsky", "values", "in", "each", "interval", "see", "eq", "7", "in", "1", "w", "m2", "lower_line_length", "float", "default", "5", "lower", "limit", "of", "line", "length", "criterion", "from", "eq", "8", "in", "1", "criterion", "satisfied", "when", "lower_line_length", "line", "length", "difference", "upper_line_length", "upper_line_length", "float", "default", "10", "upper", "limit", "of", "line", "length", "criterion", "from", "eq", "8", "in", "1", "var_diff", "float", "default", "0", "005", "threshold", "value", "in", "hz", "for", "the", "agreement", "between", "normalized", "standard", "deviations", "of", "rate", "of", "change", "in", "irradiance", "see", "eqs", "9", "through", "11", "in", "1", "slope_dev", "float", "default", "8", "threshold", "value", "for", "agreement", "between", "the", "largest", "magnitude", "of", "change", "in", "successive", "values", "see", "eqs", "12", "through", "14", "in", "1", "max_iterations", "int", "default", "20", "maximum", "number", "of", "times", "to", "apply", "a", "different", "scaling", "factor", "to", "the", "clearsky", "and", "redetermine", "clear_samples", "must", "be", "1", "or", "larger", "return_components", "bool", "default", "false", "controls", "if", "additional", "output", "should", "be", "returned", "see", "below", "returns", "clear_samples", "array", "or", "series", "boolean", "array", "or", "series", "of", "whether", "or", "not", "the", "given", "time", "is", "clear", "return", "type", "is", "the", "same", "as", "the", "input", "type", "components", "ordereddict", "optional", "dict", "of", "arrays", "of", "whether", "or", "not", "the", "given", "time", "window", "is", "clear", "for", "each", "condition", "only", "provided", "if", "return_components", "is", "true", "alpha", "scalar", "optional", "scaling", "factor", "applied", "to", "the", "clearsky_ghi", "to", "obtain", "the", "detected", "clear_samples", "only", "provided", "if", "return_components", "is", "true", "raises", "valueerror", "if", "measured", "is", "not", "a", "series", "and", "times", "is", "not", "provided", "notimplementederror", "if", "timestamps", "are", "not", "equally", "spaced", "references", "1", "reno", "m", "j", "and", "c", "w", "hansen", "identification", "of", "periods", "of", "clear", "sky", "irradiance", "in", "time", "series", "of", "ghi", "measurements", "renewable", "energy", "v90", "p", "520", "531", "2016", "notes", "initial", "implementation", "in", "matlab", "by", "matthew", "reno", "modifications", "for", "computational", "efficiency", "by", "joshua", "patrick", "and", "curtis", "martin", "ported", "to", "python", "by", "will", "holmgren", "tony", "lorenzo", "and", "cliff", "hansen", "differences", "from", "matlab", "version", "no", "support", "for", "unequal", "times", "automatically", "determines", "sample_interval", "requires", "a", "reference", "clear", "sky", "series", "instead", "calculating", "one", "from", "a", "user", "supplied", "location", "and", "utcoffset", "parameters", "are", "controllable", "via", "keyword", "arguments", "option", "to", "return", "individual", "test", "components", "and", "clearsky", "scaling", "parameter", "uses", "centered", "windows", "matlab", "function", "uses", "left", "aligned", "windows", "if", "times", "is", "none", "try", "times", "measured", "index", "except", "attributeerror", "raise", "valueerror", "times", "is", "required", "when", "measured", "is", "not", "a", "series", "be", "polite", "about", "returning", "the", "same", "type", "as", "was", "input", "ispandas", "isinstance", "measured", "pd", "series", "for", "internal", "use", "need", "a", "series", "if", "not", "ispandas", "meas", "pd", "series", "measured", "index", "times", "else", "meas", "measured", "if", "not", "isinstance", "clearsky", "pd", "series", "clear", "pd", "series", "clearsky", "index", "times", "else", "clear", "clearsky", "sample_interval", "samples_per_window", "tools", "_get_sample_intervals", "times", "window_length", "generate", "matrix", "of", "integers", "for", "creating", "windows", "with", "indexing", "h", "hankel", "np", "arange", "samples_per_window", "np", "arange", "samples_per_window", "1", "len", "times", "calculate", "measurement", "statistics", "meas_mean", "meas_max", "meas_slope_nstd", "meas_slope", "_calc_stats", "meas", "samples_per_window", "sample_interval", "h", "meas_line_length", "_line_length_windowed", "meas", "h", "samples_per_window", "sample_interval", "calculate", "clear", "sky", "statistics", "clear_mean", "clear_max", "_", "clear_slope", "_calc_stats", "clear", "samples_per_window", "sample_interval", "h", "find", "a", "scaling", "factor", "for", "the", "clear", "sky", "time", "series", "that", "minimizes", "the", "rmse", "between", "the", "clear", "times", "identified", "in", "the", "measured", "data", "and", "the", "scaled", "clear", "sky", "time", "series", "optimization", "to", "determine", "the", "scaling", "factor", "considers", "all", "identified", "clear", "times", "which", "is", "different", "from", "1", "where", "the", "scaling", "factor", "was", "determined", "from", "clear", "times", "on", "days", "with", "at", "least", "50", "of", "the", "day", "being", "identified", "as", "clear", "alpha", "1", "for", "iteration", "in", "range", "max_iterations", "scaled_clear", "alpha", "clear", "clear_line_length", "_line_length_windowed", "scaled_clear", "h", "samples_per_window", "sample_interval", "line_diff", "meas_line_length", "clear_line_length", "slope_max_diff", "_max_diff_windowed", "meas", "scaled_clear", "h", "samples_per_window", "evaluate", "comparison", "criteria", "c1", "np", "abs", "meas_mean", "alpha", "clear_mean", "mean_diff", "c2", "np", "abs", "meas_max", "alpha", "clear_max", "max_diff", "c3", "line_diff", "lower_line_length", "line_diff", "upper_line_length", "c4", "meas_slope_nstd", "var_diff", "c5", "slope_max_diff", "slope_dev", "c6", "clear_mean", "0", "np", "isnan", "clear_mean", "clear_windows", "c1", "c2", "c3", "c4", "c5", "c6", "create", "array", "to", "return", "clear_samples", "np", "full_like", "meas", "false", "dtype", "bool", "find", "the", "samples", "contained", "in", "any", "window", "classified", "as", "clear", "idx", "_clear_sample_index", "clear_windows", "samples_per_window", "center", "h", "clear_samples", "idx", "true", "find", "a", "new", "alpha", "previous_alpha", "alpha", "clear_meas", "meas", "clear_samples", "clear_clear", "clear", "clear_samples", "def", "rmse", "alpha", "return", "np", "sqrt", "np", "mean", "clear_meas", "alpha", "clear_clear", "2", "alpha", "minimize_scalar", "rmse", "x", "if", "round", "alpha", "10000", "round", "previous_alpha", "10000", "break", "else", "import", "warnings", "warnings", "warn", "rescaling", "failed", "to", "converge", "after", "s", "iterations", "max_iterations", "runtimewarning", "be", "polite", "about", "returning", "the", "same", "type", "as", "was", "input", "if", "ispandas", "clear_samples", "pd", "series", "clear_samples", "index", "times", "if", "return_components", "components", "ordereddict", "components", "mean_diff_flag", "c1", "components", "max_diff_flag", "c2", "components", "line_length_flag", "c3", "components", "slope_nstd_flag", "c4", "components", "slope_max_flag", "c5", "components", "mean_nan_flag", "c6", "components", "windows", "clear_windows", "components", "mean_diff", "np", "abs", "meas_mean", "alpha", "clear_mean", "components", "max_diff", "np", "abs", "meas_max", "alpha", "clear_max", "components", "line_length", "meas_line_length", "clear_line_length", "components", "slope_nstd", "meas_slope_nstd", "components", "slope_max", "slope_max_diff", "return", "clear_samples", "components", "alpha", "else", "return", "clear_samples"], "doc_len": 1020}
{"doc_id": "pvlib/clearsky.py::bird", "file_path": "pvlib/clearsky.py", "class_name": null, "func_name": "bird", "text": "文件路径: pvlib/clearsky.py\ndef bird(zenith, airmass_relative, aod380, aod500, precipitable_water,\n         ozone=0.3, pressure=101325., dni_extra=1364., asymmetry=0.85,\n         albedo=0.2):\n    \"\"\"\n    Bird Simple Clear Sky Broadband Solar Radiation Model\n\n    Based on NREL Excel implementation by Daryl R. Myers [1, 2].\n\n    Bird and Hulstrom define the zenith as the \"angle between a line to\n    the sun and the local zenith\". There is no distinction in the paper\n    between solar zenith and apparent (or refracted) zenith, but the\n    relative airmass is defined using the Kasten 1966 expression, which\n    requires apparent zenith. Although the formulation for calculated\n    zenith is never explicitly defined in the report, since the purpose\n    was to compare existing clear sky models with \"rigorous radiative\n    transfer models\" (RTM) it is possible that apparent zenith was\n    obtained as output from the RTM. However, the implentation presented\n    in PVLIB is tested against the NREL Excel implementation by Daryl\n    Myers which uses an analytical expression for solar zenith instead\n    of apparent zenith.\n\n    Parameters\n    ----------\n    zenith : numeric\n        Solar or apparent zenith angle in degrees - see note above\n    airmass_relative : numeric\n        Relative airmass\n    aod380 : numeric\n        Aerosol optical depth [cm] measured at 380[nm]\n    aod500 : numeric\n        Aerosol optical depth [cm] measured at 500[nm]\n    precipitable_water : numeric\n        Precipitable water [cm]\n    ozone : numeric\n        Atmospheric ozone [cm], defaults to 0.3[cm]\n    pressure : numeric\n        Ambient pressure [Pa], defaults to 101325[Pa]\n    dni_extra : numeric\n        Extraterrestrial radiation [W/m^2], defaults to 1364[W/m^2]\n    asymmetry : numeric\n        Asymmetry factor, defaults to 0.85\n    albedo : numeric, default 0.2\n        Ground surface albedo. [unitless]\n\n    Returns\n    -------\n    clearsky : DataFrame (if Series input) or OrderedDict of arrays\n        DataFrame/OrderedDict contains the columns/keys\n        ``'dhi', 'dni', 'ghi', 'direct_horizontal'`` in  [W/m^2].\n\n    See also\n    --------\n    pvlib.atmosphere.bird_hulstrom80_aod_bb\n    pvlib.atmosphere.get_relative_airmass\n\n    References\n    ----------\n    .. [1] R. E. Bird and R. L Hulstrom, \"A Simplified Clear Sky model for\n       Direct and Diffuse Insolation on Horizontal Surfaces\" SERI Technical\n       Report SERI/TR-642-761, Feb 1981. Solar Energy Research Institute,\n       Golden, CO.\n\n    .. [2] Daryl R. Myers, \"Solar Radiation: Practical Modeling for Renewable\n       Energy Applications\", pp. 46-51 CRC Press (2013)\n\n    .. [3] `NREL Bird Clear Sky Model <http://rredc.nrel.gov/solar/models/\n       clearsky/>`_\n\n    .. [4] `SERI/TR-642-761 <http://rredc.nrel.gov/solar/pubs/pdfs/\n       tr-642-761.pdf>`_\n\n    .. [5] `Error Reports <http://rredc.nrel.gov/solar/models/clearsky/\n       error_reports.html>`_\n    \"\"\"\n    etr = dni_extra  # extraradiation\n    ze_rad = np.deg2rad(zenith)  # zenith in radians\n    airmass = airmass_relative\n    # Bird clear sky model\n    am_press = atmosphere.get_absolute_airmass(airmass, pressure)\n    t_rayleigh = (\n        np.exp(-0.0903 * am_press ** 0.84 * (\n            1.0 + am_press - am_press ** 1.01\n        ))\n    )\n    am_o3 = ozone*airmass\n    t_ozone = (\n        1.0 - 0.1611 * am_o3 * (1.0 + 139.48 * am_o3) ** -0.3034 -\n        0.002715 * am_o3 / (1.0 + 0.044 * am_o3 + 0.0003 * am_o3 ** 2.0)\n    )\n    t_gases = np.exp(-0.0127 * am_press ** 0.26)\n    am_h2o = airmass * precipitable_water\n    t_water = (\n        1.0 - 2.4959 * am_h2o / (\n            (1.0 + 79.034 * am_h2o) ** 0.6828 + 6.385 * am_h2o\n        )\n    )\n    bird_huldstrom = atmosphere.bird_hulstrom80_aod_bb(aod380, aod500)\n    t_aerosol = np.exp(\n        -(bird_huldstrom ** 0.873) *\n        (1.0 + bird_huldstrom - bird_huldstrom ** 0.7088) * airmass ** 0.9108\n    )\n    taa = 1.0 - 0.1 * (1.0 - airmass + airmass ** 1.06) * (1.0 - t_aerosol)\n    rs = 0.0685 + (1.0 - asymmetry) * (1.0 - t_aerosol / taa)\n    id_ = 0.9662 * etr * t_aerosol * t_water * t_gases * t_ozone * t_rayleigh\n    ze_cos = np.where(zenith < 90, np.cos(ze_rad), 0.0)\n    id_nh = id_ * ze_cos\n    ias = (\n        etr * ze_cos * 0.79 * t_ozone * t_gases * t_water * taa *\n        (0.5 * (1.0 - t_rayleigh) + asymmetry * (1.0 - (t_aerosol / taa))) / (\n            1.0 - airmass + airmass ** 1.02\n        )\n    )\n    gh = (id_nh + ias) / (1.0 - albedo * rs)\n    diffuse_horiz = gh - id_nh\n    # TODO: be DRY, use decorator to wrap methods that need to return either\n    # OrderedDict or DataFrame instead of repeating this boilerplate code\n    irrads = OrderedDict()\n    irrads['direct_horizontal'] = id_nh\n    irrads['ghi'] = gh\n    irrads['dni'] = id_\n    irrads['dhi'] = diffuse_horiz\n    if isinstance(irrads['dni'], pd.Series):\n        irrads = pd.DataFrame.from_dict(irrads)\n    return irrads\n", "tokens": ["pvlib", "clearsky", "py", "def", "bird", "zenith", "airmass_relative", "aod380", "aod500", "precipitable_water", "ozone", "0", "3", "pressure", "101325", "dni_extra", "1364", "asymmetry", "0", "85", "albedo", "0", "2", "bird", "simple", "clear", "sky", "broadband", "solar", "radiation", "model", "based", "on", "nrel", "excel", "implementation", "by", "daryl", "r", "myers", "1", "2", "bird", "and", "hulstrom", "define", "the", "zenith", "as", "the", "angle", "between", "a", "line", "to", "the", "sun", "and", "the", "local", "zenith", "there", "is", "no", "distinction", "in", "the", "paper", "between", "solar", "zenith", "and", "apparent", "or", "refracted", "zenith", "but", "the", "relative", "airmass", "is", "defined", "using", "the", "kasten", "1966", "expression", "which", "requires", "apparent", "zenith", "although", "the", "formulation", "for", "calculated", "zenith", "is", "never", "explicitly", "defined", "in", "the", "report", "since", "the", "purpose", "was", "to", "compare", "existing", "clear", "sky", "models", "with", "rigorous", "radiative", "transfer", "models", "rtm", "it", "is", "possible", "that", "apparent", "zenith", "was", "obtained", "as", "output", "from", "the", "rtm", "however", "the", "implentation", "presented", "in", "pvlib", "is", "tested", "against", "the", "nrel", "excel", "implementation", "by", "daryl", "myers", "which", "uses", "an", "analytical", "expression", "for", "solar", "zenith", "instead", "of", "apparent", "zenith", "parameters", "zenith", "numeric", "solar", "or", "apparent", "zenith", "angle", "in", "degrees", "see", "note", "above", "airmass_relative", "numeric", "relative", "airmass", "aod380", "numeric", "aerosol", "optical", "depth", "cm", "measured", "at", "380", "nm", "aod500", "numeric", "aerosol", "optical", "depth", "cm", "measured", "at", "500", "nm", "precipitable_water", "numeric", "precipitable", "water", "cm", "ozone", "numeric", "atmospheric", "ozone", "cm", "defaults", "to", "0", "3", "cm", "pressure", "numeric", "ambient", "pressure", "pa", "defaults", "to", "101325", "pa", "dni_extra", "numeric", "extraterrestrial", "radiation", "w", "m", "2", "defaults", "to", "1364", "w", "m", "2", "asymmetry", "numeric", "asymmetry", "factor", "defaults", "to", "0", "85", "albedo", "numeric", "default", "0", "2", "ground", "surface", "albedo", "unitless", "returns", "clearsky", "dataframe", "if", "series", "input", "or", "ordereddict", "of", "arrays", "dataframe", "ordereddict", "contains", "the", "columns", "keys", "dhi", "dni", "ghi", "direct_horizontal", "in", "w", "m", "2", "see", "also", "pvlib", "atmosphere", "bird_hulstrom80_aod_bb", "pvlib", "atmosphere", "get_relative_airmass", "references", "1", "r", "e", "bird", "and", "r", "l", "hulstrom", "a", "simplified", "clear", "sky", "model", "for", "direct", "and", "diffuse", "insolation", "on", "horizontal", "surfaces", "seri", "technical", "report", "seri", "tr", "642", "761", "feb", "1981", "solar", "energy", "research", "institute", "golden", "co", "2", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "pp", "46", "51", "crc", "press", "2013", "3", "nrel", "bird", "clear", "sky", "model", "http", "rredc", "nrel", "gov", "solar", "models", "clearsky", "_", "4", "seri", "tr", "642", "761", "http", "rredc", "nrel", "gov", "solar", "pubs", "pdfs", "tr", "642", "761", "pdf", "_", "5", "error", "reports", "http", "rredc", "nrel", "gov", "solar", "models", "clearsky", "error_reports", "html", "_", "etr", "dni_extra", "extraradiation", "ze_rad", "np", "deg2rad", "zenith", "zenith", "in", "radians", "airmass", "airmass_relative", "bird", "clear", "sky", "model", "am_press", "atmosphere", "get_absolute_airmass", "airmass", "pressure", "t_rayleigh", "np", "exp", "0", "0903", "am_press", "0", "84", "1", "0", "am_press", "am_press", "1", "01", "am_o3", "ozone", "airmass", "t_ozone", "1", "0", "0", "1611", "am_o3", "1", "0", "139", "48", "am_o3", "0", "3034", "0", "002715", "am_o3", "1", "0", "0", "044", "am_o3", "0", "0003", "am_o3", "2", "0", "t_gases", "np", "exp", "0", "0127", "am_press", "0", "26", "am_h2o", "airmass", "precipitable_water", "t_water", "1", "0", "2", "4959", "am_h2o", "1", "0", "79", "034", "am_h2o", "0", "6828", "6", "385", "am_h2o", "bird_huldstrom", "atmosphere", "bird_hulstrom80_aod_bb", "aod380", "aod500", "t_aerosol", "np", "exp", "bird_huldstrom", "0", "873", "1", "0", "bird_huldstrom", "bird_huldstrom", "0", "7088", "airmass", "0", "9108", "taa", "1", "0", "0", "1", "1", "0", "airmass", "airmass", "1", "06", "1", "0", "t_aerosol", "rs", "0", "0685", "1", "0", "asymmetry", "1", "0", "t_aerosol", "taa", "id_", "0", "9662", "etr", "t_aerosol", "t_water", "t_gases", "t_ozone", "t_rayleigh", "ze_cos", "np", "where", "zenith", "90", "np", "cos", "ze_rad", "0", "0", "id_nh", "id_", "ze_cos", "ias", "etr", "ze_cos", "0", "79", "t_ozone", "t_gases", "t_water", "taa", "0", "5", "1", "0", "t_rayleigh", "asymmetry", "1", "0", "t_aerosol", "taa", "1", "0", "airmass", "airmass", "1", "02", "gh", "id_nh", "ias", "1", "0", "albedo", "rs", "diffuse_horiz", "gh", "id_nh", "todo", "be", "dry", "use", "decorator", "to", "wrap", "methods", "that", "need", "to", "return", "either", "ordereddict", "or", "dataframe", "instead", "of", "repeating", "this", "boilerplate", "code", "irrads", "ordereddict", "irrads", "direct_horizontal", "id_nh", "irrads", "ghi", "gh", "irrads", "dni", "id_", "irrads", "dhi", "diffuse_horiz", "if", "isinstance", "irrads", "dni", "pd", "series", "irrads", "pd", "dataframe", "from_dict", "irrads", "return", "irrads"], "doc_len": 624}
{"doc_id": "pvlib/forecast.py::ForecastModel.__init__", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def __init__(self, model_type, model_name, set_type, vert_level=None):\n        self.model_type = model_type\n        self.model_name = model_name\n        self.set_type = set_type\n        self.connected = False\n        self.vert_level = vert_level\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "__init__", "self", "model_type", "model_name", "set_type", "vert_level", "none", "self", "model_type", "model_type", "self", "model_name", "model_name", "self", "set_type", "set_type", "self", "connected", "false", "self", "vert_level", "vert_level"], "doc_len": 27}
{"doc_id": "pvlib/forecast.py::ForecastModel.connect_to_catalog", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "connect_to_catalog", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def connect_to_catalog(self):\n        self.catalog = TDSCatalog(self.catalog_url)\n        self.fm_models = TDSCatalog(\n            self.catalog.catalog_refs[self.model_type].href)\n        self.fm_models_list = sorted(list(self.fm_models.catalog_refs.keys()))\n\n        try:\n            model_url = self.fm_models.catalog_refs[self.model_name].href\n        except ParseError:\n            raise ParseError(self.model_name + ' model may be unavailable.')\n\n        try:\n            self.model = TDSCatalog(model_url)\n        except HTTPError:\n            try:\n                self.model = TDSCatalog(model_url)\n            except HTTPError:\n                raise HTTPError(self.model_name + ' model may be unavailable.')\n\n        self.datasets_list = list(self.model.datasets.keys())\n        self.set_dataset()\n        self.connected = True\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "connect_to_catalog", "self", "self", "catalog", "tdscatalog", "self", "catalog_url", "self", "fm_models", "tdscatalog", "self", "catalog", "catalog_refs", "self", "model_type", "href", "self", "fm_models_list", "sorted", "list", "self", "fm_models", "catalog_refs", "keys", "try", "model_url", "self", "fm_models", "catalog_refs", "self", "model_name", "href", "except", "parseerror", "raise", "parseerror", "self", "model_name", "model", "may", "be", "unavailable", "try", "self", "model", "tdscatalog", "model_url", "except", "httperror", "try", "self", "model", "tdscatalog", "model_url", "except", "httperror", "raise", "httperror", "self", "model_name", "model", "may", "be", "unavailable", "self", "datasets_list", "list", "self", "model", "datasets", "keys", "self", "set_dataset", "self", "connected", "true"], "doc_len": 81}
{"doc_id": "pvlib/forecast.py::ForecastModel.__repr__", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "__repr__", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def __repr__(self):\n        return f'{self.model_name}, {self.set_type}'\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "__repr__", "self", "return", "f", "self", "model_name", "self", "set_type"], "doc_len": 13}
{"doc_id": "pvlib/forecast.py::ForecastModel.set_dataset", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "set_dataset", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def set_dataset(self):\n        '''\n        Retrieves the designated dataset, creates NCSS object, and\n        creates a NCSS query object.\n        '''\n\n        keys = list(self.model.datasets.keys())\n        labels = [item.split()[0].lower() for item in keys]\n        if self.set_type == 'best':\n            self.dataset = self.model.datasets[keys[labels.index('best')]]\n        elif self.set_type == 'latest':\n            self.dataset = self.model.datasets[keys[labels.index('latest')]]\n        elif self.set_type == 'full':\n            self.dataset = self.model.datasets[keys[labels.index('full')]]\n\n        self.access_url = self.dataset.access_urls[self.access_url_key]\n        self.ncss = NCSS(self.access_url)\n        self.query = self.ncss.query()\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "set_dataset", "self", "retrieves", "the", "designated", "dataset", "creates", "ncss", "object", "and", "creates", "a", "ncss", "query", "object", "keys", "list", "self", "model", "datasets", "keys", "labels", "item", "split", "0", "lower", "for", "item", "in", "keys", "if", "self", "set_type", "best", "self", "dataset", "self", "model", "datasets", "keys", "labels", "index", "best", "elif", "self", "set_type", "latest", "self", "dataset", "self", "model", "datasets", "keys", "labels", "index", "latest", "elif", "self", "set_type", "full", "self", "dataset", "self", "model", "datasets", "keys", "labels", "index", "full", "self", "access_url", "self", "dataset", "access_urls", "self", "access_url_key", "self", "ncss", "ncss", "self", "access_url", "self", "query", "self", "ncss", "query"], "doc_len": 91}
{"doc_id": "pvlib/forecast.py::ForecastModel.set_query_time_range", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "set_query_time_range", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def set_query_time_range(self, start, end):\n        \"\"\"\n        Parameters\n        ----------\n        start : datetime.datetime, pandas.Timestamp\n            Must be tz-localized.\n        end : datetime.datetime, pandas.Timestamp\n            Must be tz-localized.\n\n        Notes\n        -----\n        Assigns ``self.start``, ``self.end``. Modifies ``self.query``\n        \"\"\"\n        self.start = pd.Timestamp(start)\n        self.end = pd.Timestamp(end)\n        if self.start.tz is None or self.end.tz is None:\n            raise TypeError('start and end must be tz-localized')\n        # don't assume that siphon or the server can handle anything other\n        # than UTC\n        self.query.time_range(\n            self.start.tz_convert('UTC'),\n            self.end.tz_convert('UTC')\n        )\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "set_query_time_range", "self", "start", "end", "parameters", "start", "datetime", "datetime", "pandas", "timestamp", "must", "be", "tz", "localized", "end", "datetime", "datetime", "pandas", "timestamp", "must", "be", "tz", "localized", "notes", "assigns", "self", "start", "self", "end", "modifies", "self", "query", "self", "start", "pd", "timestamp", "start", "self", "end", "pd", "timestamp", "end", "if", "self", "start", "tz", "is", "none", "or", "self", "end", "tz", "is", "none", "raise", "typeerror", "start", "and", "end", "must", "be", "tz", "localized", "don", "t", "assume", "that", "siphon", "or", "the", "server", "can", "handle", "anything", "other", "than", "utc", "self", "query", "time_range", "self", "start", "tz_convert", "utc", "self", "end", "tz_convert", "utc"], "doc_len": 93}
{"doc_id": "pvlib/forecast.py::ForecastModel.set_query_latlon", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "set_query_latlon", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def set_query_latlon(self):\n        '''\n        Sets the NCSS query location latitude and longitude.\n        '''\n\n        if (isinstance(self.longitude, list) and\n                isinstance(self.latitude, list)):\n            self.lbox = True\n            # west, east, south, north\n            self.query.lonlat_box(self.longitude[0], self.longitude[1],\n                                  self.latitude[0], self.latitude[1])\n        else:\n            self.lbox = False\n            self.query.lonlat_point(self.longitude, self.latitude)\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "set_query_latlon", "self", "sets", "the", "ncss", "query", "location", "latitude", "and", "longitude", "if", "isinstance", "self", "longitude", "list", "and", "isinstance", "self", "latitude", "list", "self", "lbox", "true", "west", "east", "south", "north", "self", "query", "lonlat_box", "self", "longitude", "0", "self", "longitude", "1", "self", "latitude", "0", "self", "latitude", "1", "else", "self", "lbox", "false", "self", "query", "lonlat_point", "self", "longitude", "self", "latitude"], "doc_len": 58}
{"doc_id": "pvlib/forecast.py::ForecastModel.set_location", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "set_location", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def set_location(self, tz, latitude, longitude):\n        '''\n        Sets the location for the query.\n\n        Parameters\n        ----------\n        tz: tzinfo\n            Timezone of the query\n        latitude: float\n            Latitude of the query\n        longitude: float\n            Longitude of the query\n\n        Notes\n        -----\n        Assigns ``self.location``.\n        '''\n        self.location = Location(latitude, longitude, tz=tz)\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "set_location", "self", "tz", "latitude", "longitude", "sets", "the", "location", "for", "the", "query", "parameters", "tz", "tzinfo", "timezone", "of", "the", "query", "latitude", "float", "latitude", "of", "the", "query", "longitude", "float", "longitude", "of", "the", "query", "notes", "assigns", "self", "location", "self", "location", "location", "latitude", "longitude", "tz", "tz"], "doc_len": 46}
{"doc_id": "pvlib/forecast.py::ForecastModel.get_data", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "get_data", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def get_data(self, latitude, longitude, start, end,\n                 vert_level=None, query_variables=None,\n                 close_netcdf_data=True, **kwargs):\n        \"\"\"\n        Submits a query to the UNIDATA servers using Siphon NCSS and\n        converts the netcdf data to a pandas DataFrame.\n\n        Parameters\n        ----------\n        latitude: float\n            The latitude value.\n        longitude: float\n            The longitude value.\n        start: datetime or timestamp\n            The start time.\n        end: datetime or timestamp\n            The end time.\n        vert_level: None, float or integer, default None\n            Vertical altitude of interest.\n        query_variables: None or list, default None\n            If None, uses self.variables.\n        close_netcdf_data: bool, default True\n            Controls if the temporary netcdf data file should be closed.\n            Set to False to access the raw data.\n        **kwargs:\n            Additional keyword arguments are silently ignored.\n\n        Returns\n        -------\n        forecast_data : DataFrame\n            column names are the weather model's variable names.\n        \"\"\"\n\n        if not self.connected:\n            self.connect_to_catalog()\n\n        if vert_level is not None:\n            self.vert_level = vert_level\n\n        if query_variables is None:\n            self.query_variables = list(self.variables.values())\n        else:\n            self.query_variables = query_variables\n\n        self.set_query_time_range(start, end)\n\n        self.latitude = latitude\n        self.longitude = longitude\n        self.set_query_latlon()  # modifies self.query\n        self.set_location(self.start.tz, latitude, longitude)\n\n        if self.vert_level is not None:\n            self.query.vertical_level(self.vert_level)\n\n        self.query.variables(*self.query_variables)\n        self.query.accept(self.data_format)\n\n        self.netcdf_data = self.ncss.get_data(self.query)\n\n        # might be better to go to xarray here so that we can handle\n        # higher dimensional data for more advanced applications\n        self.data = self._netcdf2pandas(self.netcdf_data, self.query_variables,\n                                        self.start, self.end)\n\n        if close_netcdf_data:\n            self.netcdf_data.close()\n\n        return self.data\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "get_data", "self", "latitude", "longitude", "start", "end", "vert_level", "none", "query_variables", "none", "close_netcdf_data", "true", "kwargs", "submits", "a", "query", "to", "the", "unidata", "servers", "using", "siphon", "ncss", "and", "converts", "the", "netcdf", "data", "to", "a", "pandas", "dataframe", "parameters", "latitude", "float", "the", "latitude", "value", "longitude", "float", "the", "longitude", "value", "start", "datetime", "or", "timestamp", "the", "start", "time", "end", "datetime", "or", "timestamp", "the", "end", "time", "vert_level", "none", "float", "or", "integer", "default", "none", "vertical", "altitude", "of", "interest", "query_variables", "none", "or", "list", "default", "none", "if", "none", "uses", "self", "variables", "close_netcdf_data", "bool", "default", "true", "controls", "if", "the", "temporary", "netcdf", "data", "file", "should", "be", "closed", "set", "to", "false", "to", "access", "the", "raw", "data", "kwargs", "additional", "keyword", "arguments", "are", "silently", "ignored", "returns", "forecast_data", "dataframe", "column", "names", "are", "the", "weather", "model", "s", "variable", "names", "if", "not", "self", "connected", "self", "connect_to_catalog", "if", "vert_level", "is", "not", "none", "self", "vert_level", "vert_level", "if", "query_variables", "is", "none", "self", "query_variables", "list", "self", "variables", "values", "else", "self", "query_variables", "query_variables", "self", "set_query_time_range", "start", "end", "self", "latitude", "latitude", "self", "longitude", "longitude", "self", "set_query_latlon", "modifies", "self", "query", "self", "set_location", "self", "start", "tz", "latitude", "longitude", "if", "self", "vert_level", "is", "not", "none", "self", "query", "vertical_level", "self", "vert_level", "self", "query", "variables", "self", "query_variables", "self", "query", "accept", "self", "data_format", "self", "netcdf_data", "self", "ncss", "get_data", "self", "query", "might", "be", "better", "to", "go", "to", "xarray", "here", "so", "that", "we", "can", "handle", "higher", "dimensional", "data", "for", "more", "advanced", "applications", "self", "data", "self", "_netcdf2pandas", "self", "netcdf_data", "self", "query_variables", "self", "start", "self", "end", "if", "close_netcdf_data", "self", "netcdf_data", "close", "return", "self", "data"], "doc_len": 243}
{"doc_id": "pvlib/forecast.py::ForecastModel.process_data", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def process_data(self, data, **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data. Most forecast models implement\n        their own version of this method which also call this one.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n        data = self.rename(data)\n        return data\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "process_data", "self", "data", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "most", "forecast", "models", "implement", "their", "own", "version", "of", "this", "method", "which", "also", "call", "this", "one", "parameters", "data", "dataframe", "raw", "forecast", "data", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "self", "rename", "data", "return", "data"], "doc_len": 55}
{"doc_id": "pvlib/forecast.py::ForecastModel.get_processed_data", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "get_processed_data", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def get_processed_data(self, *args, **kwargs):\n        \"\"\"\n        Get and process forecast data.\n\n        Parameters\n        ----------\n        *args: positional arguments\n            Passed to get_data\n        **kwargs: keyword arguments\n            Passed to get_data and process_data\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data\n        \"\"\"\n        return self.process_data(self.get_data(*args, **kwargs), **kwargs)\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "get_processed_data", "self", "args", "kwargs", "get", "and", "process", "forecast", "data", "parameters", "args", "positional", "arguments", "passed", "to", "get_data", "kwargs", "keyword", "arguments", "passed", "to", "get_data", "and", "process_data", "returns", "data", "dataframe", "processed", "forecast", "data", "return", "self", "process_data", "self", "get_data", "args", "kwargs", "kwargs"], "doc_len": 43}
{"doc_id": "pvlib/forecast.py::ForecastModel.rename", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "rename", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def rename(self, data, variables=None):\n        \"\"\"\n        Renames the columns according the variable mapping.\n\n        Parameters\n        ----------\n        data: DataFrame\n        variables: None or dict, default None\n            If None, uses self.variables\n\n        Returns\n        -------\n        data: DataFrame\n            Renamed data.\n        \"\"\"\n        if variables is None:\n            variables = self.variables\n        return data.rename(columns={y: x for x, y in variables.items()})\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "rename", "self", "data", "variables", "none", "renames", "the", "columns", "according", "the", "variable", "mapping", "parameters", "data", "dataframe", "variables", "none", "or", "dict", "default", "none", "if", "none", "uses", "self", "variables", "returns", "data", "dataframe", "renamed", "data", "if", "variables", "is", "none", "variables", "self", "variables", "return", "data", "rename", "columns", "y", "x", "for", "x", "y", "in", "variables", "items"], "doc_len": 55}
{"doc_id": "pvlib/forecast.py::ForecastModel._netcdf2pandas", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "_netcdf2pandas", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def _netcdf2pandas(self, netcdf_data, query_variables, start, end):\n        \"\"\"\n        Transforms data from netcdf to pandas DataFrame.\n\n        Parameters\n        ----------\n        data: netcdf\n            Data returned from UNIDATA NCSS query.\n        query_variables: list\n            The variables requested.\n        start: Timestamp\n            The start time\n        end: Timestamp\n            The end time\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        # set self.time\n        try:\n            time_var = 'time'\n            self.set_time(netcdf_data.variables[time_var])\n        except KeyError:\n            # which model does this dumb thing?\n            time_var = 'time1'\n            self.set_time(netcdf_data.variables[time_var])\n\n        data_dict = {}\n        for key, data in netcdf_data.variables.items():\n            # if accounts for possibility of extra variable returned\n            if key not in query_variables:\n                continue\n            squeezed = data[:].squeeze()\n\n            # If the data is big endian, swap the byte order to make it\n            # little endian\n            if squeezed.dtype.byteorder == '>':\n                squeezed = squeezed.byteswap().newbyteorder()\n            if squeezed.ndim == 1:\n                data_dict[key] = squeezed\n            elif squeezed.ndim == 2:\n                for num, data_level in enumerate(squeezed.T):\n                    data_dict[key + '_' + str(num)] = data_level\n            else:\n                raise ValueError('cannot parse ndim > 2')\n\n        data = pd.DataFrame(data_dict, index=self.time)\n        # sometimes data is returned as hours since T0\n        # where T0 is before start. Then the hours between\n        # T0 and start are added *after* end. So sort and slice\n        # to remove the garbage\n        data = data.sort_index().loc[start:end]\n        return data\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "_netcdf2pandas", "self", "netcdf_data", "query_variables", "start", "end", "transforms", "data", "from", "netcdf", "to", "pandas", "dataframe", "parameters", "data", "netcdf", "data", "returned", "from", "unidata", "ncss", "query", "query_variables", "list", "the", "variables", "requested", "start", "timestamp", "the", "start", "time", "end", "timestamp", "the", "end", "time", "returns", "pd", "dataframe", "set", "self", "time", "try", "time_var", "time", "self", "set_time", "netcdf_data", "variables", "time_var", "except", "keyerror", "which", "model", "does", "this", "dumb", "thing", "time_var", "time1", "self", "set_time", "netcdf_data", "variables", "time_var", "data_dict", "for", "key", "data", "in", "netcdf_data", "variables", "items", "if", "accounts", "for", "possibility", "of", "extra", "variable", "returned", "if", "key", "not", "in", "query_variables", "continue", "squeezed", "data", "squeeze", "if", "the", "data", "is", "big", "endian", "swap", "the", "byte", "order", "to", "make", "it", "little", "endian", "if", "squeezed", "dtype", "byteorder", "squeezed", "squeezed", "byteswap", "newbyteorder", "if", "squeezed", "ndim", "1", "data_dict", "key", "squeezed", "elif", "squeezed", "ndim", "2", "for", "num", "data_level", "in", "enumerate", "squeezed", "t", "data_dict", "key", "_", "str", "num", "data_level", "else", "raise", "valueerror", "cannot", "parse", "ndim", "2", "data", "pd", "dataframe", "data_dict", "index", "self", "time", "sometimes", "data", "is", "returned", "as", "hours", "since", "t0", "where", "t0", "is", "before", "start", "then", "the", "hours", "between", "t0", "and", "start", "are", "added", "after", "end", "so", "sort", "and", "slice", "to", "remove", "the", "garbage", "data", "data", "sort_index", "loc", "start", "end", "return", "data"], "doc_len": 197}
{"doc_id": "pvlib/forecast.py::ForecastModel.set_time", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "set_time", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def set_time(self, time):\n        '''\n        Converts time data into a pandas date object.\n\n        Parameters\n        ----------\n        time: netcdf\n            Contains time information.\n\n        Returns\n        -------\n        pandas.DatetimeIndex\n        '''\n        # np.masked_array with elements like real_datetime(2021, 8, 17, 16, 0)\n        # and dtype=object\n        times = num2date(time[:].squeeze(), time.units,\n                         only_use_cftime_datetimes=False,\n                         only_use_python_datetimes=True)\n        # convert to pandas, localize to UTC, convert to desired timezone\n        self.time = pd.DatetimeIndex(\n            times, tz='UTC').tz_convert(self.location.tz)\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "set_time", "self", "time", "converts", "time", "data", "into", "a", "pandas", "date", "object", "parameters", "time", "netcdf", "contains", "time", "information", "returns", "pandas", "datetimeindex", "np", "masked_array", "with", "elements", "like", "real_datetime", "2021", "8", "17", "16", "0", "and", "dtype", "object", "times", "num2date", "time", "squeeze", "time", "units", "only_use_cftime_datetimes", "false", "only_use_python_datetimes", "true", "convert", "to", "pandas", "localize", "to", "utc", "convert", "to", "desired", "timezone", "self", "time", "pd", "datetimeindex", "times", "tz", "utc", "tz_convert", "self", "location", "tz"], "doc_len": 70}
{"doc_id": "pvlib/forecast.py::ForecastModel.cloud_cover_to_ghi_linear", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "cloud_cover_to_ghi_linear", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def cloud_cover_to_ghi_linear(self, cloud_cover, ghi_clear, offset=35,\n                                  **kwargs):\n        \"\"\"\n        Convert cloud cover to GHI using a linear relationship.\n\n        0% cloud cover returns ghi_clear.\n\n        100% cloud cover returns offset*ghi_clear.\n\n        Parameters\n        ----------\n        cloud_cover: numeric\n            Cloud cover in %.\n        ghi_clear: numeric\n            GHI under clear sky conditions.\n        offset: numeric, default 35\n            Determines the minimum GHI.\n        kwargs\n            Not used.\n\n        Returns\n        -------\n        ghi: numeric\n            Estimated GHI.\n\n        References\n        ----------\n        Larson et. al. \"Day-ahead forecasting of solar power output from\n        photovoltaic plants in the American Southwest\" Renewable Energy\n        91, 11-20 (2016).\n        \"\"\"\n\n        offset = offset / 100.\n        cloud_cover = cloud_cover / 100.\n        ghi = (offset + (1 - offset) * (1 - cloud_cover)) * ghi_clear\n        return ghi\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "cloud_cover_to_ghi_linear", "self", "cloud_cover", "ghi_clear", "offset", "35", "kwargs", "convert", "cloud", "cover", "to", "ghi", "using", "a", "linear", "relationship", "0", "cloud", "cover", "returns", "ghi_clear", "100", "cloud", "cover", "returns", "offset", "ghi_clear", "parameters", "cloud_cover", "numeric", "cloud", "cover", "in", "ghi_clear", "numeric", "ghi", "under", "clear", "sky", "conditions", "offset", "numeric", "default", "35", "determines", "the", "minimum", "ghi", "kwargs", "not", "used", "returns", "ghi", "numeric", "estimated", "ghi", "references", "larson", "et", "al", "day", "ahead", "forecasting", "of", "solar", "power", "output", "from", "photovoltaic", "plants", "in", "the", "american", "southwest", "renewable", "energy", "91", "11", "20", "2016", "offset", "offset", "100", "cloud_cover", "cloud_cover", "100", "ghi", "offset", "1", "offset", "1", "cloud_cover", "ghi_clear", "return", "ghi"], "doc_len": 100}
{"doc_id": "pvlib/forecast.py::ForecastModel.cloud_cover_to_irradiance_clearsky_scaling", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "cloud_cover_to_irradiance_clearsky_scaling", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def cloud_cover_to_irradiance_clearsky_scaling(self, cloud_cover,\n                                                   method='linear',\n                                                   **kwargs):\n        \"\"\"\n        Estimates irradiance from cloud cover in the following steps:\n\n        1. Determine clear sky GHI using Ineichen model and\n           climatological turbidity.\n        2. Estimate cloudy sky GHI using a function of\n           cloud_cover e.g.\n           :py:meth:`~ForecastModel.cloud_cover_to_ghi_linear`\n        3. Estimate cloudy sky DNI using the DISC model.\n        4. Calculate DHI from DNI and GHI.\n\n        Parameters\n        ----------\n        cloud_cover : Series\n            Cloud cover in %.\n        method : str, default 'linear'\n            Method for converting cloud cover to GHI.\n            'linear' is currently the only option.\n        **kwargs\n            Passed to the method that does the conversion\n\n        Returns\n        -------\n        irrads : DataFrame\n            Estimated GHI, DNI, and DHI.\n        \"\"\"\n        solpos = self.location.get_solarposition(cloud_cover.index)\n        cs = self.location.get_clearsky(cloud_cover.index, model='ineichen',\n                                        solar_position=solpos)\n\n        method = method.lower()\n        if method == 'linear':\n            ghi = self.cloud_cover_to_ghi_linear(cloud_cover, cs['ghi'],\n                                                 **kwargs)\n        else:\n            raise ValueError('invalid method argument')\n\n        dni = disc(ghi, solpos['zenith'], cloud_cover.index)['dni']\n        dhi = ghi - dni * np.cos(np.radians(solpos['zenith']))\n\n        irrads = pd.DataFrame({'ghi': ghi, 'dni': dni, 'dhi': dhi}).fillna(0)\n        return irrads\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "cloud_cover_to_irradiance_clearsky_scaling", "self", "cloud_cover", "method", "linear", "kwargs", "estimates", "irradiance", "from", "cloud", "cover", "in", "the", "following", "steps", "1", "determine", "clear", "sky", "ghi", "using", "ineichen", "model", "and", "climatological", "turbidity", "2", "estimate", "cloudy", "sky", "ghi", "using", "a", "function", "of", "cloud_cover", "e", "g", "py", "meth", "forecastmodel", "cloud_cover_to_ghi_linear", "3", "estimate", "cloudy", "sky", "dni", "using", "the", "disc", "model", "4", "calculate", "dhi", "from", "dni", "and", "ghi", "parameters", "cloud_cover", "series", "cloud", "cover", "in", "method", "str", "default", "linear", "method", "for", "converting", "cloud", "cover", "to", "ghi", "linear", "is", "currently", "the", "only", "option", "kwargs", "passed", "to", "the", "method", "that", "does", "the", "conversion", "returns", "irrads", "dataframe", "estimated", "ghi", "dni", "and", "dhi", "solpos", "self", "location", "get_solarposition", "cloud_cover", "index", "cs", "self", "location", "get_clearsky", "cloud_cover", "index", "model", "ineichen", "solar_position", "solpos", "method", "method", "lower", "if", "method", "linear", "ghi", "self", "cloud_cover_to_ghi_linear", "cloud_cover", "cs", "ghi", "kwargs", "else", "raise", "valueerror", "invalid", "method", "argument", "dni", "disc", "ghi", "solpos", "zenith", "cloud_cover", "index", "dni", "dhi", "ghi", "dni", "np", "cos", "np", "radians", "solpos", "zenith", "irrads", "pd", "dataframe", "ghi", "ghi", "dni", "dni", "dhi", "dhi", "fillna", "0", "return", "irrads"], "doc_len": 168}
{"doc_id": "pvlib/forecast.py::ForecastModel.cloud_cover_to_transmittance_linear", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "cloud_cover_to_transmittance_linear", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def cloud_cover_to_transmittance_linear(self, cloud_cover, offset=0.75,\n                                            **kwargs):\n        \"\"\"\n        Convert cloud cover (percentage) to atmospheric transmittance\n        using a linear model.\n\n        0% cloud cover returns \"offset\".\n\n        100% cloud cover returns 0.\n\n        Parameters\n        ----------\n        cloud_cover : numeric\n            Cloud cover in %.\n        offset : numeric, default 0.75\n            Determines the maximum transmittance. [unitless]\n        kwargs\n            Not used.\n\n        Returns\n        -------\n        transmittance : numeric\n            The fraction of extraterrestrial irradiance that reaches\n            the ground. [unitless]\n        \"\"\"\n        transmittance = ((100.0 - cloud_cover) / 100.0) * offset\n\n        return transmittance\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "cloud_cover_to_transmittance_linear", "self", "cloud_cover", "offset", "0", "75", "kwargs", "convert", "cloud", "cover", "percentage", "to", "atmospheric", "transmittance", "using", "a", "linear", "model", "0", "cloud", "cover", "returns", "offset", "100", "cloud", "cover", "returns", "0", "parameters", "cloud_cover", "numeric", "cloud", "cover", "in", "offset", "numeric", "default", "0", "75", "determines", "the", "maximum", "transmittance", "unitless", "kwargs", "not", "used", "returns", "transmittance", "numeric", "the", "fraction", "of", "extraterrestrial", "irradiance", "that", "reaches", "the", "ground", "unitless", "transmittance", "100", "0", "cloud_cover", "100", "0", "offset", "return", "transmittance"], "doc_len": 74}
{"doc_id": "pvlib/forecast.py::ForecastModel.cloud_cover_to_irradiance_campbell_norman", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "cloud_cover_to_irradiance_campbell_norman", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def cloud_cover_to_irradiance_campbell_norman(self, cloud_cover, **kwargs):\n        \"\"\"\n        Estimates irradiance from cloud cover in the following steps:\n\n        1. Determine transmittance using a function of cloud cover e.g.\n           :py:meth:`~ForecastModel.cloud_cover_to_transmittance_linear`\n        2. Calculate GHI, DNI, DHI using the\n           :py:func:`pvlib.irradiance.campbell_norman` model\n\n        Parameters\n        ----------\n        cloud_cover : Series\n\n        Returns\n        -------\n        irradiance : DataFrame\n            Columns include ghi, dni, dhi\n        \"\"\"\n        # in principle, get_solarposition could use the forecast\n        # pressure, temp, etc., but the cloud cover forecast is not\n        # accurate enough to justify using these minor corrections\n        solar_position = self.location.get_solarposition(cloud_cover.index)\n        dni_extra = get_extra_radiation(cloud_cover.index)\n\n        transmittance = self.cloud_cover_to_transmittance_linear(cloud_cover,\n                                                                 **kwargs)\n\n        irrads = campbell_norman(solar_position['apparent_zenith'],\n                                 transmittance, dni_extra=dni_extra)\n        irrads = irrads.fillna(0)\n\n        return irrads\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "cloud_cover_to_irradiance_campbell_norman", "self", "cloud_cover", "kwargs", "estimates", "irradiance", "from", "cloud", "cover", "in", "the", "following", "steps", "1", "determine", "transmittance", "using", "a", "function", "of", "cloud", "cover", "e", "g", "py", "meth", "forecastmodel", "cloud_cover_to_transmittance_linear", "2", "calculate", "ghi", "dni", "dhi", "using", "the", "py", "func", "pvlib", "irradiance", "campbell_norman", "model", "parameters", "cloud_cover", "series", "returns", "irradiance", "dataframe", "columns", "include", "ghi", "dni", "dhi", "in", "principle", "get_solarposition", "could", "use", "the", "forecast", "pressure", "temp", "etc", "but", "the", "cloud", "cover", "forecast", "is", "not", "accurate", "enough", "to", "justify", "using", "these", "minor", "corrections", "solar_position", "self", "location", "get_solarposition", "cloud_cover", "index", "dni_extra", "get_extra_radiation", "cloud_cover", "index", "transmittance", "self", "cloud_cover_to_transmittance_linear", "cloud_cover", "kwargs", "irrads", "campbell_norman", "solar_position", "apparent_zenith", "transmittance", "dni_extra", "dni_extra", "irrads", "irrads", "fillna", "0", "return", "irrads"], "doc_len": 110}
{"doc_id": "pvlib/forecast.py::ForecastModel.cloud_cover_to_irradiance", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "cloud_cover_to_irradiance", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def cloud_cover_to_irradiance(self, cloud_cover, how='clearsky_scaling',\n                                  **kwargs):\n        \"\"\"\n        Convert cloud cover to irradiance. A wrapper method.\n\n        Parameters\n        ----------\n        cloud_cover : Series\n        how : str, default 'clearsky_scaling'\n            Selects the method for conversion. Can be one of\n            clearsky_scaling or campbell_norman. Method liujordan is\n            deprecated.\n        **kwargs\n            Passed to the selected method.\n\n        Returns\n        -------\n        irradiance : DataFrame\n            Columns include ghi, dni, dhi\n        \"\"\"\n\n        how = how.lower()\n        if how == 'clearsky_scaling':\n            irrads = self.cloud_cover_to_irradiance_clearsky_scaling(\n                cloud_cover, **kwargs)\n        elif how == 'campbell_norman':\n            irrads = self.cloud_cover_to_irradiance_campbell_norman(\n                cloud_cover, **kwargs)\n        else:\n            raise ValueError('invalid how argument')\n\n        return irrads\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "cloud_cover_to_irradiance", "self", "cloud_cover", "how", "clearsky_scaling", "kwargs", "convert", "cloud", "cover", "to", "irradiance", "a", "wrapper", "method", "parameters", "cloud_cover", "series", "how", "str", "default", "clearsky_scaling", "selects", "the", "method", "for", "conversion", "can", "be", "one", "of", "clearsky_scaling", "or", "campbell_norman", "method", "liujordan", "is", "deprecated", "kwargs", "passed", "to", "the", "selected", "method", "returns", "irradiance", "dataframe", "columns", "include", "ghi", "dni", "dhi", "how", "how", "lower", "if", "how", "clearsky_scaling", "irrads", "self", "cloud_cover_to_irradiance_clearsky_scaling", "cloud_cover", "kwargs", "elif", "how", "campbell_norman", "irrads", "self", "cloud_cover_to_irradiance_campbell_norman", "cloud_cover", "kwargs", "else", "raise", "valueerror", "invalid", "how", "argument", "return", "irrads"], "doc_len": 83}
{"doc_id": "pvlib/forecast.py::ForecastModel.kelvin_to_celsius", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "kelvin_to_celsius", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def kelvin_to_celsius(self, temperature):\n        \"\"\"\n        Converts Kelvin to celsius.\n\n        Parameters\n        ----------\n        temperature: numeric\n\n        Returns\n        -------\n        temperature: numeric\n        \"\"\"\n        return temperature - 273.15\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "kelvin_to_celsius", "self", "temperature", "converts", "kelvin", "to", "celsius", "parameters", "temperature", "numeric", "returns", "temperature", "numeric", "return", "temperature", "273", "15"], "doc_len": 22}
{"doc_id": "pvlib/forecast.py::ForecastModel.isobaric_to_ambient_temperature", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "isobaric_to_ambient_temperature", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def isobaric_to_ambient_temperature(self, data):\n        \"\"\"\n        Calculates temperature from isobaric temperature.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Must contain columns pressure, temperature_iso,\n            temperature_dew_iso. Input temperature in K.\n\n        Returns\n        -------\n        temperature : Series\n            Temperature in K\n        \"\"\"\n\n        P = data['pressure'] / 100.0                            # noqa: N806\n        Tiso = data['temperature_iso']                          # noqa: N806\n        Td = data['temperature_dew_iso'] - 273.15               # noqa: N806\n\n        # saturation water vapor pressure\n        e = 6.11 * 10**((7.5 * Td) / (Td + 273.3))\n\n        # saturation water vapor mixing ratio\n        w = 0.622 * (e / (P - e))\n\n        temperature = Tiso - ((2.501 * 10.**6) / 1005.7) * w\n\n        return temperature\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "isobaric_to_ambient_temperature", "self", "data", "calculates", "temperature", "from", "isobaric", "temperature", "parameters", "data", "dataframe", "must", "contain", "columns", "pressure", "temperature_iso", "temperature_dew_iso", "input", "temperature", "in", "k", "returns", "temperature", "series", "temperature", "in", "k", "p", "data", "pressure", "100", "0", "noqa", "n806", "tiso", "data", "temperature_iso", "noqa", "n806", "td", "data", "temperature_dew_iso", "273", "15", "noqa", "n806", "saturation", "water", "vapor", "pressure", "e", "6", "11", "10", "7", "5", "td", "td", "273", "3", "saturation", "water", "vapor", "mixing", "ratio", "w", "0", "622", "e", "p", "e", "temperature", "tiso", "2", "501", "10", "6", "1005", "7", "w", "return", "temperature"], "doc_len": 87}
{"doc_id": "pvlib/forecast.py::ForecastModel.uv_to_speed", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "uv_to_speed", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def uv_to_speed(self, data):\n        \"\"\"\n        Computes wind speed from wind components.\n\n        Parameters\n        ----------\n        data : DataFrame\n            Must contain the columns 'wind_speed_u' and 'wind_speed_v'.\n\n        Returns\n        -------\n        wind_speed : Series\n        \"\"\"\n        wind_speed = np.sqrt(data['wind_speed_u']**2 + data['wind_speed_v']**2)\n\n        return wind_speed\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "uv_to_speed", "self", "data", "computes", "wind", "speed", "from", "wind", "components", "parameters", "data", "dataframe", "must", "contain", "the", "columns", "wind_speed_u", "and", "wind_speed_v", "returns", "wind_speed", "series", "wind_speed", "np", "sqrt", "data", "wind_speed_u", "2", "data", "wind_speed_v", "2", "return", "wind_speed"], "doc_len": 38}
{"doc_id": "pvlib/forecast.py::ForecastModel.gust_to_speed", "file_path": "pvlib/forecast.py", "class_name": "ForecastModel", "func_name": "gust_to_speed", "text": "文件路径: pvlib/forecast.py, 类名: ForecastModel\n    def gust_to_speed(self, data, scaling=1/1.4):\n        \"\"\"\n        Computes standard wind speed from gust.\n        Very approximate and location dependent.\n\n        Parameters\n        ----------\n        data : DataFrame\n            Must contain the column 'wind_speed_gust'.\n\n        Returns\n        -------\n        wind_speed : Series\n        \"\"\"\n        wind_speed = data['wind_speed_gust'] * scaling\n\n        return wind_speed\n", "tokens": ["pvlib", "forecast", "py", "forecastmodel", "def", "gust_to_speed", "self", "data", "scaling", "1", "1", "4", "computes", "standard", "wind", "speed", "from", "gust", "very", "approximate", "and", "location", "dependent", "parameters", "data", "dataframe", "must", "contain", "the", "column", "wind_speed_gust", "returns", "wind_speed", "series", "wind_speed", "data", "wind_speed_gust", "scaling", "return", "wind_speed"], "doc_len": 40}
{"doc_id": "pvlib/forecast.py::GFS.__init__", "file_path": "pvlib/forecast.py", "class_name": "GFS", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: GFS\n    def __init__(self, resolution='half', set_type='best'):\n        model_type = 'Forecast Model Data'\n\n        resolution = resolution.title()\n        if resolution not in self._resolutions:\n            raise ValueError(f'resolution must in {self._resolutions}')\n\n        model = f'GFS {resolution} Degree Forecast'\n\n        # isobaric variables will require a vert_level to prevent\n        # excessive data downloads\n        self.variables = {\n            'temp_air': 'Temperature_surface',\n            'wind_speed_gust': 'Wind_speed_gust_surface',\n            'wind_speed_u': 'u-component_of_wind_isobaric',\n            'wind_speed_v': 'v-component_of_wind_isobaric',\n            'total_clouds':\n                'Total_cloud_cover_entire_atmosphere_Mixed_intervals_Average',\n            'low_clouds':\n                'Low_cloud_cover_low_cloud_Mixed_intervals_Average',\n            'mid_clouds':\n                'Medium_cloud_cover_middle_cloud_Mixed_intervals_Average',\n            'high_clouds':\n                'High_cloud_cover_high_cloud_Mixed_intervals_Average',\n            'boundary_clouds': ('Total_cloud_cover_boundary_layer_cloud_'\n                                'Mixed_intervals_Average'),\n            'convect_clouds': 'Total_cloud_cover_convective_cloud',\n            'ghi_raw': ('Downward_Short-Wave_Radiation_Flux_'\n                        'surface_Mixed_intervals_Average')}\n\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds',\n            'low_clouds',\n            'mid_clouds',\n            'high_clouds']\n\n        super().__init__(model_type, model, set_type,\n                                  vert_level=100000)\n", "tokens": ["pvlib", "forecast", "py", "gfs", "def", "__init__", "self", "resolution", "half", "set_type", "best", "model_type", "forecast", "model", "data", "resolution", "resolution", "title", "if", "resolution", "not", "in", "self", "_resolutions", "raise", "valueerror", "f", "resolution", "must", "in", "self", "_resolutions", "model", "f", "gfs", "resolution", "degree", "forecast", "isobaric", "variables", "will", "require", "a", "vert_level", "to", "prevent", "excessive", "data", "downloads", "self", "variables", "temp_air", "temperature_surface", "wind_speed_gust", "wind_speed_gust_surface", "wind_speed_u", "u", "component_of_wind_isobaric", "wind_speed_v", "v", "component_of_wind_isobaric", "total_clouds", "total_cloud_cover_entire_atmosphere_mixed_intervals_average", "low_clouds", "low_cloud_cover_low_cloud_mixed_intervals_average", "mid_clouds", "medium_cloud_cover_middle_cloud_mixed_intervals_average", "high_clouds", "high_cloud_cover_high_cloud_mixed_intervals_average", "boundary_clouds", "total_cloud_cover_boundary_layer_cloud_", "mixed_intervals_average", "convect_clouds", "total_cloud_cover_convective_cloud", "ghi_raw", "downward_short", "wave_radiation_flux_", "surface_mixed_intervals_average", "self", "output_variables", "temp_air", "wind_speed", "ghi", "dni", "dhi", "total_clouds", "low_clouds", "mid_clouds", "high_clouds", "super", "__init__", "model_type", "model", "set_type", "vert_level", "100000"], "doc_len": 96}
{"doc_id": "pvlib/forecast.py::GFS.process_data", "file_path": "pvlib/forecast.py", "class_name": "GFS", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: GFS\n    def process_data(self, data, cloud_cover='total_clouds', **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n        cloud_cover: str, default 'total_clouds'\n            The type of cloud cover used to infer the irradiance.\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n        data = super().process_data(data, **kwargs)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        data['wind_speed'] = self.uv_to_speed(data)\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "gfs", "def", "process_data", "self", "data", "cloud_cover", "total_clouds", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "cloud_cover", "str", "default", "total_clouds", "the", "type", "of", "cloud", "cover", "used", "to", "infer", "the", "irradiance", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "super", "process_data", "data", "kwargs", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "data", "wind_speed", "self", "uv_to_speed", "data", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "return", "data", "self", "output_variables"], "doc_len": 82}
{"doc_id": "pvlib/forecast.py::HRRR_ESRL.__init__", "file_path": "pvlib/forecast.py", "class_name": "HRRR_ESRL", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: HRRR_ESRL\n    def __init__(self, set_type='best'):\n        warnings.warn('HRRR_ESRL is an experimental model and is not '\n                      'always available.')\n\n        model_type = 'Forecast Model Data'\n        model = 'GSD HRRR CONUS 3km surface'\n\n        self.variables = {\n            'temp_air': 'Temperature_surface',\n            'wind_speed_gust': 'Wind_speed_gust_surface',\n            # 'temp_air': 'Temperature_height_above_ground',  # GH 702\n            # 'wind_speed_u': 'u-component_of_wind_height_above_ground',\n            # 'wind_speed_v': 'v-component_of_wind_height_above_ground',\n            'total_clouds': 'Total_cloud_cover_entire_atmosphere',\n            'low_clouds': 'Low_cloud_cover_UnknownLevelType-214',\n            'mid_clouds': 'Medium_cloud_cover_UnknownLevelType-224',\n            'high_clouds': 'High_cloud_cover_UnknownLevelType-234',\n            'ghi_raw': 'Downward_short-wave_radiation_flux_surface', }\n\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi_raw',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds',\n            'low_clouds',\n            'mid_clouds',\n            'high_clouds']\n\n        super().__init__(model_type, model, set_type)\n", "tokens": ["pvlib", "forecast", "py", "hrrr_esrl", "def", "__init__", "self", "set_type", "best", "warnings", "warn", "hrrr_esrl", "is", "an", "experimental", "model", "and", "is", "not", "always", "available", "model_type", "forecast", "model", "data", "model", "gsd", "hrrr", "conus", "3km", "surface", "self", "variables", "temp_air", "temperature_surface", "wind_speed_gust", "wind_speed_gust_surface", "temp_air", "temperature_height_above_ground", "gh", "702", "wind_speed_u", "u", "component_of_wind_height_above_ground", "wind_speed_v", "v", "component_of_wind_height_above_ground", "total_clouds", "total_cloud_cover_entire_atmosphere", "low_clouds", "low_cloud_cover_unknownleveltype", "214", "mid_clouds", "medium_cloud_cover_unknownleveltype", "224", "high_clouds", "high_cloud_cover_unknownleveltype", "234", "ghi_raw", "downward_short", "wave_radiation_flux_surface", "self", "output_variables", "temp_air", "wind_speed", "ghi_raw", "ghi", "dni", "dhi", "total_clouds", "low_clouds", "mid_clouds", "high_clouds", "super", "__init__", "model_type", "model", "set_type"], "doc_len": 78}
{"doc_id": "pvlib/forecast.py::HRRR_ESRL.process_data", "file_path": "pvlib/forecast.py", "class_name": "HRRR_ESRL", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: HRRR_ESRL\n    def process_data(self, data, cloud_cover='total_clouds', **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n        cloud_cover: str, default 'total_clouds'\n            The type of cloud cover used to infer the irradiance.\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n\n        data = super().process_data(data, **kwargs)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        data['wind_speed'] = self.gust_to_speed(data)\n        # data['wind_speed'] = self.uv_to_speed(data)  # GH 702\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "hrrr_esrl", "def", "process_data", "self", "data", "cloud_cover", "total_clouds", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "cloud_cover", "str", "default", "total_clouds", "the", "type", "of", "cloud", "cover", "used", "to", "infer", "the", "irradiance", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "super", "process_data", "data", "kwargs", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "data", "wind_speed", "self", "gust_to_speed", "data", "data", "wind_speed", "self", "uv_to_speed", "data", "gh", "702", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "return", "data", "self", "output_variables"], "doc_len": 89}
{"doc_id": "pvlib/forecast.py::NAM.__init__", "file_path": "pvlib/forecast.py", "class_name": "NAM", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: NAM\n    def __init__(self, set_type='best'):\n        model_type = 'Forecast Model Data'\n        model = 'NAM CONUS 12km from CONDUIT'\n\n        self.variables = {\n            'temp_air': 'Temperature_surface',\n            'wind_speed_gust': 'Wind_speed_gust_surface',\n            'total_clouds': 'Total_cloud_cover_entire_atmosphere_single_layer',\n            'low_clouds': 'Low_cloud_cover_low_cloud',\n            'mid_clouds': 'Medium_cloud_cover_middle_cloud',\n            'high_clouds': 'High_cloud_cover_high_cloud',\n            'ghi_raw': 'Downward_Short-Wave_Radiation_Flux_surface', }\n\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds',\n            'low_clouds',\n            'mid_clouds',\n            'high_clouds']\n\n        super().__init__(model_type, model, set_type)\n", "tokens": ["pvlib", "forecast", "py", "nam", "def", "__init__", "self", "set_type", "best", "model_type", "forecast", "model", "data", "model", "nam", "conus", "12km", "from", "conduit", "self", "variables", "temp_air", "temperature_surface", "wind_speed_gust", "wind_speed_gust_surface", "total_clouds", "total_cloud_cover_entire_atmosphere_single_layer", "low_clouds", "low_cloud_cover_low_cloud", "mid_clouds", "medium_cloud_cover_middle_cloud", "high_clouds", "high_cloud_cover_high_cloud", "ghi_raw", "downward_short", "wave_radiation_flux_surface", "self", "output_variables", "temp_air", "wind_speed", "ghi", "dni", "dhi", "total_clouds", "low_clouds", "mid_clouds", "high_clouds", "super", "__init__", "model_type", "model", "set_type"], "doc_len": 52}
{"doc_id": "pvlib/forecast.py::NAM.process_data", "file_path": "pvlib/forecast.py", "class_name": "NAM", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: NAM\n    def process_data(self, data, cloud_cover='total_clouds', **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n        cloud_cover: str, default 'total_clouds'\n            The type of cloud cover used to infer the irradiance.\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n\n        data = super().process_data(data, **kwargs)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        data['wind_speed'] = self.gust_to_speed(data)\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "nam", "def", "process_data", "self", "data", "cloud_cover", "total_clouds", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "cloud_cover", "str", "default", "total_clouds", "the", "type", "of", "cloud", "cover", "used", "to", "infer", "the", "irradiance", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "super", "process_data", "data", "kwargs", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "data", "wind_speed", "self", "gust_to_speed", "data", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "return", "data", "self", "output_variables"], "doc_len": 82}
{"doc_id": "pvlib/forecast.py::HRRR.__init__", "file_path": "pvlib/forecast.py", "class_name": "HRRR", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: HRRR\n    def __init__(self, set_type='best'):\n        model_type = 'Forecast Model Data'\n        model = 'HRRR CONUS 2.5km Forecasts'\n\n        self.variables = {\n            'temp_air': 'Temperature_height_above_ground',\n            'pressure': 'Pressure_surface',\n            'wind_speed_gust': 'Wind_speed_gust_surface',\n            'wind_speed_u': 'u-component_of_wind_height_above_ground',\n            'wind_speed_v': 'v-component_of_wind_height_above_ground',\n            'total_clouds': 'Total_cloud_cover_entire_atmosphere',\n            'low_clouds': 'Low_cloud_cover_low_cloud',\n            'mid_clouds': 'Medium_cloud_cover_middle_cloud',\n            'high_clouds': 'High_cloud_cover_high_cloud'}\n\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds',\n            'low_clouds',\n            'mid_clouds',\n            'high_clouds', ]\n\n        super().__init__(model_type, model, set_type)\n", "tokens": ["pvlib", "forecast", "py", "hrrr", "def", "__init__", "self", "set_type", "best", "model_type", "forecast", "model", "data", "model", "hrrr", "conus", "2", "5km", "forecasts", "self", "variables", "temp_air", "temperature_height_above_ground", "pressure", "pressure_surface", "wind_speed_gust", "wind_speed_gust_surface", "wind_speed_u", "u", "component_of_wind_height_above_ground", "wind_speed_v", "v", "component_of_wind_height_above_ground", "total_clouds", "total_cloud_cover_entire_atmosphere", "low_clouds", "low_cloud_cover_low_cloud", "mid_clouds", "medium_cloud_cover_middle_cloud", "high_clouds", "high_cloud_cover_high_cloud", "self", "output_variables", "temp_air", "wind_speed", "ghi", "dni", "dhi", "total_clouds", "low_clouds", "mid_clouds", "high_clouds", "super", "__init__", "model_type", "model", "set_type"], "doc_len": 57}
{"doc_id": "pvlib/forecast.py::HRRR.process_data", "file_path": "pvlib/forecast.py", "class_name": "HRRR", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: HRRR\n    def process_data(self, data, cloud_cover='total_clouds', **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n        cloud_cover: str, default 'total_clouds'\n            The type of cloud cover used to infer the irradiance.\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n        data = super().process_data(data, **kwargs)\n        wind_mapping = {\n            'wind_speed_u': 'u-component_of_wind_height_above_ground_0',\n            'wind_speed_v': 'v-component_of_wind_height_above_ground_0',\n        }\n        data = self.rename(data, variables=wind_mapping)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        data['wind_speed'] = self.uv_to_speed(data)\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        data = data.iloc[:-1, :]  # issue with last point\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "hrrr", "def", "process_data", "self", "data", "cloud_cover", "total_clouds", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "cloud_cover", "str", "default", "total_clouds", "the", "type", "of", "cloud", "cover", "used", "to", "infer", "the", "irradiance", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "super", "process_data", "data", "kwargs", "wind_mapping", "wind_speed_u", "u", "component_of_wind_height_above_ground_0", "wind_speed_v", "v", "component_of_wind_height_above_ground_0", "data", "self", "rename", "data", "variables", "wind_mapping", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "data", "wind_speed", "self", "uv_to_speed", "data", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "data", "data", "iloc", "1", "issue", "with", "last", "point", "return", "data", "self", "output_variables"], "doc_len": 103}
{"doc_id": "pvlib/forecast.py::NDFD.__init__", "file_path": "pvlib/forecast.py", "class_name": "NDFD", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: NDFD\n    def __init__(self, set_type='best'):\n        model_type = 'Forecast Products and Analyses'\n        model = 'National Weather Service CONUS Forecast Grids (CONDUIT)'\n        self.variables = {\n            'temp_air': 'Temperature_height_above_ground',\n            'wind_speed': 'Wind_speed_height_above_ground',\n            'total_clouds': 'Total_cloud_cover_surface', }\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds', ]\n        super().__init__(model_type, model, set_type)\n", "tokens": ["pvlib", "forecast", "py", "ndfd", "def", "__init__", "self", "set_type", "best", "model_type", "forecast", "products", "and", "analyses", "model", "national", "weather", "service", "conus", "forecast", "grids", "conduit", "self", "variables", "temp_air", "temperature_height_above_ground", "wind_speed", "wind_speed_height_above_ground", "total_clouds", "total_cloud_cover_surface", "self", "output_variables", "temp_air", "wind_speed", "ghi", "dni", "dhi", "total_clouds", "super", "__init__", "model_type", "model", "set_type"], "doc_len": 43}
{"doc_id": "pvlib/forecast.py::NDFD.process_data", "file_path": "pvlib/forecast.py", "class_name": "NDFD", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: NDFD\n    def process_data(self, data, **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n\n        cloud_cover = 'total_clouds'\n        data = super().process_data(data, **kwargs)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "ndfd", "def", "process_data", "self", "data", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "returns", "data", "dataframe", "processed", "forecast", "data", "cloud_cover", "total_clouds", "data", "super", "process_data", "data", "kwargs", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "return", "data", "self", "output_variables"], "doc_len": 63}
{"doc_id": "pvlib/forecast.py::RAP.__init__", "file_path": "pvlib/forecast.py", "class_name": "RAP", "func_name": "__init__", "text": "文件路径: pvlib/forecast.py, 类名: RAP\n    def __init__(self, resolution='20', set_type='best'):\n\n        resolution = str(resolution)\n        if resolution not in self._resolutions:\n            raise ValueError(f'resolution must in {self._resolutions}')\n\n        model_type = 'Forecast Model Data'\n        model = f'Rapid Refresh CONUS {resolution}km'\n        self.variables = {\n            'temp_air': 'Temperature_surface',\n            'wind_speed_gust': 'Wind_speed_gust_surface',\n            'total_clouds': 'Total_cloud_cover_entire_atmosphere',\n            'low_clouds': 'Low_cloud_cover_low_cloud',\n            'mid_clouds': 'Medium_cloud_cover_middle_cloud',\n            'high_clouds': 'High_cloud_cover_high_cloud', }\n        self.output_variables = [\n            'temp_air',\n            'wind_speed',\n            'ghi',\n            'dni',\n            'dhi',\n            'total_clouds',\n            'low_clouds',\n            'mid_clouds',\n            'high_clouds', ]\n        super().__init__(model_type, model, set_type)\n", "tokens": ["pvlib", "forecast", "py", "rap", "def", "__init__", "self", "resolution", "20", "set_type", "best", "resolution", "str", "resolution", "if", "resolution", "not", "in", "self", "_resolutions", "raise", "valueerror", "f", "resolution", "must", "in", "self", "_resolutions", "model_type", "forecast", "model", "data", "model", "f", "rapid", "refresh", "conus", "resolution", "km", "self", "variables", "temp_air", "temperature_surface", "wind_speed_gust", "wind_speed_gust_surface", "total_clouds", "total_cloud_cover_entire_atmosphere", "low_clouds", "low_cloud_cover_low_cloud", "mid_clouds", "medium_cloud_cover_middle_cloud", "high_clouds", "high_cloud_cover_high_cloud", "self", "output_variables", "temp_air", "wind_speed", "ghi", "dni", "dhi", "total_clouds", "low_clouds", "mid_clouds", "high_clouds", "super", "__init__", "model_type", "model", "set_type"], "doc_len": 69}
{"doc_id": "pvlib/forecast.py::RAP.process_data", "file_path": "pvlib/forecast.py", "class_name": "RAP", "func_name": "process_data", "text": "文件路径: pvlib/forecast.py, 类名: RAP\n    def process_data(self, data, cloud_cover='total_clouds', **kwargs):\n        \"\"\"\n        Defines the steps needed to convert raw forecast data\n        into processed forecast data.\n\n        Parameters\n        ----------\n        data: DataFrame\n            Raw forecast data\n        cloud_cover: str, default 'total_clouds'\n            The type of cloud cover used to infer the irradiance.\n\n        Returns\n        -------\n        data: DataFrame\n            Processed forecast data.\n        \"\"\"\n\n        data = super().process_data(data, **kwargs)\n        data['temp_air'] = self.kelvin_to_celsius(data['temp_air'])\n        data['wind_speed'] = self.gust_to_speed(data)\n        irrads = self.cloud_cover_to_irradiance(data[cloud_cover], **kwargs)\n        data = data.join(irrads, how='outer')\n        return data[self.output_variables]\n", "tokens": ["pvlib", "forecast", "py", "rap", "def", "process_data", "self", "data", "cloud_cover", "total_clouds", "kwargs", "defines", "the", "steps", "needed", "to", "convert", "raw", "forecast", "data", "into", "processed", "forecast", "data", "parameters", "data", "dataframe", "raw", "forecast", "data", "cloud_cover", "str", "default", "total_clouds", "the", "type", "of", "cloud", "cover", "used", "to", "infer", "the", "irradiance", "returns", "data", "dataframe", "processed", "forecast", "data", "data", "super", "process_data", "data", "kwargs", "data", "temp_air", "self", "kelvin_to_celsius", "data", "temp_air", "data", "wind_speed", "self", "gust_to_speed", "data", "irrads", "self", "cloud_cover_to_irradiance", "data", "cloud_cover", "kwargs", "data", "data", "join", "irrads", "how", "outer", "return", "data", "self", "output_variables"], "doc_len": 82}
{"doc_id": "pvlib/iam.py::ashrae", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "ashrae", "text": "文件路径: pvlib/iam.py\ndef ashrae(aoi, b=0.05):\n    r\"\"\"\n    Determine the incidence angle modifier using the ASHRAE transmission\n    model.\n\n    The ASHRAE (American Society of Heating, Refrigeration, and Air\n    Conditioning Engineers) transmission model is developed in\n    [1]_, and in [2]_. The model has been used in software such as PVSyst [3]_.\n\n    Parameters\n    ----------\n    aoi : numeric\n        The angle of incidence (AOI) between the module normal vector and the\n        sun-beam vector in degrees. Angles of nan will result in nan.\n\n    b : float, default 0.05\n        A parameter to adjust the incidence angle modifier as a function of\n        angle of incidence. Typical values are on the order of 0.05 [3].\n\n    Returns\n    -------\n    iam : numeric\n        The incident angle modifier (IAM). Returns zero for all abs(aoi) >= 90\n        and for all ``iam`` values that would be less than 0.\n\n    Notes\n    -----\n    The incidence angle modifier is calculated as\n\n    .. math::\n\n        IAM = 1 - b (\\sec(aoi) - 1)\n\n    As AOI approaches 90 degrees, the model yields negative values for IAM;\n    negative IAM values are set to zero in this implementation.\n\n    References\n    ----------\n    .. [1] Souka A.F., Safwat H.H., \"Determination of the optimum\n       orientations for the double exposure flat-plate collector and its\n       reflections\". Solar Energy vol .10, pp 170-174. 1966.\n\n    .. [2] ASHRAE standard 93-77\n\n    .. [3] PVsyst Contextual Help.\n       https://files.pvsyst.com/help/index.html?iam_loss.htm retrieved on\n       October 14, 2019\n\n    See Also\n    --------\n    pvlib.iam.physical\n    pvlib.iam.martin_ruiz\n    pvlib.iam.interp\n    \"\"\"\n\n    iam = 1 - b * (1 / np.cos(np.radians(aoi)) - 1)\n    aoi_gte_90 = np.full_like(aoi, False, dtype='bool')\n    np.greater_equal(np.abs(aoi), 90, where=~np.isnan(aoi), out=aoi_gte_90)\n    iam = np.where(aoi_gte_90, 0, iam)\n    iam = np.maximum(0, iam)\n\n    if isinstance(aoi, pd.Series):\n        iam = pd.Series(iam, index=aoi.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "ashrae", "aoi", "b", "0", "05", "r", "determine", "the", "incidence", "angle", "modifier", "using", "the", "ashrae", "transmission", "model", "the", "ashrae", "american", "society", "of", "heating", "refrigeration", "and", "air", "conditioning", "engineers", "transmission", "model", "is", "developed", "in", "1", "_", "and", "in", "2", "_", "the", "model", "has", "been", "used", "in", "software", "such", "as", "pvsyst", "3", "_", "parameters", "aoi", "numeric", "the", "angle", "of", "incidence", "aoi", "between", "the", "module", "normal", "vector", "and", "the", "sun", "beam", "vector", "in", "degrees", "angles", "of", "nan", "will", "result", "in", "nan", "b", "float", "default", "0", "05", "a", "parameter", "to", "adjust", "the", "incidence", "angle", "modifier", "as", "a", "function", "of", "angle", "of", "incidence", "typical", "values", "are", "on", "the", "order", "of", "0", "05", "3", "returns", "iam", "numeric", "the", "incident", "angle", "modifier", "iam", "returns", "zero", "for", "all", "abs", "aoi", "90", "and", "for", "all", "iam", "values", "that", "would", "be", "less", "than", "0", "notes", "the", "incidence", "angle", "modifier", "is", "calculated", "as", "math", "iam", "1", "b", "sec", "aoi", "1", "as", "aoi", "approaches", "90", "degrees", "the", "model", "yields", "negative", "values", "for", "iam", "negative", "iam", "values", "are", "set", "to", "zero", "in", "this", "implementation", "references", "1", "souka", "a", "f", "safwat", "h", "h", "determination", "of", "the", "optimum", "orientations", "for", "the", "double", "exposure", "flat", "plate", "collector", "and", "its", "reflections", "solar", "energy", "vol", "10", "pp", "170", "174", "1966", "2", "ashrae", "standard", "93", "77", "3", "pvsyst", "contextual", "help", "https", "files", "pvsyst", "com", "help", "index", "html", "iam_loss", "htm", "retrieved", "on", "october", "14", "2019", "see", "also", "pvlib", "iam", "physical", "pvlib", "iam", "martin_ruiz", "pvlib", "iam", "interp", "iam", "1", "b", "1", "np", "cos", "np", "radians", "aoi", "1", "aoi_gte_90", "np", "full_like", "aoi", "false", "dtype", "bool", "np", "greater_equal", "np", "abs", "aoi", "90", "where", "np", "isnan", "aoi", "out", "aoi_gte_90", "iam", "np", "where", "aoi_gte_90", "0", "iam", "iam", "np", "maximum", "0", "iam", "if", "isinstance", "aoi", "pd", "series", "iam", "pd", "series", "iam", "index", "aoi", "index", "return", "iam"], "doc_len": 293}
{"doc_id": "pvlib/iam.py::physical", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "physical", "text": "文件路径: pvlib/iam.py\ndef physical(aoi, n=1.526, K=4., L=0.002):\n    r\"\"\"\n    Determine the incidence angle modifier using refractive index ``n``,\n    extinction coefficient ``K``, and glazing thickness ``L``.\n\n    ``iam.physical`` calculates the incidence angle modifier as described in\n    [1]_, Section 3. The calculation is based on a physical model of absorbtion\n    and transmission through a transparent cover.\n\n    Parameters\n    ----------\n    aoi : numeric\n        The angle of incidence between the module normal vector and the\n        sun-beam vector in degrees. Angles of 0 are replaced with 1e-06\n        to ensure non-nan results. Angles of nan will result in nan.\n\n    n : numeric, default 1.526\n        The effective index of refraction (unitless). Reference [1]_\n        indicates that a value of 1.526 is acceptable for glass.\n\n    K : numeric, default 4.0\n        The glazing extinction coefficient in units of 1/meters.\n        Reference [1] indicates that a value of 4 is reasonable for\n        \"water white\" glass.\n\n    L : numeric, default 0.002\n        The glazing thickness in units of meters. Reference [1]_\n        indicates that 0.002 meters (2 mm) is reasonable for most\n        glass-covered PV panels.\n\n    Returns\n    -------\n    iam : numeric\n        The incident angle modifier\n\n    Notes\n    -----\n    The pvlib python authors believe that Eqn. 14 in [1]_ is\n    incorrect, which presents :math:`\\theta_{r} = \\arcsin(n \\sin(AOI))`.\n    Here, :math:`\\theta_{r} = \\arcsin(1/n \\times \\sin(AOI))`\n\n    References\n    ----------\n    .. [1] W. De Soto et al., \"Improvement and validation of a model for\n       photovoltaic array performance\", Solar Energy, vol 80, pp. 78-88,\n       2006.\n\n    .. [2] Duffie, John A. & Beckman, William A.. (2006). Solar Engineering\n       of Thermal Processes, third edition. [Books24x7 version] Available\n       from http://common.books24x7.com/toc.aspx?bookid=17160.\n\n    See Also\n    --------\n    pvlib.iam.martin_ruiz\n    pvlib.iam.ashrae\n    pvlib.iam.interp\n    pvlib.iam.sapm\n    \"\"\"\n    zeroang = 1e-06\n\n    # hold a new reference to the input aoi object since we're going to\n    # overwrite the aoi reference below, but we'll need it for the\n    # series check at the end of the function\n    aoi_input = aoi\n\n    aoi = np.where(aoi == 0, zeroang, aoi)\n\n    # angle of reflection\n    thetar_deg = asind(1.0 / n * (sind(aoi)))\n\n    # reflectance and transmittance for normal incidence light\n    rho_zero = ((1-n) / (1+n)) ** 2\n    tau_zero = np.exp(-K*L)\n\n    # reflectance for parallel and perpendicular polarized light\n    rho_para = (tand(thetar_deg - aoi) / tand(thetar_deg + aoi)) ** 2\n    rho_perp = (sind(thetar_deg - aoi) / sind(thetar_deg + aoi)) ** 2\n\n    # transmittance for non-normal light\n    tau = np.exp(-K * L / cosd(thetar_deg))\n\n    # iam is ratio of non-normal to normal incidence transmitted light\n    # after deducting the reflected portion of each\n    iam = ((1 - (rho_para + rho_perp) / 2) / (1 - rho_zero) * tau / tau_zero)\n\n    with np.errstate(invalid='ignore'):\n        # angles near zero produce nan, but iam is defined as one\n        small_angle = 1e-06\n        iam = np.where(np.abs(aoi) < small_angle, 1.0, iam)\n\n        # angles at 90 degrees can produce tiny negative values,\n        # which should be zero. this is a result of calculation precision\n        # rather than the physical model\n        iam = np.where(iam < 0, 0, iam)\n\n        # for light coming from behind the plane, none can enter the module\n        iam = np.where(aoi > 90, 0, iam)\n\n    if isinstance(aoi_input, pd.Series):\n        iam = pd.Series(iam, index=aoi_input.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "physical", "aoi", "n", "1", "526", "k", "4", "l", "0", "002", "r", "determine", "the", "incidence", "angle", "modifier", "using", "refractive", "index", "n", "extinction", "coefficient", "k", "and", "glazing", "thickness", "l", "iam", "physical", "calculates", "the", "incidence", "angle", "modifier", "as", "described", "in", "1", "_", "section", "3", "the", "calculation", "is", "based", "on", "a", "physical", "model", "of", "absorbtion", "and", "transmission", "through", "a", "transparent", "cover", "parameters", "aoi", "numeric", "the", "angle", "of", "incidence", "between", "the", "module", "normal", "vector", "and", "the", "sun", "beam", "vector", "in", "degrees", "angles", "of", "0", "are", "replaced", "with", "1e", "06", "to", "ensure", "non", "nan", "results", "angles", "of", "nan", "will", "result", "in", "nan", "n", "numeric", "default", "1", "526", "the", "effective", "index", "of", "refraction", "unitless", "reference", "1", "_", "indicates", "that", "a", "value", "of", "1", "526", "is", "acceptable", "for", "glass", "k", "numeric", "default", "4", "0", "the", "glazing", "extinction", "coefficient", "in", "units", "of", "1", "meters", "reference", "1", "indicates", "that", "a", "value", "of", "4", "is", "reasonable", "for", "water", "white", "glass", "l", "numeric", "default", "0", "002", "the", "glazing", "thickness", "in", "units", "of", "meters", "reference", "1", "_", "indicates", "that", "0", "002", "meters", "2", "mm", "is", "reasonable", "for", "most", "glass", "covered", "pv", "panels", "returns", "iam", "numeric", "the", "incident", "angle", "modifier", "notes", "the", "pvlib", "python", "authors", "believe", "that", "eqn", "14", "in", "1", "_", "is", "incorrect", "which", "presents", "math", "theta_", "r", "arcsin", "n", "sin", "aoi", "here", "math", "theta_", "r", "arcsin", "1", "n", "times", "sin", "aoi", "references", "1", "w", "de", "soto", "et", "al", "improvement", "and", "validation", "of", "a", "model", "for", "photovoltaic", "array", "performance", "solar", "energy", "vol", "80", "pp", "78", "88", "2006", "2", "duffie", "john", "a", "beckman", "william", "a", "2006", "solar", "engineering", "of", "thermal", "processes", "third", "edition", "books24x7", "version", "available", "from", "http", "common", "books24x7", "com", "toc", "aspx", "bookid", "17160", "see", "also", "pvlib", "iam", "martin_ruiz", "pvlib", "iam", "ashrae", "pvlib", "iam", "interp", "pvlib", "iam", "sapm", "zeroang", "1e", "06", "hold", "a", "new", "reference", "to", "the", "input", "aoi", "object", "since", "we", "re", "going", "to", "overwrite", "the", "aoi", "reference", "below", "but", "we", "ll", "need", "it", "for", "the", "series", "check", "at", "the", "end", "of", "the", "function", "aoi_input", "aoi", "aoi", "np", "where", "aoi", "0", "zeroang", "aoi", "angle", "of", "reflection", "thetar_deg", "asind", "1", "0", "n", "sind", "aoi", "reflectance", "and", "transmittance", "for", "normal", "incidence", "light", "rho_zero", "1", "n", "1", "n", "2", "tau_zero", "np", "exp", "k", "l", "reflectance", "for", "parallel", "and", "perpendicular", "polarized", "light", "rho_para", "tand", "thetar_deg", "aoi", "tand", "thetar_deg", "aoi", "2", "rho_perp", "sind", "thetar_deg", "aoi", "sind", "thetar_deg", "aoi", "2", "transmittance", "for", "non", "normal", "light", "tau", "np", "exp", "k", "l", "cosd", "thetar_deg", "iam", "is", "ratio", "of", "non", "normal", "to", "normal", "incidence", "transmitted", "light", "after", "deducting", "the", "reflected", "portion", "of", "each", "iam", "1", "rho_para", "rho_perp", "2", "1", "rho_zero", "tau", "tau_zero", "with", "np", "errstate", "invalid", "ignore", "angles", "near", "zero", "produce", "nan", "but", "iam", "is", "defined", "as", "one", "small_angle", "1e", "06", "iam", "np", "where", "np", "abs", "aoi", "small_angle", "1", "0", "iam", "angles", "at", "90", "degrees", "can", "produce", "tiny", "negative", "values", "which", "should", "be", "zero", "this", "is", "a", "result", "of", "calculation", "precision", "rather", "than", "the", "physical", "model", "iam", "np", "where", "iam", "0", "0", "iam", "for", "light", "coming", "from", "behind", "the", "plane", "none", "can", "enter", "the", "module", "iam", "np", "where", "aoi", "90", "0", "iam", "if", "isinstance", "aoi_input", "pd", "series", "iam", "pd", "series", "iam", "index", "aoi_input", "index", "return", "iam"], "doc_len": 519}
{"doc_id": "pvlib/iam.py::martin_ruiz", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "martin_ruiz", "text": "文件路径: pvlib/iam.py\ndef martin_ruiz(aoi, a_r=0.16):\n    r'''\n    Determine the incidence angle modifier (IAM) using the Martin\n    and Ruiz incident angle model.\n\n    Parameters\n    ----------\n    aoi : numeric, degrees\n        The angle of incidence between the module normal vector and the\n        sun-beam vector in degrees.\n\n    a_r : numeric\n        The angular losses coefficient described in equation 3 of [1]_.\n        This is an empirical dimensionless parameter. Values of ``a_r`` are\n        generally on the order of 0.08 to 0.25 for flat-plate PV modules.\n\n    Returns\n    -------\n    iam : numeric\n        The incident angle modifier(s)\n\n    Notes\n    -----\n    `martin_ruiz` calculates the incidence angle modifier (IAM) as described in\n    [1]_. The information required is the incident angle (AOI) and the angular\n    losses coefficient (a_r). Note that [1]_ has a corrigendum [2]_ which\n    clarifies a mix-up of 'alpha's and 'a's in the former.\n\n    The incident angle modifier is defined as\n\n    .. math::\n\n       IAM = \\frac{1 - \\exp(-\\frac{\\cos(aoi)}{a_r})}\n       {1 - \\exp(\\frac{-1}{a_r})}\n\n    which is presented as :math:`AL(\\alpha) = 1 - IAM` in equation 4 of [1]_,\n    with :math:`\\alpha` representing the angle of incidence AOI. Thus IAM = 1\n    at AOI = 0, and IAM = 0 at AOI = 90.  This equation is only valid for\n    -90 <= aoi <= 90, therefore `iam` is constrained to 0.0 outside this\n    interval.\n\n    References\n    ----------\n    .. [1] N. Martin and J. M. Ruiz, \"Calculation of the PV modules angular\n       losses under field conditions by means of an analytical model\", Solar\n       Energy Materials & Solar Cells, vol. 70, pp. 25-38, 2001.\n\n    .. [2] N. Martin and J. M. Ruiz, \"Corrigendum to 'Calculation of the PV\n       modules angular losses under field conditions by means of an\n       analytical model'\", Solar Energy Materials & Solar Cells, vol. 110,\n       pp. 154, 2013.\n\n    See Also\n    --------\n    pvlib.iam.martin_ruiz_diffuse\n    pvlib.iam.physical\n    pvlib.iam.ashrae\n    pvlib.iam.interp\n    pvlib.iam.sapm\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. July, 2019\n\n    aoi_input = aoi\n\n    aoi = np.asanyarray(aoi)\n    a_r = np.asanyarray(a_r)\n\n    if np.any(np.less_equal(a_r, 0)):\n        raise ValueError(\"The parameter 'a_r' cannot be zero or negative.\")\n\n    with np.errstate(invalid='ignore'):\n        iam = (1 - np.exp(-cosd(aoi) / a_r)) / (1 - np.exp(-1 / a_r))\n        iam = np.where(np.abs(aoi) >= 90.0, 0.0, iam)\n\n    if isinstance(aoi_input, pd.Series):\n        iam = pd.Series(iam, index=aoi_input.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "martin_ruiz", "aoi", "a_r", "0", "16", "r", "determine", "the", "incidence", "angle", "modifier", "iam", "using", "the", "martin", "and", "ruiz", "incident", "angle", "model", "parameters", "aoi", "numeric", "degrees", "the", "angle", "of", "incidence", "between", "the", "module", "normal", "vector", "and", "the", "sun", "beam", "vector", "in", "degrees", "a_r", "numeric", "the", "angular", "losses", "coefficient", "described", "in", "equation", "3", "of", "1", "_", "this", "is", "an", "empirical", "dimensionless", "parameter", "values", "of", "a_r", "are", "generally", "on", "the", "order", "of", "0", "08", "to", "0", "25", "for", "flat", "plate", "pv", "modules", "returns", "iam", "numeric", "the", "incident", "angle", "modifier", "s", "notes", "martin_ruiz", "calculates", "the", "incidence", "angle", "modifier", "iam", "as", "described", "in", "1", "_", "the", "information", "required", "is", "the", "incident", "angle", "aoi", "and", "the", "angular", "losses", "coefficient", "a_r", "note", "that", "1", "_", "has", "a", "corrigendum", "2", "_", "which", "clarifies", "a", "mix", "up", "of", "alpha", "s", "and", "a", "s", "in", "the", "former", "the", "incident", "angle", "modifier", "is", "defined", "as", "math", "iam", "frac", "1", "exp", "frac", "cos", "aoi", "a_r", "1", "exp", "frac", "1", "a_r", "which", "is", "presented", "as", "math", "al", "alpha", "1", "iam", "in", "equation", "4", "of", "1", "_", "with", "math", "alpha", "representing", "the", "angle", "of", "incidence", "aoi", "thus", "iam", "1", "at", "aoi", "0", "and", "iam", "0", "at", "aoi", "90", "this", "equation", "is", "only", "valid", "for", "90", "aoi", "90", "therefore", "iam", "is", "constrained", "to", "0", "0", "outside", "this", "interval", "references", "1", "n", "martin", "and", "j", "m", "ruiz", "calculation", "of", "the", "pv", "modules", "angular", "losses", "under", "field", "conditions", "by", "means", "of", "an", "analytical", "model", "solar", "energy", "materials", "solar", "cells", "vol", "70", "pp", "25", "38", "2001", "2", "n", "martin", "and", "j", "m", "ruiz", "corrigendum", "to", "calculation", "of", "the", "pv", "modules", "angular", "losses", "under", "field", "conditions", "by", "means", "of", "an", "analytical", "model", "solar", "energy", "materials", "solar", "cells", "vol", "110", "pp", "154", "2013", "see", "also", "pvlib", "iam", "martin_ruiz_diffuse", "pvlib", "iam", "physical", "pvlib", "iam", "ashrae", "pvlib", "iam", "interp", "pvlib", "iam", "sapm", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "july", "2019", "aoi_input", "aoi", "aoi", "np", "asanyarray", "aoi", "a_r", "np", "asanyarray", "a_r", "if", "np", "any", "np", "less_equal", "a_r", "0", "raise", "valueerror", "the", "parameter", "a_r", "cannot", "be", "zero", "or", "negative", "with", "np", "errstate", "invalid", "ignore", "iam", "1", "np", "exp", "cosd", "aoi", "a_r", "1", "np", "exp", "1", "a_r", "iam", "np", "where", "np", "abs", "aoi", "90", "0", "0", "0", "iam", "if", "isinstance", "aoi_input", "pd", "series", "iam", "pd", "series", "iam", "index", "aoi_input", "index", "return", "iam"], "doc_len": 382}
{"doc_id": "pvlib/iam.py::martin_ruiz_diffuse", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "martin_ruiz_diffuse", "text": "文件路径: pvlib/iam.py\ndef martin_ruiz_diffuse(surface_tilt, a_r=0.16, c1=0.4244, c2=None):\n    '''\n    Determine the incidence angle modifiers (iam) for diffuse sky and\n    ground-reflected irradiance using the Martin and Ruiz incident angle model.\n\n    Parameters\n    ----------\n    surface_tilt: float or array-like, default 0\n        Surface tilt angles in decimal degrees.\n        The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90)\n        surface_tilt must be in the range [0, 180]\n\n    a_r : numeric\n        The angular losses coefficient described in equation 3 of [1]_.\n        This is an empirical dimensionless parameter. Values of a_r are\n        generally on the order of 0.08 to 0.25 for flat-plate PV modules.\n        a_r must be greater than zero.\n\n    c1 : float\n        First fitting parameter for the expressions that approximate the\n        integral of diffuse irradiance coming from different directions.\n        c1 is given as the constant 4 / 3 / pi (0.4244) in [1]_.\n\n    c2 : float\n        Second fitting parameter for the expressions that approximate the\n        integral of diffuse irradiance coming from different directions.\n        If c2 is None, it will be calculated according to the linear\n        relationship given in [3]_.\n\n    Returns\n    -------\n    iam_sky : numeric\n        The incident angle modifier for sky diffuse\n\n    iam_ground : numeric\n        The incident angle modifier for ground-reflected diffuse\n\n    Notes\n    -----\n    Sky and ground modifiers are complementary: iam_sky for tilt = 30 is\n    equal to iam_ground for tilt = 180 - 30.  For vertical surfaces,\n    tilt = 90, the two factors are equal.\n\n    References\n    ----------\n    .. [1] N. Martin and J. M. Ruiz, \"Calculation of the PV modules angular\n       losses under field conditions by means of an analytical model\", Solar\n       Energy Materials & Solar Cells, vol. 70, pp. 25-38, 2001.\n\n    .. [2] N. Martin and J. M. Ruiz, \"Corrigendum to 'Calculation of the PV\n       modules angular losses under field conditions by means of an\n       analytical model'\", Solar Energy Materials & Solar Cells, vol. 110,\n       pp. 154, 2013.\n\n    .. [3] \"IEC 61853-3 Photovoltaic (PV) module performance testing and energy\n       rating - Part 3: Energy rating of PV modules\". IEC, Geneva, 2018.\n\n    See Also\n    --------\n    pvlib.iam.martin_ruiz\n    pvlib.iam.physical\n    pvlib.iam.ashrae\n    pvlib.iam.interp\n    pvlib.iam.sapm\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Oct. 2019\n\n    if isinstance(surface_tilt, pd.Series):\n        out_index = surface_tilt.index\n    else:\n        out_index = None\n\n    surface_tilt = np.asanyarray(surface_tilt)\n\n    # avoid undefined results for horizontal or upside-down surfaces\n    zeroang = 1e-06\n\n    surface_tilt = np.where(surface_tilt == 0, zeroang, surface_tilt)\n    surface_tilt = np.where(surface_tilt == 180, 180 - zeroang, surface_tilt)\n\n    if c2 is None:\n        # This equation is from [3] Sect. 7.2\n        c2 = 0.5 * a_r - 0.154\n\n    beta = np.radians(surface_tilt)\n    sin = np.sin\n    pi = np.pi\n    cos = np.cos\n\n    # avoid RuntimeWarnings for <, sin, and cos with nan\n    with np.errstate(invalid='ignore'):\n        # because sin(pi) isn't exactly zero\n        sin_beta = np.where(surface_tilt < 90, sin(beta), sin(pi - beta))\n\n        trig_term_sky = sin_beta + (pi - beta - sin_beta) / (1 + cos(beta))\n        trig_term_gnd = sin_beta +      (beta - sin_beta) / (1 - cos(beta))  # noqa: E222 E261 E501\n\n    iam_sky = 1 - np.exp(-(c1 + c2 * trig_term_sky) * trig_term_sky / a_r)\n    iam_gnd = 1 - np.exp(-(c1 + c2 * trig_term_gnd) * trig_term_gnd / a_r)\n\n    if out_index is not None:\n        iam_sky = pd.Series(iam_sky, index=out_index, name='iam_sky')\n        iam_gnd = pd.Series(iam_gnd, index=out_index, name='iam_ground')\n\n    return iam_sky, iam_gnd\n", "tokens": ["pvlib", "iam", "py", "def", "martin_ruiz_diffuse", "surface_tilt", "a_r", "0", "16", "c1", "0", "4244", "c2", "none", "determine", "the", "incidence", "angle", "modifiers", "iam", "for", "diffuse", "sky", "and", "ground", "reflected", "irradiance", "using", "the", "martin", "and", "ruiz", "incident", "angle", "model", "parameters", "surface_tilt", "float", "or", "array", "like", "default", "0", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_tilt", "must", "be", "in", "the", "range", "0", "180", "a_r", "numeric", "the", "angular", "losses", "coefficient", "described", "in", "equation", "3", "of", "1", "_", "this", "is", "an", "empirical", "dimensionless", "parameter", "values", "of", "a_r", "are", "generally", "on", "the", "order", "of", "0", "08", "to", "0", "25", "for", "flat", "plate", "pv", "modules", "a_r", "must", "be", "greater", "than", "zero", "c1", "float", "first", "fitting", "parameter", "for", "the", "expressions", "that", "approximate", "the", "integral", "of", "diffuse", "irradiance", "coming", "from", "different", "directions", "c1", "is", "given", "as", "the", "constant", "4", "3", "pi", "0", "4244", "in", "1", "_", "c2", "float", "second", "fitting", "parameter", "for", "the", "expressions", "that", "approximate", "the", "integral", "of", "diffuse", "irradiance", "coming", "from", "different", "directions", "if", "c2", "is", "none", "it", "will", "be", "calculated", "according", "to", "the", "linear", "relationship", "given", "in", "3", "_", "returns", "iam_sky", "numeric", "the", "incident", "angle", "modifier", "for", "sky", "diffuse", "iam_ground", "numeric", "the", "incident", "angle", "modifier", "for", "ground", "reflected", "diffuse", "notes", "sky", "and", "ground", "modifiers", "are", "complementary", "iam_sky", "for", "tilt", "30", "is", "equal", "to", "iam_ground", "for", "tilt", "180", "30", "for", "vertical", "surfaces", "tilt", "90", "the", "two", "factors", "are", "equal", "references", "1", "n", "martin", "and", "j", "m", "ruiz", "calculation", "of", "the", "pv", "modules", "angular", "losses", "under", "field", "conditions", "by", "means", "of", "an", "analytical", "model", "solar", "energy", "materials", "solar", "cells", "vol", "70", "pp", "25", "38", "2001", "2", "n", "martin", "and", "j", "m", "ruiz", "corrigendum", "to", "calculation", "of", "the", "pv", "modules", "angular", "losses", "under", "field", "conditions", "by", "means", "of", "an", "analytical", "model", "solar", "energy", "materials", "solar", "cells", "vol", "110", "pp", "154", "2013", "3", "iec", "61853", "3", "photovoltaic", "pv", "module", "performance", "testing", "and", "energy", "rating", "part", "3", "energy", "rating", "of", "pv", "modules", "iec", "geneva", "2018", "see", "also", "pvlib", "iam", "martin_ruiz", "pvlib", "iam", "physical", "pvlib", "iam", "ashrae", "pvlib", "iam", "interp", "pvlib", "iam", "sapm", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "oct", "2019", "if", "isinstance", "surface_tilt", "pd", "series", "out_index", "surface_tilt", "index", "else", "out_index", "none", "surface_tilt", "np", "asanyarray", "surface_tilt", "avoid", "undefined", "results", "for", "horizontal", "or", "upside", "down", "surfaces", "zeroang", "1e", "06", "surface_tilt", "np", "where", "surface_tilt", "0", "zeroang", "surface_tilt", "surface_tilt", "np", "where", "surface_tilt", "180", "180", "zeroang", "surface_tilt", "if", "c2", "is", "none", "this", "equation", "is", "from", "3", "sect", "7", "2", "c2", "0", "5", "a_r", "0", "154", "beta", "np", "radians", "surface_tilt", "sin", "np", "sin", "pi", "np", "pi", "cos", "np", "cos", "avoid", "runtimewarnings", "for", "sin", "and", "cos", "with", "nan", "with", "np", "errstate", "invalid", "ignore", "because", "sin", "pi", "isn", "t", "exactly", "zero", "sin_beta", "np", "where", "surface_tilt", "90", "sin", "beta", "sin", "pi", "beta", "trig_term_sky", "sin_beta", "pi", "beta", "sin_beta", "1", "cos", "beta", "trig_term_gnd", "sin_beta", "beta", "sin_beta", "1", "cos", "beta", "noqa", "e222", "e261", "e501", "iam_sky", "1", "np", "exp", "c1", "c2", "trig_term_sky", "trig_term_sky", "a_r", "iam_gnd", "1", "np", "exp", "c1", "c2", "trig_term_gnd", "trig_term_gnd", "a_r", "if", "out_index", "is", "not", "none", "iam_sky", "pd", "series", "iam_sky", "index", "out_index", "name", "iam_sky", "iam_gnd", "pd", "series", "iam_gnd", "index", "out_index", "name", "iam_ground", "return", "iam_sky", "iam_gnd"], "doc_len": 521}
{"doc_id": "pvlib/iam.py::interp", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "interp", "text": "文件路径: pvlib/iam.py\ndef interp(aoi, theta_ref, iam_ref, method='linear', normalize=True):\n    r'''\n    Determine the incidence angle modifier (IAM) by interpolating a set of\n    reference values, which are usually measured values.\n\n    Parameters\n    ----------\n    aoi : numeric\n        The angle of incidence between the module normal vector and the\n        sun-beam vector [degrees].\n\n    theta_ref : numeric\n        Vector of angles at which the IAM is known [degrees].\n\n    iam_ref : numeric\n        IAM values for each angle in ``theta_ref`` [unitless].\n\n    method : str, default 'linear'\n        Specifies the interpolation method.\n        Useful options are: 'linear', 'quadratic', 'cubic'.\n        See scipy.interpolate.interp1d for more options.\n\n    normalize : boolean, default True\n        When true, the interpolated values are divided by the interpolated\n        value at zero degrees.  This ensures that ``iam=1.0`` at normal\n        incidence.\n\n    Returns\n    -------\n    iam : numeric\n        The incident angle modifier(s) [unitless]\n\n    Notes\n    -----\n    ``theta_ref`` must have two or more points and may span any range of\n    angles. Typically there will be a dozen or more points in the range 0-90\n    degrees. Beyond the range of ``theta_ref``, IAM values are extrapolated,\n    but constrained to be non-negative.\n\n    The sign of ``aoi`` is ignored; only the magnitude is used.\n\n    See Also\n    --------\n    pvlib.iam.physical\n    pvlib.iam.ashrae\n    pvlib.iam.martin_ruiz\n    pvlib.iam.sapm\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. July, 2019\n\n    from scipy.interpolate import interp1d\n\n    # Scipy doesn't give the clearest feedback, so check number of points here.\n    MIN_REF_VALS = {'linear': 2, 'quadratic': 3, 'cubic': 4, 1: 2, 2: 3, 3: 4}\n\n    if len(theta_ref) < MIN_REF_VALS.get(method, 2):\n        raise ValueError(\"Too few reference points defined \"\n                         \"for interpolation method '%s'.\" % method)\n\n    if np.any(np.less(iam_ref, 0)):\n        raise ValueError(\"Negative value(s) found in 'iam_ref'. \"\n                         \"This is not physically possible.\")\n\n    interpolator = interp1d(theta_ref, iam_ref, kind=method,\n                            fill_value='extrapolate')\n    aoi_input = aoi\n\n    aoi = np.asanyarray(aoi)\n    aoi = np.abs(aoi)\n    iam = interpolator(aoi)\n    iam = np.clip(iam, 0, None)\n\n    if normalize:\n        iam /= interpolator(0)\n\n    if isinstance(aoi_input, pd.Series):\n        iam = pd.Series(iam, index=aoi_input.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "interp", "aoi", "theta_ref", "iam_ref", "method", "linear", "normalize", "true", "r", "determine", "the", "incidence", "angle", "modifier", "iam", "by", "interpolating", "a", "set", "of", "reference", "values", "which", "are", "usually", "measured", "values", "parameters", "aoi", "numeric", "the", "angle", "of", "incidence", "between", "the", "module", "normal", "vector", "and", "the", "sun", "beam", "vector", "degrees", "theta_ref", "numeric", "vector", "of", "angles", "at", "which", "the", "iam", "is", "known", "degrees", "iam_ref", "numeric", "iam", "values", "for", "each", "angle", "in", "theta_ref", "unitless", "method", "str", "default", "linear", "specifies", "the", "interpolation", "method", "useful", "options", "are", "linear", "quadratic", "cubic", "see", "scipy", "interpolate", "interp1d", "for", "more", "options", "normalize", "boolean", "default", "true", "when", "true", "the", "interpolated", "values", "are", "divided", "by", "the", "interpolated", "value", "at", "zero", "degrees", "this", "ensures", "that", "iam", "1", "0", "at", "normal", "incidence", "returns", "iam", "numeric", "the", "incident", "angle", "modifier", "s", "unitless", "notes", "theta_ref", "must", "have", "two", "or", "more", "points", "and", "may", "span", "any", "range", "of", "angles", "typically", "there", "will", "be", "a", "dozen", "or", "more", "points", "in", "the", "range", "0", "90", "degrees", "beyond", "the", "range", "of", "theta_ref", "iam", "values", "are", "extrapolated", "but", "constrained", "to", "be", "non", "negative", "the", "sign", "of", "aoi", "is", "ignored", "only", "the", "magnitude", "is", "used", "see", "also", "pvlib", "iam", "physical", "pvlib", "iam", "ashrae", "pvlib", "iam", "martin_ruiz", "pvlib", "iam", "sapm", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "july", "2019", "from", "scipy", "interpolate", "import", "interp1d", "scipy", "doesn", "t", "give", "the", "clearest", "feedback", "so", "check", "number", "of", "points", "here", "min_ref_vals", "linear", "2", "quadratic", "3", "cubic", "4", "1", "2", "2", "3", "3", "4", "if", "len", "theta_ref", "min_ref_vals", "get", "method", "2", "raise", "valueerror", "too", "few", "reference", "points", "defined", "for", "interpolation", "method", "s", "method", "if", "np", "any", "np", "less", "iam_ref", "0", "raise", "valueerror", "negative", "value", "s", "found", "in", "iam_ref", "this", "is", "not", "physically", "possible", "interpolator", "interp1d", "theta_ref", "iam_ref", "kind", "method", "fill_value", "extrapolate", "aoi_input", "aoi", "aoi", "np", "asanyarray", "aoi", "aoi", "np", "abs", "aoi", "iam", "interpolator", "aoi", "iam", "np", "clip", "iam", "0", "none", "if", "normalize", "iam", "interpolator", "0", "if", "isinstance", "aoi_input", "pd", "series", "iam", "pd", "series", "iam", "index", "aoi_input", "index", "return", "iam"], "doc_len": 324}
{"doc_id": "pvlib/iam.py::sapm", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "sapm", "text": "文件路径: pvlib/iam.py\ndef sapm(aoi, module, upper=None):\n    r\"\"\"\n    Determine the incidence angle modifier (IAM) using the SAPM model.\n\n    Parameters\n    ----------\n    aoi : numeric\n        Angle of incidence in degrees. Negative input angles will return\n        zeros.\n\n    module : dict-like\n        A dict or Series with the SAPM IAM model parameters.\n        See the :py:func:`sapm` notes section for more details.\n\n    upper : None or float, default None\n        Upper limit on the results.\n\n    Returns\n    -------\n    iam : numeric\n        The SAPM angle of incidence loss coefficient, termed F2 in [1]_.\n\n    Notes\n    -----\n    The SAPM [1]_ traditionally does not define an upper limit on the AOI\n    loss function and values slightly exceeding 1 may exist for moderate\n    angles of incidence (15-40 degrees). However, users may consider\n    imposing an upper limit of 1.\n\n    References\n    ----------\n    .. [1] King, D. et al, 2004, \"Sandia Photovoltaic Array Performance\n       Model\", SAND Report 3535, Sandia National Laboratories, Albuquerque,\n       NM.\n\n    .. [2] B.H. King et al, \"Procedure to Determine Coefficients for the\n       Sandia Array Performance Model (SAPM),\" SAND2016-5284, Sandia\n       National Laboratories (2016).\n\n    .. [3] B.H. King et al, \"Recent Advancements in Outdoor Measurement\n       Techniques for Angle of Incidence Effects,\" 42nd IEEE PVSC (2015).\n       DOI: 10.1109/PVSC.2015.7355849\n\n    See Also\n    --------\n    pvlib.iam.physical\n    pvlib.iam.ashrae\n    pvlib.iam.martin_ruiz\n    pvlib.iam.interp\n    \"\"\"\n\n    aoi_coeff = [module['B5'], module['B4'], module['B3'], module['B2'],\n                 module['B1'], module['B0']]\n\n    iam = np.polyval(aoi_coeff, aoi)\n    iam = np.clip(iam, 0, upper)\n    # nan tolerant masking\n    aoi_lt_0 = np.full_like(aoi, False, dtype='bool')\n    np.less(aoi, 0, where=~np.isnan(aoi), out=aoi_lt_0)\n    iam = np.where(aoi_lt_0, 0, iam)\n\n    if isinstance(aoi, pd.Series):\n        iam = pd.Series(iam, aoi.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "sapm", "aoi", "module", "upper", "none", "r", "determine", "the", "incidence", "angle", "modifier", "iam", "using", "the", "sapm", "model", "parameters", "aoi", "numeric", "angle", "of", "incidence", "in", "degrees", "negative", "input", "angles", "will", "return", "zeros", "module", "dict", "like", "a", "dict", "or", "series", "with", "the", "sapm", "iam", "model", "parameters", "see", "the", "py", "func", "sapm", "notes", "section", "for", "more", "details", "upper", "none", "or", "float", "default", "none", "upper", "limit", "on", "the", "results", "returns", "iam", "numeric", "the", "sapm", "angle", "of", "incidence", "loss", "coefficient", "termed", "f2", "in", "1", "_", "notes", "the", "sapm", "1", "_", "traditionally", "does", "not", "define", "an", "upper", "limit", "on", "the", "aoi", "loss", "function", "and", "values", "slightly", "exceeding", "1", "may", "exist", "for", "moderate", "angles", "of", "incidence", "15", "40", "degrees", "however", "users", "may", "consider", "imposing", "an", "upper", "limit", "of", "1", "references", "1", "king", "d", "et", "al", "2004", "sandia", "photovoltaic", "array", "performance", "model", "sand", "report", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "2", "b", "h", "king", "et", "al", "procedure", "to", "determine", "coefficients", "for", "the", "sandia", "array", "performance", "model", "sapm", "sand2016", "5284", "sandia", "national", "laboratories", "2016", "3", "b", "h", "king", "et", "al", "recent", "advancements", "in", "outdoor", "measurement", "techniques", "for", "angle", "of", "incidence", "effects", "42nd", "ieee", "pvsc", "2015", "doi", "10", "1109", "pvsc", "2015", "7355849", "see", "also", "pvlib", "iam", "physical", "pvlib", "iam", "ashrae", "pvlib", "iam", "martin_ruiz", "pvlib", "iam", "interp", "aoi_coeff", "module", "b5", "module", "b4", "module", "b3", "module", "b2", "module", "b1", "module", "b0", "iam", "np", "polyval", "aoi_coeff", "aoi", "iam", "np", "clip", "iam", "0", "upper", "nan", "tolerant", "masking", "aoi_lt_0", "np", "full_like", "aoi", "false", "dtype", "bool", "np", "less", "aoi", "0", "where", "np", "isnan", "aoi", "out", "aoi_lt_0", "iam", "np", "where", "aoi_lt_0", "0", "iam", "if", "isinstance", "aoi", "pd", "series", "iam", "pd", "series", "iam", "aoi", "index", "return", "iam"], "doc_len": 272}
{"doc_id": "pvlib/iam.py::marion_diffuse", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "marion_diffuse", "text": "文件路径: pvlib/iam.py\ndef marion_diffuse(model, surface_tilt, **kwargs):\n    \"\"\"\n    Determine diffuse irradiance incidence angle modifiers using Marion's\n    method of integrating over solid angle.\n\n    Parameters\n    ----------\n    model : str\n        The IAM function to evaluate across solid angle. Must be one of\n        `'ashrae', 'physical', 'martin_ruiz', 'sapm', 'schlick'`.\n\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees.\n        The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90).\n\n    **kwargs\n        Extra parameters passed to the IAM function.\n\n    Returns\n    -------\n    iam : dict\n        IAM values for each type of diffuse irradiance:\n\n            * 'sky': radiation from the sky dome (zenith <= 90)\n            * 'horizon': radiation from the region of the sky near the horizon\n              (89.5 <= zenith <= 90)\n            * 'ground': radiation reflected from the ground (zenith >= 90)\n\n        See [1]_ for a detailed description of each class.\n\n    See Also\n    --------\n    pvlib.iam.marion_integrate\n\n    References\n    ----------\n    .. [1] B. Marion \"Numerical method for angle-of-incidence correction\n       factors for diffuse radiation incident photovoltaic modules\",\n       Solar Energy, Volume 147, Pages 344-348. 2017.\n       DOI: 10.1016/j.solener.2017.03.027\n\n    Examples\n    --------\n    >>> marion_diffuse('physical', surface_tilt=20)\n    {'sky': 0.9539178294437575,\n     'horizon': 0.7652650139134007,\n     'ground': 0.6387140117795903}\n\n    >>> marion_diffuse('ashrae', [20, 30], b=0.04)\n    {'sky': array([0.96748999, 0.96938408]),\n     'horizon': array([0.86478428, 0.91825792]),\n     'ground': array([0.77004435, 0.8522436 ])}\n    \"\"\"\n\n    models = {\n        'physical': physical,\n        'ashrae': ashrae,\n        'sapm': sapm,\n        'martin_ruiz': martin_ruiz,\n        'schlick': schlick,\n    }\n\n    try:\n        iam_model = models[model]\n    except KeyError:\n        raise ValueError('model must be one of: ' + str(list(models.keys())))\n\n    iam_function = functools.partial(iam_model, **kwargs)\n    iam = {}\n    for region in ['sky', 'horizon', 'ground']:\n        iam[region] = marion_integrate(iam_function, surface_tilt, region)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "marion_diffuse", "model", "surface_tilt", "kwargs", "determine", "diffuse", "irradiance", "incidence", "angle", "modifiers", "using", "marion", "s", "method", "of", "integrating", "over", "solid", "angle", "parameters", "model", "str", "the", "iam", "function", "to", "evaluate", "across", "solid", "angle", "must", "be", "one", "of", "ashrae", "physical", "martin_ruiz", "sapm", "schlick", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "kwargs", "extra", "parameters", "passed", "to", "the", "iam", "function", "returns", "iam", "dict", "iam", "values", "for", "each", "type", "of", "diffuse", "irradiance", "sky", "radiation", "from", "the", "sky", "dome", "zenith", "90", "horizon", "radiation", "from", "the", "region", "of", "the", "sky", "near", "the", "horizon", "89", "5", "zenith", "90", "ground", "radiation", "reflected", "from", "the", "ground", "zenith", "90", "see", "1", "_", "for", "a", "detailed", "description", "of", "each", "class", "see", "also", "pvlib", "iam", "marion_integrate", "references", "1", "b", "marion", "numerical", "method", "for", "angle", "of", "incidence", "correction", "factors", "for", "diffuse", "radiation", "incident", "photovoltaic", "modules", "solar", "energy", "volume", "147", "pages", "344", "348", "2017", "doi", "10", "1016", "j", "solener", "2017", "03", "027", "examples", "marion_diffuse", "physical", "surface_tilt", "20", "sky", "0", "9539178294437575", "horizon", "0", "7652650139134007", "ground", "0", "6387140117795903", "marion_diffuse", "ashrae", "20", "30", "b", "0", "04", "sky", "array", "0", "96748999", "0", "96938408", "horizon", "array", "0", "86478428", "0", "91825792", "ground", "array", "0", "77004435", "0", "8522436", "models", "physical", "physical", "ashrae", "ashrae", "sapm", "sapm", "martin_ruiz", "martin_ruiz", "schlick", "schlick", "try", "iam_model", "models", "model", "except", "keyerror", "raise", "valueerror", "model", "must", "be", "one", "of", "str", "list", "models", "keys", "iam_function", "functools", "partial", "iam_model", "kwargs", "iam", "for", "region", "in", "sky", "horizon", "ground", "iam", "region", "marion_integrate", "iam_function", "surface_tilt", "region", "return", "iam"], "doc_len": 256}
{"doc_id": "pvlib/iam.py::marion_integrate", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "marion_integrate", "text": "文件路径: pvlib/iam.py\ndef marion_integrate(function, surface_tilt, region, num=None):\n    \"\"\"\n    Integrate an incidence angle modifier (IAM) function over solid angle\n    to determine a diffuse irradiance correction factor using Marion's method.\n\n    This lower-level function actually performs the IAM integration for the\n    specified solid angle region.\n\n    Parameters\n    ----------\n    function : callable(aoi)\n        The IAM function to evaluate across solid angle. The function must\n        be vectorized and take only one parameter, the angle of incidence in\n        degrees.\n\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees.\n        The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90).\n\n    region : {'sky', 'horizon', 'ground'}\n        The region to integrate over. Must be one of:\n\n            * 'sky': radiation from the sky dome (zenith <= 90)\n            * 'horizon': radiation from the region of the sky near the horizon\n              (89.5 <= zenith <= 90)\n            * 'ground': radiation reflected from the ground (zenith >= 90)\n\n        See [1]_ for a detailed description of each class.\n\n    num : int, optional\n        The number of increments in the zenith integration.\n        If not specified, N will follow the values used in [1]_:\n\n            * 'sky' or 'ground': num = 180\n            * 'horizon': num = 1800\n\n    Returns\n    -------\n    iam : numeric\n        AOI diffuse correction factor for the specified region.\n\n    See Also\n    --------\n    pvlib.iam.marion_diffuse\n\n    References\n    ----------\n    .. [1] B. Marion \"Numerical method for angle-of-incidence correction\n       factors for diffuse radiation incident photovoltaic modules\",\n       Solar Energy, Volume 147, Pages 344-348. 2017.\n       DOI: 10.1016/j.solener.2017.03.027\n\n    Examples\n    --------\n    >>> marion_integrate(pvlib.iam.ashrae, 20, 'sky')\n    0.9596085829811408\n\n    >>> from functools import partial\n    >>> f = partial(pvlib.iam.physical, n=1.3)\n    >>> marion_integrate(f, [20, 30], 'sky')\n    array([0.96225034, 0.9653219 ])\n    \"\"\"\n\n    if num is None:\n        if region in ['sky', 'ground']:\n            num = 180\n        elif region == 'horizon':\n            num = 1800\n        else:\n            raise ValueError(f'Invalid region: {region}')\n\n    beta = np.radians(surface_tilt)\n    if isinstance(beta, pd.Series):\n        # convert Series to np array for broadcasting later\n        beta = beta.values\n    ai = np.pi/num  # angular increment\n\n    phi_range = np.linspace(0, np.pi, num, endpoint=False)\n    psi_range = np.linspace(0, 2*np.pi, 2*num, endpoint=False)\n\n    # the pseudocode in [1] do these checks at the end, but it's\n    # faster to do this criteria check up front instead of later.\n    if region == 'sky':\n        mask = phi_range + ai <= np.pi/2\n    elif region == 'horizon':\n        lo = 89.5 * np.pi/180\n        hi = np.pi/2\n        mask = (lo <= phi_range) & (phi_range + ai <= hi)\n    elif region == 'ground':\n        mask = (phi_range >= np.pi/2)\n    else:\n        raise ValueError(f'Invalid region: {region}')\n    phi_range = phi_range[mask]\n\n    # fast Cartesian product of phi and psi\n    angles = np.array(np.meshgrid(phi_range, psi_range)).T.reshape(-1, 2)\n    # index with single-element lists to maintain 2nd dimension so that\n    # these angle arrays broadcast across the beta array\n    phi_1 = angles[:, [0]]\n    psi_1 = angles[:, [1]]\n    phi_2 = phi_1 + ai\n    # psi_2 = psi_1 + ai  # not needed\n    phi_avg = phi_1 + 0.5*ai\n    psi_avg = psi_1 + 0.5*ai\n    term_1 = np.cos(beta) * np.cos(phi_avg)\n    # The AOI formula includes a term based on the difference between\n    # panel azimuth and the photon azimuth, but because we assume each class\n    # of diffuse irradiance is isotropic and we are integrating over all\n    # angles, it doesn't matter what panel azimuth we choose (i.e., the\n    # system is rotationally invariant).  So we choose gamma to be zero so\n    # that we can omit it from the cos(psi_avg) term.\n    # Marion's paper mentions this in the Section 3 pseudocode:\n    # \"set gamma to pi (or any value between 0 and 2pi)\"\n    term_2 = np.sin(beta) * np.sin(phi_avg) * np.cos(psi_avg)\n    cosaoi = term_1 + term_2\n    aoi = np.arccos(cosaoi)\n    # simplify Eq 8, (psi_2 - psi_1) is always ai\n    dAs = ai * (np.cos(phi_1) - np.cos(phi_2))\n    cosaoi_dAs = cosaoi * dAs\n    # apply the final AOI check, zeroing out non-passing points\n    mask = aoi < np.pi/2\n    cosaoi_dAs = np.where(mask, cosaoi_dAs, 0)\n    numerator = np.sum(function(np.degrees(aoi)) * cosaoi_dAs, axis=0)\n    denominator = np.sum(cosaoi_dAs, axis=0)\n\n    with np.errstate(invalid='ignore'):\n        # in some cases, no points pass the criteria\n        # (e.g. region='ground', surface_tilt=0), so we override the division\n        # by zero to set Fd=0.  Also, preserve nans in beta.\n        Fd = np.where((denominator != 0) | ~np.isfinite(beta),\n                      numerator / denominator,\n                      0)\n\n    # preserve input type\n    if np.isscalar(surface_tilt):\n        Fd = Fd.item()\n    elif isinstance(surface_tilt, pd.Series):\n        Fd = pd.Series(Fd, surface_tilt.index)\n\n    return Fd\n", "tokens": ["pvlib", "iam", "py", "def", "marion_integrate", "function", "surface_tilt", "region", "num", "none", "integrate", "an", "incidence", "angle", "modifier", "iam", "function", "over", "solid", "angle", "to", "determine", "a", "diffuse", "irradiance", "correction", "factor", "using", "marion", "s", "method", "this", "lower", "level", "function", "actually", "performs", "the", "iam", "integration", "for", "the", "specified", "solid", "angle", "region", "parameters", "function", "callable", "aoi", "the", "iam", "function", "to", "evaluate", "across", "solid", "angle", "the", "function", "must", "be", "vectorized", "and", "take", "only", "one", "parameter", "the", "angle", "of", "incidence", "in", "degrees", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "region", "sky", "horizon", "ground", "the", "region", "to", "integrate", "over", "must", "be", "one", "of", "sky", "radiation", "from", "the", "sky", "dome", "zenith", "90", "horizon", "radiation", "from", "the", "region", "of", "the", "sky", "near", "the", "horizon", "89", "5", "zenith", "90", "ground", "radiation", "reflected", "from", "the", "ground", "zenith", "90", "see", "1", "_", "for", "a", "detailed", "description", "of", "each", "class", "num", "int", "optional", "the", "number", "of", "increments", "in", "the", "zenith", "integration", "if", "not", "specified", "n", "will", "follow", "the", "values", "used", "in", "1", "_", "sky", "or", "ground", "num", "180", "horizon", "num", "1800", "returns", "iam", "numeric", "aoi", "diffuse", "correction", "factor", "for", "the", "specified", "region", "see", "also", "pvlib", "iam", "marion_diffuse", "references", "1", "b", "marion", "numerical", "method", "for", "angle", "of", "incidence", "correction", "factors", "for", "diffuse", "radiation", "incident", "photovoltaic", "modules", "solar", "energy", "volume", "147", "pages", "344", "348", "2017", "doi", "10", "1016", "j", "solener", "2017", "03", "027", "examples", "marion_integrate", "pvlib", "iam", "ashrae", "20", "sky", "0", "9596085829811408", "from", "functools", "import", "partial", "f", "partial", "pvlib", "iam", "physical", "n", "1", "3", "marion_integrate", "f", "20", "30", "sky", "array", "0", "96225034", "0", "9653219", "if", "num", "is", "none", "if", "region", "in", "sky", "ground", "num", "180", "elif", "region", "horizon", "num", "1800", "else", "raise", "valueerror", "f", "invalid", "region", "region", "beta", "np", "radians", "surface_tilt", "if", "isinstance", "beta", "pd", "series", "convert", "series", "to", "np", "array", "for", "broadcasting", "later", "beta", "beta", "values", "ai", "np", "pi", "num", "angular", "increment", "phi_range", "np", "linspace", "0", "np", "pi", "num", "endpoint", "false", "psi_range", "np", "linspace", "0", "2", "np", "pi", "2", "num", "endpoint", "false", "the", "pseudocode", "in", "1", "do", "these", "checks", "at", "the", "end", "but", "it", "s", "faster", "to", "do", "this", "criteria", "check", "up", "front", "instead", "of", "later", "if", "region", "sky", "mask", "phi_range", "ai", "np", "pi", "2", "elif", "region", "horizon", "lo", "89", "5", "np", "pi", "180", "hi", "np", "pi", "2", "mask", "lo", "phi_range", "phi_range", "ai", "hi", "elif", "region", "ground", "mask", "phi_range", "np", "pi", "2", "else", "raise", "valueerror", "f", "invalid", "region", "region", "phi_range", "phi_range", "mask", "fast", "cartesian", "product", "of", "phi", "and", "psi", "angles", "np", "array", "np", "meshgrid", "phi_range", "psi_range", "t", "reshape", "1", "2", "index", "with", "single", "element", "lists", "to", "maintain", "2nd", "dimension", "so", "that", "these", "angle", "arrays", "broadcast", "across", "the", "beta", "array", "phi_1", "angles", "0", "psi_1", "angles", "1", "phi_2", "phi_1", "ai", "psi_2", "psi_1", "ai", "not", "needed", "phi_avg", "phi_1", "0", "5", "ai", "psi_avg", "psi_1", "0", "5", "ai", "term_1", "np", "cos", "beta", "np", "cos", "phi_avg", "the", "aoi", "formula", "includes", "a", "term", "based", "on", "the", "difference", "between", "panel", "azimuth", "and", "the", "photon", "azimuth", "but", "because", "we", "assume", "each", "class", "of", "diffuse", "irradiance", "is", "isotropic", "and", "we", "are", "integrating", "over", "all", "angles", "it", "doesn", "t", "matter", "what", "panel", "azimuth", "we", "choose", "i", "e", "the", "system", "is", "rotationally", "invariant", "so", "we", "choose", "gamma", "to", "be", "zero", "so", "that", "we", "can", "omit", "it", "from", "the", "cos", "psi_avg", "term", "marion", "s", "paper", "mentions", "this", "in", "the", "section", "3", "pseudocode", "set", "gamma", "to", "pi", "or", "any", "value", "between", "0", "and", "2pi", "term_2", "np", "sin", "beta", "np", "sin", "phi_avg", "np", "cos", "psi_avg", "cosaoi", "term_1", "term_2", "aoi", "np", "arccos", "cosaoi", "simplify", "eq", "8", "psi_2", "psi_1", "is", "always", "ai", "das", "ai", "np", "cos", "phi_1", "np", "cos", "phi_2", "cosaoi_das", "cosaoi", "das", "apply", "the", "final", "aoi", "check", "zeroing", "out", "non", "passing", "points", "mask", "aoi", "np", "pi", "2", "cosaoi_das", "np", "where", "mask", "cosaoi_das", "0", "numerator", "np", "sum", "function", "np", "degrees", "aoi", "cosaoi_das", "axis", "0", "denominator", "np", "sum", "cosaoi_das", "axis", "0", "with", "np", "errstate", "invalid", "ignore", "in", "some", "cases", "no", "points", "pass", "the", "criteria", "e", "g", "region", "ground", "surface_tilt", "0", "so", "we", "override", "the", "division", "by", "zero", "to", "set", "fd", "0", "also", "preserve", "nans", "in", "beta", "fd", "np", "where", "denominator", "0", "np", "isfinite", "beta", "numerator", "denominator", "0", "preserve", "input", "type", "if", "np", "isscalar", "surface_tilt", "fd", "fd", "item", "elif", "isinstance", "surface_tilt", "pd", "series", "fd", "pd", "series", "fd", "surface_tilt", "index", "return", "fd"], "doc_len": 706}
{"doc_id": "pvlib/iam.py::schlick", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "schlick", "text": "文件路径: pvlib/iam.py\ndef schlick(aoi):\n    \"\"\"\n    Determine incidence angle modifier (IAM) for direct irradiance using the\n    Schlick approximation to the Fresnel equations.\n\n    The Schlick approximation was proposed in [1]_ as a computationally\n    efficient alternative to computing the Fresnel factor in computer\n    graphics contexts.  This implementation is a normalized form of the\n    equation in [1]_ so that it can be used as a PV IAM model.\n    Unlike other IAM models, this model has no ability to describe\n    different reflection profiles.\n\n    In PV contexts, the Schlick approximation has been used as an analytically\n    integrable alternative to the Fresnel equations for estimating IAM\n    for diffuse irradiance [2]_.\n\n    Parameters\n    ----------\n    aoi : numeric\n        The angle of incidence (AOI) between the module normal vector and the\n        sun-beam vector. Angles of nan will result in nan. [degrees]\n\n    Returns\n    -------\n    iam : numeric\n        The incident angle modifier.\n\n    References\n    ----------\n    .. [1] Schlick, C. An inexpensive BRDF model for physically-based\n       rendering. Computer graphics forum 13 (1994).\n\n    .. [2] Xie, Y., M. Sengupta, A. Habte, A. Andreas, \"The 'Fresnel Equations'\n       for Diffuse radiation on Inclined photovoltaic Surfaces (FEDIS)\",\n       Renewable and Sustainable Energy Reviews, vol. 161, 112362. June 2022.\n       :doi:`10.1016/j.rser.2022.112362`\n\n    See Also\n    --------\n    pvlib.iam.schlick_diffuse\n    \"\"\"\n    iam = 1 - (1 - cosd(aoi)) ** 5\n    iam = np.where(np.abs(aoi) >= 90.0, 0.0, iam)\n\n    # preserve input type\n    if np.isscalar(aoi):\n        iam = iam.item()\n    elif isinstance(aoi, pd.Series):\n        iam = pd.Series(iam, aoi.index)\n\n    return iam\n", "tokens": ["pvlib", "iam", "py", "def", "schlick", "aoi", "determine", "incidence", "angle", "modifier", "iam", "for", "direct", "irradiance", "using", "the", "schlick", "approximation", "to", "the", "fresnel", "equations", "the", "schlick", "approximation", "was", "proposed", "in", "1", "_", "as", "a", "computationally", "efficient", "alternative", "to", "computing", "the", "fresnel", "factor", "in", "computer", "graphics", "contexts", "this", "implementation", "is", "a", "normalized", "form", "of", "the", "equation", "in", "1", "_", "so", "that", "it", "can", "be", "used", "as", "a", "pv", "iam", "model", "unlike", "other", "iam", "models", "this", "model", "has", "no", "ability", "to", "describe", "different", "reflection", "profiles", "in", "pv", "contexts", "the", "schlick", "approximation", "has", "been", "used", "as", "an", "analytically", "integrable", "alternative", "to", "the", "fresnel", "equations", "for", "estimating", "iam", "for", "diffuse", "irradiance", "2", "_", "parameters", "aoi", "numeric", "the", "angle", "of", "incidence", "aoi", "between", "the", "module", "normal", "vector", "and", "the", "sun", "beam", "vector", "angles", "of", "nan", "will", "result", "in", "nan", "degrees", "returns", "iam", "numeric", "the", "incident", "angle", "modifier", "references", "1", "schlick", "c", "an", "inexpensive", "brdf", "model", "for", "physically", "based", "rendering", "computer", "graphics", "forum", "13", "1994", "2", "xie", "y", "m", "sengupta", "a", "habte", "a", "andreas", "the", "fresnel", "equations", "for", "diffuse", "radiation", "on", "inclined", "photovoltaic", "surfaces", "fedis", "renewable", "and", "sustainable", "energy", "reviews", "vol", "161", "112362", "june", "2022", "doi", "10", "1016", "j", "rser", "2022", "112362", "see", "also", "pvlib", "iam", "schlick_diffuse", "iam", "1", "1", "cosd", "aoi", "5", "iam", "np", "where", "np", "abs", "aoi", "90", "0", "0", "0", "iam", "preserve", "input", "type", "if", "np", "isscalar", "aoi", "iam", "iam", "item", "elif", "isinstance", "aoi", "pd", "series", "iam", "pd", "series", "iam", "aoi", "index", "return", "iam"], "doc_len": 239}
{"doc_id": "pvlib/iam.py::schlick_diffuse", "file_path": "pvlib/iam.py", "class_name": null, "func_name": "schlick_diffuse", "text": "文件路径: pvlib/iam.py\ndef schlick_diffuse(surface_tilt):\n    \"\"\"\n    Determine the incidence angle modifiers (IAM) for diffuse sky and\n    ground-reflected irradiance on a tilted surface using the Schlick\n    incident angle model.\n\n    The diffuse iam values are calculated using an analytical integration\n    of the Schlick equation [1]_ over the portion of an isotropic sky and\n    isotropic foreground that is visible from the tilted surface [2]_.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angle measured from horizontal (e.g. surface facing\n        up = 0, surface facing horizon = 90). [degrees]\n\n    Returns\n    -------\n    iam_sky : numeric\n        The incident angle modifier for sky diffuse.\n\n    iam_ground : numeric\n        The incident angle modifier for ground-reflected diffuse.\n\n    References\n    ----------\n    .. [1] Schlick, C. An inexpensive BRDF model for physically-based\n       rendering. Computer graphics forum 13 (1994).\n\n    .. [2] Xie, Y., M. Sengupta, A. Habte, A. Andreas, \"The 'Fresnel Equations'\n       for Diffuse radiation on Inclined photovoltaic Surfaces (FEDIS)\",\n       Renewable and Sustainable Energy Reviews, vol. 161, 112362. June 2022.\n       :doi:`10.1016/j.rser.2022.112362`\n\n    See Also\n    --------\n    pvlib.iam.schlick\n    \"\"\"\n    # these calculations are as in [2]_, but with the refractive index\n    # weighting coefficient w set to 1.0 (so it is omitted)\n\n    # relative transmittance of sky diffuse radiation by PV cover:\n    cosB = cosd(surface_tilt)\n    sinB = sind(surface_tilt)\n    cuk = (2 / (np.pi * (1 + cosB))) * (\n        (30/7)*np.pi - (160/21)*np.radians(surface_tilt) - (10/3)*np.pi*cosB\n        + (160/21)*cosB*sinB - (5/3)*np.pi*cosB*sinB**2 + (20/7)*cosB*sinB**3\n        - (5/16)*np.pi*cosB*sinB**4 + (16/105)*cosB*sinB**5\n    )  # Eq 4 in [2]\n\n    # relative transmittance of ground-reflected radiation by PV cover:\n    with np.errstate(divide='ignore', invalid='ignore'):  # Eq 6 in [2]\n        cug = 40 / (21 * (1 - cosB)) - (1 + cosB) / (1 - cosB) * cuk\n\n    cug = np.where(surface_tilt < 1e-6, 0, cug)\n\n    # respect input types:\n    if np.isscalar(surface_tilt):\n        cuk = cuk.item()\n        cug = cug.item()\n    elif isinstance(surface_tilt, pd.Series):\n        cuk = pd.Series(cuk, surface_tilt.index)\n        cug = pd.Series(cug, surface_tilt.index)\n\n    return cuk, cug\n", "tokens": ["pvlib", "iam", "py", "def", "schlick_diffuse", "surface_tilt", "determine", "the", "incidence", "angle", "modifiers", "iam", "for", "diffuse", "sky", "and", "ground", "reflected", "irradiance", "on", "a", "tilted", "surface", "using", "the", "schlick", "incident", "angle", "model", "the", "diffuse", "iam", "values", "are", "calculated", "using", "an", "analytical", "integration", "of", "the", "schlick", "equation", "1", "_", "over", "the", "portion", "of", "an", "isotropic", "sky", "and", "isotropic", "foreground", "that", "is", "visible", "from", "the", "tilted", "surface", "2", "_", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angle", "measured", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degrees", "returns", "iam_sky", "numeric", "the", "incident", "angle", "modifier", "for", "sky", "diffuse", "iam_ground", "numeric", "the", "incident", "angle", "modifier", "for", "ground", "reflected", "diffuse", "references", "1", "schlick", "c", "an", "inexpensive", "brdf", "model", "for", "physically", "based", "rendering", "computer", "graphics", "forum", "13", "1994", "2", "xie", "y", "m", "sengupta", "a", "habte", "a", "andreas", "the", "fresnel", "equations", "for", "diffuse", "radiation", "on", "inclined", "photovoltaic", "surfaces", "fedis", "renewable", "and", "sustainable", "energy", "reviews", "vol", "161", "112362", "june", "2022", "doi", "10", "1016", "j", "rser", "2022", "112362", "see", "also", "pvlib", "iam", "schlick", "these", "calculations", "are", "as", "in", "2", "_", "but", "with", "the", "refractive", "index", "weighting", "coefficient", "w", "set", "to", "1", "0", "so", "it", "is", "omitted", "relative", "transmittance", "of", "sky", "diffuse", "radiation", "by", "pv", "cover", "cosb", "cosd", "surface_tilt", "sinb", "sind", "surface_tilt", "cuk", "2", "np", "pi", "1", "cosb", "30", "7", "np", "pi", "160", "21", "np", "radians", "surface_tilt", "10", "3", "np", "pi", "cosb", "160", "21", "cosb", "sinb", "5", "3", "np", "pi", "cosb", "sinb", "2", "20", "7", "cosb", "sinb", "3", "5", "16", "np", "pi", "cosb", "sinb", "4", "16", "105", "cosb", "sinb", "5", "eq", "4", "in", "2", "relative", "transmittance", "of", "ground", "reflected", "radiation", "by", "pv", "cover", "with", "np", "errstate", "divide", "ignore", "invalid", "ignore", "eq", "6", "in", "2", "cug", "40", "21", "1", "cosb", "1", "cosb", "1", "cosb", "cuk", "cug", "np", "where", "surface_tilt", "1e", "6", "0", "cug", "respect", "input", "types", "if", "np", "isscalar", "surface_tilt", "cuk", "cuk", "item", "cug", "cug", "item", "elif", "isinstance", "surface_tilt", "pd", "series", "cuk", "pd", "series", "cuk", "surface_tilt", "index", "cug", "pd", "series", "cug", "surface_tilt", "index", "return", "cuk", "cug"], "doc_len": 324}
{"doc_id": "pvlib/inverter.py::_sandia_eff", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "_sandia_eff", "text": "文件路径: pvlib/inverter.py\ndef _sandia_eff(v_dc, p_dc, inverter):\n    r'''\n    Calculate the inverter AC power without clipping\n    '''\n    Paco = inverter['Paco']\n    Pdco = inverter['Pdco']\n    Vdco = inverter['Vdco']\n    C0 = inverter['C0']\n    C1 = inverter['C1']\n    C2 = inverter['C2']\n    C3 = inverter['C3']\n    Pso = inverter['Pso']\n\n    A = Pdco * (1 + C1 * (v_dc - Vdco))\n    B = Pso * (1 + C2 * (v_dc - Vdco))\n    C = C0 * (1 + C3 * (v_dc - Vdco))\n\n    return (Paco / (A - B) - C * (A - B)) * (p_dc - B) + C * (p_dc - B)**2\n", "tokens": ["pvlib", "inverter", "py", "def", "_sandia_eff", "v_dc", "p_dc", "inverter", "r", "calculate", "the", "inverter", "ac", "power", "without", "clipping", "paco", "inverter", "paco", "pdco", "inverter", "pdco", "vdco", "inverter", "vdco", "c0", "inverter", "c0", "c1", "inverter", "c1", "c2", "inverter", "c2", "c3", "inverter", "c3", "pso", "inverter", "pso", "a", "pdco", "1", "c1", "v_dc", "vdco", "b", "pso", "1", "c2", "v_dc", "vdco", "c", "c0", "1", "c3", "v_dc", "vdco", "return", "paco", "a", "b", "c", "a", "b", "p_dc", "b", "c", "p_dc", "b", "2"], "doc_len": 71}
{"doc_id": "pvlib/inverter.py::_sandia_limits", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "_sandia_limits", "text": "文件路径: pvlib/inverter.py\ndef _sandia_limits(power_ac, p_dc, Paco, Pnt, Pso):\n    r'''\n    Applies minimum and maximum power limits to `power_ac`\n    '''\n    power_ac = np.minimum(Paco, power_ac)\n    min_ac_power = -1.0 * abs(Pnt)\n    below_limit = p_dc < Pso\n    try:\n        power_ac[below_limit] = min_ac_power\n    except TypeError:  # power_ac is a float\n        if below_limit:\n            power_ac = min_ac_power\n    return power_ac\n", "tokens": ["pvlib", "inverter", "py", "def", "_sandia_limits", "power_ac", "p_dc", "paco", "pnt", "pso", "r", "applies", "minimum", "and", "maximum", "power", "limits", "to", "power_ac", "power_ac", "np", "minimum", "paco", "power_ac", "min_ac_power", "1", "0", "abs", "pnt", "below_limit", "p_dc", "pso", "try", "power_ac", "below_limit", "min_ac_power", "except", "typeerror", "power_ac", "is", "a", "float", "if", "below_limit", "power_ac", "min_ac_power", "return", "power_ac"], "doc_len": 48}
{"doc_id": "pvlib/inverter.py::sandia", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "sandia", "text": "文件路径: pvlib/inverter.py\ndef sandia(v_dc, p_dc, inverter):\n    r'''\n    Convert DC power and voltage to AC power using Sandia's\n    Grid-Connected PV Inverter model.\n\n    Parameters\n    ----------\n    v_dc : numeric\n        DC voltage input to the inverter. [V]\n\n    p_dc : numeric\n        DC power input to the inverter. [W]\n\n    inverter : dict-like\n        Defines parameters for the inverter model in [1]_.\n\n    Returns\n    -------\n    power_ac : numeric\n        AC power output. [W]\n\n    Notes\n    -----\n\n    Determines the AC power output of an inverter given the DC voltage and DC\n    power. Output AC power is bounded above by the parameter ``Paco``, to\n    represent inverter \"clipping\".  When `power_ac` would be less than\n    parameter ``Pso`` (startup power required), then `power_ac` is set to\n    ``-Pnt``, representing self-consumption. `power_ac` is not adjusted for\n    maximum power point tracking (MPPT) voltage windows or maximum current\n    limits of the inverter.\n\n    Required model parameters are:\n\n    ======   ============================================================\n    Column   Description\n    ======   ============================================================\n    Paco     AC power rating of the inverter. [W]\n    Pdco     DC power input that results in Paco output at reference\n             voltage Vdco. [W]\n    Vdco     DC voltage at which the AC power rating is achieved\n             with Pdco power input. [V]\n    Pso      DC power required to start the inversion process, or\n             self-consumption by inverter, strongly influences inverter\n             efficiency at low power levels. [W]\n    C0       Parameter defining the curvature (parabolic) of the\n             relationship between AC power and DC power at the reference\n             operating condition. [1/W]\n    C1       Empirical coefficient allowing ``Pdco`` to vary linearly\n             with DC voltage input. [1/V]\n    C2       Empirical coefficient allowing ``Pso`` to vary linearly with\n             DC voltage input. [1/V]\n    C3       Empirical coefficient allowing ``C0`` to vary linearly with\n             DC voltage input. [1/V]\n    Pnt      AC power consumed by the inverter at night (night tare). [W]\n    ======   ============================================================\n\n    A copy of the parameter database from the System Advisor Model (SAM) [2]_\n    is provided with pvlib and may be read  using\n    :py:func:`pvlib.pvsystem.retrieve_sam`.\n\n    References\n    ----------\n    .. [1] D. King, S. Gonzalez, G. Galbraith, W. Boyson, \"Performance Model\n       for Grid-Connected Photovoltaic Inverters\", SAND2007-5036, Sandia\n       National Laboratories.\n\n    .. [2] System Advisor Model web page. https://sam.nrel.gov.\n\n    See also\n    --------\n    pvlib.pvsystem.retrieve_sam\n    '''\n\n    Paco = inverter['Paco']\n    Pnt = inverter['Pnt']\n    Pso = inverter['Pso']\n\n    power_ac = _sandia_eff(v_dc, p_dc, inverter)\n    power_ac = _sandia_limits(power_ac, p_dc, Paco, Pnt, Pso)\n\n    if isinstance(p_dc, pd.Series):\n        power_ac = pd.Series(power_ac, index=p_dc.index)\n\n    return power_ac\n", "tokens": ["pvlib", "inverter", "py", "def", "sandia", "v_dc", "p_dc", "inverter", "r", "convert", "dc", "power", "and", "voltage", "to", "ac", "power", "using", "sandia", "s", "grid", "connected", "pv", "inverter", "model", "parameters", "v_dc", "numeric", "dc", "voltage", "input", "to", "the", "inverter", "v", "p_dc", "numeric", "dc", "power", "input", "to", "the", "inverter", "w", "inverter", "dict", "like", "defines", "parameters", "for", "the", "inverter", "model", "in", "1", "_", "returns", "power_ac", "numeric", "ac", "power", "output", "w", "notes", "determines", "the", "ac", "power", "output", "of", "an", "inverter", "given", "the", "dc", "voltage", "and", "dc", "power", "output", "ac", "power", "is", "bounded", "above", "by", "the", "parameter", "paco", "to", "represent", "inverter", "clipping", "when", "power_ac", "would", "be", "less", "than", "parameter", "pso", "startup", "power", "required", "then", "power_ac", "is", "set", "to", "pnt", "representing", "self", "consumption", "power_ac", "is", "not", "adjusted", "for", "maximum", "power", "point", "tracking", "mppt", "voltage", "windows", "or", "maximum", "current", "limits", "of", "the", "inverter", "required", "model", "parameters", "are", "column", "description", "paco", "ac", "power", "rating", "of", "the", "inverter", "w", "pdco", "dc", "power", "input", "that", "results", "in", "paco", "output", "at", "reference", "voltage", "vdco", "w", "vdco", "dc", "voltage", "at", "which", "the", "ac", "power", "rating", "is", "achieved", "with", "pdco", "power", "input", "v", "pso", "dc", "power", "required", "to", "start", "the", "inversion", "process", "or", "self", "consumption", "by", "inverter", "strongly", "influences", "inverter", "efficiency", "at", "low", "power", "levels", "w", "c0", "parameter", "defining", "the", "curvature", "parabolic", "of", "the", "relationship", "between", "ac", "power", "and", "dc", "power", "at", "the", "reference", "operating", "condition", "1", "w", "c1", "empirical", "coefficient", "allowing", "pdco", "to", "vary", "linearly", "with", "dc", "voltage", "input", "1", "v", "c2", "empirical", "coefficient", "allowing", "pso", "to", "vary", "linearly", "with", "dc", "voltage", "input", "1", "v", "c3", "empirical", "coefficient", "allowing", "c0", "to", "vary", "linearly", "with", "dc", "voltage", "input", "1", "v", "pnt", "ac", "power", "consumed", "by", "the", "inverter", "at", "night", "night", "tare", "w", "a", "copy", "of", "the", "parameter", "database", "from", "the", "system", "advisor", "model", "sam", "2", "_", "is", "provided", "with", "pvlib", "and", "may", "be", "read", "using", "py", "func", "pvlib", "pvsystem", "retrieve_sam", "references", "1", "d", "king", "s", "gonzalez", "g", "galbraith", "w", "boyson", "performance", "model", "for", "grid", "connected", "photovoltaic", "inverters", "sand2007", "5036", "sandia", "national", "laboratories", "2", "system", "advisor", "model", "web", "page", "https", "sam", "nrel", "gov", "see", "also", "pvlib", "pvsystem", "retrieve_sam", "paco", "inverter", "paco", "pnt", "inverter", "pnt", "pso", "inverter", "pso", "power_ac", "_sandia_eff", "v_dc", "p_dc", "inverter", "power_ac", "_sandia_limits", "power_ac", "p_dc", "paco", "pnt", "pso", "if", "isinstance", "p_dc", "pd", "series", "power_ac", "pd", "series", "power_ac", "index", "p_dc", "index", "return", "power_ac"], "doc_len": 375}
{"doc_id": "pvlib/inverter.py::sandia_multi", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "sandia_multi", "text": "文件路径: pvlib/inverter.py\ndef sandia_multi(v_dc, p_dc, inverter):\n    r'''\n    Convert DC power and voltage to AC power for an inverter with multiple\n    MPPT inputs.\n\n    Uses Sandia's Grid-Connected PV Inverter model [1]_. Extension of [1]_\n    to inverters with multiple, unbalanced inputs as described in [2]_.\n\n    Parameters\n    ----------\n    v_dc : tuple, list or array of numeric\n        DC voltage on each MPPT input of the inverter. If type is array, must\n        be 2d with axis 0 being the MPPT inputs. [V]\n\n    p_dc : tuple, list or array of numeric\n        DC power on each MPPT input of the inverter. If type is array, must\n        be 2d with axis 0 being the MPPT inputs. [W]\n\n    inverter : dict-like\n        Defines parameters for the inverter model in [1]_.\n\n    Returns\n    -------\n    power_ac : numeric\n        AC power output for the inverter. [W]\n\n    Raises\n    ------\n    ValueError\n        If v_dc and p_dc have different lengths.\n\n    Notes\n    -----\n    See :py:func:`pvlib.inverter.sandia` for definition of the parameters in\n    `inverter`.\n\n    References\n    ----------\n    .. [1] D. King, S. Gonzalez, G. Galbraith, W. Boyson, \"Performance Model\n       for Grid-Connected Photovoltaic Inverters\", SAND2007-5036, Sandia\n       National Laboratories.\n    .. [2] C. Hansen, J. Johnson, R. Darbali-Zamora, N. Gurule. \"Modeling\n       Efficiency Of Inverters With Multiple Inputs\", 49th IEEE Photovoltaic\n       Specialist Conference, Philadelphia, PA, USA. June 2022.\n\n    See also\n    --------\n    pvlib.inverter.sandia\n    '''\n\n    if len(p_dc) != len(v_dc):\n        raise ValueError('p_dc and v_dc have different lengths')\n    power_dc = sum(p_dc)\n    power_ac = 0. * power_dc\n\n    for vdc, pdc in zip(v_dc, p_dc):\n        power_ac += pdc / power_dc * _sandia_eff(vdc, power_dc, inverter)\n\n    return _sandia_limits(power_ac, power_dc, inverter['Paco'],\n                          inverter['Pnt'], inverter['Pso'])\n", "tokens": ["pvlib", "inverter", "py", "def", "sandia_multi", "v_dc", "p_dc", "inverter", "r", "convert", "dc", "power", "and", "voltage", "to", "ac", "power", "for", "an", "inverter", "with", "multiple", "mppt", "inputs", "uses", "sandia", "s", "grid", "connected", "pv", "inverter", "model", "1", "_", "extension", "of", "1", "_", "to", "inverters", "with", "multiple", "unbalanced", "inputs", "as", "described", "in", "2", "_", "parameters", "v_dc", "tuple", "list", "or", "array", "of", "numeric", "dc", "voltage", "on", "each", "mppt", "input", "of", "the", "inverter", "if", "type", "is", "array", "must", "be", "2d", "with", "axis", "0", "being", "the", "mppt", "inputs", "v", "p_dc", "tuple", "list", "or", "array", "of", "numeric", "dc", "power", "on", "each", "mppt", "input", "of", "the", "inverter", "if", "type", "is", "array", "must", "be", "2d", "with", "axis", "0", "being", "the", "mppt", "inputs", "w", "inverter", "dict", "like", "defines", "parameters", "for", "the", "inverter", "model", "in", "1", "_", "returns", "power_ac", "numeric", "ac", "power", "output", "for", "the", "inverter", "w", "raises", "valueerror", "if", "v_dc", "and", "p_dc", "have", "different", "lengths", "notes", "see", "py", "func", "pvlib", "inverter", "sandia", "for", "definition", "of", "the", "parameters", "in", "inverter", "references", "1", "d", "king", "s", "gonzalez", "g", "galbraith", "w", "boyson", "performance", "model", "for", "grid", "connected", "photovoltaic", "inverters", "sand2007", "5036", "sandia", "national", "laboratories", "2", "c", "hansen", "j", "johnson", "r", "darbali", "zamora", "n", "gurule", "modeling", "efficiency", "of", "inverters", "with", "multiple", "inputs", "49th", "ieee", "photovoltaic", "specialist", "conference", "philadelphia", "pa", "usa", "june", "2022", "see", "also", "pvlib", "inverter", "sandia", "if", "len", "p_dc", "len", "v_dc", "raise", "valueerror", "p_dc", "and", "v_dc", "have", "different", "lengths", "power_dc", "sum", "p_dc", "power_ac", "0", "power_dc", "for", "vdc", "pdc", "in", "zip", "v_dc", "p_dc", "power_ac", "pdc", "power_dc", "_sandia_eff", "vdc", "power_dc", "inverter", "return", "_sandia_limits", "power_ac", "power_dc", "inverter", "paco", "inverter", "pnt", "inverter", "pso"], "doc_len": 254}
{"doc_id": "pvlib/inverter.py::adr", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "adr", "text": "文件路径: pvlib/inverter.py\ndef adr(v_dc, p_dc, inverter, vtol=0.10):\n    r'''\n    Converts DC power and voltage to AC power using Anton Driesse's\n    grid-connected inverter efficiency model.\n\n    Parameters\n    ----------\n    v_dc : numeric\n        DC voltage input to the inverter, should be >= 0. [V]\n\n    p_dc : numeric\n        DC power input to the inverter, should be >= 0. [W]\n\n    inverter : dict-like\n        Defines parameters for the inverter model in [1]_.  See Notes for\n        required model parameters. A parameter database is provided with pvlib\n        and may be read using :py:func:`pvlib.pvsystem.retrieve_sam`.\n\n    vtol : numeric, default 0.1\n        Fraction of DC voltage that determines how far the efficiency model is\n        extrapolated beyond the inverter's normal input voltage operating\n        range. 0.0 <= vtol <= 1.0. [unitless]\n\n    Returns\n    -------\n    power_ac : numeric\n        AC power output. [W]\n\n    Notes\n    -----\n    Determines the AC power output of an inverter given the DC voltage and DC\n    power. Output AC power is bounded above by the parameter ``Pacmax``, to\n    represent inverter \"clipping\". AC power is bounded below by ``-Pnt``\n    (negative when power is consumed rather than produced) which represents\n    self-consumption. `power_ac` is not adjusted for maximum power point\n    tracking (MPPT) voltage windows or maximum current limits of the inverter.\n\n    Required model parameters are:\n\n    ================ ==========================================================\n    Column           Description\n    ================ ==========================================================\n    Pnom             Nominal DC power, typically the DC power needed to produce\n                     maximum AC power output. [W]\n    Vnom             Nominal DC input voltage. Typically the level at which the\n                     highest efficiency is achieved. [V]\n    Vmax             Maximum DC input voltage. [V]\n    Vmin             Minimum DC input voltage. [V]\n    Vdcmax           Maximum voltage supplied from DC array. [V]\n    MPPTHi           Maximum DC voltage for MPPT range. [V]\n    MPPTLow          Minimum DC voltage for MPPT range. [V]\n    Pacmax           Maximum AC output power, used to clip the output power\n                     if needed. [W]\n    ADRCoefficients  A list of 9 coefficients that capture the influence\n                     of input voltage and power on inverter losses, and thereby\n                     efficiency. Corresponds to terms from [1]_ (in order):\n                     :math: `b_{0,0}, b_{1,0}, b_{2,0}, b_{0,1}, b_{1,1},\n                     b_{2,1}, b_{0,2}, b_{1,2},  b_{2,2}`. See [1]_ for the\n                     use of each coefficient and its associated unit.\n    Pnt              AC power consumed by inverter at night (night tare) to\n                     maintain circuitry required to sense the PV array\n                     voltage. [W]\n    ================ ==========================================================\n\n    AC power output is set to NaN where the input DC voltage exceeds a limit\n    M = max(Vmax, Vdcmax, MPPTHi) x (1 + vtol), and where the input DC voltage\n    is less than a limit m = max(Vmin, MPPTLow) x (1 - vtol)\n\n    References\n    ----------\n    .. [1] A. Driesse, \"Beyond the Curves: Modeling the Electrical Efficiency\n       of Photovoltaic Inverters\", 33rd IEEE Photovoltaic Specialist\n       Conference (PVSC), June 2008\n\n    See also\n    --------\n    pvlib.inverter.sandia\n    pvlib.pvsystem.retrieve_sam\n    '''\n\n    p_nom = inverter['Pnom']\n    v_nom = inverter['Vnom']\n    pac_max = inverter['Pacmax']\n    p_nt = inverter['Pnt']\n    ce_list = inverter['ADRCoefficients']\n    v_max = inverter['Vmax']\n    v_min = inverter['Vmin']\n    vdc_max = inverter['Vdcmax']\n    mppt_hi = inverter['MPPTHi']\n    mppt_low = inverter['MPPTLow']\n\n    v_lim_upper = float(np.nanmax([v_max, vdc_max, mppt_hi]) * (1 + vtol))\n    v_lim_lower = float(np.nanmax([v_min, mppt_low]) * (1 - vtol))\n\n    pdc = p_dc / p_nom\n    vdc = v_dc / v_nom\n    # zero voltage will lead to division by zero, but since power is\n    # set to night time value later, these errors can be safely ignored\n    with np.errstate(invalid='ignore', divide='ignore'):\n        poly = np.array([pdc**0,  # replace with np.ones_like?\n                         pdc,\n                         pdc**2,\n                         vdc - 1,\n                         pdc * (vdc - 1),\n                         pdc**2 * (vdc - 1),\n                         1. / vdc - 1,  # divide by 0\n                         pdc * (1. / vdc - 1),  # invalid 0./0. --> nan\n                         pdc**2 * (1. / vdc - 1)])  # divide by 0\n    p_loss = np.dot(np.array(ce_list), poly)\n    power_ac = p_nom * (pdc - p_loss)\n    p_nt = -1 * np.absolute(p_nt)\n\n    # set output to nan where input is outside of limits\n    # errstate silences case where input is nan\n    with np.errstate(invalid='ignore'):\n        invalid = (v_lim_upper < v_dc) | (v_dc < v_lim_lower)\n    power_ac = np.where(invalid, np.nan, power_ac)\n\n    # set night values\n    power_ac = np.where(vdc == 0, p_nt, power_ac)\n    power_ac = np.maximum(power_ac, p_nt)\n\n    # set max ac output\n    power_ac = np.minimum(power_ac, pac_max)\n\n    if isinstance(p_dc, pd.Series):\n        power_ac = pd.Series(power_ac, index=pdc.index)\n\n    return power_ac\n", "tokens": ["pvlib", "inverter", "py", "def", "adr", "v_dc", "p_dc", "inverter", "vtol", "0", "10", "r", "converts", "dc", "power", "and", "voltage", "to", "ac", "power", "using", "anton", "driesse", "s", "grid", "connected", "inverter", "efficiency", "model", "parameters", "v_dc", "numeric", "dc", "voltage", "input", "to", "the", "inverter", "should", "be", "0", "v", "p_dc", "numeric", "dc", "power", "input", "to", "the", "inverter", "should", "be", "0", "w", "inverter", "dict", "like", "defines", "parameters", "for", "the", "inverter", "model", "in", "1", "_", "see", "notes", "for", "required", "model", "parameters", "a", "parameter", "database", "is", "provided", "with", "pvlib", "and", "may", "be", "read", "using", "py", "func", "pvlib", "pvsystem", "retrieve_sam", "vtol", "numeric", "default", "0", "1", "fraction", "of", "dc", "voltage", "that", "determines", "how", "far", "the", "efficiency", "model", "is", "extrapolated", "beyond", "the", "inverter", "s", "normal", "input", "voltage", "operating", "range", "0", "0", "vtol", "1", "0", "unitless", "returns", "power_ac", "numeric", "ac", "power", "output", "w", "notes", "determines", "the", "ac", "power", "output", "of", "an", "inverter", "given", "the", "dc", "voltage", "and", "dc", "power", "output", "ac", "power", "is", "bounded", "above", "by", "the", "parameter", "pacmax", "to", "represent", "inverter", "clipping", "ac", "power", "is", "bounded", "below", "by", "pnt", "negative", "when", "power", "is", "consumed", "rather", "than", "produced", "which", "represents", "self", "consumption", "power_ac", "is", "not", "adjusted", "for", "maximum", "power", "point", "tracking", "mppt", "voltage", "windows", "or", "maximum", "current", "limits", "of", "the", "inverter", "required", "model", "parameters", "are", "column", "description", "pnom", "nominal", "dc", "power", "typically", "the", "dc", "power", "needed", "to", "produce", "maximum", "ac", "power", "output", "w", "vnom", "nominal", "dc", "input", "voltage", "typically", "the", "level", "at", "which", "the", "highest", "efficiency", "is", "achieved", "v", "vmax", "maximum", "dc", "input", "voltage", "v", "vmin", "minimum", "dc", "input", "voltage", "v", "vdcmax", "maximum", "voltage", "supplied", "from", "dc", "array", "v", "mppthi", "maximum", "dc", "voltage", "for", "mppt", "range", "v", "mpptlow", "minimum", "dc", "voltage", "for", "mppt", "range", "v", "pacmax", "maximum", "ac", "output", "power", "used", "to", "clip", "the", "output", "power", "if", "needed", "w", "adrcoefficients", "a", "list", "of", "9", "coefficients", "that", "capture", "the", "influence", "of", "input", "voltage", "and", "power", "on", "inverter", "losses", "and", "thereby", "efficiency", "corresponds", "to", "terms", "from", "1", "_", "in", "order", "math", "b_", "0", "0", "b_", "1", "0", "b_", "2", "0", "b_", "0", "1", "b_", "1", "1", "b_", "2", "1", "b_", "0", "2", "b_", "1", "2", "b_", "2", "2", "see", "1", "_", "for", "the", "use", "of", "each", "coefficient", "and", "its", "associated", "unit", "pnt", "ac", "power", "consumed", "by", "inverter", "at", "night", "night", "tare", "to", "maintain", "circuitry", "required", "to", "sense", "the", "pv", "array", "voltage", "w", "ac", "power", "output", "is", "set", "to", "nan", "where", "the", "input", "dc", "voltage", "exceeds", "a", "limit", "m", "max", "vmax", "vdcmax", "mppthi", "x", "1", "vtol", "and", "where", "the", "input", "dc", "voltage", "is", "less", "than", "a", "limit", "m", "max", "vmin", "mpptlow", "x", "1", "vtol", "references", "1", "a", "driesse", "beyond", "the", "curves", "modeling", "the", "electrical", "efficiency", "of", "photovoltaic", "inverters", "33rd", "ieee", "photovoltaic", "specialist", "conference", "pvsc", "june", "2008", "see", "also", "pvlib", "inverter", "sandia", "pvlib", "pvsystem", "retrieve_sam", "p_nom", "inverter", "pnom", "v_nom", "inverter", "vnom", "pac_max", "inverter", "pacmax", "p_nt", "inverter", "pnt", "ce_list", "inverter", "adrcoefficients", "v_max", "inverter", "vmax", "v_min", "inverter", "vmin", "vdc_max", "inverter", "vdcmax", "mppt_hi", "inverter", "mppthi", "mppt_low", "inverter", "mpptlow", "v_lim_upper", "float", "np", "nanmax", "v_max", "vdc_max", "mppt_hi", "1", "vtol", "v_lim_lower", "float", "np", "nanmax", "v_min", "mppt_low", "1", "vtol", "pdc", "p_dc", "p_nom", "vdc", "v_dc", "v_nom", "zero", "voltage", "will", "lead", "to", "division", "by", "zero", "but", "since", "power", "is", "set", "to", "night", "time", "value", "later", "these", "errors", "can", "be", "safely", "ignored", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "poly", "np", "array", "pdc", "0", "replace", "with", "np", "ones_like", "pdc", "pdc", "2", "vdc", "1", "pdc", "vdc", "1", "pdc", "2", "vdc", "1", "1", "vdc", "1", "divide", "by", "0", "pdc", "1", "vdc", "1", "invalid", "0", "0", "nan", "pdc", "2", "1", "vdc", "1", "divide", "by", "0", "p_loss", "np", "dot", "np", "array", "ce_list", "poly", "power_ac", "p_nom", "pdc", "p_loss", "p_nt", "1", "np", "absolute", "p_nt", "set", "output", "to", "nan", "where", "input", "is", "outside", "of", "limits", "errstate", "silences", "case", "where", "input", "is", "nan", "with", "np", "errstate", "invalid", "ignore", "invalid", "v_lim_upper", "v_dc", "v_dc", "v_lim_lower", "power_ac", "np", "where", "invalid", "np", "nan", "power_ac", "set", "night", "values", "power_ac", "np", "where", "vdc", "0", "p_nt", "power_ac", "power_ac", "np", "maximum", "power_ac", "p_nt", "set", "max", "ac", "output", "power_ac", "np", "minimum", "power_ac", "pac_max", "if", "isinstance", "p_dc", "pd", "series", "power_ac", "pd", "series", "power_ac", "index", "pdc", "index", "return", "power_ac"], "doc_len": 662}
{"doc_id": "pvlib/inverter.py::pvwatts", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "pvwatts", "text": "文件路径: pvlib/inverter.py\ndef pvwatts(pdc, pdc0, eta_inv_nom=0.96, eta_inv_ref=0.9637):\n    r\"\"\"\n    NREL's PVWatts inverter model.\n\n    The PVWatts inverter model [1]_ calculates inverter efficiency :math:`\\eta`\n    as a function of input DC power\n\n    .. math::\n\n        \\eta = \\frac{\\eta_{nom}}{\\eta_{ref}} (-0.0162\\zeta - \\frac{0.0059}\n        {\\zeta} + 0.9858)\n\n    where :math:`\\zeta=P_{dc}/P_{dc0}` and :math:`P_{dc0}=P_{ac0}/\\eta_{nom}`.\n\n    Output AC power is then given by\n\n    .. math::\n\n        P_{ac} = \\min(\\eta P_{dc}, P_{ac0})\n\n    Parameters\n    ----------\n    pdc : numeric\n        DC power. Same unit as ``pdc0``.\n    pdc0: numeric\n        DC input limit of the inverter.  Same unit as ``pdc``.\n    eta_inv_nom: numeric, default 0.96\n        Nominal inverter efficiency. [unitless]\n    eta_inv_ref: numeric, default 0.9637\n        Reference inverter efficiency. PVWatts defines it to be 0.9637\n        and is included here for flexibility. [unitless]\n\n    Returns\n    -------\n    power_ac: numeric\n        AC power.  Same unit as ``pdc0``.\n\n    Notes\n    -----\n    Note that ``pdc0`` is also used as a symbol in\n    :py:func:`pvlib.pvsystem.pvwatts_dc`. ``pdc0`` in this function refers to\n    the DC power input limit of the inverter. ``pdc0`` in\n    :py:func:`pvlib.pvsystem.pvwatts_dc` refers to the DC power of the modules\n    at reference conditions.\n\n    See Also\n    --------\n    pvlib.inverter.pvwatts_multi\n\n    References\n    ----------\n    .. [1] A. P. Dobos, \"PVWatts Version 5 Manual,\"\n       http://pvwatts.nrel.gov/downloads/pvwattsv5.pdf (2014).\n    \"\"\"\n\n    pac0 = eta_inv_nom * pdc0\n    zeta = pdc / pdc0\n\n    # arrays to help avoid divide by 0 for scalar and array\n    eta = np.zeros_like(pdc, dtype=float)\n    pdc_neq_0 = ~np.equal(pdc, 0)\n\n    # eta < 0 if zeta < 0.006. power_ac is forced to be >= 0 below. GH 541\n    eta = eta_inv_nom / eta_inv_ref * (\n        -0.0162 * zeta - np.divide(0.0059, zeta, out=eta, where=pdc_neq_0)\n        + 0.9858)  # noQA: W503\n\n    power_ac = eta * pdc\n    power_ac = np.minimum(pac0, power_ac)\n    power_ac = np.maximum(0, power_ac)     # GH 541\n\n    return power_ac\n", "tokens": ["pvlib", "inverter", "py", "def", "pvwatts", "pdc", "pdc0", "eta_inv_nom", "0", "96", "eta_inv_ref", "0", "9637", "r", "nrel", "s", "pvwatts", "inverter", "model", "the", "pvwatts", "inverter", "model", "1", "_", "calculates", "inverter", "efficiency", "math", "eta", "as", "a", "function", "of", "input", "dc", "power", "math", "eta", "frac", "eta_", "nom", "eta_", "ref", "0", "0162", "zeta", "frac", "0", "0059", "zeta", "0", "9858", "where", "math", "zeta", "p_", "dc", "p_", "dc0", "and", "math", "p_", "dc0", "p_", "ac0", "eta_", "nom", "output", "ac", "power", "is", "then", "given", "by", "math", "p_", "ac", "min", "eta", "p_", "dc", "p_", "ac0", "parameters", "pdc", "numeric", "dc", "power", "same", "unit", "as", "pdc0", "pdc0", "numeric", "dc", "input", "limit", "of", "the", "inverter", "same", "unit", "as", "pdc", "eta_inv_nom", "numeric", "default", "0", "96", "nominal", "inverter", "efficiency", "unitless", "eta_inv_ref", "numeric", "default", "0", "9637", "reference", "inverter", "efficiency", "pvwatts", "defines", "it", "to", "be", "0", "9637", "and", "is", "included", "here", "for", "flexibility", "unitless", "returns", "power_ac", "numeric", "ac", "power", "same", "unit", "as", "pdc0", "notes", "note", "that", "pdc0", "is", "also", "used", "as", "a", "symbol", "in", "py", "func", "pvlib", "pvsystem", "pvwatts_dc", "pdc0", "in", "this", "function", "refers", "to", "the", "dc", "power", "input", "limit", "of", "the", "inverter", "pdc0", "in", "py", "func", "pvlib", "pvsystem", "pvwatts_dc", "refers", "to", "the", "dc", "power", "of", "the", "modules", "at", "reference", "conditions", "see", "also", "pvlib", "inverter", "pvwatts_multi", "references", "1", "a", "p", "dobos", "pvwatts", "version", "5", "manual", "http", "pvwatts", "nrel", "gov", "downloads", "pvwattsv5", "pdf", "2014", "pac0", "eta_inv_nom", "pdc0", "zeta", "pdc", "pdc0", "arrays", "to", "help", "avoid", "divide", "by", "0", "for", "scalar", "and", "array", "eta", "np", "zeros_like", "pdc", "dtype", "float", "pdc_neq_0", "np", "equal", "pdc", "0", "eta", "0", "if", "zeta", "0", "006", "power_ac", "is", "forced", "to", "be", "0", "below", "gh", "541", "eta", "eta_inv_nom", "eta_inv_ref", "0", "0162", "zeta", "np", "divide", "0", "0059", "zeta", "out", "eta", "where", "pdc_neq_0", "0", "9858", "noqa", "w503", "power_ac", "eta", "pdc", "power_ac", "np", "minimum", "pac0", "power_ac", "power_ac", "np", "maximum", "0", "power_ac", "gh", "541", "return", "power_ac"], "doc_len": 294}
{"doc_id": "pvlib/inverter.py::pvwatts_multi", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "pvwatts_multi", "text": "文件路径: pvlib/inverter.py\ndef pvwatts_multi(pdc, pdc0, eta_inv_nom=0.96, eta_inv_ref=0.9637):\n    r\"\"\"\n    Extend NREL's PVWatts inverter model for multiple MPP inputs.\n\n    DC input power is summed over MPP inputs to obtain the DC power\n    input to the PVWatts inverter model. See :py:func:`pvlib.inverter.pvwatts`\n    for details.\n\n    Parameters\n    ----------\n    pdc : tuple, list or array of numeric\n        DC power on each MPPT input of the inverter. If type is array, must\n        be 2d with axis 0 being the MPPT inputs. Same unit as ``pdc0``.\n    pdc0: numeric\n        Total DC power limit of the inverter.  Same unit as ``pdc``.\n    eta_inv_nom: numeric, default 0.96\n        Nominal inverter efficiency. [unitless]\n    eta_inv_ref: numeric, default 0.9637\n        Reference inverter efficiency. PVWatts defines it to be 0.9637\n        and is included here for flexibility. [unitless]\n\n    Returns\n    -------\n    power_ac: numeric\n        AC power.  Same unit as ``pdc0``.\n\n    See Also\n    --------\n    pvlib.inverter.pvwatts\n    \"\"\"\n    return pvwatts(sum(pdc), pdc0, eta_inv_nom, eta_inv_ref)\n", "tokens": ["pvlib", "inverter", "py", "def", "pvwatts_multi", "pdc", "pdc0", "eta_inv_nom", "0", "96", "eta_inv_ref", "0", "9637", "r", "extend", "nrel", "s", "pvwatts", "inverter", "model", "for", "multiple", "mpp", "inputs", "dc", "input", "power", "is", "summed", "over", "mpp", "inputs", "to", "obtain", "the", "dc", "power", "input", "to", "the", "pvwatts", "inverter", "model", "see", "py", "func", "pvlib", "inverter", "pvwatts", "for", "details", "parameters", "pdc", "tuple", "list", "or", "array", "of", "numeric", "dc", "power", "on", "each", "mppt", "input", "of", "the", "inverter", "if", "type", "is", "array", "must", "be", "2d", "with", "axis", "0", "being", "the", "mppt", "inputs", "same", "unit", "as", "pdc0", "pdc0", "numeric", "total", "dc", "power", "limit", "of", "the", "inverter", "same", "unit", "as", "pdc", "eta_inv_nom", "numeric", "default", "0", "96", "nominal", "inverter", "efficiency", "unitless", "eta_inv_ref", "numeric", "default", "0", "9637", "reference", "inverter", "efficiency", "pvwatts", "defines", "it", "to", "be", "0", "9637", "and", "is", "included", "here", "for", "flexibility", "unitless", "returns", "power_ac", "numeric", "ac", "power", "same", "unit", "as", "pdc0", "see", "also", "pvlib", "inverter", "pvwatts", "return", "pvwatts", "sum", "pdc", "pdc0", "eta_inv_nom", "eta_inv_ref"], "doc_len": 151}
{"doc_id": "pvlib/inverter.py::fit_sandia", "file_path": "pvlib/inverter.py", "class_name": null, "func_name": "fit_sandia", "text": "文件路径: pvlib/inverter.py\ndef fit_sandia(ac_power, dc_power, dc_voltage, dc_voltage_level, p_ac_0, p_nt):\n    r'''\n    Determine parameters for the Sandia inverter model.\n\n    Parameters\n    ----------\n    ac_power : array_like\n        AC power output at each data point [W].\n    dc_power : array_like\n        DC power input at each data point [W].\n    dc_voltage : array_like\n        DC input voltage at each data point [V].\n    dc_voltage_level : array_like\n        DC input voltage level at each data point. Values must be 'Vmin',\n        'Vnom' or 'Vmax'.\n    p_ac_0 : float\n        Rated AC power of the inverter [W].\n    p_nt : float\n        Night tare, i.e., power consumed while inverter is not delivering\n        AC power. [W]\n\n    Returns\n    -------\n    dict\n        A set of parameters for the Sandia inverter model [1]_. See\n        :py:func:`pvlib.inverter.sandia` for a description of keys and values.\n\n    See Also\n    --------\n    pvlib.inverter.sandia\n\n    Notes\n    -----\n    The fitting procedure to estimate parameters is described at [2]_.\n    A data point is a pair of values (dc_power, ac_power). Typically, inverter\n    performance is measured or described at three DC input voltage levels,\n    denoted 'Vmin', 'Vnom' and 'Vmax' and at each level, inverter efficiency\n    is determined at various output power levels. For example,\n    the CEC inverter test protocol [3]_ specifies measurement of input DC\n    power that delivers AC output power of 0.1, 0.2, 0.3, 0.5, 0.75 and 1.0 of\n    the inverter's AC power rating.\n\n    References\n    ----------\n    .. [1] D. King, S. Gonzalez, G. Galbraith, W. Boyson, \"Performance Model\n       for Grid-Connected Photovoltaic Inverters\", SAND2007-5036, Sandia\n       National Laboratories.\n    .. [2] Sandia Inverter Model page, PV Performance Modeling Collaborative\n       https://pvpmc.sandia.gov/modeling-steps/dc-to-ac-conversion/sandia-inverter-model/\n    .. [3] W. Bower, et al., \"Performance Test Protocol for Evaluating\n       Inverters Used in Grid-Connected Photovoltaic Systems\", available at\n       https://www.energy.ca.gov/sites/default/files/2020-06/2004-11-22_Sandia_Test_Protocol_ada.pdf\n    '''  # noqa: E501\n\n    voltage_levels = ['Vmin', 'Vnom', 'Vmax']\n\n    # average dc input voltage at each voltage level\n    v_d = np.array(\n        [dc_voltage[dc_voltage_level == 'Vmin'].mean(),\n         dc_voltage[dc_voltage_level == 'Vnom'].mean(),\n         dc_voltage[dc_voltage_level == 'Vmax'].mean()])\n    v_nom = v_d[1]  # model parameter\n    # independent variable for regressions, x_d\n    x_d = v_d - v_nom\n\n    # empty dataframe to contain intermediate variables\n    coeffs = pd.DataFrame(index=voltage_levels,\n                          columns=['a', 'b', 'c', 'p_dc', 'p_s0'], data=np.nan)\n\n    def solve_quad(a, b, c):\n        return (-b + (b**2 - 4 * a * c)**.5) / (2 * a)\n\n    # [2] STEP 3E, fit a line to (DC voltage, model_coefficient)\n    def extract_c(x_d, add):\n        beta0, beta1 = polyfit(x_d, add, 1)\n        c = beta1 / beta0\n        return beta0, beta1, c\n\n    for d in voltage_levels:\n        x = dc_power[dc_voltage_level == d]\n        y = ac_power[dc_voltage_level == d]\n        # [2] STEP 3B\n        # fit a quadratic to (DC power, AC power)\n        c, b, a = polyfit(x, y, 2)\n\n        # [2] STEP 3D, solve for p_dc and p_s0\n        p_dc = solve_quad(a, b, (c - p_ac_0))\n        p_s0 = solve_quad(a, b, c)\n\n        # Add values to dataframe at index d\n        coeffs['a'][d] = a\n        coeffs['p_dc'][d] = p_dc\n        coeffs['p_s0'][d] = p_s0\n\n    b_dc0, b_dc1, c1 = extract_c(x_d, coeffs['p_dc'])\n    b_s0, b_s1, c2 = extract_c(x_d, coeffs['p_s0'])\n    b_c0, b_c1, c3 = extract_c(x_d, coeffs['a'])\n\n    p_dc0 = b_dc0\n    p_s0 = b_s0\n    c0 = b_c0\n\n    # prepare dict and return\n    return {'Paco': p_ac_0, 'Pdco': p_dc0, 'Vdco': v_nom, 'Pso': p_s0,\n            'C0': c0, 'C1': c1, 'C2': c2, 'C3': c3, 'Pnt': p_nt}\n", "tokens": ["pvlib", "inverter", "py", "def", "fit_sandia", "ac_power", "dc_power", "dc_voltage", "dc_voltage_level", "p_ac_0", "p_nt", "r", "determine", "parameters", "for", "the", "sandia", "inverter", "model", "parameters", "ac_power", "array_like", "ac", "power", "output", "at", "each", "data", "point", "w", "dc_power", "array_like", "dc", "power", "input", "at", "each", "data", "point", "w", "dc_voltage", "array_like", "dc", "input", "voltage", "at", "each", "data", "point", "v", "dc_voltage_level", "array_like", "dc", "input", "voltage", "level", "at", "each", "data", "point", "values", "must", "be", "vmin", "vnom", "or", "vmax", "p_ac_0", "float", "rated", "ac", "power", "of", "the", "inverter", "w", "p_nt", "float", "night", "tare", "i", "e", "power", "consumed", "while", "inverter", "is", "not", "delivering", "ac", "power", "w", "returns", "dict", "a", "set", "of", "parameters", "for", "the", "sandia", "inverter", "model", "1", "_", "see", "py", "func", "pvlib", "inverter", "sandia", "for", "a", "description", "of", "keys", "and", "values", "see", "also", "pvlib", "inverter", "sandia", "notes", "the", "fitting", "procedure", "to", "estimate", "parameters", "is", "described", "at", "2", "_", "a", "data", "point", "is", "a", "pair", "of", "values", "dc_power", "ac_power", "typically", "inverter", "performance", "is", "measured", "or", "described", "at", "three", "dc", "input", "voltage", "levels", "denoted", "vmin", "vnom", "and", "vmax", "and", "at", "each", "level", "inverter", "efficiency", "is", "determined", "at", "various", "output", "power", "levels", "for", "example", "the", "cec", "inverter", "test", "protocol", "3", "_", "specifies", "measurement", "of", "input", "dc", "power", "that", "delivers", "ac", "output", "power", "of", "0", "1", "0", "2", "0", "3", "0", "5", "0", "75", "and", "1", "0", "of", "the", "inverter", "s", "ac", "power", "rating", "references", "1", "d", "king", "s", "gonzalez", "g", "galbraith", "w", "boyson", "performance", "model", "for", "grid", "connected", "photovoltaic", "inverters", "sand2007", "5036", "sandia", "national", "laboratories", "2", "sandia", "inverter", "model", "page", "pv", "performance", "modeling", "collaborative", "https", "pvpmc", "sandia", "gov", "modeling", "steps", "dc", "to", "ac", "conversion", "sandia", "inverter", "model", "3", "w", "bower", "et", "al", "performance", "test", "protocol", "for", "evaluating", "inverters", "used", "in", "grid", "connected", "photovoltaic", "systems", "available", "at", "https", "www", "energy", "ca", "gov", "sites", "default", "files", "2020", "06", "2004", "11", "22_sandia_test_protocol_ada", "pdf", "noqa", "e501", "voltage_levels", "vmin", "vnom", "vmax", "average", "dc", "input", "voltage", "at", "each", "voltage", "level", "v_d", "np", "array", "dc_voltage", "dc_voltage_level", "vmin", "mean", "dc_voltage", "dc_voltage_level", "vnom", "mean", "dc_voltage", "dc_voltage_level", "vmax", "mean", "v_nom", "v_d", "1", "model", "parameter", "independent", "variable", "for", "regressions", "x_d", "x_d", "v_d", "v_nom", "empty", "dataframe", "to", "contain", "intermediate", "variables", "coeffs", "pd", "dataframe", "index", "voltage_levels", "columns", "a", "b", "c", "p_dc", "p_s0", "data", "np", "nan", "def", "solve_quad", "a", "b", "c", "return", "b", "b", "2", "4", "a", "c", "5", "2", "a", "2", "step", "3e", "fit", "a", "line", "to", "dc", "voltage", "model_coefficient", "def", "extract_c", "x_d", "add", "beta0", "beta1", "polyfit", "x_d", "add", "1", "c", "beta1", "beta0", "return", "beta0", "beta1", "c", "for", "d", "in", "voltage_levels", "x", "dc_power", "dc_voltage_level", "d", "y", "ac_power", "dc_voltage_level", "d", "2", "step", "3b", "fit", "a", "quadratic", "to", "dc", "power", "ac", "power", "c", "b", "a", "polyfit", "x", "y", "2", "2", "step", "3d", "solve", "for", "p_dc", "and", "p_s0", "p_dc", "solve_quad", "a", "b", "c", "p_ac_0", "p_s0", "solve_quad", "a", "b", "c", "add", "values", "to", "dataframe", "at", "index", "d", "coeffs", "a", "d", "a", "coeffs", "p_dc", "d", "p_dc", "coeffs", "p_s0", "d", "p_s0", "b_dc0", "b_dc1", "c1", "extract_c", "x_d", "coeffs", "p_dc", "b_s0", "b_s1", "c2", "extract_c", "x_d", "coeffs", "p_s0", "b_c0", "b_c1", "c3", "extract_c", "x_d", "coeffs", "a", "p_dc0", "b_dc0", "p_s0", "b_s0", "c0", "b_c0", "prepare", "dict", "and", "return", "return", "paco", "p_ac_0", "pdco", "p_dc0", "vdco", "v_nom", "pso", "p_s0", "c0", "c0", "c1", "c1", "c2", "c2", "c3", "c3", "pnt", "p_nt"], "doc_len": 516}
{"doc_id": "pvlib/irradiance.py::get_extra_radiation", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "get_extra_radiation", "text": "文件路径: pvlib/irradiance.py\ndef get_extra_radiation(datetime_or_doy, solar_constant=1366.1,\n                        method='spencer', epoch_year=2014, **kwargs):\n    \"\"\"\n    Determine extraterrestrial radiation from day of year.\n\n    Parameters\n    ----------\n    datetime_or_doy : numeric, array, date, datetime, Timestamp, DatetimeIndex\n        Day of year, array of days of year, or datetime-like object\n\n    solar_constant : float, default 1366.1\n        The solar constant.\n\n    method : string, default 'spencer'\n        The method by which the ET radiation should be calculated.\n        Options include ``'pyephem', 'spencer', 'asce', 'nrel'``.\n\n    epoch_year : int, default 2014\n        The year in which a day of year input will be calculated. Only\n        applies to day of year input used with the pyephem or nrel\n        methods.\n\n    kwargs :\n        Passed to solarposition.nrel_earthsun_distance\n\n    Returns\n    -------\n    dni_extra : float, array, or Series\n        The extraterrestrial radiation present in watts per square meter\n        on a surface which is normal to the sun. Pandas Timestamp and\n        DatetimeIndex inputs will yield a Pandas TimeSeries. All other\n        inputs will yield a float or an array of floats.\n\n    References\n    ----------\n    .. [1] M. Reno, C. Hansen, and J. Stein, \"Global Horizontal Irradiance\n       Clear Sky Models: Implementation and Analysis\", Sandia National\n       Laboratories, SAND2012-2389, 2012.\n\n    .. [2] <http://solardat.uoregon.edu/SolarRadiationBasics.html>, Eqs.\n       SR1 and SR2\n\n    .. [3] Partridge, G. W. and Platt, C. M. R. 1976. Radiative Processes\n       in Meteorology and Climatology.\n\n    .. [4] Duffie, J. A. and Beckman, W. A. 1991. Solar Engineering of\n       Thermal Processes, 2nd edn. J. Wiley and Sons, New York.\n\n    .. [5] ASCE, 2005. The ASCE Standardized Reference Evapotranspiration\n       Equation, Environmental and Water Resources Institute of the American\n       Civil Engineers, Ed. R. G. Allen et al.\n    \"\"\"\n\n    to_doy, to_datetimeindex, to_output = \\\n        _handle_extra_radiation_types(datetime_or_doy, epoch_year)\n\n    # consider putting asce and spencer methods in their own functions\n    method = method.lower()\n    if method == 'asce':\n        B = solarposition._calculate_simple_day_angle(to_doy(datetime_or_doy),\n                                                      offset=0)\n        RoverR0sqrd = 1 + 0.033 * np.cos(B)\n    elif method == 'spencer':\n        B = solarposition._calculate_simple_day_angle(to_doy(datetime_or_doy))\n        RoverR0sqrd = (1.00011 + 0.034221 * np.cos(B) + 0.00128 * np.sin(B) +\n                       0.000719 * np.cos(2 * B) + 7.7e-05 * np.sin(2 * B))\n    elif method == 'pyephem':\n        times = to_datetimeindex(datetime_or_doy)\n        RoverR0sqrd = solarposition.pyephem_earthsun_distance(times) ** (-2)\n    elif method == 'nrel':\n        times = to_datetimeindex(datetime_or_doy)\n        RoverR0sqrd = \\\n            solarposition.nrel_earthsun_distance(times, **kwargs) ** (-2)\n    else:\n        raise ValueError('Invalid method: %s', method)\n\n    Ea = solar_constant * RoverR0sqrd\n\n    Ea = to_output(Ea)\n\n    return Ea\n", "tokens": ["pvlib", "irradiance", "py", "def", "get_extra_radiation", "datetime_or_doy", "solar_constant", "1366", "1", "method", "spencer", "epoch_year", "2014", "kwargs", "determine", "extraterrestrial", "radiation", "from", "day", "of", "year", "parameters", "datetime_or_doy", "numeric", "array", "date", "datetime", "timestamp", "datetimeindex", "day", "of", "year", "array", "of", "days", "of", "year", "or", "datetime", "like", "object", "solar_constant", "float", "default", "1366", "1", "the", "solar", "constant", "method", "string", "default", "spencer", "the", "method", "by", "which", "the", "et", "radiation", "should", "be", "calculated", "options", "include", "pyephem", "spencer", "asce", "nrel", "epoch_year", "int", "default", "2014", "the", "year", "in", "which", "a", "day", "of", "year", "input", "will", "be", "calculated", "only", "applies", "to", "day", "of", "year", "input", "used", "with", "the", "pyephem", "or", "nrel", "methods", "kwargs", "passed", "to", "solarposition", "nrel_earthsun_distance", "returns", "dni_extra", "float", "array", "or", "series", "the", "extraterrestrial", "radiation", "present", "in", "watts", "per", "square", "meter", "on", "a", "surface", "which", "is", "normal", "to", "the", "sun", "pandas", "timestamp", "and", "datetimeindex", "inputs", "will", "yield", "a", "pandas", "timeseries", "all", "other", "inputs", "will", "yield", "a", "float", "or", "an", "array", "of", "floats", "references", "1", "m", "reno", "c", "hansen", "and", "j", "stein", "global", "horizontal", "irradiance", "clear", "sky", "models", "implementation", "and", "analysis", "sandia", "national", "laboratories", "sand2012", "2389", "2012", "2", "http", "solardat", "uoregon", "edu", "solarradiationbasics", "html", "eqs", "sr1", "and", "sr2", "3", "partridge", "g", "w", "and", "platt", "c", "m", "r", "1976", "radiative", "processes", "in", "meteorology", "and", "climatology", "4", "duffie", "j", "a", "and", "beckman", "w", "a", "1991", "solar", "engineering", "of", "thermal", "processes", "2nd", "edn", "j", "wiley", "and", "sons", "new", "york", "5", "asce", "2005", "the", "asce", "standardized", "reference", "evapotranspiration", "equation", "environmental", "and", "water", "resources", "institute", "of", "the", "american", "civil", "engineers", "ed", "r", "g", "allen", "et", "al", "to_doy", "to_datetimeindex", "to_output", "_handle_extra_radiation_types", "datetime_or_doy", "epoch_year", "consider", "putting", "asce", "and", "spencer", "methods", "in", "their", "own", "functions", "method", "method", "lower", "if", "method", "asce", "b", "solarposition", "_calculate_simple_day_angle", "to_doy", "datetime_or_doy", "offset", "0", "roverr0sqrd", "1", "0", "033", "np", "cos", "b", "elif", "method", "spencer", "b", "solarposition", "_calculate_simple_day_angle", "to_doy", "datetime_or_doy", "roverr0sqrd", "1", "00011", "0", "034221", "np", "cos", "b", "0", "00128", "np", "sin", "b", "0", "000719", "np", "cos", "2", "b", "7", "7e", "05", "np", "sin", "2", "b", "elif", "method", "pyephem", "times", "to_datetimeindex", "datetime_or_doy", "roverr0sqrd", "solarposition", "pyephem_earthsun_distance", "times", "2", "elif", "method", "nrel", "times", "to_datetimeindex", "datetime_or_doy", "roverr0sqrd", "solarposition", "nrel_earthsun_distance", "times", "kwargs", "2", "else", "raise", "valueerror", "invalid", "method", "s", "method", "ea", "solar_constant", "roverr0sqrd", "ea", "to_output", "ea", "return", "ea"], "doc_len": 356}
{"doc_id": "pvlib/irradiance.py::_handle_extra_radiation_types", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_handle_extra_radiation_types", "text": "文件路径: pvlib/irradiance.py\ndef _handle_extra_radiation_types(datetime_or_doy, epoch_year):\n    # This block will set the functions that can be used to convert the\n    # inputs to either day of year or pandas DatetimeIndex, and the\n    # functions that will yield the appropriate output type. It's\n    # complicated because there are many day-of-year-like input types,\n    # and the different algorithms need different types. Maybe you have\n    # a better way to do it.\n    if isinstance(datetime_or_doy, pd.DatetimeIndex):\n        to_doy = tools._pandas_to_doy  # won't be evaluated unless necessary\n        def to_datetimeindex(x): return x                       # noqa: E306\n        to_output = partial(pd.Series, index=datetime_or_doy)\n    elif isinstance(datetime_or_doy, pd.Timestamp):\n        to_doy = tools._pandas_to_doy\n        to_datetimeindex = \\\n            tools._datetimelike_scalar_to_datetimeindex\n        to_output = tools._scalar_out\n    elif isinstance(datetime_or_doy,\n                    (datetime.date, datetime.datetime, np.datetime64)):\n        to_doy = tools._datetimelike_scalar_to_doy\n        to_datetimeindex = \\\n            tools._datetimelike_scalar_to_datetimeindex\n        to_output = tools._scalar_out\n    elif np.isscalar(datetime_or_doy):  # ints and floats of various types\n        def to_doy(x): return x                                 # noqa: E306\n        to_datetimeindex = partial(tools._doy_to_datetimeindex,\n                                   epoch_year=epoch_year)\n        to_output = tools._scalar_out\n    else:  # assume that we have an array-like object of doy\n        def to_doy(x): return x                                 # noqa: E306\n        to_datetimeindex = partial(tools._doy_to_datetimeindex,\n                                   epoch_year=epoch_year)\n        to_output = tools._array_out\n\n    return to_doy, to_datetimeindex, to_output\n", "tokens": ["pvlib", "irradiance", "py", "def", "_handle_extra_radiation_types", "datetime_or_doy", "epoch_year", "this", "block", "will", "set", "the", "functions", "that", "can", "be", "used", "to", "convert", "the", "inputs", "to", "either", "day", "of", "year", "or", "pandas", "datetimeindex", "and", "the", "functions", "that", "will", "yield", "the", "appropriate", "output", "type", "it", "s", "complicated", "because", "there", "are", "many", "day", "of", "year", "like", "input", "types", "and", "the", "different", "algorithms", "need", "different", "types", "maybe", "you", "have", "a", "better", "way", "to", "do", "it", "if", "isinstance", "datetime_or_doy", "pd", "datetimeindex", "to_doy", "tools", "_pandas_to_doy", "won", "t", "be", "evaluated", "unless", "necessary", "def", "to_datetimeindex", "x", "return", "x", "noqa", "e306", "to_output", "partial", "pd", "series", "index", "datetime_or_doy", "elif", "isinstance", "datetime_or_doy", "pd", "timestamp", "to_doy", "tools", "_pandas_to_doy", "to_datetimeindex", "tools", "_datetimelike_scalar_to_datetimeindex", "to_output", "tools", "_scalar_out", "elif", "isinstance", "datetime_or_doy", "datetime", "date", "datetime", "datetime", "np", "datetime64", "to_doy", "tools", "_datetimelike_scalar_to_doy", "to_datetimeindex", "tools", "_datetimelike_scalar_to_datetimeindex", "to_output", "tools", "_scalar_out", "elif", "np", "isscalar", "datetime_or_doy", "ints", "and", "floats", "of", "various", "types", "def", "to_doy", "x", "return", "x", "noqa", "e306", "to_datetimeindex", "partial", "tools", "_doy_to_datetimeindex", "epoch_year", "epoch_year", "to_output", "tools", "_scalar_out", "else", "assume", "that", "we", "have", "an", "array", "like", "object", "of", "doy", "def", "to_doy", "x", "return", "x", "noqa", "e306", "to_datetimeindex", "partial", "tools", "_doy_to_datetimeindex", "epoch_year", "epoch_year", "to_output", "tools", "_array_out", "return", "to_doy", "to_datetimeindex", "to_output"], "doc_len": 184}
{"doc_id": "pvlib/irradiance.py::aoi_projection", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "aoi_projection", "text": "文件路径: pvlib/irradiance.py\ndef aoi_projection(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth):\n    \"\"\"\n    Calculates the dot product of the sun position unit vector and the surface\n    normal unit vector; in other words, the cosine of the angle of incidence.\n\n    Usage note: When the sun is behind the surface the value returned is\n    negative.  For many uses negative values must be set to zero.\n\n    Input all angles in degrees.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal.\n    surface_azimuth : numeric\n        Panel azimuth from north.\n    solar_zenith : numeric\n        Solar zenith angle.\n    solar_azimuth : numeric\n        Solar azimuth angle.\n\n    Returns\n    -------\n    projection : numeric\n        Dot product of panel normal and solar angle.\n    \"\"\"\n\n    projection = (\n        tools.cosd(surface_tilt) * tools.cosd(solar_zenith) +\n        tools.sind(surface_tilt) * tools.sind(solar_zenith) *\n        tools.cosd(solar_azimuth - surface_azimuth))\n\n    # GH 1185\n    projection = np.clip(projection, -1, 1)\n\n    try:\n        projection.name = 'aoi_projection'\n    except AttributeError:\n        pass\n\n    return projection\n", "tokens": ["pvlib", "irradiance", "py", "def", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "calculates", "the", "dot", "product", "of", "the", "sun", "position", "unit", "vector", "and", "the", "surface", "normal", "unit", "vector", "in", "other", "words", "the", "cosine", "of", "the", "angle", "of", "incidence", "usage", "note", "when", "the", "sun", "is", "behind", "the", "surface", "the", "value", "returned", "is", "negative", "for", "many", "uses", "negative", "values", "must", "be", "set", "to", "zero", "input", "all", "angles", "in", "degrees", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "numeric", "solar", "zenith", "angle", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "returns", "projection", "numeric", "dot", "product", "of", "panel", "normal", "and", "solar", "angle", "projection", "tools", "cosd", "surface_tilt", "tools", "cosd", "solar_zenith", "tools", "sind", "surface_tilt", "tools", "sind", "solar_zenith", "tools", "cosd", "solar_azimuth", "surface_azimuth", "gh", "1185", "projection", "np", "clip", "projection", "1", "1", "try", "projection", "name", "aoi_projection", "except", "attributeerror", "pass", "return", "projection"], "doc_len": 132}
{"doc_id": "pvlib/irradiance.py::aoi", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "aoi", "text": "文件路径: pvlib/irradiance.py\ndef aoi(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth):\n    \"\"\"\n    Calculates the angle of incidence of the solar vector on a surface.\n    This is the angle between the solar vector and the surface normal.\n\n    Input all angles in degrees.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal.\n    surface_azimuth : numeric\n        Panel azimuth from north.\n    solar_zenith : numeric\n        Solar zenith angle.\n    solar_azimuth : numeric\n        Solar azimuth angle.\n\n    Returns\n    -------\n    aoi : numeric\n        Angle of incidence in degrees.\n    \"\"\"\n\n    projection = aoi_projection(surface_tilt, surface_azimuth,\n                                solar_zenith, solar_azimuth)\n    aoi_value = np.rad2deg(np.arccos(projection))\n\n    try:\n        aoi_value.name = 'aoi'\n    except AttributeError:\n        pass\n\n    return aoi_value\n", "tokens": ["pvlib", "irradiance", "py", "def", "aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "calculates", "the", "angle", "of", "incidence", "of", "the", "solar", "vector", "on", "a", "surface", "this", "is", "the", "angle", "between", "the", "solar", "vector", "and", "the", "surface", "normal", "input", "all", "angles", "in", "degrees", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "numeric", "solar", "zenith", "angle", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "returns", "aoi", "numeric", "angle", "of", "incidence", "in", "degrees", "projection", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "aoi_value", "np", "rad2deg", "np", "arccos", "projection", "try", "aoi_value", "name", "aoi", "except", "attributeerror", "pass", "return", "aoi_value"], "doc_len": 90}
{"doc_id": "pvlib/irradiance.py::poa_horizontal_ratio", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "poa_horizontal_ratio", "text": "文件路径: pvlib/irradiance.py\ndef poa_horizontal_ratio(surface_tilt, surface_azimuth,\n                         solar_zenith, solar_azimuth):\n    \"\"\"\n    Calculates the ratio of the beam components of the plane of array\n    irradiance and the horizontal irradiance.\n\n    Input all angles in degrees.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal.\n    surface_azimuth : numeric\n        Panel azimuth from north.\n    solar_zenith : numeric\n        Solar zenith angle.\n    solar_azimuth : numeric\n        Solar azimuth angle.\n\n    Returns\n    -------\n    ratio : numeric\n        Ratio of the plane of array irradiance to the horizontal plane\n        irradiance\n    \"\"\"\n\n    cos_poa_zen = aoi_projection(surface_tilt, surface_azimuth,\n                                 solar_zenith, solar_azimuth)\n\n    cos_solar_zenith = tools.cosd(solar_zenith)\n\n    # ratio of tilted and horizontal beam irradiance\n    ratio = cos_poa_zen / cos_solar_zenith\n\n    try:\n        ratio.name = 'poa_ratio'\n    except AttributeError:\n        pass\n\n    return ratio\n", "tokens": ["pvlib", "irradiance", "py", "def", "poa_horizontal_ratio", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "calculates", "the", "ratio", "of", "the", "beam", "components", "of", "the", "plane", "of", "array", "irradiance", "and", "the", "horizontal", "irradiance", "input", "all", "angles", "in", "degrees", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "numeric", "solar", "zenith", "angle", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "returns", "ratio", "numeric", "ratio", "of", "the", "plane", "of", "array", "irradiance", "to", "the", "horizontal", "plane", "irradiance", "cos_poa_zen", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "cos_solar_zenith", "tools", "cosd", "solar_zenith", "ratio", "of", "tilted", "and", "horizontal", "beam", "irradiance", "ratio", "cos_poa_zen", "cos_solar_zenith", "try", "ratio", "name", "poa_ratio", "except", "attributeerror", "pass", "return", "ratio"], "doc_len": 98}
{"doc_id": "pvlib/irradiance.py::beam_component", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "beam_component", "text": "文件路径: pvlib/irradiance.py\ndef beam_component(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n                   dni):\n    \"\"\"\n    Calculates the beam component of the plane of array irradiance.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal.\n    surface_azimuth : numeric\n        Panel azimuth from north.\n    solar_zenith : numeric\n        Solar zenith angle.\n    solar_azimuth : numeric\n        Solar azimuth angle.\n    dni : numeric\n        Direct Normal Irradiance\n\n    Returns\n    -------\n    beam : numeric\n        Beam component\n    \"\"\"\n    beam = dni * aoi_projection(surface_tilt, surface_azimuth,\n                                solar_zenith, solar_azimuth)\n    beam = np.maximum(beam, 0)\n\n    return beam\n", "tokens": ["pvlib", "irradiance", "py", "def", "beam_component", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "calculates", "the", "beam", "component", "of", "the", "plane", "of", "array", "irradiance", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "numeric", "solar", "zenith", "angle", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "dni", "numeric", "direct", "normal", "irradiance", "returns", "beam", "numeric", "beam", "component", "beam", "dni", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "beam", "np", "maximum", "beam", "0", "return", "beam"], "doc_len": 67}
{"doc_id": "pvlib/irradiance.py::get_total_irradiance", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "get_total_irradiance", "text": "文件路径: pvlib/irradiance.py\ndef get_total_irradiance(surface_tilt, surface_azimuth,\n                         solar_zenith, solar_azimuth,\n                         dni, ghi, dhi, dni_extra=None, airmass=None,\n                         albedo=0.25, surface_type=None,\n                         model='isotropic',\n                         model_perez='allsitescomposite1990'):\n    r\"\"\"\n    Determine total in-plane irradiance and its beam, sky diffuse and ground\n    reflected components, using the specified sky diffuse irradiance model.\n\n    .. math::\n\n       I_{tot} = I_{beam} + I_{sky diffuse} + I_{ground}\n\n    Sky diffuse models include:\n        * isotropic (default)\n        * klucher\n        * haydavies\n        * reindl\n        * king\n        * perez\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal. [degree]\n    surface_azimuth : numeric\n        Panel azimuth from north. [degree]\n    solar_zenith : numeric\n        Solar zenith angle. [degree]\n    solar_azimuth : numeric\n        Solar azimuth angle. [degree]\n    dni : numeric\n        Direct Normal Irradiance. [W/m2]\n    ghi : numeric\n        Global horizontal irradiance. [W/m2]\n    dhi : numeric\n        Diffuse horizontal irradiance. [W/m2]\n    dni_extra : None or numeric, default None\n        Extraterrestrial direct normal irradiance. [W/m2]\n    airmass : None or numeric, default None\n        Relative airmass (not adjusted for pressure). [unitless]\n    albedo : numeric, default 0.25\n        Ground surface albedo. [unitless]\n    surface_type : None or str, default None\n        Surface type. See :py:func:`~pvlib.irradiance.get_ground_diffuse` for\n        the list of accepted values.\n    model : str, default 'isotropic'\n        Irradiance model. Can be one of ``'isotropic'``, ``'klucher'``,\n        ``'haydavies'``, ``'reindl'``, ``'king'``, ``'perez'``.\n    model_perez : str, default 'allsitescomposite1990'\n        Used only if ``model='perez'``. See :py:func:`~pvlib.irradiance.perez`.\n\n    Returns\n    -------\n    total_irrad : OrderedDict or DataFrame\n        Contains keys/columns ``'poa_global', 'poa_direct', 'poa_diffuse',\n        'poa_sky_diffuse', 'poa_ground_diffuse'``.\n\n    Notes\n    -----\n    Models ``'haydavies'``, ``'reindl'``, or ``'perez'`` require\n    ``'dni_extra'``. Values can be calculated using\n    :py:func:`~pvlib.irradiance.get_extra_radiation`.\n\n    The ``'perez'`` model requires relative airmass (``airmass``) as input. If\n    ``airmass`` is not provided, it is calculated using the defaults in\n    :py:func:`~pvlib.atmosphere.get_relative_airmass`.\n    \"\"\"\n\n    poa_sky_diffuse = get_sky_diffuse(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        dni, ghi, dhi, dni_extra=dni_extra, airmass=airmass, model=model,\n        model_perez=model_perez)\n\n    poa_ground_diffuse = get_ground_diffuse(surface_tilt, ghi, albedo,\n                                            surface_type)\n    aoi_ = aoi(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth)\n    irrads = poa_components(aoi_, dni, poa_sky_diffuse, poa_ground_diffuse)\n    return irrads\n", "tokens": ["pvlib", "irradiance", "py", "def", "get_total_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "none", "airmass", "none", "albedo", "0", "25", "surface_type", "none", "model", "isotropic", "model_perez", "allsitescomposite1990", "r", "determine", "total", "in", "plane", "irradiance", "and", "its", "beam", "sky", "diffuse", "and", "ground", "reflected", "components", "using", "the", "specified", "sky", "diffuse", "irradiance", "model", "math", "i_", "tot", "i_", "beam", "i_", "sky", "diffuse", "i_", "ground", "sky", "diffuse", "models", "include", "isotropic", "default", "klucher", "haydavies", "reindl", "king", "perez", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "degree", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "degree", "solar_zenith", "numeric", "solar", "zenith", "angle", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "degree", "dni", "numeric", "direct", "normal", "irradiance", "w", "m2", "ghi", "numeric", "global", "horizontal", "irradiance", "w", "m2", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "w", "m2", "dni_extra", "none", "or", "numeric", "default", "none", "extraterrestrial", "direct", "normal", "irradiance", "w", "m2", "airmass", "none", "or", "numeric", "default", "none", "relative", "airmass", "not", "adjusted", "for", "pressure", "unitless", "albedo", "numeric", "default", "0", "25", "ground", "surface", "albedo", "unitless", "surface_type", "none", "or", "str", "default", "none", "surface", "type", "see", "py", "func", "pvlib", "irradiance", "get_ground_diffuse", "for", "the", "list", "of", "accepted", "values", "model", "str", "default", "isotropic", "irradiance", "model", "can", "be", "one", "of", "isotropic", "klucher", "haydavies", "reindl", "king", "perez", "model_perez", "str", "default", "allsitescomposite1990", "used", "only", "if", "model", "perez", "see", "py", "func", "pvlib", "irradiance", "perez", "returns", "total_irrad", "ordereddict", "or", "dataframe", "contains", "keys", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "notes", "models", "haydavies", "reindl", "or", "perez", "require", "dni_extra", "values", "can", "be", "calculated", "using", "py", "func", "pvlib", "irradiance", "get_extra_radiation", "the", "perez", "model", "requires", "relative", "airmass", "airmass", "as", "input", "if", "airmass", "is", "not", "provided", "it", "is", "calculated", "using", "the", "defaults", "in", "py", "func", "pvlib", "atmosphere", "get_relative_airmass", "poa_sky_diffuse", "get_sky_diffuse", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "dni_extra", "airmass", "airmass", "model", "model", "model_perez", "model_perez", "poa_ground_diffuse", "get_ground_diffuse", "surface_tilt", "ghi", "albedo", "surface_type", "aoi_", "aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "irrads", "poa_components", "aoi_", "dni", "poa_sky_diffuse", "poa_ground_diffuse", "return", "irrads"], "doc_len": 295}
{"doc_id": "pvlib/irradiance.py::get_sky_diffuse", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "get_sky_diffuse", "text": "文件路径: pvlib/irradiance.py\ndef get_sky_diffuse(surface_tilt, surface_azimuth,\n                    solar_zenith, solar_azimuth,\n                    dni, ghi, dhi, dni_extra=None, airmass=None,\n                    model='isotropic',\n                    model_perez='allsitescomposite1990'):\n    r\"\"\"\n    Determine in-plane sky diffuse irradiance component\n    using the specified sky diffuse irradiance model.\n\n    Sky diffuse models include:\n        * isotropic (default)\n        * klucher\n        * haydavies\n        * reindl\n        * king\n        * perez\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal. [degree]\n    surface_azimuth : numeric\n        Panel azimuth from north. [degree]\n    solar_zenith : numeric\n        Solar zenith angle. [degree]\n    solar_azimuth : numeric\n        Solar azimuth angle. [degree]\n    dni : numeric\n        Direct Normal Irradiance. [W/m2]\n    ghi : numeric\n        Global horizontal irradiance. [W/m2]\n    dhi : numeric\n        Diffuse horizontal irradiance. [W/m2]\n    dni_extra : None or numeric, default None\n        Extraterrestrial direct normal irradiance. [W/m2]\n    airmass : None or numeric, default None\n        Relative airmass (not adjusted for pressure). [unitless]\n    model : str, default 'isotropic'\n        Irradiance model. Can be one of ``'isotropic'``, ``'klucher'``,\n        ``'haydavies'``, ``'reindl'``, ``'king'``, ``'perez'``.\n    model_perez : str, default 'allsitescomposite1990'\n        Used only if ``model='perez'``. See :py:func:`~pvlib.irradiance.perez`.\n\n    Returns\n    -------\n    poa_sky_diffuse : numeric\n        Sky diffuse irradiance in the plane of array. [W/m2]\n\n    Raises\n    ------\n    ValueError\n        If model is one of ``'haydavies'``, ``'reindl'``, or ``'perez'`` and\n        ``dni_extra`` is ``None``.\n\n    Notes\n    -----\n    Models ``'haydavies'``, ``'reindl'``, and ``'perez``` require 'dni_extra'.\n    Values can be calculated using\n    :py:func:`~pvlib.irradiance.get_extra_radiation`.\n\n    The ``'perez'`` model requires relative airmass (``airmass``) as input. If\n    ``airmass`` is not provided, it is calculated using the defaults in\n    :py:func:`~pvlib.atmosphere.get_relative_airmass`.\n    \"\"\"\n\n    model = model.lower()\n\n    if (model in {'haydavies', 'reindl', 'perez'}) and (dni_extra is None):\n        raise ValueError(f'dni_extra is required for model {model}')\n\n    if model == 'isotropic':\n        sky = isotropic(surface_tilt, dhi)\n    elif model == 'klucher':\n        sky = klucher(surface_tilt, surface_azimuth, dhi, ghi,\n                      solar_zenith, solar_azimuth)\n    elif model == 'haydavies':\n        sky = haydavies(surface_tilt, surface_azimuth, dhi, dni, dni_extra,\n                        solar_zenith, solar_azimuth)\n    elif model == 'reindl':\n        sky = reindl(surface_tilt, surface_azimuth, dhi, dni, ghi, dni_extra,\n                     solar_zenith, solar_azimuth)\n    elif model == 'king':\n        sky = king(surface_tilt, dhi, ghi, solar_zenith)\n    elif model == 'perez':\n        if airmass is None:\n            airmass = atmosphere.get_relative_airmass(solar_zenith)\n        sky = perez(surface_tilt, surface_azimuth, dhi, dni, dni_extra,\n                    solar_zenith, solar_azimuth, airmass,\n                    model=model_perez)\n    else:\n        raise ValueError(f'invalid model selection {model}')\n\n    return sky\n", "tokens": ["pvlib", "irradiance", "py", "def", "get_sky_diffuse", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "none", "airmass", "none", "model", "isotropic", "model_perez", "allsitescomposite1990", "r", "determine", "in", "plane", "sky", "diffuse", "irradiance", "component", "using", "the", "specified", "sky", "diffuse", "irradiance", "model", "sky", "diffuse", "models", "include", "isotropic", "default", "klucher", "haydavies", "reindl", "king", "perez", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "degree", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "degree", "solar_zenith", "numeric", "solar", "zenith", "angle", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "degree", "dni", "numeric", "direct", "normal", "irradiance", "w", "m2", "ghi", "numeric", "global", "horizontal", "irradiance", "w", "m2", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "w", "m2", "dni_extra", "none", "or", "numeric", "default", "none", "extraterrestrial", "direct", "normal", "irradiance", "w", "m2", "airmass", "none", "or", "numeric", "default", "none", "relative", "airmass", "not", "adjusted", "for", "pressure", "unitless", "model", "str", "default", "isotropic", "irradiance", "model", "can", "be", "one", "of", "isotropic", "klucher", "haydavies", "reindl", "king", "perez", "model_perez", "str", "default", "allsitescomposite1990", "used", "only", "if", "model", "perez", "see", "py", "func", "pvlib", "irradiance", "perez", "returns", "poa_sky_diffuse", "numeric", "sky", "diffuse", "irradiance", "in", "the", "plane", "of", "array", "w", "m2", "raises", "valueerror", "if", "model", "is", "one", "of", "haydavies", "reindl", "or", "perez", "and", "dni_extra", "is", "none", "notes", "models", "haydavies", "reindl", "and", "perez", "require", "dni_extra", "values", "can", "be", "calculated", "using", "py", "func", "pvlib", "irradiance", "get_extra_radiation", "the", "perez", "model", "requires", "relative", "airmass", "airmass", "as", "input", "if", "airmass", "is", "not", "provided", "it", "is", "calculated", "using", "the", "defaults", "in", "py", "func", "pvlib", "atmosphere", "get_relative_airmass", "model", "model", "lower", "if", "model", "in", "haydavies", "reindl", "perez", "and", "dni_extra", "is", "none", "raise", "valueerror", "f", "dni_extra", "is", "required", "for", "model", "model", "if", "model", "isotropic", "sky", "isotropic", "surface_tilt", "dhi", "elif", "model", "klucher", "sky", "klucher", "surface_tilt", "surface_azimuth", "dhi", "ghi", "solar_zenith", "solar_azimuth", "elif", "model", "haydavies", "sky", "haydavies", "surface_tilt", "surface_azimuth", "dhi", "dni", "dni_extra", "solar_zenith", "solar_azimuth", "elif", "model", "reindl", "sky", "reindl", "surface_tilt", "surface_azimuth", "dhi", "dni", "ghi", "dni_extra", "solar_zenith", "solar_azimuth", "elif", "model", "king", "sky", "king", "surface_tilt", "dhi", "ghi", "solar_zenith", "elif", "model", "perez", "if", "airmass", "is", "none", "airmass", "atmosphere", "get_relative_airmass", "solar_zenith", "sky", "perez", "surface_tilt", "surface_azimuth", "dhi", "dni", "dni_extra", "solar_zenith", "solar_azimuth", "airmass", "model", "model_perez", "else", "raise", "valueerror", "f", "invalid", "model", "selection", "model", "return", "sky"], "doc_len": 329}
{"doc_id": "pvlib/irradiance.py::poa_components", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "poa_components", "text": "文件路径: pvlib/irradiance.py\ndef poa_components(aoi, dni, poa_sky_diffuse, poa_ground_diffuse):\n    r'''\n    Determine in-plane irradiance components.\n\n    Combines DNI with sky diffuse and ground-reflected irradiance to calculate\n    total, direct and diffuse irradiance components in the plane of array.\n\n    Parameters\n    ----------\n    aoi : numeric\n        Angle of incidence of solar rays with respect to the module\n        surface, from :func:`aoi`.\n\n    dni : numeric\n        Direct normal irradiance (W/m^2), as measured from a TMY file or\n        calculated with a clearsky model.\n\n    poa_sky_diffuse : numeric\n        Diffuse irradiance (W/m^2) in the plane of the modules, as\n        calculated by a diffuse irradiance translation function\n\n    poa_ground_diffuse : numeric\n        Ground reflected irradiance (W/m^2) in the plane of the modules,\n        as calculated by an albedo model (eg. :func:`grounddiffuse`)\n\n    Returns\n    -------\n    irrads : OrderedDict or DataFrame\n        Contains the following keys:\n\n        * ``poa_global`` : Total in-plane irradiance (W/m^2)\n        * ``poa_direct`` : Total in-plane beam irradiance (W/m^2)\n        * ``poa_diffuse`` : Total in-plane diffuse irradiance (W/m^2)\n        * ``poa_sky_diffuse`` : In-plane diffuse irradiance from sky (W/m^2)\n        * ``poa_ground_diffuse`` : In-plane diffuse irradiance from ground\n          (W/m^2)\n\n    Notes\n    ------\n    Negative beam irradiation due to aoi :math:`> 90^{\\circ}` or AOI\n    :math:`< 0^{\\circ}` is set to zero.\n    '''\n\n    poa_direct = np.maximum(dni * np.cos(np.radians(aoi)), 0)\n    poa_diffuse = poa_sky_diffuse + poa_ground_diffuse\n    poa_global = poa_direct + poa_diffuse\n\n    irrads = OrderedDict()\n    irrads['poa_global'] = poa_global\n    irrads['poa_direct'] = poa_direct\n    irrads['poa_diffuse'] = poa_diffuse\n    irrads['poa_sky_diffuse'] = poa_sky_diffuse\n    irrads['poa_ground_diffuse'] = poa_ground_diffuse\n\n    if isinstance(poa_direct, pd.Series):\n        irrads = pd.DataFrame(irrads)\n\n    return irrads\n", "tokens": ["pvlib", "irradiance", "py", "def", "poa_components", "aoi", "dni", "poa_sky_diffuse", "poa_ground_diffuse", "r", "determine", "in", "plane", "irradiance", "components", "combines", "dni", "with", "sky", "diffuse", "and", "ground", "reflected", "irradiance", "to", "calculate", "total", "direct", "and", "diffuse", "irradiance", "components", "in", "the", "plane", "of", "array", "parameters", "aoi", "numeric", "angle", "of", "incidence", "of", "solar", "rays", "with", "respect", "to", "the", "module", "surface", "from", "func", "aoi", "dni", "numeric", "direct", "normal", "irradiance", "w", "m", "2", "as", "measured", "from", "a", "tmy", "file", "or", "calculated", "with", "a", "clearsky", "model", "poa_sky_diffuse", "numeric", "diffuse", "irradiance", "w", "m", "2", "in", "the", "plane", "of", "the", "modules", "as", "calculated", "by", "a", "diffuse", "irradiance", "translation", "function", "poa_ground_diffuse", "numeric", "ground", "reflected", "irradiance", "w", "m", "2", "in", "the", "plane", "of", "the", "modules", "as", "calculated", "by", "an", "albedo", "model", "eg", "func", "grounddiffuse", "returns", "irrads", "ordereddict", "or", "dataframe", "contains", "the", "following", "keys", "poa_global", "total", "in", "plane", "irradiance", "w", "m", "2", "poa_direct", "total", "in", "plane", "beam", "irradiance", "w", "m", "2", "poa_diffuse", "total", "in", "plane", "diffuse", "irradiance", "w", "m", "2", "poa_sky_diffuse", "in", "plane", "diffuse", "irradiance", "from", "sky", "w", "m", "2", "poa_ground_diffuse", "in", "plane", "diffuse", "irradiance", "from", "ground", "w", "m", "2", "notes", "negative", "beam", "irradiation", "due", "to", "aoi", "math", "90", "circ", "or", "aoi", "math", "0", "circ", "is", "set", "to", "zero", "poa_direct", "np", "maximum", "dni", "np", "cos", "np", "radians", "aoi", "0", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "poa_global", "poa_direct", "poa_diffuse", "irrads", "ordereddict", "irrads", "poa_global", "poa_global", "irrads", "poa_direct", "poa_direct", "irrads", "poa_diffuse", "poa_diffuse", "irrads", "poa_sky_diffuse", "poa_sky_diffuse", "irrads", "poa_ground_diffuse", "poa_ground_diffuse", "if", "isinstance", "poa_direct", "pd", "series", "irrads", "pd", "dataframe", "irrads", "return", "irrads"], "doc_len": 237}
{"doc_id": "pvlib/irradiance.py::get_ground_diffuse", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "get_ground_diffuse", "text": "文件路径: pvlib/irradiance.py\ndef get_ground_diffuse(surface_tilt, ghi, albedo=.25, surface_type=None):\n    '''\n    Estimate diffuse irradiance from ground reflections given\n    irradiance, albedo, and surface tilt.\n\n    Function to determine the portion of irradiance on a tilted surface\n    due to ground reflections. Any of the inputs may be DataFrames or\n    scalars.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. Tilt must be >=0 and\n        <=180. The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90).\n\n    ghi : numeric\n        Global horizontal irradiance. [W/m^2]\n\n    albedo : numeric, default 0.25\n        Ground reflectance, typically 0.1-0.4 for surfaces on Earth\n        (land), may increase over snow, ice, etc. May also be known as\n        the reflection coefficient. Must be >=0 and <=1. Will be\n        overridden if surface_type is supplied.\n\n    surface_type: None or string, default None\n        If not None, overrides albedo. String can be one of 'urban',\n        'grass', 'fresh grass', 'snow', 'fresh snow', 'asphalt', 'concrete',\n        'aluminum', 'copper', 'fresh steel', 'dirty steel', 'sea'.\n\n    Returns\n    -------\n    grounddiffuse : numeric\n        Ground reflected irradiance. [W/m^2]\n\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to compute\n       solar irradiance on inclined surfaces for building energy simulation\"\n       2007, Solar Energy vol. 81. pp. 254-267.\n\n    The calculation is the last term of equations 3, 4, 7, 8, 10, 11, and 12.\n\n    .. [2] albedos from:\n       http://files.pvsyst.com/help/albedo.htm\n       and\n       http://en.wikipedia.org/wiki/Albedo\n       and\n       https://doi.org/10.1175/1520-0469(1972)029<0959:AOTSS>2.0.CO;2\n    '''\n\n    if surface_type is not None:\n        albedo = SURFACE_ALBEDOS[surface_type]\n\n    diffuse_irrad = ghi * albedo * (1 - np.cos(np.radians(surface_tilt))) * 0.5\n\n    try:\n        diffuse_irrad.name = 'diffuse_ground'\n    except AttributeError:\n        pass\n\n    return diffuse_irrad\n", "tokens": ["pvlib", "irradiance", "py", "def", "get_ground_diffuse", "surface_tilt", "ghi", "albedo", "25", "surface_type", "none", "estimate", "diffuse", "irradiance", "from", "ground", "reflections", "given", "irradiance", "albedo", "and", "surface", "tilt", "function", "to", "determine", "the", "portion", "of", "irradiance", "on", "a", "tilted", "surface", "due", "to", "ground", "reflections", "any", "of", "the", "inputs", "may", "be", "dataframes", "or", "scalars", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "tilt", "must", "be", "0", "and", "180", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "ghi", "numeric", "global", "horizontal", "irradiance", "w", "m", "2", "albedo", "numeric", "default", "0", "25", "ground", "reflectance", "typically", "0", "1", "0", "4", "for", "surfaces", "on", "earth", "land", "may", "increase", "over", "snow", "ice", "etc", "may", "also", "be", "known", "as", "the", "reflection", "coefficient", "must", "be", "0", "and", "1", "will", "be", "overridden", "if", "surface_type", "is", "supplied", "surface_type", "none", "or", "string", "default", "none", "if", "not", "none", "overrides", "albedo", "string", "can", "be", "one", "of", "urban", "grass", "fresh", "grass", "snow", "fresh", "snow", "asphalt", "concrete", "aluminum", "copper", "fresh", "steel", "dirty", "steel", "sea", "returns", "grounddiffuse", "numeric", "ground", "reflected", "irradiance", "w", "m", "2", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "the", "calculation", "is", "the", "last", "term", "of", "equations", "3", "4", "7", "8", "10", "11", "and", "12", "2", "albedos", "from", "http", "files", "pvsyst", "com", "help", "albedo", "htm", "and", "http", "en", "wikipedia", "org", "wiki", "albedo", "and", "https", "doi", "org", "10", "1175", "1520", "0469", "1972", "029", "0959", "aotss", "2", "0", "co", "2", "if", "surface_type", "is", "not", "none", "albedo", "surface_albedos", "surface_type", "diffuse_irrad", "ghi", "albedo", "1", "np", "cos", "np", "radians", "surface_tilt", "0", "5", "try", "diffuse_irrad", "name", "diffuse_ground", "except", "attributeerror", "pass", "return", "diffuse_irrad"], "doc_len": 280}
{"doc_id": "pvlib/irradiance.py::isotropic", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "isotropic", "text": "文件路径: pvlib/irradiance.py\ndef isotropic(surface_tilt, dhi):\n    r'''\n    Determine diffuse irradiance from the sky on a tilted surface using\n    the isotropic sky model.\n\n    .. math::\n\n       I_{d} = DHI \\frac{1 + \\cos\\beta}{2}\n\n    Hottel and Woertz's model treats the sky as a uniform source of\n    diffuse irradiance. Thus the diffuse irradiance from the sky (ground\n    reflected irradiance is not included in this algorithm) on a tilted\n    surface can be found from the diffuse horizontal irradiance and the\n    tilt angle of the surface.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angle in decimal degrees. Tilt must be >=0 and\n        <=180. The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90)\n\n    dhi : numeric\n        Diffuse horizontal irradiance in W/m^2. DHI must be >=0.\n\n    Returns\n    -------\n    diffuse : numeric\n        The sky diffuse component of the solar radiation.\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to\n       compute solar irradiance on inclined surfaces for building energy\n       simulation\" 2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Hottel, H.C., Woertz, B.B., 1942. Evaluation of flat-plate solar\n       heat collector. Trans. ASME 64, 91.\n    '''\n\n    sky_diffuse = dhi * (1 + tools.cosd(surface_tilt)) * 0.5\n\n    return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "isotropic", "surface_tilt", "dhi", "r", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "the", "isotropic", "sky", "model", "math", "i_", "d", "dhi", "frac", "1", "cos", "beta", "2", "hottel", "and", "woertz", "s", "model", "treats", "the", "sky", "as", "a", "uniform", "source", "of", "diffuse", "irradiance", "thus", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "can", "be", "found", "from", "the", "diffuse", "horizontal", "irradiance", "and", "the", "tilt", "angle", "of", "the", "surface", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "decimal", "degrees", "tilt", "must", "be", "0", "and", "180", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "dhi", "must", "be", "0", "returns", "diffuse", "numeric", "the", "sky", "diffuse", "component", "of", "the", "solar", "radiation", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "hottel", "h", "c", "woertz", "b", "b", "1942", "evaluation", "of", "flat", "plate", "solar", "heat", "collector", "trans", "asme", "64", "91", "sky_diffuse", "dhi", "1", "tools", "cosd", "surface_tilt", "0", "5", "return", "sky_diffuse"], "doc_len": 199}
{"doc_id": "pvlib/irradiance.py::klucher", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "klucher", "text": "文件路径: pvlib/irradiance.py\ndef klucher(surface_tilt, surface_azimuth, dhi, ghi, solar_zenith,\n            solar_azimuth):\n    r'''\n    Determine diffuse irradiance from the sky on a tilted surface\n    using Klucher's 1979 model\n\n    .. math::\n\n       I_{d} = DHI \\frac{1 + \\cos\\beta}{2} (1 + F' \\sin^3(\\beta/2))\n       (1 + F' \\cos^2\\theta\\sin^3\\theta_z)\n\n    where\n\n    .. math::\n\n       F' = 1 - (I_{d0} / GHI)^2\n\n    Klucher's 1979 model determines the diffuse irradiance from the sky\n    (ground reflected irradiance is not included in this algorithm) on a\n    tilted surface using the surface tilt angle, surface azimuth angle,\n    diffuse horizontal irradiance, direct normal irradiance, global\n    horizontal irradiance, extraterrestrial irradiance, sun zenith\n    angle, and sun azimuth angle.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. surface_tilt must be >=0\n        and <=180. The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90)\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees. surface_azimuth must\n        be >=0 and <=360. The Azimuth convention is defined as degrees\n        east of north (e.g. North = 0, South=180 East = 90, West = 270).\n\n    dhi : numeric\n        Diffuse horizontal irradiance in W/m^2. DHI must be >=0.\n\n    ghi : numeric\n        Global irradiance in W/m^2. DNI must be >=0.\n\n    solar_zenith : numeric\n        Apparent (refraction-corrected) zenith angles in decimal\n        degrees. solar_zenith must be >=0 and <=180.\n\n    solar_azimuth : numeric\n        Sun azimuth angles in decimal degrees. solar_azimuth must be >=0\n        and <=360. The Azimuth convention is defined as degrees east of\n        north (e.g. North = 0, East = 90, West = 270).\n\n    Returns\n    -------\n    diffuse : numeric\n        The sky diffuse component of the solar radiation.\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to compute\n       solar irradiance on inclined surfaces for building energy simulation\"\n       2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Klucher, T.M., 1979. Evaluation of models to predict insolation on\n       tilted surfaces. Solar Energy 23 (2), 111-114.\n    '''\n\n    # zenith angle with respect to panel normal.\n    cos_tt = aoi_projection(surface_tilt, surface_azimuth,\n                            solar_zenith, solar_azimuth)\n    cos_tt = np.maximum(cos_tt, 0)  # GH 526\n\n    # silence warning from 0 / 0\n    with np.errstate(invalid='ignore'):\n        F = 1 - ((dhi / ghi) ** 2)\n\n    try:\n        # fails with single point input\n        F.fillna(0, inplace=True)\n    except AttributeError:\n        F = np.where(np.isnan(F), 0, F)\n\n    term1 = 0.5 * (1 + tools.cosd(surface_tilt))\n    term2 = 1 + F * (tools.sind(0.5 * surface_tilt) ** 3)\n    term3 = 1 + F * (cos_tt ** 2) * (tools.sind(solar_zenith) ** 3)\n\n    sky_diffuse = dhi * term1 * term2 * term3\n\n    return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "klucher", "surface_tilt", "surface_azimuth", "dhi", "ghi", "solar_zenith", "solar_azimuth", "r", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "klucher", "s", "1979", "model", "math", "i_", "d", "dhi", "frac", "1", "cos", "beta", "2", "1", "f", "sin", "3", "beta", "2", "1", "f", "cos", "2", "theta", "sin", "3", "theta_z", "where", "math", "f", "1", "i_", "d0", "ghi", "2", "klucher", "s", "1979", "model", "determines", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "using", "the", "surface", "tilt", "angle", "surface", "azimuth", "angle", "diffuse", "horizontal", "irradiance", "direct", "normal", "irradiance", "global", "horizontal", "irradiance", "extraterrestrial", "irradiance", "sun", "zenith", "angle", "and", "sun", "azimuth", "angle", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "surface_tilt", "must", "be", "0", "and", "180", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "surface_azimuth", "must", "be", "0", "and", "360", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "dhi", "must", "be", "0", "ghi", "numeric", "global", "irradiance", "in", "w", "m", "2", "dni", "must", "be", "0", "solar_zenith", "numeric", "apparent", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "solar_zenith", "must", "be", "0", "and", "180", "solar_azimuth", "numeric", "sun", "azimuth", "angles", "in", "decimal", "degrees", "solar_azimuth", "must", "be", "0", "and", "360", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "east", "90", "west", "270", "returns", "diffuse", "numeric", "the", "sky", "diffuse", "component", "of", "the", "solar", "radiation", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "klucher", "t", "m", "1979", "evaluation", "of", "models", "to", "predict", "insolation", "on", "tilted", "surfaces", "solar", "energy", "23", "2", "111", "114", "zenith", "angle", "with", "respect", "to", "panel", "normal", "cos_tt", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "cos_tt", "np", "maximum", "cos_tt", "0", "gh", "526", "silence", "warning", "from", "0", "0", "with", "np", "errstate", "invalid", "ignore", "f", "1", "dhi", "ghi", "2", "try", "fails", "with", "single", "point", "input", "f", "fillna", "0", "inplace", "true", "except", "attributeerror", "f", "np", "where", "np", "isnan", "f", "0", "f", "term1", "0", "5", "1", "tools", "cosd", "surface_tilt", "term2", "1", "f", "tools", "sind", "0", "5", "surface_tilt", "3", "term3", "1", "f", "cos_tt", "2", "tools", "sind", "solar_zenith", "3", "sky_diffuse", "dhi", "term1", "term2", "term3", "return", "sky_diffuse"], "doc_len": 398}
{"doc_id": "pvlib/irradiance.py::haydavies", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "haydavies", "text": "文件路径: pvlib/irradiance.py\ndef haydavies(surface_tilt, surface_azimuth, dhi, dni, dni_extra,\n              solar_zenith=None, solar_azimuth=None, projection_ratio=None,\n              return_components=False):\n    r'''\n    Determine diffuse irradiance from the sky on a tilted surface using\n    Hay & Davies' 1980 model\n\n    .. math::\n        I_{d} = DHI ( A R_b + (1 - A) (\\frac{1 + \\cos\\beta}{2}) )\n\n    Hay and Davies' 1980 model determines the diffuse irradiance from\n    the sky (ground reflected irradiance is not included in this\n    algorithm) on a tilted surface using the surface tilt angle, surface\n    azimuth angle, diffuse horizontal irradiance, direct normal\n    irradiance, extraterrestrial irradiance, sun zenith angle, and sun\n    azimuth angle.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. The tilt angle is\n        defined as degrees from horizontal (e.g. surface facing up = 0,\n        surface facing horizon = 90)\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees. The azimuth\n        convention is defined as degrees east of north (e.g. North=0,\n        South=180, East=90, West=270).\n\n    dhi : numeric\n        Diffuse horizontal irradiance in W/m^2.\n\n    dni : numeric\n        Direct normal irradiance in W/m^2.\n\n    dni_extra : numeric\n        Extraterrestrial normal irradiance in W/m^2.\n\n    solar_zenith : None or numeric, default None\n        Solar apparent (refraction-corrected) zenith angles in decimal\n        degrees. Must supply ``solar_zenith`` and ``solar_azimuth`` or\n        supply ``projection_ratio``.\n\n    solar_azimuth : None or numeric, default None\n        Solar azimuth angles in decimal degrees. Must supply\n        ``solar_zenith`` and ``solar_azimuth`` or supply\n        ``projection_ratio``.\n\n    projection_ratio : None or numeric, default None\n        Ratio of angle of incidence projection to solar zenith angle\n        projection. Must supply ``solar_zenith`` and ``solar_azimuth``\n        or supply ``projection_ratio``.\n\n    return_components : bool, default False\n        Flag used to decide whether to return the calculated diffuse components\n        or not.\n\n    Returns\n    --------\n    numeric, OrderedDict, or DataFrame\n        Return type controlled by `return_components` argument.\n        If ``return_components=False``, `sky_diffuse` is returned.\n        If ``return_components=True``, `diffuse_components` is returned.\n\n    sky_diffuse : numeric\n        The sky diffuse component of the solar radiation on a tilted\n        surface.\n\n    diffuse_components : OrderedDict (array input) or DataFrame (Series input)\n        Keys/columns are:\n            * sky_diffuse: Total sky diffuse\n            * isotropic\n            * circumsolar\n            * horizon\n\n    Notes\n    ------\n    When supplying ``projection_ratio``, consider constraining its values\n    when zenith angle approaches 90 degrees or angle of incidence\n    projection is negative. See code for details.\n\n    References\n    -----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to\n       compute solar irradiance on inclined surfaces for building energy\n       simulation\" 2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Hay, J.E., Davies, J.A., 1980. Calculations of the solar\n       radiation incident on an inclined surface. In: Hay, J.E., Won, T.K.\n       (Eds.), Proc. of First Canadian Solar Radiation Data Workshop, 59.\n       Ministry of Supply and Services, Canada.\n    '''\n\n    # if necessary, calculate ratio of titled and horizontal beam irradiance\n    if projection_ratio is None:\n        cos_tt = aoi_projection(surface_tilt, surface_azimuth,\n                                solar_zenith, solar_azimuth)\n        cos_tt = np.maximum(cos_tt, 0)  # GH 526\n        cos_solar_zenith = tools.cosd(solar_zenith)\n        Rb = cos_tt / np.maximum(cos_solar_zenith, 0.01745)  # GH 432\n    else:\n        Rb = projection_ratio\n\n    # Anisotropy Index\n    AI = dni / dni_extra\n\n    # these are the () and [] sub-terms of the second term of eqn 7\n    term1 = 1 - AI\n    term2 = 0.5 * (1 + tools.cosd(surface_tilt))\n\n    poa_isotropic = np.maximum(dhi * term1 * term2, 0)\n    poa_circumsolar = np.maximum(dhi * (AI * Rb), 0)\n    sky_diffuse = poa_isotropic + poa_circumsolar\n\n    if return_components:\n        diffuse_components = OrderedDict()\n        diffuse_components['sky_diffuse'] = sky_diffuse\n\n        # Calculate the individual components\n        diffuse_components['isotropic'] = poa_isotropic\n        diffuse_components['circumsolar'] = poa_circumsolar\n        diffuse_components['horizon'] = np.where(\n            np.isnan(diffuse_components['isotropic']), np.nan, 0.)\n\n        if isinstance(sky_diffuse, pd.Series):\n            diffuse_components = pd.DataFrame(diffuse_components)\n        return diffuse_components\n    else:\n        return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "haydavies", "surface_tilt", "surface_azimuth", "dhi", "dni", "dni_extra", "solar_zenith", "none", "solar_azimuth", "none", "projection_ratio", "none", "return_components", "false", "r", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "hay", "davies", "1980", "model", "math", "i_", "d", "dhi", "a", "r_b", "1", "a", "frac", "1", "cos", "beta", "2", "hay", "and", "davies", "1980", "model", "determines", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "using", "the", "surface", "tilt", "angle", "surface", "azimuth", "angle", "diffuse", "horizontal", "irradiance", "direct", "normal", "irradiance", "extraterrestrial", "irradiance", "sun", "zenith", "angle", "and", "sun", "azimuth", "angle", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "dni", "numeric", "direct", "normal", "irradiance", "in", "w", "m", "2", "dni_extra", "numeric", "extraterrestrial", "normal", "irradiance", "in", "w", "m", "2", "solar_zenith", "none", "or", "numeric", "default", "none", "solar", "apparent", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "must", "supply", "solar_zenith", "and", "solar_azimuth", "or", "supply", "projection_ratio", "solar_azimuth", "none", "or", "numeric", "default", "none", "solar", "azimuth", "angles", "in", "decimal", "degrees", "must", "supply", "solar_zenith", "and", "solar_azimuth", "or", "supply", "projection_ratio", "projection_ratio", "none", "or", "numeric", "default", "none", "ratio", "of", "angle", "of", "incidence", "projection", "to", "solar", "zenith", "angle", "projection", "must", "supply", "solar_zenith", "and", "solar_azimuth", "or", "supply", "projection_ratio", "return_components", "bool", "default", "false", "flag", "used", "to", "decide", "whether", "to", "return", "the", "calculated", "diffuse", "components", "or", "not", "returns", "numeric", "ordereddict", "or", "dataframe", "return", "type", "controlled", "by", "return_components", "argument", "if", "return_components", "false", "sky_diffuse", "is", "returned", "if", "return_components", "true", "diffuse_components", "is", "returned", "sky_diffuse", "numeric", "the", "sky", "diffuse", "component", "of", "the", "solar", "radiation", "on", "a", "tilted", "surface", "diffuse_components", "ordereddict", "array", "input", "or", "dataframe", "series", "input", "keys", "columns", "are", "sky_diffuse", "total", "sky", "diffuse", "isotropic", "circumsolar", "horizon", "notes", "when", "supplying", "projection_ratio", "consider", "constraining", "its", "values", "when", "zenith", "angle", "approaches", "90", "degrees", "or", "angle", "of", "incidence", "projection", "is", "negative", "see", "code", "for", "details", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "hay", "j", "e", "davies", "j", "a", "1980", "calculations", "of", "the", "solar", "radiation", "incident", "on", "an", "inclined", "surface", "in", "hay", "j", "e", "won", "t", "k", "eds", "proc", "of", "first", "canadian", "solar", "radiation", "data", "workshop", "59", "ministry", "of", "supply", "and", "services", "canada", "if", "necessary", "calculate", "ratio", "of", "titled", "and", "horizontal", "beam", "irradiance", "if", "projection_ratio", "is", "none", "cos_tt", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "cos_tt", "np", "maximum", "cos_tt", "0", "gh", "526", "cos_solar_zenith", "tools", "cosd", "solar_zenith", "rb", "cos_tt", "np", "maximum", "cos_solar_zenith", "0", "01745", "gh", "432", "else", "rb", "projection_ratio", "anisotropy", "index", "ai", "dni", "dni_extra", "these", "are", "the", "and", "sub", "terms", "of", "the", "second", "term", "of", "eqn", "7", "term1", "1", "ai", "term2", "0", "5", "1", "tools", "cosd", "surface_tilt", "poa_isotropic", "np", "maximum", "dhi", "term1", "term2", "0", "poa_circumsolar", "np", "maximum", "dhi", "ai", "rb", "0", "sky_diffuse", "poa_isotropic", "poa_circumsolar", "if", "return_components", "diffuse_components", "ordereddict", "diffuse_components", "sky_diffuse", "sky_diffuse", "calculate", "the", "individual", "components", "diffuse_components", "isotropic", "poa_isotropic", "diffuse_components", "circumsolar", "poa_circumsolar", "diffuse_components", "horizon", "np", "where", "np", "isnan", "diffuse_components", "isotropic", "np", "nan", "0", "if", "isinstance", "sky_diffuse", "pd", "series", "diffuse_components", "pd", "dataframe", "diffuse_components", "return", "diffuse_components", "else", "return", "sky_diffuse"], "doc_len": 544}
{"doc_id": "pvlib/irradiance.py::reindl", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "reindl", "text": "文件路径: pvlib/irradiance.py\ndef reindl(surface_tilt, surface_azimuth, dhi, dni, ghi, dni_extra,\n           solar_zenith, solar_azimuth):\n    r'''\n    Determine diffuse irradiance from the sky on a tilted surface using\n    Reindl's 1990 model\n\n    .. math::\n\n       I_{d} = DHI (A R_b + (1 - A) (\\frac{1 + \\cos\\beta}{2})\n       (1 + \\sqrt{\\frac{I_{hb}}{I_h}} \\sin^3(\\beta/2)) )\n\n    Reindl's 1990 model determines the diffuse irradiance from the sky\n    (ground reflected irradiance is not included in this algorithm) on a\n    tilted surface using the surface tilt angle, surface azimuth angle,\n    diffuse horizontal irradiance, direct normal irradiance, global\n    horizontal irradiance, extraterrestrial irradiance, sun zenith\n    angle, and sun azimuth angle.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. The tilt angle is\n        defined as degrees from horizontal (e.g. surface facing up = 0,\n        surface facing horizon = 90)\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees. The azimuth\n        convention is defined as degrees east of north (e.g. North = 0,\n        South=180 East = 90, West = 270).\n\n    dhi : numeric\n        diffuse horizontal irradiance in W/m^2.\n\n    dni : numeric\n        direct normal irradiance in W/m^2.\n\n    ghi: numeric\n        Global irradiance in W/m^2.\n\n    dni_extra : numeric\n        Extraterrestrial normal irradiance in W/m^2.\n\n    solar_zenith : numeric\n        Apparent (refraction-corrected) zenith angles in decimal degrees.\n\n    solar_azimuth : numeric\n        Sun azimuth angles in decimal degrees. The azimuth convention is\n        defined as degrees east of north (e.g. North = 0, East = 90,\n        West = 270).\n\n    Returns\n    -------\n    poa_sky_diffuse : numeric\n        The sky diffuse component of the solar radiation.\n\n    Notes\n    -----\n    The poa_sky_diffuse calculation is generated from the Loutzenhiser et al.\n    (2007) paper, equation 8. Note that I have removed the beam and ground\n    reflectance portion of the equation and this generates ONLY the diffuse\n    radiation from the sky and circumsolar, so the form of the equation\n    varies slightly from equation 8.\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to\n       compute solar irradiance on inclined surfaces for building energy\n       simulation\" 2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Reindl, D.T., Beckmann, W.A., Duffie, J.A., 1990a. Diffuse\n       fraction correlations. Solar Energy 45(1), 1-7.\n\n    .. [3] Reindl, D.T., Beckmann, W.A., Duffie, J.A., 1990b. Evaluation of\n       hourly tilted surface radiation models. Solar Energy 45(1), 9-17.\n    '''\n\n    cos_tt = aoi_projection(surface_tilt, surface_azimuth,\n                            solar_zenith, solar_azimuth)\n    cos_tt = np.maximum(cos_tt, 0)  # GH 526\n\n    # do not apply cos(zen) limit here (needed for HB below)\n    cos_solar_zenith = tools.cosd(solar_zenith)\n\n    # ratio of titled and horizontal beam irradiance\n    Rb = cos_tt / np.maximum(cos_solar_zenith, 0.01745)  # GH 432\n\n    # Anisotropy Index\n    AI = dni / dni_extra\n\n    # DNI projected onto horizontal\n    HB = dni * cos_solar_zenith\n    HB = np.maximum(HB, 0)\n\n    # these are the () and [] sub-terms of the second term of eqn 8\n    term1 = 1 - AI\n    term2 = 0.5 * (1 + tools.cosd(surface_tilt))\n    with np.errstate(invalid='ignore', divide='ignore'):\n        hb_to_ghi = np.where(ghi == 0, 0, np.divide(HB, ghi))\n    term3 = 1 + np.sqrt(hb_to_ghi) * (tools.sind(0.5 * surface_tilt)**3)\n    sky_diffuse = dhi * (AI * Rb + term1 * term2 * term3)\n    sky_diffuse = np.maximum(sky_diffuse, 0)\n\n    return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "reindl", "surface_tilt", "surface_azimuth", "dhi", "dni", "ghi", "dni_extra", "solar_zenith", "solar_azimuth", "r", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "reindl", "s", "1990", "model", "math", "i_", "d", "dhi", "a", "r_b", "1", "a", "frac", "1", "cos", "beta", "2", "1", "sqrt", "frac", "i_", "hb", "i_h", "sin", "3", "beta", "2", "reindl", "s", "1990", "model", "determines", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "using", "the", "surface", "tilt", "angle", "surface", "azimuth", "angle", "diffuse", "horizontal", "irradiance", "direct", "normal", "irradiance", "global", "horizontal", "irradiance", "extraterrestrial", "irradiance", "sun", "zenith", "angle", "and", "sun", "azimuth", "angle", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "dni", "numeric", "direct", "normal", "irradiance", "in", "w", "m", "2", "ghi", "numeric", "global", "irradiance", "in", "w", "m", "2", "dni_extra", "numeric", "extraterrestrial", "normal", "irradiance", "in", "w", "m", "2", "solar_zenith", "numeric", "apparent", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "solar_azimuth", "numeric", "sun", "azimuth", "angles", "in", "decimal", "degrees", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "east", "90", "west", "270", "returns", "poa_sky_diffuse", "numeric", "the", "sky", "diffuse", "component", "of", "the", "solar", "radiation", "notes", "the", "poa_sky_diffuse", "calculation", "is", "generated", "from", "the", "loutzenhiser", "et", "al", "2007", "paper", "equation", "8", "note", "that", "i", "have", "removed", "the", "beam", "and", "ground", "reflectance", "portion", "of", "the", "equation", "and", "this", "generates", "only", "the", "diffuse", "radiation", "from", "the", "sky", "and", "circumsolar", "so", "the", "form", "of", "the", "equation", "varies", "slightly", "from", "equation", "8", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "reindl", "d", "t", "beckmann", "w", "a", "duffie", "j", "a", "1990a", "diffuse", "fraction", "correlations", "solar", "energy", "45", "1", "1", "7", "3", "reindl", "d", "t", "beckmann", "w", "a", "duffie", "j", "a", "1990b", "evaluation", "of", "hourly", "tilted", "surface", "radiation", "models", "solar", "energy", "45", "1", "9", "17", "cos_tt", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "cos_tt", "np", "maximum", "cos_tt", "0", "gh", "526", "do", "not", "apply", "cos", "zen", "limit", "here", "needed", "for", "hb", "below", "cos_solar_zenith", "tools", "cosd", "solar_zenith", "ratio", "of", "titled", "and", "horizontal", "beam", "irradiance", "rb", "cos_tt", "np", "maximum", "cos_solar_zenith", "0", "01745", "gh", "432", "anisotropy", "index", "ai", "dni", "dni_extra", "dni", "projected", "onto", "horizontal", "hb", "dni", "cos_solar_zenith", "hb", "np", "maximum", "hb", "0", "these", "are", "the", "and", "sub", "terms", "of", "the", "second", "term", "of", "eqn", "8", "term1", "1", "ai", "term2", "0", "5", "1", "tools", "cosd", "surface_tilt", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "hb_to_ghi", "np", "where", "ghi", "0", "0", "np", "divide", "hb", "ghi", "term3", "1", "np", "sqrt", "hb_to_ghi", "tools", "sind", "0", "5", "surface_tilt", "3", "sky_diffuse", "dhi", "ai", "rb", "term1", "term2", "term3", "sky_diffuse", "np", "maximum", "sky_diffuse", "0", "return", "sky_diffuse"], "doc_len": 492}
{"doc_id": "pvlib/irradiance.py::king", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "king", "text": "文件路径: pvlib/irradiance.py\ndef king(surface_tilt, dhi, ghi, solar_zenith):\n    '''\n    Determine diffuse irradiance from the sky on a tilted surface using\n    the King model.\n\n    King's model determines the diffuse irradiance from the sky (ground\n    reflected irradiance is not included in this algorithm) on a tilted\n    surface using the surface tilt angle, diffuse horizontal irradiance,\n    global horizontal irradiance, and sun zenith angle. Note that this\n    model is not well documented and has not been published in any\n    fashion (as of January 2012).\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. The tilt angle is\n        defined as degrees from horizontal (e.g. surface facing up = 0,\n        surface facing horizon = 90)\n\n    dhi : numeric\n        Diffuse horizontal irradiance in W/m^2.\n\n    ghi : numeric\n        Global horizontal irradiance in W/m^2.\n\n    solar_zenith : numeric\n        Apparent (refraction-corrected) zenith angles in decimal degrees.\n\n    Returns\n    --------\n    poa_sky_diffuse : numeric\n        The diffuse component of the solar radiation.\n    '''\n\n    sky_diffuse = (dhi * (1 + tools.cosd(surface_tilt)) / 2 + ghi *\n                   (0.012 * solar_zenith - 0.04) *\n                   (1 - tools.cosd(surface_tilt)) / 2)\n    sky_diffuse = np.maximum(sky_diffuse, 0)\n\n    return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "king", "surface_tilt", "dhi", "ghi", "solar_zenith", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "the", "king", "model", "king", "s", "model", "determines", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "using", "the", "surface", "tilt", "angle", "diffuse", "horizontal", "irradiance", "global", "horizontal", "irradiance", "and", "sun", "zenith", "angle", "note", "that", "this", "model", "is", "not", "well", "documented", "and", "has", "not", "been", "published", "in", "any", "fashion", "as", "of", "january", "2012", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "ghi", "numeric", "global", "horizontal", "irradiance", "in", "w", "m", "2", "solar_zenith", "numeric", "apparent", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "returns", "poa_sky_diffuse", "numeric", "the", "diffuse", "component", "of", "the", "solar", "radiation", "sky_diffuse", "dhi", "1", "tools", "cosd", "surface_tilt", "2", "ghi", "0", "012", "solar_zenith", "0", "04", "1", "tools", "cosd", "surface_tilt", "2", "sky_diffuse", "np", "maximum", "sky_diffuse", "0", "return", "sky_diffuse"], "doc_len": 172}
{"doc_id": "pvlib/irradiance.py::perez", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "perez", "text": "文件路径: pvlib/irradiance.py\ndef perez(surface_tilt, surface_azimuth, dhi, dni, dni_extra,\n          solar_zenith, solar_azimuth, airmass,\n          model='allsitescomposite1990', return_components=False):\n    '''\n    Determine diffuse irradiance from the sky on a tilted surface using\n    one of the Perez models.\n\n    Perez models determine the diffuse irradiance from the sky (ground\n    reflected irradiance is not included in this algorithm) on a tilted\n    surface using the surface tilt angle, surface azimuth angle, diffuse\n    horizontal irradiance, direct normal irradiance, extraterrestrial\n    irradiance, sun zenith angle, sun azimuth angle, and relative (not\n    pressure-corrected) airmass. Optionally a selector may be used to\n    use any of Perez's model coefficient sets.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. surface_tilt must be >=0\n        and <=180. The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90)\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees. surface_azimuth must\n        be >=0 and <=360. The azimuth convention is defined as degrees\n        east of north (e.g. North = 0, South=180 East = 90, West = 270).\n\n    dhi : numeric\n        Diffuse horizontal irradiance in W/m^2. DHI must be >=0.\n\n    dni : numeric\n        Direct normal irradiance in W/m^2. DNI must be >=0.\n\n    dni_extra : numeric\n        Extraterrestrial normal irradiance in W/m^2.\n\n    solar_zenith : numeric\n        apparent (refraction-corrected) zenith angles in decimal\n        degrees. solar_zenith must be >=0 and <=180.\n\n    solar_azimuth : numeric\n        Sun azimuth angles in decimal degrees. solar_azimuth must be >=0\n        and <=360. The azimuth convention is defined as degrees east of\n        north (e.g. North = 0, East = 90, West = 270).\n\n    airmass : numeric\n        Relative (not pressure-corrected) airmass values. If AM is a\n        DataFrame it must be of the same size as all other DataFrame\n        inputs. AM must be >=0 (careful using the 1/sec(z) model of AM\n        generation)\n\n    model : string (optional, default='allsitescomposite1990')\n        A string which selects the desired set of Perez coefficients. If\n        model is not provided as an input, the default, '1990' will be\n        used. All possible model selections are:\n\n        * '1990'\n        * 'allsitescomposite1990' (same as '1990')\n        * 'allsitescomposite1988'\n        * 'sandiacomposite1988'\n        * 'usacomposite1988'\n        * 'france1988'\n        * 'phoenix1988'\n        * 'elmonte1988'\n        * 'osage1988'\n        * 'albuquerque1988'\n        * 'capecanaveral1988'\n        * 'albany1988'\n\n    return_components: bool (optional, default=False)\n        Flag used to decide whether to return the calculated diffuse components\n        or not.\n\n    Returns\n    --------\n    numeric, OrderedDict, or DataFrame\n        Return type controlled by `return_components` argument.\n        If ``return_components=False``, `sky_diffuse` is returned.\n        If ``return_components=True``, `diffuse_components` is returned.\n\n    sky_diffuse : numeric\n        The sky diffuse component of the solar radiation on a tilted\n        surface.\n\n    diffuse_components : OrderedDict (array input) or DataFrame (Series input)\n        Keys/columns are:\n            * sky_diffuse: Total sky diffuse\n            * isotropic\n            * circumsolar\n            * horizon\n\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to\n       compute solar irradiance on inclined surfaces for building energy\n       simulation\" 2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Perez, R., Seals, R., Ineichen, P., Stewart, R., Menicucci, D.,\n       1987. A new simplified version of the Perez diffuse irradiance model\n       for tilted surfaces. Solar Energy 39(3), 221-232.\n\n    .. [3] Perez, R., Ineichen, P., Seals, R., Michalsky, J., Stewart, R.,\n       1990. Modeling daylight availability and irradiance components from\n       direct and global irradiance. Solar Energy 44 (5), 271-289.\n\n    .. [4] Perez, R. et. al 1988. \"The Development and Verification of the\n       Perez Diffuse Radiation Model\". SAND88-7030\n    '''\n\n    kappa = 1.041  # for solar_zenith in radians\n    z = np.radians(solar_zenith)  # convert to radians\n\n    # delta is the sky's \"brightness\"\n    delta = dhi * airmass / dni_extra\n\n    # epsilon is the sky's \"clearness\"\n    with np.errstate(invalid='ignore'):\n        eps = ((dhi + dni) / dhi + kappa * (z ** 3)) / (1 + kappa * (z ** 3))\n\n    # numpy indexing below will not work with a Series\n    if isinstance(eps, pd.Series):\n        eps = eps.values\n\n    # Perez et al define clearness bins according to the following\n    # rules. 1 = overcast ... 8 = clear (these names really only make\n    # sense for small zenith angles, but...) these values will\n    # eventually be used as indicies for coeffecient look ups\n    ebin = np.digitize(eps, (0., 1.065, 1.23, 1.5, 1.95, 2.8, 4.5, 6.2))\n    ebin = np.array(ebin)  # GH 642\n    ebin[np.isnan(eps)] = 0\n\n    # correct for 0 indexing in coeffecient lookup\n    # later, ebin = -1 will yield nan coefficients\n    ebin -= 1\n\n    # The various possible sets of Perez coefficients are contained\n    # in a subfunction to clean up the code.\n    F1c, F2c = _get_perez_coefficients(model)\n\n    # results in invalid eps (ebin = -1) being mapped to nans\n    nans = np.array([np.nan, np.nan, np.nan])\n    F1c = np.vstack((F1c, nans))\n    F2c = np.vstack((F2c, nans))\n\n    F1 = (F1c[ebin, 0] + F1c[ebin, 1] * delta + F1c[ebin, 2] * z)\n    F1 = np.maximum(F1, 0)\n\n    F2 = (F2c[ebin, 0] + F2c[ebin, 1] * delta + F2c[ebin, 2] * z)\n\n    A = aoi_projection(surface_tilt, surface_azimuth,\n                       solar_zenith, solar_azimuth)\n    A = np.maximum(A, 0)\n\n    B = tools.cosd(solar_zenith)\n    B = np.maximum(B, tools.cosd(85))\n\n    # Calculate Diffuse POA from sky dome\n    term1 = 0.5 * (1 - F1) * (1 + tools.cosd(surface_tilt))\n    term2 = F1 * A / B\n    term3 = F2 * tools.sind(surface_tilt)\n\n    sky_diffuse = np.maximum(dhi * (term1 + term2 + term3), 0)\n\n    # we've preserved the input type until now, so don't ruin it!\n    if isinstance(sky_diffuse, pd.Series):\n        sky_diffuse[np.isnan(airmass)] = 0\n    else:\n        sky_diffuse = np.where(np.isnan(airmass), 0, sky_diffuse)\n\n    if return_components:\n        diffuse_components = OrderedDict()\n        diffuse_components['sky_diffuse'] = sky_diffuse\n\n        # Calculate the different components\n        diffuse_components['isotropic'] = dhi * term1\n        diffuse_components['circumsolar'] = dhi * term2\n        diffuse_components['horizon'] = dhi * term3\n\n        # Set values of components to 0 when sky_diffuse is 0\n        mask = sky_diffuse == 0\n        if isinstance(sky_diffuse, pd.Series):\n            diffuse_components = pd.DataFrame(diffuse_components)\n            diffuse_components.loc[mask] = 0\n        else:\n            diffuse_components = {k: np.where(mask, 0, v) for k, v in\n                                  diffuse_components.items()}\n        return diffuse_components\n    else:\n        return sky_diffuse\n", "tokens": ["pvlib", "irradiance", "py", "def", "perez", "surface_tilt", "surface_azimuth", "dhi", "dni", "dni_extra", "solar_zenith", "solar_azimuth", "airmass", "model", "allsitescomposite1990", "return_components", "false", "determine", "diffuse", "irradiance", "from", "the", "sky", "on", "a", "tilted", "surface", "using", "one", "of", "the", "perez", "models", "perez", "models", "determine", "the", "diffuse", "irradiance", "from", "the", "sky", "ground", "reflected", "irradiance", "is", "not", "included", "in", "this", "algorithm", "on", "a", "tilted", "surface", "using", "the", "surface", "tilt", "angle", "surface", "azimuth", "angle", "diffuse", "horizontal", "irradiance", "direct", "normal", "irradiance", "extraterrestrial", "irradiance", "sun", "zenith", "angle", "sun", "azimuth", "angle", "and", "relative", "not", "pressure", "corrected", "airmass", "optionally", "a", "selector", "may", "be", "used", "to", "use", "any", "of", "perez", "s", "model", "coefficient", "sets", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "surface_tilt", "must", "be", "0", "and", "180", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "surface_azimuth", "must", "be", "0", "and", "360", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "dhi", "must", "be", "0", "dni", "numeric", "direct", "normal", "irradiance", "in", "w", "m", "2", "dni", "must", "be", "0", "dni_extra", "numeric", "extraterrestrial", "normal", "irradiance", "in", "w", "m", "2", "solar_zenith", "numeric", "apparent", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "solar_zenith", "must", "be", "0", "and", "180", "solar_azimuth", "numeric", "sun", "azimuth", "angles", "in", "decimal", "degrees", "solar_azimuth", "must", "be", "0", "and", "360", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "east", "90", "west", "270", "airmass", "numeric", "relative", "not", "pressure", "corrected", "airmass", "values", "if", "am", "is", "a", "dataframe", "it", "must", "be", "of", "the", "same", "size", "as", "all", "other", "dataframe", "inputs", "am", "must", "be", "0", "careful", "using", "the", "1", "sec", "z", "model", "of", "am", "generation", "model", "string", "optional", "default", "allsitescomposite1990", "a", "string", "which", "selects", "the", "desired", "set", "of", "perez", "coefficients", "if", "model", "is", "not", "provided", "as", "an", "input", "the", "default", "1990", "will", "be", "used", "all", "possible", "model", "selections", "are", "1990", "allsitescomposite1990", "same", "as", "1990", "allsitescomposite1988", "sandiacomposite1988", "usacomposite1988", "france1988", "phoenix1988", "elmonte1988", "osage1988", "albuquerque1988", "capecanaveral1988", "albany1988", "return_components", "bool", "optional", "default", "false", "flag", "used", "to", "decide", "whether", "to", "return", "the", "calculated", "diffuse", "components", "or", "not", "returns", "numeric", "ordereddict", "or", "dataframe", "return", "type", "controlled", "by", "return_components", "argument", "if", "return_components", "false", "sky_diffuse", "is", "returned", "if", "return_components", "true", "diffuse_components", "is", "returned", "sky_diffuse", "numeric", "the", "sky", "diffuse", "component", "of", "the", "solar", "radiation", "on", "a", "tilted", "surface", "diffuse_components", "ordereddict", "array", "input", "or", "dataframe", "series", "input", "keys", "columns", "are", "sky_diffuse", "total", "sky", "diffuse", "isotropic", "circumsolar", "horizon", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "perez", "r", "seals", "r", "ineichen", "p", "stewart", "r", "menicucci", "d", "1987", "a", "new", "simplified", "version", "of", "the", "perez", "diffuse", "irradiance", "model", "for", "tilted", "surfaces", "solar", "energy", "39", "3", "221", "232", "3", "perez", "r", "ineichen", "p", "seals", "r", "michalsky", "j", "stewart", "r", "1990", "modeling", "daylight", "availability", "and", "irradiance", "components", "from", "direct", "and", "global", "irradiance", "solar", "energy", "44", "5", "271", "289", "4", "perez", "r", "et", "al", "1988", "the", "development", "and", "verification", "of", "the", "perez", "diffuse", "radiation", "model", "sand88", "7030", "kappa", "1", "041", "for", "solar_zenith", "in", "radians", "z", "np", "radians", "solar_zenith", "convert", "to", "radians", "delta", "is", "the", "sky", "s", "brightness", "delta", "dhi", "airmass", "dni_extra", "epsilon", "is", "the", "sky", "s", "clearness", "with", "np", "errstate", "invalid", "ignore", "eps", "dhi", "dni", "dhi", "kappa", "z", "3", "1", "kappa", "z", "3", "numpy", "indexing", "below", "will", "not", "work", "with", "a", "series", "if", "isinstance", "eps", "pd", "series", "eps", "eps", "values", "perez", "et", "al", "define", "clearness", "bins", "according", "to", "the", "following", "rules", "1", "overcast", "8", "clear", "these", "names", "really", "only", "make", "sense", "for", "small", "zenith", "angles", "but", "these", "values", "will", "eventually", "be", "used", "as", "indicies", "for", "coeffecient", "look", "ups", "ebin", "np", "digitize", "eps", "0", "1", "065", "1", "23", "1", "5", "1", "95", "2", "8", "4", "5", "6", "2", "ebin", "np", "array", "ebin", "gh", "642", "ebin", "np", "isnan", "eps", "0", "correct", "for", "0", "indexing", "in", "coeffecient", "lookup", "later", "ebin", "1", "will", "yield", "nan", "coefficients", "ebin", "1", "the", "various", "possible", "sets", "of", "perez", "coefficients", "are", "contained", "in", "a", "subfunction", "to", "clean", "up", "the", "code", "f1c", "f2c", "_get_perez_coefficients", "model", "results", "in", "invalid", "eps", "ebin", "1", "being", "mapped", "to", "nans", "nans", "np", "array", "np", "nan", "np", "nan", "np", "nan", "f1c", "np", "vstack", "f1c", "nans", "f2c", "np", "vstack", "f2c", "nans", "f1", "f1c", "ebin", "0", "f1c", "ebin", "1", "delta", "f1c", "ebin", "2", "z", "f1", "np", "maximum", "f1", "0", "f2", "f2c", "ebin", "0", "f2c", "ebin", "1", "delta", "f2c", "ebin", "2", "z", "a", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "a", "np", "maximum", "a", "0", "b", "tools", "cosd", "solar_zenith", "b", "np", "maximum", "b", "tools", "cosd", "85", "calculate", "diffuse", "poa", "from", "sky", "dome", "term1", "0", "5", "1", "f1", "1", "tools", "cosd", "surface_tilt", "term2", "f1", "a", "b", "term3", "f2", "tools", "sind", "surface_tilt", "sky_diffuse", "np", "maximum", "dhi", "term1", "term2", "term3", "0", "we", "ve", "preserved", "the", "input", "type", "until", "now", "so", "don", "t", "ruin", "it", "if", "isinstance", "sky_diffuse", "pd", "series", "sky_diffuse", "np", "isnan", "airmass", "0", "else", "sky_diffuse", "np", "where", "np", "isnan", "airmass", "0", "sky_diffuse", "if", "return_components", "diffuse_components", "ordereddict", "diffuse_components", "sky_diffuse", "sky_diffuse", "calculate", "the", "different", "components", "diffuse_components", "isotropic", "dhi", "term1", "diffuse_components", "circumsolar", "dhi", "term2", "diffuse_components", "horizon", "dhi", "term3", "set", "values", "of", "components", "to", "0", "when", "sky_diffuse", "is", "0", "mask", "sky_diffuse", "0", "if", "isinstance", "sky_diffuse", "pd", "series", "diffuse_components", "pd", "dataframe", "diffuse_components", "diffuse_components", "loc", "mask", "0", "else", "diffuse_components", "k", "np", "where", "mask", "0", "v", "for", "k", "v", "in", "diffuse_components", "items", "return", "diffuse_components", "else", "return", "sky_diffuse"], "doc_len": 898}
{"doc_id": "pvlib/irradiance.py::clearsky_index", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "clearsky_index", "text": "文件路径: pvlib/irradiance.py\ndef clearsky_index(ghi, clearsky_ghi, max_clearsky_index=2.0):\n    \"\"\"\n    Calculate the clearsky index.\n\n    The clearsky index is the ratio of global to clearsky global irradiance.\n    Negative and non-finite clearsky index values will be truncated to zero.\n\n    Parameters\n    ----------\n    ghi : numeric\n        Global horizontal irradiance in W/m^2.\n\n    clearsky_ghi : numeric\n        Modeled clearsky GHI\n\n    max_clearsky_index : numeric, default 2.0\n        Maximum value of the clearsky index. The default, 2.0, allows\n        for over-irradiance events typically seen in sub-hourly data.\n\n    Returns\n    -------\n    clearsky_index : numeric\n        Clearsky index\n    \"\"\"\n    clearsky_index = ghi / clearsky_ghi\n    # set +inf, -inf, and nans to zero\n    clearsky_index = np.where(~np.isfinite(clearsky_index), 0,\n                              clearsky_index)\n    # but preserve nans in the input arrays\n    input_is_nan = ~np.isfinite(ghi) | ~np.isfinite(clearsky_ghi)\n    clearsky_index = np.where(input_is_nan, np.nan, clearsky_index)\n\n    clearsky_index = np.maximum(clearsky_index, 0)\n    clearsky_index = np.minimum(clearsky_index, max_clearsky_index)\n\n    # preserve input type\n    if isinstance(ghi, pd.Series):\n        clearsky_index = pd.Series(clearsky_index, index=ghi.index)\n\n    return clearsky_index\n", "tokens": ["pvlib", "irradiance", "py", "def", "clearsky_index", "ghi", "clearsky_ghi", "max_clearsky_index", "2", "0", "calculate", "the", "clearsky", "index", "the", "clearsky", "index", "is", "the", "ratio", "of", "global", "to", "clearsky", "global", "irradiance", "negative", "and", "non", "finite", "clearsky", "index", "values", "will", "be", "truncated", "to", "zero", "parameters", "ghi", "numeric", "global", "horizontal", "irradiance", "in", "w", "m", "2", "clearsky_ghi", "numeric", "modeled", "clearsky", "ghi", "max_clearsky_index", "numeric", "default", "2", "0", "maximum", "value", "of", "the", "clearsky", "index", "the", "default", "2", "0", "allows", "for", "over", "irradiance", "events", "typically", "seen", "in", "sub", "hourly", "data", "returns", "clearsky_index", "numeric", "clearsky", "index", "clearsky_index", "ghi", "clearsky_ghi", "set", "inf", "inf", "and", "nans", "to", "zero", "clearsky_index", "np", "where", "np", "isfinite", "clearsky_index", "0", "clearsky_index", "but", "preserve", "nans", "in", "the", "input", "arrays", "input_is_nan", "np", "isfinite", "ghi", "np", "isfinite", "clearsky_ghi", "clearsky_index", "np", "where", "input_is_nan", "np", "nan", "clearsky_index", "clearsky_index", "np", "maximum", "clearsky_index", "0", "clearsky_index", "np", "minimum", "clearsky_index", "max_clearsky_index", "preserve", "input", "type", "if", "isinstance", "ghi", "pd", "series", "clearsky_index", "pd", "series", "clearsky_index", "index", "ghi", "index", "return", "clearsky_index"], "doc_len": 150}
{"doc_id": "pvlib/irradiance.py::clearness_index", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "clearness_index", "text": "文件路径: pvlib/irradiance.py\ndef clearness_index(ghi, solar_zenith, extra_radiation, min_cos_zenith=0.065,\n                    max_clearness_index=2.0):\n    \"\"\"\n    Calculate the clearness index.\n\n    The clearness index is the ratio of global to extraterrestrial\n    irradiance on a horizontal plane [1]_.\n\n    Parameters\n    ----------\n    ghi : numeric\n        Global horizontal irradiance in W/m^2.\n\n    solar_zenith : numeric\n        True (not refraction-corrected) solar zenith angle in decimal\n        degrees.\n\n    extra_radiation : numeric\n        Irradiance incident at the top of the atmosphere\n\n    min_cos_zenith : numeric, default 0.065\n        Minimum value of cos(zenith) to allow when calculating global\n        clearness index `kt`. Equivalent to zenith = 86.273 degrees.\n\n    max_clearness_index : numeric, default 2.0\n        Maximum value of the clearness index. The default, 2.0, allows\n        for over-irradiance events typically seen in sub-hourly data.\n        NREL's SRRL Fortran code used 0.82 for hourly data.\n\n    Returns\n    -------\n    kt : numeric\n        Clearness index\n\n    References\n    ----------\n    .. [1] Maxwell, E. L., \"A Quasi-Physical Model for Converting Hourly\n           Global Horizontal to Direct Normal Insolation\", Technical\n           Report No. SERI/TR-215-3087, Golden, CO: Solar Energy Research\n           Institute, 1987.\n    \"\"\"\n    cos_zenith = tools.cosd(solar_zenith)\n    I0h = extra_radiation * np.maximum(cos_zenith, min_cos_zenith)\n    # consider adding\n    # with np.errstate(invalid='ignore', divide='ignore'):\n    # to kt calculation, but perhaps it's good to allow these\n    # warnings to the users that override min_cos_zenith\n    kt = ghi / I0h\n    kt = np.maximum(kt, 0)\n    kt = np.minimum(kt, max_clearness_index)\n    return kt\n", "tokens": ["pvlib", "irradiance", "py", "def", "clearness_index", "ghi", "solar_zenith", "extra_radiation", "min_cos_zenith", "0", "065", "max_clearness_index", "2", "0", "calculate", "the", "clearness", "index", "the", "clearness", "index", "is", "the", "ratio", "of", "global", "to", "extraterrestrial", "irradiance", "on", "a", "horizontal", "plane", "1", "_", "parameters", "ghi", "numeric", "global", "horizontal", "irradiance", "in", "w", "m", "2", "solar_zenith", "numeric", "true", "not", "refraction", "corrected", "solar", "zenith", "angle", "in", "decimal", "degrees", "extra_radiation", "numeric", "irradiance", "incident", "at", "the", "top", "of", "the", "atmosphere", "min_cos_zenith", "numeric", "default", "0", "065", "minimum", "value", "of", "cos", "zenith", "to", "allow", "when", "calculating", "global", "clearness", "index", "kt", "equivalent", "to", "zenith", "86", "273", "degrees", "max_clearness_index", "numeric", "default", "2", "0", "maximum", "value", "of", "the", "clearness", "index", "the", "default", "2", "0", "allows", "for", "over", "irradiance", "events", "typically", "seen", "in", "sub", "hourly", "data", "nrel", "s", "srrl", "fortran", "code", "used", "0", "82", "for", "hourly", "data", "returns", "kt", "numeric", "clearness", "index", "references", "1", "maxwell", "e", "l", "a", "quasi", "physical", "model", "for", "converting", "hourly", "global", "horizontal", "to", "direct", "normal", "insolation", "technical", "report", "no", "seri", "tr", "215", "3087", "golden", "co", "solar", "energy", "research", "institute", "1987", "cos_zenith", "tools", "cosd", "solar_zenith", "i0h", "extra_radiation", "np", "maximum", "cos_zenith", "min_cos_zenith", "consider", "adding", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "to", "kt", "calculation", "but", "perhaps", "it", "s", "good", "to", "allow", "these", "warnings", "to", "the", "users", "that", "override", "min_cos_zenith", "kt", "ghi", "i0h", "kt", "np", "maximum", "kt", "0", "kt", "np", "minimum", "kt", "max_clearness_index", "return", "kt"], "doc_len": 217}
{"doc_id": "pvlib/irradiance.py::clearness_index_zenith_independent", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "clearness_index_zenith_independent", "text": "文件路径: pvlib/irradiance.py\ndef clearness_index_zenith_independent(clearness_index, airmass,\n                                       max_clearness_index=2.0):\n    \"\"\"\n    Calculate the zenith angle independent clearness index.\n\n    See [1]_ for details.\n\n    Parameters\n    ----------\n    clearness_index : numeric\n        Ratio of global to extraterrestrial irradiance on a horizontal\n        plane\n\n    airmass : numeric\n        Airmass\n\n    max_clearness_index : numeric, default 2.0\n        Maximum value of the clearness index. The default, 2.0, allows\n        for over-irradiance events typically seen in sub-hourly data.\n        NREL's SRRL Fortran code used 0.82 for hourly data.\n\n    Returns\n    -------\n    kt_prime : numeric\n        Zenith independent clearness index\n\n    References\n    ----------\n    .. [1] Perez, R., P. Ineichen, E. Maxwell, R. Seals and A. Zelenka,\n           (1992). \"Dynamic Global-to-Direct Irradiance Conversion Models\".\n           ASHRAE Transactions-Research Series, pp. 354-369\n    \"\"\"\n    # Perez eqn 1\n    kt_prime = clearness_index / _kt_kt_prime_factor(airmass)\n    kt_prime = np.maximum(kt_prime, 0)\n    kt_prime = np.minimum(kt_prime, max_clearness_index)\n    return kt_prime\n", "tokens": ["pvlib", "irradiance", "py", "def", "clearness_index_zenith_independent", "clearness_index", "airmass", "max_clearness_index", "2", "0", "calculate", "the", "zenith", "angle", "independent", "clearness", "index", "see", "1", "_", "for", "details", "parameters", "clearness_index", "numeric", "ratio", "of", "global", "to", "extraterrestrial", "irradiance", "on", "a", "horizontal", "plane", "airmass", "numeric", "airmass", "max_clearness_index", "numeric", "default", "2", "0", "maximum", "value", "of", "the", "clearness", "index", "the", "default", "2", "0", "allows", "for", "over", "irradiance", "events", "typically", "seen", "in", "sub", "hourly", "data", "nrel", "s", "srrl", "fortran", "code", "used", "0", "82", "for", "hourly", "data", "returns", "kt_prime", "numeric", "zenith", "independent", "clearness", "index", "references", "1", "perez", "r", "p", "ineichen", "e", "maxwell", "r", "seals", "and", "a", "zelenka", "1992", "dynamic", "global", "to", "direct", "irradiance", "conversion", "models", "ashrae", "transactions", "research", "series", "pp", "354", "369", "perez", "eqn", "1", "kt_prime", "clearness_index", "_kt_kt_prime_factor", "airmass", "kt_prime", "np", "maximum", "kt_prime", "0", "kt_prime", "np", "minimum", "kt_prime", "max_clearness_index", "return", "kt_prime"], "doc_len": 129}
{"doc_id": "pvlib/irradiance.py::_kt_kt_prime_factor", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_kt_kt_prime_factor", "text": "文件路径: pvlib/irradiance.py\ndef _kt_kt_prime_factor(airmass):\n    \"\"\"\n    Calculate the conversion factor between kt and kt prime.\n    Function is useful because DIRINT and GTI-DIRINT both use this.\n    \"\"\"\n    # consider adding\n    # airmass = np.maximum(airmass, 12)  # GH 450\n    return 1.031 * np.exp(-1.4 / (0.9 + 9.4 / airmass)) + 0.1\n", "tokens": ["pvlib", "irradiance", "py", "def", "_kt_kt_prime_factor", "airmass", "calculate", "the", "conversion", "factor", "between", "kt", "and", "kt", "prime", "function", "is", "useful", "because", "dirint", "and", "gti", "dirint", "both", "use", "this", "consider", "adding", "airmass", "np", "maximum", "airmass", "12", "gh", "450", "return", "1", "031", "np", "exp", "1", "4", "0", "9", "9", "4", "airmass", "0", "1"], "doc_len": 49}
{"doc_id": "pvlib/irradiance.py::disc", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "disc", "text": "文件路径: pvlib/irradiance.py\ndef disc(ghi, solar_zenith, datetime_or_doy, pressure=101325,\n         min_cos_zenith=0.065, max_zenith=87, max_airmass=12):\n    \"\"\"\n    Estimate Direct Normal Irradiance from Global Horizontal Irradiance\n    using the DISC model.\n\n    The DISC algorithm converts global horizontal irradiance to direct\n    normal irradiance through empirical relationships between the global\n    and direct clearness indices.\n\n    The pvlib implementation limits the clearness index to 1.\n\n    The original report describing the DISC model [1]_ uses the\n    relative airmass rather than the absolute (pressure-corrected)\n    airmass. However, the NREL implementation of the DISC model [2]_\n    uses absolute airmass. PVLib Matlab also uses the absolute airmass.\n    pvlib python defaults to absolute airmass, but the relative airmass\n    can be used by supplying `pressure=None`.\n\n    Parameters\n    ----------\n    ghi : numeric\n        Global horizontal irradiance in W/m^2.\n\n    solar_zenith : numeric\n        True (not refraction-corrected) solar zenith angles in decimal\n        degrees.\n\n    datetime_or_doy : int, float, array, pd.DatetimeIndex\n        Day of year or array of days of year e.g.\n        pd.DatetimeIndex.dayofyear, or pd.DatetimeIndex.\n\n    pressure : None or numeric, default 101325\n        Site pressure in Pascal. If None, relative airmass is used\n        instead of absolute (pressure-corrected) airmass.\n\n    min_cos_zenith : numeric, default 0.065\n        Minimum value of cos(zenith) to allow when calculating global\n        clearness index `kt`. Equivalent to zenith = 86.273 degrees.\n\n    max_zenith : numeric, default 87\n        Maximum value of zenith to allow in DNI calculation. DNI will be\n        set to 0 for times with zenith values greater than `max_zenith`.\n\n    max_airmass : numeric, default 12\n        Maximum value of the airmass to allow in Kn calculation.\n        Default value (12) comes from range over which Kn was fit\n        to airmass in the original paper.\n\n    Returns\n    -------\n    output : OrderedDict or DataFrame\n        Contains the following keys:\n\n        * ``dni``: The modeled direct normal irradiance\n          in W/m^2 provided by the\n          Direct Insolation Simulation Code (DISC) model.\n        * ``kt``: Ratio of global to extraterrestrial\n          irradiance on a horizontal plane.\n        * ``airmass``: Airmass\n\n    References\n    ----------\n    .. [1] Maxwell, E. L., \"A Quasi-Physical Model for Converting Hourly\n       Global Horizontal to Direct Normal Insolation\", Technical\n       Report No. SERI/TR-215-3087, Golden, CO: Solar Energy Research\n       Institute, 1987.\n\n    .. [2] Maxwell, E. \"DISC Model\", Excel Worksheet.\n       https://www.nrel.gov/grid/solar-resource/disc.html\n\n    See Also\n    --------\n    dirint\n    \"\"\"\n\n    # this is the I0 calculation from the reference\n    # SSC uses solar constant = 1367.0 (checked 2018 08 15)\n    I0 = get_extra_radiation(datetime_or_doy, 1370., 'spencer')\n\n    kt = clearness_index(ghi, solar_zenith, I0, min_cos_zenith=min_cos_zenith,\n                         max_clearness_index=1)\n\n    am = atmosphere.get_relative_airmass(solar_zenith, model='kasten1966')\n    if pressure is not None:\n        am = atmosphere.get_absolute_airmass(am, pressure)\n\n    Kn, am = _disc_kn(kt, am, max_airmass=max_airmass)\n    dni = Kn * I0\n\n    bad_values = (solar_zenith > max_zenith) | (ghi < 0) | (dni < 0)\n    dni = np.where(bad_values, 0, dni)\n\n    output = OrderedDict()\n    output['dni'] = dni\n    output['kt'] = kt\n    output['airmass'] = am\n\n    if isinstance(datetime_or_doy, pd.DatetimeIndex):\n        output = pd.DataFrame(output, index=datetime_or_doy)\n\n    return output\n", "tokens": ["pvlib", "irradiance", "py", "def", "disc", "ghi", "solar_zenith", "datetime_or_doy", "pressure", "101325", "min_cos_zenith", "0", "065", "max_zenith", "87", "max_airmass", "12", "estimate", "direct", "normal", "irradiance", "from", "global", "horizontal", "irradiance", "using", "the", "disc", "model", "the", "disc", "algorithm", "converts", "global", "horizontal", "irradiance", "to", "direct", "normal", "irradiance", "through", "empirical", "relationships", "between", "the", "global", "and", "direct", "clearness", "indices", "the", "pvlib", "implementation", "limits", "the", "clearness", "index", "to", "1", "the", "original", "report", "describing", "the", "disc", "model", "1", "_", "uses", "the", "relative", "airmass", "rather", "than", "the", "absolute", "pressure", "corrected", "airmass", "however", "the", "nrel", "implementation", "of", "the", "disc", "model", "2", "_", "uses", "absolute", "airmass", "pvlib", "matlab", "also", "uses", "the", "absolute", "airmass", "pvlib", "python", "defaults", "to", "absolute", "airmass", "but", "the", "relative", "airmass", "can", "be", "used", "by", "supplying", "pressure", "none", "parameters", "ghi", "numeric", "global", "horizontal", "irradiance", "in", "w", "m", "2", "solar_zenith", "numeric", "true", "not", "refraction", "corrected", "solar", "zenith", "angles", "in", "decimal", "degrees", "datetime_or_doy", "int", "float", "array", "pd", "datetimeindex", "day", "of", "year", "or", "array", "of", "days", "of", "year", "e", "g", "pd", "datetimeindex", "dayofyear", "or", "pd", "datetimeindex", "pressure", "none", "or", "numeric", "default", "101325", "site", "pressure", "in", "pascal", "if", "none", "relative", "airmass", "is", "used", "instead", "of", "absolute", "pressure", "corrected", "airmass", "min_cos_zenith", "numeric", "default", "0", "065", "minimum", "value", "of", "cos", "zenith", "to", "allow", "when", "calculating", "global", "clearness", "index", "kt", "equivalent", "to", "zenith", "86", "273", "degrees", "max_zenith", "numeric", "default", "87", "maximum", "value", "of", "zenith", "to", "allow", "in", "dni", "calculation", "dni", "will", "be", "set", "to", "0", "for", "times", "with", "zenith", "values", "greater", "than", "max_zenith", "max_airmass", "numeric", "default", "12", "maximum", "value", "of", "the", "airmass", "to", "allow", "in", "kn", "calculation", "default", "value", "12", "comes", "from", "range", "over", "which", "kn", "was", "fit", "to", "airmass", "in", "the", "original", "paper", "returns", "output", "ordereddict", "or", "dataframe", "contains", "the", "following", "keys", "dni", "the", "modeled", "direct", "normal", "irradiance", "in", "w", "m", "2", "provided", "by", "the", "direct", "insolation", "simulation", "code", "disc", "model", "kt", "ratio", "of", "global", "to", "extraterrestrial", "irradiance", "on", "a", "horizontal", "plane", "airmass", "airmass", "references", "1", "maxwell", "e", "l", "a", "quasi", "physical", "model", "for", "converting", "hourly", "global", "horizontal", "to", "direct", "normal", "insolation", "technical", "report", "no", "seri", "tr", "215", "3087", "golden", "co", "solar", "energy", "research", "institute", "1987", "2", "maxwell", "e", "disc", "model", "excel", "worksheet", "https", "www", "nrel", "gov", "grid", "solar", "resource", "disc", "html", "see", "also", "dirint", "this", "is", "the", "i0", "calculation", "from", "the", "reference", "ssc", "uses", "solar", "constant", "1367", "0", "checked", "2018", "08", "15", "i0", "get_extra_radiation", "datetime_or_doy", "1370", "spencer", "kt", "clearness_index", "ghi", "solar_zenith", "i0", "min_cos_zenith", "min_cos_zenith", "max_clearness_index", "1", "am", "atmosphere", "get_relative_airmass", "solar_zenith", "model", "kasten1966", "if", "pressure", "is", "not", "none", "am", "atmosphere", "get_absolute_airmass", "am", "pressure", "kn", "am", "_disc_kn", "kt", "am", "max_airmass", "max_airmass", "dni", "kn", "i0", "bad_values", "solar_zenith", "max_zenith", "ghi", "0", "dni", "0", "dni", "np", "where", "bad_values", "0", "dni", "output", "ordereddict", "output", "dni", "dni", "output", "kt", "kt", "output", "airmass", "am", "if", "isinstance", "datetime_or_doy", "pd", "datetimeindex", "output", "pd", "dataframe", "output", "index", "datetime_or_doy", "return", "output"], "doc_len": 452}
{"doc_id": "pvlib/irradiance.py::_disc_kn", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_disc_kn", "text": "文件路径: pvlib/irradiance.py\ndef _disc_kn(clearness_index, airmass, max_airmass=12):\n    \"\"\"\n    Calculate Kn for `disc`\n\n    Parameters\n    ----------\n    clearness_index : numeric\n    airmass : numeric\n    max_airmass : float\n        airmass > max_airmass is set to max_airmass before being used\n        in calculating Kn.\n\n    Returns\n    -------\n    Kn : numeric\n    am : numeric\n        airmass used in the calculation of Kn. am <= max_airmass.\n    \"\"\"\n    # short names for equations\n    kt = clearness_index\n    am = airmass\n\n    am = np.minimum(am, max_airmass)  # GH 450\n\n    # powers of kt will be used repeatedly, so compute only once\n    kt2 = kt * kt  # about the same as kt ** 2\n    kt3 = kt2 * kt  # 5-10x faster than kt ** 3\n\n    bools = (kt <= 0.6)\n    a = np.where(bools,\n                 0.512 - 1.56*kt + 2.286*kt2 - 2.222*kt3,\n                 -5.743 + 21.77*kt - 27.49*kt2 + 11.56*kt3)\n    b = np.where(bools,\n                 0.37 + 0.962*kt,\n                 41.4 - 118.5*kt + 66.05*kt2 + 31.9*kt3)\n    c = np.where(bools,\n                 -0.28 + 0.932*kt - 2.048*kt2,\n                 -47.01 + 184.2*kt - 222.0*kt2 + 73.81*kt3)\n\n    delta_kn = a + b * np.exp(c*am)\n\n    Knc = 0.866 - 0.122*am + 0.0121*am**2 - 0.000653*am**3 + 1.4e-05*am**4\n    Kn = Knc - delta_kn\n    return Kn, am\n", "tokens": ["pvlib", "irradiance", "py", "def", "_disc_kn", "clearness_index", "airmass", "max_airmass", "12", "calculate", "kn", "for", "disc", "parameters", "clearness_index", "numeric", "airmass", "numeric", "max_airmass", "float", "airmass", "max_airmass", "is", "set", "to", "max_airmass", "before", "being", "used", "in", "calculating", "kn", "returns", "kn", "numeric", "am", "numeric", "airmass", "used", "in", "the", "calculation", "of", "kn", "am", "max_airmass", "short", "names", "for", "equations", "kt", "clearness_index", "am", "airmass", "am", "np", "minimum", "am", "max_airmass", "gh", "450", "powers", "of", "kt", "will", "be", "used", "repeatedly", "so", "compute", "only", "once", "kt2", "kt", "kt", "about", "the", "same", "as", "kt", "2", "kt3", "kt2", "kt", "5", "10x", "faster", "than", "kt", "3", "bools", "kt", "0", "6", "a", "np", "where", "bools", "0", "512", "1", "56", "kt", "2", "286", "kt2", "2", "222", "kt3", "5", "743", "21", "77", "kt", "27", "49", "kt2", "11", "56", "kt3", "b", "np", "where", "bools", "0", "37", "0", "962", "kt", "41", "4", "118", "5", "kt", "66", "05", "kt2", "31", "9", "kt3", "c", "np", "where", "bools", "0", "28", "0", "932", "kt", "2", "048", "kt2", "47", "01", "184", "2", "kt", "222", "0", "kt2", "73", "81", "kt3", "delta_kn", "a", "b", "np", "exp", "c", "am", "knc", "0", "866", "0", "122", "am", "0", "0121", "am", "2", "0", "000653", "am", "3", "1", "4e", "05", "am", "4", "kn", "knc", "delta_kn", "return", "kn", "am"], "doc_len": 195}
{"doc_id": "pvlib/irradiance.py::dirint", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "dirint", "text": "文件路径: pvlib/irradiance.py\ndef dirint(ghi, solar_zenith, times, pressure=101325., use_delta_kt_prime=True,\n           temp_dew=None, min_cos_zenith=0.065, max_zenith=87):\n    \"\"\"\n    Determine DNI from GHI using the DIRINT modification of the DISC\n    model.\n\n    Implements the modified DISC model known as \"DIRINT\" introduced in\n    [1]_. DIRINT predicts direct normal irradiance (DNI) from measured\n    global horizontal irradiance (GHI). DIRINT improves upon the DISC\n    model by using time-series GHI data and dew point temperature\n    information. The effectiveness of the DIRINT model improves with\n    each piece of information provided.\n\n    The pvlib implementation limits the clearness index to 1.\n\n    Parameters\n    ----------\n    ghi : array-like\n        Global horizontal irradiance in W/m^2.\n\n    solar_zenith : array-like\n        True (not refraction-corrected) solar_zenith angles in decimal\n        degrees.\n\n    times : DatetimeIndex\n\n    pressure : float or array-like, default 101325.0\n        The site pressure in Pascal. Pressure may be measured or an\n        average pressure may be calculated from site altitude.\n\n    use_delta_kt_prime : bool, default True\n        If True, indicates that the stability index delta_kt_prime is\n        included in the model. The stability index adjusts the estimated\n        DNI in response to dynamics in the time series of GHI. It is\n        recommended that delta_kt_prime is not used if the time between\n        GHI points is 1.5 hours or greater. If use_delta_kt_prime=True,\n        input data must be Series.\n\n    temp_dew : None, float, or array-like, default None\n        Surface dew point temperatures, in degrees C. Values of temp_dew\n        may be numeric or NaN. Any single time period point with a\n        temp_dew=NaN does not have dew point improvements applied. If\n        temp_dew is not provided, then dew point improvements are not\n        applied.\n\n    min_cos_zenith : numeric, default 0.065\n        Minimum value of cos(zenith) to allow when calculating global\n        clearness index `kt`. Equivalent to zenith = 86.273 degrees.\n\n    max_zenith : numeric, default 87\n        Maximum value of zenith to allow in DNI calculation. DNI will be\n        set to 0 for times with zenith values greater than `max_zenith`.\n\n    Returns\n    -------\n    dni : array-like\n        The modeled direct normal irradiance in W/m^2 provided by the\n        DIRINT model.\n\n    Notes\n    -----\n    DIRINT model requires time series data (ie. one of the inputs must\n    be a vector of length > 2).\n\n    References\n    ----------\n    .. [1] Perez, R., P. Ineichen, E. Maxwell, R. Seals and A. Zelenka,\n       (1992). \"Dynamic Global-to-Direct Irradiance Conversion Models\".\n       ASHRAE Transactions-Research Series, pp. 354-369\n\n    .. [2] Maxwell, E. L., \"A Quasi-Physical Model for Converting Hourly\n       Global Horizontal to Direct Normal Insolation\", Technical Report No.\n       SERI/TR-215-3087, Golden, CO: Solar Energy Research Institute, 1987.\n    \"\"\"\n\n    disc_out = disc(ghi, solar_zenith, times, pressure=pressure,\n                    min_cos_zenith=min_cos_zenith, max_zenith=max_zenith)\n    airmass = disc_out['airmass']\n    kt = disc_out['kt']\n\n    kt_prime = clearness_index_zenith_independent(\n        kt, airmass, max_clearness_index=1)\n    delta_kt_prime = _delta_kt_prime_dirint(kt_prime, use_delta_kt_prime,\n                                            times)\n    w = _temp_dew_dirint(temp_dew, times)\n\n    dirint_coeffs = _dirint_coeffs(times, kt_prime, solar_zenith, w,\n                                   delta_kt_prime)\n\n    # Perez eqn 5\n    dni = disc_out['dni'] * dirint_coeffs\n\n    return dni\n", "tokens": ["pvlib", "irradiance", "py", "def", "dirint", "ghi", "solar_zenith", "times", "pressure", "101325", "use_delta_kt_prime", "true", "temp_dew", "none", "min_cos_zenith", "0", "065", "max_zenith", "87", "determine", "dni", "from", "ghi", "using", "the", "dirint", "modification", "of", "the", "disc", "model", "implements", "the", "modified", "disc", "model", "known", "as", "dirint", "introduced", "in", "1", "_", "dirint", "predicts", "direct", "normal", "irradiance", "dni", "from", "measured", "global", "horizontal", "irradiance", "ghi", "dirint", "improves", "upon", "the", "disc", "model", "by", "using", "time", "series", "ghi", "data", "and", "dew", "point", "temperature", "information", "the", "effectiveness", "of", "the", "dirint", "model", "improves", "with", "each", "piece", "of", "information", "provided", "the", "pvlib", "implementation", "limits", "the", "clearness", "index", "to", "1", "parameters", "ghi", "array", "like", "global", "horizontal", "irradiance", "in", "w", "m", "2", "solar_zenith", "array", "like", "true", "not", "refraction", "corrected", "solar_zenith", "angles", "in", "decimal", "degrees", "times", "datetimeindex", "pressure", "float", "or", "array", "like", "default", "101325", "0", "the", "site", "pressure", "in", "pascal", "pressure", "may", "be", "measured", "or", "an", "average", "pressure", "may", "be", "calculated", "from", "site", "altitude", "use_delta_kt_prime", "bool", "default", "true", "if", "true", "indicates", "that", "the", "stability", "index", "delta_kt_prime", "is", "included", "in", "the", "model", "the", "stability", "index", "adjusts", "the", "estimated", "dni", "in", "response", "to", "dynamics", "in", "the", "time", "series", "of", "ghi", "it", "is", "recommended", "that", "delta_kt_prime", "is", "not", "used", "if", "the", "time", "between", "ghi", "points", "is", "1", "5", "hours", "or", "greater", "if", "use_delta_kt_prime", "true", "input", "data", "must", "be", "series", "temp_dew", "none", "float", "or", "array", "like", "default", "none", "surface", "dew", "point", "temperatures", "in", "degrees", "c", "values", "of", "temp_dew", "may", "be", "numeric", "or", "nan", "any", "single", "time", "period", "point", "with", "a", "temp_dew", "nan", "does", "not", "have", "dew", "point", "improvements", "applied", "if", "temp_dew", "is", "not", "provided", "then", "dew", "point", "improvements", "are", "not", "applied", "min_cos_zenith", "numeric", "default", "0", "065", "minimum", "value", "of", "cos", "zenith", "to", "allow", "when", "calculating", "global", "clearness", "index", "kt", "equivalent", "to", "zenith", "86", "273", "degrees", "max_zenith", "numeric", "default", "87", "maximum", "value", "of", "zenith", "to", "allow", "in", "dni", "calculation", "dni", "will", "be", "set", "to", "0", "for", "times", "with", "zenith", "values", "greater", "than", "max_zenith", "returns", "dni", "array", "like", "the", "modeled", "direct", "normal", "irradiance", "in", "w", "m", "2", "provided", "by", "the", "dirint", "model", "notes", "dirint", "model", "requires", "time", "series", "data", "ie", "one", "of", "the", "inputs", "must", "be", "a", "vector", "of", "length", "2", "references", "1", "perez", "r", "p", "ineichen", "e", "maxwell", "r", "seals", "and", "a", "zelenka", "1992", "dynamic", "global", "to", "direct", "irradiance", "conversion", "models", "ashrae", "transactions", "research", "series", "pp", "354", "369", "2", "maxwell", "e", "l", "a", "quasi", "physical", "model", "for", "converting", "hourly", "global", "horizontal", "to", "direct", "normal", "insolation", "technical", "report", "no", "seri", "tr", "215", "3087", "golden", "co", "solar", "energy", "research", "institute", "1987", "disc_out", "disc", "ghi", "solar_zenith", "times", "pressure", "pressure", "min_cos_zenith", "min_cos_zenith", "max_zenith", "max_zenith", "airmass", "disc_out", "airmass", "kt", "disc_out", "kt", "kt_prime", "clearness_index_zenith_independent", "kt", "airmass", "max_clearness_index", "1", "delta_kt_prime", "_delta_kt_prime_dirint", "kt_prime", "use_delta_kt_prime", "times", "w", "_temp_dew_dirint", "temp_dew", "times", "dirint_coeffs", "_dirint_coeffs", "times", "kt_prime", "solar_zenith", "w", "delta_kt_prime", "perez", "eqn", "5", "dni", "disc_out", "dni", "dirint_coeffs", "return", "dni"], "doc_len": 454}
{"doc_id": "pvlib/irradiance.py::_dirint_from_dni_ktprime", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_dirint_from_dni_ktprime", "text": "文件路径: pvlib/irradiance.py\ndef _dirint_from_dni_ktprime(dni, kt_prime, solar_zenith, use_delta_kt_prime,\n                             temp_dew):\n    \"\"\"\n    Calculate DIRINT DNI from supplied DISC DNI and Kt'.\n\n    Supports :py:func:`gti_dirint`\n    \"\"\"\n    times = dni.index\n    delta_kt_prime = _delta_kt_prime_dirint(kt_prime, use_delta_kt_prime,\n                                            times)\n    w = _temp_dew_dirint(temp_dew, times)\n    dirint_coeffs = _dirint_coeffs(times, kt_prime, solar_zenith, w,\n                                   delta_kt_prime)\n    dni_dirint = dni * dirint_coeffs\n    return dni_dirint\n", "tokens": ["pvlib", "irradiance", "py", "def", "_dirint_from_dni_ktprime", "dni", "kt_prime", "solar_zenith", "use_delta_kt_prime", "temp_dew", "calculate", "dirint", "dni", "from", "supplied", "disc", "dni", "and", "kt", "supports", "py", "func", "gti_dirint", "times", "dni", "index", "delta_kt_prime", "_delta_kt_prime_dirint", "kt_prime", "use_delta_kt_prime", "times", "w", "_temp_dew_dirint", "temp_dew", "times", "dirint_coeffs", "_dirint_coeffs", "times", "kt_prime", "solar_zenith", "w", "delta_kt_prime", "dni_dirint", "dni", "dirint_coeffs", "return", "dni_dirint"], "doc_len": 47}
{"doc_id": "pvlib/irradiance.py::_delta_kt_prime_dirint", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_delta_kt_prime_dirint", "text": "文件路径: pvlib/irradiance.py\ndef _delta_kt_prime_dirint(kt_prime, use_delta_kt_prime, times):\n    \"\"\"\n    Calculate delta_kt_prime (Perez eqn 2 and eqn 3), or return a default value\n    for use with :py:func:`_dirint_bins`.\n    \"\"\"\n    if use_delta_kt_prime:\n        # Perez eqn 2\n        kt_next = kt_prime.shift(-1)\n        kt_previous = kt_prime.shift(1)\n        # replace nan with values that implement Perez Eq 3 for first and last\n        # positions. Use kt_previous and kt_next to handle series of length 1\n        kt_next.iloc[-1] = kt_previous.iloc[-1]\n        kt_previous.iloc[0] = kt_next.iloc[0]\n        delta_kt_prime = 0.5 * ((kt_prime - kt_next).abs().add(\n                                (kt_prime - kt_previous).abs(),\n                                fill_value=0))\n    else:\n        # do not change unless also modifying _dirint_bins\n        delta_kt_prime = pd.Series(-1, index=times)\n    return delta_kt_prime\n", "tokens": ["pvlib", "irradiance", "py", "def", "_delta_kt_prime_dirint", "kt_prime", "use_delta_kt_prime", "times", "calculate", "delta_kt_prime", "perez", "eqn", "2", "and", "eqn", "3", "or", "return", "a", "default", "value", "for", "use", "with", "py", "func", "_dirint_bins", "if", "use_delta_kt_prime", "perez", "eqn", "2", "kt_next", "kt_prime", "shift", "1", "kt_previous", "kt_prime", "shift", "1", "replace", "nan", "with", "values", "that", "implement", "perez", "eq", "3", "for", "first", "and", "last", "positions", "use", "kt_previous", "and", "kt_next", "to", "handle", "series", "of", "length", "1", "kt_next", "iloc", "1", "kt_previous", "iloc", "1", "kt_previous", "iloc", "0", "kt_next", "iloc", "0", "delta_kt_prime", "0", "5", "kt_prime", "kt_next", "abs", "add", "kt_prime", "kt_previous", "abs", "fill_value", "0", "else", "do", "not", "change", "unless", "also", "modifying", "_dirint_bins", "delta_kt_prime", "pd", "series", "1", "index", "times", "return", "delta_kt_prime"], "doc_len": 104}
{"doc_id": "pvlib/irradiance.py::_temp_dew_dirint", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_temp_dew_dirint", "text": "文件路径: pvlib/irradiance.py\ndef _temp_dew_dirint(temp_dew, times):\n    \"\"\"\n    Calculate precipitable water from surface dew point temp (Perez eqn 4),\n    or return a default value for use with :py:func:`_dirint_bins`.\n    \"\"\"\n    if temp_dew is not None:\n        # Perez eqn 4\n        w = pd.Series(np.exp(0.07 * temp_dew - 0.075), index=times)\n    else:\n        # do not change unless also modifying _dirint_bins\n        w = pd.Series(-1, index=times)\n    return w\n", "tokens": ["pvlib", "irradiance", "py", "def", "_temp_dew_dirint", "temp_dew", "times", "calculate", "precipitable", "water", "from", "surface", "dew", "point", "temp", "perez", "eqn", "4", "or", "return", "a", "default", "value", "for", "use", "with", "py", "func", "_dirint_bins", "if", "temp_dew", "is", "not", "none", "perez", "eqn", "4", "w", "pd", "series", "np", "exp", "0", "07", "temp_dew", "0", "075", "index", "times", "else", "do", "not", "change", "unless", "also", "modifying", "_dirint_bins", "w", "pd", "series", "1", "index", "times", "return", "w"], "doc_len": 65}
{"doc_id": "pvlib/irradiance.py::_dirint_coeffs", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_dirint_coeffs", "text": "文件路径: pvlib/irradiance.py\ndef _dirint_coeffs(times, kt_prime, solar_zenith, w, delta_kt_prime):\n    \"\"\"\n    Determine the DISC to DIRINT multiplier `dirint_coeffs`.\n\n    dni = disc_out['dni'] * dirint_coeffs\n\n    Parameters\n    ----------\n    times : pd.DatetimeIndex\n    kt_prime : Zenith-independent clearness index\n    solar_zenith : Solar zenith angle\n    w : precipitable water estimated from surface dew-point temperature\n    delta_kt_prime : stability index\n\n    Returns\n    -------\n    dirint_coeffs : array-like\n    \"\"\"\n    kt_prime_bin, zenith_bin, w_bin, delta_kt_prime_bin = \\\n        _dirint_bins(times, kt_prime, solar_zenith, w, delta_kt_prime)\n\n    # get the coefficients\n    coeffs = _get_dirint_coeffs()\n\n    # subtract 1 to account for difference between MATLAB-style bin\n    # assignment and Python-style array lookup.\n    dirint_coeffs = coeffs[kt_prime_bin-1, zenith_bin-1,\n                           delta_kt_prime_bin-1, w_bin-1]\n\n    # convert unassigned bins to nan\n    dirint_coeffs = np.where((kt_prime_bin == 0) | (zenith_bin == 0) |\n                             (w_bin == 0) | (delta_kt_prime_bin == 0),\n                             np.nan, dirint_coeffs)\n    return dirint_coeffs\n", "tokens": ["pvlib", "irradiance", "py", "def", "_dirint_coeffs", "times", "kt_prime", "solar_zenith", "w", "delta_kt_prime", "determine", "the", "disc", "to", "dirint", "multiplier", "dirint_coeffs", "dni", "disc_out", "dni", "dirint_coeffs", "parameters", "times", "pd", "datetimeindex", "kt_prime", "zenith", "independent", "clearness", "index", "solar_zenith", "solar", "zenith", "angle", "w", "precipitable", "water", "estimated", "from", "surface", "dew", "point", "temperature", "delta_kt_prime", "stability", "index", "returns", "dirint_coeffs", "array", "like", "kt_prime_bin", "zenith_bin", "w_bin", "delta_kt_prime_bin", "_dirint_bins", "times", "kt_prime", "solar_zenith", "w", "delta_kt_prime", "get", "the", "coefficients", "coeffs", "_get_dirint_coeffs", "subtract", "1", "to", "account", "for", "difference", "between", "matlab", "style", "bin", "assignment", "and", "python", "style", "array", "lookup", "dirint_coeffs", "coeffs", "kt_prime_bin", "1", "zenith_bin", "1", "delta_kt_prime_bin", "1", "w_bin", "1", "convert", "unassigned", "bins", "to", "nan", "dirint_coeffs", "np", "where", "kt_prime_bin", "0", "zenith_bin", "0", "w_bin", "0", "delta_kt_prime_bin", "0", "np", "nan", "dirint_coeffs", "return", "dirint_coeffs"], "doc_len": 112}
{"doc_id": "pvlib/irradiance.py::_dirint_bins", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_dirint_bins", "text": "文件路径: pvlib/irradiance.py\ndef _dirint_bins(times, kt_prime, zenith, w, delta_kt_prime):\n    \"\"\"\n    Determine the bins for the DIRINT coefficients.\n\n    Parameters\n    ----------\n    times : pd.DatetimeIndex\n    kt_prime : Zenith-independent clearness index\n    zenith : Solar zenith angle\n    w : precipitable water estimated from surface dew-point temperature\n    delta_kt_prime : stability index\n\n    Returns\n    -------\n    tuple of kt_prime_bin, zenith_bin, w_bin, delta_kt_prime_bin\n    \"\"\"\n    # @wholmgren: the following bin assignments use MATLAB's 1-indexing.\n    # Later, we'll subtract 1 to conform to Python's 0-indexing.\n\n    # Create kt_prime bins\n    kt_prime_bin = pd.Series(0, index=times, dtype=np.int64)\n    kt_prime_bin[(kt_prime >= 0) & (kt_prime < 0.24)] = 1\n    kt_prime_bin[(kt_prime >= 0.24) & (kt_prime < 0.4)] = 2\n    kt_prime_bin[(kt_prime >= 0.4) & (kt_prime < 0.56)] = 3\n    kt_prime_bin[(kt_prime >= 0.56) & (kt_prime < 0.7)] = 4\n    kt_prime_bin[(kt_prime >= 0.7) & (kt_prime < 0.8)] = 5\n    kt_prime_bin[(kt_prime >= 0.8) & (kt_prime <= 1)] = 6\n\n    # Create zenith angle bins\n    zenith_bin = pd.Series(0, index=times, dtype=np.int64)\n    zenith_bin[(zenith >= 0) & (zenith < 25)] = 1\n    zenith_bin[(zenith >= 25) & (zenith < 40)] = 2\n    zenith_bin[(zenith >= 40) & (zenith < 55)] = 3\n    zenith_bin[(zenith >= 55) & (zenith < 70)] = 4\n    zenith_bin[(zenith >= 70) & (zenith < 80)] = 5\n    zenith_bin[(zenith >= 80)] = 6\n\n    # Create the bins for w based on dew point temperature\n    w_bin = pd.Series(0, index=times, dtype=np.int64)\n    w_bin[(w >= 0) & (w < 1)] = 1\n    w_bin[(w >= 1) & (w < 2)] = 2\n    w_bin[(w >= 2) & (w < 3)] = 3\n    w_bin[(w >= 3)] = 4\n    w_bin[(w == -1)] = 5\n\n    # Create delta_kt_prime binning.\n    delta_kt_prime_bin = pd.Series(0, index=times, dtype=np.int64)\n    delta_kt_prime_bin[(delta_kt_prime >= 0) & (delta_kt_prime < 0.015)] = 1\n    delta_kt_prime_bin[(delta_kt_prime >= 0.015) &\n                       (delta_kt_prime < 0.035)] = 2\n    delta_kt_prime_bin[(delta_kt_prime >= 0.035) & (delta_kt_prime < 0.07)] = 3\n    delta_kt_prime_bin[(delta_kt_prime >= 0.07) & (delta_kt_prime < 0.15)] = 4\n    delta_kt_prime_bin[(delta_kt_prime >= 0.15) & (delta_kt_prime < 0.3)] = 5\n    delta_kt_prime_bin[(delta_kt_prime >= 0.3) & (delta_kt_prime <= 1)] = 6\n    delta_kt_prime_bin[delta_kt_prime == -1] = 7\n\n    return kt_prime_bin, zenith_bin, w_bin, delta_kt_prime_bin\n", "tokens": ["pvlib", "irradiance", "py", "def", "_dirint_bins", "times", "kt_prime", "zenith", "w", "delta_kt_prime", "determine", "the", "bins", "for", "the", "dirint", "coefficients", "parameters", "times", "pd", "datetimeindex", "kt_prime", "zenith", "independent", "clearness", "index", "zenith", "solar", "zenith", "angle", "w", "precipitable", "water", "estimated", "from", "surface", "dew", "point", "temperature", "delta_kt_prime", "stability", "index", "returns", "tuple", "of", "kt_prime_bin", "zenith_bin", "w_bin", "delta_kt_prime_bin", "wholmgren", "the", "following", "bin", "assignments", "use", "matlab", "s", "1", "indexing", "later", "we", "ll", "subtract", "1", "to", "conform", "to", "python", "s", "0", "indexing", "create", "kt_prime", "bins", "kt_prime_bin", "pd", "series", "0", "index", "times", "dtype", "np", "int64", "kt_prime_bin", "kt_prime", "0", "kt_prime", "0", "24", "1", "kt_prime_bin", "kt_prime", "0", "24", "kt_prime", "0", "4", "2", "kt_prime_bin", "kt_prime", "0", "4", "kt_prime", "0", "56", "3", "kt_prime_bin", "kt_prime", "0", "56", "kt_prime", "0", "7", "4", "kt_prime_bin", "kt_prime", "0", "7", "kt_prime", "0", "8", "5", "kt_prime_bin", "kt_prime", "0", "8", "kt_prime", "1", "6", "create", "zenith", "angle", "bins", "zenith_bin", "pd", "series", "0", "index", "times", "dtype", "np", "int64", "zenith_bin", "zenith", "0", "zenith", "25", "1", "zenith_bin", "zenith", "25", "zenith", "40", "2", "zenith_bin", "zenith", "40", "zenith", "55", "3", "zenith_bin", "zenith", "55", "zenith", "70", "4", "zenith_bin", "zenith", "70", "zenith", "80", "5", "zenith_bin", "zenith", "80", "6", "create", "the", "bins", "for", "w", "based", "on", "dew", "point", "temperature", "w_bin", "pd", "series", "0", "index", "times", "dtype", "np", "int64", "w_bin", "w", "0", "w", "1", "1", "w_bin", "w", "1", "w", "2", "2", "w_bin", "w", "2", "w", "3", "3", "w_bin", "w", "3", "4", "w_bin", "w", "1", "5", "create", "delta_kt_prime", "binning", "delta_kt_prime_bin", "pd", "series", "0", "index", "times", "dtype", "np", "int64", "delta_kt_prime_bin", "delta_kt_prime", "0", "delta_kt_prime", "0", "015", "1", "delta_kt_prime_bin", "delta_kt_prime", "0", "015", "delta_kt_prime", "0", "035", "2", "delta_kt_prime_bin", "delta_kt_prime", "0", "035", "delta_kt_prime", "0", "07", "3", "delta_kt_prime_bin", "delta_kt_prime", "0", "07", "delta_kt_prime", "0", "15", "4", "delta_kt_prime_bin", "delta_kt_prime", "0", "15", "delta_kt_prime", "0", "3", "5", "delta_kt_prime_bin", "delta_kt_prime", "0", "3", "delta_kt_prime", "1", "6", "delta_kt_prime_bin", "delta_kt_prime", "1", "7", "return", "kt_prime_bin", "zenith_bin", "w_bin", "delta_kt_prime_bin"], "doc_len": 288}
{"doc_id": "pvlib/irradiance.py::dirindex", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "dirindex", "text": "文件路径: pvlib/irradiance.py\ndef dirindex(ghi, ghi_clearsky, dni_clearsky, zenith, times, pressure=101325.,\n             use_delta_kt_prime=True, temp_dew=None, min_cos_zenith=0.065,\n             max_zenith=87):\n    \"\"\"\n    Determine DNI from GHI using the DIRINDEX model.\n\n    The DIRINDEX model [1]_ modifies the DIRINT model implemented in\n    :py:func:`pvlib.irradiance.dirint` by taking into account information\n    from a clear sky model. It is recommended that ``ghi_clearsky`` be\n    calculated using the Ineichen clear sky model\n    :py:func:`pvlib.clearsky.ineichen` with ``perez_enhancement=True``.\n\n    The pvlib implementation limits the clearness index to 1.\n\n    Parameters\n    ----------\n    ghi : array-like\n        Global horizontal irradiance in W/m^2.\n\n    ghi_clearsky : array-like\n        Global horizontal irradiance from clear sky model, in W/m^2.\n\n    dni_clearsky : array-like\n        Direct normal irradiance from clear sky model, in W/m^2.\n\n    zenith : array-like\n        True (not refraction-corrected) zenith angles in decimal\n        degrees. If Z is a vector it must be of the same size as all\n        other vector inputs. Z must be >=0 and <=180.\n\n    times : DatetimeIndex\n\n    pressure : float or array-like, default 101325.0\n        The site pressure in Pascal. Pressure may be measured or an\n        average pressure may be calculated from site altitude.\n\n    use_delta_kt_prime : bool, default True\n        If True, indicates that the stability index delta_kt_prime is\n        included in the model. The stability index adjusts the estimated\n        DNI in response to dynamics in the time series of GHI. It is\n        recommended that delta_kt_prime is not used if the time between\n        GHI points is 1.5 hours or greater. If use_delta_kt_prime=True,\n        input data must be Series.\n\n    temp_dew : None, float, or array-like, default None\n        Surface dew point temperatures, in degrees C. Values of temp_dew\n        may be numeric or NaN. Any single time period point with a\n        temp_dew=NaN does not have dew point improvements applied. If\n        temp_dew is not provided, then dew point improvements are not\n        applied.\n\n    min_cos_zenith : numeric, default 0.065\n        Minimum value of cos(zenith) to allow when calculating global\n        clearness index `kt`. Equivalent to zenith = 86.273 degrees.\n\n    max_zenith : numeric, default 87\n        Maximum value of zenith to allow in DNI calculation. DNI will be\n        set to 0 for times with zenith values greater than `max_zenith`.\n\n    Returns\n    -------\n    dni : array-like\n        The modeled direct normal irradiance in W/m^2.\n\n    Notes\n    -----\n    DIRINDEX model requires time series data (ie. one of the inputs must\n    be a vector of length > 2).\n\n    References\n    ----------\n    .. [1] Perez, R., Ineichen, P., Moore, K., Kmiecik, M., Chain, C., George,\n       R., & Vignola, F. (2002). A new operational model for satellite-derived\n       irradiances: description and validation. Solar Energy, 73(5), 307-317.\n    \"\"\"\n\n    dni_dirint = dirint(ghi, zenith, times, pressure=pressure,\n                        use_delta_kt_prime=use_delta_kt_prime,\n                        temp_dew=temp_dew, min_cos_zenith=min_cos_zenith,\n                        max_zenith=max_zenith)\n\n    dni_dirint_clearsky = dirint(ghi_clearsky, zenith, times,\n                                 pressure=pressure,\n                                 use_delta_kt_prime=use_delta_kt_prime,\n                                 temp_dew=temp_dew,\n                                 min_cos_zenith=min_cos_zenith,\n                                 max_zenith=max_zenith)\n\n    dni_dirindex = dni_clearsky * dni_dirint / dni_dirint_clearsky\n\n    dni_dirindex[dni_dirindex < 0] = 0.\n\n    return dni_dirindex\n", "tokens": ["pvlib", "irradiance", "py", "def", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "zenith", "times", "pressure", "101325", "use_delta_kt_prime", "true", "temp_dew", "none", "min_cos_zenith", "0", "065", "max_zenith", "87", "determine", "dni", "from", "ghi", "using", "the", "dirindex", "model", "the", "dirindex", "model", "1", "_", "modifies", "the", "dirint", "model", "implemented", "in", "py", "func", "pvlib", "irradiance", "dirint", "by", "taking", "into", "account", "information", "from", "a", "clear", "sky", "model", "it", "is", "recommended", "that", "ghi_clearsky", "be", "calculated", "using", "the", "ineichen", "clear", "sky", "model", "py", "func", "pvlib", "clearsky", "ineichen", "with", "perez_enhancement", "true", "the", "pvlib", "implementation", "limits", "the", "clearness", "index", "to", "1", "parameters", "ghi", "array", "like", "global", "horizontal", "irradiance", "in", "w", "m", "2", "ghi_clearsky", "array", "like", "global", "horizontal", "irradiance", "from", "clear", "sky", "model", "in", "w", "m", "2", "dni_clearsky", "array", "like", "direct", "normal", "irradiance", "from", "clear", "sky", "model", "in", "w", "m", "2", "zenith", "array", "like", "true", "not", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "if", "z", "is", "a", "vector", "it", "must", "be", "of", "the", "same", "size", "as", "all", "other", "vector", "inputs", "z", "must", "be", "0", "and", "180", "times", "datetimeindex", "pressure", "float", "or", "array", "like", "default", "101325", "0", "the", "site", "pressure", "in", "pascal", "pressure", "may", "be", "measured", "or", "an", "average", "pressure", "may", "be", "calculated", "from", "site", "altitude", "use_delta_kt_prime", "bool", "default", "true", "if", "true", "indicates", "that", "the", "stability", "index", "delta_kt_prime", "is", "included", "in", "the", "model", "the", "stability", "index", "adjusts", "the", "estimated", "dni", "in", "response", "to", "dynamics", "in", "the", "time", "series", "of", "ghi", "it", "is", "recommended", "that", "delta_kt_prime", "is", "not", "used", "if", "the", "time", "between", "ghi", "points", "is", "1", "5", "hours", "or", "greater", "if", "use_delta_kt_prime", "true", "input", "data", "must", "be", "series", "temp_dew", "none", "float", "or", "array", "like", "default", "none", "surface", "dew", "point", "temperatures", "in", "degrees", "c", "values", "of", "temp_dew", "may", "be", "numeric", "or", "nan", "any", "single", "time", "period", "point", "with", "a", "temp_dew", "nan", "does", "not", "have", "dew", "point", "improvements", "applied", "if", "temp_dew", "is", "not", "provided", "then", "dew", "point", "improvements", "are", "not", "applied", "min_cos_zenith", "numeric", "default", "0", "065", "minimum", "value", "of", "cos", "zenith", "to", "allow", "when", "calculating", "global", "clearness", "index", "kt", "equivalent", "to", "zenith", "86", "273", "degrees", "max_zenith", "numeric", "default", "87", "maximum", "value", "of", "zenith", "to", "allow", "in", "dni", "calculation", "dni", "will", "be", "set", "to", "0", "for", "times", "with", "zenith", "values", "greater", "than", "max_zenith", "returns", "dni", "array", "like", "the", "modeled", "direct", "normal", "irradiance", "in", "w", "m", "2", "notes", "dirindex", "model", "requires", "time", "series", "data", "ie", "one", "of", "the", "inputs", "must", "be", "a", "vector", "of", "length", "2", "references", "1", "perez", "r", "ineichen", "p", "moore", "k", "kmiecik", "m", "chain", "c", "george", "r", "vignola", "f", "2002", "a", "new", "operational", "model", "for", "satellite", "derived", "irradiances", "description", "and", "validation", "solar", "energy", "73", "5", "307", "317", "dni_dirint", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "use_delta_kt_prime", "use_delta_kt_prime", "temp_dew", "temp_dew", "min_cos_zenith", "min_cos_zenith", "max_zenith", "max_zenith", "dni_dirint_clearsky", "dirint", "ghi_clearsky", "zenith", "times", "pressure", "pressure", "use_delta_kt_prime", "use_delta_kt_prime", "temp_dew", "temp_dew", "min_cos_zenith", "min_cos_zenith", "max_zenith", "max_zenith", "dni_dirindex", "dni_clearsky", "dni_dirint", "dni_dirint_clearsky", "dni_dirindex", "dni_dirindex", "0", "0", "return", "dni_dirindex"], "doc_len": 458}
{"doc_id": "pvlib/irradiance.py::gti_dirint", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "gti_dirint", "text": "文件路径: pvlib/irradiance.py\ndef gti_dirint(poa_global, aoi, solar_zenith, solar_azimuth, times,\n               surface_tilt, surface_azimuth, pressure=101325.,\n               use_delta_kt_prime=True, temp_dew=None, albedo=.25,\n               model='perez', model_perez='allsitescomposite1990',\n               calculate_gt_90=True, max_iterations=30):\n    \"\"\"\n    Determine GHI, DNI, DHI from POA global using the GTI DIRINT model.\n\n    The GTI DIRINT model is described in [1]_.\n\n    .. warning::\n\n        Model performance is poor for AOI greater than approximately\n        80 degrees `and` plane of array irradiance greater than\n        approximately 200 W/m^2.\n\n    Parameters\n    ----------\n    poa_global : array-like\n        Plane of array global irradiance in W/m^2.\n\n    aoi : array-like\n        Angle of incidence of solar rays with respect to the module\n        surface normal.\n\n    solar_zenith : array-like\n        True (not refraction-corrected) solar zenith angles in decimal\n        degrees.\n\n    solar_azimuth : array-like\n        Solar azimuth angles in decimal degrees.\n\n    times : DatetimeIndex\n        Time indices for the input array-like data.\n\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees. Tilt must be >=0 and\n        <=180. The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90).\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees. surface_azimuth must\n        be >=0 and <=360. The Azimuth convention is defined as degrees\n        east of north (e.g. North = 0, South=180 East = 90, West = 270).\n\n    pressure : numeric, default 101325.0\n        The site pressure in Pascal. Pressure may be measured or an\n        average pressure may be calculated from site altitude.\n\n    use_delta_kt_prime : bool, default True\n        If True, indicates that the stability index delta_kt_prime is\n        included in the model. The stability index adjusts the estimated\n        DNI in response to dynamics in the time series of GHI. It is\n        recommended that delta_kt_prime is not used if the time between\n        GHI points is 1.5 hours or greater. If use_delta_kt_prime=True,\n        input data must be Series.\n\n    temp_dew : None, float, or array-like, default None\n        Surface dew point temperatures, in degrees C. Values of temp_dew\n        may be numeric or NaN. Any single time period point with a\n        temp_dew=NaN does not have dew point improvements applied. If\n        temp_dew is not provided, then dew point improvements are not\n        applied.\n\n    albedo : numeric, default 0.25\n        Ground surface albedo. [unitless]\n\n    model : String, default 'perez'\n        Irradiance model.  See :py:func:`get_sky_diffuse` for allowed values.\n\n    model_perez : String, default 'allsitescomposite1990'\n        Used only if model='perez'. See :py:func:`perez`.\n\n    calculate_gt_90 : bool, default True\n        Controls if the algorithm evaluates inputs with AOI >= 90 degrees.\n        If False, returns nan for AOI >= 90 degrees. Significant speed ups\n        can be achieved by setting this parameter to False.\n\n    max_iterations : int, default 30\n        Maximum number of iterations for the aoi < 90 deg algorithm.\n\n    Returns\n    -------\n    data : DataFrame\n        Contains the following keys/columns:\n\n            * ``ghi``: the modeled global horizontal irradiance in W/m^2.\n            * ``dni``: the modeled direct normal irradiance in W/m^2.\n            * ``dhi``: the modeled diffuse horizontal irradiance in\n              W/m^2.\n\n    References\n    ----------\n    .. [1] B. Marion, A model for deriving the direct normal and\n           diffuse horizontal irradiance from the global tilted\n           irradiance, Solar Energy 122, 1037-1046.\n           :doi:`10.1016/j.solener.2015.10.024`\n    \"\"\"\n\n    aoi_lt_90 = aoi < 90\n\n    # for AOI less than 90 degrees\n    ghi, dni, dhi, kt_prime = _gti_dirint_lt_90(\n        poa_global, aoi, aoi_lt_90, solar_zenith, solar_azimuth, times,\n        surface_tilt, surface_azimuth, pressure=pressure,\n        use_delta_kt_prime=use_delta_kt_prime, temp_dew=temp_dew,\n        albedo=albedo, model=model, model_perez=model_perez,\n        max_iterations=max_iterations)\n\n    # for AOI greater than or equal to 90 degrees\n    if calculate_gt_90:\n        ghi_gte_90, dni_gte_90, dhi_gte_90 = _gti_dirint_gte_90(\n            poa_global, aoi, solar_zenith, solar_azimuth,\n            surface_tilt, times, kt_prime,\n            pressure=pressure, temp_dew=temp_dew, albedo=albedo)\n    else:\n        ghi_gte_90, dni_gte_90, dhi_gte_90 = np.nan, np.nan, np.nan\n\n    # put the AOI < 90 and AOI >= 90 conditions together\n    output = OrderedDict()\n    output['ghi'] = ghi.where(aoi_lt_90, ghi_gte_90)\n    output['dni'] = dni.where(aoi_lt_90, dni_gte_90)\n    output['dhi'] = dhi.where(aoi_lt_90, dhi_gte_90)\n\n    output = pd.DataFrame(output, index=times)\n\n    return output\n", "tokens": ["pvlib", "irradiance", "py", "def", "gti_dirint", "poa_global", "aoi", "solar_zenith", "solar_azimuth", "times", "surface_tilt", "surface_azimuth", "pressure", "101325", "use_delta_kt_prime", "true", "temp_dew", "none", "albedo", "25", "model", "perez", "model_perez", "allsitescomposite1990", "calculate_gt_90", "true", "max_iterations", "30", "determine", "ghi", "dni", "dhi", "from", "poa", "global", "using", "the", "gti", "dirint", "model", "the", "gti", "dirint", "model", "is", "described", "in", "1", "_", "warning", "model", "performance", "is", "poor", "for", "aoi", "greater", "than", "approximately", "80", "degrees", "and", "plane", "of", "array", "irradiance", "greater", "than", "approximately", "200", "w", "m", "2", "parameters", "poa_global", "array", "like", "plane", "of", "array", "global", "irradiance", "in", "w", "m", "2", "aoi", "array", "like", "angle", "of", "incidence", "of", "solar", "rays", "with", "respect", "to", "the", "module", "surface", "normal", "solar_zenith", "array", "like", "true", "not", "refraction", "corrected", "solar", "zenith", "angles", "in", "decimal", "degrees", "solar_azimuth", "array", "like", "solar", "azimuth", "angles", "in", "decimal", "degrees", "times", "datetimeindex", "time", "indices", "for", "the", "input", "array", "like", "data", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "tilt", "must", "be", "0", "and", "180", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "surface_azimuth", "must", "be", "0", "and", "360", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "pressure", "numeric", "default", "101325", "0", "the", "site", "pressure", "in", "pascal", "pressure", "may", "be", "measured", "or", "an", "average", "pressure", "may", "be", "calculated", "from", "site", "altitude", "use_delta_kt_prime", "bool", "default", "true", "if", "true", "indicates", "that", "the", "stability", "index", "delta_kt_prime", "is", "included", "in", "the", "model", "the", "stability", "index", "adjusts", "the", "estimated", "dni", "in", "response", "to", "dynamics", "in", "the", "time", "series", "of", "ghi", "it", "is", "recommended", "that", "delta_kt_prime", "is", "not", "used", "if", "the", "time", "between", "ghi", "points", "is", "1", "5", "hours", "or", "greater", "if", "use_delta_kt_prime", "true", "input", "data", "must", "be", "series", "temp_dew", "none", "float", "or", "array", "like", "default", "none", "surface", "dew", "point", "temperatures", "in", "degrees", "c", "values", "of", "temp_dew", "may", "be", "numeric", "or", "nan", "any", "single", "time", "period", "point", "with", "a", "temp_dew", "nan", "does", "not", "have", "dew", "point", "improvements", "applied", "if", "temp_dew", "is", "not", "provided", "then", "dew", "point", "improvements", "are", "not", "applied", "albedo", "numeric", "default", "0", "25", "ground", "surface", "albedo", "unitless", "model", "string", "default", "perez", "irradiance", "model", "see", "py", "func", "get_sky_diffuse", "for", "allowed", "values", "model_perez", "string", "default", "allsitescomposite1990", "used", "only", "if", "model", "perez", "see", "py", "func", "perez", "calculate_gt_90", "bool", "default", "true", "controls", "if", "the", "algorithm", "evaluates", "inputs", "with", "aoi", "90", "degrees", "if", "false", "returns", "nan", "for", "aoi", "90", "degrees", "significant", "speed", "ups", "can", "be", "achieved", "by", "setting", "this", "parameter", "to", "false", "max_iterations", "int", "default", "30", "maximum", "number", "of", "iterations", "for", "the", "aoi", "90", "deg", "algorithm", "returns", "data", "dataframe", "contains", "the", "following", "keys", "columns", "ghi", "the", "modeled", "global", "horizontal", "irradiance", "in", "w", "m", "2", "dni", "the", "modeled", "direct", "normal", "irradiance", "in", "w", "m", "2", "dhi", "the", "modeled", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "references", "1", "b", "marion", "a", "model", "for", "deriving", "the", "direct", "normal", "and", "diffuse", "horizontal", "irradiance", "from", "the", "global", "tilted", "irradiance", "solar", "energy", "122", "1037", "1046", "doi", "10", "1016", "j", "solener", "2015", "10", "024", "aoi_lt_90", "aoi", "90", "for", "aoi", "less", "than", "90", "degrees", "ghi", "dni", "dhi", "kt_prime", "_gti_dirint_lt_90", "poa_global", "aoi", "aoi_lt_90", "solar_zenith", "solar_azimuth", "times", "surface_tilt", "surface_azimuth", "pressure", "pressure", "use_delta_kt_prime", "use_delta_kt_prime", "temp_dew", "temp_dew", "albedo", "albedo", "model", "model", "model_perez", "model_perez", "max_iterations", "max_iterations", "for", "aoi", "greater", "than", "or", "equal", "to", "90", "degrees", "if", "calculate_gt_90", "ghi_gte_90", "dni_gte_90", "dhi_gte_90", "_gti_dirint_gte_90", "poa_global", "aoi", "solar_zenith", "solar_azimuth", "surface_tilt", "times", "kt_prime", "pressure", "pressure", "temp_dew", "temp_dew", "albedo", "albedo", "else", "ghi_gte_90", "dni_gte_90", "dhi_gte_90", "np", "nan", "np", "nan", "np", "nan", "put", "the", "aoi", "90", "and", "aoi", "90", "conditions", "together", "output", "ordereddict", "output", "ghi", "ghi", "where", "aoi_lt_90", "ghi_gte_90", "output", "dni", "dni", "where", "aoi_lt_90", "dni_gte_90", "output", "dhi", "dhi", "where", "aoi_lt_90", "dhi_gte_90", "output", "pd", "dataframe", "output", "index", "times", "return", "output"], "doc_len": 603}
{"doc_id": "pvlib/irradiance.py::_gti_dirint_lt_90", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_gti_dirint_lt_90", "text": "文件路径: pvlib/irradiance.py\ndef _gti_dirint_lt_90(poa_global, aoi, aoi_lt_90, solar_zenith, solar_azimuth,\n                      times, surface_tilt, surface_azimuth, pressure=101325.,\n                      use_delta_kt_prime=True, temp_dew=None, albedo=.25,\n                      model='perez', model_perez='allsitescomposite1990',\n                      max_iterations=30):\n    \"\"\"\n    GTI-DIRINT model for AOI < 90 degrees. See Marion 2015 Section 2.1.\n\n    See gti_dirint signature for parameter details.\n    \"\"\"\n    I0 = get_extra_radiation(times, 1370, 'spencer')\n    cos_zenith = tools.cosd(solar_zenith)\n    # I0h as in Marion 2015 eqns 1, 3\n    I0h = I0 * np.maximum(0.065, cos_zenith)\n\n    airmass = atmosphere.get_relative_airmass(solar_zenith, model='kasten1966')\n    airmass = atmosphere.get_absolute_airmass(airmass, pressure)\n\n    # these coeffs and diff variables and the loop below\n    # implement figure 1 of Marion 2015\n\n    # make coeffs that is at least 30 elements long so that all\n    # coeffs can be assigned as specified in Marion 2015.\n    # slice below will limit iterations if necessary\n    coeffs = np.empty(max(30, max_iterations))\n    coeffs[0:3] = 1\n    coeffs[3:10] = 0.5\n    coeffs[10:20] = 0.25\n    coeffs[20:] = 0.125\n    coeffs = coeffs[:max_iterations]  # covers case where max_iterations < 30\n\n    # initialize diff\n    diff = pd.Series(9999, index=times)\n    best_diff = diff\n\n    # initialize poa_global_i\n    poa_global_i = poa_global\n\n    for iteration, coeff in enumerate(coeffs):\n\n        # test if difference between modeled GTI and\n        # measured GTI (poa_global) is less than 1 W/m^2\n        # only test for aoi less than 90 deg\n        best_diff_lte_1 = best_diff <= 1\n        best_diff_lte_1_lt_90 = best_diff_lte_1[aoi_lt_90]\n        if best_diff_lte_1_lt_90.all():\n            # all aoi < 90 points have a difference <= 1, so break loop\n            break\n\n        # calculate kt and DNI from GTI\n        kt = clearness_index(poa_global_i, aoi, I0)  # kt from Marion eqn 2\n        disc_dni = np.maximum(_disc_kn(kt, airmass)[0] * I0, 0)\n        kt_prime = clearness_index_zenith_independent(kt, airmass)\n        # dirint DNI in Marion eqn 3\n        dni = _dirint_from_dni_ktprime(disc_dni, kt_prime, solar_zenith,\n                                       use_delta_kt_prime, temp_dew)\n\n        # calculate DHI using Marion eqn 3 (identify 1st term on RHS as GHI)\n        # I0h has a minimum zenith projection, but multiplier of DNI does not\n        ghi = kt * I0h                  # Kt * I0 * max(0.065, cos(zen))\n        dhi = ghi - dni * cos_zenith    # no cos(zen) restriction here\n\n        # following SSC code\n        dni = np.maximum(dni, 0)\n        ghi = np.maximum(ghi, 0)\n        dhi = np.maximum(dhi, 0)\n\n        # use DNI and DHI to model GTI\n        # GTI-DIRINT uses perez transposition model, but we allow for\n        # any model here\n        all_irrad = get_total_irradiance(\n            surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n            dni, ghi, dhi, dni_extra=I0, airmass=airmass,\n            albedo=albedo, model=model, model_perez=model_perez)\n\n        gti_model = all_irrad['poa_global']\n\n        # calculate new diff\n        diff = gti_model - poa_global\n\n        # determine if the new diff is smaller in magnitude\n        # than the old diff\n        diff_abs = diff.abs()\n        smallest_diff = diff_abs < best_diff\n\n        # save the best differences\n        best_diff = diff_abs.where(smallest_diff, best_diff)\n\n        # on first iteration, the best values are the only values\n        if iteration == 0:\n            best_ghi = ghi\n            best_dni = dni\n            best_dhi = dhi\n            best_kt_prime = kt_prime\n        else:\n            # save new DNI, DHI, DHI if they provide the best consistency\n            # otherwise use the older values.\n            best_ghi = ghi.where(smallest_diff, best_ghi)\n            best_dni = dni.where(smallest_diff, best_dni)\n            best_dhi = dhi.where(smallest_diff, best_dhi)\n            best_kt_prime = kt_prime.where(smallest_diff, best_kt_prime)\n\n        # calculate adjusted inputs for next iteration. Marion eqn 4\n        poa_global_i = np.maximum(1.0, poa_global_i - coeff * diff)\n    else:\n        # we are here because we ran out of coeffs to loop over and\n        # therefore we have exceeded max_iterations\n        import warnings\n        failed_points = best_diff[aoi_lt_90][~best_diff_lte_1_lt_90]\n        warnings.warn(\n            ('%s points failed to converge after %s iterations. best_diff:\\n%s'\n             % (len(failed_points), max_iterations, failed_points)),\n            RuntimeWarning)\n\n    # return the best data, whether or not the solution converged\n    return best_ghi, best_dni, best_dhi, best_kt_prime\n", "tokens": ["pvlib", "irradiance", "py", "def", "_gti_dirint_lt_90", "poa_global", "aoi", "aoi_lt_90", "solar_zenith", "solar_azimuth", "times", "surface_tilt", "surface_azimuth", "pressure", "101325", "use_delta_kt_prime", "true", "temp_dew", "none", "albedo", "25", "model", "perez", "model_perez", "allsitescomposite1990", "max_iterations", "30", "gti", "dirint", "model", "for", "aoi", "90", "degrees", "see", "marion", "2015", "section", "2", "1", "see", "gti_dirint", "signature", "for", "parameter", "details", "i0", "get_extra_radiation", "times", "1370", "spencer", "cos_zenith", "tools", "cosd", "solar_zenith", "i0h", "as", "in", "marion", "2015", "eqns", "1", "3", "i0h", "i0", "np", "maximum", "0", "065", "cos_zenith", "airmass", "atmosphere", "get_relative_airmass", "solar_zenith", "model", "kasten1966", "airmass", "atmosphere", "get_absolute_airmass", "airmass", "pressure", "these", "coeffs", "and", "diff", "variables", "and", "the", "loop", "below", "implement", "figure", "1", "of", "marion", "2015", "make", "coeffs", "that", "is", "at", "least", "30", "elements", "long", "so", "that", "all", "coeffs", "can", "be", "assigned", "as", "specified", "in", "marion", "2015", "slice", "below", "will", "limit", "iterations", "if", "necessary", "coeffs", "np", "empty", "max", "30", "max_iterations", "coeffs", "0", "3", "1", "coeffs", "3", "10", "0", "5", "coeffs", "10", "20", "0", "25", "coeffs", "20", "0", "125", "coeffs", "coeffs", "max_iterations", "covers", "case", "where", "max_iterations", "30", "initialize", "diff", "diff", "pd", "series", "9999", "index", "times", "best_diff", "diff", "initialize", "poa_global_i", "poa_global_i", "poa_global", "for", "iteration", "coeff", "in", "enumerate", "coeffs", "test", "if", "difference", "between", "modeled", "gti", "and", "measured", "gti", "poa_global", "is", "less", "than", "1", "w", "m", "2", "only", "test", "for", "aoi", "less", "than", "90", "deg", "best_diff_lte_1", "best_diff", "1", "best_diff_lte_1_lt_90", "best_diff_lte_1", "aoi_lt_90", "if", "best_diff_lte_1_lt_90", "all", "all", "aoi", "90", "points", "have", "a", "difference", "1", "so", "break", "loop", "break", "calculate", "kt", "and", "dni", "from", "gti", "kt", "clearness_index", "poa_global_i", "aoi", "i0", "kt", "from", "marion", "eqn", "2", "disc_dni", "np", "maximum", "_disc_kn", "kt", "airmass", "0", "i0", "0", "kt_prime", "clearness_index_zenith_independent", "kt", "airmass", "dirint", "dni", "in", "marion", "eqn", "3", "dni", "_dirint_from_dni_ktprime", "disc_dni", "kt_prime", "solar_zenith", "use_delta_kt_prime", "temp_dew", "calculate", "dhi", "using", "marion", "eqn", "3", "identify", "1st", "term", "on", "rhs", "as", "ghi", "i0h", "has", "a", "minimum", "zenith", "projection", "but", "multiplier", "of", "dni", "does", "not", "ghi", "kt", "i0h", "kt", "i0", "max", "0", "065", "cos", "zen", "dhi", "ghi", "dni", "cos_zenith", "no", "cos", "zen", "restriction", "here", "following", "ssc", "code", "dni", "np", "maximum", "dni", "0", "ghi", "np", "maximum", "ghi", "0", "dhi", "np", "maximum", "dhi", "0", "use", "dni", "and", "dhi", "to", "model", "gti", "gti", "dirint", "uses", "perez", "transposition", "model", "but", "we", "allow", "for", "any", "model", "here", "all_irrad", "get_total_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "i0", "airmass", "airmass", "albedo", "albedo", "model", "model", "model_perez", "model_perez", "gti_model", "all_irrad", "poa_global", "calculate", "new", "diff", "diff", "gti_model", "poa_global", "determine", "if", "the", "new", "diff", "is", "smaller", "in", "magnitude", "than", "the", "old", "diff", "diff_abs", "diff", "abs", "smallest_diff", "diff_abs", "best_diff", "save", "the", "best", "differences", "best_diff", "diff_abs", "where", "smallest_diff", "best_diff", "on", "first", "iteration", "the", "best", "values", "are", "the", "only", "values", "if", "iteration", "0", "best_ghi", "ghi", "best_dni", "dni", "best_dhi", "dhi", "best_kt_prime", "kt_prime", "else", "save", "new", "dni", "dhi", "dhi", "if", "they", "provide", "the", "best", "consistency", "otherwise", "use", "the", "older", "values", "best_ghi", "ghi", "where", "smallest_diff", "best_ghi", "best_dni", "dni", "where", "smallest_diff", "best_dni", "best_dhi", "dhi", "where", "smallest_diff", "best_dhi", "best_kt_prime", "kt_prime", "where", "smallest_diff", "best_kt_prime", "calculate", "adjusted", "inputs", "for", "next", "iteration", "marion", "eqn", "4", "poa_global_i", "np", "maximum", "1", "0", "poa_global_i", "coeff", "diff", "else", "we", "are", "here", "because", "we", "ran", "out", "of", "coeffs", "to", "loop", "over", "and", "therefore", "we", "have", "exceeded", "max_iterations", "import", "warnings", "failed_points", "best_diff", "aoi_lt_90", "best_diff_lte_1_lt_90", "warnings", "warn", "s", "points", "failed", "to", "converge", "after", "s", "iterations", "best_diff", "n", "s", "len", "failed_points", "max_iterations", "failed_points", "runtimewarning", "return", "the", "best", "data", "whether", "or", "not", "the", "solution", "converged", "return", "best_ghi", "best_dni", "best_dhi", "best_kt_prime"], "doc_len": 535}
{"doc_id": "pvlib/irradiance.py::_gti_dirint_gte_90", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_gti_dirint_gte_90", "text": "文件路径: pvlib/irradiance.py\ndef _gti_dirint_gte_90(poa_global, aoi, solar_zenith, solar_azimuth,\n                       surface_tilt, times, kt_prime,\n                       pressure=101325., temp_dew=None, albedo=.25):\n    \"\"\"\n    GTI-DIRINT model for AOI >= 90 degrees. See Marion 2015 Section 2.2.\n\n    See gti_dirint signature for parameter details.\n    \"\"\"\n    kt_prime_gte_90 = _gti_dirint_gte_90_kt_prime(aoi, solar_zenith,\n                                                  solar_azimuth, times,\n                                                  kt_prime)\n\n    I0 = get_extra_radiation(times, 1370, 'spencer')\n    airmass = atmosphere.get_relative_airmass(solar_zenith, model='kasten1966')\n    airmass = atmosphere.get_absolute_airmass(airmass, pressure)\n    kt = kt_prime_gte_90 * _kt_kt_prime_factor(airmass)\n    disc_dni = np.maximum(_disc_kn(kt, airmass)[0] * I0, 0)\n\n    dni_gte_90 = _dirint_from_dni_ktprime(disc_dni, kt_prime, solar_zenith,\n                                          False, temp_dew)\n\n    dni_gte_90_proj = dni_gte_90 * tools.cosd(solar_zenith)\n    cos_surface_tilt = tools.cosd(surface_tilt)\n\n    # isotropic sky plus ground diffuse\n    dhi_gte_90 = (\n        (2 * poa_global - dni_gte_90_proj * albedo * (1 - cos_surface_tilt)) /\n        (1 + cos_surface_tilt + albedo * (1 - cos_surface_tilt)))\n\n    ghi_gte_90 = dni_gte_90_proj + dhi_gte_90\n\n    return ghi_gte_90, dni_gte_90, dhi_gte_90\n", "tokens": ["pvlib", "irradiance", "py", "def", "_gti_dirint_gte_90", "poa_global", "aoi", "solar_zenith", "solar_azimuth", "surface_tilt", "times", "kt_prime", "pressure", "101325", "temp_dew", "none", "albedo", "25", "gti", "dirint", "model", "for", "aoi", "90", "degrees", "see", "marion", "2015", "section", "2", "2", "see", "gti_dirint", "signature", "for", "parameter", "details", "kt_prime_gte_90", "_gti_dirint_gte_90_kt_prime", "aoi", "solar_zenith", "solar_azimuth", "times", "kt_prime", "i0", "get_extra_radiation", "times", "1370", "spencer", "airmass", "atmosphere", "get_relative_airmass", "solar_zenith", "model", "kasten1966", "airmass", "atmosphere", "get_absolute_airmass", "airmass", "pressure", "kt", "kt_prime_gte_90", "_kt_kt_prime_factor", "airmass", "disc_dni", "np", "maximum", "_disc_kn", "kt", "airmass", "0", "i0", "0", "dni_gte_90", "_dirint_from_dni_ktprime", "disc_dni", "kt_prime", "solar_zenith", "false", "temp_dew", "dni_gte_90_proj", "dni_gte_90", "tools", "cosd", "solar_zenith", "cos_surface_tilt", "tools", "cosd", "surface_tilt", "isotropic", "sky", "plus", "ground", "diffuse", "dhi_gte_90", "2", "poa_global", "dni_gte_90_proj", "albedo", "1", "cos_surface_tilt", "1", "cos_surface_tilt", "albedo", "1", "cos_surface_tilt", "ghi_gte_90", "dni_gte_90_proj", "dhi_gte_90", "return", "ghi_gte_90", "dni_gte_90", "dhi_gte_90"], "doc_len": 113}
{"doc_id": "pvlib/irradiance.py::_gti_dirint_gte_90_kt_prime", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_gti_dirint_gte_90_kt_prime", "text": "文件路径: pvlib/irradiance.py\ndef _gti_dirint_gte_90_kt_prime(aoi, solar_zenith, solar_azimuth, times,\n                                kt_prime):\n    \"\"\"\n    Determine kt' values to be used in GTI-DIRINT AOI >= 90 deg case.\n    See Marion 2015 Section 2.2.\n\n    For AOI >= 90 deg: average of the kt_prime values for 65 < AOI < 80\n    in each day's morning and afternoon. Morning and afternoon are treated\n    separately.\n\n    For AOI < 90 deg: NaN.\n\n    See gti_dirint signature for parameter details.\n\n    Returns\n    -------\n    kt_prime_gte_90 : Series\n        Index is `times`.\n    \"\"\"\n    # kt_prime values from DIRINT calculation for AOI < 90 case\n    # set the kt_prime from sunrise to AOI=90 to be equal to\n    # the kt_prime for 65 < AOI < 80 during the morning.\n    # similar for the afternoon. repeat for every day.\n    aoi_gte_90 = aoi >= 90\n    aoi_65_80 = (aoi > 65) & (aoi < 80)\n    zenith_lt_90 = solar_zenith < 90\n    morning = solar_azimuth < 180\n    afternoon = solar_azimuth > 180\n    aoi_65_80_morning = aoi_65_80 & morning\n    aoi_65_80_afternoon = aoi_65_80 & afternoon\n    zenith_lt_90_aoi_gte_90_morning = zenith_lt_90 & aoi_gte_90 & morning\n    zenith_lt_90_aoi_gte_90_afternoon = zenith_lt_90 & aoi_gte_90 & afternoon\n\n    kt_prime_gte_90 = []\n    for date, data in kt_prime.groupby(times.date):\n        kt_prime_am_avg = data[aoi_65_80_morning].mean()\n        kt_prime_pm_avg = data[aoi_65_80_afternoon].mean()\n\n        kt_prime_by_date = pd.Series(np.nan, index=data.index)\n        kt_prime_by_date[zenith_lt_90_aoi_gte_90_morning] = kt_prime_am_avg\n        kt_prime_by_date[zenith_lt_90_aoi_gte_90_afternoon] = kt_prime_pm_avg\n        kt_prime_gte_90.append(kt_prime_by_date)\n    kt_prime_gte_90 = pd.concat(kt_prime_gte_90)\n\n    return kt_prime_gte_90\n", "tokens": ["pvlib", "irradiance", "py", "def", "_gti_dirint_gte_90_kt_prime", "aoi", "solar_zenith", "solar_azimuth", "times", "kt_prime", "determine", "kt", "values", "to", "be", "used", "in", "gti", "dirint", "aoi", "90", "deg", "case", "see", "marion", "2015", "section", "2", "2", "for", "aoi", "90", "deg", "average", "of", "the", "kt_prime", "values", "for", "65", "aoi", "80", "in", "each", "day", "s", "morning", "and", "afternoon", "morning", "and", "afternoon", "are", "treated", "separately", "for", "aoi", "90", "deg", "nan", "see", "gti_dirint", "signature", "for", "parameter", "details", "returns", "kt_prime_gte_90", "series", "index", "is", "times", "kt_prime", "values", "from", "dirint", "calculation", "for", "aoi", "90", "case", "set", "the", "kt_prime", "from", "sunrise", "to", "aoi", "90", "to", "be", "equal", "to", "the", "kt_prime", "for", "65", "aoi", "80", "during", "the", "morning", "similar", "for", "the", "afternoon", "repeat", "for", "every", "day", "aoi_gte_90", "aoi", "90", "aoi_65_80", "aoi", "65", "aoi", "80", "zenith_lt_90", "solar_zenith", "90", "morning", "solar_azimuth", "180", "afternoon", "solar_azimuth", "180", "aoi_65_80_morning", "aoi_65_80", "morning", "aoi_65_80_afternoon", "aoi_65_80", "afternoon", "zenith_lt_90_aoi_gte_90_morning", "zenith_lt_90", "aoi_gte_90", "morning", "zenith_lt_90_aoi_gte_90_afternoon", "zenith_lt_90", "aoi_gte_90", "afternoon", "kt_prime_gte_90", "for", "date", "data", "in", "kt_prime", "groupby", "times", "date", "kt_prime_am_avg", "data", "aoi_65_80_morning", "mean", "kt_prime_pm_avg", "data", "aoi_65_80_afternoon", "mean", "kt_prime_by_date", "pd", "series", "np", "nan", "index", "data", "index", "kt_prime_by_date", "zenith_lt_90_aoi_gte_90_morning", "kt_prime_am_avg", "kt_prime_by_date", "zenith_lt_90_aoi_gte_90_afternoon", "kt_prime_pm_avg", "kt_prime_gte_90", "append", "kt_prime_by_date", "kt_prime_gte_90", "pd", "concat", "kt_prime_gte_90", "return", "kt_prime_gte_90"], "doc_len": 181}
{"doc_id": "pvlib/irradiance.py::erbs", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "erbs", "text": "文件路径: pvlib/irradiance.py\ndef erbs(ghi, zenith, datetime_or_doy, min_cos_zenith=0.065, max_zenith=87):\n    r\"\"\"\n    Estimate DNI and DHI from GHI using the Erbs model.\n\n    The Erbs model [1]_ estimates the diffuse fraction DF from global\n    horizontal irradiance through an empirical relationship between DF\n    and the ratio of GHI to extraterrestrial irradiance, Kt. The\n    function uses the diffuse fraction to compute DHI as\n\n    .. math::\n\n        DHI = DF \\times GHI\n\n    DNI is then estimated as\n\n    .. math::\n\n        DNI = (GHI - DHI)/\\cos(Z)\n\n    where Z is the zenith angle.\n\n    Parameters\n    ----------\n    ghi: numeric\n        Global horizontal irradiance in W/m^2.\n    zenith: numeric\n        True (not refraction-corrected) zenith angles in decimal degrees.\n    datetime_or_doy : int, float, array, pd.DatetimeIndex\n        Day of year or array of days of year e.g.\n        pd.DatetimeIndex.dayofyear, or pd.DatetimeIndex.\n    min_cos_zenith : numeric, default 0.065\n        Minimum value of cos(zenith) to allow when calculating global\n        clearness index `kt`. Equivalent to zenith = 86.273 degrees.\n    max_zenith : numeric, default 87\n        Maximum value of zenith to allow in DNI calculation. DNI will be\n        set to 0 for times with zenith values greater than `max_zenith`.\n\n    Returns\n    -------\n    data : OrderedDict or DataFrame\n        Contains the following keys/columns:\n\n            * ``dni``: the modeled direct normal irradiance in W/m^2.\n            * ``dhi``: the modeled diffuse horizontal irradiance in\n              W/m^2.\n            * ``kt``: Ratio of global to extraterrestrial irradiance\n              on a horizontal plane.\n\n    References\n    ----------\n    .. [1] D. G. Erbs, S. A. Klein and J. A. Duffie, Estimation of the\n       diffuse radiation fraction for hourly, daily and monthly-average\n       global radiation, Solar Energy 28(4), pp 293-302, 1982. Eq. 1\n\n    See also\n    --------\n    dirint\n    disc\n    \"\"\"\n\n    dni_extra = get_extra_radiation(datetime_or_doy)\n\n    kt = clearness_index(ghi, zenith, dni_extra, min_cos_zenith=min_cos_zenith,\n                         max_clearness_index=1)\n\n    # For Kt <= 0.22, set the diffuse fraction\n    df = 1 - 0.09*kt\n\n    # For Kt > 0.22 and Kt <= 0.8, set the diffuse fraction\n    df = np.where((kt > 0.22) & (kt <= 0.8),\n                  0.9511 - 0.1604*kt + 4.388*kt**2 -\n                  16.638*kt**3 + 12.336*kt**4,\n                  df)\n\n    # For Kt > 0.8, set the diffuse fraction\n    df = np.where(kt > 0.8, 0.165, df)\n\n    dhi = df * ghi\n\n    dni = (ghi - dhi) / tools.cosd(zenith)\n    bad_values = (zenith > max_zenith) | (ghi < 0) | (dni < 0)\n    dni = np.where(bad_values, 0, dni)\n    # ensure that closure relationship remains valid\n    dhi = np.where(bad_values, ghi, dhi)\n\n    data = OrderedDict()\n    data['dni'] = dni\n    data['dhi'] = dhi\n    data['kt'] = kt\n\n    if isinstance(datetime_or_doy, pd.DatetimeIndex):\n        data = pd.DataFrame(data, index=datetime_or_doy)\n\n    return data\n", "tokens": ["pvlib", "irradiance", "py", "def", "erbs", "ghi", "zenith", "datetime_or_doy", "min_cos_zenith", "0", "065", "max_zenith", "87", "r", "estimate", "dni", "and", "dhi", "from", "ghi", "using", "the", "erbs", "model", "the", "erbs", "model", "1", "_", "estimates", "the", "diffuse", "fraction", "df", "from", "global", "horizontal", "irradiance", "through", "an", "empirical", "relationship", "between", "df", "and", "the", "ratio", "of", "ghi", "to", "extraterrestrial", "irradiance", "kt", "the", "function", "uses", "the", "diffuse", "fraction", "to", "compute", "dhi", "as", "math", "dhi", "df", "times", "ghi", "dni", "is", "then", "estimated", "as", "math", "dni", "ghi", "dhi", "cos", "z", "where", "z", "is", "the", "zenith", "angle", "parameters", "ghi", "numeric", "global", "horizontal", "irradiance", "in", "w", "m", "2", "zenith", "numeric", "true", "not", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "datetime_or_doy", "int", "float", "array", "pd", "datetimeindex", "day", "of", "year", "or", "array", "of", "days", "of", "year", "e", "g", "pd", "datetimeindex", "dayofyear", "or", "pd", "datetimeindex", "min_cos_zenith", "numeric", "default", "0", "065", "minimum", "value", "of", "cos", "zenith", "to", "allow", "when", "calculating", "global", "clearness", "index", "kt", "equivalent", "to", "zenith", "86", "273", "degrees", "max_zenith", "numeric", "default", "87", "maximum", "value", "of", "zenith", "to", "allow", "in", "dni", "calculation", "dni", "will", "be", "set", "to", "0", "for", "times", "with", "zenith", "values", "greater", "than", "max_zenith", "returns", "data", "ordereddict", "or", "dataframe", "contains", "the", "following", "keys", "columns", "dni", "the", "modeled", "direct", "normal", "irradiance", "in", "w", "m", "2", "dhi", "the", "modeled", "diffuse", "horizontal", "irradiance", "in", "w", "m", "2", "kt", "ratio", "of", "global", "to", "extraterrestrial", "irradiance", "on", "a", "horizontal", "plane", "references", "1", "d", "g", "erbs", "s", "a", "klein", "and", "j", "a", "duffie", "estimation", "of", "the", "diffuse", "radiation", "fraction", "for", "hourly", "daily", "and", "monthly", "average", "global", "radiation", "solar", "energy", "28", "4", "pp", "293", "302", "1982", "eq", "1", "see", "also", "dirint", "disc", "dni_extra", "get_extra_radiation", "datetime_or_doy", "kt", "clearness_index", "ghi", "zenith", "dni_extra", "min_cos_zenith", "min_cos_zenith", "max_clearness_index", "1", "for", "kt", "0", "22", "set", "the", "diffuse", "fraction", "df", "1", "0", "09", "kt", "for", "kt", "0", "22", "and", "kt", "0", "8", "set", "the", "diffuse", "fraction", "df", "np", "where", "kt", "0", "22", "kt", "0", "8", "0", "9511", "0", "1604", "kt", "4", "388", "kt", "2", "16", "638", "kt", "3", "12", "336", "kt", "4", "df", "for", "kt", "0", "8", "set", "the", "diffuse", "fraction", "df", "np", "where", "kt", "0", "8", "0", "165", "df", "dhi", "df", "ghi", "dni", "ghi", "dhi", "tools", "cosd", "zenith", "bad_values", "zenith", "max_zenith", "ghi", "0", "dni", "0", "dni", "np", "where", "bad_values", "0", "dni", "ensure", "that", "closure", "relationship", "remains", "valid", "dhi", "np", "where", "bad_values", "ghi", "dhi", "data", "ordereddict", "data", "dni", "dni", "data", "dhi", "dhi", "data", "kt", "kt", "if", "isinstance", "datetime_or_doy", "pd", "datetimeindex", "data", "pd", "dataframe", "data", "index", "datetime_or_doy", "return", "data"], "doc_len": 400}
{"doc_id": "pvlib/irradiance.py::campbell_norman", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "campbell_norman", "text": "文件路径: pvlib/irradiance.py\ndef campbell_norman(zenith, transmittance, pressure=101325.0,\n                    dni_extra=1367.0):\n    '''\n    Determine DNI, DHI, GHI from extraterrestrial flux, transmittance,\n    and atmospheric pressure.\n\n    Parameters\n    ----------\n    zenith: pd.Series\n        True (not refraction-corrected) zenith angles in decimal\n        degrees. If Z is a vector it must be of the same size as all\n        other vector inputs. Z must be >=0 and <=180.\n\n    transmittance: float\n        Atmospheric transmittance between 0 and 1.\n\n    pressure: float, default 101325.0\n        Air pressure\n\n    dni_extra: float, default 1367.0\n        Direct irradiance incident at the top of the atmosphere.\n\n    Returns\n    -------\n    irradiance: DataFrame\n        Modeled direct normal irradiance, direct horizontal irradiance,\n        and global horizontal irradiance in W/m^2\n\n    References\n    ----------\n    .. [1] Campbell, G. S., J. M. Norman (1998) An Introduction to\n       Environmental Biophysics. 2nd Ed. New York: Springer.\n    '''\n\n    tau = transmittance\n\n    airmass = atmosphere.get_relative_airmass(zenith, model='simple')\n    airmass = atmosphere.get_absolute_airmass(airmass, pressure=pressure)\n    dni = dni_extra*tau**airmass\n    cos_zen = tools.cosd(zenith)\n    dhi = 0.3 * (1.0 - tau**airmass) * dni_extra * cos_zen\n    ghi = dhi + dni * cos_zen\n\n    irrads = OrderedDict()\n    irrads['ghi'] = ghi\n    irrads['dni'] = dni\n    irrads['dhi'] = dhi\n\n    if isinstance(ghi, pd.Series):\n        irrads = pd.DataFrame(irrads)\n\n    return irrads\n", "tokens": ["pvlib", "irradiance", "py", "def", "campbell_norman", "zenith", "transmittance", "pressure", "101325", "0", "dni_extra", "1367", "0", "determine", "dni", "dhi", "ghi", "from", "extraterrestrial", "flux", "transmittance", "and", "atmospheric", "pressure", "parameters", "zenith", "pd", "series", "true", "not", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "if", "z", "is", "a", "vector", "it", "must", "be", "of", "the", "same", "size", "as", "all", "other", "vector", "inputs", "z", "must", "be", "0", "and", "180", "transmittance", "float", "atmospheric", "transmittance", "between", "0", "and", "1", "pressure", "float", "default", "101325", "0", "air", "pressure", "dni_extra", "float", "default", "1367", "0", "direct", "irradiance", "incident", "at", "the", "top", "of", "the", "atmosphere", "returns", "irradiance", "dataframe", "modeled", "direct", "normal", "irradiance", "direct", "horizontal", "irradiance", "and", "global", "horizontal", "irradiance", "in", "w", "m", "2", "references", "1", "campbell", "g", "s", "j", "m", "norman", "1998", "an", "introduction", "to", "environmental", "biophysics", "2nd", "ed", "new", "york", "springer", "tau", "transmittance", "airmass", "atmosphere", "get_relative_airmass", "zenith", "model", "simple", "airmass", "atmosphere", "get_absolute_airmass", "airmass", "pressure", "pressure", "dni", "dni_extra", "tau", "airmass", "cos_zen", "tools", "cosd", "zenith", "dhi", "0", "3", "1", "0", "tau", "airmass", "dni_extra", "cos_zen", "ghi", "dhi", "dni", "cos_zen", "irrads", "ordereddict", "irrads", "ghi", "ghi", "irrads", "dni", "dni", "irrads", "dhi", "dhi", "if", "isinstance", "ghi", "pd", "series", "irrads", "pd", "dataframe", "irrads", "return", "irrads"], "doc_len": 183}
{"doc_id": "pvlib/irradiance.py::_liujordan", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_liujordan", "text": "文件路径: pvlib/irradiance.py\ndef _liujordan(zenith, transmittance, airmass, dni_extra=1367.0):\n    '''\n    Determine DNI, DHI, GHI from extraterrestrial flux, transmittance,\n    and optical air mass number.\n\n    Liu and Jordan, 1960, developed a simplified direct radiation model.\n    DHI is from an empirical equation for diffuse radiation from Liu and\n    Jordan, 1960.\n\n    Parameters\n    ----------\n    zenith: pd.Series\n        True (not refraction-corrected) zenith angles in decimal\n        degrees. If Z is a vector it must be of the same size as all\n        other vector inputs. Z must be >=0 and <=180.\n\n    transmittance: float\n        Atmospheric transmittance between 0 and 1.\n\n    pressure: float, default 101325.0\n        Air pressure\n\n    dni_extra: float, default 1367.0\n        Direct irradiance incident at the top of the atmosphere.\n\n    Returns\n    -------\n    irradiance: DataFrame\n        Modeled direct normal irradiance, direct horizontal irradiance,\n        and global horizontal irradiance in W/m^2\n\n    References\n    ----------\n    .. [1] Campbell, G. S., J. M. Norman (1998) An Introduction to\n       Environmental Biophysics. 2nd Ed. New York: Springer.\n\n    .. [2] Liu, B. Y., R. C. Jordan, (1960). \"The interrelationship and\n       characteristic distribution of direct, diffuse, and total solar\n       radiation\".  Solar Energy 4:1-19\n    '''\n\n    tau = transmittance\n\n    dni = dni_extra*tau**airmass\n    dhi = 0.3 * (1.0 - tau**airmass) * dni_extra * np.cos(np.radians(zenith))\n    ghi = dhi + dni * np.cos(np.radians(zenith))\n\n    irrads = OrderedDict()\n    irrads['ghi'] = ghi\n    irrads['dni'] = dni\n    irrads['dhi'] = dhi\n\n    if isinstance(ghi, pd.Series):\n        irrads = pd.DataFrame(irrads)\n\n    return irrads\n", "tokens": ["pvlib", "irradiance", "py", "def", "_liujordan", "zenith", "transmittance", "airmass", "dni_extra", "1367", "0", "determine", "dni", "dhi", "ghi", "from", "extraterrestrial", "flux", "transmittance", "and", "optical", "air", "mass", "number", "liu", "and", "jordan", "1960", "developed", "a", "simplified", "direct", "radiation", "model", "dhi", "is", "from", "an", "empirical", "equation", "for", "diffuse", "radiation", "from", "liu", "and", "jordan", "1960", "parameters", "zenith", "pd", "series", "true", "not", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "if", "z", "is", "a", "vector", "it", "must", "be", "of", "the", "same", "size", "as", "all", "other", "vector", "inputs", "z", "must", "be", "0", "and", "180", "transmittance", "float", "atmospheric", "transmittance", "between", "0", "and", "1", "pressure", "float", "default", "101325", "0", "air", "pressure", "dni_extra", "float", "default", "1367", "0", "direct", "irradiance", "incident", "at", "the", "top", "of", "the", "atmosphere", "returns", "irradiance", "dataframe", "modeled", "direct", "normal", "irradiance", "direct", "horizontal", "irradiance", "and", "global", "horizontal", "irradiance", "in", "w", "m", "2", "references", "1", "campbell", "g", "s", "j", "m", "norman", "1998", "an", "introduction", "to", "environmental", "biophysics", "2nd", "ed", "new", "york", "springer", "2", "liu", "b", "y", "r", "c", "jordan", "1960", "the", "interrelationship", "and", "characteristic", "distribution", "of", "direct", "diffuse", "and", "total", "solar", "radiation", "solar", "energy", "4", "1", "19", "tau", "transmittance", "dni", "dni_extra", "tau", "airmass", "dhi", "0", "3", "1", "0", "tau", "airmass", "dni_extra", "np", "cos", "np", "radians", "zenith", "ghi", "dhi", "dni", "np", "cos", "np", "radians", "zenith", "irrads", "ordereddict", "irrads", "ghi", "ghi", "irrads", "dni", "dni", "irrads", "dhi", "dhi", "if", "isinstance", "ghi", "pd", "series", "irrads", "pd", "dataframe", "irrads", "return", "irrads"], "doc_len": 224}
{"doc_id": "pvlib/irradiance.py::_get_perez_coefficients", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_get_perez_coefficients", "text": "文件路径: pvlib/irradiance.py\ndef _get_perez_coefficients(perezmodel):\n    '''\n    Find coefficients for the Perez model\n\n    Parameters\n    ----------\n\n    perezmodel : string (optional, default='allsitescomposite1990')\n\n          a character string which selects the desired set of Perez\n          coefficients. If model is not provided as an input, the default,\n          '1990' will be used.\n\n    All possible model selections are:\n\n          * '1990'\n          * 'allsitescomposite1990' (same as '1990')\n          * 'allsitescomposite1988'\n          * 'sandiacomposite1988'\n          * 'usacomposite1988'\n          * 'france1988'\n          * 'phoenix1988'\n          * 'elmonte1988'\n          * 'osage1988'\n          * 'albuquerque1988'\n          * 'capecanaveral1988'\n          * 'albany1988'\n\n    Returns\n    --------\n    F1coeffs, F2coeffs : (array, array)\n          F1 and F2 coefficients for the Perez model\n\n    References\n    ----------\n    .. [1] Loutzenhiser P.G. et. al. \"Empirical validation of models to\n       compute solar irradiance on inclined surfaces for building energy\n       simulation\" 2007, Solar Energy vol. 81. pp. 254-267\n\n    .. [2] Perez, R., Seals, R., Ineichen, P., Stewart, R., Menicucci, D.,\n       1987. A new simplified version of the Perez diffuse irradiance model\n       for tilted surfaces. Solar Energy 39(3), 221-232.\n\n    .. [3] Perez, R., Ineichen, P., Seals, R., Michalsky, J., Stewart, R.,\n       1990. Modeling daylight availability and irradiance components from\n       direct and global irradiance. Solar Energy 44 (5), 271-289.\n\n    .. [4] Perez, R. et. al 1988. \"The Development and Verification of the\n       Perez Diffuse Radiation Model\". SAND88-7030\n\n    '''\n    coeffdict = {\n        'allsitescomposite1990': [\n            [-0.0080,    0.5880,   -0.0620,   -0.0600,    0.0720,   -0.0220],\n            [0.1300,    0.6830,   -0.1510,   -0.0190,    0.0660,   -0.0290],\n            [0.3300,    0.4870,   -0.2210,    0.0550,   -0.0640,   -0.0260],\n            [0.5680,    0.1870,   -0.2950,    0.1090,   -0.1520,   -0.0140],\n            [0.8730,   -0.3920,   -0.3620,    0.2260,   -0.4620,    0.0010],\n            [1.1320,   -1.2370,   -0.4120,    0.2880,   -0.8230,    0.0560],\n            [1.0600,   -1.6000,   -0.3590,    0.2640,   -1.1270,    0.1310],\n            [0.6780,   -0.3270,   -0.2500,    0.1560,   -1.3770,    0.2510]],\n        'allsitescomposite1988': [\n            [-0.0180,    0.7050,   -0.071,   -0.0580,    0.1020,   -0.0260],\n            [0.1910,    0.6450,   -0.1710,    0.0120,    0.0090,   -0.0270],\n            [0.4400,    0.3780,   -0.2560,    0.0870,   -0.1040,   -0.0250],\n            [0.7560,   -0.1210,   -0.3460,    0.1790,   -0.3210,   -0.0080],\n            [0.9960,   -0.6450,   -0.4050,    0.2600,   -0.5900,    0.0170],\n            [1.0980,   -1.2900,   -0.3930,    0.2690,   -0.8320,    0.0750],\n            [0.9730,   -1.1350,   -0.3780,    0.1240,   -0.2580,    0.1490],\n            [0.6890,   -0.4120,   -0.2730,    0.1990,   -1.6750,    0.2370]],\n        'sandiacomposite1988': [\n            [-0.1960,    1.0840,   -0.0060,   -0.1140,    0.1800,   -0.0190],\n            [0.2360,    0.5190,   -0.1800,   -0.0110,    0.0200,   -0.0380],\n            [0.4540,    0.3210,   -0.2550,    0.0720,   -0.0980,   -0.0460],\n            [0.8660,   -0.3810,   -0.3750,    0.2030,   -0.4030,   -0.0490],\n            [1.0260,   -0.7110,   -0.4260,    0.2730,   -0.6020,   -0.0610],\n            [0.9780,   -0.9860,   -0.3500,    0.2800,   -0.9150,   -0.0240],\n            [0.7480,   -0.9130,   -0.2360,    0.1730,   -1.0450,    0.0650],\n            [0.3180,   -0.7570,    0.1030,    0.0620,   -1.6980,    0.2360]],\n        'usacomposite1988': [\n            [-0.0340,    0.6710,   -0.0590,   -0.0590,    0.0860,   -0.0280],\n            [0.2550,    0.4740,   -0.1910,    0.0180,   -0.0140,   -0.0330],\n            [0.4270,    0.3490,   -0.2450,    0.0930,   -0.1210,   -0.0390],\n            [0.7560,   -0.2130,   -0.3280,    0.1750,   -0.3040,   -0.0270],\n            [1.0200,   -0.8570,   -0.3850,    0.2800,   -0.6380,   -0.0190],\n            [1.0500,   -1.3440,   -0.3480,    0.2800,   -0.8930,    0.0370],\n            [0.9740,   -1.5070,   -0.3700,    0.1540,   -0.5680,    0.1090],\n            [0.7440,   -1.8170,   -0.2560,    0.2460,   -2.6180,    0.2300]],\n        'france1988': [\n            [0.0130,    0.7640,   -0.1000,   -0.0580,    0.1270,   -0.0230],\n            [0.0950,    0.9200,   -0.1520,         0,    0.0510,   -0.0200],\n            [0.4640,    0.4210,   -0.2800,    0.0640,   -0.0510,   -0.0020],\n            [0.7590,   -0.0090,   -0.3730,    0.2010,   -0.3820,    0.0100],\n            [0.9760,   -0.4000,   -0.4360,    0.2710,   -0.6380,    0.0510],\n            [1.1760,   -1.2540,   -0.4620,    0.2950,   -0.9750,    0.1290],\n            [1.1060,   -1.5630,   -0.3980,    0.3010,   -1.4420,    0.2120],\n            [0.9340,   -1.5010,   -0.2710,    0.4200,   -2.9170,    0.2490]],\n        'phoenix1988': [\n            [-0.0030,    0.7280,   -0.0970,   -0.0750,    0.1420,   -0.0430],\n            [0.2790,    0.3540,   -0.1760,    0.0300,   -0.0550,   -0.0540],\n            [0.4690,    0.1680,   -0.2460,    0.0480,   -0.0420,   -0.0570],\n            [0.8560,   -0.5190,   -0.3400,    0.1760,   -0.3800,   -0.0310],\n            [0.9410,   -0.6250,   -0.3910,    0.1880,   -0.3600,   -0.0490],\n            [1.0560,   -1.1340,   -0.4100,    0.2810,   -0.7940,   -0.0650],\n            [0.9010,   -2.1390,   -0.2690,    0.1180,   -0.6650,    0.0460],\n            [0.1070,    0.4810,    0.1430,   -0.1110,   -0.1370,    0.2340]],\n        'elmonte1988': [\n            [0.0270,    0.7010,   -0.1190,   -0.0580,    0.1070,  -0.0600],\n            [0.1810,    0.6710,   -0.1780,   -0.0790,    0.1940,  -0.0350],\n            [0.4760,    0.4070,   -0.2880,    0.0540,   -0.0320,  -0.0550],\n            [0.8750,   -0.2180,   -0.4030,    0.1870,   -0.3090,  -0.0610],\n            [1.1660,   -1.0140,   -0.4540,    0.2110,   -0.4100,  -0.0440],\n            [1.1430,   -2.0640,   -0.2910,    0.0970,   -0.3190,   0.0530],\n            [1.0940,   -2.6320,   -0.2590,    0.0290,   -0.4220,   0.1470],\n            [0.1550,    1.7230,    0.1630,   -0.1310,   -0.0190,   0.2770]],\n        'osage1988': [\n            [-0.3530,    1.4740,   0.0570,   -0.1750,    0.3120,   0.0090],\n            [0.3630,    0.2180,  -0.2120,    0.0190,   -0.0340,  -0.0590],\n            [-0.0310,    1.2620,  -0.0840,   -0.0820,    0.2310,  -0.0170],\n            [0.6910,    0.0390,  -0.2950,    0.0910,   -0.1310,  -0.0350],\n            [1.1820,   -1.3500,  -0.3210,    0.4080,   -0.9850,  -0.0880],\n            [0.7640,    0.0190,  -0.2030,    0.2170,   -0.2940,  -0.1030],\n            [0.2190,    1.4120,   0.2440,    0.4710,   -2.9880,   0.0340],\n            [3.5780,   22.2310, -10.7450,    2.4260,    4.8920,  -5.6870]],\n        'albuquerque1988': [\n            [0.0340,    0.5010,  -0.0940,   -0.0630,    0.1060,  -0.0440],\n            [0.2290,    0.4670,  -0.1560,   -0.0050,   -0.0190,  -0.0230],\n            [0.4860,    0.2410,  -0.2530,    0.0530,   -0.0640,  -0.0220],\n            [0.8740,   -0.3930,  -0.3970,    0.1810,   -0.3270,  -0.0370],\n            [1.1930,   -1.2960,  -0.5010,    0.2810,   -0.6560,  -0.0450],\n            [1.0560,   -1.7580,  -0.3740,    0.2260,   -0.7590,   0.0340],\n            [0.9010,   -4.7830,  -0.1090,    0.0630,   -0.9700,   0.1960],\n            [0.8510,   -7.0550,  -0.0530,    0.0600,   -2.8330,   0.3300]],\n        'capecanaveral1988': [\n            [0.0750,    0.5330,   -0.1240,  -0.0670,   0.0420,  -0.0200],\n            [0.2950,    0.4970,   -0.2180,  -0.0080,   0.0030,  -0.0290],\n            [0.5140,    0.0810,   -0.2610,   0.0750,  -0.1600,  -0.0290],\n            [0.7470,   -0.3290,   -0.3250,   0.1810,  -0.4160,  -0.0300],\n            [0.9010,   -0.8830,   -0.2970,   0.1780,  -0.4890,   0.0080],\n            [0.5910,   -0.0440,   -0.1160,   0.2350,  -0.9990,   0.0980],\n            [0.5370,   -2.4020,    0.3200,   0.1690,  -1.9710,   0.3100],\n            [-0.8050,    4.5460,    1.0720,  -0.2580,  -0.9500,    0.7530]],\n        'albany1988': [\n            [0.0120,    0.5540,   -0.0760, -0.0520,   0.0840,  -0.0290],\n            [0.2670,    0.4370,   -0.1940,  0.0160,   0.0220,  -0.0360],\n            [0.4200,    0.3360,   -0.2370,  0.0740,  -0.0520,  -0.0320],\n            [0.6380,   -0.0010,   -0.2810,  0.1380,  -0.1890,  -0.0120],\n            [1.0190,   -1.0270,   -0.3420,  0.2710,  -0.6280,   0.0140],\n            [1.1490,   -1.9400,   -0.3310,  0.3220,  -1.0970,   0.0800],\n            [1.4340,   -3.9940,   -0.4920,  0.4530,  -2.3760,   0.1170],\n            [1.0070,   -2.2920,   -0.4820,  0.3900,  -3.3680,   0.2290]], }\n\n    array = np.array(coeffdict[perezmodel])\n\n    F1coeffs = array[:, 0:3]\n    F2coeffs = array[:, 3:7]\n\n    return F1coeffs, F2coeffs\n", "tokens": ["pvlib", "irradiance", "py", "def", "_get_perez_coefficients", "perezmodel", "find", "coefficients", "for", "the", "perez", "model", "parameters", "perezmodel", "string", "optional", "default", "allsitescomposite1990", "a", "character", "string", "which", "selects", "the", "desired", "set", "of", "perez", "coefficients", "if", "model", "is", "not", "provided", "as", "an", "input", "the", "default", "1990", "will", "be", "used", "all", "possible", "model", "selections", "are", "1990", "allsitescomposite1990", "same", "as", "1990", "allsitescomposite1988", "sandiacomposite1988", "usacomposite1988", "france1988", "phoenix1988", "elmonte1988", "osage1988", "albuquerque1988", "capecanaveral1988", "albany1988", "returns", "f1coeffs", "f2coeffs", "array", "array", "f1", "and", "f2", "coefficients", "for", "the", "perez", "model", "references", "1", "loutzenhiser", "p", "g", "et", "al", "empirical", "validation", "of", "models", "to", "compute", "solar", "irradiance", "on", "inclined", "surfaces", "for", "building", "energy", "simulation", "2007", "solar", "energy", "vol", "81", "pp", "254", "267", "2", "perez", "r", "seals", "r", "ineichen", "p", "stewart", "r", "menicucci", "d", "1987", "a", "new", "simplified", "version", "of", "the", "perez", "diffuse", "irradiance", "model", "for", "tilted", "surfaces", "solar", "energy", "39", "3", "221", "232", "3", "perez", "r", "ineichen", "p", "seals", "r", "michalsky", "j", "stewart", "r", "1990", "modeling", "daylight", "availability", "and", "irradiance", "components", "from", "direct", "and", "global", "irradiance", "solar", "energy", "44", "5", "271", "289", "4", "perez", "r", "et", "al", "1988", "the", "development", "and", "verification", "of", "the", "perez", "diffuse", "radiation", "model", "sand88", "7030", "coeffdict", "allsitescomposite1990", "0", "0080", "0", "5880", "0", "0620", "0", "0600", "0", "0720", "0", "0220", "0", "1300", "0", "6830", "0", "1510", "0", "0190", "0", "0660", "0", "0290", "0", "3300", "0", "4870", "0", "2210", "0", "0550", "0", "0640", "0", "0260", "0", "5680", "0", "1870", "0", "2950", "0", "1090", "0", "1520", "0", "0140", "0", "8730", "0", "3920", "0", "3620", "0", "2260", "0", "4620", "0", "0010", "1", "1320", "1", "2370", "0", "4120", "0", "2880", "0", "8230", "0", "0560", "1", "0600", "1", "6000", "0", "3590", "0", "2640", "1", "1270", "0", "1310", "0", "6780", "0", "3270", "0", "2500", "0", "1560", "1", "3770", "0", "2510", "allsitescomposite1988", "0", "0180", "0", "7050", "0", "071", "0", "0580", "0", "1020", "0", "0260", "0", "1910", "0", "6450", "0", "1710", "0", "0120", "0", "0090", "0", "0270", "0", "4400", "0", "3780", "0", "2560", "0", "0870", "0", "1040", "0", "0250", "0", "7560", "0", "1210", "0", "3460", "0", "1790", "0", "3210", "0", "0080", "0", "9960", "0", "6450", "0", "4050", "0", "2600", "0", "5900", "0", "0170", "1", "0980", "1", "2900", "0", "3930", "0", "2690", "0", "8320", "0", "0750", "0", "9730", "1", "1350", "0", "3780", "0", "1240", "0", "2580", "0", "1490", "0", "6890", "0", "4120", "0", "2730", "0", "1990", "1", "6750", "0", "2370", "sandiacomposite1988", "0", "1960", "1", "0840", "0", "0060", "0", "1140", "0", "1800", "0", "0190", "0", "2360", "0", "5190", "0", "1800", "0", "0110", "0", "0200", "0", "0380", "0", "4540", "0", "3210", "0", "2550", "0", "0720", "0", "0980", "0", "0460", "0", "8660", "0", "3810", "0", "3750", "0", "2030", "0", "4030", "0", "0490", "1", "0260", "0", "7110", "0", "4260", "0", "2730", "0", "6020", "0", "0610", "0", "9780", "0", "9860", "0", "3500", "0", "2800", "0", "9150", "0", "0240", "0", "7480", "0", "9130", "0", "2360", "0", "1730", "1", "0450", "0", "0650", "0", "3180", "0", "7570", "0", "1030", "0", "0620", "1", "6980", "0", "2360", "usacomposite1988", "0", "0340", "0", "6710", "0", "0590", "0", "0590", "0", "0860", "0", "0280", "0", "2550", "0", "4740", "0", "1910", "0", "0180", "0", "0140", "0", "0330", "0", "4270", "0", "3490", "0", "2450", "0", "0930", "0", "1210", "0", "0390", "0", "7560", "0", "2130", "0", "3280", "0", "1750", "0", "3040", "0", "0270", "1", "0200", "0", "8570", "0", "3850", "0", "2800", "0", "6380", "0", "0190", "1", "0500", "1", "3440", "0", "3480", "0", "2800", "0", "8930", "0", "0370", "0", "9740", "1", "5070", "0", "3700", "0", "1540", "0", "5680", "0", "1090", "0", "7440", "1", "8170", "0", "2560", "0", "2460", "2", "6180", "0", "2300", "france1988", "0", "0130", "0", "7640", "0", "1000", "0", "0580", "0", "1270", "0", "0230", "0", "0950", "0", "9200", "0", "1520", "0", "0", "0510", "0", "0200", "0", "4640", "0", "4210", "0", "2800", "0", "0640", "0", "0510", "0", "0020", "0", "7590", "0", "0090", "0", "3730", "0", "2010", "0", "3820", "0", "0100", "0", "9760", "0", "4000", "0", "4360", "0", "2710", "0", "6380", "0", "0510", "1", "1760", "1", "2540", "0", "4620", "0", "2950", "0", "9750", "0", "1290", "1", "1060", "1", "5630", "0", "3980", "0", "3010", "1", "4420", "0", "2120", "0", "9340", "1", "5010", "0", "2710", "0", "4200", "2", "9170", "0", "2490", "phoenix1988", "0", "0030", "0", "7280", "0", "0970", "0", "0750", "0", "1420", "0", "0430", "0", "2790", "0", "3540", "0", "1760", "0", "0300", "0", "0550", "0", "0540", "0", "4690", "0", "1680", "0", "2460", "0", "0480", "0", "0420", "0", "0570", "0", "8560", "0", "5190", "0", "3400", "0", "1760", "0", "3800", "0", "0310", "0", "9410", "0", "6250", "0", "3910", "0", "1880", "0", "3600", "0", "0490", "1", "0560", "1", "1340", "0", "4100", "0", "2810", "0", "7940", "0", "0650", "0", "9010", "2", "1390", "0", "2690", "0", "1180", "0", "6650", "0", "0460", "0", "1070", "0", "4810", "0", "1430", "0", "1110", "0", "1370", "0", "2340", "elmonte1988", "0", "0270", "0", "7010", "0", "1190", "0", "0580", "0", "1070", "0", "0600", "0", "1810", "0", "6710", "0", "1780", "0", "0790", "0", "1940", "0", "0350", "0", "4760", "0", "4070", "0", "2880", "0", "0540", "0", "0320", "0", "0550", "0", "8750", "0", "2180", "0", "4030", "0", "1870", "0", "3090", "0", "0610", "1", "1660", "1", "0140", "0", "4540", "0", "2110", "0", "4100", "0", "0440", "1", "1430", "2", "0640", "0", "2910", "0", "0970", "0", "3190", "0", "0530", "1", "0940", "2", "6320", "0", "2590", "0", "0290", "0", "4220", "0", "1470", "0", "1550", "1", "7230", "0", "1630", "0", "1310", "0", "0190", "0", "2770", "osage1988", "0", "3530", "1", "4740", "0", "0570", "0", "1750", "0", "3120", "0", "0090", "0", "3630", "0", "2180", "0", "2120", "0", "0190", "0", "0340", "0", "0590", "0", "0310", "1", "2620", "0", "0840", "0", "0820", "0", "2310", "0", "0170", "0", "6910", "0", "0390", "0", "2950", "0", "0910", "0", "1310", "0", "0350", "1", "1820", "1", "3500", "0", "3210", "0", "4080", "0", "9850", "0", "0880", "0", "7640", "0", "0190", "0", "2030", "0", "2170", "0", "2940", "0", "1030", "0", "2190", "1", "4120", "0", "2440", "0", "4710", "2", "9880", "0", "0340", "3", "5780", "22", "2310", "10", "7450", "2", "4260", "4", "8920", "5", "6870", "albuquerque1988", "0", "0340", "0", "5010", "0", "0940", "0", "0630", "0", "1060", "0", "0440", "0", "2290", "0", "4670", "0", "1560", "0", "0050", "0", "0190", "0", "0230", "0", "4860", "0", "2410", "0", "2530", "0", "0530", "0", "0640", "0", "0220", "0", "8740", "0", "3930", "0", "3970", "0", "1810", "0", "3270", "0", "0370", "1", "1930", "1", "2960", "0", "5010", "0", "2810", "0", "6560", "0", "0450", "1", "0560", "1", "7580", "0", "3740", "0", "2260", "0", "7590", "0", "0340", "0", "9010", "4", "7830", "0", "1090", "0", "0630", "0", "9700", "0", "1960", "0", "8510", "7", "0550", "0", "0530", "0", "0600", "2", "8330", "0", "3300", "capecanaveral1988", "0", "0750", "0", "5330", "0", "1240", "0", "0670", "0", "0420", "0", "0200", "0", "2950", "0", "4970", "0", "2180", "0", "0080", "0", "0030", "0", "0290", "0", "5140", "0", "0810", "0", "2610", "0", "0750", "0", "1600", "0", "0290", "0", "7470", "0", "3290", "0", "3250", "0", "1810", "0", "4160", "0", "0300", "0", "9010", "0", "8830", "0", "2970", "0", "1780", "0", "4890", "0", "0080", "0", "5910", "0", "0440", "0", "1160", "0", "2350", "0", "9990", "0", "0980", "0", "5370", "2", "4020", "0", "3200", "0", "1690", "1", "9710", "0", "3100", "0", "8050", "4", "5460", "1", "0720", "0", "2580", "0", "9500", "0", "7530", "albany1988", "0", "0120", "0", "5540", "0", "0760", "0", "0520", "0", "0840", "0", "0290", "0", "2670", "0", "4370", "0", "1940", "0", "0160", "0", "0220", "0", "0360", "0", "4200", "0", "3360", "0", "2370", "0", "0740", "0", "0520", "0", "0320", "0", "6380", "0", "0010", "0", "2810", "0", "1380", "0", "1890", "0", "0120", "1", "0190", "1", "0270", "0", "3420", "0", "2710", "0", "6280", "0", "0140", "1", "1490", "1", "9400", "0", "3310", "0", "3220", "1", "0970", "0", "0800", "1", "4340", "3", "9940", "0", "4920", "0", "4530", "2", "3760", "0", "1170", "1", "0070", "2", "2920", "0", "4820", "0", "3900", "3", "3680", "0", "2290", "array", "np", "array", "coeffdict", "perezmodel", "f1coeffs", "array", "0", "3", "f2coeffs", "array", "3", "7", "return", "f1coeffs", "f2coeffs"], "doc_len": 1267}
{"doc_id": "pvlib/irradiance.py::_get_dirint_coeffs", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "_get_dirint_coeffs", "text": "文件路径: pvlib/irradiance.py\ndef _get_dirint_coeffs():\n    \"\"\"\n    A place to stash the dirint coefficients.\n\n    Returns\n    -------\n    np.array with shape ``(6, 6, 7, 5)``.\n    Ordering is ``[kt_prime_bin, zenith_bin, delta_kt_prime_bin, w_bin]``\n    \"\"\"\n\n    # To allow for maximum copy/paste from the MATLAB 1-indexed code,\n    # we create and assign values to an oversized array.\n    # Then, we return the [1:, 1:, :, :] slice.\n\n    coeffs = np.zeros((7, 7, 7, 5))\n\n    coeffs[1, 1, :, :] = [\n        [0.385230, 0.385230, 0.385230, 0.462880, 0.317440],\n        [0.338390, 0.338390, 0.221270, 0.316730, 0.503650],\n        [0.235680, 0.235680, 0.241280, 0.157830, 0.269440],\n        [0.830130, 0.830130, 0.171970, 0.841070, 0.457370],\n        [0.548010, 0.548010, 0.478000, 0.966880, 1.036370],\n        [0.548010, 0.548010, 1.000000, 3.012370, 1.976540],\n        [0.582690, 0.582690, 0.229720, 0.892710, 0.569950]]\n\n    coeffs[1, 2, :, :] = [\n        [0.131280, 0.131280, 0.385460, 0.511070, 0.127940],\n        [0.223710, 0.223710, 0.193560, 0.304560, 0.193940],\n        [0.229970, 0.229970, 0.275020, 0.312730, 0.244610],\n        [0.090100, 0.184580, 0.260500, 0.687480, 0.579440],\n        [0.131530, 0.131530, 0.370190, 1.380350, 1.052270],\n        [1.116250, 1.116250, 0.928030, 3.525490, 2.316920],\n        [0.090100, 0.237000, 0.300040, 0.812470, 0.664970]]\n\n    coeffs[1, 3, :, :] = [\n        [0.587510, 0.130000, 0.400000, 0.537210, 0.832490],\n        [0.306210, 0.129830, 0.204460, 0.500000, 0.681640],\n        [0.224020, 0.260620, 0.334080, 0.501040, 0.350470],\n        [0.421540, 0.753970, 0.750660, 3.706840, 0.983790],\n        [0.706680, 0.373530, 1.245670, 0.864860, 1.992630],\n        [4.864400, 0.117390, 0.265180, 0.359180, 3.310820],\n        [0.392080, 0.493290, 0.651560, 1.932780, 0.898730]]\n\n    coeffs[1, 4, :, :] = [\n        [0.126970, 0.126970, 0.126970, 0.126970, 0.126970],\n        [0.810820, 0.810820, 0.810820, 0.810820, 0.810820],\n        [3.241680, 2.500000, 2.291440, 2.291440, 2.291440],\n        [4.000000, 3.000000, 2.000000, 0.975430, 1.965570],\n        [12.494170, 12.494170, 8.000000, 5.083520, 8.792390],\n        [21.744240, 21.744240, 21.744240, 21.744240, 21.744240],\n        [3.241680, 12.494170, 1.620760, 1.375250, 2.331620]]\n\n    coeffs[1, 5, :, :] = [\n        [0.126970, 0.126970, 0.126970, 0.126970, 0.126970],\n        [0.810820, 0.810820, 0.810820, 0.810820, 0.810820],\n        [3.241680, 2.500000, 2.291440, 2.291440, 2.291440],\n        [4.000000, 3.000000, 2.000000, 0.975430, 1.965570],\n        [12.494170, 12.494170, 8.000000, 5.083520, 8.792390],\n        [21.744240, 21.744240, 21.744240, 21.744240, 21.744240],\n        [3.241680, 12.494170, 1.620760, 1.375250, 2.331620]]\n\n    coeffs[1, 6, :, :] = [\n        [0.126970, 0.126970, 0.126970, 0.126970, 0.126970],\n        [0.810820, 0.810820, 0.810820, 0.810820, 0.810820],\n        [3.241680, 2.500000, 2.291440, 2.291440, 2.291440],\n        [4.000000, 3.000000, 2.000000, 0.975430, 1.965570],\n        [12.494170, 12.494170, 8.000000, 5.083520, 8.792390],\n        [21.744240, 21.744240, 21.744240, 21.744240, 21.744240],\n        [3.241680, 12.494170, 1.620760, 1.375250, 2.331620]]\n\n    coeffs[2, 1, :, :] = [\n        [0.337440, 0.337440, 0.969110, 1.097190, 1.116080],\n        [0.337440, 0.337440, 0.969110, 1.116030, 0.623900],\n        [0.337440, 0.337440, 1.530590, 1.024420, 0.908480],\n        [0.584040, 0.584040, 0.847250, 0.914940, 1.289300],\n        [0.337440, 0.337440, 0.310240, 1.435020, 1.852830],\n        [0.337440, 0.337440, 1.015010, 1.097190, 2.117230],\n        [0.337440, 0.337440, 0.969110, 1.145730, 1.476400]]\n\n    coeffs[2, 2, :, :] = [\n        [0.300000, 0.300000, 0.700000, 1.100000, 0.796940],\n        [0.219870, 0.219870, 0.526530, 0.809610, 0.649300],\n        [0.386650, 0.386650, 0.119320, 0.576120, 0.685460],\n        [0.746730, 0.399830, 0.470970, 0.986530, 0.785370],\n        [0.575420, 0.936700, 1.649200, 1.495840, 1.335590],\n        [1.319670, 4.002570, 1.276390, 2.644550, 2.518670],\n        [0.665190, 0.678910, 1.012360, 1.199940, 0.986580]]\n\n    coeffs[2, 3, :, :] = [\n        [0.378870, 0.974060, 0.500000, 0.491880, 0.665290],\n        [0.105210, 0.263470, 0.407040, 0.553460, 0.582590],\n        [0.312900, 0.345240, 1.144180, 0.854790, 0.612280],\n        [0.119070, 0.365120, 0.560520, 0.793720, 0.802600],\n        [0.781610, 0.837390, 1.270420, 1.537980, 1.292950],\n        [1.152290, 1.152290, 1.492080, 1.245370, 2.177100],\n        [0.424660, 0.529550, 0.966910, 1.033460, 0.958730]]\n\n    coeffs[2, 4, :, :] = [\n        [0.310590, 0.714410, 0.252450, 0.500000, 0.607600],\n        [0.975190, 0.363420, 0.500000, 0.400000, 0.502800],\n        [0.175580, 0.196250, 0.476360, 1.072470, 0.490510],\n        [0.719280, 0.698620, 0.657770, 1.190840, 0.681110],\n        [0.426240, 1.464840, 0.678550, 1.157730, 0.978430],\n        [2.501120, 1.789130, 1.387090, 2.394180, 2.394180],\n        [0.491640, 0.677610, 0.685610, 1.082400, 0.735410]]\n\n    coeffs[2, 5, :, :] = [\n        [0.597000, 0.500000, 0.300000, 0.310050, 0.413510],\n        [0.314790, 0.336310, 0.400000, 0.400000, 0.442460],\n        [0.166510, 0.460440, 0.552570, 1.000000, 0.461610],\n        [0.401020, 0.559110, 0.403630, 1.016710, 0.671490],\n        [0.400360, 0.750830, 0.842640, 1.802600, 1.023830],\n        [3.315300, 1.510380, 2.443650, 1.638820, 2.133990],\n        [0.530790, 0.745850, 0.693050, 1.458040, 0.804500]]\n\n    coeffs[2, 6, :, :] = [\n        [0.597000, 0.500000, 0.300000, 0.310050, 0.800920],\n        [0.314790, 0.336310, 0.400000, 0.400000, 0.237040],\n        [0.166510, 0.460440, 0.552570, 1.000000, 0.581990],\n        [0.401020, 0.559110, 0.403630, 1.016710, 0.898570],\n        [0.400360, 0.750830, 0.842640, 1.802600, 3.400390],\n        [3.315300, 1.510380, 2.443650, 1.638820, 2.508780],\n        [0.204340, 1.157740, 2.003080, 2.622080, 1.409380]]\n\n    coeffs[3, 1, :, :] = [\n        [1.242210, 1.242210, 1.242210, 1.242210, 1.242210],\n        [0.056980, 0.056980, 0.656990, 0.656990, 0.925160],\n        [0.089090, 0.089090, 1.040430, 1.232480, 1.205300],\n        [1.053850, 1.053850, 1.399690, 1.084640, 1.233340],\n        [1.151540, 1.151540, 1.118290, 1.531640, 1.411840],\n        [1.494980, 1.494980, 1.700000, 1.800810, 1.671600],\n        [1.018450, 1.018450, 1.153600, 1.321890, 1.294670]]\n\n    coeffs[3, 2, :, :] = [\n        [0.700000, 0.700000, 1.023460, 0.700000, 0.945830],\n        [0.886300, 0.886300, 1.333620, 0.800000, 1.066620],\n        [0.902180, 0.902180, 0.954330, 1.126690, 1.097310],\n        [1.095300, 1.075060, 1.176490, 1.139470, 1.096110],\n        [1.201660, 1.201660, 1.438200, 1.256280, 1.198060],\n        [1.525850, 1.525850, 1.869160, 1.985410, 1.911590],\n        [1.288220, 1.082810, 1.286370, 1.166170, 1.119330]]\n\n    coeffs[3, 3, :, :] = [\n        [0.600000, 1.029910, 0.859890, 0.550000, 0.813600],\n        [0.604450, 1.029910, 0.859890, 0.656700, 0.928840],\n        [0.455850, 0.750580, 0.804930, 0.823000, 0.911000],\n        [0.526580, 0.932310, 0.908620, 0.983520, 0.988090],\n        [1.036110, 1.100690, 0.848380, 1.035270, 1.042380],\n        [1.048440, 1.652720, 0.900000, 2.350410, 1.082950],\n        [0.817410, 0.976160, 0.861300, 0.974780, 1.004580]]\n\n    coeffs[3, 4, :, :] = [\n        [0.782110, 0.564280, 0.600000, 0.600000, 0.665740],\n        [0.894480, 0.680730, 0.541990, 0.800000, 0.669140],\n        [0.487460, 0.818950, 0.841830, 0.872540, 0.709040],\n        [0.709310, 0.872780, 0.908480, 0.953290, 0.844350],\n        [0.863920, 0.947770, 0.876220, 1.078750, 0.936910],\n        [1.280350, 0.866720, 0.769790, 1.078750, 0.975130],\n        [0.725420, 0.869970, 0.868810, 0.951190, 0.829220]]\n\n    coeffs[3, 5, :, :] = [\n        [0.791750, 0.654040, 0.483170, 0.409000, 0.597180],\n        [0.566140, 0.948990, 0.971820, 0.653570, 0.718550],\n        [0.648710, 0.637730, 0.870510, 0.860600, 0.694300],\n        [0.637630, 0.767610, 0.925670, 0.990310, 0.847670],\n        [0.736380, 0.946060, 1.117590, 1.029340, 0.947020],\n        [1.180970, 0.850000, 1.050000, 0.950000, 0.888580],\n        [0.700560, 0.801440, 0.961970, 0.906140, 0.823880]]\n\n    coeffs[3, 6, :, :] = [\n        [0.500000, 0.500000, 0.586770, 0.470550, 0.629790],\n        [0.500000, 0.500000, 1.056220, 1.260140, 0.658140],\n        [0.500000, 0.500000, 0.631830, 0.842620, 0.582780],\n        [0.554710, 0.734730, 0.985820, 0.915640, 0.898260],\n        [0.712510, 1.205990, 0.909510, 1.078260, 0.885610],\n        [1.899260, 1.559710, 1.000000, 1.150000, 1.120390],\n        [0.653880, 0.793120, 0.903320, 0.944070, 0.796130]]\n\n    coeffs[4, 1, :, :] = [\n        [1.000000, 1.000000, 1.050000, 1.170380, 1.178090],\n        [0.960580, 0.960580, 1.059530, 1.179030, 1.131690],\n        [0.871470, 0.871470, 0.995860, 1.141910, 1.114600],\n        [1.201590, 1.201590, 0.993610, 1.109380, 1.126320],\n        [1.065010, 1.065010, 0.828660, 0.939970, 1.017930],\n        [1.065010, 1.065010, 0.623690, 1.119620, 1.132260],\n        [1.071570, 1.071570, 0.958070, 1.114130, 1.127110]]\n\n    coeffs[4, 2, :, :] = [\n        [0.950000, 0.973390, 0.852520, 1.092200, 1.096590],\n        [0.804120, 0.913870, 0.980990, 1.094580, 1.042420],\n        [0.737540, 0.935970, 0.999940, 1.056490, 1.050060],\n        [1.032980, 1.034540, 0.968460, 1.032080, 1.015780],\n        [0.900000, 0.977210, 0.945960, 1.008840, 0.969960],\n        [0.600000, 0.750000, 0.750000, 0.844710, 0.899100],\n        [0.926800, 0.965030, 0.968520, 1.044910, 1.032310]]\n\n    coeffs[4, 3, :, :] = [\n        [0.850000, 1.029710, 0.961100, 1.055670, 1.009700],\n        [0.818530, 0.960010, 0.996450, 1.081970, 1.036470],\n        [0.765380, 0.953500, 0.948260, 1.052110, 1.000140],\n        [0.775610, 0.909610, 0.927800, 0.987800, 0.952100],\n        [1.000990, 0.881880, 0.875950, 0.949100, 0.893690],\n        [0.902370, 0.875960, 0.807990, 0.942410, 0.917920],\n        [0.856580, 0.928270, 0.946820, 1.032260, 0.972990]]\n\n    coeffs[4, 4, :, :] = [\n        [0.750000, 0.857930, 0.983800, 1.056540, 0.980240],\n        [0.750000, 0.987010, 1.013730, 1.133780, 1.038250],\n        [0.800000, 0.947380, 1.012380, 1.091270, 0.999840],\n        [0.800000, 0.914550, 0.908570, 0.999190, 0.915230],\n        [0.778540, 0.800590, 0.799070, 0.902180, 0.851560],\n        [0.680190, 0.317410, 0.507680, 0.388910, 0.646710],\n        [0.794920, 0.912780, 0.960830, 1.057110, 0.947950]]\n\n    coeffs[4, 5, :, :] = [\n        [0.750000, 0.833890, 0.867530, 1.059890, 0.932840],\n        [0.979700, 0.971470, 0.995510, 1.068490, 1.030150],\n        [0.858850, 0.987920, 1.043220, 1.108700, 1.044900],\n        [0.802400, 0.955110, 0.911660, 1.045070, 0.944470],\n        [0.884890, 0.766210, 0.885390, 0.859070, 0.818190],\n        [0.615680, 0.700000, 0.850000, 0.624620, 0.669300],\n        [0.835570, 0.946150, 0.977090, 1.049350, 0.979970]]\n\n    coeffs[4, 6, :, :] = [\n        [0.689220, 0.809600, 0.900000, 0.789500, 0.853990],\n        [0.854660, 0.852840, 0.938200, 0.923110, 0.955010],\n        [0.938600, 0.932980, 1.010390, 1.043950, 1.041640],\n        [0.843620, 0.981300, 0.951590, 0.946100, 0.966330],\n        [0.694740, 0.814690, 0.572650, 0.400000, 0.726830],\n        [0.211370, 0.671780, 0.416340, 0.297290, 0.498050],\n        [0.843540, 0.882330, 0.911760, 0.898420, 0.960210]]\n\n    coeffs[5, 1, :, :] = [\n        [1.054880, 1.075210, 1.068460, 1.153370, 1.069220],\n        [1.000000, 1.062220, 1.013470, 1.088170, 1.046200],\n        [0.885090, 0.993530, 0.942590, 1.054990, 1.012740],\n        [0.920000, 0.950000, 0.978720, 1.020280, 0.984440],\n        [0.850000, 0.908500, 0.839940, 0.985570, 0.962180],\n        [0.800000, 0.800000, 0.810080, 0.950000, 0.961550],\n        [1.038590, 1.063200, 1.034440, 1.112780, 1.037800]]\n\n    coeffs[5, 2, :, :] = [\n        [1.017610, 1.028360, 1.058960, 1.133180, 1.045620],\n        [0.920000, 0.998970, 1.033590, 1.089030, 1.022060],\n        [0.912370, 0.949930, 0.979770, 1.020420, 0.981770],\n        [0.847160, 0.935300, 0.930540, 0.955050, 0.946560],\n        [0.880260, 0.867110, 0.874130, 0.972650, 0.883420],\n        [0.627150, 0.627150, 0.700000, 0.774070, 0.845130],\n        [0.973700, 1.006240, 1.026190, 1.071960, 1.017240]]\n\n    coeffs[5, 3, :, :] = [\n        [1.028710, 1.017570, 1.025900, 1.081790, 1.024240],\n        [0.924980, 0.985500, 1.014100, 1.092210, 0.999610],\n        [0.828570, 0.934920, 0.994950, 1.024590, 0.949710],\n        [0.900810, 0.901330, 0.928830, 0.979570, 0.913100],\n        [0.761030, 0.845150, 0.805360, 0.936790, 0.853460],\n        [0.626400, 0.546750, 0.730500, 0.850000, 0.689050],\n        [0.957630, 0.985480, 0.991790, 1.050220, 0.987900]]\n\n    coeffs[5, 4, :, :] = [\n        [0.992730, 0.993880, 1.017150, 1.059120, 1.017450],\n        [0.975610, 0.987160, 1.026820, 1.075440, 1.007250],\n        [0.871090, 0.933190, 0.974690, 0.979840, 0.952730],\n        [0.828750, 0.868090, 0.834920, 0.905510, 0.871530],\n        [0.781540, 0.782470, 0.767910, 0.764140, 0.795890],\n        [0.743460, 0.693390, 0.514870, 0.630150, 0.715660],\n        [0.934760, 0.957870, 0.959640, 0.972510, 0.981640]]\n\n    coeffs[5, 5, :, :] = [\n        [0.965840, 0.941240, 0.987100, 1.022540, 1.011160],\n        [0.988630, 0.994770, 0.976590, 0.950000, 1.034840],\n        [0.958200, 1.018080, 0.974480, 0.920000, 0.989870],\n        [0.811720, 0.869090, 0.812020, 0.850000, 0.821050],\n        [0.682030, 0.679480, 0.632450, 0.746580, 0.738550],\n        [0.668290, 0.445860, 0.500000, 0.678920, 0.696510],\n        [0.926940, 0.953350, 0.959050, 0.876210, 0.991490]]\n\n    coeffs[5, 6, :, :] = [\n        [0.948940, 0.997760, 0.850000, 0.826520, 0.998470],\n        [1.017860, 0.970000, 0.850000, 0.700000, 0.988560],\n        [1.000000, 0.950000, 0.850000, 0.606240, 0.947260],\n        [1.000000, 0.746140, 0.751740, 0.598390, 0.725230],\n        [0.922210, 0.500000, 0.376800, 0.517110, 0.548630],\n        [0.500000, 0.450000, 0.429970, 0.404490, 0.539940],\n        [0.960430, 0.881630, 0.775640, 0.596350, 0.937680]]\n\n    coeffs[6, 1, :, :] = [\n        [1.030000, 1.040000, 1.000000, 1.000000, 1.049510],\n        [1.050000, 0.990000, 0.990000, 0.950000, 0.996530],\n        [1.050000, 0.990000, 0.990000, 0.820000, 0.971940],\n        [1.050000, 0.790000, 0.880000, 0.820000, 0.951840],\n        [1.000000, 0.530000, 0.440000, 0.710000, 0.928730],\n        [0.540000, 0.470000, 0.500000, 0.550000, 0.773950],\n        [1.038270, 0.920180, 0.910930, 0.821140, 1.034560]]\n\n    coeffs[6, 2, :, :] = [\n        [1.041020, 0.997520, 0.961600, 1.000000, 1.035780],\n        [0.948030, 0.980000, 0.900000, 0.950360, 0.977460],\n        [0.950000, 0.977250, 0.869270, 0.800000, 0.951680],\n        [0.951870, 0.850000, 0.748770, 0.700000, 0.883850],\n        [0.900000, 0.823190, 0.727450, 0.600000, 0.839870],\n        [0.850000, 0.805020, 0.692310, 0.500000, 0.788410],\n        [1.010090, 0.895270, 0.773030, 0.816280, 1.011680]]\n\n    coeffs[6, 3, :, :] = [\n        [1.022450, 1.004600, 0.983650, 1.000000, 1.032940],\n        [0.943960, 0.999240, 0.983920, 0.905990, 0.978150],\n        [0.936240, 0.946480, 0.850000, 0.850000, 0.930320],\n        [0.816420, 0.885000, 0.644950, 0.817650, 0.865310],\n        [0.742960, 0.765690, 0.561520, 0.700000, 0.827140],\n        [0.643870, 0.596710, 0.474460, 0.600000, 0.651200],\n        [0.971740, 0.940560, 0.714880, 0.864380, 1.001650]]\n\n    coeffs[6, 4, :, :] = [\n        [0.995260, 0.977010, 1.000000, 1.000000, 1.035250],\n        [0.939810, 0.975250, 0.939980, 0.950000, 0.982550],\n        [0.876870, 0.879440, 0.850000, 0.900000, 0.917810],\n        [0.873480, 0.873450, 0.751470, 0.850000, 0.863040],\n        [0.761470, 0.702360, 0.638770, 0.750000, 0.783120],\n        [0.734080, 0.650000, 0.600000, 0.650000, 0.715660],\n        [0.942160, 0.919100, 0.770340, 0.731170, 0.995180]]\n\n    coeffs[6, 5, :, :] = [\n        [0.952560, 0.916780, 0.920000, 0.900000, 1.005880],\n        [0.928620, 0.994420, 0.900000, 0.900000, 0.983720],\n        [0.913070, 0.850000, 0.850000, 0.800000, 0.924280],\n        [0.868090, 0.807170, 0.823550, 0.600000, 0.844520],\n        [0.769570, 0.719870, 0.650000, 0.550000, 0.733500],\n        [0.580250, 0.650000, 0.600000, 0.500000, 0.628850],\n        [0.904770, 0.852650, 0.708370, 0.493730, 0.949030]]\n\n    coeffs[6, 6, :, :] = [\n        [0.911970, 0.800000, 0.800000, 0.800000, 0.956320],\n        [0.912620, 0.682610, 0.750000, 0.700000, 0.950110],\n        [0.653450, 0.659330, 0.700000, 0.600000, 0.856110],\n        [0.648440, 0.600000, 0.641120, 0.500000, 0.695780],\n        [0.570000, 0.550000, 0.598800, 0.400000, 0.560150],\n        [0.475230, 0.500000, 0.518640, 0.339970, 0.520230],\n        [0.743440, 0.592190, 0.603060, 0.316930, 0.794390]]\n\n    return coeffs[1:, 1:, :, :]\n", "tokens": ["pvlib", "irradiance", "py", "def", "_get_dirint_coeffs", "a", "place", "to", "stash", "the", "dirint", "coefficients", "returns", "np", "array", "with", "shape", "6", "6", "7", "5", "ordering", "is", "kt_prime_bin", "zenith_bin", "delta_kt_prime_bin", "w_bin", "to", "allow", "for", "maximum", "copy", "paste", "from", "the", "matlab", "1", "indexed", "code", "we", "create", "and", "assign", "values", "to", "an", "oversized", "array", "then", "we", "return", "the", "1", "1", "slice", "coeffs", "np", "zeros", "7", "7", "7", "5", "coeffs", "1", "1", "0", "385230", "0", "385230", "0", "385230", "0", "462880", "0", "317440", "0", "338390", "0", "338390", "0", "221270", "0", "316730", "0", "503650", "0", "235680", "0", "235680", "0", "241280", "0", "157830", "0", "269440", "0", "830130", "0", "830130", "0", "171970", "0", "841070", "0", "457370", "0", "548010", "0", "548010", "0", "478000", "0", "966880", "1", "036370", "0", "548010", "0", "548010", "1", "000000", "3", "012370", "1", "976540", "0", "582690", "0", "582690", "0", "229720", "0", "892710", "0", "569950", "coeffs", "1", "2", "0", "131280", "0", "131280", "0", "385460", "0", "511070", "0", "127940", "0", "223710", "0", "223710", "0", "193560", "0", "304560", "0", "193940", "0", "229970", "0", "229970", "0", "275020", "0", "312730", "0", "244610", "0", "090100", "0", "184580", "0", "260500", "0", "687480", "0", "579440", "0", "131530", "0", "131530", "0", "370190", "1", "380350", "1", "052270", "1", "116250", "1", "116250", "0", "928030", "3", "525490", "2", "316920", "0", "090100", "0", "237000", "0", "300040", "0", "812470", "0", "664970", "coeffs", "1", "3", "0", "587510", "0", "130000", "0", "400000", "0", "537210", "0", "832490", "0", "306210", "0", "129830", "0", "204460", "0", "500000", "0", "681640", "0", "224020", "0", "260620", "0", "334080", "0", "501040", "0", "350470", "0", "421540", "0", "753970", "0", "750660", "3", "706840", "0", "983790", "0", "706680", "0", "373530", "1", "245670", "0", "864860", "1", "992630", "4", "864400", "0", "117390", "0", "265180", "0", "359180", "3", "310820", "0", "392080", "0", "493290", "0", "651560", "1", "932780", "0", "898730", "coeffs", "1", "4", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "3", "241680", "2", "500000", "2", "291440", "2", "291440", "2", "291440", "4", "000000", "3", "000000", "2", "000000", "0", "975430", "1", "965570", "12", "494170", "12", "494170", "8", "000000", "5", "083520", "8", "792390", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "3", "241680", "12", "494170", "1", "620760", "1", "375250", "2", "331620", "coeffs", "1", "5", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "3", "241680", "2", "500000", "2", "291440", "2", "291440", "2", "291440", "4", "000000", "3", "000000", "2", "000000", "0", "975430", "1", "965570", "12", "494170", "12", "494170", "8", "000000", "5", "083520", "8", "792390", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "3", "241680", "12", "494170", "1", "620760", "1", "375250", "2", "331620", "coeffs", "1", "6", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "126970", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "0", "810820", "3", "241680", "2", "500000", "2", "291440", "2", "291440", "2", "291440", "4", "000000", "3", "000000", "2", "000000", "0", "975430", "1", "965570", "12", "494170", "12", "494170", "8", "000000", "5", "083520", "8", "792390", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "21", "744240", "3", "241680", "12", "494170", "1", "620760", "1", "375250", "2", "331620", "coeffs", "2", "1", "0", "337440", "0", "337440", "0", "969110", "1", "097190", "1", "116080", "0", "337440", "0", "337440", "0", "969110", "1", "116030", "0", "623900", "0", "337440", "0", "337440", "1", "530590", "1", "024420", "0", "908480", "0", "584040", "0", "584040", "0", "847250", "0", "914940", "1", "289300", "0", "337440", "0", "337440", "0", "310240", "1", "435020", "1", "852830", "0", "337440", "0", "337440", "1", "015010", "1", "097190", "2", "117230", "0", "337440", "0", "337440", "0", "969110", "1", "145730", "1", "476400", "coeffs", "2", "2", "0", "300000", "0", "300000", "0", "700000", "1", "100000", "0", "796940", "0", "219870", "0", "219870", "0", "526530", "0", "809610", "0", "649300", "0", "386650", "0", "386650", "0", "119320", "0", "576120", "0", "685460", "0", "746730", "0", "399830", "0", "470970", "0", "986530", "0", "785370", "0", "575420", "0", "936700", "1", "649200", "1", "495840", "1", "335590", "1", "319670", "4", "002570", "1", "276390", "2", "644550", "2", "518670", "0", "665190", "0", "678910", "1", "012360", "1", "199940", "0", "986580", "coeffs", "2", "3", "0", "378870", "0", "974060", "0", "500000", "0", "491880", "0", "665290", "0", "105210", "0", "263470", "0", "407040", "0", "553460", "0", "582590", "0", "312900", "0", "345240", "1", "144180", "0", "854790", "0", "612280", "0", "119070", "0", "365120", "0", "560520", "0", "793720", "0", "802600", "0", "781610", "0", "837390", "1", "270420", "1", "537980", "1", "292950", "1", "152290", "1", "152290", "1", "492080", "1", "245370", "2", "177100", "0", "424660", "0", "529550", "0", "966910", "1", "033460", "0", "958730", "coeffs", "2", "4", "0", "310590", "0", "714410", "0", "252450", "0", "500000", "0", "607600", "0", "975190", "0", "363420", "0", "500000", "0", "400000", "0", "502800", "0", "175580", "0", "196250", "0", "476360", "1", "072470", "0", "490510", "0", "719280", "0", "698620", "0", "657770", "1", "190840", "0", "681110", "0", "426240", "1", "464840", "0", "678550", "1", "157730", "0", "978430", "2", "501120", "1", "789130", "1", "387090", "2", "394180", "2", "394180", "0", "491640", "0", "677610", "0", "685610", "1", "082400", "0", "735410", "coeffs", "2", "5", "0", "597000", "0", "500000", "0", "300000", "0", "310050", "0", "413510", "0", "314790", "0", "336310", "0", "400000", "0", "400000", "0", "442460", "0", "166510", "0", "460440", "0", "552570", "1", "000000", "0", "461610", "0", "401020", "0", "559110", "0", "403630", "1", "016710", "0", "671490", "0", "400360", "0", "750830", "0", "842640", "1", "802600", "1", "023830", "3", "315300", "1", "510380", "2", "443650", "1", "638820", "2", "133990", "0", "530790", "0", "745850", "0", "693050", "1", "458040", "0", "804500", "coeffs", "2", "6", "0", "597000", "0", "500000", "0", "300000", "0", "310050", "0", "800920", "0", "314790", "0", "336310", "0", "400000", "0", "400000", "0", "237040", "0", "166510", "0", "460440", "0", "552570", "1", "000000", "0", "581990", "0", "401020", "0", "559110", "0", "403630", "1", "016710", "0", "898570", "0", "400360", "0", "750830", "0", "842640", "1", "802600", "3", "400390", "3", "315300", "1", "510380", "2", "443650", "1", "638820", "2", "508780", "0", "204340", "1", "157740", "2", "003080", "2", "622080", "1", "409380", "coeffs", "3", "1", "1", "242210", "1", "242210", "1", "242210", "1", "242210", "1", "242210", "0", "056980", "0", "056980", "0", "656990", "0", "656990", "0", "925160", "0", "089090", "0", "089090", "1", "040430", "1", "232480", "1", "205300", "1", "053850", "1", "053850", "1", "399690", "1", "084640", "1", "233340", "1", "151540", "1", "151540", "1", "118290", "1", "531640", "1", "411840", "1", "494980", "1", "494980", "1", "700000", "1", "800810", "1", "671600", "1", "018450", "1", "018450", "1", "153600", "1", "321890", "1", "294670", "coeffs", "3", "2", "0", "700000", "0", "700000", "1", "023460", "0", "700000", "0", "945830", "0", "886300", "0", "886300", "1", "333620", "0", "800000", "1", "066620", "0", "902180", "0", "902180", "0", "954330", "1", "126690", "1", "097310", "1", "095300", "1", "075060", "1", "176490", "1", "139470", "1", "096110", "1", "201660", "1", "201660", "1", "438200", "1", "256280", "1", "198060", "1", "525850", "1", "525850", "1", "869160", "1", "985410", "1", "911590", "1", "288220", "1", "082810", "1", "286370", "1", "166170", "1", "119330", "coeffs", "3", "3", "0", "600000", "1", "029910", "0", "859890", "0", "550000", "0", "813600", "0", "604450", "1", "029910", "0", "859890", "0", "656700", "0", "928840", "0", "455850", "0", "750580", "0", "804930", "0", "823000", "0", "911000", "0", "526580", "0", "932310", "0", "908620", "0", "983520", "0", "988090", "1", "036110", "1", "100690", "0", "848380", "1", "035270", "1", "042380", "1", "048440", "1", "652720", "0", "900000", "2", "350410", "1", "082950", "0", "817410", "0", "976160", "0", "861300", "0", "974780", "1", "004580", "coeffs", "3", "4", "0", "782110", "0", "564280", "0", "600000", "0", "600000", "0", "665740", "0", "894480", "0", "680730", "0", "541990", "0", "800000", "0", "669140", "0", "487460", "0", "818950", "0", "841830", "0", "872540", "0", "709040", "0", "709310", "0", "872780", "0", "908480", "0", "953290", "0", "844350", "0", "863920", "0", "947770", "0", "876220", "1", "078750", "0", "936910", "1", "280350", "0", "866720", "0", "769790", "1", "078750", "0", "975130", "0", "725420", "0", "869970", "0", "868810", "0", "951190", "0", "829220", "coeffs", "3", "5", "0", "791750", "0", "654040", "0", "483170", "0", "409000", "0", "597180", "0", "566140", "0", "948990", "0", "971820", "0", "653570", "0", "718550", "0", "648710", "0", "637730", "0", "870510", "0", "860600", "0", "694300", "0", "637630", "0", "767610", "0", "925670", "0", "990310", "0", "847670", "0", "736380", "0", "946060", "1", "117590", "1", "029340", "0", "947020", "1", "180970", "0", "850000", "1", "050000", "0", "950000", "0", "888580", "0", "700560", "0", "801440", "0", "961970", "0", "906140", "0", "823880", "coeffs", "3", "6", "0", "500000", "0", "500000", "0", "586770", "0", "470550", "0", "629790", "0", "500000", "0", "500000", "1", "056220", "1", "260140", "0", "658140", "0", "500000", "0", "500000", "0", "631830", "0", "842620", "0", "582780", "0", "554710", "0", "734730", "0", "985820", "0", "915640", "0", "898260", "0", "712510", "1", "205990", "0", "909510", "1", "078260", "0", "885610", "1", "899260", "1", "559710", "1", "000000", "1", "150000", "1", "120390", "0", "653880", "0", "793120", "0", "903320", "0", "944070", "0", "796130", "coeffs", "4", "1", "1", "000000", "1", "000000", "1", "050000", "1", "170380", "1", "178090", "0", "960580", "0", "960580", "1", "059530", "1", "179030", "1", "131690", "0", "871470", "0", "871470", "0", "995860", "1", "141910", "1", "114600", "1", "201590", "1", "201590", "0", "993610", "1", "109380", "1", "126320", "1", "065010", "1", "065010", "0", "828660", "0", "939970", "1", "017930", "1", "065010", "1", "065010", "0", "623690", "1", "119620", "1", "132260", "1", "071570", "1", "071570", "0", "958070", "1", "114130", "1", "127110", "coeffs", "4", "2", "0", "950000", "0", "973390", "0", "852520", "1", "092200", "1", "096590", "0", "804120", "0", "913870", "0", "980990", "1", "094580", "1", "042420", "0", "737540", "0", "935970", "0", "999940", "1", "056490", "1", "050060", "1", "032980", "1", "034540", "0", "968460", "1", "032080", "1", "015780", "0", "900000", "0", "977210", "0", "945960", "1", "008840", "0", "969960", "0", "600000", "0", "750000", "0", "750000", "0", "844710", "0", "899100", "0", "926800", "0", "965030", "0", "968520", "1", "044910", "1", "032310", "coeffs", "4", "3", "0", "850000", "1", "029710", "0", "961100", "1", "055670", "1", "009700", "0", "818530", "0", "960010", "0", "996450", "1", "081970", "1", "036470", "0", "765380", "0", "953500", "0", "948260", "1", "052110", "1", "000140", "0", "775610", "0", "909610", "0", "927800", "0", "987800", "0", "952100", "1", "000990", "0", "881880", "0", "875950", "0", "949100", "0", "893690", "0", "902370", "0", "875960", "0", "807990", "0", "942410", "0", "917920", "0", "856580", "0", "928270", "0", "946820", "1", "032260", "0", "972990", "coeffs", "4", "4", "0", "750000", "0", "857930", "0", "983800", "1", "056540", "0", "980240", "0", "750000", "0", "987010", "1", "013730", "1", "133780", "1", "038250", "0", "800000", "0", "947380", "1", "012380", "1", "091270", "0", "999840", "0", "800000", "0", "914550", "0", "908570", "0", "999190", "0", "915230", "0", "778540", "0", "800590", "0", "799070", "0", "902180", "0", "851560", "0", "680190", "0", "317410", "0", "507680", "0", "388910", "0", "646710", "0", "794920", "0", "912780", "0", "960830", "1", "057110", "0", "947950", "coeffs", "4", "5", "0", "750000", "0", "833890", "0", "867530", "1", "059890", "0", "932840", "0", "979700", "0", "971470", "0", "995510", "1", "068490", "1", "030150", "0", "858850", "0", "987920", "1", "043220", "1", "108700", "1", "044900", "0", "802400", "0", "955110", "0", "911660", "1", "045070", "0", "944470", "0", "884890", "0", "766210", "0", "885390", "0", "859070", "0", "818190", "0", "615680", "0", "700000", "0", "850000", "0", "624620", "0", "669300", "0", "835570", "0", "946150", "0", "977090", "1", "049350", "0", "979970", "coeffs", "4", "6", "0", "689220", "0", "809600", "0", "900000", "0", "789500", "0", "853990", "0", "854660", "0", "852840", "0", "938200", "0", "923110", "0", "955010", "0", "938600", "0", "932980", "1", "010390", "1", "043950", "1", "041640", "0", "843620", "0", "981300", "0", "951590", "0", "946100", "0", "966330", "0", "694740", "0", "814690", "0", "572650", "0", "400000", "0", "726830", "0", "211370", "0", "671780", "0", "416340", "0", "297290", "0", "498050", "0", "843540", "0", "882330", "0", "911760", "0", "898420", "0", "960210", "coeffs", "5", "1", "1", "054880", "1", "075210", "1", "068460", "1", "153370", "1", "069220", "1", "000000", "1", "062220", "1", "013470", "1", "088170", "1", "046200", "0", "885090", "0", "993530", "0", "942590", "1", "054990", "1", "012740", "0", "920000", "0", "950000", "0", "978720", "1", "020280", "0", "984440", "0", "850000", "0", "908500", "0", "839940", "0", "985570", "0", "962180", "0", "800000", "0", "800000", "0", "810080", "0", "950000", "0", "961550", "1", "038590", "1", "063200", "1", "034440", "1", "112780", "1", "037800", "coeffs", "5", "2", "1", "017610", "1", "028360", "1", "058960", "1", "133180", "1", "045620", "0", "920000", "0", "998970", "1", "033590", "1", "089030", "1", "022060", "0", "912370", "0", "949930", "0", "979770", "1", "020420", "0", "981770", "0", "847160", "0", "935300", "0", "930540", "0", "955050", "0", "946560", "0", "880260", "0", "867110", "0", "874130", "0", "972650", "0", "883420", "0", "627150", "0", "627150", "0", "700000", "0", "774070", "0", "845130", "0", "973700", "1", "006240", "1", "026190", "1", "071960", "1", "017240", "coeffs", "5", "3", "1", "028710", "1", "017570", "1", "025900", "1", "081790", "1", "024240", "0", "924980", "0", "985500", "1", "014100", "1", "092210", "0", "999610", "0", "828570", "0", "934920", "0", "994950", "1", "024590", "0", "949710", "0", "900810", "0", "901330", "0", "928830", "0", "979570", "0", "913100", "0", "761030", "0", "845150", "0", "805360", "0", "936790", "0", "853460", "0", "626400", "0", "546750", "0", "730500", "0", "850000", "0", "689050", "0", "957630", "0", "985480", "0", "991790", "1", "050220", "0", "987900", "coeffs", "5", "4", "0", "992730", "0", "993880", "1", "017150", "1", "059120", "1", "017450", "0", "975610", "0", "987160", "1", "026820", "1", "075440", "1", "007250", "0", "871090", "0", "933190", "0", "974690", "0", "979840", "0", "952730", "0", "828750", "0", "868090", "0", "834920", "0", "905510", "0", "871530", "0", "781540", "0", "782470", "0", "767910", "0", "764140", "0", "795890", "0", "743460", "0", "693390", "0", "514870", "0", "630150", "0", "715660", "0", "934760", "0", "957870", "0", "959640", "0", "972510", "0", "981640", "coeffs", "5", "5", "0", "965840", "0", "941240", "0", "987100", "1", "022540", "1", "011160", "0", "988630", "0", "994770", "0", "976590", "0", "950000", "1", "034840", "0", "958200", "1", "018080", "0", "974480", "0", "920000", "0", "989870", "0", "811720", "0", "869090", "0", "812020", "0", "850000", "0", "821050", "0", "682030", "0", "679480", "0", "632450", "0", "746580", "0", "738550", "0", "668290", "0", "445860", "0", "500000", "0", "678920", "0", "696510", "0", "926940", "0", "953350", "0", "959050", "0", "876210", "0", "991490", "coeffs", "5", "6", "0", "948940", "0", "997760", "0", "850000", "0", "826520", "0", "998470", "1", "017860", "0", "970000", "0", "850000", "0", "700000", "0", "988560", "1", "000000", "0", "950000", "0", "850000", "0", "606240", "0", "947260", "1", "000000", "0", "746140", "0", "751740", "0", "598390", "0", "725230", "0", "922210", "0", "500000", "0", "376800", "0", "517110", "0", "548630", "0", "500000", "0", "450000", "0", "429970", "0", "404490", "0", "539940", "0", "960430", "0", "881630", "0", "775640", "0", "596350", "0", "937680", "coeffs", "6", "1", "1", "030000", "1", "040000", "1", "000000", "1", "000000", "1", "049510", "1", "050000", "0", "990000", "0", "990000", "0", "950000", "0", "996530", "1", "050000", "0", "990000", "0", "990000", "0", "820000", "0", "971940", "1", "050000", "0", "790000", "0", "880000", "0", "820000", "0", "951840", "1", "000000", "0", "530000", "0", "440000", "0", "710000", "0", "928730", "0", "540000", "0", "470000", "0", "500000", "0", "550000", "0", "773950", "1", "038270", "0", "920180", "0", "910930", "0", "821140", "1", "034560", "coeffs", "6", "2", "1", "041020", "0", "997520", "0", "961600", "1", "000000", "1", "035780", "0", "948030", "0", "980000", "0", "900000", "0", "950360", "0", "977460", "0", "950000", "0", "977250", "0", "869270", "0", "800000", "0", "951680", "0", "951870", "0", "850000", "0", "748770", "0", "700000", "0", "883850", "0", "900000", "0", "823190", "0", "727450", "0", "600000", "0", "839870", "0", "850000", "0", "805020", "0", "692310", "0", "500000", "0", "788410", "1", "010090", "0", "895270", "0", "773030", "0", "816280", "1", "011680", "coeffs", "6", "3", "1", "022450", "1", "004600", "0", "983650", "1", "000000", "1", "032940", "0", "943960", "0", "999240", "0", "983920", "0", "905990", "0", "978150", "0", "936240", "0", "946480", "0", "850000", "0", "850000", "0", "930320", "0", "816420", "0", "885000", "0", "644950", "0", "817650", "0", "865310", "0", "742960", "0", "765690", "0", "561520", "0", "700000", "0", "827140", "0", "643870", "0", "596710", "0", "474460", "0", "600000", "0", "651200", "0", "971740", "0", "940560", "0", "714880", "0", "864380", "1", "001650", "coeffs", "6", "4", "0", "995260", "0", "977010", "1", "000000", "1", "000000", "1", "035250", "0", "939810", "0", "975250", "0", "939980", "0", "950000", "0", "982550", "0", "876870", "0", "879440", "0", "850000", "0", "900000", "0", "917810", "0", "873480", "0", "873450", "0", "751470", "0", "850000", "0", "863040", "0", "761470", "0", "702360", "0", "638770", "0", "750000", "0", "783120", "0", "734080", "0", "650000", "0", "600000", "0", "650000", "0", "715660", "0", "942160", "0", "919100", "0", "770340", "0", "731170", "0", "995180", "coeffs", "6", "5", "0", "952560", "0", "916780", "0", "920000", "0", "900000", "1", "005880", "0", "928620", "0", "994420", "0", "900000", "0", "900000", "0", "983720", "0", "913070", "0", "850000", "0", "850000", "0", "800000", "0", "924280", "0", "868090", "0", "807170", "0", "823550", "0", "600000", "0", "844520", "0", "769570", "0", "719870", "0", "650000", "0", "550000", "0", "733500", "0", "580250", "0", "650000", "0", "600000", "0", "500000", "0", "628850", "0", "904770", "0", "852650", "0", "708370", "0", "493730", "0", "949030", "coeffs", "6", "6", "0", "911970", "0", "800000", "0", "800000", "0", "800000", "0", "956320", "0", "912620", "0", "682610", "0", "750000", "0", "700000", "0", "950110", "0", "653450", "0", "659330", "0", "700000", "0", "600000", "0", "856110", "0", "648440", "0", "600000", "0", "641120", "0", "500000", "0", "695780", "0", "570000", "0", "550000", "0", "598800", "0", "400000", "0", "560150", "0", "475230", "0", "500000", "0", "518640", "0", "339970", "0", "520230", "0", "743440", "0", "592190", "0", "603060", "0", "316930", "0", "794390", "return", "coeffs", "1", "1"], "doc_len": 2694}
{"doc_id": "pvlib/irradiance.py::dni", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "dni", "text": "文件路径: pvlib/irradiance.py\ndef dni(ghi, dhi, zenith, clearsky_dni=None, clearsky_tolerance=1.1,\n        zenith_threshold_for_zero_dni=88.0,\n        zenith_threshold_for_clearsky_limit=80.0):\n    \"\"\"\n    Determine DNI from GHI and DHI.\n\n    When calculating the DNI from GHI and DHI the calculated DNI may be\n    unreasonably high or negative for zenith angles close to 90 degrees\n    (sunrise/sunset transitions). This function identifies unreasonable DNI\n    values and sets them to NaN. If the clearsky DNI is given unreasonably high\n    values are cut off.\n\n    Parameters\n    ----------\n    ghi : Series\n        Global horizontal irradiance.\n\n    dhi : Series\n        Diffuse horizontal irradiance.\n\n    zenith : Series\n        True (not refraction-corrected) zenith angles in decimal\n        degrees. Angles must be >=0 and <=180.\n\n    clearsky_dni : None or Series, default None\n        Clearsky direct normal irradiance.\n\n    clearsky_tolerance : float, default 1.1\n        If 'clearsky_dni' is given this parameter can be used to allow a\n        tolerance by how much the calculated DNI value can be greater than\n        the clearsky value before it is identified as an unreasonable value.\n\n    zenith_threshold_for_zero_dni : float, default 88.0\n        Non-zero DNI values for zenith angles greater than or equal to\n        'zenith_threshold_for_zero_dni' will be set to NaN.\n\n    zenith_threshold_for_clearsky_limit : float, default 80.0\n        DNI values for zenith angles greater than or equal to\n        'zenith_threshold_for_clearsky_limit' and smaller the\n        'zenith_threshold_for_zero_dni' that are greater than the clearsky DNI\n        (times allowed tolerance) will be corrected. Only applies if\n        'clearsky_dni' is not None.\n\n    Returns\n    -------\n    dni : Series\n        The modeled direct normal irradiance.\n    \"\"\"\n\n    # calculate DNI\n    dni = (ghi - dhi) / tools.cosd(zenith)\n\n    # cutoff negative values\n    dni[dni < 0] = float('nan')\n\n    # set non-zero DNI values for zenith angles >=\n    # zenith_threshold_for_zero_dni to NaN\n    dni[(zenith >= zenith_threshold_for_zero_dni) & (dni != 0)] = float('nan')\n\n    # correct DNI values for zenith angles greater or equal to the\n    # zenith_threshold_for_clearsky_limit and smaller than the\n    # upper_cutoff_zenith that are greater than the clearsky DNI (times\n    # clearsky_tolerance)\n    if clearsky_dni is not None:\n        max_dni = clearsky_dni * clearsky_tolerance\n        dni[(zenith >= zenith_threshold_for_clearsky_limit) &\n            (zenith < zenith_threshold_for_zero_dni) &\n            (dni > max_dni)] = max_dni\n    return dni\n", "tokens": ["pvlib", "irradiance", "py", "def", "dni", "ghi", "dhi", "zenith", "clearsky_dni", "none", "clearsky_tolerance", "1", "1", "zenith_threshold_for_zero_dni", "88", "0", "zenith_threshold_for_clearsky_limit", "80", "0", "determine", "dni", "from", "ghi", "and", "dhi", "when", "calculating", "the", "dni", "from", "ghi", "and", "dhi", "the", "calculated", "dni", "may", "be", "unreasonably", "high", "or", "negative", "for", "zenith", "angles", "close", "to", "90", "degrees", "sunrise", "sunset", "transitions", "this", "function", "identifies", "unreasonable", "dni", "values", "and", "sets", "them", "to", "nan", "if", "the", "clearsky", "dni", "is", "given", "unreasonably", "high", "values", "are", "cut", "off", "parameters", "ghi", "series", "global", "horizontal", "irradiance", "dhi", "series", "diffuse", "horizontal", "irradiance", "zenith", "series", "true", "not", "refraction", "corrected", "zenith", "angles", "in", "decimal", "degrees", "angles", "must", "be", "0", "and", "180", "clearsky_dni", "none", "or", "series", "default", "none", "clearsky", "direct", "normal", "irradiance", "clearsky_tolerance", "float", "default", "1", "1", "if", "clearsky_dni", "is", "given", "this", "parameter", "can", "be", "used", "to", "allow", "a", "tolerance", "by", "how", "much", "the", "calculated", "dni", "value", "can", "be", "greater", "than", "the", "clearsky", "value", "before", "it", "is", "identified", "as", "an", "unreasonable", "value", "zenith_threshold_for_zero_dni", "float", "default", "88", "0", "non", "zero", "dni", "values", "for", "zenith", "angles", "greater", "than", "or", "equal", "to", "zenith_threshold_for_zero_dni", "will", "be", "set", "to", "nan", "zenith_threshold_for_clearsky_limit", "float", "default", "80", "0", "dni", "values", "for", "zenith", "angles", "greater", "than", "or", "equal", "to", "zenith_threshold_for_clearsky_limit", "and", "smaller", "the", "zenith_threshold_for_zero_dni", "that", "are", "greater", "than", "the", "clearsky", "dni", "times", "allowed", "tolerance", "will", "be", "corrected", "only", "applies", "if", "clearsky_dni", "is", "not", "none", "returns", "dni", "series", "the", "modeled", "direct", "normal", "irradiance", "calculate", "dni", "dni", "ghi", "dhi", "tools", "cosd", "zenith", "cutoff", "negative", "values", "dni", "dni", "0", "float", "nan", "set", "non", "zero", "dni", "values", "for", "zenith", "angles", "zenith_threshold_for_zero_dni", "to", "nan", "dni", "zenith", "zenith_threshold_for_zero_dni", "dni", "0", "float", "nan", "correct", "dni", "values", "for", "zenith", "angles", "greater", "or", "equal", "to", "the", "zenith_threshold_for_clearsky_limit", "and", "smaller", "than", "the", "upper_cutoff_zenith", "that", "are", "greater", "than", "the", "clearsky", "dni", "times", "clearsky_tolerance", "if", "clearsky_dni", "is", "not", "none", "max_dni", "clearsky_dni", "clearsky_tolerance", "dni", "zenith", "zenith_threshold_for_clearsky_limit", "zenith", "zenith_threshold_for_zero_dni", "dni", "max_dni", "max_dni", "return", "dni"], "doc_len": 302}
{"doc_id": "pvlib/irradiance.py::complete_irradiance", "file_path": "pvlib/irradiance.py", "class_name": null, "func_name": "complete_irradiance", "text": "文件路径: pvlib/irradiance.py\ndef complete_irradiance(solar_zenith,\n                        ghi=None,\n                        dhi=None,\n                        dni=None,\n                        dni_clear=None):\n    r\"\"\"\n    Use the component sum equations to calculate the missing series, using\n    the other available time series. One of the three parameters (ghi, dhi,\n    dni) is passed as None, and the other associated series passed are used to\n    calculate the missing series value.\n\n    The \"component sum\" or \"closure\" equation relates the three\n    primary irradiance components as follows:\n\n    .. math::\n\n       GHI = DHI + DNI \\cos(\\theta_z)\n\n    Parameters\n    ----------\n    solar_zenith : Series\n        Zenith angles in decimal degrees, with datetime index.\n        Angles must be >=0 and <=180. Must have the same datetime index\n        as ghi, dhi, and dni series, when available.\n    ghi : Series, optional\n        Pandas series of dni data, with datetime index. Must have the same\n        datetime index as dni, dhi, and zenith series, when available.\n    dhi : Series, optional\n        Pandas series of dni data, with datetime index. Must have the same\n        datetime index as ghi, dni, and zenith series, when available.\n    dni : Series, optional\n        Pandas series of dni data, with datetime index. Must have the same\n        datetime index as ghi, dhi, and zenith series, when available.\n    dni_clear : Series, optional\n        Pandas series of clearsky dni data. Must have the same datetime index\n        as ghi, dhi, dni, and zenith series, when available. See\n        :py:func:`dni` for details.\n\n    Returns\n    -------\n    component_sum_df : Dataframe\n        Pandas series of 'ghi', 'dhi', and 'dni' columns with datetime index\n    \"\"\"\n    if ghi is not None and dhi is not None and dni is None:\n        dni = pvlib.irradiance.dni(ghi, dhi, solar_zenith,\n                                   clearsky_dni=dni_clear,\n                                   clearsky_tolerance=1.1)\n    elif dni is not None and dhi is not None and ghi is None:\n        ghi = (dhi + dni * tools.cosd(solar_zenith))\n    elif dni is not None and ghi is not None and dhi is None:\n        dhi = (ghi - dni * tools.cosd(solar_zenith))\n    else:\n        raise ValueError(\n            \"Please check that exactly one of ghi, dhi and dni parameters \"\n            \"is set to None\"\n        )\n    # Merge the outputs into a master dataframe containing 'ghi', 'dhi',\n    # and 'dni' columns\n    component_sum_df = pd.DataFrame({'ghi': ghi,\n                                     'dhi': dhi,\n                                     'dni': dni})\n    return component_sum_df\n", "tokens": ["pvlib", "irradiance", "py", "def", "complete_irradiance", "solar_zenith", "ghi", "none", "dhi", "none", "dni", "none", "dni_clear", "none", "r", "use", "the", "component", "sum", "equations", "to", "calculate", "the", "missing", "series", "using", "the", "other", "available", "time", "series", "one", "of", "the", "three", "parameters", "ghi", "dhi", "dni", "is", "passed", "as", "none", "and", "the", "other", "associated", "series", "passed", "are", "used", "to", "calculate", "the", "missing", "series", "value", "the", "component", "sum", "or", "closure", "equation", "relates", "the", "three", "primary", "irradiance", "components", "as", "follows", "math", "ghi", "dhi", "dni", "cos", "theta_z", "parameters", "solar_zenith", "series", "zenith", "angles", "in", "decimal", "degrees", "with", "datetime", "index", "angles", "must", "be", "0", "and", "180", "must", "have", "the", "same", "datetime", "index", "as", "ghi", "dhi", "and", "dni", "series", "when", "available", "ghi", "series", "optional", "pandas", "series", "of", "dni", "data", "with", "datetime", "index", "must", "have", "the", "same", "datetime", "index", "as", "dni", "dhi", "and", "zenith", "series", "when", "available", "dhi", "series", "optional", "pandas", "series", "of", "dni", "data", "with", "datetime", "index", "must", "have", "the", "same", "datetime", "index", "as", "ghi", "dni", "and", "zenith", "series", "when", "available", "dni", "series", "optional", "pandas", "series", "of", "dni", "data", "with", "datetime", "index", "must", "have", "the", "same", "datetime", "index", "as", "ghi", "dhi", "and", "zenith", "series", "when", "available", "dni_clear", "series", "optional", "pandas", "series", "of", "clearsky", "dni", "data", "must", "have", "the", "same", "datetime", "index", "as", "ghi", "dhi", "dni", "and", "zenith", "series", "when", "available", "see", "py", "func", "dni", "for", "details", "returns", "component_sum_df", "dataframe", "pandas", "series", "of", "ghi", "dhi", "and", "dni", "columns", "with", "datetime", "index", "if", "ghi", "is", "not", "none", "and", "dhi", "is", "not", "none", "and", "dni", "is", "none", "dni", "pvlib", "irradiance", "dni", "ghi", "dhi", "solar_zenith", "clearsky_dni", "dni_clear", "clearsky_tolerance", "1", "1", "elif", "dni", "is", "not", "none", "and", "dhi", "is", "not", "none", "and", "ghi", "is", "none", "ghi", "dhi", "dni", "tools", "cosd", "solar_zenith", "elif", "dni", "is", "not", "none", "and", "ghi", "is", "not", "none", "and", "dhi", "is", "none", "dhi", "ghi", "dni", "tools", "cosd", "solar_zenith", "else", "raise", "valueerror", "please", "check", "that", "exactly", "one", "of", "ghi", "dhi", "and", "dni", "parameters", "is", "set", "to", "none", "merge", "the", "outputs", "into", "a", "master", "dataframe", "containing", "ghi", "dhi", "and", "dni", "columns", "component_sum_df", "pd", "dataframe", "ghi", "ghi", "dhi", "dhi", "dni", "dni", "return", "component_sum_df"], "doc_len": 335}
{"doc_id": "pvlib/location.py::Location.__init__", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "__init__", "text": "文件路径: pvlib/location.py, 类名: Location\n    def __init__(self, latitude, longitude, tz='UTC', altitude=0, name=None):\n\n        self.latitude = latitude\n        self.longitude = longitude\n\n        if isinstance(tz, str):\n            self.tz = tz\n            self.pytz = pytz.timezone(tz)\n        elif isinstance(tz, datetime.timezone):\n            self.tz = 'UTC'\n            self.pytz = pytz.UTC\n        elif isinstance(tz, datetime.tzinfo):\n            self.tz = tz.zone\n            self.pytz = tz\n        elif isinstance(tz, (int, float)):\n            self.tz = tz\n            self.pytz = pytz.FixedOffset(tz*60)\n        else:\n            raise TypeError('Invalid tz specification')\n\n        self.altitude = altitude\n\n        self.name = name\n", "tokens": ["pvlib", "location", "py", "location", "def", "__init__", "self", "latitude", "longitude", "tz", "utc", "altitude", "0", "name", "none", "self", "latitude", "latitude", "self", "longitude", "longitude", "if", "isinstance", "tz", "str", "self", "tz", "tz", "self", "pytz", "pytz", "timezone", "tz", "elif", "isinstance", "tz", "datetime", "timezone", "self", "tz", "utc", "self", "pytz", "pytz", "utc", "elif", "isinstance", "tz", "datetime", "tzinfo", "self", "tz", "tz", "zone", "self", "pytz", "tz", "elif", "isinstance", "tz", "int", "float", "self", "tz", "tz", "self", "pytz", "pytz", "fixedoffset", "tz", "60", "else", "raise", "typeerror", "invalid", "tz", "specification", "self", "altitude", "altitude", "self", "name", "name"], "doc_len": 83}
{"doc_id": "pvlib/location.py::Location.__repr__", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "__repr__", "text": "文件路径: pvlib/location.py, 类名: Location\n    def __repr__(self):\n        attrs = ['name', 'latitude', 'longitude', 'altitude', 'tz']\n        return ('Location: \\n  ' + '\\n  '.join(\n            f'{attr}: {getattr(self, attr)}' for attr in attrs))\n", "tokens": ["pvlib", "location", "py", "location", "def", "__repr__", "self", "attrs", "name", "latitude", "longitude", "altitude", "tz", "return", "location", "n", "n", "join", "f", "attr", "getattr", "self", "attr", "for", "attr", "in", "attrs"], "doc_len": 27}
{"doc_id": "pvlib/location.py::Location.from_tmy", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "from_tmy", "text": "文件路径: pvlib/location.py, 类名: Location\n    def from_tmy(cls, tmy_metadata, tmy_data=None, **kwargs):\n        \"\"\"\n        Create an object based on a metadata\n        dictionary from tmy2 or tmy3 data readers.\n\n        Parameters\n        ----------\n        tmy_metadata : dict\n            Returned from tmy.readtmy2 or tmy.readtmy3\n        tmy_data : None or DataFrame, default None\n            Optionally attach the TMY data to this object.\n\n        Returns\n        -------\n        Location\n        \"\"\"\n        # not complete, but hopefully you get the idea.\n        # might need code to handle the difference between tmy2 and tmy3\n\n        # determine if we're dealing with TMY2 or TMY3 data\n        tmy2 = tmy_metadata.get('City', False)\n\n        latitude = tmy_metadata['latitude']\n        longitude = tmy_metadata['longitude']\n\n        if tmy2:\n            name = tmy_metadata['City']\n        else:\n            name = tmy_metadata['Name']\n\n        tz = tmy_metadata['TZ']\n        altitude = tmy_metadata['altitude']\n\n        new_object = cls(latitude, longitude, tz=tz, altitude=altitude,\n                         name=name, **kwargs)\n\n        # not sure if this should be assigned regardless of input.\n        if tmy_data is not None:\n            new_object.tmy_data = tmy_data\n            new_object.weather = tmy_data\n\n        return new_object\n", "tokens": ["pvlib", "location", "py", "location", "def", "from_tmy", "cls", "tmy_metadata", "tmy_data", "none", "kwargs", "create", "an", "object", "based", "on", "a", "metadata", "dictionary", "from", "tmy2", "or", "tmy3", "data", "readers", "parameters", "tmy_metadata", "dict", "returned", "from", "tmy", "readtmy2", "or", "tmy", "readtmy3", "tmy_data", "none", "or", "dataframe", "default", "none", "optionally", "attach", "the", "tmy", "data", "to", "this", "object", "returns", "location", "not", "complete", "but", "hopefully", "you", "get", "the", "idea", "might", "need", "code", "to", "handle", "the", "difference", "between", "tmy2", "and", "tmy3", "determine", "if", "we", "re", "dealing", "with", "tmy2", "or", "tmy3", "data", "tmy2", "tmy_metadata", "get", "city", "false", "latitude", "tmy_metadata", "latitude", "longitude", "tmy_metadata", "longitude", "if", "tmy2", "name", "tmy_metadata", "city", "else", "name", "tmy_metadata", "name", "tz", "tmy_metadata", "tz", "altitude", "tmy_metadata", "altitude", "new_object", "cls", "latitude", "longitude", "tz", "tz", "altitude", "altitude", "name", "name", "kwargs", "not", "sure", "if", "this", "should", "be", "assigned", "regardless", "of", "input", "if", "tmy_data", "is", "not", "none", "new_object", "tmy_data", "tmy_data", "new_object", "weather", "tmy_data", "return", "new_object"], "doc_len": 140}
{"doc_id": "pvlib/location.py::Location.from_epw", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "from_epw", "text": "文件路径: pvlib/location.py, 类名: Location\n    def from_epw(cls, metadata, data=None, **kwargs):\n        \"\"\"\n        Create a Location object based on a metadata\n        dictionary from epw data readers.\n\n        Parameters\n        ----------\n        metadata : dict\n            Returned from epw.read_epw\n        data : None or DataFrame, default None\n            Optionally attach the epw data to this object.\n\n        Returns\n        -------\n        Location object (or the child class of Location that you\n        called this method from).\n        \"\"\"\n\n        latitude = metadata['latitude']\n        longitude = metadata['longitude']\n\n        name = metadata['city']\n\n        tz = metadata['TZ']\n        altitude = metadata['altitude']\n\n        new_object = cls(latitude, longitude, tz=tz, altitude=altitude,\n                         name=name, **kwargs)\n\n        if data is not None:\n            new_object.weather = data\n\n        return new_object\n", "tokens": ["pvlib", "location", "py", "location", "def", "from_epw", "cls", "metadata", "data", "none", "kwargs", "create", "a", "location", "object", "based", "on", "a", "metadata", "dictionary", "from", "epw", "data", "readers", "parameters", "metadata", "dict", "returned", "from", "epw", "read_epw", "data", "none", "or", "dataframe", "default", "none", "optionally", "attach", "the", "epw", "data", "to", "this", "object", "returns", "location", "object", "or", "the", "child", "class", "of", "location", "that", "you", "called", "this", "method", "from", "latitude", "metadata", "latitude", "longitude", "metadata", "longitude", "name", "metadata", "city", "tz", "metadata", "tz", "altitude", "metadata", "altitude", "new_object", "cls", "latitude", "longitude", "tz", "tz", "altitude", "altitude", "name", "name", "kwargs", "if", "data", "is", "not", "none", "new_object", "weather", "data", "return", "new_object"], "doc_len": 96}
{"doc_id": "pvlib/location.py::Location.get_solarposition", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "get_solarposition", "text": "文件路径: pvlib/location.py, 类名: Location\n    def get_solarposition(self, times, pressure=None, temperature=12,\n                          **kwargs):\n        \"\"\"\n        Uses the :py:func:`pvlib.solarposition.get_solarposition` function\n        to calculate the solar zenith, azimuth, etc. at this location.\n\n        Parameters\n        ----------\n        times : pandas.DatetimeIndex\n            Must be localized or UTC will be assumed.\n        pressure : None, float, or array-like, default None\n            If None, pressure will be calculated using\n            :py:func:`pvlib.atmosphere.alt2pres` and ``self.altitude``.\n        temperature : None, float, or array-like, default 12\n\n        kwargs\n            passed to :py:func:`pvlib.solarposition.get_solarposition`\n\n        Returns\n        -------\n        solar_position : DataFrame\n            Columns depend on the ``method`` kwarg, but always include\n            ``zenith`` and ``azimuth``. The angles are in degrees.\n        \"\"\"\n        if pressure is None:\n            pressure = atmosphere.alt2pres(self.altitude)\n\n        return solarposition.get_solarposition(times, latitude=self.latitude,\n                                               longitude=self.longitude,\n                                               altitude=self.altitude,\n                                               pressure=pressure,\n                                               temperature=temperature,\n                                               **kwargs)\n", "tokens": ["pvlib", "location", "py", "location", "def", "get_solarposition", "self", "times", "pressure", "none", "temperature", "12", "kwargs", "uses", "the", "py", "func", "pvlib", "solarposition", "get_solarposition", "function", "to", "calculate", "the", "solar", "zenith", "azimuth", "etc", "at", "this", "location", "parameters", "times", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "pressure", "none", "float", "or", "array", "like", "default", "none", "if", "none", "pressure", "will", "be", "calculated", "using", "py", "func", "pvlib", "atmosphere", "alt2pres", "and", "self", "altitude", "temperature", "none", "float", "or", "array", "like", "default", "12", "kwargs", "passed", "to", "py", "func", "pvlib", "solarposition", "get_solarposition", "returns", "solar_position", "dataframe", "columns", "depend", "on", "the", "method", "kwarg", "but", "always", "include", "zenith", "and", "azimuth", "the", "angles", "are", "in", "degrees", "if", "pressure", "is", "none", "pressure", "atmosphere", "alt2pres", "self", "altitude", "return", "solarposition", "get_solarposition", "times", "latitude", "self", "latitude", "longitude", "self", "longitude", "altitude", "self", "altitude", "pressure", "pressure", "temperature", "temperature", "kwargs"], "doc_len": 129}
{"doc_id": "pvlib/location.py::Location.get_clearsky", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "get_clearsky", "text": "文件路径: pvlib/location.py, 类名: Location\n    def get_clearsky(self, times, model='ineichen', solar_position=None,\n                     dni_extra=None, **kwargs):\n        \"\"\"\n        Calculate the clear sky estimates of GHI, DNI, and/or DHI\n        at this location.\n\n        Parameters\n        ----------\n        times: DatetimeIndex\n        model: str, default 'ineichen'\n            The clear sky model to use. Must be one of\n            'ineichen', 'haurwitz', 'simplified_solis'.\n        solar_position : None or DataFrame, default None\n            DataFrame with columns 'apparent_zenith', 'zenith',\n            'apparent_elevation'.\n        dni_extra: None or numeric, default None\n            If None, will be calculated from times.\n\n        kwargs\n            Extra parameters passed to the relevant functions. Climatological\n            values are assumed in many cases. See source code for details!\n\n        Returns\n        -------\n        clearsky : DataFrame\n            Column names are: ``ghi, dni, dhi``.\n        \"\"\"\n        if dni_extra is None:\n            dni_extra = irradiance.get_extra_radiation(times)\n\n        try:\n            pressure = kwargs.pop('pressure')\n        except KeyError:\n            pressure = atmosphere.alt2pres(self.altitude)\n\n        if solar_position is None:\n            solar_position = self.get_solarposition(times, pressure=pressure)\n\n        apparent_zenith = solar_position['apparent_zenith']\n        apparent_elevation = solar_position['apparent_elevation']\n\n        if model == 'ineichen':\n            try:\n                linke_turbidity = kwargs.pop('linke_turbidity')\n            except KeyError:\n                interp_turbidity = kwargs.pop('interp_turbidity', True)\n                linke_turbidity = clearsky.lookup_linke_turbidity(\n                    times, self.latitude, self.longitude,\n                    interp_turbidity=interp_turbidity)\n\n            try:\n                airmass_absolute = kwargs.pop('airmass_absolute')\n            except KeyError:\n                airmass_absolute = self.get_airmass(\n                    times, solar_position=solar_position)['airmass_absolute']\n\n            cs = clearsky.ineichen(apparent_zenith, airmass_absolute,\n                                   linke_turbidity, altitude=self.altitude,\n                                   dni_extra=dni_extra, **kwargs)\n        elif model == 'haurwitz':\n            cs = clearsky.haurwitz(apparent_zenith)\n        elif model == 'simplified_solis':\n            cs = clearsky.simplified_solis(\n                apparent_elevation, pressure=pressure, dni_extra=dni_extra,\n                **kwargs)\n        else:\n            raise ValueError('{} is not a valid clear sky model. Must be '\n                             'one of ineichen, simplified_solis, haurwitz'\n                             .format(model))\n\n        return cs\n", "tokens": ["pvlib", "location", "py", "location", "def", "get_clearsky", "self", "times", "model", "ineichen", "solar_position", "none", "dni_extra", "none", "kwargs", "calculate", "the", "clear", "sky", "estimates", "of", "ghi", "dni", "and", "or", "dhi", "at", "this", "location", "parameters", "times", "datetimeindex", "model", "str", "default", "ineichen", "the", "clear", "sky", "model", "to", "use", "must", "be", "one", "of", "ineichen", "haurwitz", "simplified_solis", "solar_position", "none", "or", "dataframe", "default", "none", "dataframe", "with", "columns", "apparent_zenith", "zenith", "apparent_elevation", "dni_extra", "none", "or", "numeric", "default", "none", "if", "none", "will", "be", "calculated", "from", "times", "kwargs", "extra", "parameters", "passed", "to", "the", "relevant", "functions", "climatological", "values", "are", "assumed", "in", "many", "cases", "see", "source", "code", "for", "details", "returns", "clearsky", "dataframe", "column", "names", "are", "ghi", "dni", "dhi", "if", "dni_extra", "is", "none", "dni_extra", "irradiance", "get_extra_radiation", "times", "try", "pressure", "kwargs", "pop", "pressure", "except", "keyerror", "pressure", "atmosphere", "alt2pres", "self", "altitude", "if", "solar_position", "is", "none", "solar_position", "self", "get_solarposition", "times", "pressure", "pressure", "apparent_zenith", "solar_position", "apparent_zenith", "apparent_elevation", "solar_position", "apparent_elevation", "if", "model", "ineichen", "try", "linke_turbidity", "kwargs", "pop", "linke_turbidity", "except", "keyerror", "interp_turbidity", "kwargs", "pop", "interp_turbidity", "true", "linke_turbidity", "clearsky", "lookup_linke_turbidity", "times", "self", "latitude", "self", "longitude", "interp_turbidity", "interp_turbidity", "try", "airmass_absolute", "kwargs", "pop", "airmass_absolute", "except", "keyerror", "airmass_absolute", "self", "get_airmass", "times", "solar_position", "solar_position", "airmass_absolute", "cs", "clearsky", "ineichen", "apparent_zenith", "airmass_absolute", "linke_turbidity", "altitude", "self", "altitude", "dni_extra", "dni_extra", "kwargs", "elif", "model", "haurwitz", "cs", "clearsky", "haurwitz", "apparent_zenith", "elif", "model", "simplified_solis", "cs", "clearsky", "simplified_solis", "apparent_elevation", "pressure", "pressure", "dni_extra", "dni_extra", "kwargs", "else", "raise", "valueerror", "is", "not", "a", "valid", "clear", "sky", "model", "must", "be", "one", "of", "ineichen", "simplified_solis", "haurwitz", "format", "model", "return", "cs"], "doc_len": 230}
{"doc_id": "pvlib/location.py::Location.get_airmass", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "get_airmass", "text": "文件路径: pvlib/location.py, 类名: Location\n    def get_airmass(self, times=None, solar_position=None,\n                    model='kastenyoung1989'):\n        \"\"\"\n        Calculate the relative and absolute airmass.\n\n        Automatically chooses zenith or apparant zenith\n        depending on the selected model.\n\n        Parameters\n        ----------\n        times : None or DatetimeIndex, default None\n            Only used if solar_position is not provided.\n        solar_position : None or DataFrame, default None\n            DataFrame with with columns 'apparent_zenith', 'zenith'.\n        model : str, default 'kastenyoung1989'\n            Relative airmass model. See\n            :py:func:`pvlib.atmosphere.get_relative_airmass`\n            for a list of available models.\n\n        Returns\n        -------\n        airmass : DataFrame\n            Columns are 'airmass_relative', 'airmass_absolute'\n\n        See also\n        --------\n        pvlib.atmosphere.get_relative_airmass\n        \"\"\"\n\n        if solar_position is None:\n            solar_position = self.get_solarposition(times)\n\n        if model in atmosphere.APPARENT_ZENITH_MODELS:\n            zenith = solar_position['apparent_zenith']\n        elif model in atmosphere.TRUE_ZENITH_MODELS:\n            zenith = solar_position['zenith']\n        else:\n            raise ValueError(f'{model} is not a valid airmass model')\n\n        airmass_relative = atmosphere.get_relative_airmass(zenith, model)\n\n        pressure = atmosphere.alt2pres(self.altitude)\n        airmass_absolute = atmosphere.get_absolute_airmass(airmass_relative,\n                                                           pressure)\n\n        airmass = pd.DataFrame(index=solar_position.index)\n        airmass['airmass_relative'] = airmass_relative\n        airmass['airmass_absolute'] = airmass_absolute\n\n        return airmass\n", "tokens": ["pvlib", "location", "py", "location", "def", "get_airmass", "self", "times", "none", "solar_position", "none", "model", "kastenyoung1989", "calculate", "the", "relative", "and", "absolute", "airmass", "automatically", "chooses", "zenith", "or", "apparant", "zenith", "depending", "on", "the", "selected", "model", "parameters", "times", "none", "or", "datetimeindex", "default", "none", "only", "used", "if", "solar_position", "is", "not", "provided", "solar_position", "none", "or", "dataframe", "default", "none", "dataframe", "with", "with", "columns", "apparent_zenith", "zenith", "model", "str", "default", "kastenyoung1989", "relative", "airmass", "model", "see", "py", "func", "pvlib", "atmosphere", "get_relative_airmass", "for", "a", "list", "of", "available", "models", "returns", "airmass", "dataframe", "columns", "are", "airmass_relative", "airmass_absolute", "see", "also", "pvlib", "atmosphere", "get_relative_airmass", "if", "solar_position", "is", "none", "solar_position", "self", "get_solarposition", "times", "if", "model", "in", "atmosphere", "apparent_zenith_models", "zenith", "solar_position", "apparent_zenith", "elif", "model", "in", "atmosphere", "true_zenith_models", "zenith", "solar_position", "zenith", "else", "raise", "valueerror", "f", "model", "is", "not", "a", "valid", "airmass", "model", "airmass_relative", "atmosphere", "get_relative_airmass", "zenith", "model", "pressure", "atmosphere", "alt2pres", "self", "altitude", "airmass_absolute", "atmosphere", "get_absolute_airmass", "airmass_relative", "pressure", "airmass", "pd", "dataframe", "index", "solar_position", "index", "airmass", "airmass_relative", "airmass_relative", "airmass", "airmass_absolute", "airmass_absolute", "return", "airmass"], "doc_len": 151}
{"doc_id": "pvlib/location.py::Location.get_sun_rise_set_transit", "file_path": "pvlib/location.py", "class_name": "Location", "func_name": "get_sun_rise_set_transit", "text": "文件路径: pvlib/location.py, 类名: Location\n    def get_sun_rise_set_transit(self, times, method='pyephem', **kwargs):\n        \"\"\"\n        Calculate sunrise, sunset and transit times.\n\n        Parameters\n        ----------\n        times : DatetimeIndex\n            Must be localized to the Location\n        method : str, default 'pyephem'\n            'pyephem', 'spa', or 'geometric'\n\n        kwargs are passed to the relevant functions. See\n        solarposition.sun_rise_set_transit_<method> for details.\n\n        Returns\n        -------\n        result : DataFrame\n            Column names are: ``sunrise, sunset, transit``.\n        \"\"\"\n\n        if method == 'pyephem':\n            result = solarposition.sun_rise_set_transit_ephem(\n                times, self.latitude, self.longitude, **kwargs)\n        elif method == 'spa':\n            result = solarposition.sun_rise_set_transit_spa(\n                times, self.latitude, self.longitude, **kwargs)\n        elif method == 'geometric':\n            sr, ss, tr = solarposition.sun_rise_set_transit_geometric(\n                times, self.latitude, self.longitude, **kwargs)\n            result = pd.DataFrame(index=times,\n                                  data={'sunrise': sr,\n                                        'sunset': ss,\n                                        'transit': tr})\n        else:\n            raise ValueError('{} is not a valid method. Must be '\n                             'one of pyephem, spa, geometric'\n                             .format(method))\n        return result\n", "tokens": ["pvlib", "location", "py", "location", "def", "get_sun_rise_set_transit", "self", "times", "method", "pyephem", "kwargs", "calculate", "sunrise", "sunset", "and", "transit", "times", "parameters", "times", "datetimeindex", "must", "be", "localized", "to", "the", "location", "method", "str", "default", "pyephem", "pyephem", "spa", "or", "geometric", "kwargs", "are", "passed", "to", "the", "relevant", "functions", "see", "solarposition", "sun_rise_set_transit_", "method", "for", "details", "returns", "result", "dataframe", "column", "names", "are", "sunrise", "sunset", "transit", "if", "method", "pyephem", "result", "solarposition", "sun_rise_set_transit_ephem", "times", "self", "latitude", "self", "longitude", "kwargs", "elif", "method", "spa", "result", "solarposition", "sun_rise_set_transit_spa", "times", "self", "latitude", "self", "longitude", "kwargs", "elif", "method", "geometric", "sr", "ss", "tr", "solarposition", "sun_rise_set_transit_geometric", "times", "self", "latitude", "self", "longitude", "kwargs", "result", "pd", "dataframe", "index", "times", "data", "sunrise", "sr", "sunset", "ss", "transit", "tr", "else", "raise", "valueerror", "is", "not", "a", "valid", "method", "must", "be", "one", "of", "pyephem", "spa", "geometric", "format", "method", "return", "result"], "doc_len": 125}
{"doc_id": "pvlib/location.py::lookup_altitude", "file_path": "pvlib/location.py", "class_name": null, "func_name": "lookup_altitude", "text": "文件路径: pvlib/location.py\ndef lookup_altitude(latitude, longitude):\n    \"\"\"\n    Look up location altitude from low-resolution altitude map\n    supplied with pvlib. The data for this map comes from multiple open data\n    sources with varying resolutions aggregated by Mapzen.\n\n    More details can be found here\n    https://github.com/tilezen/joerd/blob/master/docs/data-sources.md\n\n    Altitudes from this map are a coarse approximation and can have\n    significant errors (100+ meters) introduced by downsampling and\n    source data resolution.\n\n    Parameters\n    ----------\n    latitude : float.\n        Positive is north of the equator.\n        Use decimal degrees notation.\n\n    longitude : float.\n        Positive is east of the prime meridian.\n        Use decimal degrees notation.\n\n    Returns\n    -------\n    altitude : float\n        The altitude of the location in meters.\n\n    Notes\n    -----------\n    Attributions:\n\n    * ArcticDEM terrain data DEM(s) were created from DigitalGlobe, Inc.,\n      imagery and funded under National Science Foundation awards 1043681,\n      1559691, and 1542736;\n    * Australia terrain data © Commonwealth of Australia\n      (Geoscience Australia) 2017;\n    * Austria terrain data © offene Daten Österreichs - Digitales\n      Geländemodell (DGM) Österreich;\n    * Canada terrain data contains information licensed under the Open\n      Government Licence - Canada;\n    * Europe terrain data produced using Copernicus data and information\n      funded by the European Union - EU-DEM layers;\n    * Global ETOPO1 terrain data U.S. National Oceanic and Atmospheric\n      Administration\n    * Mexico terrain data source: INEGI, Continental relief, 2016;\n    * New Zealand terrain data Copyright 2011 Crown copyright (c) Land\n      Information New Zealand and the New Zealand Government\n      (All rights reserved);\n    * Norway terrain data © Kartverket;\n    * United Kingdom terrain data © Environment Agency copyright and/or\n      database right 2015. All rights reserved;\n    * United States 3DEP (formerly NED) and global GMTED2010 and SRTM\n      terrain data courtesy of the U.S. Geological Survey.\n\n    References\n    ----------\n    .. [1] `Mapzen, Linux foundation project for open data maps\n        <https://www.mapzen.com/>`_\n    .. [2] `Joerd, tool for downloading and processing DEMs, Used by Mapzen\n        <https://github.com/tilezen/joerd/>`_\n    .. [3] `AWS, Open Data Registry Terrain Tiles\n        <https://registry.opendata.aws/terrain-tiles/>`_\n\n    \"\"\"\n\n    pvlib_path = os.path.dirname(os.path.abspath(__file__))\n    filepath = os.path.join(pvlib_path, 'data', 'Altitude.h5')\n\n    latitude_index = _degrees_to_index(latitude, coordinate='latitude')\n    longitude_index = _degrees_to_index(longitude, coordinate='longitude')\n\n    with h5py.File(filepath, 'r') as alt_h5_file:\n        alt = alt_h5_file['Altitude'][latitude_index, longitude_index]\n\n    # 255 is a special value that means nodata. Fallback to 0 if nodata.\n    if alt == 255:\n        return 0\n    # Altitude is encoded in 28 meter steps from -450 meters to 6561 meters\n    # There are 0-254 possible altitudes, with 255 reserved for nodata.\n    alt *= 28\n    alt -= 450\n    return float(alt)\n", "tokens": ["pvlib", "location", "py", "def", "lookup_altitude", "latitude", "longitude", "look", "up", "location", "altitude", "from", "low", "resolution", "altitude", "map", "supplied", "with", "pvlib", "the", "data", "for", "this", "map", "comes", "from", "multiple", "open", "data", "sources", "with", "varying", "resolutions", "aggregated", "by", "mapzen", "more", "details", "can", "be", "found", "here", "https", "github", "com", "tilezen", "joerd", "blob", "master", "docs", "data", "sources", "md", "altitudes", "from", "this", "map", "are", "a", "coarse", "approximation", "and", "can", "have", "significant", "errors", "100", "meters", "introduced", "by", "downsampling", "and", "source", "data", "resolution", "parameters", "latitude", "float", "positive", "is", "north", "of", "the", "equator", "use", "decimal", "degrees", "notation", "longitude", "float", "positive", "is", "east", "of", "the", "prime", "meridian", "use", "decimal", "degrees", "notation", "returns", "altitude", "float", "the", "altitude", "of", "the", "location", "in", "meters", "notes", "attributions", "arcticdem", "terrain", "data", "dem", "s", "were", "created", "from", "digitalglobe", "inc", "imagery", "and", "funded", "under", "national", "science", "foundation", "awards", "1043681", "1559691", "and", "1542736", "australia", "terrain", "data", "commonwealth", "of", "australia", "geoscience", "australia", "2017", "austria", "terrain", "data", "offene", "daten", "sterreichs", "digitales", "gel", "ndemodell", "dgm", "sterreich", "canada", "terrain", "data", "contains", "information", "licensed", "under", "the", "open", "government", "licence", "canada", "europe", "terrain", "data", "produced", "using", "copernicus", "data", "and", "information", "funded", "by", "the", "european", "union", "eu", "dem", "layers", "global", "etopo1", "terrain", "data", "u", "s", "national", "oceanic", "and", "atmospheric", "administration", "mexico", "terrain", "data", "source", "inegi", "continental", "relief", "2016", "new", "zealand", "terrain", "data", "copyright", "2011", "crown", "copyright", "c", "land", "information", "new", "zealand", "and", "the", "new", "zealand", "government", "all", "rights", "reserved", "norway", "terrain", "data", "kartverket", "united", "kingdom", "terrain", "data", "environment", "agency", "copyright", "and", "or", "database", "right", "2015", "all", "rights", "reserved", "united", "states", "3dep", "formerly", "ned", "and", "global", "gmted2010", "and", "srtm", "terrain", "data", "courtesy", "of", "the", "u", "s", "geological", "survey", "references", "1", "mapzen", "linux", "foundation", "project", "for", "open", "data", "maps", "https", "www", "mapzen", "com", "_", "2", "joerd", "tool", "for", "downloading", "and", "processing", "dems", "used", "by", "mapzen", "https", "github", "com", "tilezen", "joerd", "_", "3", "aws", "open", "data", "registry", "terrain", "tiles", "https", "registry", "opendata", "aws", "terrain", "tiles", "_", "pvlib_path", "os", "path", "dirname", "os", "path", "abspath", "__file__", "filepath", "os", "path", "join", "pvlib_path", "data", "altitude", "h5", "latitude_index", "_degrees_to_index", "latitude", "coordinate", "latitude", "longitude_index", "_degrees_to_index", "longitude", "coordinate", "longitude", "with", "h5py", "file", "filepath", "r", "as", "alt_h5_file", "alt", "alt_h5_file", "altitude", "latitude_index", "longitude_index", "255", "is", "a", "special", "value", "that", "means", "nodata", "fallback", "to", "0", "if", "nodata", "if", "alt", "255", "return", "0", "altitude", "is", "encoded", "in", "28", "meter", "steps", "from", "450", "meters", "to", "6561", "meters", "there", "are", "0", "254", "possible", "altitudes", "with", "255", "reserved", "for", "nodata", "alt", "28", "alt", "450", "return", "float", "alt"], "doc_len": 395}
{"doc_id": "pvlib/modelchain.py::basic_chain", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "basic_chain", "text": "文件路径: pvlib/modelchain.py\ndef basic_chain(times, latitude, longitude,\n                surface_tilt, surface_azimuth,\n                module_parameters, temperature_model_parameters,\n                inverter_parameters,\n                irradiance=None, weather=None,\n                transposition_model='haydavies',\n                solar_position_method='nrel_numpy',\n                airmass_model='kastenyoung1989',\n                altitude=None, pressure=None,\n                **kwargs):\n    \"\"\"\n    An experimental function that computes all of the modeling steps\n    necessary for calculating power or energy for a PV system at a given\n    location.\n\n    Parameters\n    ----------\n    times : DatetimeIndex\n        Times at which to evaluate the model.\n\n    latitude : float.\n        Positive is north of the equator.\n        Use decimal degrees notation.\n\n    longitude : float.\n        Positive is east of the prime meridian.\n        Use decimal degrees notation.\n\n    surface_tilt : numeric\n        Surface tilt angles in decimal degrees.\n        The tilt angle is defined as degrees from horizontal\n        (e.g. surface facing up = 0, surface facing horizon = 90)\n\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees.\n        The azimuth convention is defined\n        as degrees east of north\n        (North=0, South=180, East=90, West=270).\n\n    module_parameters : None, dict or Series\n        Module parameters as defined by the SAPM. See pvsystem.sapm for\n        details.\n\n    temperature_model_parameters : None, dict or Series.\n        Temperature model parameters as defined by the SAPM.\n        See temperature.sapm_cell for details.\n\n    inverter_parameters : None, dict or Series\n        Inverter parameters as defined by the CEC. See\n        :py:func:`inverter.sandia` for details.\n\n    irradiance : None or DataFrame, default None\n        If None, calculates clear sky data.\n        Columns must be 'dni', 'ghi', 'dhi'.\n\n    weather : None or DataFrame, default None\n        If None, assumes air temperature is 20 C and\n        wind speed is 0 m/s.\n        Columns must be 'wind_speed', 'temp_air'.\n\n    transposition_model : str, default 'haydavies'\n        Passed to system.get_irradiance.\n\n    solar_position_method : str, default 'nrel_numpy'\n        Passed to solarposition.get_solarposition.\n\n    airmass_model : str, default 'kastenyoung1989'\n        Passed to atmosphere.relativeairmass.\n\n    altitude : None or float, default None\n        If None, computed from pressure. Assumed to be 0 m\n        if pressure is also None.\n\n    pressure : None or float, default None\n        If None, computed from altitude. Assumed to be 101325 Pa\n        if altitude is also None.\n\n    **kwargs\n        Arbitrary keyword arguments.\n        See code for details.\n\n    Returns\n    -------\n    output : (dc, ac)\n        Tuple of DC power (with SAPM parameters) (DataFrame) and AC\n        power (Series).\n    \"\"\"\n\n    if altitude is None and pressure is None:\n        altitude = 0.\n        pressure = 101325.\n    elif altitude is None:\n        altitude = atmosphere.pres2alt(pressure)\n    elif pressure is None:\n        pressure = atmosphere.alt2pres(altitude)\n\n    solar_position = solarposition.get_solarposition(\n        times, latitude, longitude, altitude=altitude, pressure=pressure,\n        method=solar_position_method, **kwargs)\n\n    # possible error with using apparent zenith with some models\n    airmass = atmosphere.get_relative_airmass(\n        solar_position['apparent_zenith'], model=airmass_model)\n    airmass = atmosphere.get_absolute_airmass(airmass, pressure)\n    dni_extra = pvlib.irradiance.get_extra_radiation(solar_position.index)\n\n    aoi = pvlib.irradiance.aoi(surface_tilt, surface_azimuth,\n                               solar_position['apparent_zenith'],\n                               solar_position['azimuth'])\n\n    if irradiance is None:\n        linke_turbidity = clearsky.lookup_linke_turbidity(\n            solar_position.index, latitude, longitude)\n        irradiance = clearsky.ineichen(\n            solar_position['apparent_zenith'],\n            airmass,\n            linke_turbidity,\n            altitude=altitude,\n            dni_extra=dni_extra\n        )\n\n    total_irrad = pvlib.irradiance.get_total_irradiance(\n        surface_tilt,\n        surface_azimuth,\n        solar_position['apparent_zenith'],\n        solar_position['azimuth'],\n        irradiance['dni'],\n        irradiance['ghi'],\n        irradiance['dhi'],\n        model=transposition_model,\n        dni_extra=dni_extra)\n\n    if weather is None:\n        weather = {'wind_speed': 0, 'temp_air': 20}\n\n    cell_temperature = temperature.sapm_cell(\n        total_irrad['poa_global'], weather['temp_air'], weather['wind_speed'],\n        temperature_model_parameters['a'], temperature_model_parameters['b'],\n        temperature_model_parameters['deltaT'])\n\n    effective_irradiance = pvsystem.sapm_effective_irradiance(\n        total_irrad['poa_direct'], total_irrad['poa_diffuse'], airmass, aoi,\n        module_parameters)\n\n    dc = pvsystem.sapm(effective_irradiance, cell_temperature,\n                       module_parameters)\n\n    ac = inverter.sandia(dc['v_mp'], dc['p_mp'], inverter_parameters)\n\n    return dc, ac\n", "tokens": ["pvlib", "modelchain", "py", "def", "basic_chain", "times", "latitude", "longitude", "surface_tilt", "surface_azimuth", "module_parameters", "temperature_model_parameters", "inverter_parameters", "irradiance", "none", "weather", "none", "transposition_model", "haydavies", "solar_position_method", "nrel_numpy", "airmass_model", "kastenyoung1989", "altitude", "none", "pressure", "none", "kwargs", "an", "experimental", "function", "that", "computes", "all", "of", "the", "modeling", "steps", "necessary", "for", "calculating", "power", "or", "energy", "for", "a", "pv", "system", "at", "a", "given", "location", "parameters", "times", "datetimeindex", "times", "at", "which", "to", "evaluate", "the", "model", "latitude", "float", "positive", "is", "north", "of", "the", "equator", "use", "decimal", "degrees", "notation", "longitude", "float", "positive", "is", "east", "of", "the", "prime", "meridian", "use", "decimal", "degrees", "notation", "surface_tilt", "numeric", "surface", "tilt", "angles", "in", "decimal", "degrees", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "the", "azimuth", "convention", "is", "defined", "as", "degrees", "east", "of", "north", "north", "0", "south", "180", "east", "90", "west", "270", "module_parameters", "none", "dict", "or", "series", "module", "parameters", "as", "defined", "by", "the", "sapm", "see", "pvsystem", "sapm", "for", "details", "temperature_model_parameters", "none", "dict", "or", "series", "temperature", "model", "parameters", "as", "defined", "by", "the", "sapm", "see", "temperature", "sapm_cell", "for", "details", "inverter_parameters", "none", "dict", "or", "series", "inverter", "parameters", "as", "defined", "by", "the", "cec", "see", "py", "func", "inverter", "sandia", "for", "details", "irradiance", "none", "or", "dataframe", "default", "none", "if", "none", "calculates", "clear", "sky", "data", "columns", "must", "be", "dni", "ghi", "dhi", "weather", "none", "or", "dataframe", "default", "none", "if", "none", "assumes", "air", "temperature", "is", "20", "c", "and", "wind", "speed", "is", "0", "m", "s", "columns", "must", "be", "wind_speed", "temp_air", "transposition_model", "str", "default", "haydavies", "passed", "to", "system", "get_irradiance", "solar_position_method", "str", "default", "nrel_numpy", "passed", "to", "solarposition", "get_solarposition", "airmass_model", "str", "default", "kastenyoung1989", "passed", "to", "atmosphere", "relativeairmass", "altitude", "none", "or", "float", "default", "none", "if", "none", "computed", "from", "pressure", "assumed", "to", "be", "0", "m", "if", "pressure", "is", "also", "none", "pressure", "none", "or", "float", "default", "none", "if", "none", "computed", "from", "altitude", "assumed", "to", "be", "101325", "pa", "if", "altitude", "is", "also", "none", "kwargs", "arbitrary", "keyword", "arguments", "see", "code", "for", "details", "returns", "output", "dc", "ac", "tuple", "of", "dc", "power", "with", "sapm", "parameters", "dataframe", "and", "ac", "power", "series", "if", "altitude", "is", "none", "and", "pressure", "is", "none", "altitude", "0", "pressure", "101325", "elif", "altitude", "is", "none", "altitude", "atmosphere", "pres2alt", "pressure", "elif", "pressure", "is", "none", "pressure", "atmosphere", "alt2pres", "altitude", "solar_position", "solarposition", "get_solarposition", "times", "latitude", "longitude", "altitude", "altitude", "pressure", "pressure", "method", "solar_position_method", "kwargs", "possible", "error", "with", "using", "apparent", "zenith", "with", "some", "models", "airmass", "atmosphere", "get_relative_airmass", "solar_position", "apparent_zenith", "model", "airmass_model", "airmass", "atmosphere", "get_absolute_airmass", "airmass", "pressure", "dni_extra", "pvlib", "irradiance", "get_extra_radiation", "solar_position", "index", "aoi", "pvlib", "irradiance", "aoi", "surface_tilt", "surface_azimuth", "solar_position", "apparent_zenith", "solar_position", "azimuth", "if", "irradiance", "is", "none", "linke_turbidity", "clearsky", "lookup_linke_turbidity", "solar_position", "index", "latitude", "longitude", "irradiance", "clearsky", "ineichen", "solar_position", "apparent_zenith", "airmass", "linke_turbidity", "altitude", "altitude", "dni_extra", "dni_extra", "total_irrad", "pvlib", "irradiance", "get_total_irradiance", "surface_tilt", "surface_azimuth", "solar_position", "apparent_zenith", "solar_position", "azimuth", "irradiance", "dni", "irradiance", "ghi", "irradiance", "dhi", "model", "transposition_model", "dni_extra", "dni_extra", "if", "weather", "is", "none", "weather", "wind_speed", "0", "temp_air", "20", "cell_temperature", "temperature", "sapm_cell", "total_irrad", "poa_global", "weather", "temp_air", "weather", "wind_speed", "temperature_model_parameters", "a", "temperature_model_parameters", "b", "temperature_model_parameters", "deltat", "effective_irradiance", "pvsystem", "sapm_effective_irradiance", "total_irrad", "poa_direct", "total_irrad", "poa_diffuse", "airmass", "aoi", "module_parameters", "dc", "pvsystem", "sapm", "effective_irradiance", "cell_temperature", "module_parameters", "ac", "inverter", "sandia", "dc", "v_mp", "dc", "p_mp", "inverter_parameters", "return", "dc", "ac"], "doc_len": 499}
{"doc_id": "pvlib/modelchain.py::get_orientation", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "get_orientation", "text": "文件路径: pvlib/modelchain.py\ndef get_orientation(strategy, **kwargs):\n    \"\"\"\n    Determine a PV system's surface tilt and surface azimuth\n    using a named strategy.\n\n    Parameters\n    ----------\n    strategy: str\n        The orientation strategy.\n        Allowed strategies include 'flat', 'south_at_latitude_tilt'.\n    **kwargs:\n        Strategy-dependent keyword arguments. See code for details.\n\n    Returns\n    -------\n    surface_tilt, surface_azimuth\n    \"\"\"\n\n    if strategy == 'south_at_latitude_tilt':\n        surface_azimuth = 180\n        surface_tilt = kwargs['latitude']\n    elif strategy == 'flat':\n        surface_azimuth = 180\n        surface_tilt = 0\n    else:\n        raise ValueError('invalid orientation strategy. strategy must '\n                         'be one of south_at_latitude, flat,')\n\n    return surface_tilt, surface_azimuth\n", "tokens": ["pvlib", "modelchain", "py", "def", "get_orientation", "strategy", "kwargs", "determine", "a", "pv", "system", "s", "surface", "tilt", "and", "surface", "azimuth", "using", "a", "named", "strategy", "parameters", "strategy", "str", "the", "orientation", "strategy", "allowed", "strategies", "include", "flat", "south_at_latitude_tilt", "kwargs", "strategy", "dependent", "keyword", "arguments", "see", "code", "for", "details", "returns", "surface_tilt", "surface_azimuth", "if", "strategy", "south_at_latitude_tilt", "surface_azimuth", "180", "surface_tilt", "kwargs", "latitude", "elif", "strategy", "flat", "surface_azimuth", "180", "surface_tilt", "0", "else", "raise", "valueerror", "invalid", "orientation", "strategy", "strategy", "must", "be", "one", "of", "south_at_latitude", "flat", "return", "surface_tilt", "surface_azimuth"], "doc_len": 75}
{"doc_id": "pvlib/modelchain.py::ModelChainResult._result_type", "file_path": "pvlib/modelchain.py", "class_name": "ModelChainResult", "func_name": "_result_type", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChainResult\n    def _result_type(self, value):\n        \"\"\"Coerce `value` to the correct type according to\n        ``self._singleton_tuples``.\"\"\"\n        # Allow None to pass through without being wrapped in a tuple\n        if (self._singleton_tuples\n                and not isinstance(value, tuple)\n                and value is not None):\n            return (value,)\n        return value\n", "tokens": ["pvlib", "modelchain", "py", "modelchainresult", "def", "_result_type", "self", "value", "coerce", "value", "to", "the", "correct", "type", "according", "to", "self", "_singleton_tuples", "allow", "none", "to", "pass", "through", "without", "being", "wrapped", "in", "a", "tuple", "if", "self", "_singleton_tuples", "and", "not", "isinstance", "value", "tuple", "and", "value", "is", "not", "none", "return", "value", "return", "value"], "doc_len": 46}
{"doc_id": "pvlib/modelchain.py::ModelChainResult.__setattr__", "file_path": "pvlib/modelchain.py", "class_name": "ModelChainResult", "func_name": "__setattr__", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChainResult\n    def __setattr__(self, key, value):\n        if key in ModelChainResult._per_array_fields:\n            value = self._result_type(value)\n        super().__setattr__(key, value)\n", "tokens": ["pvlib", "modelchain", "py", "modelchainresult", "def", "__setattr__", "self", "key", "value", "if", "key", "in", "modelchainresult", "_per_array_fields", "value", "self", "_result_type", "value", "super", "__setattr__", "key", "value"], "doc_len": 22}
{"doc_id": "pvlib/modelchain.py::ModelChain.__init__", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "__init__", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def __init__(self, system, location,\n                 clearsky_model='ineichen',\n                 transposition_model='haydavies',\n                 solar_position_method='nrel_numpy',\n                 airmass_model='kastenyoung1989',\n                 dc_model=None, ac_model=None, aoi_model=None,\n                 spectral_model=None, temperature_model=None,\n                 dc_ohmic_model='no_loss',\n                 losses_model='no_loss', name=None):\n\n        self.name = name\n        self.system = system\n\n        self.location = location\n        self.clearsky_model = clearsky_model\n        self.transposition_model = transposition_model\n        self.solar_position_method = solar_position_method\n        self.airmass_model = airmass_model\n\n        # calls setters\n        self.dc_model = dc_model\n        self.ac_model = ac_model\n        self.aoi_model = aoi_model\n        self.spectral_model = spectral_model\n        self.temperature_model = temperature_model\n\n        self.dc_ohmic_model = dc_ohmic_model\n        self.losses_model = losses_model\n\n        self.results = ModelChainResult()\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "__init__", "self", "system", "location", "clearsky_model", "ineichen", "transposition_model", "haydavies", "solar_position_method", "nrel_numpy", "airmass_model", "kastenyoung1989", "dc_model", "none", "ac_model", "none", "aoi_model", "none", "spectral_model", "none", "temperature_model", "none", "dc_ohmic_model", "no_loss", "losses_model", "no_loss", "name", "none", "self", "name", "name", "self", "system", "system", "self", "location", "location", "self", "clearsky_model", "clearsky_model", "self", "transposition_model", "transposition_model", "self", "solar_position_method", "solar_position_method", "self", "airmass_model", "airmass_model", "calls", "setters", "self", "dc_model", "dc_model", "self", "ac_model", "ac_model", "self", "aoi_model", "aoi_model", "self", "spectral_model", "spectral_model", "self", "temperature_model", "temperature_model", "self", "dc_ohmic_model", "dc_ohmic_model", "self", "losses_model", "losses_model", "self", "results", "modelchainresult"], "doc_len": 80}
{"doc_id": "pvlib/modelchain.py::ModelChain.__getattr__", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "__getattr__", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def __getattr__(self, key):\n        if key in ModelChain._deprecated_attrs:\n            msg = f'ModelChain.{key} is deprecated and will' \\\n                  f' be removed in v0.10. Use' \\\n                  f' ModelChain.results.{key} instead'\n            warnings.warn(msg, pvlibDeprecationWarning)\n            return getattr(self.results, key)\n        # __getattr__ is only called if __getattribute__ fails.\n        # In that case we should check if key is a deprecated attribute,\n        # and fail with an AttributeError if it is not.\n        raise AttributeError\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "__getattr__", "self", "key", "if", "key", "in", "modelchain", "_deprecated_attrs", "msg", "f", "modelchain", "key", "is", "deprecated", "and", "will", "f", "be", "removed", "in", "v0", "10", "use", "f", "modelchain", "results", "key", "instead", "warnings", "warn", "msg", "pvlibdeprecationwarning", "return", "getattr", "self", "results", "key", "__getattr__", "is", "only", "called", "if", "__getattribute__", "fails", "in", "that", "case", "we", "should", "check", "if", "key", "is", "a", "deprecated", "attribute", "and", "fail", "with", "an", "attributeerror", "if", "it", "is", "not", "raise", "attributeerror"], "doc_len": 72}
{"doc_id": "pvlib/modelchain.py::ModelChain.__setattr__", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "__setattr__", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def __setattr__(self, key, value):\n        if key in ModelChain._deprecated_attrs:\n            msg = f'ModelChain.{key} is deprecated from v0.9. Use' \\\n                  f' ModelChain.results.{key} instead'\n            warnings.warn(msg, pvlibDeprecationWarning)\n            setattr(self.results, key, value)\n        else:\n            super().__setattr__(key, value)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "__setattr__", "self", "key", "value", "if", "key", "in", "modelchain", "_deprecated_attrs", "msg", "f", "modelchain", "key", "is", "deprecated", "from", "v0", "9", "use", "f", "modelchain", "results", "key", "instead", "warnings", "warn", "msg", "pvlibdeprecationwarning", "setattr", "self", "results", "key", "value", "else", "super", "__setattr__", "key", "value"], "doc_len": 43}
{"doc_id": "pvlib/modelchain.py::ModelChain.with_pvwatts", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "with_pvwatts", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def with_pvwatts(cls, system, location,\n                     clearsky_model='ineichen',\n                     airmass_model='kastenyoung1989',\n                     name=None,\n                     **kwargs):\n        \"\"\"\n        ModelChain that follows the PVWatts methods.\n\n        Parameters\n        ----------\n        system : PVSystem\n            A :py:class:`~pvlib.pvsystem.PVSystem` object that represents\n            the connected set of modules, inverters, etc.\n\n        location : Location\n            A :py:class:`~pvlib.location.Location` object that represents\n            the physical location at which to evaluate the model.\n\n        clearsky_model : str, default 'ineichen'\n            Passed to location.get_clearsky.\n\n        airmass_model : str, default 'kastenyoung1989'\n            Passed to location.get_airmass.\n\n        name: None or str, default None\n            Name of ModelChain instance.\n\n        **kwargs\n            Parameters supplied here are passed to the ModelChain\n            constructor and take precedence over the default\n            configuration.\n\n        Examples\n        --------\n        >>> module_parameters = dict(gamma_pdc=-0.003, pdc0=4500)\n        >>> inverter_parameters = dict(pac0=4000)\n        >>> tparams = TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']\n        >>> system = PVSystem(surface_tilt=30, surface_azimuth=180,\n        ...     module_parameters=module_parameters,\n        ...     inverter_parameters=inverter_parameters,\n        ...     temperature_model_parameters=tparams)\n        >>> location = Location(32.2, -110.9)\n        >>> ModelChain.with_pvwatts(system, location)\n        ModelChain:\n          name: None\n          clearsky_model: ineichen\n          transposition_model: perez\n          solar_position_method: nrel_numpy\n          airmass_model: kastenyoung1989\n          dc_model: pvwatts_dc\n          ac_model: pvwatts_inverter\n          aoi_model: physical_aoi_loss\n          spectral_model: no_spectral_loss\n          temperature_model: sapm_temp\n          losses_model: pvwatts_losses\n        \"\"\"  # noqa: E501\n        config = PVWATTS_CONFIG.copy()\n        config.update(kwargs)\n        return ModelChain(\n            system, location,\n            clearsky_model=clearsky_model,\n            airmass_model=airmass_model,\n            name=name,\n            **config\n        )\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "with_pvwatts", "cls", "system", "location", "clearsky_model", "ineichen", "airmass_model", "kastenyoung1989", "name", "none", "kwargs", "modelchain", "that", "follows", "the", "pvwatts", "methods", "parameters", "system", "pvsystem", "a", "py", "class", "pvlib", "pvsystem", "pvsystem", "object", "that", "represents", "the", "connected", "set", "of", "modules", "inverters", "etc", "location", "location", "a", "py", "class", "pvlib", "location", "location", "object", "that", "represents", "the", "physical", "location", "at", "which", "to", "evaluate", "the", "model", "clearsky_model", "str", "default", "ineichen", "passed", "to", "location", "get_clearsky", "airmass_model", "str", "default", "kastenyoung1989", "passed", "to", "location", "get_airmass", "name", "none", "or", "str", "default", "none", "name", "of", "modelchain", "instance", "kwargs", "parameters", "supplied", "here", "are", "passed", "to", "the", "modelchain", "constructor", "and", "take", "precedence", "over", "the", "default", "configuration", "examples", "module_parameters", "dict", "gamma_pdc", "0", "003", "pdc0", "4500", "inverter_parameters", "dict", "pac0", "4000", "tparams", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "system", "pvsystem", "surface_tilt", "30", "surface_azimuth", "180", "module_parameters", "module_parameters", "inverter_parameters", "inverter_parameters", "temperature_model_parameters", "tparams", "location", "location", "32", "2", "110", "9", "modelchain", "with_pvwatts", "system", "location", "modelchain", "name", "none", "clearsky_model", "ineichen", "transposition_model", "perez", "solar_position_method", "nrel_numpy", "airmass_model", "kastenyoung1989", "dc_model", "pvwatts_dc", "ac_model", "pvwatts_inverter", "aoi_model", "physical_aoi_loss", "spectral_model", "no_spectral_loss", "temperature_model", "sapm_temp", "losses_model", "pvwatts_losses", "noqa", "e501", "config", "pvwatts_config", "copy", "config", "update", "kwargs", "return", "modelchain", "system", "location", "clearsky_model", "clearsky_model", "airmass_model", "airmass_model", "name", "name", "config"], "doc_len": 184}
{"doc_id": "pvlib/modelchain.py::ModelChain.with_sapm", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "with_sapm", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def with_sapm(cls, system, location,\n                  clearsky_model='ineichen',\n                  transposition_model='haydavies',\n                  solar_position_method='nrel_numpy',\n                  airmass_model='kastenyoung1989',\n                  name=None,\n                  **kwargs):\n        \"\"\"\n        ModelChain that follows the Sandia Array Performance Model\n        (SAPM) methods.\n\n        Parameters\n        ----------\n        system : PVSystem\n            A :py:class:`~pvlib.pvsystem.PVSystem` object that represents\n            the connected set of modules, inverters, etc.\n\n        location : Location\n            A :py:class:`~pvlib.location.Location` object that represents\n            the physical location at which to evaluate the model.\n\n        clearsky_model : str, default 'ineichen'\n            Passed to location.get_clearsky.\n\n        transposition_model : str, default 'haydavies'\n            Passed to system.get_irradiance.\n\n        solar_position_method : str, default 'nrel_numpy'\n            Passed to location.get_solarposition.\n\n        airmass_model : str, default 'kastenyoung1989'\n            Passed to location.get_airmass.\n\n        name: None or str, default None\n            Name of ModelChain instance.\n\n        **kwargs\n            Parameters supplied here are passed to the ModelChain\n            constructor and take precedence over the default\n            configuration.\n\n        Examples\n        --------\n        >>> mods = pvlib.pvsystem.retrieve_sam('sandiamod')\n        >>> invs = pvlib.pvsystem.retrieve_sam('cecinverter')\n        >>> module_parameters = mods['Canadian_Solar_CS5P_220M___2009_']\n        >>> inverter_parameters = invs['ABB__MICRO_0_25_I_OUTD_US_240__240V_']\n        >>> tparams = TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']\n        >>> system = PVSystem(surface_tilt=30, surface_azimuth=180,\n        ...     module_parameters=module_parameters,\n        ...     inverter_parameters=inverter_parameters,\n        ...     temperature_model_parameters=tparams)\n        >>> location = Location(32.2, -110.9)\n        >>> ModelChain.with_sapm(system, location)\n        ModelChain:\n          name: None\n          clearsky_model: ineichen\n          transposition_model: haydavies\n          solar_position_method: nrel_numpy\n          airmass_model: kastenyoung1989\n          dc_model: sapm\n          ac_model: snlinverter\n          aoi_model: sapm_aoi_loss\n          spectral_model: sapm_spectral_loss\n          temperature_model: sapm_temp\n          losses_model: no_extra_losses\n        \"\"\"  # noqa: E501\n        config = SAPM_CONFIG.copy()\n        config.update(kwargs)\n        return ModelChain(\n            system, location,\n            clearsky_model=clearsky_model,\n            transposition_model=transposition_model,\n            solar_position_method=solar_position_method,\n            airmass_model=airmass_model,\n            name=name,\n            **config\n        )\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "with_sapm", "cls", "system", "location", "clearsky_model", "ineichen", "transposition_model", "haydavies", "solar_position_method", "nrel_numpy", "airmass_model", "kastenyoung1989", "name", "none", "kwargs", "modelchain", "that", "follows", "the", "sandia", "array", "performance", "model", "sapm", "methods", "parameters", "system", "pvsystem", "a", "py", "class", "pvlib", "pvsystem", "pvsystem", "object", "that", "represents", "the", "connected", "set", "of", "modules", "inverters", "etc", "location", "location", "a", "py", "class", "pvlib", "location", "location", "object", "that", "represents", "the", "physical", "location", "at", "which", "to", "evaluate", "the", "model", "clearsky_model", "str", "default", "ineichen", "passed", "to", "location", "get_clearsky", "transposition_model", "str", "default", "haydavies", "passed", "to", "system", "get_irradiance", "solar_position_method", "str", "default", "nrel_numpy", "passed", "to", "location", "get_solarposition", "airmass_model", "str", "default", "kastenyoung1989", "passed", "to", "location", "get_airmass", "name", "none", "or", "str", "default", "none", "name", "of", "modelchain", "instance", "kwargs", "parameters", "supplied", "here", "are", "passed", "to", "the", "modelchain", "constructor", "and", "take", "precedence", "over", "the", "default", "configuration", "examples", "mods", "pvlib", "pvsystem", "retrieve_sam", "sandiamod", "invs", "pvlib", "pvsystem", "retrieve_sam", "cecinverter", "module_parameters", "mods", "canadian_solar_cs5p_220m___2009_", "inverter_parameters", "invs", "abb__micro_0_25_i_outd_us_240__240v_", "tparams", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "system", "pvsystem", "surface_tilt", "30", "surface_azimuth", "180", "module_parameters", "module_parameters", "inverter_parameters", "inverter_parameters", "temperature_model_parameters", "tparams", "location", "location", "32", "2", "110", "9", "modelchain", "with_sapm", "system", "location", "modelchain", "name", "none", "clearsky_model", "ineichen", "transposition_model", "haydavies", "solar_position_method", "nrel_numpy", "airmass_model", "kastenyoung1989", "dc_model", "sapm", "ac_model", "snlinverter", "aoi_model", "sapm_aoi_loss", "spectral_model", "sapm_spectral_loss", "temperature_model", "sapm_temp", "losses_model", "no_extra_losses", "noqa", "e501", "config", "sapm_config", "copy", "config", "update", "kwargs", "return", "modelchain", "system", "location", "clearsky_model", "clearsky_model", "transposition_model", "transposition_model", "solar_position_method", "solar_position_method", "airmass_model", "airmass_model", "name", "name", "config"], "doc_len": 217}
{"doc_id": "pvlib/modelchain.py::ModelChain.__repr__", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "__repr__", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def __repr__(self):\n        attrs = [\n            'name', 'clearsky_model',\n            'transposition_model', 'solar_position_method',\n            'airmass_model', 'dc_model', 'ac_model', 'aoi_model',\n            'spectral_model', 'temperature_model', 'losses_model'\n        ]\n\n        def getmcattr(self, attr):\n            \"\"\"needed to avoid recursion in property lookups\"\"\"\n            out = getattr(self, attr)\n            try:\n                out = out.__name__\n            except AttributeError:\n                pass\n            return out\n\n        return ('ModelChain: \\n  ' + '\\n  '.join(\n            f'{attr}: {getmcattr(self, attr)}' for attr in attrs))\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "__repr__", "self", "attrs", "name", "clearsky_model", "transposition_model", "solar_position_method", "airmass_model", "dc_model", "ac_model", "aoi_model", "spectral_model", "temperature_model", "losses_model", "def", "getmcattr", "self", "attr", "needed", "to", "avoid", "recursion", "in", "property", "lookups", "out", "getattr", "self", "attr", "try", "out", "out", "__name__", "except", "attributeerror", "pass", "return", "out", "return", "modelchain", "n", "n", "join", "f", "attr", "getmcattr", "self", "attr", "for", "attr", "in", "attrs"], "doc_len": 57}
{"doc_id": "pvlib/modelchain.py::ModelChain.dc_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "dc_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def dc_model(self):\n        return self._dc_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "dc_model", "self", "return", "self", "_dc_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.dc_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "dc_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def dc_model(self, model):\n        # guess at model if None\n        if model is None:\n            self._dc_model, model = self.infer_dc_model()\n\n        # Set model and validate parameters\n        if isinstance(model, str):\n            model = model.lower()\n            if model in _DC_MODEL_PARAMS.keys():\n                # validate module parameters\n                module_parameters = tuple(\n                    array.module_parameters for array in self.system.arrays)\n                missing_params = (\n                    _DC_MODEL_PARAMS[model] - _common_keys(module_parameters))\n                if missing_params:  # some parameters are not in module.keys()\n                    raise ValueError(model + ' selected for the DC model but '\n                                     'one or more Arrays are missing '\n                                     'one or more required parameters '\n                                     ' : ' + str(missing_params))\n                if model == 'sapm':\n                    self._dc_model = self.sapm\n                elif model == 'desoto':\n                    self._dc_model = self.desoto\n                elif model == 'cec':\n                    self._dc_model = self.cec\n                elif model == 'pvsyst':\n                    self._dc_model = self.pvsyst\n                elif model == 'pvwatts':\n                    self._dc_model = self.pvwatts_dc\n            else:\n                raise ValueError(model + ' is not a valid DC power model')\n        else:\n            self._dc_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "dc_model", "self", "model", "guess", "at", "model", "if", "none", "if", "model", "is", "none", "self", "_dc_model", "model", "self", "infer_dc_model", "set", "model", "and", "validate", "parameters", "if", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "in", "_dc_model_params", "keys", "validate", "module", "parameters", "module_parameters", "tuple", "array", "module_parameters", "for", "array", "in", "self", "system", "arrays", "missing_params", "_dc_model_params", "model", "_common_keys", "module_parameters", "if", "missing_params", "some", "parameters", "are", "not", "in", "module", "keys", "raise", "valueerror", "model", "selected", "for", "the", "dc", "model", "but", "one", "or", "more", "arrays", "are", "missing", "one", "or", "more", "required", "parameters", "str", "missing_params", "if", "model", "sapm", "self", "_dc_model", "self", "sapm", "elif", "model", "desoto", "self", "_dc_model", "self", "desoto", "elif", "model", "cec", "self", "_dc_model", "self", "cec", "elif", "model", "pvsyst", "self", "_dc_model", "self", "pvsyst", "elif", "model", "pvwatts", "self", "_dc_model", "self", "pvwatts_dc", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "dc", "power", "model", "else", "self", "_dc_model", "partial", "model", "self"], "doc_len": 140}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_dc_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_dc_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_dc_model(self):\n        \"\"\"Infer DC power model from Array module parameters.\"\"\"\n        params = _common_keys(\n            tuple(array.module_parameters for array in self.system.arrays))\n        if {'A0', 'A1', 'C7'} <= params:\n            return self.sapm, 'sapm'\n        elif {'a_ref', 'I_L_ref', 'I_o_ref', 'R_sh_ref', 'R_s',\n              'Adjust'} <= params:\n            return self.cec, 'cec'\n        elif {'a_ref', 'I_L_ref', 'I_o_ref', 'R_sh_ref', 'R_s'} <= params:\n            return self.desoto, 'desoto'\n        elif {'gamma_ref', 'mu_gamma', 'I_L_ref', 'I_o_ref', 'R_sh_ref',\n              'R_sh_0', 'R_sh_exp', 'R_s'} <= params:\n            return self.pvsyst, 'pvsyst'\n        elif {'pdc0', 'gamma_pdc'} <= params:\n            return self.pvwatts_dc, 'pvwatts'\n        else:\n            raise ValueError(\n                'Could not infer DC model from the module_parameters '\n                'attributes of system.arrays. Check the module_parameters '\n                'attributes or explicitly set the model with the dc_model '\n                'keyword argument.')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_dc_model", "self", "infer", "dc", "power", "model", "from", "array", "module", "parameters", "params", "_common_keys", "tuple", "array", "module_parameters", "for", "array", "in", "self", "system", "arrays", "if", "a0", "a1", "c7", "params", "return", "self", "sapm", "sapm", "elif", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "adjust", "params", "return", "self", "cec", "cec", "elif", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "params", "return", "self", "desoto", "desoto", "elif", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_sh_exp", "r_s", "params", "return", "self", "pvsyst", "pvsyst", "elif", "pdc0", "gamma_pdc", "params", "return", "self", "pvwatts_dc", "pvwatts", "else", "raise", "valueerror", "could", "not", "infer", "dc", "model", "from", "the", "module_parameters", "attributes", "of", "system", "arrays", "check", "the", "module_parameters", "attributes", "or", "explicitly", "set", "the", "model", "with", "the", "dc_model", "keyword", "argument"], "doc_len": 109}
{"doc_id": "pvlib/modelchain.py::ModelChain.sapm", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "sapm", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def sapm(self):\n        dc = self.system.sapm(self.results.effective_irradiance,\n                              self.results.cell_temperature)\n        self.results.dc = self.system.scale_voltage_current_power(dc)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "sapm", "self", "dc", "self", "system", "sapm", "self", "results", "effective_irradiance", "self", "results", "cell_temperature", "self", "results", "dc", "self", "system", "scale_voltage_current_power", "dc", "return", "self"], "doc_len": 26}
{"doc_id": "pvlib/modelchain.py::ModelChain._singlediode", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_singlediode", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _singlediode(self, calcparams_model_function):\n        def _make_diode_params(photocurrent, saturation_current,\n                               resistance_series, resistance_shunt,\n                               nNsVth):\n            return pd.DataFrame(\n                {'I_L': photocurrent, 'I_o': saturation_current,\n                 'R_s': resistance_series, 'R_sh': resistance_shunt,\n                 'nNsVth': nNsVth}\n            )\n        params = calcparams_model_function(self.results.effective_irradiance,\n                                           self.results.cell_temperature,\n                                           unwrap=False)\n        self.results.diode_params = tuple(itertools.starmap(\n            _make_diode_params, params))\n        self.results.dc = tuple(itertools.starmap(\n            self.system.singlediode, params))\n        self.results.dc = self.system.scale_voltage_current_power(\n            self.results.dc,\n            unwrap=False\n        )\n        self.results.dc = tuple(dc.fillna(0) for dc in self.results.dc)\n        # If the system has one Array, unwrap the single return value\n        # to preserve the original behavior of ModelChain\n        if self.system.num_arrays == 1:\n            self.results.diode_params = self.results.diode_params[0]\n            self.results.dc = self.results.dc[0]\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_singlediode", "self", "calcparams_model_function", "def", "_make_diode_params", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "return", "pd", "dataframe", "i_l", "photocurrent", "i_o", "saturation_current", "r_s", "resistance_series", "r_sh", "resistance_shunt", "nnsvth", "nnsvth", "params", "calcparams_model_function", "self", "results", "effective_irradiance", "self", "results", "cell_temperature", "unwrap", "false", "self", "results", "diode_params", "tuple", "itertools", "starmap", "_make_diode_params", "params", "self", "results", "dc", "tuple", "itertools", "starmap", "self", "system", "singlediode", "params", "self", "results", "dc", "self", "system", "scale_voltage_current_power", "self", "results", "dc", "unwrap", "false", "self", "results", "dc", "tuple", "dc", "fillna", "0", "for", "dc", "in", "self", "results", "dc", "if", "the", "system", "has", "one", "array", "unwrap", "the", "single", "return", "value", "to", "preserve", "the", "original", "behavior", "of", "modelchain", "if", "self", "system", "num_arrays", "1", "self", "results", "diode_params", "self", "results", "diode_params", "0", "self", "results", "dc", "self", "results", "dc", "0", "return", "self"], "doc_len": 119}
{"doc_id": "pvlib/modelchain.py::ModelChain.desoto", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "desoto", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def desoto(self):\n        return self._singlediode(self.system.calcparams_desoto)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "desoto", "self", "return", "self", "_singlediode", "self", "system", "calcparams_desoto"], "doc_len": 13}
{"doc_id": "pvlib/modelchain.py::ModelChain.cec", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "cec", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def cec(self):\n        return self._singlediode(self.system.calcparams_cec)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "cec", "self", "return", "self", "_singlediode", "self", "system", "calcparams_cec"], "doc_len": 13}
{"doc_id": "pvlib/modelchain.py::ModelChain.pvsyst", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "pvsyst", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def pvsyst(self):\n        return self._singlediode(self.system.calcparams_pvsyst)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "pvsyst", "self", "return", "self", "_singlediode", "self", "system", "calcparams_pvsyst"], "doc_len": 13}
{"doc_id": "pvlib/modelchain.py::ModelChain.pvwatts_dc", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "pvwatts_dc", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def pvwatts_dc(self):\n        \"\"\"Calculate DC power using the PVWatts model.\n\n        Results are stored in ModelChain.results.dc. DC power is computed\n        from PVSystem.arrays[i].module_parameters['pdc0'] and then scaled by\n        PVSystem.modules_per_string and PVSystem.strings_per_inverter.\n\n        Returns\n        -------\n        self\n\n        See also\n        --------\n        pvlib.pvsystem.PVSystem.pvwatts_dc\n        pvlib.pvsystem.PVSystem.scale_voltage_current_power\n        \"\"\"\n        dc = self.system.pvwatts_dc(\n            self.results.effective_irradiance,\n            self.results.cell_temperature,\n            unwrap=False\n        )\n        p_mp = tuple(pd.DataFrame(s, columns=['p_mp']) for s in dc)\n        scaled = self.system.scale_voltage_current_power(p_mp)\n        self.results.dc = _tuple_from_dfs(scaled, \"p_mp\")\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "pvwatts_dc", "self", "calculate", "dc", "power", "using", "the", "pvwatts", "model", "results", "are", "stored", "in", "modelchain", "results", "dc", "dc", "power", "is", "computed", "from", "pvsystem", "arrays", "i", "module_parameters", "pdc0", "and", "then", "scaled", "by", "pvsystem", "modules_per_string", "and", "pvsystem", "strings_per_inverter", "returns", "self", "see", "also", "pvlib", "pvsystem", "pvsystem", "pvwatts_dc", "pvlib", "pvsystem", "pvsystem", "scale_voltage_current_power", "dc", "self", "system", "pvwatts_dc", "self", "results", "effective_irradiance", "self", "results", "cell_temperature", "unwrap", "false", "p_mp", "tuple", "pd", "dataframe", "s", "columns", "p_mp", "for", "s", "in", "dc", "scaled", "self", "system", "scale_voltage_current_power", "p_mp", "self", "results", "dc", "_tuple_from_dfs", "scaled", "p_mp", "return", "self"], "doc_len": 88}
{"doc_id": "pvlib/modelchain.py::ModelChain.ac_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "ac_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def ac_model(self):\n        return self._ac_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "ac_model", "self", "return", "self", "_ac_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.ac_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "ac_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def ac_model(self, model):\n        if model is None:\n            self._ac_model = self.infer_ac_model()\n        elif isinstance(model, str):\n            model = model.lower()\n            if model == 'sandia':\n                self._ac_model = self.sandia_inverter\n            elif model in 'adr':\n                self._ac_model = self.adr_inverter\n            elif model == 'pvwatts':\n                self._ac_model = self.pvwatts_inverter\n            else:\n                raise ValueError(model + ' is not a valid AC power model')\n        else:\n            self._ac_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "ac_model", "self", "model", "if", "model", "is", "none", "self", "_ac_model", "self", "infer_ac_model", "elif", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "sandia", "self", "_ac_model", "self", "sandia_inverter", "elif", "model", "in", "adr", "self", "_ac_model", "self", "adr_inverter", "elif", "model", "pvwatts", "self", "_ac_model", "self", "pvwatts_inverter", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "ac", "power", "model", "else", "self", "_ac_model", "partial", "model", "self"], "doc_len": 62}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_ac_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_ac_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_ac_model(self):\n        \"\"\"Infer AC power model from system attributes.\"\"\"\n        inverter_params = set(self.system.inverter_parameters.keys())\n        if _snl_params(inverter_params):\n            return self.sandia_inverter\n        if _adr_params(inverter_params):\n            if self.system.num_arrays > 1:\n                raise ValueError(\n                    'The adr inverter function cannot be used for an inverter',\n                    ' with multiple MPPT inputs')\n            else:\n                return self.adr_inverter\n        if _pvwatts_params(inverter_params):\n            return self.pvwatts_inverter\n        raise ValueError('could not infer AC model from '\n                         'system.inverter_parameters. Check '\n                         'system.inverter_parameters or explicitly '\n                         'set the model with the ac_model kwarg.')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_ac_model", "self", "infer", "ac", "power", "model", "from", "system", "attributes", "inverter_params", "set", "self", "system", "inverter_parameters", "keys", "if", "_snl_params", "inverter_params", "return", "self", "sandia_inverter", "if", "_adr_params", "inverter_params", "if", "self", "system", "num_arrays", "1", "raise", "valueerror", "the", "adr", "inverter", "function", "cannot", "be", "used", "for", "an", "inverter", "with", "multiple", "mppt", "inputs", "else", "return", "self", "adr_inverter", "if", "_pvwatts_params", "inverter_params", "return", "self", "pvwatts_inverter", "raise", "valueerror", "could", "not", "infer", "ac", "model", "from", "system", "inverter_parameters", "check", "system", "inverter_parameters", "or", "explicitly", "set", "the", "model", "with", "the", "ac_model", "kwarg"], "doc_len": 82}
{"doc_id": "pvlib/modelchain.py::ModelChain.sandia_inverter", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "sandia_inverter", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def sandia_inverter(self):\n        self.results.ac = self.system.get_ac(\n            'sandia',\n            _tuple_from_dfs(self.results.dc, 'p_mp'),\n            v_dc=_tuple_from_dfs(self.results.dc, 'v_mp')\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "sandia_inverter", "self", "self", "results", "ac", "self", "system", "get_ac", "sandia", "_tuple_from_dfs", "self", "results", "dc", "p_mp", "v_dc", "_tuple_from_dfs", "self", "results", "dc", "v_mp", "return", "self"], "doc_len": 27}
{"doc_id": "pvlib/modelchain.py::ModelChain.adr_inverter", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "adr_inverter", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def adr_inverter(self):\n        self.results.ac = self.system.get_ac(\n            'adr',\n            self.results.dc['p_mp'],\n            v_dc=self.results.dc['v_mp']\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "adr_inverter", "self", "self", "results", "ac", "self", "system", "get_ac", "adr", "self", "results", "dc", "p_mp", "v_dc", "self", "results", "dc", "v_mp", "return", "self"], "doc_len": 25}
{"doc_id": "pvlib/modelchain.py::ModelChain.pvwatts_inverter", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "pvwatts_inverter", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def pvwatts_inverter(self):\n        ac = self.system.get_ac('pvwatts', self.results.dc)\n        self.results.ac = ac.fillna(0)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "pvwatts_inverter", "self", "ac", "self", "system", "get_ac", "pvwatts", "self", "results", "dc", "self", "results", "ac", "ac", "fillna", "0", "return", "self"], "doc_len": 23}
{"doc_id": "pvlib/modelchain.py::ModelChain.aoi_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "aoi_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def aoi_model(self):\n        return self._aoi_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "aoi_model", "self", "return", "self", "_aoi_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.aoi_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "aoi_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def aoi_model(self, model):\n        if model is None:\n            self._aoi_model = self.infer_aoi_model()\n        elif isinstance(model, str):\n            model = model.lower()\n            if model == 'ashrae':\n                self._aoi_model = self.ashrae_aoi_loss\n            elif model == 'physical':\n                self._aoi_model = self.physical_aoi_loss\n            elif model == 'sapm':\n                self._aoi_model = self.sapm_aoi_loss\n            elif model == 'martin_ruiz':\n                self._aoi_model = self.martin_ruiz_aoi_loss\n            elif model == 'no_loss':\n                self._aoi_model = self.no_aoi_loss\n            else:\n                raise ValueError(model + ' is not a valid aoi loss model')\n        else:\n            self._aoi_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "aoi_model", "self", "model", "if", "model", "is", "none", "self", "_aoi_model", "self", "infer_aoi_model", "elif", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "ashrae", "self", "_aoi_model", "self", "ashrae_aoi_loss", "elif", "model", "physical", "self", "_aoi_model", "self", "physical_aoi_loss", "elif", "model", "sapm", "self", "_aoi_model", "self", "sapm_aoi_loss", "elif", "model", "martin_ruiz", "self", "_aoi_model", "self", "martin_ruiz_aoi_loss", "elif", "model", "no_loss", "self", "_aoi_model", "self", "no_aoi_loss", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "aoi", "loss", "model", "else", "self", "_aoi_model", "partial", "model", "self"], "doc_len": 75}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_aoi_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_aoi_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_aoi_model(self):\n        module_parameters = tuple(\n            array.module_parameters for array in self.system.arrays)\n        params = _common_keys(module_parameters)\n        if {'K', 'L', 'n'} <= params:\n            return self.physical_aoi_loss\n        elif {'B5', 'B4', 'B3', 'B2', 'B1', 'B0'} <= params:\n            return self.sapm_aoi_loss\n        elif {'b'} <= params:\n            return self.ashrae_aoi_loss\n        elif {'a_r'} <= params:\n            return self.martin_ruiz_aoi_loss\n        else:\n            raise ValueError('could not infer AOI model from '\n                             'system.arrays[i].module_parameters. Check that '\n                             'the module_parameters for all Arrays in '\n                             'system.arrays contain parameters for '\n                             'the physical, aoi, ashrae or martin_ruiz model; '\n                             'explicitly set the model with the aoi_model '\n                             'kwarg; or set aoi_model=\"no_loss\".')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_aoi_model", "self", "module_parameters", "tuple", "array", "module_parameters", "for", "array", "in", "self", "system", "arrays", "params", "_common_keys", "module_parameters", "if", "k", "l", "n", "params", "return", "self", "physical_aoi_loss", "elif", "b5", "b4", "b3", "b2", "b1", "b0", "params", "return", "self", "sapm_aoi_loss", "elif", "b", "params", "return", "self", "ashrae_aoi_loss", "elif", "a_r", "params", "return", "self", "martin_ruiz_aoi_loss", "else", "raise", "valueerror", "could", "not", "infer", "aoi", "model", "from", "system", "arrays", "i", "module_parameters", "check", "that", "the", "module_parameters", "for", "all", "arrays", "in", "system", "arrays", "contain", "parameters", "for", "the", "physical", "aoi", "ashrae", "or", "martin_ruiz", "model", "explicitly", "set", "the", "model", "with", "the", "aoi_model", "kwarg", "or", "set", "aoi_model", "no_loss"], "doc_len": 96}
{"doc_id": "pvlib/modelchain.py::ModelChain.ashrae_aoi_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "ashrae_aoi_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def ashrae_aoi_loss(self):\n        self.results.aoi_modifier = self.system.get_iam(\n            self.results.aoi,\n            iam_model='ashrae'\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "ashrae_aoi_loss", "self", "self", "results", "aoi_modifier", "self", "system", "get_iam", "self", "results", "aoi", "iam_model", "ashrae", "return", "self"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::ModelChain.physical_aoi_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "physical_aoi_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def physical_aoi_loss(self):\n        self.results.aoi_modifier = self.system.get_iam(\n            self.results.aoi,\n            iam_model='physical'\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "physical_aoi_loss", "self", "self", "results", "aoi_modifier", "self", "system", "get_iam", "self", "results", "aoi", "iam_model", "physical", "return", "self"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::ModelChain.sapm_aoi_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "sapm_aoi_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def sapm_aoi_loss(self):\n        self.results.aoi_modifier = self.system.get_iam(\n            self.results.aoi,\n            iam_model='sapm'\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "sapm_aoi_loss", "self", "self", "results", "aoi_modifier", "self", "system", "get_iam", "self", "results", "aoi", "iam_model", "sapm", "return", "self"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::ModelChain.martin_ruiz_aoi_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "martin_ruiz_aoi_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def martin_ruiz_aoi_loss(self):\n        self.results.aoi_modifier = self.system.get_iam(\n            self.results.aoi, iam_model='martin_ruiz'\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "martin_ruiz_aoi_loss", "self", "self", "results", "aoi_modifier", "self", "system", "get_iam", "self", "results", "aoi", "iam_model", "martin_ruiz", "return", "self"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::ModelChain.no_aoi_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "no_aoi_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def no_aoi_loss(self):\n        if self.system.num_arrays == 1:\n            self.results.aoi_modifier = 1.0\n        else:\n            self.results.aoi_modifier = (1.0,) * self.system.num_arrays\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "no_aoi_loss", "self", "if", "self", "system", "num_arrays", "1", "self", "results", "aoi_modifier", "1", "0", "else", "self", "results", "aoi_modifier", "1", "0", "self", "system", "num_arrays", "return", "self"], "doc_len": 28}
{"doc_id": "pvlib/modelchain.py::ModelChain.spectral_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "spectral_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def spectral_model(self):\n        return self._spectral_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "spectral_model", "self", "return", "self", "_spectral_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.spectral_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "spectral_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def spectral_model(self, model):\n        if model is None:\n            self._spectral_model = self.infer_spectral_model()\n        elif isinstance(model, str):\n            model = model.lower()\n            if model == 'first_solar':\n                self._spectral_model = self.first_solar_spectral_loss\n            elif model == 'sapm':\n                self._spectral_model = self.sapm_spectral_loss\n            elif model == 'no_loss':\n                self._spectral_model = self.no_spectral_loss\n            else:\n                raise ValueError(model + ' is not a valid spectral loss model')\n        else:\n            self._spectral_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "spectral_model", "self", "model", "if", "model", "is", "none", "self", "_spectral_model", "self", "infer_spectral_model", "elif", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "first_solar", "self", "_spectral_model", "self", "first_solar_spectral_loss", "elif", "model", "sapm", "self", "_spectral_model", "self", "sapm_spectral_loss", "elif", "model", "no_loss", "self", "_spectral_model", "self", "no_spectral_loss", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "spectral", "loss", "model", "else", "self", "_spectral_model", "partial", "model", "self"], "doc_len": 61}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_spectral_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_spectral_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_spectral_model(self):\n        \"\"\"Infer spectral model from system attributes.\"\"\"\n        module_parameters = tuple(\n            array.module_parameters for array in self.system.arrays)\n        params = _common_keys(module_parameters)\n        if {'A4', 'A3', 'A2', 'A1', 'A0'} <= params:\n            return self.sapm_spectral_loss\n        elif ((('Technology' in params or\n                'Material' in params) and\n               (self.system._infer_cell_type() is not None)) or\n              'first_solar_spectral_coefficients' in params):\n            return self.first_solar_spectral_loss\n        else:\n            raise ValueError('could not infer spectral model from '\n                             'system.arrays[i].module_parameters. Check that '\n                             'the module_parameters for all Arrays in '\n                             'system.arrays contain valid '\n                             'first_solar_spectral_coefficients, a valid '\n                             'Material or Technology value, or set '\n                             'spectral_model=\"no_loss\".')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_spectral_model", "self", "infer", "spectral", "model", "from", "system", "attributes", "module_parameters", "tuple", "array", "module_parameters", "for", "array", "in", "self", "system", "arrays", "params", "_common_keys", "module_parameters", "if", "a4", "a3", "a2", "a1", "a0", "params", "return", "self", "sapm_spectral_loss", "elif", "technology", "in", "params", "or", "material", "in", "params", "and", "self", "system", "_infer_cell_type", "is", "not", "none", "or", "first_solar_spectral_coefficients", "in", "params", "return", "self", "first_solar_spectral_loss", "else", "raise", "valueerror", "could", "not", "infer", "spectral", "model", "from", "system", "arrays", "i", "module_parameters", "check", "that", "the", "module_parameters", "for", "all", "arrays", "in", "system", "arrays", "contain", "valid", "first_solar_spectral_coefficients", "a", "valid", "material", "or", "technology", "value", "or", "set", "spectral_model", "no_loss"], "doc_len": 94}
{"doc_id": "pvlib/modelchain.py::ModelChain.first_solar_spectral_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "first_solar_spectral_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def first_solar_spectral_loss(self):\n        self.results.spectral_modifier = self.system.first_solar_spectral_loss(\n            _tuple_from_dfs(self.results.weather, 'precipitable_water'),\n            self.results.airmass['airmass_absolute']\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "first_solar_spectral_loss", "self", "self", "results", "spectral_modifier", "self", "system", "first_solar_spectral_loss", "_tuple_from_dfs", "self", "results", "weather", "precipitable_water", "self", "results", "airmass", "airmass_absolute", "return", "self"], "doc_len": 24}
{"doc_id": "pvlib/modelchain.py::ModelChain.sapm_spectral_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "sapm_spectral_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def sapm_spectral_loss(self):\n        self.results.spectral_modifier = self.system.sapm_spectral_loss(\n            self.results.airmass['airmass_absolute']\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "sapm_spectral_loss", "self", "self", "results", "spectral_modifier", "self", "system", "sapm_spectral_loss", "self", "results", "airmass", "airmass_absolute", "return", "self"], "doc_len": 19}
{"doc_id": "pvlib/modelchain.py::ModelChain.no_spectral_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "no_spectral_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def no_spectral_loss(self):\n        if self.system.num_arrays == 1:\n            self.results.spectral_modifier = 1\n        else:\n            self.results.spectral_modifier = (1,) * self.system.num_arrays\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "no_spectral_loss", "self", "if", "self", "system", "num_arrays", "1", "self", "results", "spectral_modifier", "1", "else", "self", "results", "spectral_modifier", "1", "self", "system", "num_arrays", "return", "self"], "doc_len": 26}
{"doc_id": "pvlib/modelchain.py::ModelChain.temperature_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "temperature_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def temperature_model(self):\n        return self._temperature_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "temperature_model", "self", "return", "self", "_temperature_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.temperature_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "temperature_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def temperature_model(self, model):\n        if model is None:\n            self._temperature_model = self.infer_temperature_model()\n        elif isinstance(model, str):\n            model = model.lower()\n            if model == 'sapm':\n                self._temperature_model = self.sapm_temp\n            elif model == 'pvsyst':\n                self._temperature_model = self.pvsyst_temp\n            elif model == 'faiman':\n                self._temperature_model = self.faiman_temp\n            elif model == 'fuentes':\n                self._temperature_model = self.fuentes_temp\n            elif model == 'noct_sam':\n                self._temperature_model = self.noct_sam_temp\n            else:\n                raise ValueError(model + ' is not a valid temperature model')\n            # check system.temperature_model_parameters for consistency\n            name_from_params = self.infer_temperature_model().__name__\n            if self._temperature_model.__name__ != name_from_params:\n                common_params = _common_keys(tuple(\n                    array.temperature_model_parameters\n                    for array in self.system.arrays))\n                raise ValueError(\n                    f'Temperature model {self._temperature_model.__name__} is '\n                    f'inconsistent with PVSystem temperature model '\n                    f'parameters. All Arrays in system.arrays must have '\n                    f'consistent parameters. Common temperature model '\n                    f'parameters: {common_params}'\n                )\n        else:\n            self._temperature_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "temperature_model", "self", "model", "if", "model", "is", "none", "self", "_temperature_model", "self", "infer_temperature_model", "elif", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "sapm", "self", "_temperature_model", "self", "sapm_temp", "elif", "model", "pvsyst", "self", "_temperature_model", "self", "pvsyst_temp", "elif", "model", "faiman", "self", "_temperature_model", "self", "faiman_temp", "elif", "model", "fuentes", "self", "_temperature_model", "self", "fuentes_temp", "elif", "model", "noct_sam", "self", "_temperature_model", "self", "noct_sam_temp", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "temperature", "model", "check", "system", "temperature_model_parameters", "for", "consistency", "name_from_params", "self", "infer_temperature_model", "__name__", "if", "self", "_temperature_model", "__name__", "name_from_params", "common_params", "_common_keys", "tuple", "array", "temperature_model_parameters", "for", "array", "in", "self", "system", "arrays", "raise", "valueerror", "f", "temperature", "model", "self", "_temperature_model", "__name__", "is", "f", "inconsistent", "with", "pvsystem", "temperature", "model", "f", "parameters", "all", "arrays", "in", "system", "arrays", "must", "have", "f", "consistent", "parameters", "common", "temperature", "model", "f", "parameters", "common_params", "else", "self", "_temperature_model", "partial", "model", "self"], "doc_len": 132}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_temperature_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_temperature_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_temperature_model(self):\n        \"\"\"Infer temperature model from system attributes.\"\"\"\n        temperature_model_parameters = tuple(\n            array.temperature_model_parameters for array in self.system.arrays)\n        params = _common_keys(temperature_model_parameters)\n        # remove or statement in v0.9\n        if {'a', 'b', 'deltaT'} <= params or (\n                not params and self.system.racking_model is None\n                and self.system.module_type is None):\n            return self.sapm_temp\n        elif {'u_c', 'u_v'} <= params:\n            return self.pvsyst_temp\n        elif {'u0', 'u1'} <= params:\n            return self.faiman_temp\n        elif {'noct_installed'} <= params:\n            return self.fuentes_temp\n        elif {'noct', 'module_efficiency'} <= params:\n            return self.noct_sam_temp\n        else:\n            raise ValueError(f'could not infer temperature model from '\n                             f'system.temperature_model_parameters. Check '\n                             f'that all Arrays in system.arrays have '\n                             f'parameters for the same temperature model. '\n                             f'Common temperature model parameters: {params}.')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_temperature_model", "self", "infer", "temperature", "model", "from", "system", "attributes", "temperature_model_parameters", "tuple", "array", "temperature_model_parameters", "for", "array", "in", "self", "system", "arrays", "params", "_common_keys", "temperature_model_parameters", "remove", "or", "statement", "in", "v0", "9", "if", "a", "b", "deltat", "params", "or", "not", "params", "and", "self", "system", "racking_model", "is", "none", "and", "self", "system", "module_type", "is", "none", "return", "self", "sapm_temp", "elif", "u_c", "u_v", "params", "return", "self", "pvsyst_temp", "elif", "u0", "u1", "params", "return", "self", "faiman_temp", "elif", "noct_installed", "params", "return", "self", "fuentes_temp", "elif", "noct", "module_efficiency", "params", "return", "self", "noct_sam_temp", "else", "raise", "valueerror", "f", "could", "not", "infer", "temperature", "model", "from", "f", "system", "temperature_model_parameters", "check", "f", "that", "all", "arrays", "in", "system", "arrays", "have", "f", "parameters", "for", "the", "same", "temperature", "model", "f", "common", "temperature", "model", "parameters", "params"], "doc_len": 117}
{"doc_id": "pvlib/modelchain.py::ModelChain._set_celltemp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_set_celltemp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _set_celltemp(self, model):\n        \"\"\"Set self.results.cell_temperature using the given cell\n        temperature model.\n\n        Parameters\n        ----------\n        model : str\n            A cell temperature model name to pass to\n            :py:meth:`pvlib.pvsystem.PVSystem.get_cell_temperature`.\n            Valid names are 'sapm', 'pvsyst', 'faiman', 'fuentes', 'noct_sam'\n\n        Returns\n        -------\n        self\n        \"\"\"\n\n        poa = _irrad_for_celltemp(self.results.total_irrad,\n                                  self.results.effective_irradiance)\n        temp_air = _tuple_from_dfs(self.results.weather, 'temp_air')\n        wind_speed = _tuple_from_dfs(self.results.weather, 'wind_speed')\n        kwargs = {}\n        if model == 'noct_sam':\n            kwargs['effective_irradiance'] = self.results.effective_irradiance\n        self.results.cell_temperature = self.system.get_cell_temperature(\n            poa, temp_air, wind_speed, model=model, **kwargs)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_set_celltemp", "self", "model", "set", "self", "results", "cell_temperature", "using", "the", "given", "cell", "temperature", "model", "parameters", "model", "str", "a", "cell", "temperature", "model", "name", "to", "pass", "to", "py", "meth", "pvlib", "pvsystem", "pvsystem", "get_cell_temperature", "valid", "names", "are", "sapm", "pvsyst", "faiman", "fuentes", "noct_sam", "returns", "self", "poa", "_irrad_for_celltemp", "self", "results", "total_irrad", "self", "results", "effective_irradiance", "temp_air", "_tuple_from_dfs", "self", "results", "weather", "temp_air", "wind_speed", "_tuple_from_dfs", "self", "results", "weather", "wind_speed", "kwargs", "if", "model", "noct_sam", "kwargs", "effective_irradiance", "self", "results", "effective_irradiance", "self", "results", "cell_temperature", "self", "system", "get_cell_temperature", "poa", "temp_air", "wind_speed", "model", "model", "kwargs", "return", "self"], "doc_len": 88}
{"doc_id": "pvlib/modelchain.py::ModelChain.sapm_temp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "sapm_temp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def sapm_temp(self):\n        return self._set_celltemp('sapm')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "sapm_temp", "self", "return", "self", "_set_celltemp", "sapm"], "doc_len": 11}
{"doc_id": "pvlib/modelchain.py::ModelChain.pvsyst_temp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "pvsyst_temp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def pvsyst_temp(self):\n        return self._set_celltemp('pvsyst')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "pvsyst_temp", "self", "return", "self", "_set_celltemp", "pvsyst"], "doc_len": 11}
{"doc_id": "pvlib/modelchain.py::ModelChain.faiman_temp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "faiman_temp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def faiman_temp(self):\n        return self._set_celltemp('faiman')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "faiman_temp", "self", "return", "self", "_set_celltemp", "faiman"], "doc_len": 11}
{"doc_id": "pvlib/modelchain.py::ModelChain.fuentes_temp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "fuentes_temp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def fuentes_temp(self):\n        return self._set_celltemp('fuentes')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "fuentes_temp", "self", "return", "self", "_set_celltemp", "fuentes"], "doc_len": 11}
{"doc_id": "pvlib/modelchain.py::ModelChain.noct_sam_temp", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "noct_sam_temp", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def noct_sam_temp(self):\n        return self._set_celltemp('noct_sam')\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "noct_sam_temp", "self", "return", "self", "_set_celltemp", "noct_sam"], "doc_len": 11}
{"doc_id": "pvlib/modelchain.py::ModelChain.dc_ohmic_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "dc_ohmic_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def dc_ohmic_model(self):\n        return self._dc_ohmic_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "dc_ohmic_model", "self", "return", "self", "_dc_ohmic_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.dc_ohmic_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "dc_ohmic_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def dc_ohmic_model(self, model):\n        if isinstance(model, str):\n            model = model.lower()\n            if model == 'dc_ohms_from_percent':\n                self._dc_ohmic_model = self.dc_ohms_from_percent\n            elif model == 'no_loss':\n                self._dc_ohmic_model = self.no_dc_ohmic_loss\n            else:\n                raise ValueError(model + ' is not a valid losses model')\n        else:\n            self._dc_ohmic_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "dc_ohmic_model", "self", "model", "if", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "dc_ohms_from_percent", "self", "_dc_ohmic_model", "self", "dc_ohms_from_percent", "elif", "model", "no_loss", "self", "_dc_ohmic_model", "self", "no_dc_ohmic_loss", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "losses", "model", "else", "self", "_dc_ohmic_model", "partial", "model", "self"], "doc_len": 45}
{"doc_id": "pvlib/modelchain.py::ModelChain.dc_ohms_from_percent", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "dc_ohms_from_percent", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def dc_ohms_from_percent(self):\n        \"\"\"\n        Calculate time series of ohmic losses and apply those to the mpp power\n        output of the `dc_model` based on the pvsyst equivalent resistance\n        method. Uses a `dc_ohmic_percent` parameter in the `losses_parameters`\n        of the PVsystem.\n        \"\"\"\n        Rw = self.system.dc_ohms_from_percent()\n        if isinstance(self.results.dc, tuple):\n            self.results.dc_ohmic_losses = tuple(\n                pvsystem.dc_ohmic_losses(Rw, df['i_mp'])\n                for Rw, df in zip(Rw, self.results.dc)\n            )\n            for df, loss in zip(self.results.dc, self.results.dc_ohmic_losses):\n                df['p_mp'] = df['p_mp'] - loss\n        else:\n            self.results.dc_ohmic_losses = pvsystem.dc_ohmic_losses(\n                Rw, self.results.dc['i_mp']\n            )\n            self.results.dc['p_mp'] = (self.results.dc['p_mp']\n                                       - self.results.dc_ohmic_losses)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "dc_ohms_from_percent", "self", "calculate", "time", "series", "of", "ohmic", "losses", "and", "apply", "those", "to", "the", "mpp", "power", "output", "of", "the", "dc_model", "based", "on", "the", "pvsyst", "equivalent", "resistance", "method", "uses", "a", "dc_ohmic_percent", "parameter", "in", "the", "losses_parameters", "of", "the", "pvsystem", "rw", "self", "system", "dc_ohms_from_percent", "if", "isinstance", "self", "results", "dc", "tuple", "self", "results", "dc_ohmic_losses", "tuple", "pvsystem", "dc_ohmic_losses", "rw", "df", "i_mp", "for", "rw", "df", "in", "zip", "rw", "self", "results", "dc", "for", "df", "loss", "in", "zip", "self", "results", "dc", "self", "results", "dc_ohmic_losses", "df", "p_mp", "df", "p_mp", "loss", "else", "self", "results", "dc_ohmic_losses", "pvsystem", "dc_ohmic_losses", "rw", "self", "results", "dc", "i_mp", "self", "results", "dc", "p_mp", "self", "results", "dc", "p_mp", "self", "results", "dc_ohmic_losses", "return", "self"], "doc_len": 109}
{"doc_id": "pvlib/modelchain.py::ModelChain.no_dc_ohmic_loss", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "no_dc_ohmic_loss", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def no_dc_ohmic_loss(self):\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "no_dc_ohmic_loss", "self", "return", "self"], "doc_len": 9}
{"doc_id": "pvlib/modelchain.py::ModelChain.losses_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "losses_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def losses_model(self):\n        return self._losses_model\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "losses_model", "self", "return", "self", "_losses_model"], "doc_len": 10}
{"doc_id": "pvlib/modelchain.py::ModelChain.losses_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "losses_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def losses_model(self, model):\n        if model is None:\n            self._losses_model = self.infer_losses_model()\n        elif isinstance(model, str):\n            model = model.lower()\n            if model == 'pvwatts':\n                self._losses_model = self.pvwatts_losses\n            elif model == 'no_loss':\n                self._losses_model = self.no_extra_losses\n            else:\n                raise ValueError(model + ' is not a valid losses model')\n        else:\n            self._losses_model = partial(model, self)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "losses_model", "self", "model", "if", "model", "is", "none", "self", "_losses_model", "self", "infer_losses_model", "elif", "isinstance", "model", "str", "model", "model", "lower", "if", "model", "pvwatts", "self", "_losses_model", "self", "pvwatts_losses", "elif", "model", "no_loss", "self", "_losses_model", "self", "no_extra_losses", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "losses", "model", "else", "self", "_losses_model", "partial", "model", "self"], "doc_len": 53}
{"doc_id": "pvlib/modelchain.py::ModelChain.infer_losses_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "infer_losses_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def infer_losses_model(self):\n        raise NotImplementedError\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "infer_losses_model", "self", "raise", "notimplementederror"], "doc_len": 9}
{"doc_id": "pvlib/modelchain.py::ModelChain.pvwatts_losses", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "pvwatts_losses", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def pvwatts_losses(self):\n        self.results.losses = (100 - self.system.pvwatts_losses()) / 100.\n        if isinstance(self.results.dc, tuple):\n            for dc in self.results.dc:\n                dc *= self.results.losses\n        else:\n            self.results.dc *= self.results.losses\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "pvwatts_losses", "self", "self", "results", "losses", "100", "self", "system", "pvwatts_losses", "100", "if", "isinstance", "self", "results", "dc", "tuple", "for", "dc", "in", "self", "results", "dc", "dc", "self", "results", "losses", "else", "self", "results", "dc", "self", "results", "losses", "return", "self"], "doc_len": 40}
{"doc_id": "pvlib/modelchain.py::ModelChain.no_extra_losses", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "no_extra_losses", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def no_extra_losses(self):\n        self.results.losses = 1\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "no_extra_losses", "self", "self", "results", "losses", "1", "return", "self"], "doc_len": 13}
{"doc_id": "pvlib/modelchain.py::ModelChain.effective_irradiance_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "effective_irradiance_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def effective_irradiance_model(self):\n        def _eff_irrad(module_parameters, total_irrad, spect_mod, aoi_mod):\n            fd = module_parameters.get('FD', 1.)\n            return spect_mod * (total_irrad['poa_direct'] * aoi_mod +\n                                fd * total_irrad['poa_diffuse'])\n        if isinstance(self.results.total_irrad, tuple):\n            self.results.effective_irradiance = tuple(\n                _eff_irrad(array.module_parameters, ti, sm, am) for\n                array, ti, sm, am in zip(\n                    self.system.arrays, self.results.total_irrad,\n                    self.results.spectral_modifier, self.results.aoi_modifier))\n        else:\n            self.results.effective_irradiance = _eff_irrad(\n                self.system.arrays[0].module_parameters,\n                self.results.total_irrad,\n                self.results.spectral_modifier,\n                self.results.aoi_modifier\n            )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "effective_irradiance_model", "self", "def", "_eff_irrad", "module_parameters", "total_irrad", "spect_mod", "aoi_mod", "fd", "module_parameters", "get", "fd", "1", "return", "spect_mod", "total_irrad", "poa_direct", "aoi_mod", "fd", "total_irrad", "poa_diffuse", "if", "isinstance", "self", "results", "total_irrad", "tuple", "self", "results", "effective_irradiance", "tuple", "_eff_irrad", "array", "module_parameters", "ti", "sm", "am", "for", "array", "ti", "sm", "am", "in", "zip", "self", "system", "arrays", "self", "results", "total_irrad", "self", "results", "spectral_modifier", "self", "results", "aoi_modifier", "else", "self", "results", "effective_irradiance", "_eff_irrad", "self", "system", "arrays", "0", "module_parameters", "self", "results", "total_irrad", "self", "results", "spectral_modifier", "self", "results", "aoi_modifier", "return", "self"], "doc_len": 82}
{"doc_id": "pvlib/modelchain.py::ModelChain.complete_irradiance", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "complete_irradiance", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def complete_irradiance(self, weather):\n        \"\"\"\n        Determine the missing irradiation columns. Only two of the\n        following data columns (dni, ghi, dhi) are needed to calculate\n        the missing data.\n\n        This function is not safe at the moment. Results can be too high\n        or negative. Please contribute and help to improve this function\n        on https://github.com/pvlib/pvlib-python\n\n        Parameters\n        ----------\n        weather : DataFrame, or tuple or list of DataFrame\n            Column names must be ``'dni'``, ``'ghi'``, ``'dhi'``,\n            ``'wind_speed'``, ``'temp_air'``. All irradiance components\n            are required. Air temperature of 20 C and wind speed\n            of 0 m/s will be added to the DataFrame if not provided.\n            If `weather` is a tuple it must be the same length as the number\n            of Arrays in the system and the indices for each DataFrame must\n            be the same.\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ValueError\n            if the number of dataframes in `weather` is not the same as the\n            number of Arrays in the system or if the indices of all elements\n            of `weather` are not the same.\n\n        Notes\n        -----\n        Assigns attributes to ``results``: ``times``, ``weather``\n\n        Examples\n        --------\n        This example does not work until the parameters `my_system`,\n        `my_location`, and `my_weather` are defined but shows the basic idea\n        how this method can be used.\n\n        >>> from pvlib.modelchain import ModelChain\n\n        >>> # my_weather containing 'dhi' and 'ghi'.\n        >>> mc = ModelChain(my_system, my_location)  # doctest: +SKIP\n        >>> mc.complete_irradiance(my_weather)  # doctest: +SKIP\n        >>> mc.run_model(mc.results.weather)  # doctest: +SKIP\n\n        >>> # my_weather containing 'dhi', 'ghi' and 'dni'.\n        >>> mc = ModelChain(my_system, my_location)  # doctest: +SKIP\n        >>> mc.run_model(my_weather)  # doctest: +SKIP\n        \"\"\"\n        weather = _to_tuple(weather)\n        self._check_multiple_input(weather)\n        # Don't use ModelChain._assign_weather() here because it adds\n        # temperature and wind-speed columns which we do not need here.\n        self.results.weather = _copy(weather)\n        self._assign_times()\n        self.results.solar_position = self.location.get_solarposition(\n            self.results.times, method=self.solar_position_method)\n        # Calculate the irradiance using the component sum equations,\n        # if needed\n        if isinstance(weather, tuple):\n            for w in self.results.weather:\n                self._complete_irradiance(w)\n        else:\n            self._complete_irradiance(self.results.weather)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "complete_irradiance", "self", "weather", "determine", "the", "missing", "irradiation", "columns", "only", "two", "of", "the", "following", "data", "columns", "dni", "ghi", "dhi", "are", "needed", "to", "calculate", "the", "missing", "data", "this", "function", "is", "not", "safe", "at", "the", "moment", "results", "can", "be", "too", "high", "or", "negative", "please", "contribute", "and", "help", "to", "improve", "this", "function", "on", "https", "github", "com", "pvlib", "pvlib", "python", "parameters", "weather", "dataframe", "or", "tuple", "or", "list", "of", "dataframe", "column", "names", "must", "be", "dni", "ghi", "dhi", "wind_speed", "temp_air", "all", "irradiance", "components", "are", "required", "air", "temperature", "of", "20", "c", "and", "wind", "speed", "of", "0", "m", "s", "will", "be", "added", "to", "the", "dataframe", "if", "not", "provided", "if", "weather", "is", "a", "tuple", "it", "must", "be", "the", "same", "length", "as", "the", "number", "of", "arrays", "in", "the", "system", "and", "the", "indices", "for", "each", "dataframe", "must", "be", "the", "same", "returns", "self", "raises", "valueerror", "if", "the", "number", "of", "dataframes", "in", "weather", "is", "not", "the", "same", "as", "the", "number", "of", "arrays", "in", "the", "system", "or", "if", "the", "indices", "of", "all", "elements", "of", "weather", "are", "not", "the", "same", "notes", "assigns", "attributes", "to", "results", "times", "weather", "examples", "this", "example", "does", "not", "work", "until", "the", "parameters", "my_system", "my_location", "and", "my_weather", "are", "defined", "but", "shows", "the", "basic", "idea", "how", "this", "method", "can", "be", "used", "from", "pvlib", "modelchain", "import", "modelchain", "my_weather", "containing", "dhi", "and", "ghi", "mc", "modelchain", "my_system", "my_location", "doctest", "skip", "mc", "complete_irradiance", "my_weather", "doctest", "skip", "mc", "run_model", "mc", "results", "weather", "doctest", "skip", "my_weather", "containing", "dhi", "ghi", "and", "dni", "mc", "modelchain", "my_system", "my_location", "doctest", "skip", "mc", "run_model", "my_weather", "doctest", "skip", "weather", "_to_tuple", "weather", "self", "_check_multiple_input", "weather", "don", "t", "use", "modelchain", "_assign_weather", "here", "because", "it", "adds", "temperature", "and", "wind", "speed", "columns", "which", "we", "do", "not", "need", "here", "self", "results", "weather", "_copy", "weather", "self", "_assign_times", "self", "results", "solar_position", "self", "location", "get_solarposition", "self", "results", "times", "method", "self", "solar_position_method", "calculate", "the", "irradiance", "using", "the", "component", "sum", "equations", "if", "needed", "if", "isinstance", "weather", "tuple", "for", "w", "in", "self", "results", "weather", "self", "_complete_irradiance", "w", "else", "self", "_complete_irradiance", "self", "results", "weather", "return", "self"], "doc_len": 323}
{"doc_id": "pvlib/modelchain.py::ModelChain._complete_irradiance", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_complete_irradiance", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _complete_irradiance(self, weather):\n        icolumns = set(weather.columns)\n        wrn_txt = (\"This function is not safe at the moment.\\n\" +\n                   \"Results can be too high or negative.\\n\" +\n                   \"Help to improve this function on github:\\n\" +\n                   \"https://github.com/pvlib/pvlib-python \\n\")\n        if {'ghi', 'dhi'} <= icolumns and 'dni' not in icolumns:\n            clearsky = self.location.get_clearsky(\n                weather.index, solar_position=self.results.solar_position)\n            complete_irrad_df = pvlib.irradiance.complete_irradiance(\n                solar_zenith=self.results.solar_position.zenith,\n                ghi=weather.ghi,\n                dhi=weather.dhi,\n                dni=None,\n                dni_clear=clearsky.dni)\n            weather.loc[:, 'dni'] = complete_irrad_df.dni\n        elif {'dni', 'dhi'} <= icolumns and 'ghi' not in icolumns:\n            warnings.warn(wrn_txt, UserWarning)\n            complete_irrad_df = pvlib.irradiance.complete_irradiance(\n                solar_zenith=self.results.solar_position.zenith,\n                ghi=None,\n                dhi=weather.dhi,\n                dni=weather.dni)\n            weather.loc[:, 'ghi'] = complete_irrad_df.ghi\n        elif {'dni', 'ghi'} <= icolumns and 'dhi' not in icolumns:\n            warnings.warn(wrn_txt, UserWarning)\n            complete_irrad_df = pvlib.irradiance.complete_irradiance(\n                solar_zenith=self.results.solar_position.zenith,\n                ghi=weather.ghi,\n                dhi=None,\n                dni=weather.dni)\n            weather.loc[:, 'dhi'] = complete_irrad_df.dhi\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_complete_irradiance", "self", "weather", "icolumns", "set", "weather", "columns", "wrn_txt", "this", "function", "is", "not", "safe", "at", "the", "moment", "n", "results", "can", "be", "too", "high", "or", "negative", "n", "help", "to", "improve", "this", "function", "on", "github", "n", "https", "github", "com", "pvlib", "pvlib", "python", "n", "if", "ghi", "dhi", "icolumns", "and", "dni", "not", "in", "icolumns", "clearsky", "self", "location", "get_clearsky", "weather", "index", "solar_position", "self", "results", "solar_position", "complete_irrad_df", "pvlib", "irradiance", "complete_irradiance", "solar_zenith", "self", "results", "solar_position", "zenith", "ghi", "weather", "ghi", "dhi", "weather", "dhi", "dni", "none", "dni_clear", "clearsky", "dni", "weather", "loc", "dni", "complete_irrad_df", "dni", "elif", "dni", "dhi", "icolumns", "and", "ghi", "not", "in", "icolumns", "warnings", "warn", "wrn_txt", "userwarning", "complete_irrad_df", "pvlib", "irradiance", "complete_irradiance", "solar_zenith", "self", "results", "solar_position", "zenith", "ghi", "none", "dhi", "weather", "dhi", "dni", "weather", "dni", "weather", "loc", "ghi", "complete_irrad_df", "ghi", "elif", "dni", "ghi", "icolumns", "and", "dhi", "not", "in", "icolumns", "warnings", "warn", "wrn_txt", "userwarning", "complete_irrad_df", "pvlib", "irradiance", "complete_irradiance", "solar_zenith", "self", "results", "solar_position", "zenith", "ghi", "weather", "ghi", "dhi", "none", "dni", "weather", "dni", "weather", "loc", "dhi", "complete_irrad_df", "dhi"], "doc_len": 159}
{"doc_id": "pvlib/modelchain.py::ModelChain._prep_inputs_solar_pos", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prep_inputs_solar_pos", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prep_inputs_solar_pos(self, weather):\n        \"\"\"\n        Assign solar position\n        \"\"\"\n        # build weather kwargs for solar position calculation\n        kwargs = _build_kwargs(['pressure', 'temp_air'],\n                               weather[0] if isinstance(weather, tuple)\n                               else weather)\n        try:\n            kwargs['temperature'] = kwargs.pop('temp_air')\n        except KeyError:\n            pass\n\n        self.results.solar_position = self.location.get_solarposition(\n            self.results.times, method=self.solar_position_method,\n            **kwargs)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prep_inputs_solar_pos", "self", "weather", "assign", "solar", "position", "build", "weather", "kwargs", "for", "solar", "position", "calculation", "kwargs", "_build_kwargs", "pressure", "temp_air", "weather", "0", "if", "isinstance", "weather", "tuple", "else", "weather", "try", "kwargs", "temperature", "kwargs", "pop", "temp_air", "except", "keyerror", "pass", "self", "results", "solar_position", "self", "location", "get_solarposition", "self", "results", "times", "method", "self", "solar_position_method", "kwargs", "return", "self"], "doc_len": 54}
{"doc_id": "pvlib/modelchain.py::ModelChain._prep_inputs_albedo", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prep_inputs_albedo", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prep_inputs_albedo(self, weather):\n        \"\"\"\n        Get albedo from weather\n        \"\"\"\n        try:\n            self.results.albedo = _tuple_from_dfs(weather, 'albedo')\n        except KeyError:\n            self.results.albedo = tuple([\n                a.albedo for a in self.system.arrays])\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prep_inputs_albedo", "self", "weather", "get", "albedo", "from", "weather", "try", "self", "results", "albedo", "_tuple_from_dfs", "weather", "albedo", "except", "keyerror", "self", "results", "albedo", "tuple", "a", "albedo", "for", "a", "in", "self", "system", "arrays", "return", "self"], "doc_len": 35}
{"doc_id": "pvlib/modelchain.py::ModelChain._prep_inputs_airmass", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prep_inputs_airmass", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prep_inputs_airmass(self):\n        \"\"\"\n        Assign airmass\n        \"\"\"\n        self.results.airmass = self.location.get_airmass(\n            solar_position=self.results.solar_position,\n            model=self.airmass_model)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prep_inputs_airmass", "self", "assign", "airmass", "self", "results", "airmass", "self", "location", "get_airmass", "solar_position", "self", "results", "solar_position", "model", "self", "airmass_model", "return", "self"], "doc_len": 24}
{"doc_id": "pvlib/modelchain.py::ModelChain._prep_inputs_tracking", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prep_inputs_tracking", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prep_inputs_tracking(self):\n        \"\"\"\n        Calculate tracker position and AOI\n        \"\"\"\n        self.results.tracking = self.system.singleaxis(\n            self.results.solar_position['apparent_zenith'],\n            self.results.solar_position['azimuth'])\n        self.results.tracking['surface_tilt'] = (\n            self.results.tracking['surface_tilt']\n                .fillna(self.system.axis_tilt))\n        self.results.tracking['surface_azimuth'] = (\n            self.results.tracking['surface_azimuth']\n                .fillna(self.system.axis_azimuth))\n        self.results.aoi = self.results.tracking['aoi']\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prep_inputs_tracking", "self", "calculate", "tracker", "position", "and", "aoi", "self", "results", "tracking", "self", "system", "singleaxis", "self", "results", "solar_position", "apparent_zenith", "self", "results", "solar_position", "azimuth", "self", "results", "tracking", "surface_tilt", "self", "results", "tracking", "surface_tilt", "fillna", "self", "system", "axis_tilt", "self", "results", "tracking", "surface_azimuth", "self", "results", "tracking", "surface_azimuth", "fillna", "self", "system", "axis_azimuth", "self", "results", "aoi", "self", "results", "tracking", "aoi", "return", "self"], "doc_len": 59}
{"doc_id": "pvlib/modelchain.py::ModelChain._prep_inputs_fixed", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prep_inputs_fixed", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prep_inputs_fixed(self):\n        \"\"\"\n        Calculate AOI for fixed tilt system\n        \"\"\"\n        self.results.aoi = self.system.get_aoi(\n            self.results.solar_position['apparent_zenith'],\n            self.results.solar_position['azimuth'])\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prep_inputs_fixed", "self", "calculate", "aoi", "for", "fixed", "tilt", "system", "self", "results", "aoi", "self", "system", "get_aoi", "self", "results", "solar_position", "apparent_zenith", "self", "results", "solar_position", "azimuth", "return", "self"], "doc_len": 29}
{"doc_id": "pvlib/modelchain.py::ModelChain._verify_df", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_verify_df", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _verify_df(self, data, required):\n        \"\"\" Checks data for column names in required\n\n        Parameters\n        ----------\n        data : Dataframe\n        required : List of str\n\n        Raises\n        ------\n        ValueError if any of required are not in data.columns.\n        \"\"\"\n        def _verify(data, index=None):\n            if not set(required) <= set(data.columns):\n                tuple_txt = \"\" if index is None else f\"in element {index} \"\n                raise ValueError(\n                    \"Incomplete input data. Data needs to contain \"\n                    f\"{required}. Detected data {tuple_txt}contains: \"\n                    f\"{list(data.columns)}\")\n        if not isinstance(data, tuple):\n            _verify(data)\n        else:\n            for (i, array_data) in enumerate(data):\n                _verify(array_data, i)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_verify_df", "self", "data", "required", "checks", "data", "for", "column", "names", "in", "required", "parameters", "data", "dataframe", "required", "list", "of", "str", "raises", "valueerror", "if", "any", "of", "required", "are", "not", "in", "data", "columns", "def", "_verify", "data", "index", "none", "if", "not", "set", "required", "set", "data", "columns", "tuple_txt", "if", "index", "is", "none", "else", "f", "in", "element", "index", "raise", "valueerror", "incomplete", "input", "data", "data", "needs", "to", "contain", "f", "required", "detected", "data", "tuple_txt", "contains", "f", "list", "data", "columns", "if", "not", "isinstance", "data", "tuple", "_verify", "data", "else", "for", "i", "array_data", "in", "enumerate", "data", "_verify", "array_data", "i"], "doc_len": 92}
{"doc_id": "pvlib/modelchain.py::ModelChain._configure_results", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_configure_results", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _configure_results(self, per_array_data):\n        \"\"\"Configure the type used for per-array fields in\n        ModelChainResult.\n\n        If ``per_array_data`` is True and the number of arrays in the\n        system is 1, then per-array results are stored as length-1\n        tuples. This overrides the PVSystem defaults of unpacking a 1\n        length tuple into a singleton.\n\n        Parameters\n        ----------\n        per_array_data : bool\n            If input data is provided for each array, pass True. If a\n            single input data is provided for all arrays, pass False.\n        \"\"\"\n        self.results._singleton_tuples = (\n            self.system.num_arrays == 1 and per_array_data\n        )\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_configure_results", "self", "per_array_data", "configure", "the", "type", "used", "for", "per", "array", "fields", "in", "modelchainresult", "if", "per_array_data", "is", "true", "and", "the", "number", "of", "arrays", "in", "the", "system", "is", "1", "then", "per", "array", "results", "are", "stored", "as", "length", "1", "tuples", "this", "overrides", "the", "pvsystem", "defaults", "of", "unpacking", "a", "1", "length", "tuple", "into", "a", "singleton", "parameters", "per_array_data", "bool", "if", "input", "data", "is", "provided", "for", "each", "array", "pass", "true", "if", "a", "single", "input", "data", "is", "provided", "for", "all", "arrays", "pass", "false", "self", "results", "_singleton_tuples", "self", "system", "num_arrays", "1", "and", "per_array_data"], "doc_len": 90}
{"doc_id": "pvlib/modelchain.py::ModelChain._assign_weather", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_assign_weather", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _assign_weather(self, data):\n        def _build_weather(data):\n            key_list = [k for k in WEATHER_KEYS if k in data]\n            weather = data[key_list].copy()\n            if weather.get('wind_speed') is None:\n                weather['wind_speed'] = 0\n            if weather.get('temp_air') is None:\n                weather['temp_air'] = 20\n            return weather\n        if isinstance(data, tuple):\n            weather = tuple(_build_weather(wx) for wx in data)\n            self._configure_results(per_array_data=True)\n        else:\n            weather = _build_weather(data)\n            self._configure_results(per_array_data=False)\n        self.results.weather = weather\n        self._assign_times()\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_assign_weather", "self", "data", "def", "_build_weather", "data", "key_list", "k", "for", "k", "in", "weather_keys", "if", "k", "in", "data", "weather", "data", "key_list", "copy", "if", "weather", "get", "wind_speed", "is", "none", "weather", "wind_speed", "0", "if", "weather", "get", "temp_air", "is", "none", "weather", "temp_air", "20", "return", "weather", "if", "isinstance", "data", "tuple", "weather", "tuple", "_build_weather", "wx", "for", "wx", "in", "data", "self", "_configure_results", "per_array_data", "true", "else", "weather", "_build_weather", "data", "self", "_configure_results", "per_array_data", "false", "self", "results", "weather", "weather", "self", "_assign_times", "return", "self"], "doc_len": 77}
{"doc_id": "pvlib/modelchain.py::ModelChain._assign_total_irrad", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_assign_total_irrad", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _assign_total_irrad(self, data):\n        def _build_irrad(data):\n            key_list = [k for k in POA_KEYS if k in data]\n            return data[key_list].copy()\n        if isinstance(data, tuple):\n            self.results.total_irrad = tuple(\n                _build_irrad(irrad_data) for irrad_data in data\n            )\n            return self\n        self.results.total_irrad = _build_irrad(data)\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_assign_total_irrad", "self", "data", "def", "_build_irrad", "data", "key_list", "k", "for", "k", "in", "poa_keys", "if", "k", "in", "data", "return", "data", "key_list", "copy", "if", "isinstance", "data", "tuple", "self", "results", "total_irrad", "tuple", "_build_irrad", "irrad_data", "for", "irrad_data", "in", "data", "return", "self", "self", "results", "total_irrad", "_build_irrad", "data", "return", "self"], "doc_len": 48}
{"doc_id": "pvlib/modelchain.py::ModelChain._assign_times", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_assign_times", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _assign_times(self):\n        \"\"\"Assign self.results.times according the the index of\n        self.results.weather.\n\n        If there are multiple DataFrames in self.results.weather then\n        the index of the first one is assigned. It is assumed that the\n        indices of each DataFrame in self.results.weather are the same.\n        This can be verified by calling :py:func:`_all_same_index` or\n        :py:meth:`self._check_multiple_weather` before calling this\n        method.\n        \"\"\"\n        if isinstance(self.results.weather, tuple):\n            self.results.times = self.results.weather[0].index\n        else:\n            self.results.times = self.results.weather.index\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_assign_times", "self", "assign", "self", "results", "times", "according", "the", "the", "index", "of", "self", "results", "weather", "if", "there", "are", "multiple", "dataframes", "in", "self", "results", "weather", "then", "the", "index", "of", "the", "first", "one", "is", "assigned", "it", "is", "assumed", "that", "the", "indices", "of", "each", "dataframe", "in", "self", "results", "weather", "are", "the", "same", "this", "can", "be", "verified", "by", "calling", "py", "func", "_all_same_index", "or", "py", "meth", "self", "_check_multiple_weather", "before", "calling", "this", "method", "if", "isinstance", "self", "results", "weather", "tuple", "self", "results", "times", "self", "results", "weather", "0", "index", "else", "self", "results", "times", "self", "results", "weather", "index"], "doc_len": 93}
{"doc_id": "pvlib/modelchain.py::ModelChain.prepare_inputs", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "prepare_inputs", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def prepare_inputs(self, weather):\n        \"\"\"\n        Prepare the solar position, irradiance, and weather inputs to\n        the model, starting with GHI, DNI and DHI.\n\n        Parameters\n        ----------\n        weather : DataFrame, or tuple or list of DataFrames\n            Required column names include ``'dni'``, ``'ghi'``, ``'dhi'``.\n            Optional column names are ``'wind_speed'``, ``'temp_air'``,\n            ``'albedo'``.\n\n            If optional columns ``'wind_speed'``, ``'temp_air'`` are not\n            provided, air temperature of 20 C and wind speed\n            of 0 m/s will be added to the ``weather`` DataFrame.\n\n            If optional column ``'albedo'`` is provided, albedo values in the\n            ModelChain's PVSystem.arrays are ignored.\n\n            If `weather` is a tuple or list, it must be of the same length and\n            order as the Arrays of the ModelChain's PVSystem.\n\n        Raises\n        ------\n        ValueError\n            If any `weather` DataFrame(s) is missing an irradiance component.\n        ValueError\n            If `weather` is a tuple or list and the DataFrames it contains have\n            different indices.\n        ValueError\n            If `weather` is a tuple or list with a different length than the\n            number of Arrays in the system.\n\n        Notes\n        -----\n        Assigns attributes to ``results``: ``times``, ``weather``,\n        ``solar_position``, ``airmass``, ``total_irrad``, ``aoi``, ``albedo``.\n\n        See also\n        --------\n        ModelChain.complete_irradiance\n        \"\"\"\n        weather = _to_tuple(weather)\n        self._check_multiple_input(weather, strict=False)\n        self._verify_df(weather, required=['ghi', 'dni', 'dhi'])\n        self._assign_weather(weather)\n\n        self._prep_inputs_solar_pos(weather)\n        self._prep_inputs_airmass()\n        self._prep_inputs_albedo(weather)\n\n        # PVSystem.get_irradiance and SingleAxisTracker.get_irradiance\n        # and PVSystem.get_aoi and SingleAxisTracker.get_aoi\n        # have different method signatures. Use partial to handle\n        # the differences.\n        if isinstance(self.system, SingleAxisTracker):\n            self._prep_inputs_tracking()\n            get_irradiance = partial(\n                self.system.get_irradiance,\n                self.results.tracking['surface_tilt'],\n                self.results.tracking['surface_azimuth'],\n                self.results.solar_position['apparent_zenith'],\n                self.results.solar_position['azimuth'])\n        else:\n            self._prep_inputs_fixed()\n            get_irradiance = partial(\n                self.system.get_irradiance,\n                self.results.solar_position['apparent_zenith'],\n                self.results.solar_position['azimuth'])\n\n        self.results.total_irrad = get_irradiance(\n            _tuple_from_dfs(self.results.weather, 'dni'),\n            _tuple_from_dfs(self.results.weather, 'ghi'),\n            _tuple_from_dfs(self.results.weather, 'dhi'),\n            albedo=self.results.albedo,\n            airmass=self.results.airmass['airmass_relative'],\n            model=self.transposition_model\n        )\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "prepare_inputs", "self", "weather", "prepare", "the", "solar", "position", "irradiance", "and", "weather", "inputs", "to", "the", "model", "starting", "with", "ghi", "dni", "and", "dhi", "parameters", "weather", "dataframe", "or", "tuple", "or", "list", "of", "dataframes", "required", "column", "names", "include", "dni", "ghi", "dhi", "optional", "column", "names", "are", "wind_speed", "temp_air", "albedo", "if", "optional", "columns", "wind_speed", "temp_air", "are", "not", "provided", "air", "temperature", "of", "20", "c", "and", "wind", "speed", "of", "0", "m", "s", "will", "be", "added", "to", "the", "weather", "dataframe", "if", "optional", "column", "albedo", "is", "provided", "albedo", "values", "in", "the", "modelchain", "s", "pvsystem", "arrays", "are", "ignored", "if", "weather", "is", "a", "tuple", "or", "list", "it", "must", "be", "of", "the", "same", "length", "and", "order", "as", "the", "arrays", "of", "the", "modelchain", "s", "pvsystem", "raises", "valueerror", "if", "any", "weather", "dataframe", "s", "is", "missing", "an", "irradiance", "component", "valueerror", "if", "weather", "is", "a", "tuple", "or", "list", "and", "the", "dataframes", "it", "contains", "have", "different", "indices", "valueerror", "if", "weather", "is", "a", "tuple", "or", "list", "with", "a", "different", "length", "than", "the", "number", "of", "arrays", "in", "the", "system", "notes", "assigns", "attributes", "to", "results", "times", "weather", "solar_position", "airmass", "total_irrad", "aoi", "albedo", "see", "also", "modelchain", "complete_irradiance", "weather", "_to_tuple", "weather", "self", "_check_multiple_input", "weather", "strict", "false", "self", "_verify_df", "weather", "required", "ghi", "dni", "dhi", "self", "_assign_weather", "weather", "self", "_prep_inputs_solar_pos", "weather", "self", "_prep_inputs_airmass", "self", "_prep_inputs_albedo", "weather", "pvsystem", "get_irradiance", "and", "singleaxistracker", "get_irradiance", "and", "pvsystem", "get_aoi", "and", "singleaxistracker", "get_aoi", "have", "different", "method", "signatures", "use", "partial", "to", "handle", "the", "differences", "if", "isinstance", "self", "system", "singleaxistracker", "self", "_prep_inputs_tracking", "get_irradiance", "partial", "self", "system", "get_irradiance", "self", "results", "tracking", "surface_tilt", "self", "results", "tracking", "surface_azimuth", "self", "results", "solar_position", "apparent_zenith", "self", "results", "solar_position", "azimuth", "else", "self", "_prep_inputs_fixed", "get_irradiance", "partial", "self", "system", "get_irradiance", "self", "results", "solar_position", "apparent_zenith", "self", "results", "solar_position", "azimuth", "self", "results", "total_irrad", "get_irradiance", "_tuple_from_dfs", "self", "results", "weather", "dni", "_tuple_from_dfs", "self", "results", "weather", "ghi", "_tuple_from_dfs", "self", "results", "weather", "dhi", "albedo", "self", "results", "albedo", "airmass", "self", "results", "airmass", "airmass_relative", "model", "self", "transposition_model", "return", "self"], "doc_len": 303}
{"doc_id": "pvlib/modelchain.py::ModelChain._check_multiple_input", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_check_multiple_input", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _check_multiple_input(self, data, strict=True):\n        \"\"\"Check that the number of elements in `data` is the same as\n        the number of Arrays in `self.system`.\n\n        In most cases if ``self.system.num_arrays`` is greater than 1 we\n        want to raise an error when `data` is not a tuple; however, that\n        behavior can be suppressed by setting ``strict=False``. This is\n        useful for validating inputs such as GHI, DHI, DNI, wind speed, or\n        air temperature that can be applied a ``PVSystem`` as a system-wide\n        input. In this case we want to ensure that when a tuple is provided\n        it has the same length as the number of Arrays, but we do not want\n        to fail if the input is not a tuple.\n        \"\"\"\n        if (not strict or self.system.num_arrays == 1) \\\n                and not isinstance(data, tuple):\n            return\n        if strict and not isinstance(data, tuple):\n            raise TypeError(\"Input must be a tuple of length \"\n                            f\"{self.system.num_arrays}, \"\n                            f\"got {type(data).__name__}.\")\n        if len(data) != self.system.num_arrays:\n            raise ValueError(\"Input must be same length as number of Arrays \"\n                             f\"in system. Expected {self.system.num_arrays}, \"\n                             f\"got {len(data)}.\")\n        _all_same_index(data)\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_check_multiple_input", "self", "data", "strict", "true", "check", "that", "the", "number", "of", "elements", "in", "data", "is", "the", "same", "as", "the", "number", "of", "arrays", "in", "self", "system", "in", "most", "cases", "if", "self", "system", "num_arrays", "is", "greater", "than", "1", "we", "want", "to", "raise", "an", "error", "when", "data", "is", "not", "a", "tuple", "however", "that", "behavior", "can", "be", "suppressed", "by", "setting", "strict", "false", "this", "is", "useful", "for", "validating", "inputs", "such", "as", "ghi", "dhi", "dni", "wind", "speed", "or", "air", "temperature", "that", "can", "be", "applied", "a", "pvsystem", "as", "a", "system", "wide", "input", "in", "this", "case", "we", "want", "to", "ensure", "that", "when", "a", "tuple", "is", "provided", "it", "has", "the", "same", "length", "as", "the", "number", "of", "arrays", "but", "we", "do", "not", "want", "to", "fail", "if", "the", "input", "is", "not", "a", "tuple", "if", "not", "strict", "or", "self", "system", "num_arrays", "1", "and", "not", "isinstance", "data", "tuple", "return", "if", "strict", "and", "not", "isinstance", "data", "tuple", "raise", "typeerror", "input", "must", "be", "a", "tuple", "of", "length", "f", "self", "system", "num_arrays", "f", "got", "type", "data", "__name__", "if", "len", "data", "self", "system", "num_arrays", "raise", "valueerror", "input", "must", "be", "same", "length", "as", "number", "of", "arrays", "f", "in", "system", "expected", "self", "system", "num_arrays", "f", "got", "len", "data", "_all_same_index", "data"], "doc_len": 195}
{"doc_id": "pvlib/modelchain.py::ModelChain.prepare_inputs_from_poa", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "prepare_inputs_from_poa", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def prepare_inputs_from_poa(self, data):\n        \"\"\"\n        Prepare the solar position, irradiance and weather inputs to\n        the model, starting with plane-of-array irradiance.\n\n        Parameters\n        ----------\n        data : DataFrame, or tuple or list of DataFrame\n            Contains plane-of-array irradiance data. Required column names\n            include ``'poa_global'``, ``'poa_direct'`` and ``'poa_diffuse'``.\n            Columns with weather-related data are ssigned to the\n            ``weather`` attribute.  If columns for ``'temp_air'`` and\n            ``'wind_speed'`` are not provided, air temperature of 20 C and wind\n            speed of 0 m/s are assumed.\n\n            If list or tuple, must be of the same length and order as the\n            Arrays of the ModelChain's PVSystem.\n\n        Raises\n        ------\n        ValueError\n             If the number of DataFrames passed in `data` is not the same\n             as the number of Arrays in the system.\n\n        Notes\n        -----\n        Assigns attributes to ``results``: ``times``, ``weather``,\n        ``total_irrad``, ``solar_position``, ``airmass``, ``aoi``.\n\n        See also\n        --------\n        pvlib.modelchain.ModelChain.prepare_inputs\n        \"\"\"\n        data = _to_tuple(data)\n        self._check_multiple_input(data)\n        self._assign_weather(data)\n\n        self._verify_df(data, required=['poa_global', 'poa_direct',\n                                        'poa_diffuse'])\n        self._assign_total_irrad(data)\n\n        self._prep_inputs_solar_pos(data)\n        self._prep_inputs_airmass()\n\n        if isinstance(self.system, SingleAxisTracker):\n            self._prep_inputs_tracking()\n        else:\n            self._prep_inputs_fixed()\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "prepare_inputs_from_poa", "self", "data", "prepare", "the", "solar", "position", "irradiance", "and", "weather", "inputs", "to", "the", "model", "starting", "with", "plane", "of", "array", "irradiance", "parameters", "data", "dataframe", "or", "tuple", "or", "list", "of", "dataframe", "contains", "plane", "of", "array", "irradiance", "data", "required", "column", "names", "include", "poa_global", "poa_direct", "and", "poa_diffuse", "columns", "with", "weather", "related", "data", "are", "ssigned", "to", "the", "weather", "attribute", "if", "columns", "for", "temp_air", "and", "wind_speed", "are", "not", "provided", "air", "temperature", "of", "20", "c", "and", "wind", "speed", "of", "0", "m", "s", "are", "assumed", "if", "list", "or", "tuple", "must", "be", "of", "the", "same", "length", "and", "order", "as", "the", "arrays", "of", "the", "modelchain", "s", "pvsystem", "raises", "valueerror", "if", "the", "number", "of", "dataframes", "passed", "in", "data", "is", "not", "the", "same", "as", "the", "number", "of", "arrays", "in", "the", "system", "notes", "assigns", "attributes", "to", "results", "times", "weather", "total_irrad", "solar_position", "airmass", "aoi", "see", "also", "pvlib", "modelchain", "modelchain", "prepare_inputs", "data", "_to_tuple", "data", "self", "_check_multiple_input", "data", "self", "_assign_weather", "data", "self", "_verify_df", "data", "required", "poa_global", "poa_direct", "poa_diffuse", "self", "_assign_total_irrad", "data", "self", "_prep_inputs_solar_pos", "data", "self", "_prep_inputs_airmass", "if", "isinstance", "self", "system", "singleaxistracker", "self", "_prep_inputs_tracking", "else", "self", "_prep_inputs_fixed", "return", "self"], "doc_len": 177}
{"doc_id": "pvlib/modelchain.py::ModelChain._get_cell_temperature", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_get_cell_temperature", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _get_cell_temperature(self, data,\n                              poa, temperature_model_parameters):\n        \"\"\"Extract the cell temperature data from a DataFrame.\n\n        If 'cell_temperature' column exists in data then it is returned. If\n        'module_temperature' column exists in data, then it is used with poa to\n        calculate the cell temperature. If neither column exists then None is\n        returned.\n\n        Parameters\n        ----------\n        data : DataFrame (not a tuple of DataFrame)\n        poa : Series (not a tuple of Series)\n\n        Returns\n        -------\n        Series\n        \"\"\"\n        if 'cell_temperature' in data:\n            return data['cell_temperature']\n        # cell_temperature is not in input. Calculate cell_temperature using\n        # a temperature_model.\n        # If module_temperature is in input data we can use the SAPM cell\n        # temperature model.\n        if (('module_temperature' in data) and\n                (self.temperature_model == self.sapm_temp)):\n            # use SAPM cell temperature model only\n            return pvlib.temperature.sapm_cell_from_module(\n                module_temperature=data['module_temperature'],\n                poa_global=poa,\n                deltaT=temperature_model_parameters['deltaT'])\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_get_cell_temperature", "self", "data", "poa", "temperature_model_parameters", "extract", "the", "cell", "temperature", "data", "from", "a", "dataframe", "if", "cell_temperature", "column", "exists", "in", "data", "then", "it", "is", "returned", "if", "module_temperature", "column", "exists", "in", "data", "then", "it", "is", "used", "with", "poa", "to", "calculate", "the", "cell", "temperature", "if", "neither", "column", "exists", "then", "none", "is", "returned", "parameters", "data", "dataframe", "not", "a", "tuple", "of", "dataframe", "poa", "series", "not", "a", "tuple", "of", "series", "returns", "series", "if", "cell_temperature", "in", "data", "return", "data", "cell_temperature", "cell_temperature", "is", "not", "in", "input", "calculate", "cell_temperature", "using", "a", "temperature_model", "if", "module_temperature", "is", "in", "input", "data", "we", "can", "use", "the", "sapm", "cell", "temperature", "model", "if", "module_temperature", "in", "data", "and", "self", "temperature_model", "self", "sapm_temp", "use", "sapm", "cell", "temperature", "model", "only", "return", "pvlib", "temperature", "sapm_cell_from_module", "module_temperature", "data", "module_temperature", "poa_global", "poa", "deltat", "temperature_model_parameters", "deltat"], "doc_len": 128}
{"doc_id": "pvlib/modelchain.py::ModelChain._prepare_temperature_single_array", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prepare_temperature_single_array", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prepare_temperature_single_array(self, data, poa):\n        \"\"\"Set cell_temperature using a single data frame.\"\"\"\n        self.results.cell_temperature = self._get_cell_temperature(\n            data,\n            poa,\n            self.system.arrays[0].temperature_model_parameters\n        )\n        if self.results.cell_temperature is None:\n            self.temperature_model()\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prepare_temperature_single_array", "self", "data", "poa", "set", "cell_temperature", "using", "a", "single", "data", "frame", "self", "results", "cell_temperature", "self", "_get_cell_temperature", "data", "poa", "self", "system", "arrays", "0", "temperature_model_parameters", "if", "self", "results", "cell_temperature", "is", "none", "self", "temperature_model", "return", "self"], "doc_len": 38}
{"doc_id": "pvlib/modelchain.py::ModelChain._prepare_temperature", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_prepare_temperature", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _prepare_temperature(self, data=None):\n        \"\"\"\n        Sets cell_temperature using inputs in data and the specified\n        temperature model.\n\n        If 'data' contains 'cell_temperature', these values are assigned to\n        attribute ``cell_temperature``. If 'data' contains 'module_temperature`\n        and `temperature_model' is 'sapm', cell temperature is calculated using\n        :py:func:`pvlib.temperature.sapm_cell_from_module`. Otherwise, cell\n        temperature is calculated by 'temperature_model'.\n\n        Parameters\n        ----------\n        data : DataFrame, default None\n            May contain columns ``'cell_temperature'`` or\n            ``'module_temperaure'``.\n\n        Returns\n        -------\n        self\n\n        Assigns attribute ``results.cell_temperature``.\n\n        \"\"\"\n        poa = _irrad_for_celltemp(self.results.total_irrad,\n                                  self.results.effective_irradiance)\n        # handle simple case first, single array, data not iterable\n        if not isinstance(data, tuple) and self.system.num_arrays == 1:\n            return self._prepare_temperature_single_array(data, poa)\n        if not isinstance(data, tuple):\n            # broadcast data to all arrays\n            data = (data,) * self.system.num_arrays\n        # data is tuple, so temperature_model_parameters must also be\n        # tuple. system.temperature_model_parameters is reduced to a dict\n        # if system.num_arrays == 1, so manually access parameters. GH 1192\n        t_mod_params = tuple(array.temperature_model_parameters\n                             for array in self.system.arrays)\n        # find where cell or module temperature is specified in input data\n        given_cell_temperature = tuple(itertools.starmap(\n            self._get_cell_temperature, zip(data, poa, t_mod_params)\n        ))\n        # If cell temperature has been specified for all arrays return\n        # immediately and do not try to compute it.\n        if all(cell_temp is not None for cell_temp in given_cell_temperature):\n            self.results.cell_temperature = given_cell_temperature\n            return self\n        # Calculate cell temperature from weather data. If cell_temperature\n        # has not been provided for some arrays then it is computed.\n        self.temperature_model()\n        # replace calculated cell temperature with temperature given in `data`\n        # where available.\n        self.results.cell_temperature = tuple(\n            itertools.starmap(\n                lambda given, modeled: modeled if given is None else given,\n                zip(given_cell_temperature, self.results.cell_temperature)\n            )\n        )\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_prepare_temperature", "self", "data", "none", "sets", "cell_temperature", "using", "inputs", "in", "data", "and", "the", "specified", "temperature", "model", "if", "data", "contains", "cell_temperature", "these", "values", "are", "assigned", "to", "attribute", "cell_temperature", "if", "data", "contains", "module_temperature", "and", "temperature_model", "is", "sapm", "cell", "temperature", "is", "calculated", "using", "py", "func", "pvlib", "temperature", "sapm_cell_from_module", "otherwise", "cell", "temperature", "is", "calculated", "by", "temperature_model", "parameters", "data", "dataframe", "default", "none", "may", "contain", "columns", "cell_temperature", "or", "module_temperaure", "returns", "self", "assigns", "attribute", "results", "cell_temperature", "poa", "_irrad_for_celltemp", "self", "results", "total_irrad", "self", "results", "effective_irradiance", "handle", "simple", "case", "first", "single", "array", "data", "not", "iterable", "if", "not", "isinstance", "data", "tuple", "and", "self", "system", "num_arrays", "1", "return", "self", "_prepare_temperature_single_array", "data", "poa", "if", "not", "isinstance", "data", "tuple", "broadcast", "data", "to", "all", "arrays", "data", "data", "self", "system", "num_arrays", "data", "is", "tuple", "so", "temperature_model_parameters", "must", "also", "be", "tuple", "system", "temperature_model_parameters", "is", "reduced", "to", "a", "dict", "if", "system", "num_arrays", "1", "so", "manually", "access", "parameters", "gh", "1192", "t_mod_params", "tuple", "array", "temperature_model_parameters", "for", "array", "in", "self", "system", "arrays", "find", "where", "cell", "or", "module", "temperature", "is", "specified", "in", "input", "data", "given_cell_temperature", "tuple", "itertools", "starmap", "self", "_get_cell_temperature", "zip", "data", "poa", "t_mod_params", "if", "cell", "temperature", "has", "been", "specified", "for", "all", "arrays", "return", "immediately", "and", "do", "not", "try", "to", "compute", "it", "if", "all", "cell_temp", "is", "not", "none", "for", "cell_temp", "in", "given_cell_temperature", "self", "results", "cell_temperature", "given_cell_temperature", "return", "self", "calculate", "cell", "temperature", "from", "weather", "data", "if", "cell_temperature", "has", "not", "been", "provided", "for", "some", "arrays", "then", "it", "is", "computed", "self", "temperature_model", "replace", "calculated", "cell", "temperature", "with", "temperature", "given", "in", "data", "where", "available", "self", "results", "cell_temperature", "tuple", "itertools", "starmap", "lambda", "given", "modeled", "modeled", "if", "given", "is", "none", "else", "given", "zip", "given_cell_temperature", "self", "results", "cell_temperature", "return", "self"], "doc_len": 266}
{"doc_id": "pvlib/modelchain.py::ModelChain.run_model", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "run_model", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def run_model(self, weather):\n        \"\"\"\n        Run the model chain starting with broadband global, diffuse and/or\n        direct irradiance.\n\n        Parameters\n        ----------\n        weather : DataFrame, or tuple or list of DataFrame\n            Column names must include:\n\n            - ``'dni'``\n            - ``'ghi'``\n            - ``'dhi'``\n\n            Optional columns are:\n\n            - ``'temp_air'``\n            - ``'cell_temperature'``\n            - ``'module_temperature'``\n            - ``'wind_speed'``\n            - ``'albedo'``\n\n            If optional columns ``'temp_air'`` and ``'wind_speed'``\n            are not provided, air temperature of 20 C and wind speed of 0 m/s\n            are added to the DataFrame. If optional column\n            ``'cell_temperature'`` is provided, these values are used instead\n            of `temperature_model`. If optional column ``'module_temperature'``\n            is provided, ``temperature_model`` must be ``'sapm'``.\n\n            If optional column ``'albedo'`` is provided, ``'albedo'`` may not\n            be present on the ModelChain's PVSystem.Arrays.\n\n            If weather is a list or tuple, it must be of the same length and\n            order as the Arrays of the ModelChain's PVSystem.\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ValueError\n            If the number of DataFrames in `data` is different than the number\n            of Arrays in the PVSystem.\n        ValueError\n            If the DataFrames in `data` have different indexes.\n\n        Notes\n        -----\n        Assigns attributes to ``results``: ``times``, ``weather``,\n        ``solar_position``, ``airmass``, ``total_irrad``, ``aoi``,\n        ``aoi_modifier``, ``spectral_modifier``, and\n        ``effective_irradiance``, ``cell_temperature``, ``dc``, ``ac``,\n        ``losses``, ``diode_params`` (if dc_model is a single diode\n        model).\n\n        See also\n        --------\n        pvlib.modelchain.ModelChain.run_model_from_poa\n        pvlib.modelchain.ModelChain.run_model_from_effective_irradiance\n        \"\"\"\n        weather = _to_tuple(weather)\n        self.prepare_inputs(weather)\n        self.aoi_model()\n        self.spectral_model()\n        self.effective_irradiance_model()\n\n        self._run_from_effective_irrad(weather)\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "run_model", "self", "weather", "run", "the", "model", "chain", "starting", "with", "broadband", "global", "diffuse", "and", "or", "direct", "irradiance", "parameters", "weather", "dataframe", "or", "tuple", "or", "list", "of", "dataframe", "column", "names", "must", "include", "dni", "ghi", "dhi", "optional", "columns", "are", "temp_air", "cell_temperature", "module_temperature", "wind_speed", "albedo", "if", "optional", "columns", "temp_air", "and", "wind_speed", "are", "not", "provided", "air", "temperature", "of", "20", "c", "and", "wind", "speed", "of", "0", "m", "s", "are", "added", "to", "the", "dataframe", "if", "optional", "column", "cell_temperature", "is", "provided", "these", "values", "are", "used", "instead", "of", "temperature_model", "if", "optional", "column", "module_temperature", "is", "provided", "temperature_model", "must", "be", "sapm", "if", "optional", "column", "albedo", "is", "provided", "albedo", "may", "not", "be", "present", "on", "the", "modelchain", "s", "pvsystem", "arrays", "if", "weather", "is", "a", "list", "or", "tuple", "it", "must", "be", "of", "the", "same", "length", "and", "order", "as", "the", "arrays", "of", "the", "modelchain", "s", "pvsystem", "returns", "self", "raises", "valueerror", "if", "the", "number", "of", "dataframes", "in", "data", "is", "different", "than", "the", "number", "of", "arrays", "in", "the", "pvsystem", "valueerror", "if", "the", "dataframes", "in", "data", "have", "different", "indexes", "notes", "assigns", "attributes", "to", "results", "times", "weather", "solar_position", "airmass", "total_irrad", "aoi", "aoi_modifier", "spectral_modifier", "and", "effective_irradiance", "cell_temperature", "dc", "ac", "losses", "diode_params", "if", "dc_model", "is", "a", "single", "diode", "model", "see", "also", "pvlib", "modelchain", "modelchain", "run_model_from_poa", "pvlib", "modelchain", "modelchain", "run_model_from_effective_irradiance", "weather", "_to_tuple", "weather", "self", "prepare_inputs", "weather", "self", "aoi_model", "self", "spectral_model", "self", "effective_irradiance_model", "self", "_run_from_effective_irrad", "weather", "return", "self"], "doc_len": 219}
{"doc_id": "pvlib/modelchain.py::ModelChain.run_model_from_poa", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "run_model_from_poa", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def run_model_from_poa(self, data):\n        \"\"\"\n        Run the model starting with broadband irradiance in the plane of array.\n\n        Data must include direct, diffuse and total irradiance (W/m2) in the\n        plane of array. Reflections and spectral adjustments are made to\n        calculate effective irradiance (W/m2).\n\n        Parameters\n        ----------\n        data : DataFrame, or tuple or list of DataFrame\n            Required column names include ``'poa_global'``,\n            ``'poa_direct'`` and ``'poa_diffuse'``. If optional columns\n            ``'temp_air'`` and ``'wind_speed'`` are not provided, air\n            temperature of 20 C and wind speed of 0 m/s are assumed.\n            If optional column ``'cell_temperature'`` is provided, these values\n            are used instead of `temperature_model`. If optional column\n            ``'module_temperature'`` is provided, `temperature_model` must be\n            ``'sapm'``.\n\n            If the ModelChain's PVSystem has multiple arrays, `data` must be a\n            list or tuple with the same length and order as the PVsystem's\n            Arrays. Each element of `data` provides the irradiance and weather\n            for the corresponding array.\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ValueError\n            If the number of DataFrames in `data` is different than the number\n            of Arrays in the PVSystem.\n        ValueError\n            If the DataFrames in `data` have different indexes.\n\n        Notes\n        -----\n        Assigns attributes to results: ``times``, ``weather``,\n        ``solar_position``, ``airmass``, ``total_irrad``, ``aoi``,\n        ``aoi_modifier``, ``spectral_modifier``, and\n        ``effective_irradiance``, ``cell_temperature``, ``dc``, ``ac``,\n        ``losses``, ``diode_params`` (if dc_model is a single diode\n        model).\n\n        See also\n        --------\n        pvlib.modelchain.ModelChain.run_model\n        pvlib.modelchain.ModelChain.run_model_from_effective_irradiance\n        \"\"\"\n        data = _to_tuple(data)\n        self.prepare_inputs_from_poa(data)\n\n        self.aoi_model()\n        self.spectral_model()\n        self.effective_irradiance_model()\n\n        self._run_from_effective_irrad(data)\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "run_model_from_poa", "self", "data", "run", "the", "model", "starting", "with", "broadband", "irradiance", "in", "the", "plane", "of", "array", "data", "must", "include", "direct", "diffuse", "and", "total", "irradiance", "w", "m2", "in", "the", "plane", "of", "array", "reflections", "and", "spectral", "adjustments", "are", "made", "to", "calculate", "effective", "irradiance", "w", "m2", "parameters", "data", "dataframe", "or", "tuple", "or", "list", "of", "dataframe", "required", "column", "names", "include", "poa_global", "poa_direct", "and", "poa_diffuse", "if", "optional", "columns", "temp_air", "and", "wind_speed", "are", "not", "provided", "air", "temperature", "of", "20", "c", "and", "wind", "speed", "of", "0", "m", "s", "are", "assumed", "if", "optional", "column", "cell_temperature", "is", "provided", "these", "values", "are", "used", "instead", "of", "temperature_model", "if", "optional", "column", "module_temperature", "is", "provided", "temperature_model", "must", "be", "sapm", "if", "the", "modelchain", "s", "pvsystem", "has", "multiple", "arrays", "data", "must", "be", "a", "list", "or", "tuple", "with", "the", "same", "length", "and", "order", "as", "the", "pvsystem", "s", "arrays", "each", "element", "of", "data", "provides", "the", "irradiance", "and", "weather", "for", "the", "corresponding", "array", "returns", "self", "raises", "valueerror", "if", "the", "number", "of", "dataframes", "in", "data", "is", "different", "than", "the", "number", "of", "arrays", "in", "the", "pvsystem", "valueerror", "if", "the", "dataframes", "in", "data", "have", "different", "indexes", "notes", "assigns", "attributes", "to", "results", "times", "weather", "solar_position", "airmass", "total_irrad", "aoi", "aoi_modifier", "spectral_modifier", "and", "effective_irradiance", "cell_temperature", "dc", "ac", "losses", "diode_params", "if", "dc_model", "is", "a", "single", "diode", "model", "see", "also", "pvlib", "modelchain", "modelchain", "run_model", "pvlib", "modelchain", "modelchain", "run_model_from_effective_irradiance", "data", "_to_tuple", "data", "self", "prepare_inputs_from_poa", "data", "self", "aoi_model", "self", "spectral_model", "self", "effective_irradiance_model", "self", "_run_from_effective_irrad", "data", "return", "self"], "doc_len": 233}
{"doc_id": "pvlib/modelchain.py::ModelChain._run_from_effective_irrad", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "_run_from_effective_irrad", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def _run_from_effective_irrad(self, data=None):\n        \"\"\"\n        Executes the temperature, DC, losses and AC models.\n\n        Parameters\n        ----------\n        data : DataFrame, or tuple of DataFrame, default None\n            If optional column ``'cell_temperature'`` is provided, these values\n            are used instead of `temperature_model`. If optional column\n            `module_temperature` is provided, `temperature_model` must be\n            ``'sapm'``.\n\n        Returns\n        -------\n        self\n\n        Notes\n        -----\n        Assigns attributes:``cell_temperature``, ``dc``, ``ac``, ``losses``,\n        ``diode_params`` (if dc_model is a single diode model).\n        \"\"\"\n        self._prepare_temperature(data)\n        self.dc_model()\n        self.dc_ohmic_model()\n        self.losses_model()\n        self.ac_model()\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "_run_from_effective_irrad", "self", "data", "none", "executes", "the", "temperature", "dc", "losses", "and", "ac", "models", "parameters", "data", "dataframe", "or", "tuple", "of", "dataframe", "default", "none", "if", "optional", "column", "cell_temperature", "is", "provided", "these", "values", "are", "used", "instead", "of", "temperature_model", "if", "optional", "column", "module_temperature", "is", "provided", "temperature_model", "must", "be", "sapm", "returns", "self", "notes", "assigns", "attributes", "cell_temperature", "dc", "ac", "losses", "diode_params", "if", "dc_model", "is", "a", "single", "diode", "model", "self", "_prepare_temperature", "data", "self", "dc_model", "self", "dc_ohmic_model", "self", "losses_model", "self", "ac_model", "return", "self"], "doc_len": 79}
{"doc_id": "pvlib/modelchain.py::ModelChain.run_model_from_effective_irradiance", "file_path": "pvlib/modelchain.py", "class_name": "ModelChain", "func_name": "run_model_from_effective_irradiance", "text": "文件路径: pvlib/modelchain.py, 类名: ModelChain\n    def run_model_from_effective_irradiance(self, data=None):\n        \"\"\"\n        Run the model starting with effective irradiance in the plane of array.\n\n        Effective irradiance is irradiance in the plane-of-array after any\n        adjustments for soiling, reflections and spectrum.\n\n        Parameters\n        ----------\n        data : DataFrame, or list or tuple of DataFrame\n            Required column is ``'effective_irradiance'``.\n            Optional columns include ``'cell_temperature'``,\n            ``'module_temperature'`` and ``'poa_global'``.\n\n            If the ModelChain's PVSystem has multiple arrays, `data` must be a\n            list or tuple with the same length and order as the PVsystem's\n            Arrays. Each element of `data` provides the irradiance and weather\n            for the corresponding array.\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ValueError\n            If the number of DataFrames in `data` is different than the number\n            of Arrays in the PVSystem.\n        ValueError\n            If the DataFrames in `data` have different indexes.\n\n        Notes\n        -----\n        Optional ``data`` columns ``'cell_temperature'``,\n        ``'module_temperature'`` and ``'poa_global'`` are used for determining\n        cell temperature.\n\n        * If optional column ``'cell_temperature'`` is present, these values\n          are used and `temperature_model` is ignored.\n        * If optional column ``'module_temperature'`` is preset,\n          `temperature_model` must be ``'sapm'``.\n        * Otherwise, cell temperature is calculated using `temperature_model`.\n\n        The cell temperature models require plane-of-array irradiance as input.\n        If optional column ``'poa_global'`` is present, these data are used.\n        If ``'poa_global'`` is not present, ``'effective_irradiance'`` is used.\n\n        Assigns attributes to results: ``times``, ``weather``, ``total_irrad``,\n        ``effective_irradiance``, ``cell_temperature``, ``dc``, ``ac``,\n        ``losses``, ``diode_params`` (if dc_model is a single diode model).\n\n        See also\n        --------\n        pvlib.modelchain.ModelChain.run_model\n        pvlib.modelchain.ModelChain.run_model_from_poa\n        \"\"\"\n        data = _to_tuple(data)\n        self._check_multiple_input(data)\n        self._verify_df(data, required=['effective_irradiance'])\n        self._assign_weather(data)\n        self._assign_total_irrad(data)\n        self.results.effective_irradiance = _tuple_from_dfs(\n            data, 'effective_irradiance')\n        self._run_from_effective_irrad(data)\n\n        return self\n", "tokens": ["pvlib", "modelchain", "py", "modelchain", "def", "run_model_from_effective_irradiance", "self", "data", "none", "run", "the", "model", "starting", "with", "effective", "irradiance", "in", "the", "plane", "of", "array", "effective", "irradiance", "is", "irradiance", "in", "the", "plane", "of", "array", "after", "any", "adjustments", "for", "soiling", "reflections", "and", "spectrum", "parameters", "data", "dataframe", "or", "list", "or", "tuple", "of", "dataframe", "required", "column", "is", "effective_irradiance", "optional", "columns", "include", "cell_temperature", "module_temperature", "and", "poa_global", "if", "the", "modelchain", "s", "pvsystem", "has", "multiple", "arrays", "data", "must", "be", "a", "list", "or", "tuple", "with", "the", "same", "length", "and", "order", "as", "the", "pvsystem", "s", "arrays", "each", "element", "of", "data", "provides", "the", "irradiance", "and", "weather", "for", "the", "corresponding", "array", "returns", "self", "raises", "valueerror", "if", "the", "number", "of", "dataframes", "in", "data", "is", "different", "than", "the", "number", "of", "arrays", "in", "the", "pvsystem", "valueerror", "if", "the", "dataframes", "in", "data", "have", "different", "indexes", "notes", "optional", "data", "columns", "cell_temperature", "module_temperature", "and", "poa_global", "are", "used", "for", "determining", "cell", "temperature", "if", "optional", "column", "cell_temperature", "is", "present", "these", "values", "are", "used", "and", "temperature_model", "is", "ignored", "if", "optional", "column", "module_temperature", "is", "preset", "temperature_model", "must", "be", "sapm", "otherwise", "cell", "temperature", "is", "calculated", "using", "temperature_model", "the", "cell", "temperature", "models", "require", "plane", "of", "array", "irradiance", "as", "input", "if", "optional", "column", "poa_global", "is", "present", "these", "data", "are", "used", "if", "poa_global", "is", "not", "present", "effective_irradiance", "is", "used", "assigns", "attributes", "to", "results", "times", "weather", "total_irrad", "effective_irradiance", "cell_temperature", "dc", "ac", "losses", "diode_params", "if", "dc_model", "is", "a", "single", "diode", "model", "see", "also", "pvlib", "modelchain", "modelchain", "run_model", "pvlib", "modelchain", "modelchain", "run_model_from_poa", "data", "_to_tuple", "data", "self", "_check_multiple_input", "data", "self", "_verify_df", "data", "required", "effective_irradiance", "self", "_assign_weather", "data", "self", "_assign_total_irrad", "data", "self", "results", "effective_irradiance", "_tuple_from_dfs", "data", "effective_irradiance", "self", "_run_from_effective_irrad", "data", "return", "self"], "doc_len": 259}
{"doc_id": "pvlib/modelchain.py::_irrad_for_celltemp", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_irrad_for_celltemp", "text": "文件路径: pvlib/modelchain.py\ndef _irrad_for_celltemp(total_irrad, effective_irradiance):\n    \"\"\"\n    Determine irradiance to use for cell temperature models, in order\n    of preference 'poa_global' then 'effective_irradiance'\n\n    Returns\n    -------\n    Series or tuple of Series\n        tuple if total_irrad is a tuple of DataFrame\n\n    \"\"\"\n    if isinstance(total_irrad, tuple):\n        if all(['poa_global' in df for df in total_irrad]):\n            return _tuple_from_dfs(total_irrad, 'poa_global')\n        else:\n            return effective_irradiance\n    else:\n        if 'poa_global' in total_irrad:\n            return total_irrad['poa_global']\n        else:\n            return effective_irradiance\n", "tokens": ["pvlib", "modelchain", "py", "def", "_irrad_for_celltemp", "total_irrad", "effective_irradiance", "determine", "irradiance", "to", "use", "for", "cell", "temperature", "models", "in", "order", "of", "preference", "poa_global", "then", "effective_irradiance", "returns", "series", "or", "tuple", "of", "series", "tuple", "if", "total_irrad", "is", "a", "tuple", "of", "dataframe", "if", "isinstance", "total_irrad", "tuple", "if", "all", "poa_global", "in", "df", "for", "df", "in", "total_irrad", "return", "_tuple_from_dfs", "total_irrad", "poa_global", "else", "return", "effective_irradiance", "else", "if", "poa_global", "in", "total_irrad", "return", "total_irrad", "poa_global", "else", "return", "effective_irradiance"], "doc_len": 67}
{"doc_id": "pvlib/modelchain.py::_snl_params", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_snl_params", "text": "文件路径: pvlib/modelchain.py\ndef _snl_params(inverter_params):\n    \"\"\"Return True if `inverter_params` includes parameters for the\n    Sandia inverter model.\"\"\"\n    return {'C0', 'C1', 'C2'} <= inverter_params\n", "tokens": ["pvlib", "modelchain", "py", "def", "_snl_params", "inverter_params", "return", "true", "if", "inverter_params", "includes", "parameters", "for", "the", "sandia", "inverter", "model", "return", "c0", "c1", "c2", "inverter_params"], "doc_len": 22}
{"doc_id": "pvlib/modelchain.py::_adr_params", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_adr_params", "text": "文件路径: pvlib/modelchain.py\ndef _adr_params(inverter_params):\n    \"\"\"Return True if `inverter_params` includes parameters for the ADR\n    inverter model.\"\"\"\n    return {'ADRCoefficients'} <= inverter_params\n", "tokens": ["pvlib", "modelchain", "py", "def", "_adr_params", "inverter_params", "return", "true", "if", "inverter_params", "includes", "parameters", "for", "the", "adr", "inverter", "model", "return", "adrcoefficients", "inverter_params"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::_pvwatts_params", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_pvwatts_params", "text": "文件路径: pvlib/modelchain.py\ndef _pvwatts_params(inverter_params):\n    \"\"\"Return True if `inverter_params` includes parameters for the\n    PVWatts inverter model.\"\"\"\n    return {'pdc0'} <= inverter_params\n", "tokens": ["pvlib", "modelchain", "py", "def", "_pvwatts_params", "inverter_params", "return", "true", "if", "inverter_params", "includes", "parameters", "for", "the", "pvwatts", "inverter", "model", "return", "pdc0", "inverter_params"], "doc_len": 20}
{"doc_id": "pvlib/modelchain.py::_copy", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_copy", "text": "文件路径: pvlib/modelchain.py\ndef _copy(data):\n    \"\"\"Return a copy of each DataFrame in `data` if it is a tuple,\n    otherwise return a copy of `data`.\"\"\"\n    if not isinstance(data, tuple):\n        return data.copy()\n    return tuple(df.copy() for df in data)\n", "tokens": ["pvlib", "modelchain", "py", "def", "_copy", "data", "return", "a", "copy", "of", "each", "dataframe", "in", "data", "if", "it", "is", "a", "tuple", "otherwise", "return", "a", "copy", "of", "data", "if", "not", "isinstance", "data", "tuple", "return", "data", "copy", "return", "tuple", "df", "copy", "for", "df", "in", "data"], "doc_len": 41}
{"doc_id": "pvlib/modelchain.py::_all_same_index", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_all_same_index", "text": "文件路径: pvlib/modelchain.py\ndef _all_same_index(data):\n    \"\"\"Raise a ValueError if all DataFrames in `data` do not have the\n    same index.\"\"\"\n    indexes = map(lambda df: df.index, data)\n    next(indexes, None)\n    for index in indexes:\n        if not index.equals(data[0].index):\n            raise ValueError(\"Input DataFrames must have same index.\")\n", "tokens": ["pvlib", "modelchain", "py", "def", "_all_same_index", "data", "raise", "a", "valueerror", "if", "all", "dataframes", "in", "data", "do", "not", "have", "the", "same", "index", "indexes", "map", "lambda", "df", "df", "index", "data", "next", "indexes", "none", "for", "index", "in", "indexes", "if", "not", "index", "equals", "data", "0", "index", "raise", "valueerror", "input", "dataframes", "must", "have", "same", "index"], "doc_len": 49}
{"doc_id": "pvlib/modelchain.py::_common_keys", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_common_keys", "text": "文件路径: pvlib/modelchain.py\ndef _common_keys(dicts):\n    \"\"\"Return the intersection of the set of keys for each dictionary\n    in `dicts`\"\"\"\n    def _keys(x):\n        return set(x.keys())\n    if isinstance(dicts, tuple):\n        return set.intersection(*map(_keys, dicts))\n    return _keys(dicts)\n", "tokens": ["pvlib", "modelchain", "py", "def", "_common_keys", "dicts", "return", "the", "intersection", "of", "the", "set", "of", "keys", "for", "each", "dictionary", "in", "dicts", "def", "_keys", "x", "return", "set", "x", "keys", "if", "isinstance", "dicts", "tuple", "return", "set", "intersection", "map", "_keys", "dicts", "return", "_keys", "dicts"], "doc_len": 39}
{"doc_id": "pvlib/modelchain.py::_tuple_from_dfs", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_tuple_from_dfs", "text": "文件路径: pvlib/modelchain.py\ndef _tuple_from_dfs(dfs, name):\n    \"\"\"Extract a column from each DataFrame in `dfs` if `dfs` is a tuple.\n\n    Returns a tuple of Series if `dfs` is a tuple or a Series if `dfs` is\n    a DataFrame.\n    \"\"\"\n    if isinstance(dfs, tuple):\n        return tuple(df[name] for df in dfs)\n    else:\n        return dfs[name]\n", "tokens": ["pvlib", "modelchain", "py", "def", "_tuple_from_dfs", "dfs", "name", "extract", "a", "column", "from", "each", "dataframe", "in", "dfs", "if", "dfs", "is", "a", "tuple", "returns", "a", "tuple", "of", "series", "if", "dfs", "is", "a", "tuple", "or", "a", "series", "if", "dfs", "is", "a", "dataframe", "if", "isinstance", "dfs", "tuple", "return", "tuple", "df", "name", "for", "df", "in", "dfs", "else", "return", "dfs", "name"], "doc_len": 54}
{"doc_id": "pvlib/modelchain.py::_to_tuple", "file_path": "pvlib/modelchain.py", "class_name": null, "func_name": "_to_tuple", "text": "文件路径: pvlib/modelchain.py\ndef _to_tuple(x):\n    if not isinstance(x, (tuple, list)):\n        return x\n    return tuple(x)\n", "tokens": ["pvlib", "modelchain", "py", "def", "_to_tuple", "x", "if", "not", "isinstance", "x", "tuple", "list", "return", "x", "return", "tuple", "x"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::_unwrap_single_value", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "_unwrap_single_value", "text": "文件路径: pvlib/pvsystem.py\ndef _unwrap_single_value(func):\n    \"\"\"Decorator for functions that return iterables.\n\n    If the length of the iterable returned by `func` is 1, then\n    the single member of the iterable is returned. If the length is\n    greater than 1, then entire iterable is returned.\n\n    Adds 'unwrap' as a keyword argument that can be set to False\n    to force the return value to be a tuple, regardless of its length.\n    \"\"\"\n    @functools.wraps(func)\n    def f(*args, **kwargs):\n        unwrap = kwargs.pop('unwrap', True)\n        x = func(*args, **kwargs)\n        if unwrap and len(x) == 1:\n            return x[0]\n        return x\n    return f\n", "tokens": ["pvlib", "pvsystem", "py", "def", "_unwrap_single_value", "func", "decorator", "for", "functions", "that", "return", "iterables", "if", "the", "length", "of", "the", "iterable", "returned", "by", "func", "is", "1", "then", "the", "single", "member", "of", "the", "iterable", "is", "returned", "if", "the", "length", "is", "greater", "than", "1", "then", "entire", "iterable", "is", "returned", "adds", "unwrap", "as", "a", "keyword", "argument", "that", "can", "be", "set", "to", "false", "to", "force", "the", "return", "value", "to", "be", "a", "tuple", "regardless", "of", "its", "length", "functools", "wraps", "func", "def", "f", "args", "kwargs", "unwrap", "kwargs", "pop", "unwrap", "true", "x", "func", "args", "kwargs", "if", "unwrap", "and", "len", "x", "1", "return", "x", "0", "return", "x", "return", "f"], "doc_len": 98}
{"doc_id": "pvlib/pvsystem.py::_check_deprecated_passthrough", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "_check_deprecated_passthrough", "text": "文件路径: pvlib/pvsystem.py\ndef _check_deprecated_passthrough(func):\n    \"\"\"\n    Decorator to warn or error when getting and setting the \"pass-through\"\n    PVSystem properties that have been moved to Array.  Emits a warning for\n    PVSystems with only one Array and raises an error for PVSystems with\n    more than one Array.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        pvsystem_attr = func.__name__\n        class_name = self.__class__.__name__  # PVSystem or SingleAxisTracker\n        overrides = {  # some Array attrs aren't the same as PVSystem\n            'strings_per_inverter': 'strings',\n        }\n        array_attr = overrides.get(pvsystem_attr, pvsystem_attr)\n        alternative = f'{class_name}.arrays[i].{array_attr}'\n\n        if len(self.arrays) > 1:\n            raise AttributeError(\n                f'{class_name}.{pvsystem_attr} not supported for multi-array '\n                f'systems. Set {array_attr} for each Array in '\n                f'{class_name}.arrays instead.')\n\n        wrapped = deprecated('0.9', alternative=alternative, removal='0.10',\n                             name=f\"{class_name}.{pvsystem_attr}\")(func)\n        return wrapped(self, *args, **kwargs)\n\n    return wrapper\n", "tokens": ["pvlib", "pvsystem", "py", "def", "_check_deprecated_passthrough", "func", "decorator", "to", "warn", "or", "error", "when", "getting", "and", "setting", "the", "pass", "through", "pvsystem", "properties", "that", "have", "been", "moved", "to", "array", "emits", "a", "warning", "for", "pvsystems", "with", "only", "one", "array", "and", "raises", "an", "error", "for", "pvsystems", "with", "more", "than", "one", "array", "functools", "wraps", "func", "def", "wrapper", "self", "args", "kwargs", "pvsystem_attr", "func", "__name__", "class_name", "self", "__class__", "__name__", "pvsystem", "or", "singleaxistracker", "overrides", "some", "array", "attrs", "aren", "t", "the", "same", "as", "pvsystem", "strings_per_inverter", "strings", "array_attr", "overrides", "get", "pvsystem_attr", "pvsystem_attr", "alternative", "f", "class_name", "arrays", "i", "array_attr", "if", "len", "self", "arrays", "1", "raise", "attributeerror", "f", "class_name", "pvsystem_attr", "not", "supported", "for", "multi", "array", "f", "systems", "set", "array_attr", "for", "each", "array", "in", "f", "class_name", "arrays", "instead", "wrapped", "deprecated", "0", "9", "alternative", "alternative", "removal", "0", "10", "name", "f", "class_name", "pvsystem_attr", "func", "return", "wrapped", "self", "args", "kwargs", "return", "wrapper"], "doc_len": 135}
{"doc_id": "pvlib/pvsystem.py::PVSystem.__init__", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "__init__", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def __init__(self,\n                 arrays=None,\n                 surface_tilt=0, surface_azimuth=180,\n                 albedo=None, surface_type=None,\n                 module=None, module_type=None,\n                 module_parameters=None,\n                 temperature_model_parameters=None,\n                 modules_per_string=1, strings_per_inverter=1,\n                 inverter=None, inverter_parameters=None,\n                 racking_model=None, losses_parameters=None, name=None):\n\n        if arrays is None:\n            if losses_parameters is None:\n                array_losses_parameters = {}\n            else:\n                array_losses_parameters = _build_kwargs(['dc_ohmic_percent'],\n                                                        losses_parameters)\n            self.arrays = (Array(\n                FixedMount(surface_tilt, surface_azimuth, racking_model),\n                albedo,\n                surface_type,\n                module,\n                module_type,\n                module_parameters,\n                temperature_model_parameters,\n                modules_per_string,\n                strings_per_inverter,\n                array_losses_parameters,\n            ),)\n        elif len(arrays) == 0:\n            raise ValueError(\"PVSystem must have at least one Array. \"\n                             \"If you want to create a PVSystem instance \"\n                             \"with a single Array pass `arrays=None` and pass \"\n                             \"values directly to PVSystem attributes, e.g., \"\n                             \"`surface_tilt=30`\")\n        else:\n            self.arrays = tuple(arrays)\n\n        self.inverter = inverter\n        if inverter_parameters is None:\n            self.inverter_parameters = {}\n        else:\n            self.inverter_parameters = inverter_parameters\n\n        if losses_parameters is None:\n            self.losses_parameters = {}\n        else:\n            self.losses_parameters = losses_parameters\n\n        self.name = name\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "__init__", "self", "arrays", "none", "surface_tilt", "0", "surface_azimuth", "180", "albedo", "none", "surface_type", "none", "module", "none", "module_type", "none", "module_parameters", "none", "temperature_model_parameters", "none", "modules_per_string", "1", "strings_per_inverter", "1", "inverter", "none", "inverter_parameters", "none", "racking_model", "none", "losses_parameters", "none", "name", "none", "if", "arrays", "is", "none", "if", "losses_parameters", "is", "none", "array_losses_parameters", "else", "array_losses_parameters", "_build_kwargs", "dc_ohmic_percent", "losses_parameters", "self", "arrays", "array", "fixedmount", "surface_tilt", "surface_azimuth", "racking_model", "albedo", "surface_type", "module", "module_type", "module_parameters", "temperature_model_parameters", "modules_per_string", "strings_per_inverter", "array_losses_parameters", "elif", "len", "arrays", "0", "raise", "valueerror", "pvsystem", "must", "have", "at", "least", "one", "array", "if", "you", "want", "to", "create", "a", "pvsystem", "instance", "with", "a", "single", "array", "pass", "arrays", "none", "and", "pass", "values", "directly", "to", "pvsystem", "attributes", "e", "g", "surface_tilt", "30", "else", "self", "arrays", "tuple", "arrays", "self", "inverter", "inverter", "if", "inverter_parameters", "is", "none", "self", "inverter_parameters", "else", "self", "inverter_parameters", "inverter_parameters", "if", "losses_parameters", "is", "none", "self", "losses_parameters", "else", "self", "losses_parameters", "losses_parameters", "self", "name", "name"], "doc_len": 139}
{"doc_id": "pvlib/pvsystem.py::PVSystem.__repr__", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "__repr__", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def __repr__(self):\n        repr = f'PVSystem:\\n  name: {self.name}\\n  '\n        for array in self.arrays:\n            repr += '\\n  '.join(array.__repr__().split('\\n'))\n            repr += '\\n  '\n        repr += f'inverter: {self.inverter}'\n        return repr\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "__repr__", "self", "repr", "f", "pvsystem", "n", "name", "self", "name", "n", "for", "array", "in", "self", "arrays", "repr", "n", "join", "array", "__repr__", "split", "n", "repr", "n", "repr", "f", "inverter", "self", "inverter", "return", "repr"], "doc_len": 36}
{"doc_id": "pvlib/pvsystem.py::PVSystem._validate_per_array", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "_validate_per_array", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def _validate_per_array(self, values, system_wide=False):\n        \"\"\"Check that `values` is a tuple of the same length as\n        `self.arrays`.\n\n        If `values` is not a tuple it is packed in to a length-1 tuple before\n        the check. If the lengths are not the same a ValueError is raised,\n        otherwise the tuple `values` is returned.\n\n        When `system_wide` is True and `values` is not a tuple, `values`\n        is replicated to a tuple of the same length as `self.arrays` and that\n        tuple is returned.\n        \"\"\"\n        if system_wide and not isinstance(values, tuple):\n            return (values,) * self.num_arrays\n        if not isinstance(values, tuple):\n            values = (values,)\n        if len(values) != len(self.arrays):\n            raise ValueError(\"Length mismatch for per-array parameter\")\n        return values\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "_validate_per_array", "self", "values", "system_wide", "false", "check", "that", "values", "is", "a", "tuple", "of", "the", "same", "length", "as", "self", "arrays", "if", "values", "is", "not", "a", "tuple", "it", "is", "packed", "in", "to", "a", "length", "1", "tuple", "before", "the", "check", "if", "the", "lengths", "are", "not", "the", "same", "a", "valueerror", "is", "raised", "otherwise", "the", "tuple", "values", "is", "returned", "when", "system_wide", "is", "true", "and", "values", "is", "not", "a", "tuple", "values", "is", "replicated", "to", "a", "tuple", "of", "the", "same", "length", "as", "self", "arrays", "and", "that", "tuple", "is", "returned", "if", "system_wide", "and", "not", "isinstance", "values", "tuple", "return", "values", "self", "num_arrays", "if", "not", "isinstance", "values", "tuple", "values", "values", "if", "len", "values", "len", "self", "arrays", "raise", "valueerror", "length", "mismatch", "for", "per", "array", "parameter", "return", "values"], "doc_len": 120}
{"doc_id": "pvlib/pvsystem.py::PVSystem._infer_cell_type", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "_infer_cell_type", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def _infer_cell_type(self):\n        \"\"\"\n        Examines module_parameters and maps the Technology key for the CEC\n        database and the Material key for the Sandia database to a common\n        list of strings for cell type.\n\n        Returns\n        -------\n        cell_type: str\n        \"\"\"\n        return tuple(array._infer_cell_type() for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "_infer_cell_type", "self", "examines", "module_parameters", "and", "maps", "the", "technology", "key", "for", "the", "cec", "database", "and", "the", "material", "key", "for", "the", "sandia", "database", "to", "a", "common", "list", "of", "strings", "for", "cell", "type", "returns", "cell_type", "str", "return", "tuple", "array", "_infer_cell_type", "for", "array", "in", "self", "arrays"], "doc_len": 47}
{"doc_id": "pvlib/pvsystem.py::PVSystem.get_aoi", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "get_aoi", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def get_aoi(self, solar_zenith, solar_azimuth):\n        \"\"\"Get the angle of incidence on the Array(s) in the system.\n\n        Parameters\n        ----------\n        solar_zenith : float or Series.\n            Solar zenith angle.\n        solar_azimuth : float or Series.\n            Solar azimuth angle.\n\n        Returns\n        -------\n        aoi : Series or tuple of Series\n            The angle of incidence\n        \"\"\"\n\n        return tuple(array.get_aoi(solar_zenith, solar_azimuth)\n                     for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "get_aoi", "self", "solar_zenith", "solar_azimuth", "get", "the", "angle", "of", "incidence", "on", "the", "array", "s", "in", "the", "system", "parameters", "solar_zenith", "float", "or", "series", "solar", "zenith", "angle", "solar_azimuth", "float", "or", "series", "solar", "azimuth", "angle", "returns", "aoi", "series", "or", "tuple", "of", "series", "the", "angle", "of", "incidence", "return", "tuple", "array", "get_aoi", "solar_zenith", "solar_azimuth", "for", "array", "in", "self", "arrays"], "doc_len": 58}
{"doc_id": "pvlib/pvsystem.py::PVSystem.get_irradiance", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "get_irradiance", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def get_irradiance(self, solar_zenith, solar_azimuth, dni, ghi, dhi,\n                       dni_extra=None, airmass=None, albedo=None,\n                       model='haydavies', **kwargs):\n        \"\"\"\n        Uses the :py:func:`irradiance.get_total_irradiance` function to\n        calculate the plane of array irradiance components on the tilted\n        surfaces defined by each array's ``surface_tilt`` and\n        ``surface_azimuth``.\n\n        Parameters\n        ----------\n        solar_zenith : float or Series\n            Solar zenith angle.\n        solar_azimuth : float or Series\n            Solar azimuth angle.\n        dni : float or Series or tuple of float or Series\n            Direct Normal Irradiance. [W/m2]\n        ghi : float or Series or tuple of float or Series\n            Global horizontal irradiance. [W/m2]\n        dhi : float or Series or tuple of float or Series\n            Diffuse horizontal irradiance. [W/m2]\n        dni_extra : None, float, Series or tuple of float or Series,\\\n            default None\n            Extraterrestrial direct normal irradiance. [W/m2]\n        airmass : None, float or Series, default None\n            Airmass. [unitless]\n        albedo : None, float or Series, default None\n            Ground surface albedo. [unitless]\n        model : String, default 'haydavies'\n            Irradiance model.\n\n        kwargs\n            Extra parameters passed to :func:`irradiance.get_total_irradiance`.\n\n        Notes\n        -----\n        Each of `dni`, `ghi`, and `dni` parameters may be passed as a tuple\n        to provide different irradiance for each array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n\n        Returns\n        -------\n        poa_irradiance : DataFrame or tuple of DataFrame\n            Column names are: ``'poa_global', 'poa_direct', 'poa_diffuse',\n            'poa_sky_diffuse', 'poa_ground_diffuse'``.\n\n        See also\n        --------\n        pvlib.irradiance.get_total_irradiance\n        \"\"\"\n        dni = self._validate_per_array(dni, system_wide=True)\n        ghi = self._validate_per_array(ghi, system_wide=True)\n        dhi = self._validate_per_array(dhi, system_wide=True)\n\n        albedo = self._validate_per_array(albedo, system_wide=True)\n\n        return tuple(\n            array.get_irradiance(solar_zenith, solar_azimuth,\n                                 dni, ghi, dhi,\n                                 dni_extra=dni_extra, airmass=airmass,\n                                 albedo=albedo, model=model, **kwargs)\n            for array, dni, ghi, dhi, albedo in zip(\n                self.arrays, dni, ghi, dhi, albedo\n            )\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "get_irradiance", "self", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "none", "airmass", "none", "albedo", "none", "model", "haydavies", "kwargs", "uses", "the", "py", "func", "irradiance", "get_total_irradiance", "function", "to", "calculate", "the", "plane", "of", "array", "irradiance", "components", "on", "the", "tilted", "surfaces", "defined", "by", "each", "array", "s", "surface_tilt", "and", "surface_azimuth", "parameters", "solar_zenith", "float", "or", "series", "solar", "zenith", "angle", "solar_azimuth", "float", "or", "series", "solar", "azimuth", "angle", "dni", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "direct", "normal", "irradiance", "w", "m2", "ghi", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "global", "horizontal", "irradiance", "w", "m2", "dhi", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "diffuse", "horizontal", "irradiance", "w", "m2", "dni_extra", "none", "float", "series", "or", "tuple", "of", "float", "or", "series", "default", "none", "extraterrestrial", "direct", "normal", "irradiance", "w", "m2", "airmass", "none", "float", "or", "series", "default", "none", "airmass", "unitless", "albedo", "none", "float", "or", "series", "default", "none", "ground", "surface", "albedo", "unitless", "model", "string", "default", "haydavies", "irradiance", "model", "kwargs", "extra", "parameters", "passed", "to", "func", "irradiance", "get_total_irradiance", "notes", "each", "of", "dni", "ghi", "and", "dni", "parameters", "may", "be", "passed", "as", "a", "tuple", "to", "provide", "different", "irradiance", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "returns", "poa_irradiance", "dataframe", "or", "tuple", "of", "dataframe", "column", "names", "are", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "see", "also", "pvlib", "irradiance", "get_total_irradiance", "dni", "self", "_validate_per_array", "dni", "system_wide", "true", "ghi", "self", "_validate_per_array", "ghi", "system_wide", "true", "dhi", "self", "_validate_per_array", "dhi", "system_wide", "true", "albedo", "self", "_validate_per_array", "albedo", "system_wide", "true", "return", "tuple", "array", "get_irradiance", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "dni_extra", "airmass", "airmass", "albedo", "albedo", "model", "model", "kwargs", "for", "array", "dni", "ghi", "dhi", "albedo", "in", "zip", "self", "arrays", "dni", "ghi", "dhi", "albedo"], "doc_len": 293}
{"doc_id": "pvlib/pvsystem.py::PVSystem.get_iam", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "get_iam", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def get_iam(self, aoi, iam_model='physical'):\n        \"\"\"\n        Determine the incidence angle modifier using the method specified by\n        ``iam_model``.\n\n        Parameters for the selected IAM model are expected to be in\n        ``PVSystem.module_parameters``. Default parameters are available for\n        the 'physical', 'ashrae' and 'martin_ruiz' models.\n\n        Parameters\n        ----------\n        aoi : numeric or tuple of numeric\n            The angle of incidence in degrees.\n\n        aoi_model : string, default 'physical'\n            The IAM model to be used. Valid strings are 'physical', 'ashrae',\n            'martin_ruiz' and 'sapm'.\n        Returns\n        -------\n        iam : numeric or tuple of numeric\n            The AOI modifier.\n\n        Raises\n        ------\n        ValueError\n            if `iam_model` is not a valid model name.\n        \"\"\"\n        aoi = self._validate_per_array(aoi)\n        return tuple(array.get_iam(aoi, iam_model)\n                     for array, aoi in zip(self.arrays, aoi))\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "get_iam", "self", "aoi", "iam_model", "physical", "determine", "the", "incidence", "angle", "modifier", "using", "the", "method", "specified", "by", "iam_model", "parameters", "for", "the", "selected", "iam", "model", "are", "expected", "to", "be", "in", "pvsystem", "module_parameters", "default", "parameters", "are", "available", "for", "the", "physical", "ashrae", "and", "martin_ruiz", "models", "parameters", "aoi", "numeric", "or", "tuple", "of", "numeric", "the", "angle", "of", "incidence", "in", "degrees", "aoi_model", "string", "default", "physical", "the", "iam", "model", "to", "be", "used", "valid", "strings", "are", "physical", "ashrae", "martin_ruiz", "and", "sapm", "returns", "iam", "numeric", "or", "tuple", "of", "numeric", "the", "aoi", "modifier", "raises", "valueerror", "if", "iam_model", "is", "not", "a", "valid", "model", "name", "aoi", "self", "_validate_per_array", "aoi", "return", "tuple", "array", "get_iam", "aoi", "iam_model", "for", "array", "aoi", "in", "zip", "self", "arrays", "aoi"], "doc_len": 114}
{"doc_id": "pvlib/pvsystem.py::PVSystem.get_cell_temperature", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "get_cell_temperature", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def get_cell_temperature(self, poa_global, temp_air, wind_speed, model,\n                             effective_irradiance=None):\n        \"\"\"\n        Determine cell temperature using the method specified by ``model``.\n\n        Parameters\n        ----------\n        poa_global : numeric or tuple of numeric\n            Total incident irradiance in W/m^2.\n\n        temp_air : numeric or tuple of numeric\n            Ambient dry bulb temperature in degrees C.\n\n        wind_speed : numeric or tuple of numeric\n            Wind speed in m/s.\n\n        model : str\n            Supported models include ``'sapm'``, ``'pvsyst'``,\n            ``'faiman'``, ``'fuentes'``, and ``'noct_sam'``\n\n        effective_irradiance : numeric or tuple of numeric, optional\n            The irradiance that is converted to photocurrent in W/m^2.\n            Only used for some models.\n\n        Returns\n        -------\n        numeric or tuple of numeric\n            Values in degrees C.\n\n        See Also\n        --------\n        Array.get_cell_temperature\n\n        Notes\n        -----\n        The `temp_air` and `wind_speed` parameters may be passed as tuples\n        to provide different values for each Array in the system. If passed as\n        a tuple the length must be the same as the number of Arrays. If not\n        passed as a tuple then the same value is used for each Array.\n        \"\"\"\n        poa_global = self._validate_per_array(poa_global)\n        temp_air = self._validate_per_array(temp_air, system_wide=True)\n        wind_speed = self._validate_per_array(wind_speed, system_wide=True)\n        # Not used for all models, but Array.get_cell_temperature handles it\n        effective_irradiance = self._validate_per_array(effective_irradiance,\n                                                        system_wide=True)\n\n        return tuple(\n            array.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                       model, effective_irradiance)\n            for array, poa_global, temp_air, wind_speed, effective_irradiance\n            in zip(\n                self.arrays, poa_global, temp_air, wind_speed,\n                effective_irradiance\n            )\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "get_cell_temperature", "self", "poa_global", "temp_air", "wind_speed", "model", "effective_irradiance", "none", "determine", "cell", "temperature", "using", "the", "method", "specified", "by", "model", "parameters", "poa_global", "numeric", "or", "tuple", "of", "numeric", "total", "incident", "irradiance", "in", "w", "m", "2", "temp_air", "numeric", "or", "tuple", "of", "numeric", "ambient", "dry", "bulb", "temperature", "in", "degrees", "c", "wind_speed", "numeric", "or", "tuple", "of", "numeric", "wind", "speed", "in", "m", "s", "model", "str", "supported", "models", "include", "sapm", "pvsyst", "faiman", "fuentes", "and", "noct_sam", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "optional", "the", "irradiance", "that", "is", "converted", "to", "photocurrent", "in", "w", "m", "2", "only", "used", "for", "some", "models", "returns", "numeric", "or", "tuple", "of", "numeric", "values", "in", "degrees", "c", "see", "also", "array", "get_cell_temperature", "notes", "the", "temp_air", "and", "wind_speed", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "each", "array", "poa_global", "self", "_validate_per_array", "poa_global", "temp_air", "self", "_validate_per_array", "temp_air", "system_wide", "true", "wind_speed", "self", "_validate_per_array", "wind_speed", "system_wide", "true", "not", "used", "for", "all", "models", "but", "array", "get_cell_temperature", "handles", "it", "effective_irradiance", "self", "_validate_per_array", "effective_irradiance", "system_wide", "true", "return", "tuple", "array", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "effective_irradiance", "for", "array", "poa_global", "temp_air", "wind_speed", "effective_irradiance", "in", "zip", "self", "arrays", "poa_global", "temp_air", "wind_speed", "effective_irradiance"], "doc_len": 215}
{"doc_id": "pvlib/pvsystem.py::PVSystem.calcparams_desoto", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "calcparams_desoto", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def calcparams_desoto(self, effective_irradiance, temp_cell):\n        \"\"\"\n        Use the :py:func:`calcparams_desoto` function, the input\n        parameters and ``self.module_parameters`` to calculate the\n        module currents and resistances.\n\n        Parameters\n        ----------\n        effective_irradiance : numeric or tuple of numeric\n            The irradiance (W/m2) that is converted to photocurrent.\n\n        temp_cell : float or Series or tuple of float or Series\n            The average cell temperature of cells within a module in C.\n\n        Returns\n        -------\n        See pvsystem.calcparams_desoto for details\n        \"\"\"\n        effective_irradiance = self._validate_per_array(effective_irradiance)\n        temp_cell = self._validate_per_array(temp_cell)\n\n        build_kwargs = functools.partial(\n            _build_kwargs,\n            ['a_ref', 'I_L_ref', 'I_o_ref', 'R_sh_ref',\n             'R_s', 'alpha_sc', 'EgRef', 'dEgdT',\n             'irrad_ref', 'temp_ref']\n        )\n\n        return tuple(\n            calcparams_desoto(\n                effective_irradiance, temp_cell,\n                **build_kwargs(array.module_parameters)\n            )\n            for array, effective_irradiance, temp_cell\n            in zip(self.arrays, effective_irradiance, temp_cell)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "calcparams_desoto", "self", "effective_irradiance", "temp_cell", "use", "the", "py", "func", "calcparams_desoto", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "the", "module", "currents", "and", "resistances", "parameters", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "returns", "see", "pvsystem", "calcparams_desoto", "for", "details", "effective_irradiance", "self", "_validate_per_array", "effective_irradiance", "temp_cell", "self", "_validate_per_array", "temp_cell", "build_kwargs", "functools", "partial", "_build_kwargs", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "alpha_sc", "egref", "degdt", "irrad_ref", "temp_ref", "return", "tuple", "calcparams_desoto", "effective_irradiance", "temp_cell", "build_kwargs", "array", "module_parameters", "for", "array", "effective_irradiance", "temp_cell", "in", "zip", "self", "arrays", "effective_irradiance", "temp_cell"], "doc_len": 111}
{"doc_id": "pvlib/pvsystem.py::PVSystem.calcparams_cec", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "calcparams_cec", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def calcparams_cec(self, effective_irradiance, temp_cell):\n        \"\"\"\n        Use the :py:func:`calcparams_cec` function, the input\n        parameters and ``self.module_parameters`` to calculate the\n        module currents and resistances.\n\n        Parameters\n        ----------\n        effective_irradiance : numeric or tuple of numeric\n            The irradiance (W/m2) that is converted to photocurrent.\n\n        temp_cell : float or Series or tuple of float or Series\n            The average cell temperature of cells within a module in C.\n\n        Returns\n        -------\n        See pvsystem.calcparams_cec for details\n        \"\"\"\n        effective_irradiance = self._validate_per_array(effective_irradiance)\n        temp_cell = self._validate_per_array(temp_cell)\n\n        build_kwargs = functools.partial(\n            _build_kwargs,\n            ['a_ref', 'I_L_ref', 'I_o_ref', 'R_sh_ref',\n             'R_s', 'alpha_sc', 'Adjust', 'EgRef', 'dEgdT',\n             'irrad_ref', 'temp_ref']\n        )\n\n        return tuple(\n            calcparams_cec(\n                effective_irradiance, temp_cell,\n                **build_kwargs(array.module_parameters)\n            )\n            for array, effective_irradiance, temp_cell\n            in zip(self.arrays, effective_irradiance, temp_cell)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "calcparams_cec", "self", "effective_irradiance", "temp_cell", "use", "the", "py", "func", "calcparams_cec", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "the", "module", "currents", "and", "resistances", "parameters", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "returns", "see", "pvsystem", "calcparams_cec", "for", "details", "effective_irradiance", "self", "_validate_per_array", "effective_irradiance", "temp_cell", "self", "_validate_per_array", "temp_cell", "build_kwargs", "functools", "partial", "_build_kwargs", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "alpha_sc", "adjust", "egref", "degdt", "irrad_ref", "temp_ref", "return", "tuple", "calcparams_cec", "effective_irradiance", "temp_cell", "build_kwargs", "array", "module_parameters", "for", "array", "effective_irradiance", "temp_cell", "in", "zip", "self", "arrays", "effective_irradiance", "temp_cell"], "doc_len": 112}
{"doc_id": "pvlib/pvsystem.py::PVSystem.calcparams_pvsyst", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "calcparams_pvsyst", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def calcparams_pvsyst(self, effective_irradiance, temp_cell):\n        \"\"\"\n        Use the :py:func:`calcparams_pvsyst` function, the input\n        parameters and ``self.module_parameters`` to calculate the\n        module currents and resistances.\n\n        Parameters\n        ----------\n        effective_irradiance : numeric or tuple of numeric\n            The irradiance (W/m2) that is converted to photocurrent.\n\n        temp_cell : float or Series or tuple of float or Series\n            The average cell temperature of cells within a module in C.\n\n        Returns\n        -------\n        See pvsystem.calcparams_pvsyst for details\n        \"\"\"\n        effective_irradiance = self._validate_per_array(effective_irradiance)\n        temp_cell = self._validate_per_array(temp_cell)\n\n        build_kwargs = functools.partial(\n            _build_kwargs,\n            ['gamma_ref', 'mu_gamma', 'I_L_ref', 'I_o_ref',\n             'R_sh_ref', 'R_sh_0', 'R_sh_exp',\n             'R_s', 'alpha_sc', 'EgRef',\n             'irrad_ref', 'temp_ref',\n             'cells_in_series']\n        )\n\n        return tuple(\n            calcparams_pvsyst(\n                effective_irradiance, temp_cell,\n                **build_kwargs(array.module_parameters)\n            )\n            for array, effective_irradiance, temp_cell\n            in zip(self.arrays, effective_irradiance, temp_cell)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "calcparams_pvsyst", "self", "effective_irradiance", "temp_cell", "use", "the", "py", "func", "calcparams_pvsyst", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "the", "module", "currents", "and", "resistances", "parameters", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "returns", "see", "pvsystem", "calcparams_pvsyst", "for", "details", "effective_irradiance", "self", "_validate_per_array", "effective_irradiance", "temp_cell", "self", "_validate_per_array", "temp_cell", "build_kwargs", "functools", "partial", "_build_kwargs", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_sh_exp", "r_s", "alpha_sc", "egref", "irrad_ref", "temp_ref", "cells_in_series", "return", "tuple", "calcparams_pvsyst", "effective_irradiance", "temp_cell", "build_kwargs", "array", "module_parameters", "for", "array", "effective_irradiance", "temp_cell", "in", "zip", "self", "arrays", "effective_irradiance", "temp_cell"], "doc_len": 114}
{"doc_id": "pvlib/pvsystem.py::PVSystem.sapm", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "sapm", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def sapm(self, effective_irradiance, temp_cell):\n        \"\"\"\n        Use the :py:func:`sapm` function, the input parameters,\n        and ``self.module_parameters`` to calculate\n        Voc, Isc, Ix, Ixx, Vmp, and Imp.\n\n        Parameters\n        ----------\n        effective_irradiance : numeric or tuple of numeric\n            The irradiance (W/m2) that is converted to photocurrent.\n\n        temp_cell : float or Series or tuple of float or Series\n            The average cell temperature of cells within a module in C.\n\n        Returns\n        -------\n        See pvsystem.sapm for details\n        \"\"\"\n        effective_irradiance = self._validate_per_array(effective_irradiance)\n        temp_cell = self._validate_per_array(temp_cell)\n\n        return tuple(\n            sapm(effective_irradiance, temp_cell, array.module_parameters)\n            for array, effective_irradiance, temp_cell\n            in zip(self.arrays, effective_irradiance, temp_cell)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "sapm", "self", "effective_irradiance", "temp_cell", "use", "the", "py", "func", "sapm", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "voc", "isc", "ix", "ixx", "vmp", "and", "imp", "parameters", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "float", "or", "series", "or", "tuple", "of", "float", "or", "series", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "returns", "see", "pvsystem", "sapm", "for", "details", "effective_irradiance", "self", "_validate_per_array", "effective_irradiance", "temp_cell", "self", "_validate_per_array", "temp_cell", "return", "tuple", "sapm", "effective_irradiance", "temp_cell", "array", "module_parameters", "for", "array", "effective_irradiance", "temp_cell", "in", "zip", "self", "arrays", "effective_irradiance", "temp_cell"], "doc_len": 98}
{"doc_id": "pvlib/pvsystem.py::PVSystem.sapm_celltemp", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "sapm_celltemp", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def sapm_celltemp(self, poa_global, temp_air, wind_speed):\n        \"\"\"Uses :py:func:`pvlib.temperature.sapm_cell` to calculate cell\n        temperatures.\n\n        Parameters\n        ----------\n        poa_global : numeric or tuple of numeric\n            Total incident irradiance in W/m^2.\n\n        temp_air : numeric or tuple of numeric\n            Ambient dry bulb temperature in degrees C.\n\n        wind_speed : numeric or tuple of numeric\n            Wind speed in m/s at a height of 10 meters.\n\n        Returns\n        -------\n        numeric or tuple of numeric\n            values in degrees C.\n\n        Notes\n        -----\n        The `temp_air` and `wind_speed` parameters may be passed as tuples\n        to provide different values for each Array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n        \"\"\"\n        return self.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                         model='sapm')\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "sapm_celltemp", "self", "poa_global", "temp_air", "wind_speed", "uses", "py", "func", "pvlib", "temperature", "sapm_cell", "to", "calculate", "cell", "temperatures", "parameters", "poa_global", "numeric", "or", "tuple", "of", "numeric", "total", "incident", "irradiance", "in", "w", "m", "2", "temp_air", "numeric", "or", "tuple", "of", "numeric", "ambient", "dry", "bulb", "temperature", "in", "degrees", "c", "wind_speed", "numeric", "or", "tuple", "of", "numeric", "wind", "speed", "in", "m", "s", "at", "a", "height", "of", "10", "meters", "returns", "numeric", "or", "tuple", "of", "numeric", "values", "in", "degrees", "c", "notes", "the", "temp_air", "and", "wind_speed", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "return", "self", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "sapm"], "doc_len": 136}
{"doc_id": "pvlib/pvsystem.py::PVSystem.sapm_spectral_loss", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "sapm_spectral_loss", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def sapm_spectral_loss(self, airmass_absolute):\n        \"\"\"\n        Use the :py:func:`sapm_spectral_loss` function, the input\n        parameters, and ``self.module_parameters`` to calculate F1.\n\n        Parameters\n        ----------\n        airmass_absolute : numeric\n            Absolute airmass.\n\n        Returns\n        -------\n        F1 : numeric or tuple of numeric\n            The SAPM spectral loss coefficient.\n        \"\"\"\n        return tuple(\n            sapm_spectral_loss(airmass_absolute, array.module_parameters)\n            for array in self.arrays\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "sapm_spectral_loss", "self", "airmass_absolute", "use", "the", "py", "func", "sapm_spectral_loss", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "f1", "parameters", "airmass_absolute", "numeric", "absolute", "airmass", "returns", "f1", "numeric", "or", "tuple", "of", "numeric", "the", "sapm", "spectral", "loss", "coefficient", "return", "tuple", "sapm_spectral_loss", "airmass_absolute", "array", "module_parameters", "for", "array", "in", "self", "arrays"], "doc_len": 51}
{"doc_id": "pvlib/pvsystem.py::PVSystem.sapm_effective_irradiance", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "sapm_effective_irradiance", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def sapm_effective_irradiance(self, poa_direct, poa_diffuse,\n                                  airmass_absolute, aoi,\n                                  reference_irradiance=1000):\n        \"\"\"\n        Use the :py:func:`sapm_effective_irradiance` function, the input\n        parameters, and ``self.module_parameters`` to calculate\n        effective irradiance.\n\n        Parameters\n        ----------\n        poa_direct : numeric or tuple of numeric\n            The direct irradiance incident upon the module.  [W/m2]\n\n        poa_diffuse : numeric or tuple of numeric\n            The diffuse irradiance incident on module.  [W/m2]\n\n        airmass_absolute : numeric\n            Absolute airmass. [unitless]\n\n        aoi : numeric or tuple of numeric\n            Angle of incidence. [degrees]\n\n        Returns\n        -------\n        effective_irradiance : numeric or tuple of numeric\n            The SAPM effective irradiance. [W/m2]\n        \"\"\"\n        poa_direct = self._validate_per_array(poa_direct)\n        poa_diffuse = self._validate_per_array(poa_diffuse)\n        aoi = self._validate_per_array(aoi)\n        return tuple(\n            sapm_effective_irradiance(\n                poa_direct, poa_diffuse, airmass_absolute, aoi,\n                array.module_parameters)\n            for array, poa_direct, poa_diffuse, aoi\n            in zip(self.arrays, poa_direct, poa_diffuse, aoi)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "sapm_effective_irradiance", "self", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "reference_irradiance", "1000", "use", "the", "py", "func", "sapm_effective_irradiance", "function", "the", "input", "parameters", "and", "self", "module_parameters", "to", "calculate", "effective", "irradiance", "parameters", "poa_direct", "numeric", "or", "tuple", "of", "numeric", "the", "direct", "irradiance", "incident", "upon", "the", "module", "w", "m2", "poa_diffuse", "numeric", "or", "tuple", "of", "numeric", "the", "diffuse", "irradiance", "incident", "on", "module", "w", "m2", "airmass_absolute", "numeric", "absolute", "airmass", "unitless", "aoi", "numeric", "or", "tuple", "of", "numeric", "angle", "of", "incidence", "degrees", "returns", "effective_irradiance", "numeric", "or", "tuple", "of", "numeric", "the", "sapm", "effective", "irradiance", "w", "m2", "poa_direct", "self", "_validate_per_array", "poa_direct", "poa_diffuse", "self", "_validate_per_array", "poa_diffuse", "aoi", "self", "_validate_per_array", "aoi", "return", "tuple", "sapm_effective_irradiance", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "array", "module_parameters", "for", "array", "poa_direct", "poa_diffuse", "aoi", "in", "zip", "self", "arrays", "poa_direct", "poa_diffuse", "aoi"], "doc_len": 120}
{"doc_id": "pvlib/pvsystem.py::PVSystem.pvsyst_celltemp", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "pvsyst_celltemp", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def pvsyst_celltemp(self, poa_global, temp_air, wind_speed=1.0):\n        \"\"\"Uses :py:func:`pvlib.temperature.pvsyst_cell` to calculate cell\n        temperature.\n\n        Parameters\n        ----------\n        poa_global : numeric or tuple of numeric\n            Total incident irradiance in W/m^2.\n\n        temp_air : numeric or tuple of numeric\n            Ambient dry bulb temperature in degrees C.\n\n        wind_speed : numeric or tuple of numeric, default 1.0\n            Wind speed in m/s measured at the same height for which the wind\n            loss factor was determined.  The default value is 1.0, which is\n            the wind speed at module height used to determine NOCT.\n\n        Returns\n        -------\n        numeric or tuple of numeric\n            values in degrees C.\n\n        Notes\n        -----\n        The `temp_air` and `wind_speed` parameters may be passed as tuples\n        to provide different values for each Array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n        \"\"\"\n        return self.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                         model='pvsyst')\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "pvsyst_celltemp", "self", "poa_global", "temp_air", "wind_speed", "1", "0", "uses", "py", "func", "pvlib", "temperature", "pvsyst_cell", "to", "calculate", "cell", "temperature", "parameters", "poa_global", "numeric", "or", "tuple", "of", "numeric", "total", "incident", "irradiance", "in", "w", "m", "2", "temp_air", "numeric", "or", "tuple", "of", "numeric", "ambient", "dry", "bulb", "temperature", "in", "degrees", "c", "wind_speed", "numeric", "or", "tuple", "of", "numeric", "default", "1", "0", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "the", "default", "value", "is", "1", "0", "which", "is", "the", "wind", "speed", "at", "module", "height", "used", "to", "determine", "noct", "returns", "numeric", "or", "tuple", "of", "numeric", "values", "in", "degrees", "c", "notes", "the", "temp_air", "and", "wind_speed", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "return", "self", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "pvsyst"], "doc_len": 166}
{"doc_id": "pvlib/pvsystem.py::PVSystem.faiman_celltemp", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "faiman_celltemp", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def faiman_celltemp(self, poa_global, temp_air, wind_speed=1.0):\n        \"\"\"\n        Use :py:func:`pvlib.temperature.faiman` to calculate cell temperature.\n\n        Parameters\n        ----------\n        poa_global : numeric or tuple of numeric\n            Total incident irradiance [W/m^2].\n\n        temp_air : numeric or tuple of numeric\n            Ambient dry bulb temperature [C].\n\n        wind_speed : numeric or tuple of numeric, default 1.0\n            Wind speed in m/s measured at the same height for which the wind\n            loss factor was determined.  The default value 1.0 m/s is the wind\n            speed at module height used to determine NOCT. [m/s]\n\n        Returns\n        -------\n        numeric or tuple of numeric\n            values in degrees C.\n\n        Notes\n        -----\n        The `temp_air` and `wind_speed` parameters may be passed as tuples\n        to provide different values for each Array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n        \"\"\"\n        return self.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                         model='faiman')\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "faiman_celltemp", "self", "poa_global", "temp_air", "wind_speed", "1", "0", "use", "py", "func", "pvlib", "temperature", "faiman", "to", "calculate", "cell", "temperature", "parameters", "poa_global", "numeric", "or", "tuple", "of", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "or", "tuple", "of", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "or", "tuple", "of", "numeric", "default", "1", "0", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "the", "default", "value", "1", "0", "m", "s", "is", "the", "wind", "speed", "at", "module", "height", "used", "to", "determine", "noct", "m", "s", "returns", "numeric", "or", "tuple", "of", "numeric", "values", "in", "degrees", "c", "notes", "the", "temp_air", "and", "wind_speed", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "return", "self", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "faiman"], "doc_len": 165}
{"doc_id": "pvlib/pvsystem.py::PVSystem.fuentes_celltemp", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "fuentes_celltemp", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def fuentes_celltemp(self, poa_global, temp_air, wind_speed):\n        \"\"\"\n        Use :py:func:`pvlib.temperature.fuentes` to calculate cell temperature.\n\n        Parameters\n        ----------\n        poa_global : pandas Series or tuple of Series\n            Total incident irradiance [W/m^2]\n\n        temp_air : pandas Series or tuple of Series\n            Ambient dry bulb temperature [C]\n\n        wind_speed : pandas Series or tuple of Series\n            Wind speed [m/s]\n\n        Returns\n        -------\n        temperature_cell : Series or tuple of Series\n            The modeled cell temperature [C]\n\n        Notes\n        -----\n        The Fuentes thermal model uses the module surface tilt for convection\n        modeling. The SAM implementation of PVWatts hardcodes the surface tilt\n        value at 30 degrees, ignoring whatever value is used for irradiance\n        transposition.  If you want to match the PVWatts behavior you can\n        either leave ``surface_tilt`` unspecified to use the PVWatts default\n        of 30, or specify a ``surface_tilt`` value in the Array's\n        ``temperature_model_parameters``.\n\n        The `temp_air`, `wind_speed`, and `surface_tilt` parameters may be\n        passed as tuples\n        to provide different values for each Array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n        \"\"\"\n        return self.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                         model='fuentes')\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "fuentes_celltemp", "self", "poa_global", "temp_air", "wind_speed", "use", "py", "func", "pvlib", "temperature", "fuentes", "to", "calculate", "cell", "temperature", "parameters", "poa_global", "pandas", "series", "or", "tuple", "of", "series", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "pandas", "series", "or", "tuple", "of", "series", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "pandas", "series", "or", "tuple", "of", "series", "wind", "speed", "m", "s", "returns", "temperature_cell", "series", "or", "tuple", "of", "series", "the", "modeled", "cell", "temperature", "c", "notes", "the", "fuentes", "thermal", "model", "uses", "the", "module", "surface", "tilt", "for", "convection", "modeling", "the", "sam", "implementation", "of", "pvwatts", "hardcodes", "the", "surface", "tilt", "value", "at", "30", "degrees", "ignoring", "whatever", "value", "is", "used", "for", "irradiance", "transposition", "if", "you", "want", "to", "match", "the", "pvwatts", "behavior", "you", "can", "either", "leave", "surface_tilt", "unspecified", "to", "use", "the", "pvwatts", "default", "of", "30", "or", "specify", "a", "surface_tilt", "value", "in", "the", "array", "s", "temperature_model_parameters", "the", "temp_air", "wind_speed", "and", "surface_tilt", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "return", "self", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "fuentes"], "doc_len": 196}
{"doc_id": "pvlib/pvsystem.py::PVSystem.noct_sam_celltemp", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "noct_sam_celltemp", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def noct_sam_celltemp(self, poa_global, temp_air, wind_speed,\n                          effective_irradiance=None):\n        \"\"\"\n        Use :py:func:`pvlib.temperature.noct_sam` to calculate cell\n        temperature.\n\n        Parameters\n        ----------\n        poa_global : numeric or tuple of numeric\n            Total incident irradiance in W/m^2.\n\n        temp_air : numeric or tuple of numeric\n            Ambient dry bulb temperature in degrees C.\n\n        wind_speed : numeric or tuple of numeric\n            Wind speed in m/s at a height of 10 meters.\n\n        effective_irradiance : numeric, tuple of numeric, or None.\n            The irradiance that is converted to photocurrent. If None,\n            assumed equal to ``poa_global``. [W/m^2]\n\n        Returns\n        -------\n        temperature_cell : numeric or tuple of numeric\n            The modeled cell temperature [C]\n\n        Notes\n        -----\n        The `temp_air` and `wind_speed` parameters may be passed as tuples\n        to provide different values for each Array in the system. If not\n        passed as a tuple then the same value is used for input to each Array.\n        If passed as a tuple the length must be the same as the number of\n        Arrays.\n        \"\"\"\n        return self.get_cell_temperature(\n            poa_global, temp_air, wind_speed, model='noct_sam',\n            effective_irradiance=effective_irradiance)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "noct_sam_celltemp", "self", "poa_global", "temp_air", "wind_speed", "effective_irradiance", "none", "use", "py", "func", "pvlib", "temperature", "noct_sam", "to", "calculate", "cell", "temperature", "parameters", "poa_global", "numeric", "or", "tuple", "of", "numeric", "total", "incident", "irradiance", "in", "w", "m", "2", "temp_air", "numeric", "or", "tuple", "of", "numeric", "ambient", "dry", "bulb", "temperature", "in", "degrees", "c", "wind_speed", "numeric", "or", "tuple", "of", "numeric", "wind", "speed", "in", "m", "s", "at", "a", "height", "of", "10", "meters", "effective_irradiance", "numeric", "tuple", "of", "numeric", "or", "none", "the", "irradiance", "that", "is", "converted", "to", "photocurrent", "if", "none", "assumed", "equal", "to", "poa_global", "w", "m", "2", "returns", "temperature_cell", "numeric", "or", "tuple", "of", "numeric", "the", "modeled", "cell", "temperature", "c", "notes", "the", "temp_air", "and", "wind_speed", "parameters", "may", "be", "passed", "as", "tuples", "to", "provide", "different", "values", "for", "each", "array", "in", "the", "system", "if", "not", "passed", "as", "a", "tuple", "then", "the", "same", "value", "is", "used", "for", "input", "to", "each", "array", "if", "passed", "as", "a", "tuple", "the", "length", "must", "be", "the", "same", "as", "the", "number", "of", "arrays", "return", "self", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "noct_sam", "effective_irradiance", "effective_irradiance"], "doc_len": 165}
{"doc_id": "pvlib/pvsystem.py::PVSystem.first_solar_spectral_loss", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "first_solar_spectral_loss", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def first_solar_spectral_loss(self, pw, airmass_absolute):\n        \"\"\"\n        Use :py:func:`pvlib.atmosphere.first_solar_spectral_correction` to\n        calculate the spectral loss modifier. The model coefficients are\n        specific to the module's cell type, and are determined by searching\n        for one of the following keys in self.module_parameters (in order):\n\n        - 'first_solar_spectral_coefficients' (user-supplied coefficients)\n        - 'Technology' - a string describing the cell type, can be read from\n          the CEC module parameter database\n        - 'Material' - a string describing the cell type, can be read from\n          the Sandia module database.\n\n        Parameters\n        ----------\n        pw : array-like\n            atmospheric precipitable water (cm).\n\n        airmass_absolute : array-like\n            absolute (pressure corrected) airmass.\n\n        Returns\n        -------\n        modifier: array-like or tuple of array-like\n            spectral mismatch factor (unitless) which can be multiplied\n            with broadband irradiance reaching a module's cells to estimate\n            effective irradiance, i.e., the irradiance that is converted to\n            electrical current.\n        \"\"\"\n        pw = self._validate_per_array(pw, system_wide=True)\n\n        def _spectral_correction(array, pw):\n            if 'first_solar_spectral_coefficients' in \\\n                    array.module_parameters.keys():\n                coefficients = \\\n                    array.module_parameters[\n                        'first_solar_spectral_coefficients'\n                    ]\n                module_type = None\n            else:\n                module_type = array._infer_cell_type()\n                coefficients = None\n\n            return atmosphere.first_solar_spectral_correction(\n                pw, airmass_absolute,\n                module_type, coefficients\n            )\n        return tuple(\n            itertools.starmap(_spectral_correction, zip(self.arrays, pw))\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "first_solar_spectral_loss", "self", "pw", "airmass_absolute", "use", "py", "func", "pvlib", "atmosphere", "first_solar_spectral_correction", "to", "calculate", "the", "spectral", "loss", "modifier", "the", "model", "coefficients", "are", "specific", "to", "the", "module", "s", "cell", "type", "and", "are", "determined", "by", "searching", "for", "one", "of", "the", "following", "keys", "in", "self", "module_parameters", "in", "order", "first_solar_spectral_coefficients", "user", "supplied", "coefficients", "technology", "a", "string", "describing", "the", "cell", "type", "can", "be", "read", "from", "the", "cec", "module", "parameter", "database", "material", "a", "string", "describing", "the", "cell", "type", "can", "be", "read", "from", "the", "sandia", "module", "database", "parameters", "pw", "array", "like", "atmospheric", "precipitable", "water", "cm", "airmass_absolute", "array", "like", "absolute", "pressure", "corrected", "airmass", "returns", "modifier", "array", "like", "or", "tuple", "of", "array", "like", "spectral", "mismatch", "factor", "unitless", "which", "can", "be", "multiplied", "with", "broadband", "irradiance", "reaching", "a", "module", "s", "cells", "to", "estimate", "effective", "irradiance", "i", "e", "the", "irradiance", "that", "is", "converted", "to", "electrical", "current", "pw", "self", "_validate_per_array", "pw", "system_wide", "true", "def", "_spectral_correction", "array", "pw", "if", "first_solar_spectral_coefficients", "in", "array", "module_parameters", "keys", "coefficients", "array", "module_parameters", "first_solar_spectral_coefficients", "module_type", "none", "else", "module_type", "array", "_infer_cell_type", "coefficients", "none", "return", "atmosphere", "first_solar_spectral_correction", "pw", "airmass_absolute", "module_type", "coefficients", "return", "tuple", "itertools", "starmap", "_spectral_correction", "zip", "self", "arrays", "pw"], "doc_len": 181}
{"doc_id": "pvlib/pvsystem.py::PVSystem.singlediode", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "singlediode", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def singlediode(self, photocurrent, saturation_current,\n                    resistance_series, resistance_shunt, nNsVth,\n                    ivcurve_pnts=None):\n        \"\"\"Wrapper around the :py:func:`pvlib.pvsystem.singlediode` function.\n\n        See :py:func:`pvsystem.singlediode` for details\n        \"\"\"\n        return singlediode(photocurrent, saturation_current,\n                           resistance_series, resistance_shunt, nNsVth,\n                           ivcurve_pnts=ivcurve_pnts)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "singlediode", "self", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "ivcurve_pnts", "none", "wrapper", "around", "the", "py", "func", "pvlib", "pvsystem", "singlediode", "function", "see", "py", "func", "pvsystem", "singlediode", "for", "details", "return", "singlediode", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "ivcurve_pnts", "ivcurve_pnts"], "doc_len": 39}
{"doc_id": "pvlib/pvsystem.py::PVSystem.i_from_v", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "i_from_v", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def i_from_v(self, resistance_shunt, resistance_series, nNsVth, voltage,\n                 saturation_current, photocurrent):\n        \"\"\"Wrapper around the :py:func:`pvlib.pvsystem.i_from_v` function.\n\n        See :py:func:`pvsystem.i_from_v` for details\n        \"\"\"\n        return i_from_v(resistance_shunt, resistance_series, nNsVth, voltage,\n                        saturation_current, photocurrent)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "i_from_v", "self", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "wrapper", "around", "the", "py", "func", "pvlib", "pvsystem", "i_from_v", "function", "see", "py", "func", "pvsystem", "i_from_v", "for", "details", "return", "i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent"], "doc_len": 37}
{"doc_id": "pvlib/pvsystem.py::PVSystem.get_ac", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "get_ac", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def get_ac(self, model, p_dc, v_dc=None):\n        r\"\"\"Calculates AC power from p_dc using the inverter model indicated\n        by model and self.inverter_parameters.\n\n        Parameters\n        ----------\n        model : str\n            Must be one of 'sandia', 'adr', or 'pvwatts'.\n        p_dc : numeric, or tuple, list or array of numeric\n            DC power on each MPPT input of the inverter. Use tuple, list or\n            array for inverters with multiple MPPT inputs. If type is array,\n            p_dc must be 2d with axis 0 being the MPPT inputs. [W]\n        v_dc : numeric, or tuple, list or array of numeric\n            DC voltage on each MPPT input of the inverter. Required when\n            model='sandia' or model='adr'. Use tuple, list or\n            array for inverters with multiple MPPT inputs. If type is array,\n            v_dc must be 2d with axis 0 being the MPPT inputs. [V]\n\n        Returns\n        -------\n        power_ac : numeric\n            AC power output for the inverter. [W]\n\n        Raises\n        ------\n        ValueError\n            If model is not one of 'sandia', 'adr' or 'pvwatts'.\n        ValueError\n            If model='adr' and the PVSystem has more than one array.\n\n        See also\n        --------\n        pvlib.inverter.sandia\n        pvlib.inverter.sandia_multi\n        pvlib.inverter.adr\n        pvlib.inverter.pvwatts\n        pvlib.inverter.pvwatts_multi\n        \"\"\"\n        model = model.lower()\n        multiple_arrays = self.num_arrays > 1\n        if model == 'sandia':\n            p_dc = self._validate_per_array(p_dc)\n            v_dc = self._validate_per_array(v_dc)\n            if multiple_arrays:\n                return inverter.sandia_multi(\n                    v_dc, p_dc, self.inverter_parameters)\n            return inverter.sandia(v_dc[0], p_dc[0], self.inverter_parameters)\n        elif model == 'pvwatts':\n            kwargs = _build_kwargs(['eta_inv_nom', 'eta_inv_ref'],\n                                   self.inverter_parameters)\n            p_dc = self._validate_per_array(p_dc)\n            if multiple_arrays:\n                return inverter.pvwatts_multi(\n                    p_dc, self.inverter_parameters['pdc0'], **kwargs)\n            return inverter.pvwatts(\n                p_dc[0], self.inverter_parameters['pdc0'], **kwargs)\n        elif model == 'adr':\n            if multiple_arrays:\n                raise ValueError(\n                    'The adr inverter function cannot be used for an inverter',\n                    ' with multiple MPPT inputs')\n            # While this is only used for single-array systems, calling\n            # _validate_per_arry lets us pass in singleton tuples.\n            p_dc = self._validate_per_array(p_dc)\n            v_dc = self._validate_per_array(v_dc)\n            return inverter.adr(v_dc[0], p_dc[0], self.inverter_parameters)\n        else:\n            raise ValueError(\n                model + ' is not a valid AC power model.',\n                ' model must be one of \"sandia\", \"adr\" or \"pvwatts\"')\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "get_ac", "self", "model", "p_dc", "v_dc", "none", "r", "calculates", "ac", "power", "from", "p_dc", "using", "the", "inverter", "model", "indicated", "by", "model", "and", "self", "inverter_parameters", "parameters", "model", "str", "must", "be", "one", "of", "sandia", "adr", "or", "pvwatts", "p_dc", "numeric", "or", "tuple", "list", "or", "array", "of", "numeric", "dc", "power", "on", "each", "mppt", "input", "of", "the", "inverter", "use", "tuple", "list", "or", "array", "for", "inverters", "with", "multiple", "mppt", "inputs", "if", "type", "is", "array", "p_dc", "must", "be", "2d", "with", "axis", "0", "being", "the", "mppt", "inputs", "w", "v_dc", "numeric", "or", "tuple", "list", "or", "array", "of", "numeric", "dc", "voltage", "on", "each", "mppt", "input", "of", "the", "inverter", "required", "when", "model", "sandia", "or", "model", "adr", "use", "tuple", "list", "or", "array", "for", "inverters", "with", "multiple", "mppt", "inputs", "if", "type", "is", "array", "v_dc", "must", "be", "2d", "with", "axis", "0", "being", "the", "mppt", "inputs", "v", "returns", "power_ac", "numeric", "ac", "power", "output", "for", "the", "inverter", "w", "raises", "valueerror", "if", "model", "is", "not", "one", "of", "sandia", "adr", "or", "pvwatts", "valueerror", "if", "model", "adr", "and", "the", "pvsystem", "has", "more", "than", "one", "array", "see", "also", "pvlib", "inverter", "sandia", "pvlib", "inverter", "sandia_multi", "pvlib", "inverter", "adr", "pvlib", "inverter", "pvwatts", "pvlib", "inverter", "pvwatts_multi", "model", "model", "lower", "multiple_arrays", "self", "num_arrays", "1", "if", "model", "sandia", "p_dc", "self", "_validate_per_array", "p_dc", "v_dc", "self", "_validate_per_array", "v_dc", "if", "multiple_arrays", "return", "inverter", "sandia_multi", "v_dc", "p_dc", "self", "inverter_parameters", "return", "inverter", "sandia", "v_dc", "0", "p_dc", "0", "self", "inverter_parameters", "elif", "model", "pvwatts", "kwargs", "_build_kwargs", "eta_inv_nom", "eta_inv_ref", "self", "inverter_parameters", "p_dc", "self", "_validate_per_array", "p_dc", "if", "multiple_arrays", "return", "inverter", "pvwatts_multi", "p_dc", "self", "inverter_parameters", "pdc0", "kwargs", "return", "inverter", "pvwatts", "p_dc", "0", "self", "inverter_parameters", "pdc0", "kwargs", "elif", "model", "adr", "if", "multiple_arrays", "raise", "valueerror", "the", "adr", "inverter", "function", "cannot", "be", "used", "for", "an", "inverter", "with", "multiple", "mppt", "inputs", "while", "this", "is", "only", "used", "for", "single", "array", "systems", "calling", "_validate_per_arry", "lets", "us", "pass", "in", "singleton", "tuples", "p_dc", "self", "_validate_per_array", "p_dc", "v_dc", "self", "_validate_per_array", "v_dc", "return", "inverter", "adr", "v_dc", "0", "p_dc", "0", "self", "inverter_parameters", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "ac", "power", "model", "model", "must", "be", "one", "of", "sandia", "adr", "or", "pvwatts"], "doc_len": 329}
{"doc_id": "pvlib/pvsystem.py::PVSystem.snlinverter", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "snlinverter", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def snlinverter(self, v_dc, p_dc):\n        \"\"\"Uses :py:func:`pvlib.inverter.sandia` to calculate AC power based on\n        ``self.inverter_parameters`` and the input voltage and power.\n\n        See :py:func:`pvlib.inverter.sandia` for details\n        \"\"\"\n        return inverter.sandia(v_dc, p_dc, self.inverter_parameters)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "snlinverter", "self", "v_dc", "p_dc", "uses", "py", "func", "pvlib", "inverter", "sandia", "to", "calculate", "ac", "power", "based", "on", "self", "inverter_parameters", "and", "the", "input", "voltage", "and", "power", "see", "py", "func", "pvlib", "inverter", "sandia", "for", "details", "return", "inverter", "sandia", "v_dc", "p_dc", "self", "inverter_parameters"], "doc_len": 44}
{"doc_id": "pvlib/pvsystem.py::PVSystem.adrinverter", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "adrinverter", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def adrinverter(self, v_dc, p_dc):\n        \"\"\"Uses :py:func:`pvlib.inverter.adr` to calculate AC power based on\n        ``self.inverter_parameters`` and the input voltage and power.\n\n        See :py:func:`pvlib.inverter.adr` for details\n        \"\"\"\n        return inverter.adr(v_dc, p_dc, self.inverter_parameters)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "adrinverter", "self", "v_dc", "p_dc", "uses", "py", "func", "pvlib", "inverter", "adr", "to", "calculate", "ac", "power", "based", "on", "self", "inverter_parameters", "and", "the", "input", "voltage", "and", "power", "see", "py", "func", "pvlib", "inverter", "adr", "for", "details", "return", "inverter", "adr", "v_dc", "p_dc", "self", "inverter_parameters"], "doc_len": 44}
{"doc_id": "pvlib/pvsystem.py::PVSystem.scale_voltage_current_power", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "scale_voltage_current_power", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def scale_voltage_current_power(self, data):\n        \"\"\"\n        Scales the voltage, current, and power of the `data` DataFrame\n        by `self.modules_per_string` and `self.strings_per_inverter`.\n\n        Parameters\n        ----------\n        data: DataFrame or tuple of DataFrame\n            May contain columns `'v_mp', 'v_oc', 'i_mp' ,'i_x', 'i_xx',\n            'i_sc', 'p_mp'`.\n\n        Returns\n        -------\n        scaled_data: DataFrame or tuple of DataFrame\n            A scaled copy of the input data.\n        \"\"\"\n        data = self._validate_per_array(data)\n        return tuple(\n            scale_voltage_current_power(data,\n                                        voltage=array.modules_per_string,\n                                        current=array.strings)\n            for array, data in zip(self.arrays, data)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "scale_voltage_current_power", "self", "data", "scales", "the", "voltage", "current", "and", "power", "of", "the", "data", "dataframe", "by", "self", "modules_per_string", "and", "self", "strings_per_inverter", "parameters", "data", "dataframe", "or", "tuple", "of", "dataframe", "may", "contain", "columns", "v_mp", "v_oc", "i_mp", "i_x", "i_xx", "i_sc", "p_mp", "returns", "scaled_data", "dataframe", "or", "tuple", "of", "dataframe", "a", "scaled", "copy", "of", "the", "input", "data", "data", "self", "_validate_per_array", "data", "return", "tuple", "scale_voltage_current_power", "data", "voltage", "array", "modules_per_string", "current", "array", "strings", "for", "array", "data", "in", "zip", "self", "arrays", "data"], "doc_len": 77}
{"doc_id": "pvlib/pvsystem.py::PVSystem.pvwatts_dc", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "pvwatts_dc", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def pvwatts_dc(self, g_poa_effective, temp_cell):\n        \"\"\"\n        Calcuates DC power according to the PVWatts model using\n        :py:func:`pvlib.pvsystem.pvwatts_dc`, `self.module_parameters['pdc0']`,\n        and `self.module_parameters['gamma_pdc']`.\n\n        See :py:func:`pvlib.pvsystem.pvwatts_dc` for details.\n        \"\"\"\n        g_poa_effective = self._validate_per_array(g_poa_effective)\n        temp_cell = self._validate_per_array(temp_cell)\n        return tuple(\n            pvwatts_dc(g_poa_effective, temp_cell,\n                       array.module_parameters['pdc0'],\n                       array.module_parameters['gamma_pdc'],\n                       **_build_kwargs(['temp_ref'], array.module_parameters))\n            for array, g_poa_effective, temp_cell\n            in zip(self.arrays, g_poa_effective, temp_cell)\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "pvwatts_dc", "self", "g_poa_effective", "temp_cell", "calcuates", "dc", "power", "according", "to", "the", "pvwatts", "model", "using", "py", "func", "pvlib", "pvsystem", "pvwatts_dc", "self", "module_parameters", "pdc0", "and", "self", "module_parameters", "gamma_pdc", "see", "py", "func", "pvlib", "pvsystem", "pvwatts_dc", "for", "details", "g_poa_effective", "self", "_validate_per_array", "g_poa_effective", "temp_cell", "self", "_validate_per_array", "temp_cell", "return", "tuple", "pvwatts_dc", "g_poa_effective", "temp_cell", "array", "module_parameters", "pdc0", "array", "module_parameters", "gamma_pdc", "_build_kwargs", "temp_ref", "array", "module_parameters", "for", "array", "g_poa_effective", "temp_cell", "in", "zip", "self", "arrays", "g_poa_effective", "temp_cell"], "doc_len": 71}
{"doc_id": "pvlib/pvsystem.py::PVSystem.pvwatts_losses", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "pvwatts_losses", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def pvwatts_losses(self):\n        \"\"\"\n        Calculates DC power losses according the PVwatts model using\n        :py:func:`pvlib.pvsystem.pvwatts_losses` and\n        ``self.losses_parameters``.\n\n        See :py:func:`pvlib.pvsystem.pvwatts_losses` for details.\n        \"\"\"\n        kwargs = _build_kwargs(['soiling', 'shading', 'snow', 'mismatch',\n                                'wiring', 'connections', 'lid',\n                                'nameplate_rating', 'age', 'availability'],\n                               self.losses_parameters)\n        return pvwatts_losses(**kwargs)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "pvwatts_losses", "self", "calculates", "dc", "power", "losses", "according", "the", "pvwatts", "model", "using", "py", "func", "pvlib", "pvsystem", "pvwatts_losses", "and", "self", "losses_parameters", "see", "py", "func", "pvlib", "pvsystem", "pvwatts_losses", "for", "details", "kwargs", "_build_kwargs", "soiling", "shading", "snow", "mismatch", "wiring", "connections", "lid", "nameplate_rating", "age", "availability", "self", "losses_parameters", "return", "pvwatts_losses", "kwargs"], "doc_len": 49}
{"doc_id": "pvlib/pvsystem.py::PVSystem.pvwatts_ac", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "pvwatts_ac", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def pvwatts_ac(self, pdc):\n        \"\"\"\n        Calculates AC power according to the PVWatts model using\n        :py:func:`pvlib.inverter.pvwatts`, `self.module_parameters[\"pdc0\"]`,\n        and `eta_inv_nom=self.inverter_parameters[\"eta_inv_nom\"]`.\n\n        See :py:func:`pvlib.inverter.pvwatts` for details.\n        \"\"\"\n        kwargs = _build_kwargs(['eta_inv_nom', 'eta_inv_ref'],\n                               self.inverter_parameters)\n\n        return inverter.pvwatts(pdc, self.inverter_parameters['pdc0'],\n                                **kwargs)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "pvwatts_ac", "self", "pdc", "calculates", "ac", "power", "according", "to", "the", "pvwatts", "model", "using", "py", "func", "pvlib", "inverter", "pvwatts", "self", "module_parameters", "pdc0", "and", "eta_inv_nom", "self", "inverter_parameters", "eta_inv_nom", "see", "py", "func", "pvlib", "inverter", "pvwatts", "for", "details", "kwargs", "_build_kwargs", "eta_inv_nom", "eta_inv_ref", "self", "inverter_parameters", "return", "inverter", "pvwatts", "pdc", "self", "inverter_parameters", "pdc0", "kwargs"], "doc_len": 52}
{"doc_id": "pvlib/pvsystem.py::PVSystem.dc_ohms_from_percent", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "dc_ohms_from_percent", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def dc_ohms_from_percent(self):\n        \"\"\"\n        Calculates the equivalent resistance of the wires for each array using\n        :py:func:`pvlib.pvsystem.dc_ohms_from_percent`\n\n        See :py:func:`pvlib.pvsystem.dc_ohms_from_percent` for details.\n        \"\"\"\n\n        return tuple(array.dc_ohms_from_percent() for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "dc_ohms_from_percent", "self", "calculates", "the", "equivalent", "resistance", "of", "the", "wires", "for", "each", "array", "using", "py", "func", "pvlib", "pvsystem", "dc_ohms_from_percent", "see", "py", "func", "pvlib", "pvsystem", "dc_ohms_from_percent", "for", "details", "return", "tuple", "array", "dc_ohms_from_percent", "for", "array", "in", "self", "arrays"], "doc_len": 40}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module_parameters", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module_parameters", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module_parameters(self):\n        return tuple(array.module_parameters for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module_parameters", "self", "return", "tuple", "array", "module_parameters", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module_parameters", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module_parameters", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module_parameters(self, value):\n        for array in self.arrays:\n            array.module_parameters = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module_parameters", "self", "value", "for", "array", "in", "self", "arrays", "array", "module_parameters", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module(self):\n        return tuple(array.module for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module", "self", "return", "tuple", "array", "module", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module(self, value):\n        for array in self.arrays:\n            array.module = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module", "self", "value", "for", "array", "in", "self", "arrays", "array", "module", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module_type", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module_type", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module_type(self):\n        return tuple(array.module_type for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module_type", "self", "return", "tuple", "array", "module_type", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.module_type", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "module_type", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def module_type(self, value):\n        for array in self.arrays:\n            array.module_type = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "module_type", "self", "value", "for", "array", "in", "self", "arrays", "array", "module_type", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.temperature_model_parameters", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "temperature_model_parameters", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def temperature_model_parameters(self):\n        return tuple(array.temperature_model_parameters\n                     for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "temperature_model_parameters", "self", "return", "tuple", "array", "temperature_model_parameters", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.temperature_model_parameters", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "temperature_model_parameters", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def temperature_model_parameters(self, value):\n        for array in self.arrays:\n            array.temperature_model_parameters = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "temperature_model_parameters", "self", "value", "for", "array", "in", "self", "arrays", "array", "temperature_model_parameters", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.surface_tilt", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "surface_tilt", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def surface_tilt(self):\n        return tuple(array.mount.surface_tilt for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "surface_tilt", "self", "return", "tuple", "array", "mount", "surface_tilt", "for", "array", "in", "self", "arrays"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.surface_tilt", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "surface_tilt", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def surface_tilt(self, value):\n        for array in self.arrays:\n            array.mount.surface_tilt = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "surface_tilt", "self", "value", "for", "array", "in", "self", "arrays", "array", "mount", "surface_tilt", "value"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.surface_azimuth", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "surface_azimuth", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def surface_azimuth(self):\n        return tuple(array.mount.surface_azimuth for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "surface_azimuth", "self", "return", "tuple", "array", "mount", "surface_azimuth", "for", "array", "in", "self", "arrays"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.surface_azimuth", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "surface_azimuth", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def surface_azimuth(self, value):\n        for array in self.arrays:\n            array.mount.surface_azimuth = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "surface_azimuth", "self", "value", "for", "array", "in", "self", "arrays", "array", "mount", "surface_azimuth", "value"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.albedo", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "albedo", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def albedo(self):\n        return tuple(array.albedo for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "albedo", "self", "return", "tuple", "array", "albedo", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.albedo", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "albedo", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def albedo(self, value):\n        for array in self.arrays:\n            array.albedo = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "albedo", "self", "value", "for", "array", "in", "self", "arrays", "array", "albedo", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.racking_model", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "racking_model", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def racking_model(self):\n        return tuple(array.mount.racking_model for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "racking_model", "self", "return", "tuple", "array", "mount", "racking_model", "for", "array", "in", "self", "arrays"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.racking_model", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "racking_model", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def racking_model(self, value):\n        for array in self.arrays:\n            array.mount.racking_model = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "racking_model", "self", "value", "for", "array", "in", "self", "arrays", "array", "mount", "racking_model", "value"], "doc_len": 17}
{"doc_id": "pvlib/pvsystem.py::PVSystem.modules_per_string", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "modules_per_string", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def modules_per_string(self):\n        return tuple(array.modules_per_string for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "modules_per_string", "self", "return", "tuple", "array", "modules_per_string", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.modules_per_string", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "modules_per_string", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def modules_per_string(self, value):\n        for array in self.arrays:\n            array.modules_per_string = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "modules_per_string", "self", "value", "for", "array", "in", "self", "arrays", "array", "modules_per_string", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.strings_per_inverter", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "strings_per_inverter", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def strings_per_inverter(self):\n        return tuple(array.strings for array in self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "strings_per_inverter", "self", "return", "tuple", "array", "strings", "for", "array", "in", "self", "arrays"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.strings_per_inverter", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "strings_per_inverter", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def strings_per_inverter(self, value):\n        for array in self.arrays:\n            array.strings = value\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "strings_per_inverter", "self", "value", "for", "array", "in", "self", "arrays", "array", "strings", "value"], "doc_len": 16}
{"doc_id": "pvlib/pvsystem.py::PVSystem.num_arrays", "file_path": "pvlib/pvsystem.py", "class_name": "PVSystem", "func_name": "num_arrays", "text": "文件路径: pvlib/pvsystem.py, 类名: PVSystem\n    def num_arrays(self):\n        \"\"\"The number of Arrays in the system.\"\"\"\n        return len(self.arrays)\n", "tokens": ["pvlib", "pvsystem", "py", "pvsystem", "def", "num_arrays", "self", "the", "number", "of", "arrays", "in", "the", "system", "return", "len", "self", "arrays"], "doc_len": 18}
{"doc_id": "pvlib/pvsystem.py::Array.__init__", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "__init__", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def __init__(self, mount,\n                 albedo=None, surface_type=None,\n                 module=None, module_type=None,\n                 module_parameters=None,\n                 temperature_model_parameters=None,\n                 modules_per_string=1, strings=1,\n                 array_losses_parameters=None,\n                 name=None):\n        self.mount = mount\n\n        self.surface_type = surface_type\n        if albedo is None:\n            self.albedo = irradiance.SURFACE_ALBEDOS.get(surface_type, 0.25)\n        else:\n            self.albedo = albedo\n\n        self.module = module\n        if module_parameters is None:\n            self.module_parameters = {}\n        else:\n            self.module_parameters = module_parameters\n\n        self.module_type = module_type\n\n        self.strings = strings\n        self.modules_per_string = modules_per_string\n\n        if temperature_model_parameters is None:\n            self.temperature_model_parameters = \\\n                self._infer_temperature_model_params()\n        else:\n            self.temperature_model_parameters = temperature_model_parameters\n\n        if array_losses_parameters is None:\n            self.array_losses_parameters = {}\n        else:\n            self.array_losses_parameters = array_losses_parameters\n\n        self.name = name\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "__init__", "self", "mount", "albedo", "none", "surface_type", "none", "module", "none", "module_type", "none", "module_parameters", "none", "temperature_model_parameters", "none", "modules_per_string", "1", "strings", "1", "array_losses_parameters", "none", "name", "none", "self", "mount", "mount", "self", "surface_type", "surface_type", "if", "albedo", "is", "none", "self", "albedo", "irradiance", "surface_albedos", "get", "surface_type", "0", "25", "else", "self", "albedo", "albedo", "self", "module", "module", "if", "module_parameters", "is", "none", "self", "module_parameters", "else", "self", "module_parameters", "module_parameters", "self", "module_type", "module_type", "self", "strings", "strings", "self", "modules_per_string", "modules_per_string", "if", "temperature_model_parameters", "is", "none", "self", "temperature_model_parameters", "self", "_infer_temperature_model_params", "else", "self", "temperature_model_parameters", "temperature_model_parameters", "if", "array_losses_parameters", "is", "none", "self", "array_losses_parameters", "else", "self", "array_losses_parameters", "array_losses_parameters", "self", "name", "name"], "doc_len": 97}
{"doc_id": "pvlib/pvsystem.py::Array.__repr__", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "__repr__", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def __repr__(self):\n        attrs = ['name', 'mount', 'module',\n                 'albedo', 'module_type',\n                 'temperature_model_parameters',\n                 'strings', 'modules_per_string']\n\n        return 'Array:\\n  ' + '\\n  '.join(\n            f'{attr}: {getattr(self, attr)}' for attr in attrs\n        )\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "__repr__", "self", "attrs", "name", "mount", "module", "albedo", "module_type", "temperature_model_parameters", "strings", "modules_per_string", "return", "array", "n", "n", "join", "f", "attr", "getattr", "self", "attr", "for", "attr", "in", "attrs"], "doc_len": 30}
{"doc_id": "pvlib/pvsystem.py::Array._infer_temperature_model_params", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "_infer_temperature_model_params", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def _infer_temperature_model_params(self):\n        # try to infer temperature model parameters from from racking_model\n        # and module_type\n        param_set = f'{self.mount.racking_model}_{self.module_type}'\n        if param_set in temperature.TEMPERATURE_MODEL_PARAMETERS['sapm']:\n            return temperature._temperature_model_params('sapm', param_set)\n        elif 'freestanding' in param_set:\n            return temperature._temperature_model_params('pvsyst',\n                                                         'freestanding')\n        elif 'insulated' in param_set:  # after SAPM to avoid confusing keys\n            return temperature._temperature_model_params('pvsyst',\n                                                         'insulated')\n        else:\n            return {}\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "_infer_temperature_model_params", "self", "try", "to", "infer", "temperature", "model", "parameters", "from", "from", "racking_model", "and", "module_type", "param_set", "f", "self", "mount", "racking_model", "_", "self", "module_type", "if", "param_set", "in", "temperature", "temperature_model_parameters", "sapm", "return", "temperature", "_temperature_model_params", "sapm", "param_set", "elif", "freestanding", "in", "param_set", "return", "temperature", "_temperature_model_params", "pvsyst", "freestanding", "elif", "insulated", "in", "param_set", "after", "sapm", "to", "avoid", "confusing", "keys", "return", "temperature", "_temperature_model_params", "pvsyst", "insulated", "else", "return"], "doc_len": 63}
{"doc_id": "pvlib/pvsystem.py::Array._infer_cell_type", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "_infer_cell_type", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def _infer_cell_type(self):\n        \"\"\"\n        Examines module_parameters and maps the Technology key for the CEC\n        database and the Material key for the Sandia database to a common\n        list of strings for cell type.\n\n        Returns\n        -------\n        cell_type: str\n\n        \"\"\"\n\n        _cell_type_dict = {'Multi-c-Si': 'multisi',\n                           'Mono-c-Si': 'monosi',\n                           'Thin Film': 'cigs',\n                           'a-Si/nc': 'asi',\n                           'CIS': 'cigs',\n                           'CIGS': 'cigs',\n                           '1-a-Si': 'asi',\n                           'CdTe': 'cdte',\n                           'a-Si': 'asi',\n                           '2-a-Si': None,\n                           '3-a-Si': None,\n                           'HIT-Si': 'monosi',\n                           'mc-Si': 'multisi',\n                           'c-Si': 'multisi',\n                           'Si-Film': 'asi',\n                           'EFG mc-Si': 'multisi',\n                           'GaAs': None,\n                           'a-Si / mono-Si': 'monosi'}\n\n        if 'Technology' in self.module_parameters.keys():\n            # CEC module parameter set\n            cell_type = _cell_type_dict[self.module_parameters['Technology']]\n        elif 'Material' in self.module_parameters.keys():\n            # Sandia module parameter set\n            cell_type = _cell_type_dict[self.module_parameters['Material']]\n        else:\n            cell_type = None\n\n        return cell_type\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "_infer_cell_type", "self", "examines", "module_parameters", "and", "maps", "the", "technology", "key", "for", "the", "cec", "database", "and", "the", "material", "key", "for", "the", "sandia", "database", "to", "a", "common", "list", "of", "strings", "for", "cell", "type", "returns", "cell_type", "str", "_cell_type_dict", "multi", "c", "si", "multisi", "mono", "c", "si", "monosi", "thin", "film", "cigs", "a", "si", "nc", "asi", "cis", "cigs", "cigs", "cigs", "1", "a", "si", "asi", "cdte", "cdte", "a", "si", "asi", "2", "a", "si", "none", "3", "a", "si", "none", "hit", "si", "monosi", "mc", "si", "multisi", "c", "si", "multisi", "si", "film", "asi", "efg", "mc", "si", "multisi", "gaas", "none", "a", "si", "mono", "si", "monosi", "if", "technology", "in", "self", "module_parameters", "keys", "cec", "module", "parameter", "set", "cell_type", "_cell_type_dict", "self", "module_parameters", "technology", "elif", "material", "in", "self", "module_parameters", "keys", "sandia", "module", "parameter", "set", "cell_type", "_cell_type_dict", "self", "module_parameters", "material", "else", "cell_type", "none", "return", "cell_type"], "doc_len": 133}
{"doc_id": "pvlib/pvsystem.py::Array.get_aoi", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "get_aoi", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def get_aoi(self, solar_zenith, solar_azimuth):\n        \"\"\"\n        Get the angle of incidence on the array.\n\n        Parameters\n        ----------\n        solar_zenith : float or Series\n            Solar zenith angle.\n        solar_azimuth : float or Series\n            Solar azimuth angle\n\n        Returns\n        -------\n        aoi : Series\n            Then angle of incidence.\n        \"\"\"\n        orientation = self.mount.get_orientation(solar_zenith, solar_azimuth)\n        return irradiance.aoi(orientation['surface_tilt'],\n                              orientation['surface_azimuth'],\n                              solar_zenith, solar_azimuth)\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "get_aoi", "self", "solar_zenith", "solar_azimuth", "get", "the", "angle", "of", "incidence", "on", "the", "array", "parameters", "solar_zenith", "float", "or", "series", "solar", "zenith", "angle", "solar_azimuth", "float", "or", "series", "solar", "azimuth", "angle", "returns", "aoi", "series", "then", "angle", "of", "incidence", "orientation", "self", "mount", "get_orientation", "solar_zenith", "solar_azimuth", "return", "irradiance", "aoi", "orientation", "surface_tilt", "orientation", "surface_azimuth", "solar_zenith", "solar_azimuth"], "doc_len": 54}
{"doc_id": "pvlib/pvsystem.py::Array.get_irradiance", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "get_irradiance", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def get_irradiance(self, solar_zenith, solar_azimuth, dni, ghi, dhi,\n                       dni_extra=None, airmass=None, albedo=None,\n                       model='haydavies', **kwargs):\n        \"\"\"\n        Get plane of array irradiance components.\n\n        Uses the :py:func:`pvlib.irradiance.get_total_irradiance` function to\n        calculate the plane of array irradiance components for a surface\n        defined by ``self.surface_tilt`` and ``self.surface_azimuth``.\n\n        Parameters\n        ----------\n        solar_zenith : float or Series.\n            Solar zenith angle.\n        solar_azimuth : float or Series.\n            Solar azimuth angle.\n        dni : float or Series\n            Direct normal irradiance. [W/m2]\n        ghi : float or Series. [W/m2]\n            Global horizontal irradiance\n        dhi : float or Series\n            Diffuse horizontal irradiance. [W/m2]\n        dni_extra : None, float or Series, default None\n            Extraterrestrial direct normal irradiance. [W/m2]\n        airmass : None, float or Series, default None\n            Airmass. [unitless]\n        albedo : None, float or Series, default None\n            Ground surface albedo. [unitless]\n        model : String, default 'haydavies'\n            Irradiance model.\n\n        kwargs\n            Extra parameters passed to\n            :py:func:`pvlib.irradiance.get_total_irradiance`.\n\n        Returns\n        -------\n        poa_irradiance : DataFrame\n            Column names are: ``'poa_global', 'poa_direct', 'poa_diffuse',\n            'poa_sky_diffuse', 'poa_ground_diffuse'``.\n\n        See also\n        --------\n        :py:func:`pvlib.irradiance.get_total_irradiance`\n        \"\"\"\n        if albedo is None:\n            albedo = self.albedo\n\n        # not needed for all models, but this is easier\n        if dni_extra is None:\n            dni_extra = irradiance.get_extra_radiation(solar_zenith.index)\n\n        if airmass is None:\n            airmass = atmosphere.get_relative_airmass(solar_zenith)\n\n        orientation = self.mount.get_orientation(solar_zenith, solar_azimuth)\n        return irradiance.get_total_irradiance(orientation['surface_tilt'],\n                                               orientation['surface_azimuth'],\n                                               solar_zenith, solar_azimuth,\n                                               dni, ghi, dhi,\n                                               dni_extra=dni_extra,\n                                               airmass=airmass,\n                                               albedo=albedo,\n                                               model=model,\n                                               **kwargs)\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "get_irradiance", "self", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "none", "airmass", "none", "albedo", "none", "model", "haydavies", "kwargs", "get", "plane", "of", "array", "irradiance", "components", "uses", "the", "py", "func", "pvlib", "irradiance", "get_total_irradiance", "function", "to", "calculate", "the", "plane", "of", "array", "irradiance", "components", "for", "a", "surface", "defined", "by", "self", "surface_tilt", "and", "self", "surface_azimuth", "parameters", "solar_zenith", "float", "or", "series", "solar", "zenith", "angle", "solar_azimuth", "float", "or", "series", "solar", "azimuth", "angle", "dni", "float", "or", "series", "direct", "normal", "irradiance", "w", "m2", "ghi", "float", "or", "series", "w", "m2", "global", "horizontal", "irradiance", "dhi", "float", "or", "series", "diffuse", "horizontal", "irradiance", "w", "m2", "dni_extra", "none", "float", "or", "series", "default", "none", "extraterrestrial", "direct", "normal", "irradiance", "w", "m2", "airmass", "none", "float", "or", "series", "default", "none", "airmass", "unitless", "albedo", "none", "float", "or", "series", "default", "none", "ground", "surface", "albedo", "unitless", "model", "string", "default", "haydavies", "irradiance", "model", "kwargs", "extra", "parameters", "passed", "to", "py", "func", "pvlib", "irradiance", "get_total_irradiance", "returns", "poa_irradiance", "dataframe", "column", "names", "are", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "see", "also", "py", "func", "pvlib", "irradiance", "get_total_irradiance", "if", "albedo", "is", "none", "albedo", "self", "albedo", "not", "needed", "for", "all", "models", "but", "this", "is", "easier", "if", "dni_extra", "is", "none", "dni_extra", "irradiance", "get_extra_radiation", "solar_zenith", "index", "if", "airmass", "is", "none", "airmass", "atmosphere", "get_relative_airmass", "solar_zenith", "orientation", "self", "mount", "get_orientation", "solar_zenith", "solar_azimuth", "return", "irradiance", "get_total_irradiance", "orientation", "surface_tilt", "orientation", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "dni_extra", "airmass", "airmass", "albedo", "albedo", "model", "model", "kwargs"], "doc_len": 222}
{"doc_id": "pvlib/pvsystem.py::Array.get_iam", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "get_iam", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def get_iam(self, aoi, iam_model='physical'):\n        \"\"\"\n        Determine the incidence angle modifier using the method specified by\n        ``iam_model``.\n\n        Parameters for the selected IAM model are expected to be in\n        ``Array.module_parameters``. Default parameters are available for\n        the 'physical', 'ashrae' and 'martin_ruiz' models.\n\n        Parameters\n        ----------\n        aoi : numeric\n            The angle of incidence in degrees.\n\n        aoi_model : string, default 'physical'\n            The IAM model to be used. Valid strings are 'physical', 'ashrae',\n            'martin_ruiz' and 'sapm'.\n\n        Returns\n        -------\n        iam : numeric\n            The AOI modifier.\n\n        Raises\n        ------\n        ValueError\n            if `iam_model` is not a valid model name.\n        \"\"\"\n        model = iam_model.lower()\n        if model in ['ashrae', 'physical', 'martin_ruiz']:\n            param_names = iam._IAM_MODEL_PARAMS[model]\n            kwargs = _build_kwargs(param_names, self.module_parameters)\n            func = getattr(iam, model)\n            return func(aoi, **kwargs)\n        elif model == 'sapm':\n            return iam.sapm(aoi, self.module_parameters)\n        elif model == 'interp':\n            raise ValueError(model + ' is not implemented as an IAM model '\n                             'option for Array')\n        else:\n            raise ValueError(model + ' is not a valid IAM model')\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "get_iam", "self", "aoi", "iam_model", "physical", "determine", "the", "incidence", "angle", "modifier", "using", "the", "method", "specified", "by", "iam_model", "parameters", "for", "the", "selected", "iam", "model", "are", "expected", "to", "be", "in", "array", "module_parameters", "default", "parameters", "are", "available", "for", "the", "physical", "ashrae", "and", "martin_ruiz", "models", "parameters", "aoi", "numeric", "the", "angle", "of", "incidence", "in", "degrees", "aoi_model", "string", "default", "physical", "the", "iam", "model", "to", "be", "used", "valid", "strings", "are", "physical", "ashrae", "martin_ruiz", "and", "sapm", "returns", "iam", "numeric", "the", "aoi", "modifier", "raises", "valueerror", "if", "iam_model", "is", "not", "a", "valid", "model", "name", "model", "iam_model", "lower", "if", "model", "in", "ashrae", "physical", "martin_ruiz", "param_names", "iam", "_iam_model_params", "model", "kwargs", "_build_kwargs", "param_names", "self", "module_parameters", "func", "getattr", "iam", "model", "return", "func", "aoi", "kwargs", "elif", "model", "sapm", "return", "iam", "sapm", "aoi", "self", "module_parameters", "elif", "model", "interp", "raise", "valueerror", "model", "is", "not", "implemented", "as", "an", "iam", "model", "option", "for", "array", "else", "raise", "valueerror", "model", "is", "not", "a", "valid", "iam", "model"], "doc_len": 149}
{"doc_id": "pvlib/pvsystem.py::Array.get_cell_temperature", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "get_cell_temperature", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def get_cell_temperature(self, poa_global, temp_air, wind_speed, model,\n                             effective_irradiance=None):\n        \"\"\"\n        Determine cell temperature using the method specified by ``model``.\n\n        Parameters\n        ----------\n        poa_global : numeric\n            Total incident irradiance [W/m^2]\n\n        temp_air : numeric\n            Ambient dry bulb temperature [C]\n\n        wind_speed : numeric\n            Wind speed [m/s]\n\n        model : str\n            Supported models include ``'sapm'``, ``'pvsyst'``,\n            ``'faiman'``, ``'fuentes'``, and ``'noct_sam'``\n\n        effective_irradiance : numeric, optional\n            The irradiance that is converted to photocurrent in W/m^2.\n            Only used for some models.\n\n        Returns\n        -------\n        numeric\n            Values in degrees C.\n\n        See Also\n        --------\n        pvlib.temperature.sapm_cell, pvlib.temperature.pvsyst_cell,\n        pvlib.temperature.faiman, pvlib.temperature.fuentes,\n        pvlib.temperature.noct_sam\n\n        Notes\n        -----\n        Some temperature models have requirements for the input types;\n        see the documentation of the underlying model function for details.\n        \"\"\"\n        # convenience wrapper to avoid passing args 2 and 3 every call\n        _build_tcell_args = functools.partial(\n            _build_args, input_dict=self.temperature_model_parameters,\n            dict_name='temperature_model_parameters')\n\n        if model == 'sapm':\n            func = temperature.sapm_cell\n            required = _build_tcell_args(['a', 'b', 'deltaT'])\n            optional = _build_kwargs(['irrad_ref'],\n                                     self.temperature_model_parameters)\n        elif model == 'pvsyst':\n            func = temperature.pvsyst_cell\n            required = tuple()\n            optional = {\n                # TODO remove 'eta_m' after deprecation of this parameter\n                **_build_kwargs(['eta_m', 'module_efficiency',\n                                 'alpha_absorption'],\n                                self.module_parameters),\n                **_build_kwargs(['u_c', 'u_v'],\n                                self.temperature_model_parameters)\n            }\n        elif model == 'faiman':\n            func = temperature.faiman\n            required = tuple()\n            optional = _build_kwargs(['u0', 'u1'],\n                                     self.temperature_model_parameters)\n        elif model == 'fuentes':\n            func = temperature.fuentes\n            required = _build_tcell_args(['noct_installed'])\n            optional = _build_kwargs([\n                'wind_height', 'emissivity', 'absorption',\n                'surface_tilt', 'module_width', 'module_length'],\n                self.temperature_model_parameters)\n            if self.mount.module_height is not None:\n                optional['module_height'] = self.mount.module_height\n        elif model == 'noct_sam':\n            func = functools.partial(temperature.noct_sam,\n                                     effective_irradiance=effective_irradiance)\n            required = _build_tcell_args(['noct', 'module_efficiency'])\n            optional = _build_kwargs(['transmittance_absorptance',\n                                      'array_height', 'mount_standoff'],\n                                     self.temperature_model_parameters)\n        else:\n            raise ValueError(f'{model} is not a valid cell temperature model')\n\n        temperature_cell = func(poa_global, temp_air, wind_speed,\n                                *required, **optional)\n        return temperature_cell\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "get_cell_temperature", "self", "poa_global", "temp_air", "wind_speed", "model", "effective_irradiance", "none", "determine", "cell", "temperature", "using", "the", "method", "specified", "by", "model", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "m", "s", "model", "str", "supported", "models", "include", "sapm", "pvsyst", "faiman", "fuentes", "and", "noct_sam", "effective_irradiance", "numeric", "optional", "the", "irradiance", "that", "is", "converted", "to", "photocurrent", "in", "w", "m", "2", "only", "used", "for", "some", "models", "returns", "numeric", "values", "in", "degrees", "c", "see", "also", "pvlib", "temperature", "sapm_cell", "pvlib", "temperature", "pvsyst_cell", "pvlib", "temperature", "faiman", "pvlib", "temperature", "fuentes", "pvlib", "temperature", "noct_sam", "notes", "some", "temperature", "models", "have", "requirements", "for", "the", "input", "types", "see", "the", "documentation", "of", "the", "underlying", "model", "function", "for", "details", "convenience", "wrapper", "to", "avoid", "passing", "args", "2", "and", "3", "every", "call", "_build_tcell_args", "functools", "partial", "_build_args", "input_dict", "self", "temperature_model_parameters", "dict_name", "temperature_model_parameters", "if", "model", "sapm", "func", "temperature", "sapm_cell", "required", "_build_tcell_args", "a", "b", "deltat", "optional", "_build_kwargs", "irrad_ref", "self", "temperature_model_parameters", "elif", "model", "pvsyst", "func", "temperature", "pvsyst_cell", "required", "tuple", "optional", "todo", "remove", "eta_m", "after", "deprecation", "of", "this", "parameter", "_build_kwargs", "eta_m", "module_efficiency", "alpha_absorption", "self", "module_parameters", "_build_kwargs", "u_c", "u_v", "self", "temperature_model_parameters", "elif", "model", "faiman", "func", "temperature", "faiman", "required", "tuple", "optional", "_build_kwargs", "u0", "u1", "self", "temperature_model_parameters", "elif", "model", "fuentes", "func", "temperature", "fuentes", "required", "_build_tcell_args", "noct_installed", "optional", "_build_kwargs", "wind_height", "emissivity", "absorption", "surface_tilt", "module_width", "module_length", "self", "temperature_model_parameters", "if", "self", "mount", "module_height", "is", "not", "none", "optional", "module_height", "self", "mount", "module_height", "elif", "model", "noct_sam", "func", "functools", "partial", "temperature", "noct_sam", "effective_irradiance", "effective_irradiance", "required", "_build_tcell_args", "noct", "module_efficiency", "optional", "_build_kwargs", "transmittance_absorptance", "array_height", "mount_standoff", "self", "temperature_model_parameters", "else", "raise", "valueerror", "f", "model", "is", "not", "a", "valid", "cell", "temperature", "model", "temperature_cell", "func", "poa_global", "temp_air", "wind_speed", "required", "optional", "return", "temperature_cell"], "doc_len": 268}
{"doc_id": "pvlib/pvsystem.py::Array.dc_ohms_from_percent", "file_path": "pvlib/pvsystem.py", "class_name": "Array", "func_name": "dc_ohms_from_percent", "text": "文件路径: pvlib/pvsystem.py, 类名: Array\n    def dc_ohms_from_percent(self):\n        \"\"\"\n        Calculates the equivalent resistance of the wires using\n        :py:func:`pvlib.pvsystem.dc_ohms_from_percent`\n\n        Makes use of array module parameters according to the\n        following DC models:\n\n        CEC:\n\n            * `self.module_parameters[\"V_mp_ref\"]`\n            * `self.module_parameters[\"I_mp_ref\"]`\n\n        SAPM:\n\n            * `self.module_parameters[\"Vmpo\"]`\n            * `self.module_parameters[\"Impo\"]`\n\n        PVsyst-like or other:\n\n            * `self.module_parameters[\"Vmpp\"]`\n            * `self.module_parameters[\"Impp\"]`\n\n        Other array parameters that are used are:\n        `self.losses_parameters[\"dc_ohmic_percent\"]`,\n        `self.modules_per_string`, and\n        `self.strings`.\n\n        See :py:func:`pvlib.pvsystem.dc_ohms_from_percent` for more details.\n        \"\"\"\n\n        # get relevent Vmp and Imp parameters from CEC parameters\n        if all([elem in self.module_parameters\n                for elem in ['V_mp_ref', 'I_mp_ref']]):\n            vmp_ref = self.module_parameters['V_mp_ref']\n            imp_ref = self.module_parameters['I_mp_ref']\n\n        # get relevant Vmp and Imp parameters from SAPM parameters\n        elif all([elem in self.module_parameters\n                  for elem in ['Vmpo', 'Impo']]):\n            vmp_ref = self.module_parameters['Vmpo']\n            imp_ref = self.module_parameters['Impo']\n\n        # get relevant Vmp and Imp parameters if they are PVsyst-like\n        elif all([elem in self.module_parameters\n                  for elem in ['Vmpp', 'Impp']]):\n            vmp_ref = self.module_parameters['Vmpp']\n            imp_ref = self.module_parameters['Impp']\n\n        # raise error if relevant Vmp and Imp parameters are not found\n        else:\n            raise ValueError('Parameters for Vmp and Imp could not be found '\n                             'in the array module parameters. Module '\n                             'parameters must include one set of '\n                             '{\"V_mp_ref\", \"I_mp_Ref\"}, '\n                             '{\"Vmpo\", \"Impo\"}, or '\n                             '{\"Vmpp\", \"Impp\"}.'\n                             )\n\n        return dc_ohms_from_percent(\n            vmp_ref,\n            imp_ref,\n            self.array_losses_parameters['dc_ohmic_percent'],\n            self.modules_per_string,\n            self.strings)\n", "tokens": ["pvlib", "pvsystem", "py", "array", "def", "dc_ohms_from_percent", "self", "calculates", "the", "equivalent", "resistance", "of", "the", "wires", "using", "py", "func", "pvlib", "pvsystem", "dc_ohms_from_percent", "makes", "use", "of", "array", "module", "parameters", "according", "to", "the", "following", "dc", "models", "cec", "self", "module_parameters", "v_mp_ref", "self", "module_parameters", "i_mp_ref", "sapm", "self", "module_parameters", "vmpo", "self", "module_parameters", "impo", "pvsyst", "like", "or", "other", "self", "module_parameters", "vmpp", "self", "module_parameters", "impp", "other", "array", "parameters", "that", "are", "used", "are", "self", "losses_parameters", "dc_ohmic_percent", "self", "modules_per_string", "and", "self", "strings", "see", "py", "func", "pvlib", "pvsystem", "dc_ohms_from_percent", "for", "more", "details", "get", "relevent", "vmp", "and", "imp", "parameters", "from", "cec", "parameters", "if", "all", "elem", "in", "self", "module_parameters", "for", "elem", "in", "v_mp_ref", "i_mp_ref", "vmp_ref", "self", "module_parameters", "v_mp_ref", "imp_ref", "self", "module_parameters", "i_mp_ref", "get", "relevant", "vmp", "and", "imp", "parameters", "from", "sapm", "parameters", "elif", "all", "elem", "in", "self", "module_parameters", "for", "elem", "in", "vmpo", "impo", "vmp_ref", "self", "module_parameters", "vmpo", "imp_ref", "self", "module_parameters", "impo", "get", "relevant", "vmp", "and", "imp", "parameters", "if", "they", "are", "pvsyst", "like", "elif", "all", "elem", "in", "self", "module_parameters", "for", "elem", "in", "vmpp", "impp", "vmp_ref", "self", "module_parameters", "vmpp", "imp_ref", "self", "module_parameters", "impp", "raise", "error", "if", "relevant", "vmp", "and", "imp", "parameters", "are", "not", "found", "else", "raise", "valueerror", "parameters", "for", "vmp", "and", "imp", "could", "not", "be", "found", "in", "the", "array", "module", "parameters", "module", "parameters", "must", "include", "one", "set", "of", "v_mp_ref", "i_mp_ref", "vmpo", "impo", "or", "vmpp", "impp", "return", "dc_ohms_from_percent", "vmp_ref", "imp_ref", "self", "array_losses_parameters", "dc_ohmic_percent", "self", "modules_per_string", "self", "strings"], "doc_len": 219}
{"doc_id": "pvlib/pvsystem.py::AbstractMount.get_orientation", "file_path": "pvlib/pvsystem.py", "class_name": "AbstractMount", "func_name": "get_orientation", "text": "文件路径: pvlib/pvsystem.py, 类名: AbstractMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        \"\"\"\n        Determine module orientation.\n\n        Parameters\n        ----------\n        solar_zenith : numeric\n            Solar apparent zenith angle [degrees]\n        solar_azimuth : numeric\n            Solar azimuth angle [degrees]\n\n        Returns\n        -------\n        orientation : dict-like\n            A dict-like object with keys `'surface_tilt', 'surface_azimuth'`\n            (typically a dict or pandas.DataFrame)\n        \"\"\"\n", "tokens": ["pvlib", "pvsystem", "py", "abstractmount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "determine", "module", "orientation", "parameters", "solar_zenith", "numeric", "solar", "apparent", "zenith", "angle", "degrees", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "degrees", "returns", "orientation", "dict", "like", "a", "dict", "like", "object", "with", "keys", "surface_tilt", "surface_azimuth", "typically", "a", "dict", "or", "pandas", "dataframe"], "doc_len": 44}
{"doc_id": "pvlib/pvsystem.py::FixedMount.get_orientation", "file_path": "pvlib/pvsystem.py", "class_name": "FixedMount", "func_name": "get_orientation", "text": "文件路径: pvlib/pvsystem.py, 类名: FixedMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        # note -- docstring is automatically inherited from AbstractMount\n        return {\n            'surface_tilt': self.surface_tilt,\n            'surface_azimuth': self.surface_azimuth,\n        }\n", "tokens": ["pvlib", "pvsystem", "py", "fixedmount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "note", "docstring", "is", "automatically", "inherited", "from", "abstractmount", "return", "surface_tilt", "self", "surface_tilt", "surface_azimuth", "self", "surface_azimuth"], "doc_len": 23}
{"doc_id": "pvlib/pvsystem.py::SingleAxisTrackerMount.get_orientation", "file_path": "pvlib/pvsystem.py", "class_name": "SingleAxisTrackerMount", "func_name": "get_orientation", "text": "文件路径: pvlib/pvsystem.py, 类名: SingleAxisTrackerMount\n    def get_orientation(self, solar_zenith, solar_azimuth):\n        # note -- docstring is automatically inherited from AbstractMount\n        from pvlib import tracking  # avoid circular import issue\n        tracking_data = tracking.singleaxis(\n            solar_zenith, solar_azimuth,\n            self.axis_tilt, self.axis_azimuth,\n            self.max_angle, self.backtrack,\n            self.gcr, self.cross_axis_tilt\n        )\n        return tracking_data\n", "tokens": ["pvlib", "pvsystem", "py", "singleaxistrackermount", "def", "get_orientation", "self", "solar_zenith", "solar_azimuth", "note", "docstring", "is", "automatically", "inherited", "from", "abstractmount", "from", "pvlib", "import", "tracking", "avoid", "circular", "import", "issue", "tracking_data", "tracking", "singleaxis", "solar_zenith", "solar_azimuth", "self", "axis_tilt", "self", "axis_azimuth", "self", "max_angle", "self", "backtrack", "self", "gcr", "self", "cross_axis_tilt", "return", "tracking_data"], "doc_len": 43}
{"doc_id": "pvlib/pvsystem.py::calcparams_desoto", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "calcparams_desoto", "text": "文件路径: pvlib/pvsystem.py\ndef calcparams_desoto(effective_irradiance, temp_cell,\n                      alpha_sc, a_ref, I_L_ref, I_o_ref, R_sh_ref, R_s,\n                      EgRef=1.121, dEgdT=-0.0002677,\n                      irrad_ref=1000, temp_ref=25):\n    '''\n    Calculates five parameter values for the single diode equation at\n    effective irradiance and cell temperature using the De Soto et al.\n    model described in [1]_. The five values returned by calcparams_desoto\n    can be used by singlediode to calculate an IV curve.\n\n    Parameters\n    ----------\n    effective_irradiance : numeric\n        The irradiance (W/m2) that is converted to photocurrent.\n\n    temp_cell : numeric\n        The average cell temperature of cells within a module in C.\n\n    alpha_sc : float\n        The short-circuit current temperature coefficient of the\n        module in units of A/C.\n\n    a_ref : float\n        The product of the usual diode ideality factor (n, unitless),\n        number of cells in series (Ns), and cell thermal voltage at reference\n        conditions, in units of V.\n\n    I_L_ref : float\n        The light-generated current (or photocurrent) at reference conditions,\n        in amperes.\n\n    I_o_ref : float\n        The dark or diode reverse saturation current at reference conditions,\n        in amperes.\n\n    R_sh_ref : float\n        The shunt resistance at reference conditions, in ohms.\n\n    R_s : float\n        The series resistance at reference conditions, in ohms.\n\n    EgRef : float\n        The energy bandgap at reference temperature in units of eV.\n        1.121 eV for crystalline silicon. EgRef must be >0.  For parameters\n        from the SAM CEC module database, EgRef=1.121 is implicit for all\n        cell types in the parameter estimation algorithm used by NREL.\n\n    dEgdT : float\n        The temperature dependence of the energy bandgap at reference\n        conditions in units of 1/K. May be either a scalar value\n        (e.g. -0.0002677 as in [1]_) or a DataFrame (this may be useful if\n        dEgdT is a modeled as a function of temperature). For parameters from\n        the SAM CEC module database, dEgdT=-0.0002677 is implicit for all cell\n        types in the parameter estimation algorithm used by NREL.\n\n    irrad_ref : float (optional, default=1000)\n        Reference irradiance in W/m^2.\n\n    temp_ref : float (optional, default=25)\n        Reference cell temperature in C.\n\n    Returns\n    -------\n    Tuple of the following results:\n\n    photocurrent : numeric\n        Light-generated current in amperes\n\n    saturation_current : numeric\n        Diode saturation curent in amperes\n\n    resistance_series : float\n        Series resistance in ohms\n\n    resistance_shunt : numeric\n        Shunt resistance in ohms\n\n    nNsVth : numeric\n        The product of the usual diode ideality factor (n, unitless),\n        number of cells in series (Ns), and cell thermal voltage at\n        specified effective irradiance and cell temperature.\n\n    References\n    ----------\n    .. [1] W. De Soto et al., \"Improvement and validation of a model for\n       photovoltaic array performance\", Solar Energy, vol 80, pp. 78-88,\n       2006.\n\n    .. [2] System Advisor Model web page. https://sam.nrel.gov.\n\n    .. [3] A. Dobos, \"An Improved Coefficient Calculator for the California\n       Energy Commission 6 Parameter Photovoltaic Module Model\", Journal of\n       Solar Energy Engineering, vol 134, 2012.\n\n    .. [4] O. Madelung, \"Semiconductors: Data Handbook, 3rd ed.\" ISBN\n       3-540-40488-0\n\n    See Also\n    --------\n    singlediode\n    retrieve_sam\n\n    Notes\n    -----\n    If the reference parameters in the ModuleParameters struct are read\n    from a database or library of parameters (e.g. System Advisor\n    Model), it is important to use the same EgRef and dEgdT values that\n    were used to generate the reference parameters, regardless of the\n    actual bandgap characteristics of the semiconductor. For example, in\n    the case of the System Advisor Model library, created as described\n    in [3], EgRef and dEgdT for all modules were 1.121 and -0.0002677,\n    respectively.\n\n    This table of reference bandgap energies (EgRef), bandgap energy\n    temperature dependence (dEgdT), and \"typical\" airmass response (M)\n    is provided purely as reference to those who may generate their own\n    reference module parameters (a_ref, IL_ref, I0_ref, etc.) based upon\n    the various PV semiconductors. Again, we stress the importance of\n    using identical EgRef and dEgdT when generation reference parameters\n    and modifying the reference parameters (for irradiance, temperature,\n    and airmass) per DeSoto's equations.\n\n     Crystalline Silicon (Si):\n         * EgRef = 1.121\n         * dEgdT = -0.0002677\n\n         >>> M = np.polyval([-1.26E-4, 2.816E-3, -0.024459, 0.086257, 0.9181],\n         ...                AMa) # doctest: +SKIP\n\n         Source: [1]\n\n     Cadmium Telluride (CdTe):\n         * EgRef = 1.475\n         * dEgdT = -0.0003\n\n         >>> M = np.polyval([-2.46E-5, 9.607E-4, -0.0134, 0.0716, 0.9196],\n         ...                AMa) # doctest: +SKIP\n\n         Source: [4]\n\n     Copper Indium diSelenide (CIS):\n         * EgRef = 1.010\n         * dEgdT = -0.00011\n\n         >>> M = np.polyval([-3.74E-5, 0.00125, -0.01462, 0.0718, 0.9210],\n         ...                AMa) # doctest: +SKIP\n\n         Source: [4]\n\n     Copper Indium Gallium diSelenide (CIGS):\n         * EgRef = 1.15\n         * dEgdT = ????\n\n         >>> M = np.polyval([-9.07E-5, 0.0022, -0.0202, 0.0652, 0.9417],\n         ...                AMa) # doctest: +SKIP\n\n         Source: Wikipedia\n\n     Gallium Arsenide (GaAs):\n         * EgRef = 1.424\n         * dEgdT = -0.000433\n         * M = unknown\n\n         Source: [4]\n    '''\n\n    # Boltzmann constant in eV/K\n    k = 8.617332478e-05\n\n    # reference temperature\n    Tref_K = temp_ref + 273.15\n    Tcell_K = temp_cell + 273.15\n\n    E_g = EgRef * (1 + dEgdT*(Tcell_K - Tref_K))\n\n    nNsVth = a_ref * (Tcell_K / Tref_K)\n\n    # In the equation for IL, the single factor effective_irradiance is\n    # used, in place of the product S*M in [1]. effective_irradiance is\n    # equivalent to the product of S (irradiance reaching a module's cells) *\n    # M (spectral adjustment factor) as described in [1].\n    IL = effective_irradiance / irrad_ref * \\\n        (I_L_ref + alpha_sc * (Tcell_K - Tref_K))\n    I0 = (I_o_ref * ((Tcell_K / Tref_K) ** 3) *\n          (np.exp(EgRef / (k*(Tref_K)) - (E_g / (k*(Tcell_K))))))\n    # Note that the equation for Rsh differs from [1]. In [1] Rsh is given as\n    # Rsh = Rsh_ref * (S_ref / S) where S is broadband irradiance reaching\n    # the module's cells. If desired this model behavior can be duplicated\n    # by applying reflection and soiling losses to broadband plane of array\n    # irradiance and not applying a spectral loss modifier, i.e.,\n    # spectral_modifier = 1.0.\n    # use errstate to silence divide by warning\n    with np.errstate(divide='ignore'):\n        Rsh = R_sh_ref * (irrad_ref / effective_irradiance)\n    Rs = R_s\n\n    return IL, I0, Rs, Rsh, nNsVth\n", "tokens": ["pvlib", "pvsystem", "py", "def", "calcparams_desoto", "effective_irradiance", "temp_cell", "alpha_sc", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "egref", "1", "121", "degdt", "0", "0002677", "irrad_ref", "1000", "temp_ref", "25", "calculates", "five", "parameter", "values", "for", "the", "single", "diode", "equation", "at", "effective", "irradiance", "and", "cell", "temperature", "using", "the", "de", "soto", "et", "al", "model", "described", "in", "1", "_", "the", "five", "values", "returned", "by", "calcparams_desoto", "can", "be", "used", "by", "singlediode", "to", "calculate", "an", "iv", "curve", "parameters", "effective_irradiance", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "numeric", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "alpha_sc", "float", "the", "short", "circuit", "current", "temperature", "coefficient", "of", "the", "module", "in", "units", "of", "a", "c", "a_ref", "float", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "reference", "conditions", "in", "units", "of", "v", "i_l_ref", "float", "the", "light", "generated", "current", "or", "photocurrent", "at", "reference", "conditions", "in", "amperes", "i_o_ref", "float", "the", "dark", "or", "diode", "reverse", "saturation", "current", "at", "reference", "conditions", "in", "amperes", "r_sh_ref", "float", "the", "shunt", "resistance", "at", "reference", "conditions", "in", "ohms", "r_s", "float", "the", "series", "resistance", "at", "reference", "conditions", "in", "ohms", "egref", "float", "the", "energy", "bandgap", "at", "reference", "temperature", "in", "units", "of", "ev", "1", "121", "ev", "for", "crystalline", "silicon", "egref", "must", "be", "0", "for", "parameters", "from", "the", "sam", "cec", "module", "database", "egref", "1", "121", "is", "implicit", "for", "all", "cell", "types", "in", "the", "parameter", "estimation", "algorithm", "used", "by", "nrel", "degdt", "float", "the", "temperature", "dependence", "of", "the", "energy", "bandgap", "at", "reference", "conditions", "in", "units", "of", "1", "k", "may", "be", "either", "a", "scalar", "value", "e", "g", "0", "0002677", "as", "in", "1", "_", "or", "a", "dataframe", "this", "may", "be", "useful", "if", "degdt", "is", "a", "modeled", "as", "a", "function", "of", "temperature", "for", "parameters", "from", "the", "sam", "cec", "module", "database", "degdt", "0", "0002677", "is", "implicit", "for", "all", "cell", "types", "in", "the", "parameter", "estimation", "algorithm", "used", "by", "nrel", "irrad_ref", "float", "optional", "default", "1000", "reference", "irradiance", "in", "w", "m", "2", "temp_ref", "float", "optional", "default", "25", "reference", "cell", "temperature", "in", "c", "returns", "tuple", "of", "the", "following", "results", "photocurrent", "numeric", "light", "generated", "current", "in", "amperes", "saturation_current", "numeric", "diode", "saturation", "curent", "in", "amperes", "resistance_series", "float", "series", "resistance", "in", "ohms", "resistance_shunt", "numeric", "shunt", "resistance", "in", "ohms", "nnsvth", "numeric", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "specified", "effective", "irradiance", "and", "cell", "temperature", "references", "1", "w", "de", "soto", "et", "al", "improvement", "and", "validation", "of", "a", "model", "for", "photovoltaic", "array", "performance", "solar", "energy", "vol", "80", "pp", "78", "88", "2006", "2", "system", "advisor", "model", "web", "page", "https", "sam", "nrel", "gov", "3", "a", "dobos", "an", "improved", "coefficient", "calculator", "for", "the", "california", "energy", "commission", "6", "parameter", "photovoltaic", "module", "model", "journal", "of", "solar", "energy", "engineering", "vol", "134", "2012", "4", "o", "madelung", "semiconductors", "data", "handbook", "3rd", "ed", "isbn", "3", "540", "40488", "0", "see", "also", "singlediode", "retrieve_sam", "notes", "if", "the", "reference", "parameters", "in", "the", "moduleparameters", "struct", "are", "read", "from", "a", "database", "or", "library", "of", "parameters", "e", "g", "system", "advisor", "model", "it", "is", "important", "to", "use", "the", "same", "egref", "and", "degdt", "values", "that", "were", "used", "to", "generate", "the", "reference", "parameters", "regardless", "of", "the", "actual", "bandgap", "characteristics", "of", "the", "semiconductor", "for", "example", "in", "the", "case", "of", "the", "system", "advisor", "model", "library", "created", "as", "described", "in", "3", "egref", "and", "degdt", "for", "all", "modules", "were", "1", "121", "and", "0", "0002677", "respectively", "this", "table", "of", "reference", "bandgap", "energies", "egref", "bandgap", "energy", "temperature", "dependence", "degdt", "and", "typical", "airmass", "response", "m", "is", "provided", "purely", "as", "reference", "to", "those", "who", "may", "generate", "their", "own", "reference", "module", "parameters", "a_ref", "il_ref", "i0_ref", "etc", "based", "upon", "the", "various", "pv", "semiconductors", "again", "we", "stress", "the", "importance", "of", "using", "identical", "egref", "and", "degdt", "when", "generation", "reference", "parameters", "and", "modifying", "the", "reference", "parameters", "for", "irradiance", "temperature", "and", "airmass", "per", "desoto", "s", "equations", "crystalline", "silicon", "si", "egref", "1", "121", "degdt", "0", "0002677", "m", "np", "polyval", "1", "26e", "4", "2", "816e", "3", "0", "024459", "0", "086257", "0", "9181", "ama", "doctest", "skip", "source", "1", "cadmium", "telluride", "cdte", "egref", "1", "475", "degdt", "0", "0003", "m", "np", "polyval", "2", "46e", "5", "9", "607e", "4", "0", "0134", "0", "0716", "0", "9196", "ama", "doctest", "skip", "source", "4", "copper", "indium", "diselenide", "cis", "egref", "1", "010", "degdt", "0", "00011", "m", "np", "polyval", "3", "74e", "5", "0", "00125", "0", "01462", "0", "0718", "0", "9210", "ama", "doctest", "skip", "source", "4", "copper", "indium", "gallium", "diselenide", "cigs", "egref", "1", "15", "degdt", "m", "np", "polyval", "9", "07e", "5", "0", "0022", "0", "0202", "0", "0652", "0", "9417", "ama", "doctest", "skip", "source", "wikipedia", "gallium", "arsenide", "gaas", "egref", "1", "424", "degdt", "0", "000433", "m", "unknown", "source", "4", "boltzmann", "constant", "in", "ev", "k", "k", "8", "617332478e", "05", "reference", "temperature", "tref_k", "temp_ref", "273", "15", "tcell_k", "temp_cell", "273", "15", "e_g", "egref", "1", "degdt", "tcell_k", "tref_k", "nnsvth", "a_ref", "tcell_k", "tref_k", "in", "the", "equation", "for", "il", "the", "single", "factor", "effective_irradiance", "is", "used", "in", "place", "of", "the", "product", "s", "m", "in", "1", "effective_irradiance", "is", "equivalent", "to", "the", "product", "of", "s", "irradiance", "reaching", "a", "module", "s", "cells", "m", "spectral", "adjustment", "factor", "as", "described", "in", "1", "il", "effective_irradiance", "irrad_ref", "i_l_ref", "alpha_sc", "tcell_k", "tref_k", "i0", "i_o_ref", "tcell_k", "tref_k", "3", "np", "exp", "egref", "k", "tref_k", "e_g", "k", "tcell_k", "note", "that", "the", "equation", "for", "rsh", "differs", "from", "1", "in", "1", "rsh", "is", "given", "as", "rsh", "rsh_ref", "s_ref", "s", "where", "s", "is", "broadband", "irradiance", "reaching", "the", "module", "s", "cells", "if", "desired", "this", "model", "behavior", "can", "be", "duplicated", "by", "applying", "reflection", "and", "soiling", "losses", "to", "broadband", "plane", "of", "array", "irradiance", "and", "not", "applying", "a", "spectral", "loss", "modifier", "i", "e", "spectral_modifier", "1", "0", "use", "errstate", "to", "silence", "divide", "by", "warning", "with", "np", "errstate", "divide", "ignore", "rsh", "r_sh_ref", "irrad_ref", "effective_irradiance", "rs", "r_s", "return", "il", "i0", "rs", "rsh", "nnsvth"], "doc_len": 916}
{"doc_id": "pvlib/pvsystem.py::calcparams_cec", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "calcparams_cec", "text": "文件路径: pvlib/pvsystem.py\ndef calcparams_cec(effective_irradiance, temp_cell,\n                   alpha_sc, a_ref, I_L_ref, I_o_ref, R_sh_ref, R_s,\n                   Adjust, EgRef=1.121, dEgdT=-0.0002677,\n                   irrad_ref=1000, temp_ref=25):\n    '''\n    Calculates five parameter values for the single diode equation at\n    effective irradiance and cell temperature using the CEC\n    model. The CEC model [1]_ differs from the De soto et al.\n    model [3]_ by the parameter Adjust. The five values returned by\n    calcparams_cec can be used by singlediode to calculate an IV curve.\n\n    Parameters\n    ----------\n    effective_irradiance : numeric\n        The irradiance (W/m2) that is converted to photocurrent.\n\n    temp_cell : numeric\n        The average cell temperature of cells within a module in C.\n\n    alpha_sc : float\n        The short-circuit current temperature coefficient of the\n        module in units of A/C.\n\n    a_ref : float\n        The product of the usual diode ideality factor (n, unitless),\n        number of cells in series (Ns), and cell thermal voltage at reference\n        conditions, in units of V.\n\n    I_L_ref : float\n        The light-generated current (or photocurrent) at reference conditions,\n        in amperes.\n\n    I_o_ref : float\n        The dark or diode reverse saturation current at reference conditions,\n        in amperes.\n\n    R_sh_ref : float\n        The shunt resistance at reference conditions, in ohms.\n\n    R_s : float\n        The series resistance at reference conditions, in ohms.\n\n    Adjust : float\n        The adjustment to the temperature coefficient for short circuit\n        current, in percent\n\n    EgRef : float\n        The energy bandgap at reference temperature in units of eV.\n        1.121 eV for crystalline silicon. EgRef must be >0.  For parameters\n        from the SAM CEC module database, EgRef=1.121 is implicit for all\n        cell types in the parameter estimation algorithm used by NREL.\n\n    dEgdT : float\n        The temperature dependence of the energy bandgap at reference\n        conditions in units of 1/K. May be either a scalar value\n        (e.g. -0.0002677 as in [3]) or a DataFrame (this may be useful if\n        dEgdT is a modeled as a function of temperature). For parameters from\n        the SAM CEC module database, dEgdT=-0.0002677 is implicit for all cell\n        types in the parameter estimation algorithm used by NREL.\n\n    irrad_ref : float (optional, default=1000)\n        Reference irradiance in W/m^2.\n\n    temp_ref : float (optional, default=25)\n        Reference cell temperature in C.\n\n    Returns\n    -------\n    Tuple of the following results:\n\n    photocurrent : numeric\n        Light-generated current in amperes\n\n    saturation_current : numeric\n        Diode saturation curent in amperes\n\n    resistance_series : float\n        Series resistance in ohms\n\n    resistance_shunt : numeric\n        Shunt resistance in ohms\n\n    nNsVth : numeric\n        The product of the usual diode ideality factor (n, unitless),\n        number of cells in series (Ns), and cell thermal voltage at\n        specified effective irradiance and cell temperature.\n\n    References\n    ----------\n    .. [1] A. Dobos, \"An Improved Coefficient Calculator for the California\n       Energy Commission 6 Parameter Photovoltaic Module Model\", Journal of\n       Solar Energy Engineering, vol 134, 2012.\n\n    .. [2] System Advisor Model web page. https://sam.nrel.gov.\n\n    .. [3] W. De Soto et al., \"Improvement and validation of a model for\n       photovoltaic array performance\", Solar Energy, vol 80, pp. 78-88,\n       2006.\n\n    See Also\n    --------\n    calcparams_desoto\n    singlediode\n    retrieve_sam\n\n    '''\n\n    # pass adjusted temperature coefficient to desoto\n    return calcparams_desoto(effective_irradiance, temp_cell,\n                             alpha_sc*(1.0 - Adjust/100),\n                             a_ref, I_L_ref, I_o_ref,\n                             R_sh_ref, R_s,\n                             EgRef=EgRef, dEgdT=dEgdT,\n                             irrad_ref=irrad_ref, temp_ref=temp_ref)\n", "tokens": ["pvlib", "pvsystem", "py", "def", "calcparams_cec", "effective_irradiance", "temp_cell", "alpha_sc", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "adjust", "egref", "1", "121", "degdt", "0", "0002677", "irrad_ref", "1000", "temp_ref", "25", "calculates", "five", "parameter", "values", "for", "the", "single", "diode", "equation", "at", "effective", "irradiance", "and", "cell", "temperature", "using", "the", "cec", "model", "the", "cec", "model", "1", "_", "differs", "from", "the", "de", "soto", "et", "al", "model", "3", "_", "by", "the", "parameter", "adjust", "the", "five", "values", "returned", "by", "calcparams_cec", "can", "be", "used", "by", "singlediode", "to", "calculate", "an", "iv", "curve", "parameters", "effective_irradiance", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "numeric", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "alpha_sc", "float", "the", "short", "circuit", "current", "temperature", "coefficient", "of", "the", "module", "in", "units", "of", "a", "c", "a_ref", "float", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "reference", "conditions", "in", "units", "of", "v", "i_l_ref", "float", "the", "light", "generated", "current", "or", "photocurrent", "at", "reference", "conditions", "in", "amperes", "i_o_ref", "float", "the", "dark", "or", "diode", "reverse", "saturation", "current", "at", "reference", "conditions", "in", "amperes", "r_sh_ref", "float", "the", "shunt", "resistance", "at", "reference", "conditions", "in", "ohms", "r_s", "float", "the", "series", "resistance", "at", "reference", "conditions", "in", "ohms", "adjust", "float", "the", "adjustment", "to", "the", "temperature", "coefficient", "for", "short", "circuit", "current", "in", "percent", "egref", "float", "the", "energy", "bandgap", "at", "reference", "temperature", "in", "units", "of", "ev", "1", "121", "ev", "for", "crystalline", "silicon", "egref", "must", "be", "0", "for", "parameters", "from", "the", "sam", "cec", "module", "database", "egref", "1", "121", "is", "implicit", "for", "all", "cell", "types", "in", "the", "parameter", "estimation", "algorithm", "used", "by", "nrel", "degdt", "float", "the", "temperature", "dependence", "of", "the", "energy", "bandgap", "at", "reference", "conditions", "in", "units", "of", "1", "k", "may", "be", "either", "a", "scalar", "value", "e", "g", "0", "0002677", "as", "in", "3", "or", "a", "dataframe", "this", "may", "be", "useful", "if", "degdt", "is", "a", "modeled", "as", "a", "function", "of", "temperature", "for", "parameters", "from", "the", "sam", "cec", "module", "database", "degdt", "0", "0002677", "is", "implicit", "for", "all", "cell", "types", "in", "the", "parameter", "estimation", "algorithm", "used", "by", "nrel", "irrad_ref", "float", "optional", "default", "1000", "reference", "irradiance", "in", "w", "m", "2", "temp_ref", "float", "optional", "default", "25", "reference", "cell", "temperature", "in", "c", "returns", "tuple", "of", "the", "following", "results", "photocurrent", "numeric", "light", "generated", "current", "in", "amperes", "saturation_current", "numeric", "diode", "saturation", "curent", "in", "amperes", "resistance_series", "float", "series", "resistance", "in", "ohms", "resistance_shunt", "numeric", "shunt", "resistance", "in", "ohms", "nnsvth", "numeric", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "specified", "effective", "irradiance", "and", "cell", "temperature", "references", "1", "a", "dobos", "an", "improved", "coefficient", "calculator", "for", "the", "california", "energy", "commission", "6", "parameter", "photovoltaic", "module", "model", "journal", "of", "solar", "energy", "engineering", "vol", "134", "2012", "2", "system", "advisor", "model", "web", "page", "https", "sam", "nrel", "gov", "3", "w", "de", "soto", "et", "al", "improvement", "and", "validation", "of", "a", "model", "for", "photovoltaic", "array", "performance", "solar", "energy", "vol", "80", "pp", "78", "88", "2006", "see", "also", "calcparams_desoto", "singlediode", "retrieve_sam", "pass", "adjusted", "temperature", "coefficient", "to", "desoto", "return", "calcparams_desoto", "effective_irradiance", "temp_cell", "alpha_sc", "1", "0", "adjust", "100", "a_ref", "i_l_ref", "i_o_ref", "r_sh_ref", "r_s", "egref", "egref", "degdt", "degdt", "irrad_ref", "irrad_ref", "temp_ref", "temp_ref"], "doc_len": 503}
{"doc_id": "pvlib/pvsystem.py::calcparams_pvsyst", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "calcparams_pvsyst", "text": "文件路径: pvlib/pvsystem.py\ndef calcparams_pvsyst(effective_irradiance, temp_cell,\n                      alpha_sc, gamma_ref, mu_gamma,\n                      I_L_ref, I_o_ref,\n                      R_sh_ref, R_sh_0, R_s,\n                      cells_in_series,\n                      R_sh_exp=5.5,\n                      EgRef=1.121,\n                      irrad_ref=1000, temp_ref=25):\n    '''\n    Calculates five parameter values for the single diode equation at\n    effective irradiance and cell temperature using the PVsyst v6\n    model.  The PVsyst v6 model is described in [1]_, [2]_, [3]_.\n    The five values returned by calcparams_pvsyst can be used by singlediode\n    to calculate an IV curve.\n\n    Parameters\n    ----------\n    effective_irradiance : numeric\n        The irradiance (W/m2) that is converted to photocurrent.\n\n    temp_cell : numeric\n        The average cell temperature of cells within a module in C.\n\n    alpha_sc : float\n        The short-circuit current temperature coefficient of the\n        module in units of A/C.\n\n    gamma_ref : float\n        The diode ideality factor\n\n    mu_gamma : float\n        The temperature coefficient for the diode ideality factor, 1/K\n\n    I_L_ref : float\n        The light-generated current (or photocurrent) at reference conditions,\n        in amperes.\n\n    I_o_ref : float\n        The dark or diode reverse saturation current at reference conditions,\n        in amperes.\n\n    R_sh_ref : float\n        The shunt resistance at reference conditions, in ohms.\n\n    R_sh_0 : float\n        The shunt resistance at zero irradiance conditions, in ohms.\n\n    R_s : float\n        The series resistance at reference conditions, in ohms.\n\n    cells_in_series : integer\n        The number of cells connected in series.\n\n    R_sh_exp : float\n        The exponent in the equation for shunt resistance, unitless. Defaults\n        to 5.5.\n\n    EgRef : float\n        The energy bandgap at reference temperature in units of eV.\n        1.121 eV for crystalline silicon. EgRef must be >0.\n\n    irrad_ref : float (optional, default=1000)\n        Reference irradiance in W/m^2.\n\n    temp_ref : float (optional, default=25)\n        Reference cell temperature in C.\n\n    Returns\n    -------\n    Tuple of the following results:\n\n    photocurrent : numeric\n        Light-generated current in amperes\n\n    saturation_current : numeric\n        Diode saturation current in amperes\n\n    resistance_series : float\n        Series resistance in ohms\n\n    resistance_shunt : numeric\n        Shunt resistance in ohms\n\n    nNsVth : numeric\n        The product of the usual diode ideality factor (n, unitless),\n        number of cells in series (Ns), and cell thermal voltage at\n        specified effective irradiance and cell temperature.\n\n    References\n    ----------\n    .. [1] K. Sauer, T. Roessler, C. W. Hansen, Modeling the Irradiance and\n       Temperature Dependence of Photovoltaic Modules in PVsyst,\n       IEEE Journal of Photovoltaics v5(1), January 2015.\n\n    .. [2] A. Mermoud, PV modules modelling, Presentation at the 2nd PV\n       Performance Modeling Workshop, Santa Clara, CA, May 2013\n\n    .. [3] A. Mermoud, T. Lejeune, Performance Assessment of a Simulation Model\n       for PV modules of any available technology, 25th European Photovoltaic\n       Solar Energy Conference, Valencia, Spain, Sept. 2010\n\n    See Also\n    --------\n    calcparams_desoto\n    singlediode\n\n    '''\n\n    # Boltzmann constant in J/K\n    k = 1.38064852e-23\n\n    # elementary charge in coulomb\n    q = 1.6021766e-19\n\n    # reference temperature\n    Tref_K = temp_ref + 273.15\n    Tcell_K = temp_cell + 273.15\n\n    gamma = gamma_ref + mu_gamma * (Tcell_K - Tref_K)\n    nNsVth = gamma * k / q * cells_in_series * Tcell_K\n\n    IL = effective_irradiance / irrad_ref * \\\n        (I_L_ref + alpha_sc * (Tcell_K - Tref_K))\n\n    I0 = I_o_ref * ((Tcell_K / Tref_K) ** 3) * \\\n        (np.exp((q * EgRef) / (k * gamma) * (1 / Tref_K - 1 / Tcell_K)))\n\n    Rsh_tmp = \\\n        (R_sh_ref - R_sh_0 * np.exp(-R_sh_exp)) / (1.0 - np.exp(-R_sh_exp))\n    Rsh_base = np.maximum(0.0, Rsh_tmp)\n\n    Rsh = Rsh_base + (R_sh_0 - Rsh_base) * \\\n        np.exp(-R_sh_exp * effective_irradiance / irrad_ref)\n\n    Rs = R_s\n\n    return IL, I0, Rs, Rsh, nNsVth\n", "tokens": ["pvlib", "pvsystem", "py", "def", "calcparams_pvsyst", "effective_irradiance", "temp_cell", "alpha_sc", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_s", "cells_in_series", "r_sh_exp", "5", "5", "egref", "1", "121", "irrad_ref", "1000", "temp_ref", "25", "calculates", "five", "parameter", "values", "for", "the", "single", "diode", "equation", "at", "effective", "irradiance", "and", "cell", "temperature", "using", "the", "pvsyst", "v6", "model", "the", "pvsyst", "v6", "model", "is", "described", "in", "1", "_", "2", "_", "3", "_", "the", "five", "values", "returned", "by", "calcparams_pvsyst", "can", "be", "used", "by", "singlediode", "to", "calculate", "an", "iv", "curve", "parameters", "effective_irradiance", "numeric", "the", "irradiance", "w", "m2", "that", "is", "converted", "to", "photocurrent", "temp_cell", "numeric", "the", "average", "cell", "temperature", "of", "cells", "within", "a", "module", "in", "c", "alpha_sc", "float", "the", "short", "circuit", "current", "temperature", "coefficient", "of", "the", "module", "in", "units", "of", "a", "c", "gamma_ref", "float", "the", "diode", "ideality", "factor", "mu_gamma", "float", "the", "temperature", "coefficient", "for", "the", "diode", "ideality", "factor", "1", "k", "i_l_ref", "float", "the", "light", "generated", "current", "or", "photocurrent", "at", "reference", "conditions", "in", "amperes", "i_o_ref", "float", "the", "dark", "or", "diode", "reverse", "saturation", "current", "at", "reference", "conditions", "in", "amperes", "r_sh_ref", "float", "the", "shunt", "resistance", "at", "reference", "conditions", "in", "ohms", "r_sh_0", "float", "the", "shunt", "resistance", "at", "zero", "irradiance", "conditions", "in", "ohms", "r_s", "float", "the", "series", "resistance", "at", "reference", "conditions", "in", "ohms", "cells_in_series", "integer", "the", "number", "of", "cells", "connected", "in", "series", "r_sh_exp", "float", "the", "exponent", "in", "the", "equation", "for", "shunt", "resistance", "unitless", "defaults", "to", "5", "5", "egref", "float", "the", "energy", "bandgap", "at", "reference", "temperature", "in", "units", "of", "ev", "1", "121", "ev", "for", "crystalline", "silicon", "egref", "must", "be", "0", "irrad_ref", "float", "optional", "default", "1000", "reference", "irradiance", "in", "w", "m", "2", "temp_ref", "float", "optional", "default", "25", "reference", "cell", "temperature", "in", "c", "returns", "tuple", "of", "the", "following", "results", "photocurrent", "numeric", "light", "generated", "current", "in", "amperes", "saturation_current", "numeric", "diode", "saturation", "current", "in", "amperes", "resistance_series", "float", "series", "resistance", "in", "ohms", "resistance_shunt", "numeric", "shunt", "resistance", "in", "ohms", "nnsvth", "numeric", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "specified", "effective", "irradiance", "and", "cell", "temperature", "references", "1", "k", "sauer", "t", "roessler", "c", "w", "hansen", "modeling", "the", "irradiance", "and", "temperature", "dependence", "of", "photovoltaic", "modules", "in", "pvsyst", "ieee", "journal", "of", "photovoltaics", "v5", "1", "january", "2015", "2", "a", "mermoud", "pv", "modules", "modelling", "presentation", "at", "the", "2nd", "pv", "performance", "modeling", "workshop", "santa", "clara", "ca", "may", "2013", "3", "a", "mermoud", "t", "lejeune", "performance", "assessment", "of", "a", "simulation", "model", "for", "pv", "modules", "of", "any", "available", "technology", "25th", "european", "photovoltaic", "solar", "energy", "conference", "valencia", "spain", "sept", "2010", "see", "also", "calcparams_desoto", "singlediode", "boltzmann", "constant", "in", "j", "k", "k", "1", "38064852e", "23", "elementary", "charge", "in", "coulomb", "q", "1", "6021766e", "19", "reference", "temperature", "tref_k", "temp_ref", "273", "15", "tcell_k", "temp_cell", "273", "15", "gamma", "gamma_ref", "mu_gamma", "tcell_k", "tref_k", "nnsvth", "gamma", "k", "q", "cells_in_series", "tcell_k", "il", "effective_irradiance", "irrad_ref", "i_l_ref", "alpha_sc", "tcell_k", "tref_k", "i0", "i_o_ref", "tcell_k", "tref_k", "3", "np", "exp", "q", "egref", "k", "gamma", "1", "tref_k", "1", "tcell_k", "rsh_tmp", "r_sh_ref", "r_sh_0", "np", "exp", "r_sh_exp", "1", "0", "np", "exp", "r_sh_exp", "rsh_base", "np", "maximum", "0", "0", "rsh_tmp", "rsh", "rsh_base", "r_sh_0", "rsh_base", "np", "exp", "r_sh_exp", "effective_irradiance", "irrad_ref", "rs", "r_s", "return", "il", "i0", "rs", "rsh", "nnsvth"], "doc_len": 493}
{"doc_id": "pvlib/pvsystem.py::retrieve_sam", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "retrieve_sam", "text": "文件路径: pvlib/pvsystem.py\ndef retrieve_sam(name=None, path=None):\n    '''\n    Retrieve latest module and inverter info from a local file or the\n    SAM website.\n\n    This function will retrieve either:\n\n        * CEC module database\n        * Sandia Module database\n        * CEC Inverter database\n        * Anton Driesse Inverter database\n\n    and return it as a pandas DataFrame.\n\n    Parameters\n    ----------\n    name : None or string, default None\n        Name can be one of:\n\n        * 'CECMod' - returns the CEC module database\n        * 'CECInverter' - returns the CEC Inverter database\n        * 'SandiaInverter' - returns the CEC Inverter database\n          (CEC is only current inverter db available; tag kept for\n          backwards compatibility)\n        * 'SandiaMod' - returns the Sandia Module database\n        * 'ADRInverter' - returns the ADR Inverter database\n\n    path : None or string, default None\n        Path to the SAM file. May also be a URL.\n\n    Returns\n    -------\n    samfile : DataFrame\n        A DataFrame containing all the elements of the desired database.\n        Each column represents a module or inverter, and a specific\n        dataset can be retrieved by the command\n\n    Raises\n    ------\n    ValueError\n        If no name or path is provided.\n\n    Notes\n    -----\n    Files available at\n        https://github.com/NREL/SAM/tree/develop/deploy/libraries\n    Documentation for module and inverter data sets:\n        https://sam.nrel.gov/photovoltaic/pv-sub-page-2.html\n\n    Examples\n    --------\n\n    >>> from pvlib import pvsystem\n    >>> invdb = pvsystem.retrieve_sam('CECInverter')\n    >>> inverter = invdb.AE_Solar_Energy__AE6_0__277V__277V__CEC_2012_\n    >>> inverter\n    Vac           277.000000\n    Paco         6000.000000\n    Pdco         6165.670000\n    Vdco          361.123000\n    Pso            36.792300\n    C0             -0.000002\n    C1             -0.000047\n    C2             -0.001861\n    C3              0.000721\n    Pnt             0.070000\n    Vdcmax        600.000000\n    Idcmax         32.000000\n    Mppt_low      200.000000\n    Mppt_high     500.000000\n    Name: AE_Solar_Energy__AE6_0__277V__277V__CEC_2012_, dtype: float64\n    '''\n\n    if name is not None:\n        name = name.lower()\n        data_path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), 'data')\n        if name == 'cecmod':\n            csvdata = os.path.join(\n                data_path, 'sam-library-cec-modules-2019-03-05.csv')\n        elif name == 'sandiamod':\n            csvdata = os.path.join(\n                data_path, 'sam-library-sandia-modules-2015-6-30.csv')\n        elif name == 'adrinverter':\n            csvdata = os.path.join(data_path, 'adr-library-2013-10-01.csv')\n        elif name in ['cecinverter', 'sandiainverter']:\n            # Allowing either, to provide for old code,\n            # while aligning with current expectations\n            csvdata = os.path.join(\n                data_path, 'sam-library-cec-inverters-2019-03-05.csv')\n        else:\n            raise ValueError(f'invalid name {name}')\n    elif path is not None:\n        if path.startswith('http'):\n            response = urlopen(path)\n            csvdata = io.StringIO(response.read().decode(errors='ignore'))\n        else:\n            csvdata = path\n    elif name is None and path is None:\n        raise ValueError(\"A name or path must be provided!\")\n\n    return _parse_raw_sam_df(csvdata)\n", "tokens": ["pvlib", "pvsystem", "py", "def", "retrieve_sam", "name", "none", "path", "none", "retrieve", "latest", "module", "and", "inverter", "info", "from", "a", "local", "file", "or", "the", "sam", "website", "this", "function", "will", "retrieve", "either", "cec", "module", "database", "sandia", "module", "database", "cec", "inverter", "database", "anton", "driesse", "inverter", "database", "and", "return", "it", "as", "a", "pandas", "dataframe", "parameters", "name", "none", "or", "string", "default", "none", "name", "can", "be", "one", "of", "cecmod", "returns", "the", "cec", "module", "database", "cecinverter", "returns", "the", "cec", "inverter", "database", "sandiainverter", "returns", "the", "cec", "inverter", "database", "cec", "is", "only", "current", "inverter", "db", "available", "tag", "kept", "for", "backwards", "compatibility", "sandiamod", "returns", "the", "sandia", "module", "database", "adrinverter", "returns", "the", "adr", "inverter", "database", "path", "none", "or", "string", "default", "none", "path", "to", "the", "sam", "file", "may", "also", "be", "a", "url", "returns", "samfile", "dataframe", "a", "dataframe", "containing", "all", "the", "elements", "of", "the", "desired", "database", "each", "column", "represents", "a", "module", "or", "inverter", "and", "a", "specific", "dataset", "can", "be", "retrieved", "by", "the", "command", "raises", "valueerror", "if", "no", "name", "or", "path", "is", "provided", "notes", "files", "available", "at", "https", "github", "com", "nrel", "sam", "tree", "develop", "deploy", "libraries", "documentation", "for", "module", "and", "inverter", "data", "sets", "https", "sam", "nrel", "gov", "photovoltaic", "pv", "sub", "page", "2", "html", "examples", "from", "pvlib", "import", "pvsystem", "invdb", "pvsystem", "retrieve_sam", "cecinverter", "inverter", "invdb", "ae_solar_energy__ae6_0__277v__277v__cec_2012_", "inverter", "vac", "277", "000000", "paco", "6000", "000000", "pdco", "6165", "670000", "vdco", "361", "123000", "pso", "36", "792300", "c0", "0", "000002", "c1", "0", "000047", "c2", "0", "001861", "c3", "0", "000721", "pnt", "0", "070000", "vdcmax", "600", "000000", "idcmax", "32", "000000", "mppt_low", "200", "000000", "mppt_high", "500", "000000", "name", "ae_solar_energy__ae6_0__277v__277v__cec_2012_", "dtype", "float64", "if", "name", "is", "not", "none", "name", "name", "lower", "data_path", "os", "path", "join", "os", "path", "dirname", "os", "path", "abspath", "__file__", "data", "if", "name", "cecmod", "csvdata", "os", "path", "join", "data_path", "sam", "library", "cec", "modules", "2019", "03", "05", "csv", "elif", "name", "sandiamod", "csvdata", "os", "path", "join", "data_path", "sam", "library", "sandia", "modules", "2015", "6", "30", "csv", "elif", "name", "adrinverter", "csvdata", "os", "path", "join", "data_path", "adr", "library", "2013", "10", "01", "csv", "elif", "name", "in", "cecinverter", "sandiainverter", "allowing", "either", "to", "provide", "for", "old", "code", "while", "aligning", "with", "current", "expectations", "csvdata", "os", "path", "join", "data_path", "sam", "library", "cec", "inverters", "2019", "03", "05", "csv", "else", "raise", "valueerror", "f", "invalid", "name", "name", "elif", "path", "is", "not", "none", "if", "path", "startswith", "http", "response", "urlopen", "path", "csvdata", "io", "stringio", "response", "read", "decode", "errors", "ignore", "else", "csvdata", "path", "elif", "name", "is", "none", "and", "path", "is", "none", "raise", "valueerror", "a", "name", "or", "path", "must", "be", "provided", "return", "_parse_raw_sam_df", "csvdata"], "doc_len": 392}
{"doc_id": "pvlib/pvsystem.py::_normalize_sam_product_names", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "_normalize_sam_product_names", "text": "文件路径: pvlib/pvsystem.py\ndef _normalize_sam_product_names(names):\n    '''\n    Replace special characters within the product names to make them more\n    suitable for use as Dataframe column names.\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. July, 2019\n\n    import warnings\n\n    BAD_CHARS = ' -.()[]:+/\",'\n    GOOD_CHARS = '____________'\n\n    mapping = str.maketrans(BAD_CHARS, GOOD_CHARS)\n    names = pd.Series(data=names)\n    norm_names = names.str.translate(mapping)\n\n    n_duplicates = names.duplicated().sum()\n    if n_duplicates > 0:\n        warnings.warn('Original names contain %d duplicate(s).' % n_duplicates)\n\n    n_duplicates = norm_names.duplicated().sum()\n    if n_duplicates > 0:\n        warnings.warn(\n            'Normalized names contain %d duplicate(s).' % n_duplicates)\n\n    return norm_names.values\n", "tokens": ["pvlib", "pvsystem", "py", "def", "_normalize_sam_product_names", "names", "replace", "special", "characters", "within", "the", "product", "names", "to", "make", "them", "more", "suitable", "for", "use", "as", "dataframe", "column", "names", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "july", "2019", "import", "warnings", "bad_chars", "good_chars", "____________", "mapping", "str", "maketrans", "bad_chars", "good_chars", "names", "pd", "series", "data", "names", "norm_names", "names", "str", "translate", "mapping", "n_duplicates", "names", "duplicated", "sum", "if", "n_duplicates", "0", "warnings", "warn", "original", "names", "contain", "d", "duplicate", "s", "n_duplicates", "n_duplicates", "norm_names", "duplicated", "sum", "if", "n_duplicates", "0", "warnings", "warn", "normalized", "names", "contain", "d", "duplicate", "s", "n_duplicates", "return", "norm_names", "values"], "doc_len": 89}
{"doc_id": "pvlib/pvsystem.py::_parse_raw_sam_df", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "_parse_raw_sam_df", "text": "文件路径: pvlib/pvsystem.py\ndef _parse_raw_sam_df(csvdata):\n\n    df = pd.read_csv(csvdata, index_col=0, skiprows=[1, 2])\n\n    df.columns = df.columns.str.replace(' ', '_')\n    df.index = _normalize_sam_product_names(df.index)\n    df = df.transpose()\n\n    if 'ADRCoefficients' in df.index:\n        ad_ce = 'ADRCoefficients'\n        # for each inverter, parses a string of coefficients like\n        # ' 1.33, 2.11, 3.12' into a list containing floats:\n        # [1.33, 2.11, 3.12]\n        df.loc[ad_ce] = df.loc[ad_ce].map(lambda x: list(\n            map(float, x.strip(' []').split())))\n\n    return df\n", "tokens": ["pvlib", "pvsystem", "py", "def", "_parse_raw_sam_df", "csvdata", "df", "pd", "read_csv", "csvdata", "index_col", "0", "skiprows", "1", "2", "df", "columns", "df", "columns", "str", "replace", "_", "df", "index", "_normalize_sam_product_names", "df", "index", "df", "df", "transpose", "if", "adrcoefficients", "in", "df", "index", "ad_ce", "adrcoefficients", "for", "each", "inverter", "parses", "a", "string", "of", "coefficients", "like", "1", "33", "2", "11", "3", "12", "into", "a", "list", "containing", "floats", "1", "33", "2", "11", "3", "12", "df", "loc", "ad_ce", "df", "loc", "ad_ce", "map", "lambda", "x", "list", "map", "float", "x", "strip", "split", "return", "df"], "doc_len": 80}
{"doc_id": "pvlib/pvsystem.py::sapm", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "sapm", "text": "文件路径: pvlib/pvsystem.py\ndef sapm(effective_irradiance, temp_cell, module):\n    '''\n    The Sandia PV Array Performance Model (SAPM) generates 5 points on a\n    PV module's I-V curve (Voc, Isc, Ix, Ixx, Vmp/Imp) according to\n    SAND2004-3535. Assumes a reference cell temperature of 25 C.\n\n    Parameters\n    ----------\n    effective_irradiance : numeric\n        Irradiance reaching the module's cells, after reflections and\n        adjustment for spectrum. [W/m2]\n\n    temp_cell : numeric\n        Cell temperature [C].\n\n    module : dict-like\n        A dict or Series defining the SAPM parameters. See the notes section\n        for more details.\n\n    Returns\n    -------\n    A DataFrame with the columns:\n\n        * i_sc : Short-circuit current (A)\n        * i_mp : Current at the maximum-power point (A)\n        * v_oc : Open-circuit voltage (V)\n        * v_mp : Voltage at maximum-power point (V)\n        * p_mp : Power at maximum-power point (W)\n        * i_x : Current at module V = 0.5Voc, defines 4th point on I-V\n          curve for modeling curve shape\n        * i_xx : Current at module V = 0.5(Voc+Vmp), defines 5th point on\n          I-V curve for modeling curve shape\n\n    Notes\n    -----\n    The SAPM parameters which are required in ``module`` are\n    listed in the following table.\n\n    The Sandia module database contains parameter values for a limited set\n    of modules. The CEC module database does not contain these parameters.\n    Both databases can be accessed using :py:func:`retrieve_sam`.\n\n    ================   ========================================================\n    Key                Description\n    ================   ========================================================\n    A0-A4              The airmass coefficients used in calculating\n                       effective irradiance\n    B0-B5              The angle of incidence coefficients used in calculating\n                       effective irradiance\n    C0-C7              The empirically determined coefficients relating\n                       Imp, Vmp, Ix, and Ixx to effective irradiance\n    Isco               Short circuit current at reference condition (amps)\n    Impo               Maximum power current at reference condition (amps)\n    Voco               Open circuit voltage at reference condition (amps)\n    Vmpo               Maximum power voltage at reference condition (amps)\n    Aisc               Short circuit current temperature coefficient at\n                       reference condition (1/C)\n    Aimp               Maximum power current temperature coefficient at\n                       reference condition (1/C)\n    Bvoco              Open circuit voltage temperature coefficient at\n                       reference condition (V/C)\n    Mbvoc              Coefficient providing the irradiance dependence for the\n                       BetaVoc temperature coefficient at reference irradiance\n                       (V/C)\n    Bvmpo              Maximum power voltage temperature coefficient at\n                       reference condition\n    Mbvmp              Coefficient providing the irradiance dependence for the\n                       BetaVmp temperature coefficient at reference irradiance\n                       (V/C)\n    N                  Empirically determined \"diode factor\" (dimensionless)\n    Cells_in_Series    Number of cells in series in a module's cell string(s)\n    IXO                Ix at reference conditions\n    IXXO               Ixx at reference conditions\n    FD                 Fraction of diffuse irradiance used by module\n    ================   ========================================================\n\n    References\n    ----------\n    .. [1] King, D. et al, 2004, \"Sandia Photovoltaic Array Performance\n       Model\", SAND Report 3535, Sandia National Laboratories, Albuquerque,\n       NM.\n\n    See Also\n    --------\n    retrieve_sam\n    pvlib.temperature.sapm_cell\n    pvlib.temperature.sapm_module\n    '''\n\n    # TODO: someday, change temp_ref and irrad_ref to reference_temperature and\n    # reference_irradiance and expose\n    temp_ref = 25\n    irrad_ref = 1000\n\n    q = 1.60218e-19  # Elementary charge in units of coulombs\n    kb = 1.38066e-23  # Boltzmann's constant in units of J/K\n\n    # avoid problem with integer input\n    Ee = np.array(effective_irradiance, dtype='float64') / irrad_ref\n\n    # set up masking for 0, positive, and nan inputs\n    Ee_gt_0 = np.full_like(Ee, False, dtype='bool')\n    Ee_eq_0 = np.full_like(Ee, False, dtype='bool')\n    notnan = ~np.isnan(Ee)\n    np.greater(Ee, 0, where=notnan, out=Ee_gt_0)\n    np.equal(Ee, 0, where=notnan, out=Ee_eq_0)\n\n    Bvmpo = module['Bvmpo'] + module['Mbvmp']*(1 - Ee)\n    Bvoco = module['Bvoco'] + module['Mbvoc']*(1 - Ee)\n    delta = module['N'] * kb * (temp_cell + 273.15) / q\n\n    # avoid repeated computation\n    logEe = np.full_like(Ee, np.nan)\n    np.log(Ee, where=Ee_gt_0, out=logEe)\n    logEe = np.where(Ee_eq_0, -np.inf, logEe)\n    # avoid repeated __getitem__\n    cells_in_series = module['Cells_in_Series']\n\n    out = OrderedDict()\n\n    out['i_sc'] = (\n        module['Isco'] * Ee * (1 + module['Aisc']*(temp_cell - temp_ref)))\n\n    out['i_mp'] = (\n        module['Impo'] * (module['C0']*Ee + module['C1']*(Ee**2)) *\n        (1 + module['Aimp']*(temp_cell - temp_ref)))\n\n    out['v_oc'] = np.maximum(0, (\n        module['Voco'] + cells_in_series * delta * logEe +\n        Bvoco*(temp_cell - temp_ref)))\n\n    out['v_mp'] = np.maximum(0, (\n        module['Vmpo'] +\n        module['C2'] * cells_in_series * delta * logEe +\n        module['C3'] * cells_in_series * ((delta * logEe) ** 2) +\n        Bvmpo*(temp_cell - temp_ref)))\n\n    out['p_mp'] = out['i_mp'] * out['v_mp']\n\n    out['i_x'] = (\n        module['IXO'] * (module['C4']*Ee + module['C5']*(Ee**2)) *\n        (1 + module['Aisc']*(temp_cell - temp_ref)))\n\n    # the Ixx calculation in King 2004 has a typo (mixes up Aisc and Aimp)\n    out['i_xx'] = (\n        module['IXXO'] * (module['C6']*Ee + module['C7']*(Ee**2)) *\n        (1 + module['Aisc']*(temp_cell - temp_ref)))\n\n    if isinstance(out['i_sc'], pd.Series):\n        out = pd.DataFrame(out)\n\n    return out\n", "tokens": ["pvlib", "pvsystem", "py", "def", "sapm", "effective_irradiance", "temp_cell", "module", "the", "sandia", "pv", "array", "performance", "model", "sapm", "generates", "5", "points", "on", "a", "pv", "module", "s", "i", "v", "curve", "voc", "isc", "ix", "ixx", "vmp", "imp", "according", "to", "sand2004", "3535", "assumes", "a", "reference", "cell", "temperature", "of", "25", "c", "parameters", "effective_irradiance", "numeric", "irradiance", "reaching", "the", "module", "s", "cells", "after", "reflections", "and", "adjustment", "for", "spectrum", "w", "m2", "temp_cell", "numeric", "cell", "temperature", "c", "module", "dict", "like", "a", "dict", "or", "series", "defining", "the", "sapm", "parameters", "see", "the", "notes", "section", "for", "more", "details", "returns", "a", "dataframe", "with", "the", "columns", "i_sc", "short", "circuit", "current", "a", "i_mp", "current", "at", "the", "maximum", "power", "point", "a", "v_oc", "open", "circuit", "voltage", "v", "v_mp", "voltage", "at", "maximum", "power", "point", "v", "p_mp", "power", "at", "maximum", "power", "point", "w", "i_x", "current", "at", "module", "v", "0", "5voc", "defines", "4th", "point", "on", "i", "v", "curve", "for", "modeling", "curve", "shape", "i_xx", "current", "at", "module", "v", "0", "5", "voc", "vmp", "defines", "5th", "point", "on", "i", "v", "curve", "for", "modeling", "curve", "shape", "notes", "the", "sapm", "parameters", "which", "are", "required", "in", "module", "are", "listed", "in", "the", "following", "table", "the", "sandia", "module", "database", "contains", "parameter", "values", "for", "a", "limited", "set", "of", "modules", "the", "cec", "module", "database", "does", "not", "contain", "these", "parameters", "both", "databases", "can", "be", "accessed", "using", "py", "func", "retrieve_sam", "key", "description", "a0", "a4", "the", "airmass", "coefficients", "used", "in", "calculating", "effective", "irradiance", "b0", "b5", "the", "angle", "of", "incidence", "coefficients", "used", "in", "calculating", "effective", "irradiance", "c0", "c7", "the", "empirically", "determined", "coefficients", "relating", "imp", "vmp", "ix", "and", "ixx", "to", "effective", "irradiance", "isco", "short", "circuit", "current", "at", "reference", "condition", "amps", "impo", "maximum", "power", "current", "at", "reference", "condition", "amps", "voco", "open", "circuit", "voltage", "at", "reference", "condition", "amps", "vmpo", "maximum", "power", "voltage", "at", "reference", "condition", "amps", "aisc", "short", "circuit", "current", "temperature", "coefficient", "at", "reference", "condition", "1", "c", "aimp", "maximum", "power", "current", "temperature", "coefficient", "at", "reference", "condition", "1", "c", "bvoco", "open", "circuit", "voltage", "temperature", "coefficient", "at", "reference", "condition", "v", "c", "mbvoc", "coefficient", "providing", "the", "irradiance", "dependence", "for", "the", "betavoc", "temperature", "coefficient", "at", "reference", "irradiance", "v", "c", "bvmpo", "maximum", "power", "voltage", "temperature", "coefficient", "at", "reference", "condition", "mbvmp", "coefficient", "providing", "the", "irradiance", "dependence", "for", "the", "betavmp", "temperature", "coefficient", "at", "reference", "irradiance", "v", "c", "n", "empirically", "determined", "diode", "factor", "dimensionless", "cells_in_series", "number", "of", "cells", "in", "series", "in", "a", "module", "s", "cell", "string", "s", "ixo", "ix", "at", "reference", "conditions", "ixxo", "ixx", "at", "reference", "conditions", "fd", "fraction", "of", "diffuse", "irradiance", "used", "by", "module", "references", "1", "king", "d", "et", "al", "2004", "sandia", "photovoltaic", "array", "performance", "model", "sand", "report", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "see", "also", "retrieve_sam", "pvlib", "temperature", "sapm_cell", "pvlib", "temperature", "sapm_module", "todo", "someday", "change", "temp_ref", "and", "irrad_ref", "to", "reference_temperature", "and", "reference_irradiance", "and", "expose", "temp_ref", "25", "irrad_ref", "1000", "q", "1", "60218e", "19", "elementary", "charge", "in", "units", "of", "coulombs", "kb", "1", "38066e", "23", "boltzmann", "s", "constant", "in", "units", "of", "j", "k", "avoid", "problem", "with", "integer", "input", "ee", "np", "array", "effective_irradiance", "dtype", "float64", "irrad_ref", "set", "up", "masking", "for", "0", "positive", "and", "nan", "inputs", "ee_gt_0", "np", "full_like", "ee", "false", "dtype", "bool", "ee_eq_0", "np", "full_like", "ee", "false", "dtype", "bool", "notnan", "np", "isnan", "ee", "np", "greater", "ee", "0", "where", "notnan", "out", "ee_gt_0", "np", "equal", "ee", "0", "where", "notnan", "out", "ee_eq_0", "bvmpo", "module", "bvmpo", "module", "mbvmp", "1", "ee", "bvoco", "module", "bvoco", "module", "mbvoc", "1", "ee", "delta", "module", "n", "kb", "temp_cell", "273", "15", "q", "avoid", "repeated", "computation", "logee", "np", "full_like", "ee", "np", "nan", "np", "log", "ee", "where", "ee_gt_0", "out", "logee", "logee", "np", "where", "ee_eq_0", "np", "inf", "logee", "avoid", "repeated", "__getitem__", "cells_in_series", "module", "cells_in_series", "out", "ordereddict", "out", "i_sc", "module", "isco", "ee", "1", "module", "aisc", "temp_cell", "temp_ref", "out", "i_mp", "module", "impo", "module", "c0", "ee", "module", "c1", "ee", "2", "1", "module", "aimp", "temp_cell", "temp_ref", "out", "v_oc", "np", "maximum", "0", "module", "voco", "cells_in_series", "delta", "logee", "bvoco", "temp_cell", "temp_ref", "out", "v_mp", "np", "maximum", "0", "module", "vmpo", "module", "c2", "cells_in_series", "delta", "logee", "module", "c3", "cells_in_series", "delta", "logee", "2", "bvmpo", "temp_cell", "temp_ref", "out", "p_mp", "out", "i_mp", "out", "v_mp", "out", "i_x", "module", "ixo", "module", "c4", "ee", "module", "c5", "ee", "2", "1", "module", "aisc", "temp_cell", "temp_ref", "the", "ixx", "calculation", "in", "king", "2004", "has", "a", "typo", "mixes", "up", "aisc", "and", "aimp", "out", "i_xx", "module", "ixxo", "module", "c6", "ee", "module", "c7", "ee", "2", "1", "module", "aisc", "temp_cell", "temp_ref", "if", "isinstance", "out", "i_sc", "pd", "series", "out", "pd", "dataframe", "out", "return", "out"], "doc_len": 687}
{"doc_id": "pvlib/pvsystem.py::sapm_spectral_loss", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "sapm_spectral_loss", "text": "文件路径: pvlib/pvsystem.py\ndef sapm_spectral_loss(airmass_absolute, module):\n    \"\"\"\n    Calculates the SAPM spectral loss coefficient, F1.\n\n    Parameters\n    ----------\n    airmass_absolute : numeric\n        Absolute airmass\n\n    module : dict-like\n        A dict, Series, or DataFrame defining the SAPM performance\n        parameters. See the :py:func:`sapm` notes section for more\n        details.\n\n    Returns\n    -------\n    F1 : numeric\n        The SAPM spectral loss coefficient.\n\n    Notes\n    -----\n    nan airmass values will result in 0 output.\n    \"\"\"\n\n    am_coeff = [module['A4'], module['A3'], module['A2'], module['A1'],\n                module['A0']]\n\n    spectral_loss = np.polyval(am_coeff, airmass_absolute)\n\n    spectral_loss = np.where(np.isnan(spectral_loss), 0, spectral_loss)\n\n    spectral_loss = np.maximum(0, spectral_loss)\n\n    if isinstance(airmass_absolute, pd.Series):\n        spectral_loss = pd.Series(spectral_loss, airmass_absolute.index)\n\n    return spectral_loss\n", "tokens": ["pvlib", "pvsystem", "py", "def", "sapm_spectral_loss", "airmass_absolute", "module", "calculates", "the", "sapm", "spectral", "loss", "coefficient", "f1", "parameters", "airmass_absolute", "numeric", "absolute", "airmass", "module", "dict", "like", "a", "dict", "series", "or", "dataframe", "defining", "the", "sapm", "performance", "parameters", "see", "the", "py", "func", "sapm", "notes", "section", "for", "more", "details", "returns", "f1", "numeric", "the", "sapm", "spectral", "loss", "coefficient", "notes", "nan", "airmass", "values", "will", "result", "in", "0", "output", "am_coeff", "module", "a4", "module", "a3", "module", "a2", "module", "a1", "module", "a0", "spectral_loss", "np", "polyval", "am_coeff", "airmass_absolute", "spectral_loss", "np", "where", "np", "isnan", "spectral_loss", "0", "spectral_loss", "spectral_loss", "np", "maximum", "0", "spectral_loss", "if", "isinstance", "airmass_absolute", "pd", "series", "spectral_loss", "pd", "series", "spectral_loss", "airmass_absolute", "index", "return", "spectral_loss"], "doc_len": 101}
{"doc_id": "pvlib/pvsystem.py::sapm_effective_irradiance", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "sapm_effective_irradiance", "text": "文件路径: pvlib/pvsystem.py\ndef sapm_effective_irradiance(poa_direct, poa_diffuse, airmass_absolute, aoi,\n                              module):\n    r\"\"\"\n    Calculates the SAPM effective irradiance using the SAPM spectral\n    loss and SAPM angle of incidence loss functions.\n\n    Parameters\n    ----------\n    poa_direct : numeric\n        The direct irradiance incident upon the module. [W/m2]\n\n    poa_diffuse : numeric\n        The diffuse irradiance incident on module.  [W/m2]\n\n    airmass_absolute : numeric\n        Absolute airmass. [unitless]\n\n    aoi : numeric\n        Angle of incidence. [degrees]\n\n    module : dict-like\n        A dict, Series, or DataFrame defining the SAPM performance\n        parameters. See the :py:func:`sapm` notes section for more\n        details.\n\n    Returns\n    -------\n    effective_irradiance : numeric\n        Effective irradiance accounting for reflections and spectral content.\n        [W/m2]\n\n    Notes\n    -----\n    The SAPM model for effective irradiance [1]_ translates broadband direct\n    and diffuse irradiance on the plane of array to the irradiance absorbed by\n    a module's cells.\n\n    The model is\n    .. math::\n\n        `Ee = f_1(AM_a) (E_b f_2(AOI) + f_d E_d)`\n\n    where :math:`Ee` is effective irradiance (W/m2), :math:`f_1` is a fourth\n    degree polynomial in air mass :math:`AM_a`, :math:`E_b` is beam (direct)\n    irradiance on the plane of array, :math:`E_d` is diffuse irradiance on the\n    plane of array, :math:`f_2` is a fifth degree polynomial in the angle of\n    incidence :math:`AOI`, and :math:`f_d` is the fraction of diffuse\n    irradiance on the plane of array that is not reflected away.\n\n    References\n    ----------\n    .. [1] D. King et al, \"Sandia Photovoltaic Array Performance Model\",\n       SAND2004-3535, Sandia National Laboratories, Albuquerque, NM\n\n    See also\n    --------\n    pvlib.iam.sapm\n    pvlib.pvsystem.sapm_spectral_loss\n    pvlib.pvsystem.sapm\n    \"\"\"\n\n    F1 = sapm_spectral_loss(airmass_absolute, module)\n    F2 = iam.sapm(aoi, module)\n\n    Ee = F1 * (poa_direct * F2 + module['FD'] * poa_diffuse)\n\n    return Ee\n", "tokens": ["pvlib", "pvsystem", "py", "def", "sapm_effective_irradiance", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "module", "r", "calculates", "the", "sapm", "effective", "irradiance", "using", "the", "sapm", "spectral", "loss", "and", "sapm", "angle", "of", "incidence", "loss", "functions", "parameters", "poa_direct", "numeric", "the", "direct", "irradiance", "incident", "upon", "the", "module", "w", "m2", "poa_diffuse", "numeric", "the", "diffuse", "irradiance", "incident", "on", "module", "w", "m2", "airmass_absolute", "numeric", "absolute", "airmass", "unitless", "aoi", "numeric", "angle", "of", "incidence", "degrees", "module", "dict", "like", "a", "dict", "series", "or", "dataframe", "defining", "the", "sapm", "performance", "parameters", "see", "the", "py", "func", "sapm", "notes", "section", "for", "more", "details", "returns", "effective_irradiance", "numeric", "effective", "irradiance", "accounting", "for", "reflections", "and", "spectral", "content", "w", "m2", "notes", "the", "sapm", "model", "for", "effective", "irradiance", "1", "_", "translates", "broadband", "direct", "and", "diffuse", "irradiance", "on", "the", "plane", "of", "array", "to", "the", "irradiance", "absorbed", "by", "a", "module", "s", "cells", "the", "model", "is", "math", "ee", "f_1", "am_a", "e_b", "f_2", "aoi", "f_d", "e_d", "where", "math", "ee", "is", "effective", "irradiance", "w", "m2", "math", "f_1", "is", "a", "fourth", "degree", "polynomial", "in", "air", "mass", "math", "am_a", "math", "e_b", "is", "beam", "direct", "irradiance", "on", "the", "plane", "of", "array", "math", "e_d", "is", "diffuse", "irradiance", "on", "the", "plane", "of", "array", "math", "f_2", "is", "a", "fifth", "degree", "polynomial", "in", "the", "angle", "of", "incidence", "math", "aoi", "and", "math", "f_d", "is", "the", "fraction", "of", "diffuse", "irradiance", "on", "the", "plane", "of", "array", "that", "is", "not", "reflected", "away", "references", "1", "d", "king", "et", "al", "sandia", "photovoltaic", "array", "performance", "model", "sand2004", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "see", "also", "pvlib", "iam", "sapm", "pvlib", "pvsystem", "sapm_spectral_loss", "pvlib", "pvsystem", "sapm", "f1", "sapm_spectral_loss", "airmass_absolute", "module", "f2", "iam", "sapm", "aoi", "module", "ee", "f1", "poa_direct", "f2", "module", "fd", "poa_diffuse", "return", "ee"], "doc_len": 259}
{"doc_id": "pvlib/pvsystem.py::singlediode", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "singlediode", "text": "文件路径: pvlib/pvsystem.py\ndef singlediode(photocurrent, saturation_current, resistance_series,\n                resistance_shunt, nNsVth, ivcurve_pnts=None,\n                method='lambertw'):\n    r\"\"\"\n    Solve the single-diode equation to obtain a photovoltaic IV curve.\n\n    Solves the single diode equation [1]_\n\n    .. math::\n\n        I = I_L -\n            I_0 \\left[\n                \\exp \\left(\\frac{V+I R_s}{n N_s V_{th}} \\right)-1\n            \\right] -\n            \\frac{V + I R_s}{R_{sh}}\n\n    for :math:`I` and :math:`V` when given :math:`I_L, I_0, R_s, R_{sh},` and\n    :math:`n N_s V_{th}` which are described later. Returns a DataFrame\n    which contains the 5 points on the I-V curve specified in\n    [3]_. If all :math:`I_L, I_0, R_s, R_{sh},` and\n    :math:`n N_s V_{th}` are scalar, a single curve is returned, if any\n    are Series (of the same length), multiple IV curves are calculated.\n\n    The input parameters can be calculated from meteorological data using a\n    function for a single diode model, e.g.,\n    :py:func:`~pvlib.pvsystem.calcparams_desoto`.\n\n    Parameters\n    ----------\n    photocurrent : numeric\n        Light-generated current :math:`I_L` (photocurrent)\n        ``0 <= photocurrent``. [A]\n\n    saturation_current : numeric\n        Diode saturation :math:`I_0` current under desired IV curve\n        conditions. ``0 < saturation_current``. [A]\n\n    resistance_series : numeric\n        Series resistance :math:`R_s` under desired IV curve conditions.\n        ``0 <= resistance_series < numpy.inf``.  [ohm]\n\n    resistance_shunt : numeric\n        Shunt resistance :math:`R_{sh}` under desired IV curve conditions.\n        ``0 < resistance_shunt <= numpy.inf``.  [ohm]\n\n    nNsVth : numeric\n        The product of three components: 1) the usual diode ideality factor\n        :math:`n`, 2) the number of cells in series :math:`N_s`, and 3)\n        the cell thermal voltage\n        :math:`V_{th}`. The thermal voltage of the cell (in volts) may be\n        calculated as :math:`k_B T_c / q`, where :math:`k_B` is\n        Boltzmann's constant (J/K), :math:`T_c` is the temperature of the p-n\n        junction in Kelvin, and :math:`q` is the charge of an electron\n        (coulombs). ``0 < nNsVth``.  [V]\n\n    ivcurve_pnts : None or int, default None\n        Number of points in the desired IV curve. If None or 0, no points on\n        the IV curves will be produced.\n\n    method : str, default 'lambertw'\n        Determines the method used to calculate points on the IV curve. The\n        options are ``'lambertw'``, ``'newton'``, or ``'brentq'``.\n\n    Returns\n    -------\n    OrderedDict or DataFrame\n\n    The returned dict-like object always contains the keys/columns:\n\n        * i_sc - short circuit current in amperes.\n        * v_oc - open circuit voltage in volts.\n        * i_mp - current at maximum power point in amperes.\n        * v_mp - voltage at maximum power point in volts.\n        * p_mp - power at maximum power point in watts.\n        * i_x - current, in amperes, at ``v = 0.5*v_oc``.\n        * i_xx - current, in amperes, at ``V = 0.5*(v_oc+v_mp)``.\n\n    If ivcurve_pnts is greater than 0, the output dictionary will also\n    include the keys:\n\n        * i - IV curve current in amperes.\n        * v - IV curve voltage in volts.\n\n    The output will be an OrderedDict if photocurrent is a scalar,\n    array, or ivcurve_pnts is not None.\n\n    The output will be a DataFrame if photocurrent is a Series and\n    ivcurve_pnts is None.\n\n    See also\n    --------\n    calcparams_desoto\n    calcparams_cec\n    calcparams_pvsyst\n    sapm\n    pvlib.singlediode.bishop88\n\n    Notes\n    -----\n    If the method is ``'lambertw'`` then the solution employed to solve the\n    implicit diode equation utilizes the Lambert W function to obtain an\n    explicit function of :math:`V=f(I)` and :math:`I=f(V)` as shown in [2]_.\n\n    If the method is ``'newton'`` then the root-finding Newton-Raphson method\n    is used. It should be safe for well behaved IV-curves, but the ``'brentq'``\n    method is recommended for reliability.\n\n    If the method is ``'brentq'`` then Brent's bisection search method is used\n    that guarantees convergence by bounding the voltage between zero and\n    open-circuit.\n\n    If the method is either ``'newton'`` or ``'brentq'`` and ``ivcurve_pnts``\n    are indicated, then :func:`pvlib.singlediode.bishop88` [4]_ is used to\n    calculate the points on the IV curve points at diode voltages from zero to\n    open-circuit voltage with a log spacing that gets closer as voltage\n    increases. If the method is ``'lambertw'`` then the calculated points on\n    the IV curve are linearly spaced.\n\n    References\n    ----------\n    .. [1] S.R. Wenham, M.A. Green, M.E. Watt, \"Applied Photovoltaics\" ISBN\n       0 86758 909 4\n\n    .. [2] A. Jain, A. Kapoor, \"Exact analytical solutions of the\n       parameters of real solar cells using Lambert W-function\", Solar\n       Energy Materials and Solar Cells, 81 (2004) 269-277.\n\n    .. [3] D. King et al, \"Sandia Photovoltaic Array Performance Model\",\n       SAND2004-3535, Sandia National Laboratories, Albuquerque, NM\n\n    .. [4] \"Computer simulation of the effects of electrical mismatches in\n       photovoltaic cell interconnection circuits\" JW Bishop, Solar Cell (1988)\n       https://doi.org/10.1016/0379-6787(88)90059-2\n    \"\"\"\n    # Calculate points on the IV curve using the LambertW solution to the\n    # single diode equation\n    if method.lower() == 'lambertw':\n        out = _singlediode._lambertw(\n            photocurrent, saturation_current, resistance_series,\n            resistance_shunt, nNsVth, ivcurve_pnts\n        )\n        i_sc, v_oc, i_mp, v_mp, p_mp, i_x, i_xx = out[:7]\n        if ivcurve_pnts:\n            ivcurve_i, ivcurve_v = out[7:]\n    else:\n        # Calculate points on the IV curve using either 'newton' or 'brentq'\n        # methods. Voltages are determined by first solving the single diode\n        # equation for the diode voltage V_d then backing out voltage\n        args = (photocurrent, saturation_current, resistance_series,\n                resistance_shunt, nNsVth)  # collect args\n        v_oc = _singlediode.bishop88_v_from_i(\n            0.0, *args, method=method.lower()\n        )\n        i_mp, v_mp, p_mp = _singlediode.bishop88_mpp(\n            *args, method=method.lower()\n        )\n        i_sc = _singlediode.bishop88_i_from_v(\n            0.0, *args, method=method.lower()\n        )\n        i_x = _singlediode.bishop88_i_from_v(\n            v_oc / 2.0, *args, method=method.lower()\n        )\n        i_xx = _singlediode.bishop88_i_from_v(\n            (v_oc + v_mp) / 2.0, *args, method=method.lower()\n        )\n\n        # calculate the IV curve if requested using bishop88\n        if ivcurve_pnts:\n            vd = v_oc * (\n                (11.0 - np.logspace(np.log10(11.0), 0.0, ivcurve_pnts)) / 10.0\n            )\n            ivcurve_i, ivcurve_v, _ = _singlediode.bishop88(vd, *args)\n\n    out = OrderedDict()\n    out['i_sc'] = i_sc\n    out['v_oc'] = v_oc\n    out['i_mp'] = i_mp\n    out['v_mp'] = v_mp\n    out['p_mp'] = p_mp\n    out['i_x'] = i_x\n    out['i_xx'] = i_xx\n\n    if ivcurve_pnts:\n\n        out['v'] = ivcurve_v\n        out['i'] = ivcurve_i\n\n    if isinstance(photocurrent, pd.Series) and not ivcurve_pnts:\n        out = pd.DataFrame(out, index=photocurrent.index)\n\n    return out\n", "tokens": ["pvlib", "pvsystem", "py", "def", "singlediode", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "ivcurve_pnts", "none", "method", "lambertw", "r", "solve", "the", "single", "diode", "equation", "to", "obtain", "a", "photovoltaic", "iv", "curve", "solves", "the", "single", "diode", "equation", "1", "_", "math", "i", "i_l", "i_0", "left", "exp", "left", "frac", "v", "i", "r_s", "n", "n_s", "v_", "th", "right", "1", "right", "frac", "v", "i", "r_s", "r_", "sh", "for", "math", "i", "and", "math", "v", "when", "given", "math", "i_l", "i_0", "r_s", "r_", "sh", "and", "math", "n", "n_s", "v_", "th", "which", "are", "described", "later", "returns", "a", "dataframe", "which", "contains", "the", "5", "points", "on", "the", "i", "v", "curve", "specified", "in", "3", "_", "if", "all", "math", "i_l", "i_0", "r_s", "r_", "sh", "and", "math", "n", "n_s", "v_", "th", "are", "scalar", "a", "single", "curve", "is", "returned", "if", "any", "are", "series", "of", "the", "same", "length", "multiple", "iv", "curves", "are", "calculated", "the", "input", "parameters", "can", "be", "calculated", "from", "meteorological", "data", "using", "a", "function", "for", "a", "single", "diode", "model", "e", "g", "py", "func", "pvlib", "pvsystem", "calcparams_desoto", "parameters", "photocurrent", "numeric", "light", "generated", "current", "math", "i_l", "photocurrent", "0", "photocurrent", "a", "saturation_current", "numeric", "diode", "saturation", "math", "i_0", "current", "under", "desired", "iv", "curve", "conditions", "0", "saturation_current", "a", "resistance_series", "numeric", "series", "resistance", "math", "r_s", "under", "desired", "iv", "curve", "conditions", "0", "resistance_series", "numpy", "inf", "ohm", "resistance_shunt", "numeric", "shunt", "resistance", "math", "r_", "sh", "under", "desired", "iv", "curve", "conditions", "0", "resistance_shunt", "numpy", "inf", "ohm", "nnsvth", "numeric", "the", "product", "of", "three", "components", "1", "the", "usual", "diode", "ideality", "factor", "math", "n", "2", "the", "number", "of", "cells", "in", "series", "math", "n_s", "and", "3", "the", "cell", "thermal", "voltage", "math", "v_", "th", "the", "thermal", "voltage", "of", "the", "cell", "in", "volts", "may", "be", "calculated", "as", "math", "k_b", "t_c", "q", "where", "math", "k_b", "is", "boltzmann", "s", "constant", "j", "k", "math", "t_c", "is", "the", "temperature", "of", "the", "p", "n", "junction", "in", "kelvin", "and", "math", "q", "is", "the", "charge", "of", "an", "electron", "coulombs", "0", "nnsvth", "v", "ivcurve_pnts", "none", "or", "int", "default", "none", "number", "of", "points", "in", "the", "desired", "iv", "curve", "if", "none", "or", "0", "no", "points", "on", "the", "iv", "curves", "will", "be", "produced", "method", "str", "default", "lambertw", "determines", "the", "method", "used", "to", "calculate", "points", "on", "the", "iv", "curve", "the", "options", "are", "lambertw", "newton", "or", "brentq", "returns", "ordereddict", "or", "dataframe", "the", "returned", "dict", "like", "object", "always", "contains", "the", "keys", "columns", "i_sc", "short", "circuit", "current", "in", "amperes", "v_oc", "open", "circuit", "voltage", "in", "volts", "i_mp", "current", "at", "maximum", "power", "point", "in", "amperes", "v_mp", "voltage", "at", "maximum", "power", "point", "in", "volts", "p_mp", "power", "at", "maximum", "power", "point", "in", "watts", "i_x", "current", "in", "amperes", "at", "v", "0", "5", "v_oc", "i_xx", "current", "in", "amperes", "at", "v", "0", "5", "v_oc", "v_mp", "if", "ivcurve_pnts", "is", "greater", "than", "0", "the", "output", "dictionary", "will", "also", "include", "the", "keys", "i", "iv", "curve", "current", "in", "amperes", "v", "iv", "curve", "voltage", "in", "volts", "the", "output", "will", "be", "an", "ordereddict", "if", "photocurrent", "is", "a", "scalar", "array", "or", "ivcurve_pnts", "is", "not", "none", "the", "output", "will", "be", "a", "dataframe", "if", "photocurrent", "is", "a", "series", "and", "ivcurve_pnts", "is", "none", "see", "also", "calcparams_desoto", "calcparams_cec", "calcparams_pvsyst", "sapm", "pvlib", "singlediode", "bishop88", "notes", "if", "the", "method", "is", "lambertw", "then", "the", "solution", "employed", "to", "solve", "the", "implicit", "diode", "equation", "utilizes", "the", "lambert", "w", "function", "to", "obtain", "an", "explicit", "function", "of", "math", "v", "f", "i", "and", "math", "i", "f", "v", "as", "shown", "in", "2", "_", "if", "the", "method", "is", "newton", "then", "the", "root", "finding", "newton", "raphson", "method", "is", "used", "it", "should", "be", "safe", "for", "well", "behaved", "iv", "curves", "but", "the", "brentq", "method", "is", "recommended", "for", "reliability", "if", "the", "method", "is", "brentq", "then", "brent", "s", "bisection", "search", "method", "is", "used", "that", "guarantees", "convergence", "by", "bounding", "the", "voltage", "between", "zero", "and", "open", "circuit", "if", "the", "method", "is", "either", "newton", "or", "brentq", "and", "ivcurve_pnts", "are", "indicated", "then", "func", "pvlib", "singlediode", "bishop88", "4", "_", "is", "used", "to", "calculate", "the", "points", "on", "the", "iv", "curve", "points", "at", "diode", "voltages", "from", "zero", "to", "open", "circuit", "voltage", "with", "a", "log", "spacing", "that", "gets", "closer", "as", "voltage", "increases", "if", "the", "method", "is", "lambertw", "then", "the", "calculated", "points", "on", "the", "iv", "curve", "are", "linearly", "spaced", "references", "1", "s", "r", "wenham", "m", "a", "green", "m", "e", "watt", "applied", "photovoltaics", "isbn", "0", "86758", "909", "4", "2", "a", "jain", "a", "kapoor", "exact", "analytical", "solutions", "of", "the", "parameters", "of", "real", "solar", "cells", "using", "lambert", "w", "function", "solar", "energy", "materials", "and", "solar", "cells", "81", "2004", "269", "277", "3", "d", "king", "et", "al", "sandia", "photovoltaic", "array", "performance", "model", "sand2004", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "4", "computer", "simulation", "of", "the", "effects", "of", "electrical", "mismatches", "in", "photovoltaic", "cell", "interconnection", "circuits", "jw", "bishop", "solar", "cell", "1988", "https", "doi", "org", "10", "1016", "0379", "6787", "88", "90059", "2", "calculate", "points", "on", "the", "iv", "curve", "using", "the", "lambertw", "solution", "to", "the", "single", "diode", "equation", "if", "method", "lower", "lambertw", "out", "_singlediode", "_lambertw", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "ivcurve_pnts", "i_sc", "v_oc", "i_mp", "v_mp", "p_mp", "i_x", "i_xx", "out", "7", "if", "ivcurve_pnts", "ivcurve_i", "ivcurve_v", "out", "7", "else", "calculate", "points", "on", "the", "iv", "curve", "using", "either", "newton", "or", "brentq", "methods", "voltages", "are", "determined", "by", "first", "solving", "the", "single", "diode", "equation", "for", "the", "diode", "voltage", "v_d", "then", "backing", "out", "voltage", "args", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "collect", "args", "v_oc", "_singlediode", "bishop88_v_from_i", "0", "0", "args", "method", "method", "lower", "i_mp", "v_mp", "p_mp", "_singlediode", "bishop88_mpp", "args", "method", "method", "lower", "i_sc", "_singlediode", "bishop88_i_from_v", "0", "0", "args", "method", "method", "lower", "i_x", "_singlediode", "bishop88_i_from_v", "v_oc", "2", "0", "args", "method", "method", "lower", "i_xx", "_singlediode", "bishop88_i_from_v", "v_oc", "v_mp", "2", "0", "args", "method", "method", "lower", "calculate", "the", "iv", "curve", "if", "requested", "using", "bishop88", "if", "ivcurve_pnts", "vd", "v_oc", "11", "0", "np", "logspace", "np", "log10", "11", "0", "0", "0", "ivcurve_pnts", "10", "0", "ivcurve_i", "ivcurve_v", "_", "_singlediode", "bishop88", "vd", "args", "out", "ordereddict", "out", "i_sc", "i_sc", "out", "v_oc", "v_oc", "out", "i_mp", "i_mp", "out", "v_mp", "v_mp", "out", "p_mp", "p_mp", "out", "i_x", "i_x", "out", "i_xx", "i_xx", "if", "ivcurve_pnts", "out", "v", "ivcurve_v", "out", "i", "ivcurve_i", "if", "isinstance", "photocurrent", "pd", "series", "and", "not", "ivcurve_pnts", "out", "pd", "dataframe", "out", "index", "photocurrent", "index", "return", "out"], "doc_len": 950}
{"doc_id": "pvlib/pvsystem.py::max_power_point", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "max_power_point", "text": "文件路径: pvlib/pvsystem.py\ndef max_power_point(photocurrent, saturation_current, resistance_series,\n                    resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n                    method='brentq'):\n    \"\"\"\n    Given the single diode equation coefficients, calculates the maximum power\n    point (MPP).\n\n    Parameters\n    ----------\n    photocurrent : numeric\n        photo-generated current [A]\n    saturation_current : numeric\n        diode reverse saturation current [A]\n    resistance_series : numeric\n        series resitance [ohms]\n    resistance_shunt : numeric\n        shunt resitance [ohms]\n    nNsVth : numeric\n        product of thermal voltage ``Vth`` [V], diode ideality factor ``n``,\n        and number of serices cells ``Ns``\n    d2mutau : numeric, default 0\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that accounts for recombination current in the\n        intrinsic layer. The value is the ratio of intrinsic layer thickness\n        squared :math:`d^2` to the diffusion length of charge carriers\n        :math:`\\\\mu \\\\tau`. [V]\n    NsVbi : numeric, default np.inf\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that is the product of the PV module number of series\n        cells ``Ns`` and the builtin voltage ``Vbi`` of the intrinsic layer.\n        [V].\n    method : str\n        either ``'newton'`` or ``'brentq'``\n\n    Returns\n    -------\n    OrderedDict or pandas.Datafrane\n        ``(i_mp, v_mp, p_mp)``\n\n    Notes\n    -----\n    Use this function when you only want to find the maximum power point. Use\n    :func:`singlediode` when you need to find additional points on the IV\n    curve. This function uses Brent's method by default because it is\n    guaranteed to converge.\n    \"\"\"\n    i_mp, v_mp, p_mp = _singlediode.bishop88_mpp(\n        photocurrent, saturation_current, resistance_series,\n        resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n        method=method.lower()\n    )\n    if isinstance(photocurrent, pd.Series):\n        ivp = {'i_mp': i_mp, 'v_mp': v_mp, 'p_mp': p_mp}\n        out = pd.DataFrame(ivp, index=photocurrent.index)\n    else:\n        out = OrderedDict()\n        out['i_mp'] = i_mp\n        out['v_mp'] = v_mp\n        out['p_mp'] = p_mp\n    return out\n", "tokens": ["pvlib", "pvsystem", "py", "def", "max_power_point", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "method", "brentq", "given", "the", "single", "diode", "equation", "coefficients", "calculates", "the", "maximum", "power", "point", "mpp", "parameters", "photocurrent", "numeric", "photo", "generated", "current", "a", "saturation_current", "numeric", "diode", "reverse", "saturation", "current", "a", "resistance_series", "numeric", "series", "resitance", "ohms", "resistance_shunt", "numeric", "shunt", "resitance", "ohms", "nnsvth", "numeric", "product", "of", "thermal", "voltage", "vth", "v", "diode", "ideality", "factor", "n", "and", "number", "of", "serices", "cells", "ns", "d2mutau", "numeric", "default", "0", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "accounts", "for", "recombination", "current", "in", "the", "intrinsic", "layer", "the", "value", "is", "the", "ratio", "of", "intrinsic", "layer", "thickness", "squared", "math", "d", "2", "to", "the", "diffusion", "length", "of", "charge", "carriers", "math", "mu", "tau", "v", "nsvbi", "numeric", "default", "np", "inf", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "is", "the", "product", "of", "the", "pv", "module", "number", "of", "series", "cells", "ns", "and", "the", "builtin", "voltage", "vbi", "of", "the", "intrinsic", "layer", "v", "method", "str", "either", "newton", "or", "brentq", "returns", "ordereddict", "or", "pandas", "datafrane", "i_mp", "v_mp", "p_mp", "notes", "use", "this", "function", "when", "you", "only", "want", "to", "find", "the", "maximum", "power", "point", "use", "func", "singlediode", "when", "you", "need", "to", "find", "additional", "points", "on", "the", "iv", "curve", "this", "function", "uses", "brent", "s", "method", "by", "default", "because", "it", "is", "guaranteed", "to", "converge", "i_mp", "v_mp", "p_mp", "_singlediode", "bishop88_mpp", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "method", "method", "lower", "if", "isinstance", "photocurrent", "pd", "series", "ivp", "i_mp", "i_mp", "v_mp", "v_mp", "p_mp", "p_mp", "out", "pd", "dataframe", "ivp", "index", "photocurrent", "index", "else", "out", "ordereddict", "out", "i_mp", "i_mp", "out", "v_mp", "v_mp", "out", "p_mp", "p_mp", "return", "out"], "doc_len": 267}
{"doc_id": "pvlib/pvsystem.py::v_from_i", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "v_from_i", "text": "文件路径: pvlib/pvsystem.py\ndef v_from_i(resistance_shunt, resistance_series, nNsVth, current,\n             saturation_current, photocurrent, method='lambertw'):\n    '''\n    Device voltage at the given device current for the single diode model.\n\n    Uses the single diode model (SDM) as described in, e.g.,\n    Jain and Kapoor 2004 [1]_.\n    The solution is per Eq 3 of [1]_ except when resistance_shunt=numpy.inf,\n    in which case the explict solution for voltage is used.\n    Ideal device parameters are specified by resistance_shunt=np.inf and\n    resistance_series=0.\n    Inputs to this function can include scalars and pandas.Series, but it is\n    the caller's responsibility to ensure that the arguments are all float64\n    and within the proper ranges.\n\n    Parameters\n    ----------\n    resistance_shunt : numeric\n        Shunt resistance in ohms under desired IV curve conditions.\n        Often abbreviated ``Rsh``.\n        0 < resistance_shunt <= numpy.inf\n\n    resistance_series : numeric\n        Series resistance in ohms under desired IV curve conditions.\n        Often abbreviated ``Rs``.\n        0 <= resistance_series < numpy.inf\n\n    nNsVth : numeric\n        The product of three components. 1) The usual diode ideal factor\n        (n), 2) the number of cells in series (Ns), and 3) the cell\n        thermal voltage under the desired IV curve conditions (Vth). The\n        thermal voltage of the cell (in volts) may be calculated as\n        ``k*temp_cell/q``, where k is Boltzmann's constant (J/K),\n        temp_cell is the temperature of the p-n junction in Kelvin, and\n        q is the charge of an electron (coulombs).\n        0 < nNsVth\n\n    current : numeric\n        The current in amperes under desired IV curve conditions.\n\n    saturation_current : numeric\n        Diode saturation current in amperes under desired IV curve\n        conditions. Often abbreviated ``I_0``.\n        0 < saturation_current\n\n    photocurrent : numeric\n        Light-generated current (photocurrent) in amperes under desired\n        IV curve conditions. Often abbreviated ``I_L``.\n        0 <= photocurrent\n\n    method : str\n        Method to use: ``'lambertw'``, ``'newton'``, or ``'brentq'``. *Note*:\n        ``'brentq'`` is limited to 1st quadrant only.\n\n    Returns\n    -------\n    current : np.ndarray or scalar\n\n    References\n    ----------\n    .. [1] A. Jain, A. Kapoor, \"Exact analytical solutions of the\n       parameters of real solar cells using Lambert W-function\", Solar\n       Energy Materials and Solar Cells, 81 (2004) 269-277.\n    '''\n    if method.lower() == 'lambertw':\n        return _singlediode._lambertw_v_from_i(\n            resistance_shunt, resistance_series, nNsVth, current,\n            saturation_current, photocurrent\n        )\n    else:\n        # Calculate points on the IV curve using either 'newton' or 'brentq'\n        # methods. Voltages are determined by first solving the single diode\n        # equation for the diode voltage V_d then backing out voltage\n        args = (current, photocurrent, saturation_current,\n                resistance_series, resistance_shunt, nNsVth)\n        V = _singlediode.bishop88_v_from_i(*args, method=method.lower())\n        # find the right size and shape for returns\n        size, shape = _singlediode._get_size_and_shape(args)\n        if size <= 1:\n            if shape is not None:\n                V = np.tile(V, shape)\n        if np.isnan(V).any() and size <= 1:\n            V = np.repeat(V, size)\n            if shape is not None:\n                V = V.reshape(shape)\n        return V\n", "tokens": ["pvlib", "pvsystem", "py", "def", "v_from_i", "resistance_shunt", "resistance_series", "nnsvth", "current", "saturation_current", "photocurrent", "method", "lambertw", "device", "voltage", "at", "the", "given", "device", "current", "for", "the", "single", "diode", "model", "uses", "the", "single", "diode", "model", "sdm", "as", "described", "in", "e", "g", "jain", "and", "kapoor", "2004", "1", "_", "the", "solution", "is", "per", "eq", "3", "of", "1", "_", "except", "when", "resistance_shunt", "numpy", "inf", "in", "which", "case", "the", "explict", "solution", "for", "voltage", "is", "used", "ideal", "device", "parameters", "are", "specified", "by", "resistance_shunt", "np", "inf", "and", "resistance_series", "0", "inputs", "to", "this", "function", "can", "include", "scalars", "and", "pandas", "series", "but", "it", "is", "the", "caller", "s", "responsibility", "to", "ensure", "that", "the", "arguments", "are", "all", "float64", "and", "within", "the", "proper", "ranges", "parameters", "resistance_shunt", "numeric", "shunt", "resistance", "in", "ohms", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "rsh", "0", "resistance_shunt", "numpy", "inf", "resistance_series", "numeric", "series", "resistance", "in", "ohms", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "rs", "0", "resistance_series", "numpy", "inf", "nnsvth", "numeric", "the", "product", "of", "three", "components", "1", "the", "usual", "diode", "ideal", "factor", "n", "2", "the", "number", "of", "cells", "in", "series", "ns", "and", "3", "the", "cell", "thermal", "voltage", "under", "the", "desired", "iv", "curve", "conditions", "vth", "the", "thermal", "voltage", "of", "the", "cell", "in", "volts", "may", "be", "calculated", "as", "k", "temp_cell", "q", "where", "k", "is", "boltzmann", "s", "constant", "j", "k", "temp_cell", "is", "the", "temperature", "of", "the", "p", "n", "junction", "in", "kelvin", "and", "q", "is", "the", "charge", "of", "an", "electron", "coulombs", "0", "nnsvth", "current", "numeric", "the", "current", "in", "amperes", "under", "desired", "iv", "curve", "conditions", "saturation_current", "numeric", "diode", "saturation", "current", "in", "amperes", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "i_0", "0", "saturation_current", "photocurrent", "numeric", "light", "generated", "current", "photocurrent", "in", "amperes", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "i_l", "0", "photocurrent", "method", "str", "method", "to", "use", "lambertw", "newton", "or", "brentq", "note", "brentq", "is", "limited", "to", "1st", "quadrant", "only", "returns", "current", "np", "ndarray", "or", "scalar", "references", "1", "a", "jain", "a", "kapoor", "exact", "analytical", "solutions", "of", "the", "parameters", "of", "real", "solar", "cells", "using", "lambert", "w", "function", "solar", "energy", "materials", "and", "solar", "cells", "81", "2004", "269", "277", "if", "method", "lower", "lambertw", "return", "_singlediode", "_lambertw_v_from_i", "resistance_shunt", "resistance_series", "nnsvth", "current", "saturation_current", "photocurrent", "else", "calculate", "points", "on", "the", "iv", "curve", "using", "either", "newton", "or", "brentq", "methods", "voltages", "are", "determined", "by", "first", "solving", "the", "single", "diode", "equation", "for", "the", "diode", "voltage", "v_d", "then", "backing", "out", "voltage", "args", "current", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "v", "_singlediode", "bishop88_v_from_i", "args", "method", "method", "lower", "find", "the", "right", "size", "and", "shape", "for", "returns", "size", "shape", "_singlediode", "_get_size_and_shape", "args", "if", "size", "1", "if", "shape", "is", "not", "none", "v", "np", "tile", "v", "shape", "if", "np", "isnan", "v", "any", "and", "size", "1", "v", "np", "repeat", "v", "size", "if", "shape", "is", "not", "none", "v", "v", "reshape", "shape", "return", "v"], "doc_len": 433}
{"doc_id": "pvlib/pvsystem.py::i_from_v", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "i_from_v", "text": "文件路径: pvlib/pvsystem.py\ndef i_from_v(resistance_shunt, resistance_series, nNsVth, voltage,\n             saturation_current, photocurrent, method='lambertw'):\n    '''\n    Device current at the given device voltage for the single diode model.\n\n    Uses the single diode model (SDM) as described in, e.g.,\n     Jain and Kapoor 2004 [1]_.\n    The solution is per Eq 2 of [1] except when resistance_series=0,\n     in which case the explict solution for current is used.\n    Ideal device parameters are specified by resistance_shunt=np.inf and\n     resistance_series=0.\n    Inputs to this function can include scalars and pandas.Series, but it is\n     the caller's responsibility to ensure that the arguments are all float64\n     and within the proper ranges.\n\n    Parameters\n    ----------\n    resistance_shunt : numeric\n        Shunt resistance in ohms under desired IV curve conditions.\n        Often abbreviated ``Rsh``.\n        0 < resistance_shunt <= numpy.inf\n\n    resistance_series : numeric\n        Series resistance in ohms under desired IV curve conditions.\n        Often abbreviated ``Rs``.\n        0 <= resistance_series < numpy.inf\n\n    nNsVth : numeric\n        The product of three components. 1) The usual diode ideal factor\n        (n), 2) the number of cells in series (Ns), and 3) the cell\n        thermal voltage under the desired IV curve conditions (Vth). The\n        thermal voltage of the cell (in volts) may be calculated as\n        ``k*temp_cell/q``, where k is Boltzmann's constant (J/K),\n        temp_cell is the temperature of the p-n junction in Kelvin, and\n        q is the charge of an electron (coulombs).\n        0 < nNsVth\n\n    voltage : numeric\n        The voltage in Volts under desired IV curve conditions.\n\n    saturation_current : numeric\n        Diode saturation current in amperes under desired IV curve\n        conditions. Often abbreviated ``I_0``.\n        0 < saturation_current\n\n    photocurrent : numeric\n        Light-generated current (photocurrent) in amperes under desired\n        IV curve conditions. Often abbreviated ``I_L``.\n        0 <= photocurrent\n\n    method : str\n        Method to use: ``'lambertw'``, ``'newton'``, or ``'brentq'``. *Note*:\n        ``'brentq'`` is limited to 1st quadrant only.\n\n    Returns\n    -------\n    current : np.ndarray or scalar\n\n    References\n    ----------\n    .. [1] A. Jain, A. Kapoor, \"Exact analytical solutions of the\n       parameters of real solar cells using Lambert W-function\", Solar\n       Energy Materials and Solar Cells, 81 (2004) 269-277.\n    '''\n    if method.lower() == 'lambertw':\n        return _singlediode._lambertw_i_from_v(\n            resistance_shunt, resistance_series, nNsVth, voltage,\n            saturation_current, photocurrent\n        )\n    else:\n        # Calculate points on the IV curve using either 'newton' or 'brentq'\n        # methods. Voltages are determined by first solving the single diode\n        # equation for the diode voltage V_d then backing out voltage\n        args = (voltage, photocurrent, saturation_current, resistance_series,\n                resistance_shunt, nNsVth)\n        current = _singlediode.bishop88_i_from_v(*args, method=method.lower())\n        # find the right size and shape for returns\n        size, shape = _singlediode._get_size_and_shape(args)\n        if size <= 1:\n            if shape is not None:\n                current = np.tile(current, shape)\n        if np.isnan(current).any() and size <= 1:\n            current = np.repeat(current, size)\n            if shape is not None:\n                current = current.reshape(shape)\n        return current\n", "tokens": ["pvlib", "pvsystem", "py", "def", "i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "method", "lambertw", "device", "current", "at", "the", "given", "device", "voltage", "for", "the", "single", "diode", "model", "uses", "the", "single", "diode", "model", "sdm", "as", "described", "in", "e", "g", "jain", "and", "kapoor", "2004", "1", "_", "the", "solution", "is", "per", "eq", "2", "of", "1", "except", "when", "resistance_series", "0", "in", "which", "case", "the", "explict", "solution", "for", "current", "is", "used", "ideal", "device", "parameters", "are", "specified", "by", "resistance_shunt", "np", "inf", "and", "resistance_series", "0", "inputs", "to", "this", "function", "can", "include", "scalars", "and", "pandas", "series", "but", "it", "is", "the", "caller", "s", "responsibility", "to", "ensure", "that", "the", "arguments", "are", "all", "float64", "and", "within", "the", "proper", "ranges", "parameters", "resistance_shunt", "numeric", "shunt", "resistance", "in", "ohms", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "rsh", "0", "resistance_shunt", "numpy", "inf", "resistance_series", "numeric", "series", "resistance", "in", "ohms", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "rs", "0", "resistance_series", "numpy", "inf", "nnsvth", "numeric", "the", "product", "of", "three", "components", "1", "the", "usual", "diode", "ideal", "factor", "n", "2", "the", "number", "of", "cells", "in", "series", "ns", "and", "3", "the", "cell", "thermal", "voltage", "under", "the", "desired", "iv", "curve", "conditions", "vth", "the", "thermal", "voltage", "of", "the", "cell", "in", "volts", "may", "be", "calculated", "as", "k", "temp_cell", "q", "where", "k", "is", "boltzmann", "s", "constant", "j", "k", "temp_cell", "is", "the", "temperature", "of", "the", "p", "n", "junction", "in", "kelvin", "and", "q", "is", "the", "charge", "of", "an", "electron", "coulombs", "0", "nnsvth", "voltage", "numeric", "the", "voltage", "in", "volts", "under", "desired", "iv", "curve", "conditions", "saturation_current", "numeric", "diode", "saturation", "current", "in", "amperes", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "i_0", "0", "saturation_current", "photocurrent", "numeric", "light", "generated", "current", "photocurrent", "in", "amperes", "under", "desired", "iv", "curve", "conditions", "often", "abbreviated", "i_l", "0", "photocurrent", "method", "str", "method", "to", "use", "lambertw", "newton", "or", "brentq", "note", "brentq", "is", "limited", "to", "1st", "quadrant", "only", "returns", "current", "np", "ndarray", "or", "scalar", "references", "1", "a", "jain", "a", "kapoor", "exact", "analytical", "solutions", "of", "the", "parameters", "of", "real", "solar", "cells", "using", "lambert", "w", "function", "solar", "energy", "materials", "and", "solar", "cells", "81", "2004", "269", "277", "if", "method", "lower", "lambertw", "return", "_singlediode", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "else", "calculate", "points", "on", "the", "iv", "curve", "using", "either", "newton", "or", "brentq", "methods", "voltages", "are", "determined", "by", "first", "solving", "the", "single", "diode", "equation", "for", "the", "diode", "voltage", "v_d", "then", "backing", "out", "voltage", "args", "voltage", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "current", "_singlediode", "bishop88_i_from_v", "args", "method", "method", "lower", "find", "the", "right", "size", "and", "shape", "for", "returns", "size", "shape", "_singlediode", "_get_size_and_shape", "args", "if", "size", "1", "if", "shape", "is", "not", "none", "current", "np", "tile", "current", "shape", "if", "np", "isnan", "current", "any", "and", "size", "1", "current", "np", "repeat", "current", "size", "if", "shape", "is", "not", "none", "current", "current", "reshape", "shape", "return", "current"], "doc_len": 431}
{"doc_id": "pvlib/pvsystem.py::scale_voltage_current_power", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "scale_voltage_current_power", "text": "文件路径: pvlib/pvsystem.py\ndef scale_voltage_current_power(data, voltage=1, current=1):\n    \"\"\"\n    Scales the voltage, current, and power in data by the voltage\n    and current factors.\n\n    Parameters\n    ----------\n    data: DataFrame\n        May contain columns `'v_mp', 'v_oc', 'i_mp' ,'i_x', 'i_xx',\n        'i_sc', 'p_mp'`.\n    voltage: numeric, default 1\n        The amount by which to multiply the voltages.\n    current: numeric, default 1\n        The amount by which to multiply the currents.\n\n    Returns\n    -------\n    scaled_data: DataFrame\n        A scaled copy of the input data.\n        `'p_mp'` is scaled by `voltage * current`.\n    \"\"\"\n\n    # as written, only works with a DataFrame\n    # could make it work with a dict, but it would be more verbose\n    voltage_keys = ['v_mp', 'v_oc']\n    current_keys = ['i_mp', 'i_x', 'i_xx', 'i_sc']\n    power_keys = ['p_mp']\n    voltage_df = data.filter(voltage_keys, axis=1) * voltage\n    current_df = data.filter(current_keys, axis=1) * current\n    power_df = data.filter(power_keys, axis=1) * voltage * current\n    df = pd.concat([voltage_df, current_df, power_df], axis=1)\n    df_sorted = df[data.columns]  # retain original column order\n    return df_sorted\n", "tokens": ["pvlib", "pvsystem", "py", "def", "scale_voltage_current_power", "data", "voltage", "1", "current", "1", "scales", "the", "voltage", "current", "and", "power", "in", "data", "by", "the", "voltage", "and", "current", "factors", "parameters", "data", "dataframe", "may", "contain", "columns", "v_mp", "v_oc", "i_mp", "i_x", "i_xx", "i_sc", "p_mp", "voltage", "numeric", "default", "1", "the", "amount", "by", "which", "to", "multiply", "the", "voltages", "current", "numeric", "default", "1", "the", "amount", "by", "which", "to", "multiply", "the", "currents", "returns", "scaled_data", "dataframe", "a", "scaled", "copy", "of", "the", "input", "data", "p_mp", "is", "scaled", "by", "voltage", "current", "as", "written", "only", "works", "with", "a", "dataframe", "could", "make", "it", "work", "with", "a", "dict", "but", "it", "would", "be", "more", "verbose", "voltage_keys", "v_mp", "v_oc", "current_keys", "i_mp", "i_x", "i_xx", "i_sc", "power_keys", "p_mp", "voltage_df", "data", "filter", "voltage_keys", "axis", "1", "voltage", "current_df", "data", "filter", "current_keys", "axis", "1", "current", "power_df", "data", "filter", "power_keys", "axis", "1", "voltage", "current", "df", "pd", "concat", "voltage_df", "current_df", "power_df", "axis", "1", "df_sorted", "df", "data", "columns", "retain", "original", "column", "order", "return", "df_sorted"], "doc_len": 147}
{"doc_id": "pvlib/pvsystem.py::pvwatts_dc", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "pvwatts_dc", "text": "文件路径: pvlib/pvsystem.py\ndef pvwatts_dc(g_poa_effective, temp_cell, pdc0, gamma_pdc, temp_ref=25.):\n    r\"\"\"\n    Implements NREL's PVWatts DC power model. The PVWatts DC model [1]_ is:\n\n    .. math::\n\n        P_{dc} = \\frac{G_{poa eff}}{1000} P_{dc0} ( 1 + \\gamma_{pdc} (T_{cell} - T_{ref}))\n\n    Note that the pdc0 is also used as a symbol in\n    :py:func:`pvlib.inverter.pvwatts`. pdc0 in this function refers to the DC\n    power of the modules at reference conditions. pdc0 in\n    :py:func:`pvlib.inverter.pvwatts` refers to the DC power input limit of\n    the inverter.\n\n    Parameters\n    ----------\n    g_poa_effective: numeric\n        Irradiance transmitted to the PV cells. To be\n        fully consistent with PVWatts, the user must have already\n        applied angle of incidence losses, but not soiling, spectral,\n        etc. [W/m^2]\n    temp_cell: numeric\n        Cell temperature [C].\n    pdc0: numeric\n        Power of the modules at 1000 W/m^2 and cell reference temperature. [W]\n    gamma_pdc: numeric\n        The temperature coefficient of power. Typically -0.002 to\n        -0.005 per degree C. [1/C]\n    temp_ref: numeric, default 25.0\n        Cell reference temperature. PVWatts defines it to be 25 C and\n        is included here for flexibility. [C]\n\n    Returns\n    -------\n    pdc: numeric\n        DC power.\n\n    References\n    ----------\n    .. [1] A. P. Dobos, \"PVWatts Version 5 Manual\"\n           http://pvwatts.nrel.gov/downloads/pvwattsv5.pdf\n           (2014).\n    \"\"\"  # noqa: E501\n\n    pdc = (g_poa_effective * 0.001 * pdc0 *\n           (1 + gamma_pdc * (temp_cell - temp_ref)))\n\n    return pdc\n", "tokens": ["pvlib", "pvsystem", "py", "def", "pvwatts_dc", "g_poa_effective", "temp_cell", "pdc0", "gamma_pdc", "temp_ref", "25", "r", "implements", "nrel", "s", "pvwatts", "dc", "power", "model", "the", "pvwatts", "dc", "model", "1", "_", "is", "math", "p_", "dc", "frac", "g_", "poa", "eff", "1000", "p_", "dc0", "1", "gamma_", "pdc", "t_", "cell", "t_", "ref", "note", "that", "the", "pdc0", "is", "also", "used", "as", "a", "symbol", "in", "py", "func", "pvlib", "inverter", "pvwatts", "pdc0", "in", "this", "function", "refers", "to", "the", "dc", "power", "of", "the", "modules", "at", "reference", "conditions", "pdc0", "in", "py", "func", "pvlib", "inverter", "pvwatts", "refers", "to", "the", "dc", "power", "input", "limit", "of", "the", "inverter", "parameters", "g_poa_effective", "numeric", "irradiance", "transmitted", "to", "the", "pv", "cells", "to", "be", "fully", "consistent", "with", "pvwatts", "the", "user", "must", "have", "already", "applied", "angle", "of", "incidence", "losses", "but", "not", "soiling", "spectral", "etc", "w", "m", "2", "temp_cell", "numeric", "cell", "temperature", "c", "pdc0", "numeric", "power", "of", "the", "modules", "at", "1000", "w", "m", "2", "and", "cell", "reference", "temperature", "w", "gamma_pdc", "numeric", "the", "temperature", "coefficient", "of", "power", "typically", "0", "002", "to", "0", "005", "per", "degree", "c", "1", "c", "temp_ref", "numeric", "default", "25", "0", "cell", "reference", "temperature", "pvwatts", "defines", "it", "to", "be", "25", "c", "and", "is", "included", "here", "for", "flexibility", "c", "returns", "pdc", "numeric", "dc", "power", "references", "1", "a", "p", "dobos", "pvwatts", "version", "5", "manual", "http", "pvwatts", "nrel", "gov", "downloads", "pvwattsv5", "pdf", "2014", "noqa", "e501", "pdc", "g_poa_effective", "0", "001", "pdc0", "1", "gamma_pdc", "temp_cell", "temp_ref", "return", "pdc"], "doc_len": 220}
{"doc_id": "pvlib/pvsystem.py::pvwatts_losses", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "pvwatts_losses", "text": "文件路径: pvlib/pvsystem.py\ndef pvwatts_losses(soiling=2, shading=3, snow=0, mismatch=2, wiring=2,\n                   connections=0.5, lid=1.5, nameplate_rating=1, age=0,\n                   availability=3):\n    r\"\"\"\n    Implements NREL's PVWatts system loss model.\n    The PVWatts loss model [1]_ is:\n\n    .. math::\n\n        L_{total}(\\%) = 100 [ 1 - \\Pi_i ( 1 - \\frac{L_i}{100} ) ]\n\n    All parameters must be in units of %. Parameters may be\n    array-like, though all array sizes must match.\n\n    Parameters\n    ----------\n    soiling: numeric, default 2\n    shading: numeric, default 3\n    snow: numeric, default 0\n    mismatch: numeric, default 2\n    wiring: numeric, default 2\n    connections: numeric, default 0.5\n    lid: numeric, default 1.5\n        Light induced degradation\n    nameplate_rating: numeric, default 1\n    age: numeric, default 0\n    availability: numeric, default 3\n\n    Returns\n    -------\n    losses: numeric\n        System losses in units of %.\n\n    References\n    ----------\n    .. [1] A. P. Dobos, \"PVWatts Version 5 Manual\"\n           http://pvwatts.nrel.gov/downloads/pvwattsv5.pdf\n           (2014).\n    \"\"\"\n\n    params = [soiling, shading, snow, mismatch, wiring, connections, lid,\n              nameplate_rating, age, availability]\n\n    # manually looping over params allows for numpy/pandas to handle any\n    # array-like broadcasting that might be necessary.\n    perf = 1\n    for param in params:\n        perf *= 1 - param/100\n\n    losses = (1 - perf) * 100.\n\n    return losses\n", "tokens": ["pvlib", "pvsystem", "py", "def", "pvwatts_losses", "soiling", "2", "shading", "3", "snow", "0", "mismatch", "2", "wiring", "2", "connections", "0", "5", "lid", "1", "5", "nameplate_rating", "1", "age", "0", "availability", "3", "r", "implements", "nrel", "s", "pvwatts", "system", "loss", "model", "the", "pvwatts", "loss", "model", "1", "_", "is", "math", "l_", "total", "100", "1", "pi_i", "1", "frac", "l_i", "100", "all", "parameters", "must", "be", "in", "units", "of", "parameters", "may", "be", "array", "like", "though", "all", "array", "sizes", "must", "match", "parameters", "soiling", "numeric", "default", "2", "shading", "numeric", "default", "3", "snow", "numeric", "default", "0", "mismatch", "numeric", "default", "2", "wiring", "numeric", "default", "2", "connections", "numeric", "default", "0", "5", "lid", "numeric", "default", "1", "5", "light", "induced", "degradation", "nameplate_rating", "numeric", "default", "1", "age", "numeric", "default", "0", "availability", "numeric", "default", "3", "returns", "losses", "numeric", "system", "losses", "in", "units", "of", "references", "1", "a", "p", "dobos", "pvwatts", "version", "5", "manual", "http", "pvwatts", "nrel", "gov", "downloads", "pvwattsv5", "pdf", "2014", "params", "soiling", "shading", "snow", "mismatch", "wiring", "connections", "lid", "nameplate_rating", "age", "availability", "manually", "looping", "over", "params", "allows", "for", "numpy", "pandas", "to", "handle", "any", "array", "like", "broadcasting", "that", "might", "be", "necessary", "perf", "1", "for", "param", "in", "params", "perf", "1", "param", "100", "losses", "1", "perf", "100", "return", "losses"], "doc_len": 186}
{"doc_id": "pvlib/pvsystem.py::dc_ohms_from_percent", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "dc_ohms_from_percent", "text": "文件路径: pvlib/pvsystem.py\ndef dc_ohms_from_percent(vmp_ref, imp_ref, dc_ohmic_percent,\n                         modules_per_string=1,\n                         strings=1):\n    \"\"\"\n    Calculates the equivalent resistance of the wires from a percent\n    ohmic loss at STC.\n\n    Equivalent resistance is calculated with the function:\n\n    .. math::\n        Rw = (L_{stc} / 100) * (Varray / Iarray)\n\n    :math:`Rw` is the equivalent resistance in ohms\n    :math:`Varray` is the Vmp of the modules times modules per string\n    :math:`Iarray` is the Imp of the modules times strings per array\n    :math:`L_{stc}` is the input dc loss percent\n\n    Parameters\n    ----------\n    vmp_ref: numeric\n        Voltage at maximum power in reference conditions [V]\n    imp_ref: numeric\n        Current at maximum power in reference conditions [V]\n    dc_ohmic_percent: numeric, default 0\n        input dc loss as a percent, e.g. 1.5% loss is input as 1.5\n    modules_per_string: int, default 1\n        Number of modules per string in the array.\n    strings: int, default 1\n        Number of parallel strings in the array.\n\n    Returns\n    ----------\n    Rw: numeric\n        Equivalent resistance [ohm]\n\n    See Also\n    --------\n    pvlib.pvsystem.dc_ohmic_losses\n\n    References\n    ----------\n    .. [1] PVsyst 7 Help. \"Array ohmic wiring loss\".\n       https://www.pvsyst.com/help/ohmic_loss.htm\n    \"\"\"\n    vmp = modules_per_string * vmp_ref\n\n    imp = strings * imp_ref\n\n    Rw = (dc_ohmic_percent / 100) * (vmp / imp)\n\n    return Rw\n", "tokens": ["pvlib", "pvsystem", "py", "def", "dc_ohms_from_percent", "vmp_ref", "imp_ref", "dc_ohmic_percent", "modules_per_string", "1", "strings", "1", "calculates", "the", "equivalent", "resistance", "of", "the", "wires", "from", "a", "percent", "ohmic", "loss", "at", "stc", "equivalent", "resistance", "is", "calculated", "with", "the", "function", "math", "rw", "l_", "stc", "100", "varray", "iarray", "math", "rw", "is", "the", "equivalent", "resistance", "in", "ohms", "math", "varray", "is", "the", "vmp", "of", "the", "modules", "times", "modules", "per", "string", "math", "iarray", "is", "the", "imp", "of", "the", "modules", "times", "strings", "per", "array", "math", "l_", "stc", "is", "the", "input", "dc", "loss", "percent", "parameters", "vmp_ref", "numeric", "voltage", "at", "maximum", "power", "in", "reference", "conditions", "v", "imp_ref", "numeric", "current", "at", "maximum", "power", "in", "reference", "conditions", "v", "dc_ohmic_percent", "numeric", "default", "0", "input", "dc", "loss", "as", "a", "percent", "e", "g", "1", "5", "loss", "is", "input", "as", "1", "5", "modules_per_string", "int", "default", "1", "number", "of", "modules", "per", "string", "in", "the", "array", "strings", "int", "default", "1", "number", "of", "parallel", "strings", "in", "the", "array", "returns", "rw", "numeric", "equivalent", "resistance", "ohm", "see", "also", "pvlib", "pvsystem", "dc_ohmic_losses", "references", "1", "pvsyst", "7", "help", "array", "ohmic", "wiring", "loss", "https", "www", "pvsyst", "com", "help", "ohmic_loss", "htm", "vmp", "modules_per_string", "vmp_ref", "imp", "strings", "imp_ref", "rw", "dc_ohmic_percent", "100", "vmp", "imp", "return", "rw"], "doc_len": 185}
{"doc_id": "pvlib/pvsystem.py::dc_ohmic_losses", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "dc_ohmic_losses", "text": "文件路径: pvlib/pvsystem.py\ndef dc_ohmic_losses(resistance, current):\n    \"\"\"\n    Returns ohmic losses in units of power from the equivalent\n    resistance of the wires and the operating current.\n\n    Parameters\n    ----------\n    resistance: numeric\n        Equivalent resistance of wires [ohm]\n    current: numeric, float or array-like\n        Operating current [A]\n\n    Returns\n    ----------\n    loss: numeric\n        Power Loss [W]\n\n    See Also\n    --------\n    pvlib.pvsystem.dc_ohms_from_percent\n\n    References\n    ----------\n    .. [1] PVsyst 7 Help. \"Array ohmic wiring loss\".\n       https://www.pvsyst.com/help/ohmic_loss.htm\n    \"\"\"\n    return resistance * current * current\n", "tokens": ["pvlib", "pvsystem", "py", "def", "dc_ohmic_losses", "resistance", "current", "returns", "ohmic", "losses", "in", "units", "of", "power", "from", "the", "equivalent", "resistance", "of", "the", "wires", "and", "the", "operating", "current", "parameters", "resistance", "numeric", "equivalent", "resistance", "of", "wires", "ohm", "current", "numeric", "float", "or", "array", "like", "operating", "current", "a", "returns", "loss", "numeric", "power", "loss", "w", "see", "also", "pvlib", "pvsystem", "dc_ohms_from_percent", "references", "1", "pvsyst", "7", "help", "array", "ohmic", "wiring", "loss", "https", "www", "pvsyst", "com", "help", "ohmic_loss", "htm", "return", "resistance", "current", "current"], "doc_len": 73}
{"doc_id": "pvlib/pvsystem.py::combine_loss_factors", "file_path": "pvlib/pvsystem.py", "class_name": null, "func_name": "combine_loss_factors", "text": "文件路径: pvlib/pvsystem.py\ndef combine_loss_factors(index, *losses, fill_method='ffill'):\n    r\"\"\"\n    Combines Series loss fractions while setting a common index.\n\n    The separate losses are compounded using the following equation:\n\n    .. math::\n\n        L_{total} = 1 - [ 1 - \\Pi_i ( 1 - L_i ) ]\n\n    :math:`L_{total}` is the total loss returned\n    :math:`L_i` is each individual loss factor input\n\n    Note the losses must each be a series with a DatetimeIndex.\n    All losses will be resampled to match the index parameter using\n    the fill method specified (defaults to \"fill forward\").\n\n    Parameters\n    ----------\n    index : DatetimeIndex\n        The index of the returned loss factors\n\n    *losses : Series\n        One or more Series of fractions to be compounded\n\n    fill_method : {'ffill', 'bfill', 'nearest'}, default 'ffill'\n        Method to use for filling holes in reindexed DataFrame\n\n    Returns\n    -------\n    Series\n        Fractions resulting from the combination of each loss factor\n    \"\"\"\n    combined_factor = 1\n\n    for loss in losses:\n        loss = loss.reindex(index, method=fill_method)\n        combined_factor *= (1 - loss)\n\n    return 1 - combined_factor\n", "tokens": ["pvlib", "pvsystem", "py", "def", "combine_loss_factors", "index", "losses", "fill_method", "ffill", "r", "combines", "series", "loss", "fractions", "while", "setting", "a", "common", "index", "the", "separate", "losses", "are", "compounded", "using", "the", "following", "equation", "math", "l_", "total", "1", "1", "pi_i", "1", "l_i", "math", "l_", "total", "is", "the", "total", "loss", "returned", "math", "l_i", "is", "each", "individual", "loss", "factor", "input", "note", "the", "losses", "must", "each", "be", "a", "series", "with", "a", "datetimeindex", "all", "losses", "will", "be", "resampled", "to", "match", "the", "index", "parameter", "using", "the", "fill", "method", "specified", "defaults", "to", "fill", "forward", "parameters", "index", "datetimeindex", "the", "index", "of", "the", "returned", "loss", "factors", "losses", "series", "one", "or", "more", "series", "of", "fractions", "to", "be", "compounded", "fill_method", "ffill", "bfill", "nearest", "default", "ffill", "method", "to", "use", "for", "filling", "holes", "in", "reindexed", "dataframe", "returns", "series", "fractions", "resulting", "from", "the", "combination", "of", "each", "loss", "factor", "combined_factor", "1", "for", "loss", "in", "losses", "loss", "loss", "reindex", "index", "method", "fill_method", "combined_factor", "1", "loss", "return", "1", "combined_factor"], "doc_len": 147}
{"doc_id": "pvlib/scaling.py::wvm", "file_path": "pvlib/scaling.py", "class_name": null, "func_name": "wvm", "text": "文件路径: pvlib/scaling.py\ndef wvm(clearsky_index, positions, cloud_speed, dt=None):\n    \"\"\"\n    Compute spatial aggregation time series smoothing on clear sky index based\n    on the Wavelet Variability model of Lave et al. [1]_, [2]_. Implementation\n    is basically a port of the Matlab version of the code [3]_.\n\n    Parameters\n    ----------\n    clearsky_index : numeric or pandas.Series\n        Clear Sky Index time series that will be smoothed.\n\n    positions : numeric\n        Array of coordinate distances as (x,y) pairs representing the\n        easting, northing of the site positions in meters [m]. Distributed\n        plants could be simulated by gridded points throughout the plant\n        footprint.\n\n    cloud_speed : numeric\n        Speed of cloud movement in meters per second [m/s].\n\n    dt : float, default None\n        The time series time delta. By default, is inferred from the\n        clearsky_index. Must be specified for a time series that doesn't\n        include an index. Units of seconds [s].\n\n    Returns\n    -------\n    smoothed : numeric or pandas.Series\n        The Clear Sky Index time series smoothed for the described plant.\n\n    wavelet: numeric\n        The individual wavelets for the time series before smoothing.\n\n    tmscales: numeric\n        The timescales associated with the wavelets in seconds [s].\n\n    References\n    ----------\n    .. [1] M. Lave, J. Kleissl and J.S. Stein. A Wavelet-Based Variability\n       Model (WVM) for Solar PV Power Plants. IEEE Transactions on Sustainable\n       Energy, vol. 4, no. 2, pp. 501-509, 2013.\n\n    .. [2] M. Lave and J. Kleissl. Cloud speed impact on solar variability\n       scaling - Application to the wavelet variability model. Solar Energy,\n       vol. 91, pp. 11-21, 2013.\n\n    .. [3] Wavelet Variability Model - Matlab Code:\n       https://github.com/sandialabs/wvm\n    \"\"\"\n\n    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n\n    wavelet, tmscales = _compute_wavelet(clearsky_index, dt)\n\n    vr = _compute_vr(positions, cloud_speed, tmscales)\n\n    # Scale each wavelet by VR (Eq 7 in [1])\n    wavelet_smooth = np.zeros_like(wavelet)\n    for i in np.arange(len(tmscales)):\n        if i < len(tmscales) - 1:  # Treat the lowest freq differently\n            wavelet_smooth[i, :] = wavelet[i, :] / np.sqrt(vr[i])\n        else:\n            wavelet_smooth[i, :] = wavelet[i, :]\n\n    outsignal = np.sum(wavelet_smooth, 0)\n\n    try:  # See if there's an index already, if so, return as a pandas Series\n        smoothed = pd.Series(outsignal, index=clearsky_index.index)\n    except AttributeError:\n        smoothed = outsignal  # just output the numpy signal\n\n    return smoothed, wavelet, tmscales\n", "tokens": ["pvlib", "scaling", "py", "def", "wvm", "clearsky_index", "positions", "cloud_speed", "dt", "none", "compute", "spatial", "aggregation", "time", "series", "smoothing", "on", "clear", "sky", "index", "based", "on", "the", "wavelet", "variability", "model", "of", "lave", "et", "al", "1", "_", "2", "_", "implementation", "is", "basically", "a", "port", "of", "the", "matlab", "version", "of", "the", "code", "3", "_", "parameters", "clearsky_index", "numeric", "or", "pandas", "series", "clear", "sky", "index", "time", "series", "that", "will", "be", "smoothed", "positions", "numeric", "array", "of", "coordinate", "distances", "as", "x", "y", "pairs", "representing", "the", "easting", "northing", "of", "the", "site", "positions", "in", "meters", "m", "distributed", "plants", "could", "be", "simulated", "by", "gridded", "points", "throughout", "the", "plant", "footprint", "cloud_speed", "numeric", "speed", "of", "cloud", "movement", "in", "meters", "per", "second", "m", "s", "dt", "float", "default", "none", "the", "time", "series", "time", "delta", "by", "default", "is", "inferred", "from", "the", "clearsky_index", "must", "be", "specified", "for", "a", "time", "series", "that", "doesn", "t", "include", "an", "index", "units", "of", "seconds", "s", "returns", "smoothed", "numeric", "or", "pandas", "series", "the", "clear", "sky", "index", "time", "series", "smoothed", "for", "the", "described", "plant", "wavelet", "numeric", "the", "individual", "wavelets", "for", "the", "time", "series", "before", "smoothing", "tmscales", "numeric", "the", "timescales", "associated", "with", "the", "wavelets", "in", "seconds", "s", "references", "1", "m", "lave", "j", "kleissl", "and", "j", "s", "stein", "a", "wavelet", "based", "variability", "model", "wvm", "for", "solar", "pv", "power", "plants", "ieee", "transactions", "on", "sustainable", "energy", "vol", "4", "no", "2", "pp", "501", "509", "2013", "2", "m", "lave", "and", "j", "kleissl", "cloud", "speed", "impact", "on", "solar", "variability", "scaling", "application", "to", "the", "wavelet", "variability", "model", "solar", "energy", "vol", "91", "pp", "11", "21", "2013", "3", "wavelet", "variability", "model", "matlab", "code", "https", "github", "com", "sandialabs", "wvm", "added", "by", "joe", "ranalli", "jranalli", "penn", "state", "hazleton", "2019", "wavelet", "tmscales", "_compute_wavelet", "clearsky_index", "dt", "vr", "_compute_vr", "positions", "cloud_speed", "tmscales", "scale", "each", "wavelet", "by", "vr", "eq", "7", "in", "1", "wavelet_smooth", "np", "zeros_like", "wavelet", "for", "i", "in", "np", "arange", "len", "tmscales", "if", "i", "len", "tmscales", "1", "treat", "the", "lowest", "freq", "differently", "wavelet_smooth", "i", "wavelet", "i", "np", "sqrt", "vr", "i", "else", "wavelet_smooth", "i", "wavelet", "i", "outsignal", "np", "sum", "wavelet_smooth", "0", "try", "see", "if", "there", "s", "an", "index", "already", "if", "so", "return", "as", "a", "pandas", "series", "smoothed", "pd", "series", "outsignal", "index", "clearsky_index", "index", "except", "attributeerror", "smoothed", "outsignal", "just", "output", "the", "numpy", "signal", "return", "smoothed", "wavelet", "tmscales"], "doc_len": 354}
{"doc_id": "pvlib/scaling.py::_compute_vr", "file_path": "pvlib/scaling.py", "class_name": null, "func_name": "_compute_vr", "text": "文件路径: pvlib/scaling.py\ndef _compute_vr(positions, cloud_speed, tmscales):\n    \"\"\"\n    Compute the variability reduction factors for each wavelet mode for the\n    Wavelet Variability Model [1-3].\n\n    Parameters\n    ----------\n    positions : numeric\n        Array of coordinate distances as (x,y) pairs representing the\n        easting, northing of the site positions in meters [m]. Distributed\n        plants could be simulated by gridded points throughout the plant\n        footprint.\n\n    cloud_speed : numeric\n        Speed of cloud movement in meters per second [m/s].\n\n    tmscales: numeric\n        The timescales associated with the wavelets in seconds [s].\n\n    Returns\n    -------\n    vr : numeric\n        an array of variability reduction factors for each tmscale.\n\n    References\n    ----------\n    .. [1] M. Lave, J. Kleissl and J.S. Stein. A Wavelet-Based Variability\n       Model (WVM) for Solar PV Power Plants. IEEE Transactions on Sustainable\n       Energy, vol. 4, no. 2, pp. 501-509, 2013.\n\n    .. [2] M. Lave and J. Kleissl. Cloud speed impact on solar variability\n       scaling - Application to the wavelet variability model. Solar Energy,\n       vol. 91, pp. 11-21, 2013.\n\n    .. [3] Wavelet Variability Model - Matlab Code:\n       https://github.com/sandialabs/wvm\n    \"\"\"\n\n    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2021\n\n    pos = np.array(positions)\n    dist = pdist(pos, 'euclidean')\n\n    # Find effective length of position vector, 'dist' is full pairwise\n    n_pairs = len(dist)\n\n    def fn(x):\n        return np.abs((x ** 2 - x) / 2 - n_pairs)\n\n    n_dist = np.round(scipy.optimize.fmin(fn, np.sqrt(n_pairs), disp=False))\n    # Compute VR\n    A = cloud_speed / 2  # Resultant fit for A from [2]\n    vr = np.zeros(tmscales.shape)\n    for i, tmscale in enumerate(tmscales):\n        rho = np.exp(-1 / A * dist / tmscale)  # Eq 5 from [1]\n\n        # 2*rho is because rho_ij = rho_ji. +n_dist accounts for sum(rho_ii=1)\n        denominator = 2 * np.sum(rho) + n_dist\n        vr[i] = n_dist ** 2 / denominator  # Eq 6 of [1]\n    return vr\n", "tokens": ["pvlib", "scaling", "py", "def", "_compute_vr", "positions", "cloud_speed", "tmscales", "compute", "the", "variability", "reduction", "factors", "for", "each", "wavelet", "mode", "for", "the", "wavelet", "variability", "model", "1", "3", "parameters", "positions", "numeric", "array", "of", "coordinate", "distances", "as", "x", "y", "pairs", "representing", "the", "easting", "northing", "of", "the", "site", "positions", "in", "meters", "m", "distributed", "plants", "could", "be", "simulated", "by", "gridded", "points", "throughout", "the", "plant", "footprint", "cloud_speed", "numeric", "speed", "of", "cloud", "movement", "in", "meters", "per", "second", "m", "s", "tmscales", "numeric", "the", "timescales", "associated", "with", "the", "wavelets", "in", "seconds", "s", "returns", "vr", "numeric", "an", "array", "of", "variability", "reduction", "factors", "for", "each", "tmscale", "references", "1", "m", "lave", "j", "kleissl", "and", "j", "s", "stein", "a", "wavelet", "based", "variability", "model", "wvm", "for", "solar", "pv", "power", "plants", "ieee", "transactions", "on", "sustainable", "energy", "vol", "4", "no", "2", "pp", "501", "509", "2013", "2", "m", "lave", "and", "j", "kleissl", "cloud", "speed", "impact", "on", "solar", "variability", "scaling", "application", "to", "the", "wavelet", "variability", "model", "solar", "energy", "vol", "91", "pp", "11", "21", "2013", "3", "wavelet", "variability", "model", "matlab", "code", "https", "github", "com", "sandialabs", "wvm", "added", "by", "joe", "ranalli", "jranalli", "penn", "state", "hazleton", "2021", "pos", "np", "array", "positions", "dist", "pdist", "pos", "euclidean", "find", "effective", "length", "of", "position", "vector", "dist", "is", "full", "pairwise", "n_pairs", "len", "dist", "def", "fn", "x", "return", "np", "abs", "x", "2", "x", "2", "n_pairs", "n_dist", "np", "round", "scipy", "optimize", "fmin", "fn", "np", "sqrt", "n_pairs", "disp", "false", "compute", "vr", "a", "cloud_speed", "2", "resultant", "fit", "for", "a", "from", "2", "vr", "np", "zeros", "tmscales", "shape", "for", "i", "tmscale", "in", "enumerate", "tmscales", "rho", "np", "exp", "1", "a", "dist", "tmscale", "eq", "5", "from", "1", "2", "rho", "is", "because", "rho_ij", "rho_ji", "n_dist", "accounts", "for", "sum", "rho_ii", "1", "denominator", "2", "np", "sum", "rho", "n_dist", "vr", "i", "n_dist", "2", "denominator", "eq", "6", "of", "1", "return", "vr"], "doc_len": 280}
{"doc_id": "pvlib/scaling.py::latlon_to_xy", "file_path": "pvlib/scaling.py", "class_name": null, "func_name": "latlon_to_xy", "text": "文件路径: pvlib/scaling.py\ndef latlon_to_xy(coordinates):\n    \"\"\"\n    Convert latitude and longitude in degrees to a coordinate system measured\n    in meters from zero deg latitude, zero deg longitude.\n\n    This is a convenience method to support inputs to wvm. Note that the\n    methodology used is only suitable for short distances. For conversions of\n    longer distances, users should consider use of Universal Transverse\n    Mercator (UTM) or other suitable cartographic projection. Consider\n    packages built for cartographic projection such as pyproj (e.g.\n    pyproj.transform()) [2].\n\n    Parameters\n    ----------\n\n    coordinates : numeric\n        Array or list of (latitude, longitude) coordinate pairs. Use decimal\n        degrees notation.\n\n    Returns\n    -------\n    xypos : numeric\n        Array of coordinate distances as (x,y) pairs representing the\n        easting, northing of the position in meters [m].\n\n    References\n    ----------\n    .. [1] H. Moritz. Geodetic Reference System 1980, Journal of Geodesy, vol.\n       74, no. 1, pp 128–133, 2000.\n\n    .. [2] https://pypi.org/project/pyproj/\n\n    .. [3] Wavelet Variability Model - Matlab Code:\n       https://github.com/sandialabs/wvm\n    \"\"\"\n\n    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n\n    r_earth = 6371008.7714  # mean radius of Earth, in meters\n    m_per_deg_lat = r_earth * np.pi / 180\n    try:\n        meanlat = np.mean([lat for (lat, lon) in coordinates])  # Mean latitude\n    except TypeError:  # Assume it's a single value?\n        meanlat = coordinates[0]\n    m_per_deg_lon = r_earth * np.cos(np.pi/180 * meanlat) * np.pi/180\n\n    # Conversion\n    pos = coordinates * np.array(m_per_deg_lat, m_per_deg_lon)\n\n    # reshape as (x,y) pairs to return\n    try:\n        return np.column_stack([pos[:, 1], pos[:, 0]])\n    except IndexError:  # Assume it's a single value, which has a 1D shape\n        return np.array((pos[1], pos[0]))\n", "tokens": ["pvlib", "scaling", "py", "def", "latlon_to_xy", "coordinates", "convert", "latitude", "and", "longitude", "in", "degrees", "to", "a", "coordinate", "system", "measured", "in", "meters", "from", "zero", "deg", "latitude", "zero", "deg", "longitude", "this", "is", "a", "convenience", "method", "to", "support", "inputs", "to", "wvm", "note", "that", "the", "methodology", "used", "is", "only", "suitable", "for", "short", "distances", "for", "conversions", "of", "longer", "distances", "users", "should", "consider", "use", "of", "universal", "transverse", "mercator", "utm", "or", "other", "suitable", "cartographic", "projection", "consider", "packages", "built", "for", "cartographic", "projection", "such", "as", "pyproj", "e", "g", "pyproj", "transform", "2", "parameters", "coordinates", "numeric", "array", "or", "list", "of", "latitude", "longitude", "coordinate", "pairs", "use", "decimal", "degrees", "notation", "returns", "xypos", "numeric", "array", "of", "coordinate", "distances", "as", "x", "y", "pairs", "representing", "the", "easting", "northing", "of", "the", "position", "in", "meters", "m", "references", "1", "h", "moritz", "geodetic", "reference", "system", "1980", "journal", "of", "geodesy", "vol", "74", "no", "1", "pp", "128", "133", "2000", "2", "https", "pypi", "org", "project", "pyproj", "3", "wavelet", "variability", "model", "matlab", "code", "https", "github", "com", "sandialabs", "wvm", "added", "by", "joe", "ranalli", "jranalli", "penn", "state", "hazleton", "2019", "r_earth", "6371008", "7714", "mean", "radius", "of", "earth", "in", "meters", "m_per_deg_lat", "r_earth", "np", "pi", "180", "try", "meanlat", "np", "mean", "lat", "for", "lat", "lon", "in", "coordinates", "mean", "latitude", "except", "typeerror", "assume", "it", "s", "a", "single", "value", "meanlat", "coordinates", "0", "m_per_deg_lon", "r_earth", "np", "cos", "np", "pi", "180", "meanlat", "np", "pi", "180", "conversion", "pos", "coordinates", "np", "array", "m_per_deg_lat", "m_per_deg_lon", "reshape", "as", "x", "y", "pairs", "to", "return", "try", "return", "np", "column_stack", "pos", "1", "pos", "0", "except", "indexerror", "assume", "it", "s", "a", "single", "value", "which", "has", "a", "1d", "shape", "return", "np", "array", "pos", "1", "pos", "0"], "doc_len": 251}
{"doc_id": "pvlib/scaling.py::_compute_wavelet", "file_path": "pvlib/scaling.py", "class_name": null, "func_name": "_compute_wavelet", "text": "文件路径: pvlib/scaling.py\ndef _compute_wavelet(clearsky_index, dt=None):\n    \"\"\"\n    Compute the wavelet transform on the input clear_sky time series. Uses a\n    top hat wavelet [-1,1,1,-1] shape, based on the difference of successive\n    centered moving averages. Smallest scale (filter size of 2) is a degenerate\n    case that resembles a Haar wavelet. Returns one level of approximation\n    coefficient (CAn) and n levels of detail coefficients (CD1, CD2, ...,\n    CDn-1, CDn).\n\n    Parameters\n    ----------\n    clearsky_index : numeric or pandas.Series\n        Clear Sky Index time series that will be smoothed.\n\n    dt : float, default None\n        The time series time delta. By default, is inferred from the\n        clearsky_index. Must be specified for a time series that doesn't\n        include an index. Units of seconds [s].\n\n    Returns\n    -------\n    wavelet: numeric\n        The individual wavelets for the time series. Format follows increasing\n        scale (decreasing frequency): [CD1, CD2, ..., CDn, CAn]\n\n    tmscales: numeric\n        The timescales associated with the wavelets in seconds [s]\n\n    References\n    ----------\n    .. [1] M. Lave, J. Kleissl and J.S. Stein. A Wavelet-Based Variability\n       Model (WVM) for Solar PV Power Plants. IEEE Transactions on\n       Sustainable Energy, vol. 4, no. 2, pp. 501-509, 2013.\n\n    .. [2] Wavelet Variability Model - Matlab Code:\n       https://github.com/sandialabs/wvm\n    \"\"\"\n\n    # Added by Joe Ranalli (@jranalli), Penn State Hazleton, 2019\n\n    try:  # Assume it's a pandas type\n        vals = clearsky_index.values.flatten()\n    except AttributeError:  # Assume it's a numpy type\n        vals = clearsky_index.flatten()\n        if dt is None:\n            raise ValueError(\"dt must be specified for numpy type inputs.\")\n    else:  # flatten() succeeded, thus it's a pandas type, so get its dt\n        try:  # Assume it's a time series type index\n            dt = clearsky_index.index[1] - clearsky_index.index[0]\n            dt = dt.seconds + dt.microseconds/1e6\n        except AttributeError:  # It must just be a numeric index\n            dt = (clearsky_index.index[1] - clearsky_index.index[0])\n\n    # Pad the series on both ends in time and place in a dataframe\n    cs_long = np.pad(vals, (len(vals), len(vals)), 'symmetric')\n    cs_long = pd.DataFrame(cs_long)\n\n    # Compute wavelet time scales\n    min_tmscale = np.ceil(np.log(dt)/np.log(2))  # Minimum wavelet timescale\n    max_tmscale = int(13 - min_tmscale)  # maximum wavelet timescale\n\n    tmscales = np.zeros(max_tmscale)\n    csi_mean = np.zeros([max_tmscale, len(cs_long)])\n    # Skip averaging for the 0th scale\n    csi_mean[0, :] = cs_long.values.flatten()\n    tmscales[0] = dt\n    # Loop for all time scales we will consider\n    for i in np.arange(1, max_tmscale):\n        tmscales[i] = 2**i * dt  # Wavelet integration time scale\n        intvlen = 2**i  # Wavelet integration time series interval\n        # Rolling average, retains only lower frequencies than interval\n        # Produces slightly different end effects than the MATLAB version\n        df = cs_long.rolling(window=intvlen, center=True, min_periods=1).mean()\n        # Fill nan's in both directions\n        df = df.fillna(method='bfill').fillna(method='ffill')\n        # Pop values back out of the dataframe and store\n        csi_mean[i, :] = df.values.flatten()\n        # Shift to account for different indexing in MATLAB moving average\n        csi_mean[i, :] = np.roll(csi_mean[i, :], -1)\n        csi_mean[i, -1] = csi_mean[i, -2]\n\n    # Calculate detail coefficients by difference between successive averages\n    wavelet_long = np.zeros(csi_mean.shape)\n    for i in np.arange(0, max_tmscale-1):\n        wavelet_long[i, :] = csi_mean[i, :] - csi_mean[i+1, :]\n    wavelet_long[-1, :] = csi_mean[-1, :]  # Lowest freq (CAn)\n\n    # Clip off the padding and just return the original time window\n    wavelet = np.zeros([max_tmscale, len(vals)])\n    for i in np.arange(0, max_tmscale):\n        wavelet[i, :] = wavelet_long[i, len(vals): 2*len(vals)]\n\n    return wavelet, tmscales\n", "tokens": ["pvlib", "scaling", "py", "def", "_compute_wavelet", "clearsky_index", "dt", "none", "compute", "the", "wavelet", "transform", "on", "the", "input", "clear_sky", "time", "series", "uses", "a", "top", "hat", "wavelet", "1", "1", "1", "1", "shape", "based", "on", "the", "difference", "of", "successive", "centered", "moving", "averages", "smallest", "scale", "filter", "size", "of", "2", "is", "a", "degenerate", "case", "that", "resembles", "a", "haar", "wavelet", "returns", "one", "level", "of", "approximation", "coefficient", "can", "and", "n", "levels", "of", "detail", "coefficients", "cd1", "cd2", "cdn", "1", "cdn", "parameters", "clearsky_index", "numeric", "or", "pandas", "series", "clear", "sky", "index", "time", "series", "that", "will", "be", "smoothed", "dt", "float", "default", "none", "the", "time", "series", "time", "delta", "by", "default", "is", "inferred", "from", "the", "clearsky_index", "must", "be", "specified", "for", "a", "time", "series", "that", "doesn", "t", "include", "an", "index", "units", "of", "seconds", "s", "returns", "wavelet", "numeric", "the", "individual", "wavelets", "for", "the", "time", "series", "format", "follows", "increasing", "scale", "decreasing", "frequency", "cd1", "cd2", "cdn", "can", "tmscales", "numeric", "the", "timescales", "associated", "with", "the", "wavelets", "in", "seconds", "s", "references", "1", "m", "lave", "j", "kleissl", "and", "j", "s", "stein", "a", "wavelet", "based", "variability", "model", "wvm", "for", "solar", "pv", "power", "plants", "ieee", "transactions", "on", "sustainable", "energy", "vol", "4", "no", "2", "pp", "501", "509", "2013", "2", "wavelet", "variability", "model", "matlab", "code", "https", "github", "com", "sandialabs", "wvm", "added", "by", "joe", "ranalli", "jranalli", "penn", "state", "hazleton", "2019", "try", "assume", "it", "s", "a", "pandas", "type", "vals", "clearsky_index", "values", "flatten", "except", "attributeerror", "assume", "it", "s", "a", "numpy", "type", "vals", "clearsky_index", "flatten", "if", "dt", "is", "none", "raise", "valueerror", "dt", "must", "be", "specified", "for", "numpy", "type", "inputs", "else", "flatten", "succeeded", "thus", "it", "s", "a", "pandas", "type", "so", "get", "its", "dt", "try", "assume", "it", "s", "a", "time", "series", "type", "index", "dt", "clearsky_index", "index", "1", "clearsky_index", "index", "0", "dt", "dt", "seconds", "dt", "microseconds", "1e6", "except", "attributeerror", "it", "must", "just", "be", "a", "numeric", "index", "dt", "clearsky_index", "index", "1", "clearsky_index", "index", "0", "pad", "the", "series", "on", "both", "ends", "in", "time", "and", "place", "in", "a", "dataframe", "cs_long", "np", "pad", "vals", "len", "vals", "len", "vals", "symmetric", "cs_long", "pd", "dataframe", "cs_long", "compute", "wavelet", "time", "scales", "min_tmscale", "np", "ceil", "np", "log", "dt", "np", "log", "2", "minimum", "wavelet", "timescale", "max_tmscale", "int", "13", "min_tmscale", "maximum", "wavelet", "timescale", "tmscales", "np", "zeros", "max_tmscale", "csi_mean", "np", "zeros", "max_tmscale", "len", "cs_long", "skip", "averaging", "for", "the", "0th", "scale", "csi_mean", "0", "cs_long", "values", "flatten", "tmscales", "0", "dt", "loop", "for", "all", "time", "scales", "we", "will", "consider", "for", "i", "in", "np", "arange", "1", "max_tmscale", "tmscales", "i", "2", "i", "dt", "wavelet", "integration", "time", "scale", "intvlen", "2", "i", "wavelet", "integration", "time", "series", "interval", "rolling", "average", "retains", "only", "lower", "frequencies", "than", "interval", "produces", "slightly", "different", "end", "effects", "than", "the", "matlab", "version", "df", "cs_long", "rolling", "window", "intvlen", "center", "true", "min_periods", "1", "mean", "fill", "nan", "s", "in", "both", "directions", "df", "df", "fillna", "method", "bfill", "fillna", "method", "ffill", "pop", "values", "back", "out", "of", "the", "dataframe", "and", "store", "csi_mean", "i", "df", "values", "flatten", "shift", "to", "account", "for", "different", "indexing", "in", "matlab", "moving", "average", "csi_mean", "i", "np", "roll", "csi_mean", "i", "1", "csi_mean", "i", "1", "csi_mean", "i", "2", "calculate", "detail", "coefficients", "by", "difference", "between", "successive", "averages", "wavelet_long", "np", "zeros", "csi_mean", "shape", "for", "i", "in", "np", "arange", "0", "max_tmscale", "1", "wavelet_long", "i", "csi_mean", "i", "csi_mean", "i", "1", "wavelet_long", "1", "csi_mean", "1", "lowest", "freq", "can", "clip", "off", "the", "padding", "and", "just", "return", "the", "original", "time", "window", "wavelet", "np", "zeros", "max_tmscale", "len", "vals", "for", "i", "in", "np", "arange", "0", "max_tmscale", "wavelet", "i", "wavelet_long", "i", "len", "vals", "2", "len", "vals", "return", "wavelet", "tmscales"], "doc_len": 544}
{"doc_id": "pvlib/shading.py::masking_angle", "file_path": "pvlib/shading.py", "class_name": null, "func_name": "masking_angle", "text": "文件路径: pvlib/shading.py\ndef masking_angle(surface_tilt, gcr, slant_height):\n    \"\"\"\n    The elevation angle below which diffuse irradiance is blocked.\n\n    The ``height`` parameter determines how far up the module's surface to\n    evaluate the masking angle.  The lower the point, the steeper the masking\n    angle [1]_.  SAM uses a \"worst-case\" approach where the masking angle\n    is calculated for the bottom of the array (i.e. ``slant_height=0``) [2]_.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal [degrees].\n\n    gcr : float\n        The ground coverage ratio of the array [unitless].\n\n    slant_height : numeric\n        The distance up the module's slant height to evaluate the masking\n        angle, as a fraction [0-1] of the module slant height [unitless].\n\n    Returns\n    -------\n    mask_angle : numeric\n        Angle from horizontal where diffuse light is blocked by the\n        preceding row [degrees].\n\n    See Also\n    --------\n    masking_angle_passias\n    sky_diffuse_passias\n\n    References\n    ----------\n    .. [1] D. Passias and B. Källbäck, \"Shading effects in rows of solar cell\n       panels\", Solar Cells, Volume 11, Pages 281-291.  1984.\n       DOI: 10.1016/0379-6787(84)90017-6\n    .. [2] Gilman, P. et al., (2018). \"SAM Photovoltaic Model Technical\n       Reference Update\", NREL Technical Report NREL/TP-6A20-67399.\n       Available at https://www.nrel.gov/docs/fy18osti/67399.pdf\n    \"\"\"\n    # The original equation (8 in [1]) requires pitch and collector width,\n    # but it's easy to non-dimensionalize it to make it a function of GCR\n    # by factoring out B from the argument to arctan.\n    numerator = gcr * (1 - slant_height) * sind(surface_tilt)\n    denominator = 1 - gcr * (1 - slant_height) * cosd(surface_tilt)\n    phi = np.arctan(numerator / denominator)\n    return np.degrees(phi)\n", "tokens": ["pvlib", "shading", "py", "def", "masking_angle", "surface_tilt", "gcr", "slant_height", "the", "elevation", "angle", "below", "which", "diffuse", "irradiance", "is", "blocked", "the", "height", "parameter", "determines", "how", "far", "up", "the", "module", "s", "surface", "to", "evaluate", "the", "masking", "angle", "the", "lower", "the", "point", "the", "steeper", "the", "masking", "angle", "1", "_", "sam", "uses", "a", "worst", "case", "approach", "where", "the", "masking", "angle", "is", "calculated", "for", "the", "bottom", "of", "the", "array", "i", "e", "slant_height", "0", "2", "_", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "degrees", "gcr", "float", "the", "ground", "coverage", "ratio", "of", "the", "array", "unitless", "slant_height", "numeric", "the", "distance", "up", "the", "module", "s", "slant", "height", "to", "evaluate", "the", "masking", "angle", "as", "a", "fraction", "0", "1", "of", "the", "module", "slant", "height", "unitless", "returns", "mask_angle", "numeric", "angle", "from", "horizontal", "where", "diffuse", "light", "is", "blocked", "by", "the", "preceding", "row", "degrees", "see", "also", "masking_angle_passias", "sky_diffuse_passias", "references", "1", "d", "passias", "and", "b", "k", "llb", "ck", "shading", "effects", "in", "rows", "of", "solar", "cell", "panels", "solar", "cells", "volume", "11", "pages", "281", "291", "1984", "doi", "10", "1016", "0379", "6787", "84", "90017", "6", "2", "gilman", "p", "et", "al", "2018", "sam", "photovoltaic", "model", "technical", "reference", "update", "nrel", "technical", "report", "nrel", "tp", "6a20", "67399", "available", "at", "https", "www", "nrel", "gov", "docs", "fy18osti", "67399", "pdf", "the", "original", "equation", "8", "in", "1", "requires", "pitch", "and", "collector", "width", "but", "it", "s", "easy", "to", "non", "dimensionalize", "it", "to", "make", "it", "a", "function", "of", "gcr", "by", "factoring", "out", "b", "from", "the", "argument", "to", "arctan", "numerator", "gcr", "1", "slant_height", "sind", "surface_tilt", "denominator", "1", "gcr", "1", "slant_height", "cosd", "surface_tilt", "phi", "np", "arctan", "numerator", "denominator", "return", "np", "degrees", "phi"], "doc_len": 251}
{"doc_id": "pvlib/shading.py::masking_angle_passias", "file_path": "pvlib/shading.py", "class_name": null, "func_name": "masking_angle_passias", "text": "文件路径: pvlib/shading.py\ndef masking_angle_passias(surface_tilt, gcr):\n    r\"\"\"\n    The average masking angle over the slant height of a row.\n\n    The masking angle is the angle from horizontal where the sky dome is\n    blocked by the row in front. The masking angle is larger near the lower\n    edge of a row than near the upper edge. This function calculates the\n    average masking angle as described in [1]_.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Panel tilt from horizontal [degrees].\n\n    gcr : float\n        The ground coverage ratio of the array [unitless].\n\n    Returns\n    ----------\n    mask_angle : numeric\n        Average angle from horizontal where diffuse light is blocked by the\n        preceding row [degrees].\n\n    See Also\n    --------\n    masking_angle\n    sky_diffuse_passias\n\n    Notes\n    -----\n    The pvlib-python authors believe that Eqn. 9 in [1]_ is incorrect.\n    Here we use an independent equation.  First, Eqn. 8 is non-dimensionalized\n    (recasting in terms of GCR):\n\n    .. math::\n\n        \\psi(z') = \\arctan \\left [\n            \\frac{(1 - z') \\sin \\beta}\n                 {\\mathrm{GCR}^{-1} + (z' - 1) \\cos \\beta}\n        \\right ]\n\n    Where :math:`GCR = B/C` and :math:`z' = z/B`. The average masking angle\n    :math:`\\overline{\\psi} = \\int_0^1 \\psi(z') \\mathrm{d}z'` is then\n    evaluated symbolically using Maxima (using :math:`X = 1/\\mathrm{GCR}`):\n\n    .. code-block:: none\n\n        load(scifac)    /* for the gcfac function */\n        assume(X>0, cos(beta)>0, cos(beta)-X<0);   /* X is 1/GCR */\n        gcfac(integrate(atan((1-z)*sin(beta)/(X+(z-1)*cos(beta))), z, 0, 1))\n\n    This yields the equation implemented by this function:\n\n    .. math::\n\n        \\overline{\\psi} = \\\n            &-\\frac{X}{2} \\sin\\beta \\log | 2 X \\cos\\beta - (X^2 + 1)| \\\\\n            &+ (X \\cos\\beta - 1) \\arctan \\frac{X \\cos\\beta - 1}{X \\sin\\beta} \\\\\n            &+ (1 - X \\cos\\beta) \\arctan \\frac{\\cos\\beta}{\\sin\\beta} \\\\\n            &+ X \\log X \\sin\\beta\n\n    The pvlib-python authors have validated this equation against numerical\n    integration of :math:`\\overline{\\psi} = \\int_0^1 \\psi(z') \\mathrm{d}z'`.\n\n    References\n    ----------\n    .. [1] D. Passias and B. Källbäck, \"Shading effects in rows of solar cell\n       panels\", Solar Cells, Volume 11, Pages 281-291.  1984.\n       DOI: 10.1016/0379-6787(84)90017-6\n    \"\"\"\n    # wrap it in an array so that division by zero is handled well\n    beta = np.radians(np.array(surface_tilt))\n    sin_b = np.sin(beta)\n    cos_b = np.cos(beta)\n    X = 1/gcr\n\n    with np.errstate(divide='ignore', invalid='ignore'):  # ignore beta=0\n        term1 = -X * sin_b * np.log(np.abs(2 * X * cos_b - (X**2 + 1))) / 2\n        term2 = (X * cos_b - 1) * np.arctan((X * cos_b - 1) / (X * sin_b))\n        term3 = (1 - X * cos_b) * np.arctan(cos_b / sin_b)\n        term4 = X * np.log(X) * sin_b\n\n    psi_avg = term1 + term2 + term3 + term4\n    # when beta=0, divide by zero makes psi_avg NaN.  replace with 0:\n    psi_avg = np.where(np.isfinite(psi_avg), psi_avg, 0)\n\n    if isinstance(surface_tilt, pd.Series):\n        psi_avg = pd.Series(psi_avg, index=surface_tilt.index)\n\n    return np.degrees(psi_avg)\n", "tokens": ["pvlib", "shading", "py", "def", "masking_angle_passias", "surface_tilt", "gcr", "r", "the", "average", "masking", "angle", "over", "the", "slant", "height", "of", "a", "row", "the", "masking", "angle", "is", "the", "angle", "from", "horizontal", "where", "the", "sky", "dome", "is", "blocked", "by", "the", "row", "in", "front", "the", "masking", "angle", "is", "larger", "near", "the", "lower", "edge", "of", "a", "row", "than", "near", "the", "upper", "edge", "this", "function", "calculates", "the", "average", "masking", "angle", "as", "described", "in", "1", "_", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "degrees", "gcr", "float", "the", "ground", "coverage", "ratio", "of", "the", "array", "unitless", "returns", "mask_angle", "numeric", "average", "angle", "from", "horizontal", "where", "diffuse", "light", "is", "blocked", "by", "the", "preceding", "row", "degrees", "see", "also", "masking_angle", "sky_diffuse_passias", "notes", "the", "pvlib", "python", "authors", "believe", "that", "eqn", "9", "in", "1", "_", "is", "incorrect", "here", "we", "use", "an", "independent", "equation", "first", "eqn", "8", "is", "non", "dimensionalized", "recasting", "in", "terms", "of", "gcr", "math", "psi", "z", "arctan", "left", "frac", "1", "z", "sin", "beta", "mathrm", "gcr", "1", "z", "1", "cos", "beta", "right", "where", "math", "gcr", "b", "c", "and", "math", "z", "z", "b", "the", "average", "masking", "angle", "math", "overline", "psi", "int_0", "1", "psi", "z", "mathrm", "d", "z", "is", "then", "evaluated", "symbolically", "using", "maxima", "using", "math", "x", "1", "mathrm", "gcr", "code", "block", "none", "load", "scifac", "for", "the", "gcfac", "function", "assume", "x", "0", "cos", "beta", "0", "cos", "beta", "x", "0", "x", "is", "1", "gcr", "gcfac", "integrate", "atan", "1", "z", "sin", "beta", "x", "z", "1", "cos", "beta", "z", "0", "1", "this", "yields", "the", "equation", "implemented", "by", "this", "function", "math", "overline", "psi", "frac", "x", "2", "sin", "beta", "log", "2", "x", "cos", "beta", "x", "2", "1", "x", "cos", "beta", "1", "arctan", "frac", "x", "cos", "beta", "1", "x", "sin", "beta", "1", "x", "cos", "beta", "arctan", "frac", "cos", "beta", "sin", "beta", "x", "log", "x", "sin", "beta", "the", "pvlib", "python", "authors", "have", "validated", "this", "equation", "against", "numerical", "integration", "of", "math", "overline", "psi", "int_0", "1", "psi", "z", "mathrm", "d", "z", "references", "1", "d", "passias", "and", "b", "k", "llb", "ck", "shading", "effects", "in", "rows", "of", "solar", "cell", "panels", "solar", "cells", "volume", "11", "pages", "281", "291", "1984", "doi", "10", "1016", "0379", "6787", "84", "90017", "6", "wrap", "it", "in", "an", "array", "so", "that", "division", "by", "zero", "is", "handled", "well", "beta", "np", "radians", "np", "array", "surface_tilt", "sin_b", "np", "sin", "beta", "cos_b", "np", "cos", "beta", "x", "1", "gcr", "with", "np", "errstate", "divide", "ignore", "invalid", "ignore", "ignore", "beta", "0", "term1", "x", "sin_b", "np", "log", "np", "abs", "2", "x", "cos_b", "x", "2", "1", "2", "term2", "x", "cos_b", "1", "np", "arctan", "x", "cos_b", "1", "x", "sin_b", "term3", "1", "x", "cos_b", "np", "arctan", "cos_b", "sin_b", "term4", "x", "np", "log", "x", "sin_b", "psi_avg", "term1", "term2", "term3", "term4", "when", "beta", "0", "divide", "by", "zero", "makes", "psi_avg", "nan", "replace", "with", "0", "psi_avg", "np", "where", "np", "isfinite", "psi_avg", "psi_avg", "0", "if", "isinstance", "surface_tilt", "pd", "series", "psi_avg", "pd", "series", "psi_avg", "index", "surface_tilt", "index", "return", "np", "degrees", "psi_avg"], "doc_len": 456}
{"doc_id": "pvlib/shading.py::sky_diffuse_passias", "file_path": "pvlib/shading.py", "class_name": null, "func_name": "sky_diffuse_passias", "text": "文件路径: pvlib/shading.py\ndef sky_diffuse_passias(masking_angle):\n    r\"\"\"\n    The diffuse irradiance loss caused by row-to-row sky diffuse shading.\n\n    Even when the sun is high in the sky, a row's view of the sky dome will\n    be partially blocked by the row in front. This causes a reduction in the\n    diffuse irradiance incident on the module. The reduction depends on the\n    masking angle, the elevation angle from a point on the shaded module to\n    the top of the shading row. In [1]_ the masking angle is calculated as\n    the average across the module height. SAM assumes the \"worst-case\" loss\n    where the masking angle is calculated for the bottom of the array [2]_.\n\n    This function, as in [1]_, makes the assumption that sky diffuse\n    irradiance is isotropic.\n\n    Parameters\n    ----------\n    masking_angle : numeric\n        The elevation angle below which diffuse irradiance is blocked\n        [degrees].\n\n    Returns\n    -------\n    derate : numeric\n        The fraction [0-1] of blocked sky diffuse irradiance.\n\n    See Also\n    --------\n    masking_angle\n    masking_angle_passias\n\n    References\n    ----------\n    .. [1] D. Passias and B. Källbäck, \"Shading effects in rows of solar cell\n       panels\", Solar Cells, Volume 11, Pages 281-291.  1984.\n       DOI: 10.1016/0379-6787(84)90017-6\n    .. [2] Gilman, P. et al., (2018). \"SAM Photovoltaic Model Technical\n       Reference Update\", NREL Technical Report NREL/TP-6A20-67399.\n       Available at https://www.nrel.gov/docs/fy18osti/67399.pdf\n    \"\"\"\n    return 1 - cosd(masking_angle/2)**2\n", "tokens": ["pvlib", "shading", "py", "def", "sky_diffuse_passias", "masking_angle", "r", "the", "diffuse", "irradiance", "loss", "caused", "by", "row", "to", "row", "sky", "diffuse", "shading", "even", "when", "the", "sun", "is", "high", "in", "the", "sky", "a", "row", "s", "view", "of", "the", "sky", "dome", "will", "be", "partially", "blocked", "by", "the", "row", "in", "front", "this", "causes", "a", "reduction", "in", "the", "diffuse", "irradiance", "incident", "on", "the", "module", "the", "reduction", "depends", "on", "the", "masking", "angle", "the", "elevation", "angle", "from", "a", "point", "on", "the", "shaded", "module", "to", "the", "top", "of", "the", "shading", "row", "in", "1", "_", "the", "masking", "angle", "is", "calculated", "as", "the", "average", "across", "the", "module", "height", "sam", "assumes", "the", "worst", "case", "loss", "where", "the", "masking", "angle", "is", "calculated", "for", "the", "bottom", "of", "the", "array", "2", "_", "this", "function", "as", "in", "1", "_", "makes", "the", "assumption", "that", "sky", "diffuse", "irradiance", "is", "isotropic", "parameters", "masking_angle", "numeric", "the", "elevation", "angle", "below", "which", "diffuse", "irradiance", "is", "blocked", "degrees", "returns", "derate", "numeric", "the", "fraction", "0", "1", "of", "blocked", "sky", "diffuse", "irradiance", "see", "also", "masking_angle", "masking_angle_passias", "references", "1", "d", "passias", "and", "b", "k", "llb", "ck", "shading", "effects", "in", "rows", "of", "solar", "cell", "panels", "solar", "cells", "volume", "11", "pages", "281", "291", "1984", "doi", "10", "1016", "0379", "6787", "84", "90017", "6", "2", "gilman", "p", "et", "al", "2018", "sam", "photovoltaic", "model", "technical", "reference", "update", "nrel", "technical", "report", "nrel", "tp", "6a20", "67399", "available", "at", "https", "www", "nrel", "gov", "docs", "fy18osti", "67399", "pdf", "return", "1", "cosd", "masking_angle", "2", "2"], "doc_len": 228}
{"doc_id": "pvlib/singlediode.py::estimate_voc", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "estimate_voc", "text": "文件路径: pvlib/singlediode.py\ndef estimate_voc(photocurrent, saturation_current, nNsVth):\n    \"\"\"\n    Rough estimate of open circuit voltage useful for bounding searches for\n    ``i`` of ``v`` when using :func:`~pvlib.pvsystem.singlediode`.\n\n    Parameters\n    ----------\n    photocurrent : numeric\n        photo-generated current [A]\n    saturation_current : numeric\n        diode reverse saturation current [A]\n    nNsVth : numeric\n        product of thermal voltage ``Vth`` [V], diode ideality factor ``n``,\n        and number of series cells ``Ns``\n\n    Returns\n    -------\n    numeric\n        rough estimate of open circuit voltage [V]\n\n    Notes\n    -----\n    Calculating the open circuit voltage, :math:`V_{oc}`, of an ideal device\n    with infinite shunt resistance, :math:`R_{sh} \\\\to \\\\infty`, and zero\n    series resistance, :math:`R_s = 0`, yields the following equation [1]. As\n    an estimate of :math:`V_{oc}` it is useful as an upper bound for the\n    bisection method.\n\n    .. math::\n\n        V_{oc, est}=n Ns V_{th} \\\\log \\\\left( \\\\frac{I_L}{I_0} + 1 \\\\right)\n\n    .. [1] http://www.pveducation.org/pvcdrom/open-circuit-voltage\n    \"\"\"\n\n    return nNsVth * np.log(np.asarray(photocurrent) / saturation_current + 1.0)\n", "tokens": ["pvlib", "singlediode", "py", "def", "estimate_voc", "photocurrent", "saturation_current", "nnsvth", "rough", "estimate", "of", "open", "circuit", "voltage", "useful", "for", "bounding", "searches", "for", "i", "of", "v", "when", "using", "func", "pvlib", "pvsystem", "singlediode", "parameters", "photocurrent", "numeric", "photo", "generated", "current", "a", "saturation_current", "numeric", "diode", "reverse", "saturation", "current", "a", "nnsvth", "numeric", "product", "of", "thermal", "voltage", "vth", "v", "diode", "ideality", "factor", "n", "and", "number", "of", "series", "cells", "ns", "returns", "numeric", "rough", "estimate", "of", "open", "circuit", "voltage", "v", "notes", "calculating", "the", "open", "circuit", "voltage", "math", "v_", "oc", "of", "an", "ideal", "device", "with", "infinite", "shunt", "resistance", "math", "r_", "sh", "to", "infty", "and", "zero", "series", "resistance", "math", "r_s", "0", "yields", "the", "following", "equation", "1", "as", "an", "estimate", "of", "math", "v_", "oc", "it", "is", "useful", "as", "an", "upper", "bound", "for", "the", "bisection", "method", "math", "v_", "oc", "est", "n", "ns", "v_", "th", "log", "left", "frac", "i_l", "i_0", "1", "right", "1", "http", "www", "pveducation", "org", "pvcdrom", "open", "circuit", "voltage", "return", "nnsvth", "np", "log", "np", "asarray", "photocurrent", "saturation_current", "1", "0"], "doc_len": 155}
{"doc_id": "pvlib/singlediode.py::bishop88", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "bishop88", "text": "文件路径: pvlib/singlediode.py\ndef bishop88(diode_voltage, photocurrent, saturation_current,\n             resistance_series, resistance_shunt, nNsVth, d2mutau=0,\n             NsVbi=np.Inf, breakdown_factor=0., breakdown_voltage=-5.5,\n             breakdown_exp=3.28, gradients=False):\n    r\"\"\"\n    Explicit calculation of points on the IV curve described by the single\n    diode equation.  Values are calculated as described in [1]_.\n\n    The single diode equation with recombination current and reverse bias\n    breakdown is\n\n    .. math::\n\n        I = I_{L} - I_{0} \\left (\\exp \\frac{V_{d}}{nN_{s}V_{th}} - 1 \\right )\n        - \\frac{V_{d}}{R_{sh}}\n        - \\frac{I_{L} \\frac{d^{2}}{\\mu \\tau}}{N_{s} V_{bi} - V_{d}}\n        - a \\frac{V_{d}}{R_{sh}} \\left (1 - \\frac{V_{d}}{V_{br}} \\right )^{-m}\n\n    The input `diode_voltage` must be :math:`V + I R_{s}`.\n\n\n    .. warning::\n       * Usage of ``d2mutau`` is required with PVSyst\n         coefficients for cadmium-telluride (CdTe) and amorphous-silicon\n         (a:Si) PV modules only.\n       * Do not use ``d2mutau`` with CEC coefficients.\n\n    Parameters\n    ----------\n    diode_voltage : numeric\n        diode voltage :math:`V_d` [V]\n    photocurrent : numeric\n        photo-generated current :math:`I_{L}` [A]\n    saturation_current : numeric\n        diode reverse saturation current :math:`I_{0}` [A]\n    resistance_series : numeric\n        series resistance :math:`R_{s}` [ohms]\n    resistance_shunt: numeric\n        shunt resistance :math:`R_{sh}` [ohms]\n    nNsVth : numeric\n        product of thermal voltage :math:`V_{th}` [V], diode ideality factor\n        :math:`n`, and number of series cells :math:`N_{s}` [V]\n    d2mutau : numeric, default 0\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that accounts for recombination current in the\n        intrinsic layer. The value is the ratio of intrinsic layer thickness\n        squared :math:`d^2` to the diffusion length of charge carriers\n        :math:`\\mu \\tau`. [V]\n    NsVbi : numeric, default np.inf\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that is the product of the PV module number of series\n        cells :math:`N_{s}` and the builtin voltage :math:`V_{bi}` of the\n        intrinsic layer. [V].\n    breakdown_factor : numeric, default 0\n        fraction of ohmic current involved in avalanche breakdown :math:`a`.\n        Default of 0 excludes the reverse bias term from the model. [unitless]\n    breakdown_voltage : numeric, default -5.5\n        reverse breakdown voltage of the photovoltaic junction :math:`V_{br}`\n        [V]\n    breakdown_exp : numeric, default 3.28\n        avalanche breakdown exponent :math:`m` [unitless]\n    gradients : bool\n        False returns only I, V, and P. True also returns gradients\n\n    Returns\n    -------\n    tuple\n        currents [A], voltages [V], power [W], and optionally\n        :math:`\\frac{dI}{dV_d}`, :math:`\\frac{dV}{dV_d}`,\n        :math:`\\frac{dI}{dV}`, :math:`\\frac{dP}{dV}`, and\n        :math:`\\frac{d^2 P}{dV dV_d}`\n\n    Notes\n    -----\n    The PVSyst thin-film recombination losses parameters ``d2mutau`` and\n    ``NsVbi`` should only be applied to cadmium-telluride (CdTe) and amorphous-\n    silicon (a-Si) PV modules, [2]_, [3]_. The builtin voltage :math:`V_{bi}`\n    should account for all junctions. For example: tandem and triple junction\n    cells would have builtin voltages of 1.8[V] and 2.7[V] respectively, based\n    on the default of 0.9[V] for a single junction. The parameter ``NsVbi``\n    should only account for the number of series cells in a single parallel\n    sub-string if the module has cells in parallel greater than 1.\n\n    References\n    ----------\n    .. [1] \"Computer simulation of the effects of electrical mismatches in\n       photovoltaic cell interconnection circuits\" JW Bishop, Solar Cell (1988)\n       :doi:`10.1016/0379-6787(88)90059-2`\n\n    .. [2] \"Improved equivalent circuit and Analytical Model for Amorphous\n       Silicon Solar Cells and Modules.\" J. Mertens, et al., IEEE Transactions\n       on Electron Devices, Vol 45, No 2, Feb 1998.\n       :doi:`10.1109/16.658676`\n\n    .. [3] \"Performance assessment of a simulation model for PV modules of any\n       available technology\", André Mermoud and Thibault Lejeune, 25th EUPVSEC,\n       2010\n       :doi:`10.4229/25thEUPVSEC2010-4BV.1.114`\n    \"\"\"\n    # calculate recombination loss current where d2mutau > 0\n    is_recomb = d2mutau > 0  # True where there is thin-film recombination loss\n    v_recomb = np.where(is_recomb, NsVbi - diode_voltage, np.inf)\n    i_recomb = np.where(is_recomb, photocurrent * d2mutau / v_recomb, 0)\n    # calculate temporary values to simplify calculations\n    v_star = diode_voltage / nNsVth  # non-dimensional diode voltage\n    g_sh = 1.0 / resistance_shunt  # conductance\n    if breakdown_factor > 0:  # reverse bias is considered\n        brk_term = 1 - diode_voltage / breakdown_voltage\n        brk_pwr = np.power(brk_term, -breakdown_exp)\n        i_breakdown = breakdown_factor * diode_voltage * g_sh * brk_pwr\n    else:\n        i_breakdown = 0.\n    i = (photocurrent - saturation_current * np.expm1(v_star)  # noqa: W503\n         - diode_voltage * g_sh - i_recomb - i_breakdown)   # noqa: W503\n    v = diode_voltage - i * resistance_series\n    retval = (i, v, i*v)\n    if gradients:\n        # calculate recombination loss current gradients where d2mutau > 0\n        grad_i_recomb = np.where(is_recomb, i_recomb / v_recomb, 0)\n        grad_2i_recomb = np.where(is_recomb, 2 * grad_i_recomb / v_recomb, 0)\n        g_diode = saturation_current * np.exp(v_star) / nNsVth  # conductance\n        if breakdown_factor > 0:  # reverse bias is considered\n            brk_pwr_1 = np.power(brk_term, -breakdown_exp - 1)\n            brk_pwr_2 = np.power(brk_term, -breakdown_exp - 2)\n            brk_fctr = breakdown_factor * g_sh\n            grad_i_brk = brk_fctr * (brk_pwr + diode_voltage *\n                                     -breakdown_exp * brk_pwr_1)\n            grad2i_brk = (brk_fctr * -breakdown_exp        # noqa: W503\n                          * (2 * brk_pwr_1 + diode_voltage   # noqa: W503\n                             * (-breakdown_exp - 1) * brk_pwr_2))  # noqa: W503\n        else:\n            grad_i_brk = 0.\n            grad2i_brk = 0.\n        grad_i = -g_diode - g_sh - grad_i_recomb - grad_i_brk  # di/dvd\n        grad_v = 1.0 - grad_i * resistance_series  # dv/dvd\n        # dp/dv = d(iv)/dv = v * di/dv + i\n        grad = grad_i / grad_v  # di/dv\n        grad_p = v * grad + i  # dp/dv\n        grad2i = -g_diode / nNsVth - grad_2i_recomb - grad2i_brk  # d2i/dvd\n        grad2v = -grad2i * resistance_series  # d2v/dvd\n        grad2p = (\n            grad_v * grad + v * (grad2i/grad_v - grad_i*grad2v/grad_v**2)\n            + grad_i\n        )  # d2p/dv/dvd\n        retval += (grad_i, grad_v, grad, grad_p, grad2p)\n    return retval\n", "tokens": ["pvlib", "singlediode", "py", "def", "bishop88", "diode_voltage", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "breakdown_factor", "0", "breakdown_voltage", "5", "5", "breakdown_exp", "3", "28", "gradients", "false", "r", "explicit", "calculation", "of", "points", "on", "the", "iv", "curve", "described", "by", "the", "single", "diode", "equation", "values", "are", "calculated", "as", "described", "in", "1", "_", "the", "single", "diode", "equation", "with", "recombination", "current", "and", "reverse", "bias", "breakdown", "is", "math", "i", "i_", "l", "i_", "0", "left", "exp", "frac", "v_", "d", "nn_", "s", "v_", "th", "1", "right", "frac", "v_", "d", "r_", "sh", "frac", "i_", "l", "frac", "d", "2", "mu", "tau", "n_", "s", "v_", "bi", "v_", "d", "a", "frac", "v_", "d", "r_", "sh", "left", "1", "frac", "v_", "d", "v_", "br", "right", "m", "the", "input", "diode_voltage", "must", "be", "math", "v", "i", "r_", "s", "warning", "usage", "of", "d2mutau", "is", "required", "with", "pvsyst", "coefficients", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "pv", "modules", "only", "do", "not", "use", "d2mutau", "with", "cec", "coefficients", "parameters", "diode_voltage", "numeric", "diode", "voltage", "math", "v_d", "v", "photocurrent", "numeric", "photo", "generated", "current", "math", "i_", "l", "a", "saturation_current", "numeric", "diode", "reverse", "saturation", "current", "math", "i_", "0", "a", "resistance_series", "numeric", "series", "resistance", "math", "r_", "s", "ohms", "resistance_shunt", "numeric", "shunt", "resistance", "math", "r_", "sh", "ohms", "nnsvth", "numeric", "product", "of", "thermal", "voltage", "math", "v_", "th", "v", "diode", "ideality", "factor", "math", "n", "and", "number", "of", "series", "cells", "math", "n_", "s", "v", "d2mutau", "numeric", "default", "0", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "accounts", "for", "recombination", "current", "in", "the", "intrinsic", "layer", "the", "value", "is", "the", "ratio", "of", "intrinsic", "layer", "thickness", "squared", "math", "d", "2", "to", "the", "diffusion", "length", "of", "charge", "carriers", "math", "mu", "tau", "v", "nsvbi", "numeric", "default", "np", "inf", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "is", "the", "product", "of", "the", "pv", "module", "number", "of", "series", "cells", "math", "n_", "s", "and", "the", "builtin", "voltage", "math", "v_", "bi", "of", "the", "intrinsic", "layer", "v", "breakdown_factor", "numeric", "default", "0", "fraction", "of", "ohmic", "current", "involved", "in", "avalanche", "breakdown", "math", "a", "default", "of", "0", "excludes", "the", "reverse", "bias", "term", "from", "the", "model", "unitless", "breakdown_voltage", "numeric", "default", "5", "5", "reverse", "breakdown", "voltage", "of", "the", "photovoltaic", "junction", "math", "v_", "br", "v", "breakdown_exp", "numeric", "default", "3", "28", "avalanche", "breakdown", "exponent", "math", "m", "unitless", "gradients", "bool", "false", "returns", "only", "i", "v", "and", "p", "true", "also", "returns", "gradients", "returns", "tuple", "currents", "a", "voltages", "v", "power", "w", "and", "optionally", "math", "frac", "di", "dv_d", "math", "frac", "dv", "dv_d", "math", "frac", "di", "dv", "math", "frac", "dp", "dv", "and", "math", "frac", "d", "2", "p", "dv", "dv_d", "notes", "the", "pvsyst", "thin", "film", "recombination", "losses", "parameters", "d2mutau", "and", "nsvbi", "should", "only", "be", "applied", "to", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "pv", "modules", "2", "_", "3", "_", "the", "builtin", "voltage", "math", "v_", "bi", "should", "account", "for", "all", "junctions", "for", "example", "tandem", "and", "triple", "junction", "cells", "would", "have", "builtin", "voltages", "of", "1", "8", "v", "and", "2", "7", "v", "respectively", "based", "on", "the", "default", "of", "0", "9", "v", "for", "a", "single", "junction", "the", "parameter", "nsvbi", "should", "only", "account", "for", "the", "number", "of", "series", "cells", "in", "a", "single", "parallel", "sub", "string", "if", "the", "module", "has", "cells", "in", "parallel", "greater", "than", "1", "references", "1", "computer", "simulation", "of", "the", "effects", "of", "electrical", "mismatches", "in", "photovoltaic", "cell", "interconnection", "circuits", "jw", "bishop", "solar", "cell", "1988", "doi", "10", "1016", "0379", "6787", "88", "90059", "2", "2", "improved", "equivalent", "circuit", "and", "analytical", "model", "for", "amorphous", "silicon", "solar", "cells", "and", "modules", "j", "mertens", "et", "al", "ieee", "transactions", "on", "electron", "devices", "vol", "45", "no", "2", "feb", "1998", "doi", "10", "1109", "16", "658676", "3", "performance", "assessment", "of", "a", "simulation", "model", "for", "pv", "modules", "of", "any", "available", "technology", "andr", "mermoud", "and", "thibault", "lejeune", "25th", "eupvsec", "2010", "doi", "10", "4229", "25theupvsec2010", "4bv", "1", "114", "calculate", "recombination", "loss", "current", "where", "d2mutau", "0", "is_recomb", "d2mutau", "0", "true", "where", "there", "is", "thin", "film", "recombination", "loss", "v_recomb", "np", "where", "is_recomb", "nsvbi", "diode_voltage", "np", "inf", "i_recomb", "np", "where", "is_recomb", "photocurrent", "d2mutau", "v_recomb", "0", "calculate", "temporary", "values", "to", "simplify", "calculations", "v_star", "diode_voltage", "nnsvth", "non", "dimensional", "diode", "voltage", "g_sh", "1", "0", "resistance_shunt", "conductance", "if", "breakdown_factor", "0", "reverse", "bias", "is", "considered", "brk_term", "1", "diode_voltage", "breakdown_voltage", "brk_pwr", "np", "power", "brk_term", "breakdown_exp", "i_breakdown", "breakdown_factor", "diode_voltage", "g_sh", "brk_pwr", "else", "i_breakdown", "0", "i", "photocurrent", "saturation_current", "np", "expm1", "v_star", "noqa", "w503", "diode_voltage", "g_sh", "i_recomb", "i_breakdown", "noqa", "w503", "v", "diode_voltage", "i", "resistance_series", "retval", "i", "v", "i", "v", "if", "gradients", "calculate", "recombination", "loss", "current", "gradients", "where", "d2mutau", "0", "grad_i_recomb", "np", "where", "is_recomb", "i_recomb", "v_recomb", "0", "grad_2i_recomb", "np", "where", "is_recomb", "2", "grad_i_recomb", "v_recomb", "0", "g_diode", "saturation_current", "np", "exp", "v_star", "nnsvth", "conductance", "if", "breakdown_factor", "0", "reverse", "bias", "is", "considered", "brk_pwr_1", "np", "power", "brk_term", "breakdown_exp", "1", "brk_pwr_2", "np", "power", "brk_term", "breakdown_exp", "2", "brk_fctr", "breakdown_factor", "g_sh", "grad_i_brk", "brk_fctr", "brk_pwr", "diode_voltage", "breakdown_exp", "brk_pwr_1", "grad2i_brk", "brk_fctr", "breakdown_exp", "noqa", "w503", "2", "brk_pwr_1", "diode_voltage", "noqa", "w503", "breakdown_exp", "1", "brk_pwr_2", "noqa", "w503", "else", "grad_i_brk", "0", "grad2i_brk", "0", "grad_i", "g_diode", "g_sh", "grad_i_recomb", "grad_i_brk", "di", "dvd", "grad_v", "1", "0", "grad_i", "resistance_series", "dv", "dvd", "dp", "dv", "d", "iv", "dv", "v", "di", "dv", "i", "grad", "grad_i", "grad_v", "di", "dv", "grad_p", "v", "grad", "i", "dp", "dv", "grad2i", "g_diode", "nnsvth", "grad_2i_recomb", "grad2i_brk", "d2i", "dvd", "grad2v", "grad2i", "resistance_series", "d2v", "dvd", "grad2p", "grad_v", "grad", "v", "grad2i", "grad_v", "grad_i", "grad2v", "grad_v", "2", "grad_i", "d2p", "dv", "dvd", "retval", "grad_i", "grad_v", "grad", "grad_p", "grad2p", "return", "retval"], "doc_len": 849}
{"doc_id": "pvlib/singlediode.py::bishop88_i_from_v", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "bishop88_i_from_v", "text": "文件路径: pvlib/singlediode.py\ndef bishop88_i_from_v(voltage, photocurrent, saturation_current,\n                      resistance_series, resistance_shunt, nNsVth,\n                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n                      breakdown_voltage=-5.5, breakdown_exp=3.28,\n                      method='newton'):\n    \"\"\"\n    Find current given any voltage.\n\n    Parameters\n    ----------\n    voltage : numeric\n        voltage (V) in volts [V]\n    photocurrent : numeric\n        photogenerated current (Iph or IL) [A]\n    saturation_current : numeric\n        diode dark or saturation current (Io or Isat) [A]\n    resistance_series : numeric\n        series resistance (Rs) in [Ohm]\n    resistance_shunt : numeric\n        shunt resistance (Rsh) [Ohm]\n    nNsVth : numeric\n        product of diode ideality factor (n), number of series cells (Ns), and\n        thermal voltage (Vth = k_b * T / q_e) in volts [V]\n    d2mutau : numeric, default 0\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that accounts for recombination current in the\n        intrinsic layer. The value is the ratio of intrinsic layer thickness\n        squared :math:`d^2` to the diffusion length of charge carriers\n        :math:`\\\\mu \\\\tau`. [V]\n    NsVbi : numeric, default np.inf\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that is the product of the PV module number of series\n        cells ``Ns`` and the builtin voltage ``Vbi`` of the intrinsic layer.\n        [V].\n    breakdown_factor : numeric, default 0\n        fraction of ohmic current involved in avalanche breakdown :math:`a`.\n        Default of 0 excludes the reverse bias term from the model. [unitless]\n    breakdown_voltage : numeric, default -5.5\n        reverse breakdown voltage of the photovoltaic junction :math:`V_{br}`\n        [V]\n    breakdown_exp : numeric, default 3.28\n        avalanche breakdown exponent :math:`m` [unitless]\n    method : str, default 'newton'\n       Either ``'newton'`` or ``'brentq'``. ''method'' must be ``'newton'``\n       if ``breakdown_factor`` is not 0.\n\n    Returns\n    -------\n    current : numeric\n        current (I) at the specified voltage (V). [A]\n    \"\"\"\n    # collect args\n    args = (photocurrent, saturation_current, resistance_series,\n            resistance_shunt, nNsVth, d2mutau, NsVbi,\n            breakdown_factor, breakdown_voltage, breakdown_exp)\n\n    def fv(x, v, *a):\n        # calculate voltage residual given diode voltage \"x\"\n        return bishop88(x, *a)[1] - v\n\n    if method.lower() == 'brentq':\n        # first bound the search using voc\n        voc_est = estimate_voc(photocurrent, saturation_current, nNsVth)\n\n        # brentq only works with scalar inputs, so we need a set up function\n        # and np.vectorize to repeatedly call the optimizer with the right\n        # arguments for possible array input\n        def vd_from_brent(voc, v, iph, isat, rs, rsh, gamma, d2mutau, NsVbi,\n                          breakdown_factor, breakdown_voltage, breakdown_exp):\n            return brentq(fv, 0.0, voc,\n                          args=(v, iph, isat, rs, rsh, gamma, d2mutau, NsVbi,\n                                breakdown_factor, breakdown_voltage,\n                                breakdown_exp))\n\n        vd_from_brent_vectorized = np.vectorize(vd_from_brent)\n        vd = vd_from_brent_vectorized(voc_est, voltage, *args)\n    elif method.lower() == 'newton':\n        # make sure all args are numpy arrays if max size > 1\n        # if voltage is an array, then make a copy to use for initial guess, v0\n        args, v0 = _prepare_newton_inputs((voltage,), args, voltage)\n        vd = newton(func=lambda x, *a: fv(x, voltage, *a), x0=v0,\n                    fprime=lambda x, *a: bishop88(x, *a, gradients=True)[4],\n                    args=args)\n    else:\n        raise NotImplementedError(\"Method '%s' isn't implemented\" % method)\n    return bishop88(vd, *args)[0]\n", "tokens": ["pvlib", "singlediode", "py", "def", "bishop88_i_from_v", "voltage", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "breakdown_factor", "0", "breakdown_voltage", "5", "5", "breakdown_exp", "3", "28", "method", "newton", "find", "current", "given", "any", "voltage", "parameters", "voltage", "numeric", "voltage", "v", "in", "volts", "v", "photocurrent", "numeric", "photogenerated", "current", "iph", "or", "il", "a", "saturation_current", "numeric", "diode", "dark", "or", "saturation", "current", "io", "or", "isat", "a", "resistance_series", "numeric", "series", "resistance", "rs", "in", "ohm", "resistance_shunt", "numeric", "shunt", "resistance", "rsh", "ohm", "nnsvth", "numeric", "product", "of", "diode", "ideality", "factor", "n", "number", "of", "series", "cells", "ns", "and", "thermal", "voltage", "vth", "k_b", "t", "q_e", "in", "volts", "v", "d2mutau", "numeric", "default", "0", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "accounts", "for", "recombination", "current", "in", "the", "intrinsic", "layer", "the", "value", "is", "the", "ratio", "of", "intrinsic", "layer", "thickness", "squared", "math", "d", "2", "to", "the", "diffusion", "length", "of", "charge", "carriers", "math", "mu", "tau", "v", "nsvbi", "numeric", "default", "np", "inf", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "is", "the", "product", "of", "the", "pv", "module", "number", "of", "series", "cells", "ns", "and", "the", "builtin", "voltage", "vbi", "of", "the", "intrinsic", "layer", "v", "breakdown_factor", "numeric", "default", "0", "fraction", "of", "ohmic", "current", "involved", "in", "avalanche", "breakdown", "math", "a", "default", "of", "0", "excludes", "the", "reverse", "bias", "term", "from", "the", "model", "unitless", "breakdown_voltage", "numeric", "default", "5", "5", "reverse", "breakdown", "voltage", "of", "the", "photovoltaic", "junction", "math", "v_", "br", "v", "breakdown_exp", "numeric", "default", "3", "28", "avalanche", "breakdown", "exponent", "math", "m", "unitless", "method", "str", "default", "newton", "either", "newton", "or", "brentq", "method", "must", "be", "newton", "if", "breakdown_factor", "is", "not", "0", "returns", "current", "numeric", "current", "i", "at", "the", "specified", "voltage", "v", "a", "collect", "args", "args", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "def", "fv", "x", "v", "a", "calculate", "voltage", "residual", "given", "diode", "voltage", "x", "return", "bishop88", "x", "a", "1", "v", "if", "method", "lower", "brentq", "first", "bound", "the", "search", "using", "voc", "voc_est", "estimate_voc", "photocurrent", "saturation_current", "nnsvth", "brentq", "only", "works", "with", "scalar", "inputs", "so", "we", "need", "a", "set", "up", "function", "and", "np", "vectorize", "to", "repeatedly", "call", "the", "optimizer", "with", "the", "right", "arguments", "for", "possible", "array", "input", "def", "vd_from_brent", "voc", "v", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "return", "brentq", "fv", "0", "0", "voc", "args", "v", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "vd_from_brent_vectorized", "np", "vectorize", "vd_from_brent", "vd", "vd_from_brent_vectorized", "voc_est", "voltage", "args", "elif", "method", "lower", "newton", "make", "sure", "all", "args", "are", "numpy", "arrays", "if", "max", "size", "1", "if", "voltage", "is", "an", "array", "then", "make", "a", "copy", "to", "use", "for", "initial", "guess", "v0", "args", "v0", "_prepare_newton_inputs", "voltage", "args", "voltage", "vd", "newton", "func", "lambda", "x", "a", "fv", "x", "voltage", "a", "x0", "v0", "fprime", "lambda", "x", "a", "bishop88", "x", "a", "gradients", "true", "4", "args", "args", "else", "raise", "notimplementederror", "method", "s", "isn", "t", "implemented", "method", "return", "bishop88", "vd", "args", "0"], "doc_len": 454}
{"doc_id": "pvlib/singlediode.py::bishop88_v_from_i", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "bishop88_v_from_i", "text": "文件路径: pvlib/singlediode.py\ndef bishop88_v_from_i(current, photocurrent, saturation_current,\n                      resistance_series, resistance_shunt, nNsVth,\n                      d2mutau=0, NsVbi=np.Inf, breakdown_factor=0.,\n                      breakdown_voltage=-5.5, breakdown_exp=3.28,\n                      method='newton'):\n    \"\"\"\n    Find voltage given any current.\n\n    Parameters\n    ----------\n    current : numeric\n        current (I) in amperes [A]\n    photocurrent : numeric\n        photogenerated current (Iph or IL) [A]\n    saturation_current : numeric\n        diode dark or saturation current (Io or Isat) [A]\n    resistance_series : numeric\n        series resistance (Rs) in [Ohm]\n    resistance_shunt : numeric\n        shunt resistance (Rsh) [Ohm]\n    nNsVth : numeric\n        product of diode ideality factor (n), number of series cells (Ns), and\n        thermal voltage (Vth = k_b * T / q_e) in volts [V]\n    d2mutau : numeric, default 0\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that accounts for recombination current in the\n        intrinsic layer. The value is the ratio of intrinsic layer thickness\n        squared :math:`d^2` to the diffusion length of charge carriers\n        :math:`\\\\mu \\\\tau`. [V]\n    NsVbi : numeric, default np.inf\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that is the product of the PV module number of series\n        cells ``Ns`` and the builtin voltage ``Vbi`` of the intrinsic layer.\n        [V].\n    breakdown_factor : numeric, default 0\n        fraction of ohmic current involved in avalanche breakdown :math:`a`.\n        Default of 0 excludes the reverse bias term from the model. [unitless]\n    breakdown_voltage : numeric, default -5.5\n        reverse breakdown voltage of the photovoltaic junction :math:`V_{br}`\n        [V]\n    breakdown_exp : numeric, default 3.28\n        avalanche breakdown exponent :math:`m` [unitless]\n    method : str, default 'newton'\n       Either ``'newton'`` or ``'brentq'``. ''method'' must be ``'newton'``\n       if ``breakdown_factor`` is not 0.\n\n    Returns\n    -------\n    voltage : numeric\n        voltage (V) at the specified current (I) in volts [V]\n    \"\"\"\n    # collect args\n    args = (photocurrent, saturation_current, resistance_series,\n            resistance_shunt, nNsVth, d2mutau, NsVbi, breakdown_factor,\n            breakdown_voltage, breakdown_exp)\n    # first bound the search using voc\n    voc_est = estimate_voc(photocurrent, saturation_current, nNsVth)\n\n    def fi(x, i, *a):\n        # calculate current residual given diode voltage \"x\"\n        return bishop88(x, *a)[0] - i\n\n    if method.lower() == 'brentq':\n        # brentq only works with scalar inputs, so we need a set up function\n        # and np.vectorize to repeatedly call the optimizer with the right\n        # arguments for possible array input\n        def vd_from_brent(voc, i, iph, isat, rs, rsh, gamma, d2mutau, NsVbi,\n                          breakdown_factor, breakdown_voltage, breakdown_exp):\n            return brentq(fi, 0.0, voc,\n                          args=(i, iph, isat, rs, rsh, gamma, d2mutau, NsVbi,\n                                breakdown_factor, breakdown_voltage,\n                                breakdown_exp))\n\n        vd_from_brent_vectorized = np.vectorize(vd_from_brent)\n        vd = vd_from_brent_vectorized(voc_est, current, *args)\n    elif method.lower() == 'newton':\n        # make sure all args are numpy arrays if max size > 1\n        # if voc_est is an array, then make a copy to use for initial guess, v0\n        args, v0 = _prepare_newton_inputs((current,), args, voc_est)\n        vd = newton(func=lambda x, *a: fi(x, current, *a), x0=v0,\n                    fprime=lambda x, *a: bishop88(x, *a, gradients=True)[3],\n                    args=args)\n    else:\n        raise NotImplementedError(\"Method '%s' isn't implemented\" % method)\n    return bishop88(vd, *args)[1]\n", "tokens": ["pvlib", "singlediode", "py", "def", "bishop88_v_from_i", "current", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "breakdown_factor", "0", "breakdown_voltage", "5", "5", "breakdown_exp", "3", "28", "method", "newton", "find", "voltage", "given", "any", "current", "parameters", "current", "numeric", "current", "i", "in", "amperes", "a", "photocurrent", "numeric", "photogenerated", "current", "iph", "or", "il", "a", "saturation_current", "numeric", "diode", "dark", "or", "saturation", "current", "io", "or", "isat", "a", "resistance_series", "numeric", "series", "resistance", "rs", "in", "ohm", "resistance_shunt", "numeric", "shunt", "resistance", "rsh", "ohm", "nnsvth", "numeric", "product", "of", "diode", "ideality", "factor", "n", "number", "of", "series", "cells", "ns", "and", "thermal", "voltage", "vth", "k_b", "t", "q_e", "in", "volts", "v", "d2mutau", "numeric", "default", "0", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "accounts", "for", "recombination", "current", "in", "the", "intrinsic", "layer", "the", "value", "is", "the", "ratio", "of", "intrinsic", "layer", "thickness", "squared", "math", "d", "2", "to", "the", "diffusion", "length", "of", "charge", "carriers", "math", "mu", "tau", "v", "nsvbi", "numeric", "default", "np", "inf", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "is", "the", "product", "of", "the", "pv", "module", "number", "of", "series", "cells", "ns", "and", "the", "builtin", "voltage", "vbi", "of", "the", "intrinsic", "layer", "v", "breakdown_factor", "numeric", "default", "0", "fraction", "of", "ohmic", "current", "involved", "in", "avalanche", "breakdown", "math", "a", "default", "of", "0", "excludes", "the", "reverse", "bias", "term", "from", "the", "model", "unitless", "breakdown_voltage", "numeric", "default", "5", "5", "reverse", "breakdown", "voltage", "of", "the", "photovoltaic", "junction", "math", "v_", "br", "v", "breakdown_exp", "numeric", "default", "3", "28", "avalanche", "breakdown", "exponent", "math", "m", "unitless", "method", "str", "default", "newton", "either", "newton", "or", "brentq", "method", "must", "be", "newton", "if", "breakdown_factor", "is", "not", "0", "returns", "voltage", "numeric", "voltage", "v", "at", "the", "specified", "current", "i", "in", "volts", "v", "collect", "args", "args", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "first", "bound", "the", "search", "using", "voc", "voc_est", "estimate_voc", "photocurrent", "saturation_current", "nnsvth", "def", "fi", "x", "i", "a", "calculate", "current", "residual", "given", "diode", "voltage", "x", "return", "bishop88", "x", "a", "0", "i", "if", "method", "lower", "brentq", "brentq", "only", "works", "with", "scalar", "inputs", "so", "we", "need", "a", "set", "up", "function", "and", "np", "vectorize", "to", "repeatedly", "call", "the", "optimizer", "with", "the", "right", "arguments", "for", "possible", "array", "input", "def", "vd_from_brent", "voc", "i", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "return", "brentq", "fi", "0", "0", "voc", "args", "i", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "vd_from_brent_vectorized", "np", "vectorize", "vd_from_brent", "vd", "vd_from_brent_vectorized", "voc_est", "current", "args", "elif", "method", "lower", "newton", "make", "sure", "all", "args", "are", "numpy", "arrays", "if", "max", "size", "1", "if", "voc_est", "is", "an", "array", "then", "make", "a", "copy", "to", "use", "for", "initial", "guess", "v0", "args", "v0", "_prepare_newton_inputs", "current", "args", "voc_est", "vd", "newton", "func", "lambda", "x", "a", "fi", "x", "current", "a", "x0", "v0", "fprime", "lambda", "x", "a", "bishop88", "x", "a", "gradients", "true", "3", "args", "args", "else", "raise", "notimplementederror", "method", "s", "isn", "t", "implemented", "method", "return", "bishop88", "vd", "args", "1"], "doc_len": 456}
{"doc_id": "pvlib/singlediode.py::bishop88_mpp", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "bishop88_mpp", "text": "文件路径: pvlib/singlediode.py\ndef bishop88_mpp(photocurrent, saturation_current, resistance_series,\n                 resistance_shunt, nNsVth, d2mutau=0, NsVbi=np.Inf,\n                 breakdown_factor=0., breakdown_voltage=-5.5,\n                 breakdown_exp=3.28, method='newton'):\n    \"\"\"\n    Find max power point.\n\n    Parameters\n    ----------\n    photocurrent : numeric\n        photogenerated current (Iph or IL) [A]\n    saturation_current : numeric\n        diode dark or saturation current (Io or Isat) [A]\n    resistance_series : numeric\n        series resistance (Rs) in [Ohm]\n    resistance_shunt : numeric\n        shunt resistance (Rsh) [Ohm]\n    nNsVth : numeric\n        product of diode ideality factor (n), number of series cells (Ns), and\n        thermal voltage (Vth = k_b * T / q_e) in volts [V]\n    d2mutau : numeric, default 0\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that accounts for recombination current in the\n        intrinsic layer. The value is the ratio of intrinsic layer thickness\n        squared :math:`d^2` to the diffusion length of charge carriers\n        :math:`\\\\mu \\\\tau`. [V]\n    NsVbi : numeric, default np.inf\n        PVsyst parameter for cadmium-telluride (CdTe) and amorphous-silicon\n        (a-Si) modules that is the product of the PV module number of series\n        cells ``Ns`` and the builtin voltage ``Vbi`` of the intrinsic layer.\n        [V].\n    breakdown_factor : numeric, default 0\n        fraction of ohmic current involved in avalanche breakdown :math:`a`.\n        Default of 0 excludes the reverse bias term from the model. [unitless]\n    breakdown_voltage : numeric, default -5.5\n        reverse breakdown voltage of the photovoltaic junction :math:`V_{br}`\n        [V]\n    breakdown_exp : numeric, default 3.28\n        avalanche breakdown exponent :math:`m` [unitless]\n    method : str, default 'newton'\n       Either ``'newton'`` or ``'brentq'``. ''method'' must be ``'newton'``\n       if ``breakdown_factor`` is not 0.\n\n    Returns\n    -------\n    OrderedDict or pandas.DataFrame\n        max power current ``i_mp`` [A], max power voltage ``v_mp`` [V], and\n        max power ``p_mp`` [W]\n    \"\"\"\n    # collect args\n    args = (photocurrent, saturation_current, resistance_series,\n            resistance_shunt, nNsVth, d2mutau, NsVbi, breakdown_factor,\n            breakdown_voltage, breakdown_exp)\n    # first bound the search using voc\n    voc_est = estimate_voc(photocurrent, saturation_current, nNsVth)\n\n    def fmpp(x, *a):\n        return bishop88(x, *a, gradients=True)[6]\n\n    if method.lower() == 'brentq':\n        # break out arguments for numpy.vectorize to handle broadcasting\n        vec_fun = np.vectorize(\n            lambda voc, iph, isat, rs, rsh, gamma, d2mutau, NsVbi, vbr_a, vbr,\n            vbr_exp: brentq(fmpp, 0.0, voc,\n                            args=(iph, isat, rs, rsh, gamma, d2mutau, NsVbi,\n                                  vbr_a, vbr, vbr_exp))\n        )\n        vd = vec_fun(voc_est, *args)\n    elif method.lower() == 'newton':\n        # make sure all args are numpy arrays if max size > 1\n        # if voc_est is an array, then make a copy to use for initial guess, v0\n        args, v0 = _prepare_newton_inputs((), args, voc_est)\n        vd = newton(\n            func=fmpp, x0=v0,\n            fprime=lambda x, *a: bishop88(x, *a, gradients=True)[7], args=args\n        )\n    else:\n        raise NotImplementedError(\"Method '%s' isn't implemented\" % method)\n    return bishop88(vd, *args)\n", "tokens": ["pvlib", "singlediode", "py", "def", "bishop88_mpp", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "0", "nsvbi", "np", "inf", "breakdown_factor", "0", "breakdown_voltage", "5", "5", "breakdown_exp", "3", "28", "method", "newton", "find", "max", "power", "point", "parameters", "photocurrent", "numeric", "photogenerated", "current", "iph", "or", "il", "a", "saturation_current", "numeric", "diode", "dark", "or", "saturation", "current", "io", "or", "isat", "a", "resistance_series", "numeric", "series", "resistance", "rs", "in", "ohm", "resistance_shunt", "numeric", "shunt", "resistance", "rsh", "ohm", "nnsvth", "numeric", "product", "of", "diode", "ideality", "factor", "n", "number", "of", "series", "cells", "ns", "and", "thermal", "voltage", "vth", "k_b", "t", "q_e", "in", "volts", "v", "d2mutau", "numeric", "default", "0", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "accounts", "for", "recombination", "current", "in", "the", "intrinsic", "layer", "the", "value", "is", "the", "ratio", "of", "intrinsic", "layer", "thickness", "squared", "math", "d", "2", "to", "the", "diffusion", "length", "of", "charge", "carriers", "math", "mu", "tau", "v", "nsvbi", "numeric", "default", "np", "inf", "pvsyst", "parameter", "for", "cadmium", "telluride", "cdte", "and", "amorphous", "silicon", "a", "si", "modules", "that", "is", "the", "product", "of", "the", "pv", "module", "number", "of", "series", "cells", "ns", "and", "the", "builtin", "voltage", "vbi", "of", "the", "intrinsic", "layer", "v", "breakdown_factor", "numeric", "default", "0", "fraction", "of", "ohmic", "current", "involved", "in", "avalanche", "breakdown", "math", "a", "default", "of", "0", "excludes", "the", "reverse", "bias", "term", "from", "the", "model", "unitless", "breakdown_voltage", "numeric", "default", "5", "5", "reverse", "breakdown", "voltage", "of", "the", "photovoltaic", "junction", "math", "v_", "br", "v", "breakdown_exp", "numeric", "default", "3", "28", "avalanche", "breakdown", "exponent", "math", "m", "unitless", "method", "str", "default", "newton", "either", "newton", "or", "brentq", "method", "must", "be", "newton", "if", "breakdown_factor", "is", "not", "0", "returns", "ordereddict", "or", "pandas", "dataframe", "max", "power", "current", "i_mp", "a", "max", "power", "voltage", "v_mp", "v", "and", "max", "power", "p_mp", "w", "collect", "args", "args", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "d2mutau", "nsvbi", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "first", "bound", "the", "search", "using", "voc", "voc_est", "estimate_voc", "photocurrent", "saturation_current", "nnsvth", "def", "fmpp", "x", "a", "return", "bishop88", "x", "a", "gradients", "true", "6", "if", "method", "lower", "brentq", "break", "out", "arguments", "for", "numpy", "vectorize", "to", "handle", "broadcasting", "vec_fun", "np", "vectorize", "lambda", "voc", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "vbr_a", "vbr", "vbr_exp", "brentq", "fmpp", "0", "0", "voc", "args", "iph", "isat", "rs", "rsh", "gamma", "d2mutau", "nsvbi", "vbr_a", "vbr", "vbr_exp", "vd", "vec_fun", "voc_est", "args", "elif", "method", "lower", "newton", "make", "sure", "all", "args", "are", "numpy", "arrays", "if", "max", "size", "1", "if", "voc_est", "is", "an", "array", "then", "make", "a", "copy", "to", "use", "for", "initial", "guess", "v0", "args", "v0", "_prepare_newton_inputs", "args", "voc_est", "vd", "newton", "func", "fmpp", "x0", "v0", "fprime", "lambda", "x", "a", "bishop88", "x", "a", "gradients", "true", "7", "args", "args", "else", "raise", "notimplementederror", "method", "s", "isn", "t", "implemented", "method", "return", "bishop88", "vd", "args"], "doc_len": 413}
{"doc_id": "pvlib/singlediode.py::_get_size_and_shape", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_get_size_and_shape", "text": "文件路径: pvlib/singlediode.py\ndef _get_size_and_shape(args):\n    # find the right size and shape for returns\n    size, shape = 0, None  # 0 or None both mean scalar\n    for arg in args:\n        try:\n            this_shape = arg.shape  # try to get shape\n        except AttributeError:\n            this_shape = None\n            try:\n                this_size = len(arg)  # try to get the size\n            except TypeError:\n                this_size = 0\n        else:\n            this_size = arg.size  # if it has shape then it also has size\n            if shape is None:\n                shape = this_shape  # set the shape if None\n        # update size and shape\n        if this_size > size:\n            size = this_size\n            if this_shape is not None:\n                shape = this_shape\n    return size, shape\n", "tokens": ["pvlib", "singlediode", "py", "def", "_get_size_and_shape", "args", "find", "the", "right", "size", "and", "shape", "for", "returns", "size", "shape", "0", "none", "0", "or", "none", "both", "mean", "scalar", "for", "arg", "in", "args", "try", "this_shape", "arg", "shape", "try", "to", "get", "shape", "except", "attributeerror", "this_shape", "none", "try", "this_size", "len", "arg", "try", "to", "get", "the", "size", "except", "typeerror", "this_size", "0", "else", "this_size", "arg", "size", "if", "it", "has", "shape", "then", "it", "also", "has", "size", "if", "shape", "is", "none", "shape", "this_shape", "set", "the", "shape", "if", "none", "update", "size", "and", "shape", "if", "this_size", "size", "size", "this_size", "if", "this_shape", "is", "not", "none", "shape", "this_shape", "return", "size", "shape"], "doc_len": 96}
{"doc_id": "pvlib/singlediode.py::_prepare_newton_inputs", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_prepare_newton_inputs", "text": "文件路径: pvlib/singlediode.py\ndef _prepare_newton_inputs(i_or_v_tup, args, v0):\n    # broadcast arguments for newton method\n    # the first argument should be a tuple, eg: (i,), (v,) or ()\n    size, shape = _get_size_and_shape(i_or_v_tup + args)\n    if size > 1:\n        args = [np.asarray(arg) for arg in args]\n    # newton uses initial guess for the output shape\n    # copy v0 to a new array and broadcast it to the shape of max size\n    if shape is not None:\n        v0 = np.broadcast_to(v0, shape).copy()\n    return args, v0\n", "tokens": ["pvlib", "singlediode", "py", "def", "_prepare_newton_inputs", "i_or_v_tup", "args", "v0", "broadcast", "arguments", "for", "newton", "method", "the", "first", "argument", "should", "be", "a", "tuple", "eg", "i", "v", "or", "size", "shape", "_get_size_and_shape", "i_or_v_tup", "args", "if", "size", "1", "args", "np", "asarray", "arg", "for", "arg", "in", "args", "newton", "uses", "initial", "guess", "for", "the", "output", "shape", "copy", "v0", "to", "a", "new", "array", "and", "broadcast", "it", "to", "the", "shape", "of", "max", "size", "if", "shape", "is", "not", "none", "v0", "np", "broadcast_to", "v0", "shape", "copy", "return", "args", "v0"], "doc_len": 77}
{"doc_id": "pvlib/singlediode.py::_lambertw_v_from_i", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_lambertw_v_from_i", "text": "文件路径: pvlib/singlediode.py\ndef _lambertw_v_from_i(resistance_shunt, resistance_series, nNsVth, current,\n                       saturation_current, photocurrent):\n    # Record if inputs were all scalar\n    output_is_scalar = all(map(np.isscalar,\n                               [resistance_shunt, resistance_series, nNsVth,\n                                current, saturation_current, photocurrent]))\n\n    # This transforms Gsh=1/Rsh, including ideal Rsh=np.inf into Gsh=0., which\n    #  is generally more numerically stable\n    conductance_shunt = 1. / resistance_shunt\n\n    # Ensure that we are working with read-only views of numpy arrays\n    # Turns Series into arrays so that we don't have to worry about\n    #  multidimensional broadcasting failing\n    Gsh, Rs, a, I, I0, IL = \\\n        np.broadcast_arrays(conductance_shunt, resistance_series, nNsVth,\n                            current, saturation_current, photocurrent)\n\n    # Intitalize output V (I might not be float64)\n    V = np.full_like(I, np.nan, dtype=np.float64)\n\n    # Determine indices where 0 < Gsh requires implicit model solution\n    idx_p = 0. < Gsh\n\n    # Determine indices where 0 = Gsh allows explicit model solution\n    idx_z = 0. == Gsh\n\n    # Explicit solutions where Gsh=0\n    if np.any(idx_z):\n        V[idx_z] = a[idx_z] * np.log1p((IL[idx_z] - I[idx_z]) / I0[idx_z]) - \\\n                   I[idx_z] * Rs[idx_z]\n\n    # Only compute using LambertW if there are cases with Gsh>0\n    if np.any(idx_p):\n        # LambertW argument, cannot be float128, may overflow to np.inf\n        # overflow is explicitly handled below, so ignore warnings here\n        with np.errstate(over='ignore'):\n            argW = (I0[idx_p] / (Gsh[idx_p] * a[idx_p]) *\n                    np.exp((-I[idx_p] + IL[idx_p] + I0[idx_p]) /\n                           (Gsh[idx_p] * a[idx_p])))\n\n        # lambertw typically returns complex value with zero imaginary part\n        # may overflow to np.inf\n        lambertwterm = lambertw(argW).real\n\n        # Record indices where lambertw input overflowed output\n        idx_inf = np.logical_not(np.isfinite(lambertwterm))\n\n        # Only re-compute LambertW if it overflowed\n        if np.any(idx_inf):\n            # Calculate using log(argW) in case argW is really big\n            logargW = (np.log(I0[idx_p]) - np.log(Gsh[idx_p]) -\n                       np.log(a[idx_p]) +\n                       (-I[idx_p] + IL[idx_p] + I0[idx_p]) /\n                       (Gsh[idx_p] * a[idx_p]))[idx_inf]\n\n            # Three iterations of Newton-Raphson method to solve\n            #  w+log(w)=logargW. The initial guess is w=logargW. Where direct\n            #  evaluation (above) results in NaN from overflow, 3 iterations\n            #  of Newton's method gives approximately 8 digits of precision.\n            w = logargW\n            for _ in range(0, 3):\n                w = w * (1. - np.log(w) + logargW) / (1. + w)\n            lambertwterm[idx_inf] = w\n\n        # Eqn. 3 in Jain and Kapoor, 2004\n        #  V = -I*(Rs + Rsh) + IL*Rsh - a*lambertwterm + I0*Rsh\n        # Recast in terms of Gsh=1/Rsh for better numerical stability.\n        V[idx_p] = (IL[idx_p] + I0[idx_p] - I[idx_p]) / Gsh[idx_p] - \\\n            I[idx_p] * Rs[idx_p] - a[idx_p] * lambertwterm\n\n    if output_is_scalar:\n        return V.item()\n    else:\n        return V\n", "tokens": ["pvlib", "singlediode", "py", "def", "_lambertw_v_from_i", "resistance_shunt", "resistance_series", "nnsvth", "current", "saturation_current", "photocurrent", "record", "if", "inputs", "were", "all", "scalar", "output_is_scalar", "all", "map", "np", "isscalar", "resistance_shunt", "resistance_series", "nnsvth", "current", "saturation_current", "photocurrent", "this", "transforms", "gsh", "1", "rsh", "including", "ideal", "rsh", "np", "inf", "into", "gsh", "0", "which", "is", "generally", "more", "numerically", "stable", "conductance_shunt", "1", "resistance_shunt", "ensure", "that", "we", "are", "working", "with", "read", "only", "views", "of", "numpy", "arrays", "turns", "series", "into", "arrays", "so", "that", "we", "don", "t", "have", "to", "worry", "about", "multidimensional", "broadcasting", "failing", "gsh", "rs", "a", "i", "i0", "il", "np", "broadcast_arrays", "conductance_shunt", "resistance_series", "nnsvth", "current", "saturation_current", "photocurrent", "intitalize", "output", "v", "i", "might", "not", "be", "float64", "v", "np", "full_like", "i", "np", "nan", "dtype", "np", "float64", "determine", "indices", "where", "0", "gsh", "requires", "implicit", "model", "solution", "idx_p", "0", "gsh", "determine", "indices", "where", "0", "gsh", "allows", "explicit", "model", "solution", "idx_z", "0", "gsh", "explicit", "solutions", "where", "gsh", "0", "if", "np", "any", "idx_z", "v", "idx_z", "a", "idx_z", "np", "log1p", "il", "idx_z", "i", "idx_z", "i0", "idx_z", "i", "idx_z", "rs", "idx_z", "only", "compute", "using", "lambertw", "if", "there", "are", "cases", "with", "gsh", "0", "if", "np", "any", "idx_p", "lambertw", "argument", "cannot", "be", "float128", "may", "overflow", "to", "np", "inf", "overflow", "is", "explicitly", "handled", "below", "so", "ignore", "warnings", "here", "with", "np", "errstate", "over", "ignore", "argw", "i0", "idx_p", "gsh", "idx_p", "a", "idx_p", "np", "exp", "i", "idx_p", "il", "idx_p", "i0", "idx_p", "gsh", "idx_p", "a", "idx_p", "lambertw", "typically", "returns", "complex", "value", "with", "zero", "imaginary", "part", "may", "overflow", "to", "np", "inf", "lambertwterm", "lambertw", "argw", "real", "record", "indices", "where", "lambertw", "input", "overflowed", "output", "idx_inf", "np", "logical_not", "np", "isfinite", "lambertwterm", "only", "re", "compute", "lambertw", "if", "it", "overflowed", "if", "np", "any", "idx_inf", "calculate", "using", "log", "argw", "in", "case", "argw", "is", "really", "big", "logargw", "np", "log", "i0", "idx_p", "np", "log", "gsh", "idx_p", "np", "log", "a", "idx_p", "i", "idx_p", "il", "idx_p", "i0", "idx_p", "gsh", "idx_p", "a", "idx_p", "idx_inf", "three", "iterations", "of", "newton", "raphson", "method", "to", "solve", "w", "log", "w", "logargw", "the", "initial", "guess", "is", "w", "logargw", "where", "direct", "evaluation", "above", "results", "in", "nan", "from", "overflow", "3", "iterations", "of", "newton", "s", "method", "gives", "approximately", "8", "digits", "of", "precision", "w", "logargw", "for", "_", "in", "range", "0", "3", "w", "w", "1", "np", "log", "w", "logargw", "1", "w", "lambertwterm", "idx_inf", "w", "eqn", "3", "in", "jain", "and", "kapoor", "2004", "v", "i", "rs", "rsh", "il", "rsh", "a", "lambertwterm", "i0", "rsh", "recast", "in", "terms", "of", "gsh", "1", "rsh", "for", "better", "numerical", "stability", "v", "idx_p", "il", "idx_p", "i0", "idx_p", "i", "idx_p", "gsh", "idx_p", "i", "idx_p", "rs", "idx_p", "a", "idx_p", "lambertwterm", "if", "output_is_scalar", "return", "v", "item", "else", "return", "v"], "doc_len": 404}
{"doc_id": "pvlib/singlediode.py::_lambertw_i_from_v", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_lambertw_i_from_v", "text": "文件路径: pvlib/singlediode.py\ndef _lambertw_i_from_v(resistance_shunt, resistance_series, nNsVth, voltage,\n                       saturation_current, photocurrent):\n    # Record if inputs were all scalar\n    output_is_scalar = all(map(np.isscalar,\n                               [resistance_shunt, resistance_series, nNsVth,\n                                voltage, saturation_current, photocurrent]))\n\n    # This transforms Gsh=1/Rsh, including ideal Rsh=np.inf into Gsh=0., which\n    #  is generally more numerically stable\n    conductance_shunt = 1. / resistance_shunt\n\n    # Ensure that we are working with read-only views of numpy arrays\n    # Turns Series into arrays so that we don't have to worry about\n    #  multidimensional broadcasting failing\n    Gsh, Rs, a, V, I0, IL = \\\n        np.broadcast_arrays(conductance_shunt, resistance_series, nNsVth,\n                            voltage, saturation_current, photocurrent)\n\n    # Intitalize output I (V might not be float64)\n    I = np.full_like(V, np.nan, dtype=np.float64)           # noqa: E741, N806\n\n    # Determine indices where 0 < Rs requires implicit model solution\n    idx_p = 0. < Rs\n\n    # Determine indices where 0 = Rs allows explicit model solution\n    idx_z = 0. == Rs\n\n    # Explicit solutions where Rs=0\n    if np.any(idx_z):\n        I[idx_z] = IL[idx_z] - I0[idx_z] * np.expm1(V[idx_z] / a[idx_z]) - \\\n                   Gsh[idx_z] * V[idx_z]\n\n    # Only compute using LambertW if there are cases with Rs>0\n    # Does NOT handle possibility of overflow, github issue 298\n    if np.any(idx_p):\n        # LambertW argument, cannot be float128, may overflow to np.inf\n        argW = Rs[idx_p] * I0[idx_p] / (\n                    a[idx_p] * (Rs[idx_p] * Gsh[idx_p] + 1.)) * \\\n               np.exp((Rs[idx_p] * (IL[idx_p] + I0[idx_p]) + V[idx_p]) /\n                      (a[idx_p] * (Rs[idx_p] * Gsh[idx_p] + 1.)))\n\n        # lambertw typically returns complex value with zero imaginary part\n        # may overflow to np.inf\n        lambertwterm = lambertw(argW).real\n\n        # Eqn. 2 in Jain and Kapoor, 2004\n        #  I = -V/(Rs + Rsh) - (a/Rs)*lambertwterm + Rsh*(IL + I0)/(Rs + Rsh)\n        # Recast in terms of Gsh=1/Rsh for better numerical stability.\n        I[idx_p] = (IL[idx_p] + I0[idx_p] - V[idx_p] * Gsh[idx_p]) / \\\n                   (Rs[idx_p] * Gsh[idx_p] + 1.) - (\n                               a[idx_p] / Rs[idx_p]) * lambertwterm\n\n    if output_is_scalar:\n        return I.item()\n    else:\n        return I\n", "tokens": ["pvlib", "singlediode", "py", "def", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "record", "if", "inputs", "were", "all", "scalar", "output_is_scalar", "all", "map", "np", "isscalar", "resistance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "this", "transforms", "gsh", "1", "rsh", "including", "ideal", "rsh", "np", "inf", "into", "gsh", "0", "which", "is", "generally", "more", "numerically", "stable", "conductance_shunt", "1", "resistance_shunt", "ensure", "that", "we", "are", "working", "with", "read", "only", "views", "of", "numpy", "arrays", "turns", "series", "into", "arrays", "so", "that", "we", "don", "t", "have", "to", "worry", "about", "multidimensional", "broadcasting", "failing", "gsh", "rs", "a", "v", "i0", "il", "np", "broadcast_arrays", "conductance_shunt", "resistance_series", "nnsvth", "voltage", "saturation_current", "photocurrent", "intitalize", "output", "i", "v", "might", "not", "be", "float64", "i", "np", "full_like", "v", "np", "nan", "dtype", "np", "float64", "noqa", "e741", "n806", "determine", "indices", "where", "0", "rs", "requires", "implicit", "model", "solution", "idx_p", "0", "rs", "determine", "indices", "where", "0", "rs", "allows", "explicit", "model", "solution", "idx_z", "0", "rs", "explicit", "solutions", "where", "rs", "0", "if", "np", "any", "idx_z", "i", "idx_z", "il", "idx_z", "i0", "idx_z", "np", "expm1", "v", "idx_z", "a", "idx_z", "gsh", "idx_z", "v", "idx_z", "only", "compute", "using", "lambertw", "if", "there", "are", "cases", "with", "rs", "0", "does", "not", "handle", "possibility", "of", "overflow", "github", "issue", "298", "if", "np", "any", "idx_p", "lambertw", "argument", "cannot", "be", "float128", "may", "overflow", "to", "np", "inf", "argw", "rs", "idx_p", "i0", "idx_p", "a", "idx_p", "rs", "idx_p", "gsh", "idx_p", "1", "np", "exp", "rs", "idx_p", "il", "idx_p", "i0", "idx_p", "v", "idx_p", "a", "idx_p", "rs", "idx_p", "gsh", "idx_p", "1", "lambertw", "typically", "returns", "complex", "value", "with", "zero", "imaginary", "part", "may", "overflow", "to", "np", "inf", "lambertwterm", "lambertw", "argw", "real", "eqn", "2", "in", "jain", "and", "kapoor", "2004", "i", "v", "rs", "rsh", "a", "rs", "lambertwterm", "rsh", "il", "i0", "rs", "rsh", "recast", "in", "terms", "of", "gsh", "1", "rsh", "for", "better", "numerical", "stability", "i", "idx_p", "il", "idx_p", "i0", "idx_p", "v", "idx_p", "gsh", "idx_p", "rs", "idx_p", "gsh", "idx_p", "1", "a", "idx_p", "rs", "idx_p", "lambertwterm", "if", "output_is_scalar", "return", "i", "item", "else", "return", "i"], "doc_len": 300}
{"doc_id": "pvlib/singlediode.py::_lambertw", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_lambertw", "text": "文件路径: pvlib/singlediode.py\ndef _lambertw(photocurrent, saturation_current, resistance_series,\n              resistance_shunt, nNsVth, ivcurve_pnts=None):\n    # Compute short circuit current\n    i_sc = _lambertw_i_from_v(resistance_shunt, resistance_series, nNsVth, 0.,\n                              saturation_current, photocurrent)\n\n    # Compute open circuit voltage\n    v_oc = _lambertw_v_from_i(resistance_shunt, resistance_series, nNsVth, 0.,\n                              saturation_current, photocurrent)\n\n    params = {'r_sh': resistance_shunt,\n              'r_s': resistance_series,\n              'nNsVth': nNsVth,\n              'i_0': saturation_current,\n              'i_l': photocurrent}\n\n    # Find the voltage, v_mp, where the power is maximized.\n    # Start the golden section search at v_oc * 1.14\n    p_mp, v_mp = _golden_sect_DataFrame(params, 0., v_oc * 1.14,\n                                        _pwr_optfcn)\n\n    # Find Imp using Lambert W\n    i_mp = _lambertw_i_from_v(resistance_shunt, resistance_series, nNsVth,\n                              v_mp, saturation_current, photocurrent)\n\n    # Find Ix and Ixx using Lambert W\n    i_x = _lambertw_i_from_v(resistance_shunt, resistance_series, nNsVth,\n                             0.5 * v_oc, saturation_current, photocurrent)\n\n    i_xx = _lambertw_i_from_v(resistance_shunt, resistance_series, nNsVth,\n                              0.5 * (v_oc + v_mp), saturation_current,\n                              photocurrent)\n\n    out = (i_sc, v_oc, i_mp, v_mp, p_mp, i_x, i_xx)\n\n    # create ivcurve\n    if ivcurve_pnts:\n        ivcurve_v = (np.asarray(v_oc)[..., np.newaxis] *\n                     np.linspace(0, 1, ivcurve_pnts))\n\n        ivcurve_i = _lambertw_i_from_v(resistance_shunt, resistance_series,\n                                       nNsVth, ivcurve_v.T, saturation_current,\n                                       photocurrent).T\n\n        out += (ivcurve_i, ivcurve_v)\n\n    return out\n", "tokens": ["pvlib", "singlediode", "py", "def", "_lambertw", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "ivcurve_pnts", "none", "compute", "short", "circuit", "current", "i_sc", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "0", "saturation_current", "photocurrent", "compute", "open", "circuit", "voltage", "v_oc", "_lambertw_v_from_i", "resistance_shunt", "resistance_series", "nnsvth", "0", "saturation_current", "photocurrent", "params", "r_sh", "resistance_shunt", "r_s", "resistance_series", "nnsvth", "nnsvth", "i_0", "saturation_current", "i_l", "photocurrent", "find", "the", "voltage", "v_mp", "where", "the", "power", "is", "maximized", "start", "the", "golden", "section", "search", "at", "v_oc", "1", "14", "p_mp", "v_mp", "_golden_sect_dataframe", "params", "0", "v_oc", "1", "14", "_pwr_optfcn", "find", "imp", "using", "lambert", "w", "i_mp", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "v_mp", "saturation_current", "photocurrent", "find", "ix", "and", "ixx", "using", "lambert", "w", "i_x", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "0", "5", "v_oc", "saturation_current", "photocurrent", "i_xx", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "0", "5", "v_oc", "v_mp", "saturation_current", "photocurrent", "out", "i_sc", "v_oc", "i_mp", "v_mp", "p_mp", "i_x", "i_xx", "create", "ivcurve", "if", "ivcurve_pnts", "ivcurve_v", "np", "asarray", "v_oc", "np", "newaxis", "np", "linspace", "0", "1", "ivcurve_pnts", "ivcurve_i", "_lambertw_i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "ivcurve_v", "t", "saturation_current", "photocurrent", "t", "out", "ivcurve_i", "ivcurve_v", "return", "out"], "doc_len": 153}
{"doc_id": "pvlib/singlediode.py::_pwr_optfcn", "file_path": "pvlib/singlediode.py", "class_name": null, "func_name": "_pwr_optfcn", "text": "文件路径: pvlib/singlediode.py\ndef _pwr_optfcn(df, loc):\n    '''\n    Function to find power from ``i_from_v``.\n    '''\n\n    I = _lambertw_i_from_v(df['r_sh'], df['r_s'],           # noqa: E741, N806\n                           df['nNsVth'], df[loc], df['i_0'], df['i_l'])\n\n    return I * df[loc]\n", "tokens": ["pvlib", "singlediode", "py", "def", "_pwr_optfcn", "df", "loc", "function", "to", "find", "power", "from", "i_from_v", "i", "_lambertw_i_from_v", "df", "r_sh", "df", "r_s", "noqa", "e741", "n806", "df", "nnsvth", "df", "loc", "df", "i_0", "df", "i_l", "return", "i", "df", "loc"], "doc_len": 34}
{"doc_id": "pvlib/snow.py::_time_delta_in_hours", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "_time_delta_in_hours", "text": "文件路径: pvlib/snow.py\ndef _time_delta_in_hours(times):\n    delta = times.to_series().diff()\n    return delta.dt.total_seconds().div(3600)\n", "tokens": ["pvlib", "snow", "py", "def", "_time_delta_in_hours", "times", "delta", "times", "to_series", "diff", "return", "delta", "dt", "total_seconds", "div", "3600"], "doc_len": 16}
{"doc_id": "pvlib/snow.py::fully_covered_nrel", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "fully_covered_nrel", "text": "文件路径: pvlib/snow.py\ndef fully_covered_nrel(snowfall, threshold_snowfall=1.):\n    '''\n    Calculates the timesteps when the row's slant height is fully covered\n    by snow.\n\n    Parameters\n    ----------\n    snowfall : Series\n        Accumulated snowfall in each time period [cm]\n\n    threshold_snowfall : float, default 1.0\n        Hourly snowfall above which snow coverage is set to the row's slant\n        height. [cm/hr]\n\n    Returns\n    ----------\n    boolean: Series\n        True where the snowfall exceeds the defined threshold to fully cover\n        the panel.\n\n    Notes\n    -----\n    Implements the model described in [1]_ with minor improvements in [2]_.\n\n    References\n    ----------\n    .. [1] Marion, B.; Schaefer, R.; Caine, H.; Sanchez, G. (2013).\n       \"Measured and modeled photovoltaic system energy losses from snow for\n       Colorado and Wisconsin locations.\" Solar Energy 97; pp.112-121.\n    .. [2] Ryberg, D; Freeman, J. \"Integration, Validation, and Application\n       of a PV Snow Coverage Model in SAM\" (2017) NREL Technical Report\n       NREL/TP-6A20-68705\n    '''\n    timestep = _time_delta_in_hours(snowfall.index)\n    hourly_snow_rate = snowfall / timestep\n    # if we can infer a time frequency, use first snowfall value\n    # otherwise the first snowfall value is ignored\n    freq = pd.infer_freq(snowfall.index)\n    if freq is not None:\n        timedelta = pd.tseries.frequencies.to_offset(freq) / pd.Timedelta('1h')\n        hourly_snow_rate.iloc[0] = snowfall[0] / timedelta\n    else:  # can't infer frequency from index\n        hourly_snow_rate[0] = 0  # replaces NaN\n    return hourly_snow_rate > threshold_snowfall\n", "tokens": ["pvlib", "snow", "py", "def", "fully_covered_nrel", "snowfall", "threshold_snowfall", "1", "calculates", "the", "timesteps", "when", "the", "row", "s", "slant", "height", "is", "fully", "covered", "by", "snow", "parameters", "snowfall", "series", "accumulated", "snowfall", "in", "each", "time", "period", "cm", "threshold_snowfall", "float", "default", "1", "0", "hourly", "snowfall", "above", "which", "snow", "coverage", "is", "set", "to", "the", "row", "s", "slant", "height", "cm", "hr", "returns", "boolean", "series", "true", "where", "the", "snowfall", "exceeds", "the", "defined", "threshold", "to", "fully", "cover", "the", "panel", "notes", "implements", "the", "model", "described", "in", "1", "_", "with", "minor", "improvements", "in", "2", "_", "references", "1", "marion", "b", "schaefer", "r", "caine", "h", "sanchez", "g", "2013", "measured", "and", "modeled", "photovoltaic", "system", "energy", "losses", "from", "snow", "for", "colorado", "and", "wisconsin", "locations", "solar", "energy", "97", "pp", "112", "121", "2", "ryberg", "d", "freeman", "j", "integration", "validation", "and", "application", "of", "a", "pv", "snow", "coverage", "model", "in", "sam", "2017", "nrel", "technical", "report", "nrel", "tp", "6a20", "68705", "timestep", "_time_delta_in_hours", "snowfall", "index", "hourly_snow_rate", "snowfall", "timestep", "if", "we", "can", "infer", "a", "time", "frequency", "use", "first", "snowfall", "value", "otherwise", "the", "first", "snowfall", "value", "is", "ignored", "freq", "pd", "infer_freq", "snowfall", "index", "if", "freq", "is", "not", "none", "timedelta", "pd", "tseries", "frequencies", "to_offset", "freq", "pd", "timedelta", "1h", "hourly_snow_rate", "iloc", "0", "snowfall", "0", "timedelta", "else", "can", "t", "infer", "frequency", "from", "index", "hourly_snow_rate", "0", "0", "replaces", "nan", "return", "hourly_snow_rate", "threshold_snowfall"], "doc_len": 204}
{"doc_id": "pvlib/snow.py::coverage_nrel", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "coverage_nrel", "text": "文件路径: pvlib/snow.py\ndef coverage_nrel(snowfall, poa_irradiance, temp_air, surface_tilt,\n                  initial_coverage=0, threshold_snowfall=1.,\n                  can_slide_coefficient=-80., slide_amount_coefficient=0.197):\n    '''\n    Calculates the fraction of the slant height of a row of modules covered by\n    snow at every time step.\n\n    Implements the model described in [1]_ with minor improvements in [2]_,\n    with the change that the output is in fraction of the row's slant height\n    rather than in tenths of the row slant height. As described in [1]_, model\n    validation focused on fixed tilt systems.\n\n    Parameters\n    ----------\n    snowfall : Series\n        Accumulated snowfall within each time period. [cm]\n    poa_irradiance : Series\n        Total in-plane irradiance [W/m^2]\n    temp_air : Series\n        Ambient air temperature [C]\n    surface_tilt : numeric\n        Tilt of module's from horizontal, e.g. surface facing up = 0,\n        surface facing horizon = 90. [degrees]\n    initial_coverage : float, default 0\n        Fraction of row's slant height that is covered with snow at the\n        beginning of the simulation. [unitless]\n    threshold_snowfall : float, default 1.0\n        Hourly snowfall above which snow coverage is set to the row's slant\n        height. [cm/hr]\n    can_slide_coefficient : float, default -80.\n        Coefficient to determine if snow can slide given irradiance and air\n        temperature. [W/(m^2 C)]\n    slide_amount_coefficient : float, default 0.197\n        Coefficient to determine fraction of snow that slides off in one hour.\n        [unitless]\n\n    Returns\n    -------\n    snow_coverage : Series\n        The fraction of the slant height of a row of modules that is covered\n        by snow at each time step.\n\n    Notes\n    -----\n    In [1]_, `can_slide_coefficient` is termed `m`, and the value of\n    `slide_amount_coefficient` is given in tenths of a module's slant height.\n\n    References\n    ----------\n    .. [1] Marion, B.; Schaefer, R.; Caine, H.; Sanchez, G. (2013).\n       \"Measured and modeled photovoltaic system energy losses from snow for\n       Colorado and Wisconsin locations.\" Solar Energy 97; pp.112-121.\n    .. [2] Ryberg, D; Freeman, J. (2017). \"Integration, Validation, and\n       Application of a PV Snow Coverage Model in SAM\" NREL Technical Report\n       NREL/TP-6A20-68705\n    '''\n\n    # find times with new snowfall\n    new_snowfall = fully_covered_nrel(snowfall, threshold_snowfall)\n\n    # set up output Series\n    snow_coverage = pd.Series(np.nan, index=poa_irradiance.index)\n\n    # determine amount that snow can slide in each timestep\n    can_slide = temp_air > poa_irradiance / can_slide_coefficient\n    slide_amt = slide_amount_coefficient * sind(surface_tilt) * \\\n        _time_delta_in_hours(poa_irradiance.index)\n    slide_amt[~can_slide] = 0.\n    # don't slide during snow events\n    slide_amt[new_snowfall] = 0.\n    # don't slide in the interval preceding the snowfall data\n    slide_amt.iloc[0] = 0\n\n    # build time series of cumulative slide amounts\n    sliding_period_ID = new_snowfall.cumsum()\n    cumulative_sliding = slide_amt.groupby(sliding_period_ID).cumsum()\n\n    # set up time series of snow coverage without any sliding applied\n    snow_coverage[new_snowfall] = 1.0\n    if np.isnan(snow_coverage.iloc[0]):\n        snow_coverage.iloc[0] = initial_coverage\n    snow_coverage.ffill(inplace=True)\n    snow_coverage -= cumulative_sliding\n\n    # clean up periods where row is completely uncovered\n    return snow_coverage.clip(lower=0)\n", "tokens": ["pvlib", "snow", "py", "def", "coverage_nrel", "snowfall", "poa_irradiance", "temp_air", "surface_tilt", "initial_coverage", "0", "threshold_snowfall", "1", "can_slide_coefficient", "80", "slide_amount_coefficient", "0", "197", "calculates", "the", "fraction", "of", "the", "slant", "height", "of", "a", "row", "of", "modules", "covered", "by", "snow", "at", "every", "time", "step", "implements", "the", "model", "described", "in", "1", "_", "with", "minor", "improvements", "in", "2", "_", "with", "the", "change", "that", "the", "output", "is", "in", "fraction", "of", "the", "row", "s", "slant", "height", "rather", "than", "in", "tenths", "of", "the", "row", "slant", "height", "as", "described", "in", "1", "_", "model", "validation", "focused", "on", "fixed", "tilt", "systems", "parameters", "snowfall", "series", "accumulated", "snowfall", "within", "each", "time", "period", "cm", "poa_irradiance", "series", "total", "in", "plane", "irradiance", "w", "m", "2", "temp_air", "series", "ambient", "air", "temperature", "c", "surface_tilt", "numeric", "tilt", "of", "module", "s", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degrees", "initial_coverage", "float", "default", "0", "fraction", "of", "row", "s", "slant", "height", "that", "is", "covered", "with", "snow", "at", "the", "beginning", "of", "the", "simulation", "unitless", "threshold_snowfall", "float", "default", "1", "0", "hourly", "snowfall", "above", "which", "snow", "coverage", "is", "set", "to", "the", "row", "s", "slant", "height", "cm", "hr", "can_slide_coefficient", "float", "default", "80", "coefficient", "to", "determine", "if", "snow", "can", "slide", "given", "irradiance", "and", "air", "temperature", "w", "m", "2", "c", "slide_amount_coefficient", "float", "default", "0", "197", "coefficient", "to", "determine", "fraction", "of", "snow", "that", "slides", "off", "in", "one", "hour", "unitless", "returns", "snow_coverage", "series", "the", "fraction", "of", "the", "slant", "height", "of", "a", "row", "of", "modules", "that", "is", "covered", "by", "snow", "at", "each", "time", "step", "notes", "in", "1", "_", "can_slide_coefficient", "is", "termed", "m", "and", "the", "value", "of", "slide_amount_coefficient", "is", "given", "in", "tenths", "of", "a", "module", "s", "slant", "height", "references", "1", "marion", "b", "schaefer", "r", "caine", "h", "sanchez", "g", "2013", "measured", "and", "modeled", "photovoltaic", "system", "energy", "losses", "from", "snow", "for", "colorado", "and", "wisconsin", "locations", "solar", "energy", "97", "pp", "112", "121", "2", "ryberg", "d", "freeman", "j", "2017", "integration", "validation", "and", "application", "of", "a", "pv", "snow", "coverage", "model", "in", "sam", "nrel", "technical", "report", "nrel", "tp", "6a20", "68705", "find", "times", "with", "new", "snowfall", "new_snowfall", "fully_covered_nrel", "snowfall", "threshold_snowfall", "set", "up", "output", "series", "snow_coverage", "pd", "series", "np", "nan", "index", "poa_irradiance", "index", "determine", "amount", "that", "snow", "can", "slide", "in", "each", "timestep", "can_slide", "temp_air", "poa_irradiance", "can_slide_coefficient", "slide_amt", "slide_amount_coefficient", "sind", "surface_tilt", "_time_delta_in_hours", "poa_irradiance", "index", "slide_amt", "can_slide", "0", "don", "t", "slide", "during", "snow", "events", "slide_amt", "new_snowfall", "0", "don", "t", "slide", "in", "the", "interval", "preceding", "the", "snowfall", "data", "slide_amt", "iloc", "0", "0", "build", "time", "series", "of", "cumulative", "slide", "amounts", "sliding_period_id", "new_snowfall", "cumsum", "cumulative_sliding", "slide_amt", "groupby", "sliding_period_id", "cumsum", "set", "up", "time", "series", "of", "snow", "coverage", "without", "any", "sliding", "applied", "snow_coverage", "new_snowfall", "1", "0", "if", "np", "isnan", "snow_coverage", "iloc", "0", "snow_coverage", "iloc", "0", "initial_coverage", "snow_coverage", "ffill", "inplace", "true", "snow_coverage", "cumulative_sliding", "clean", "up", "periods", "where", "row", "is", "completely", "uncovered", "return", "snow_coverage", "clip", "lower", "0"], "doc_len": 439}
{"doc_id": "pvlib/snow.py::dc_loss_nrel", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "dc_loss_nrel", "text": "文件路径: pvlib/snow.py\ndef dc_loss_nrel(snow_coverage, num_strings):\n    '''\n    Calculates the fraction of DC capacity lost due to snow coverage.\n\n    DC capacity loss assumes that if a string is partially covered by snow,\n    the string's capacity is lost; see [1]_, Eq. 11.8.\n\n    Module orientation is accounted for by specifying the number of cell\n    strings in parallel along the slant height.\n    For example, a typical 60-cell module has 3 parallel strings, each\n    comprising 20 cells in series, with the cells arranged in 6 columns of 10\n    cells each. For a row consisting of single modules, if the module is\n    mounted in portrait orientation, i.e., the row slant height is along a\n    column of 10 cells, there is 1 string in parallel along the row slant\n    height, so `num_strings=1`. In contrast, if the module is mounted in\n    landscape orientation with the row slant height comprising 6 cells, there\n    are 3 parallel strings along the row slant height, so `num_strings=3`.\n\n    Parameters\n    ----------\n    snow_coverage : numeric\n        The fraction of row slant height covered by snow at each time step.\n\n    num_strings: int\n        The number of parallel-connected strings along a row slant height.\n\n    Returns\n    -------\n    loss : numeric\n        fraction of DC capacity loss due to snow coverage at each time step.\n\n    References\n    ----------\n    .. [1] Gilman, P. et al., (2018). \"SAM Photovoltaic Model Technical\n       Reference Update\", NREL Technical Report NREL/TP-6A20-67399.\n       Available at https://www.nrel.gov/docs/fy18osti/67399.pdf\n    '''\n    return np.ceil(snow_coverage * num_strings) / num_strings\n", "tokens": ["pvlib", "snow", "py", "def", "dc_loss_nrel", "snow_coverage", "num_strings", "calculates", "the", "fraction", "of", "dc", "capacity", "lost", "due", "to", "snow", "coverage", "dc", "capacity", "loss", "assumes", "that", "if", "a", "string", "is", "partially", "covered", "by", "snow", "the", "string", "s", "capacity", "is", "lost", "see", "1", "_", "eq", "11", "8", "module", "orientation", "is", "accounted", "for", "by", "specifying", "the", "number", "of", "cell", "strings", "in", "parallel", "along", "the", "slant", "height", "for", "example", "a", "typical", "60", "cell", "module", "has", "3", "parallel", "strings", "each", "comprising", "20", "cells", "in", "series", "with", "the", "cells", "arranged", "in", "6", "columns", "of", "10", "cells", "each", "for", "a", "row", "consisting", "of", "single", "modules", "if", "the", "module", "is", "mounted", "in", "portrait", "orientation", "i", "e", "the", "row", "slant", "height", "is", "along", "a", "column", "of", "10", "cells", "there", "is", "1", "string", "in", "parallel", "along", "the", "row", "slant", "height", "so", "num_strings", "1", "in", "contrast", "if", "the", "module", "is", "mounted", "in", "landscape", "orientation", "with", "the", "row", "slant", "height", "comprising", "6", "cells", "there", "are", "3", "parallel", "strings", "along", "the", "row", "slant", "height", "so", "num_strings", "3", "parameters", "snow_coverage", "numeric", "the", "fraction", "of", "row", "slant", "height", "covered", "by", "snow", "at", "each", "time", "step", "num_strings", "int", "the", "number", "of", "parallel", "connected", "strings", "along", "a", "row", "slant", "height", "returns", "loss", "numeric", "fraction", "of", "dc", "capacity", "loss", "due", "to", "snow", "coverage", "at", "each", "time", "step", "references", "1", "gilman", "p", "et", "al", "2018", "sam", "photovoltaic", "model", "technical", "reference", "update", "nrel", "technical", "report", "nrel", "tp", "6a20", "67399", "available", "at", "https", "www", "nrel", "gov", "docs", "fy18osti", "67399", "pdf", "return", "np", "ceil", "snow_coverage", "num_strings", "num_strings"], "doc_len": 243}
{"doc_id": "pvlib/snow.py::_townsend_effective_snow", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "_townsend_effective_snow", "text": "文件路径: pvlib/snow.py\ndef _townsend_effective_snow(snow_total, snow_events):\n    '''\n    Calculates effective snow using the total snowfall received each month and\n    the number of snowfall events each month.\n\n    Parameters\n    ----------\n    snow_total : array-like\n        Snow received each month. Referred to as S in [1]_. [cm]\n\n    snow_events : array-like\n        Number of snowfall events each month. Referred to as N in [1]_. [-]\n\n    Returns\n    -------\n    effective_snowfall : array-like\n        Effective snowfall as defined in the Townsend model. [cm]\n\n    References\n    ----------\n    .. [1] Townsend, Tim & Powers, Loren. (2011). Photovoltaics and snow: An\n       update from two winters of measurements in the SIERRA. 37th IEEE\n       Photovoltaic Specialists Conference, Seattle, WA, USA.\n       :doi:`10.1109/PVSC.2011.6186627`\n    '''\n    snow_events_no_zeros = np.maximum(snow_events, 1)\n    effective_snow = 0.5 * snow_total * (1 + 1 / snow_events_no_zeros)\n    return np.where(snow_events > 0, effective_snow, 0)\n", "tokens": ["pvlib", "snow", "py", "def", "_townsend_effective_snow", "snow_total", "snow_events", "calculates", "effective", "snow", "using", "the", "total", "snowfall", "received", "each", "month", "and", "the", "number", "of", "snowfall", "events", "each", "month", "parameters", "snow_total", "array", "like", "snow", "received", "each", "month", "referred", "to", "as", "s", "in", "1", "_", "cm", "snow_events", "array", "like", "number", "of", "snowfall", "events", "each", "month", "referred", "to", "as", "n", "in", "1", "_", "returns", "effective_snowfall", "array", "like", "effective", "snowfall", "as", "defined", "in", "the", "townsend", "model", "cm", "references", "1", "townsend", "tim", "powers", "loren", "2011", "photovoltaics", "and", "snow", "an", "update", "from", "two", "winters", "of", "measurements", "in", "the", "sierra", "37th", "ieee", "photovoltaic", "specialists", "conference", "seattle", "wa", "usa", "doi", "10", "1109", "pvsc", "2011", "6186627", "snow_events_no_zeros", "np", "maximum", "snow_events", "1", "effective_snow", "0", "5", "snow_total", "1", "1", "snow_events_no_zeros", "return", "np", "where", "snow_events", "0", "effective_snow", "0"], "doc_len": 123}
{"doc_id": "pvlib/snow.py::loss_townsend", "file_path": "pvlib/snow.py", "class_name": null, "func_name": "loss_townsend", "text": "文件路径: pvlib/snow.py\ndef loss_townsend(snow_total, snow_events, surface_tilt, relative_humidity,\n                  temp_air, poa_global, slant_height, lower_edge_height,\n                  angle_of_repose=40):\n    '''\n    Calculates monthly snow loss based on the Townsend monthly snow loss\n    model [1]_.\n\n    Parameters\n    ----------\n    snow_total : array-like\n        Snow received each month. Referred to as S in [1]_. [cm]\n\n    snow_events : array-like\n        Number of snowfall events each month. Referred to as N in [1]_. [-]\n\n    surface_tilt : float\n        Tilt angle of the array. [deg]\n\n    relative_humidity : array-like\n        Monthly average relative humidity. [%]\n\n    temp_air : array-like\n        Monthly average ambient temperature. [C]\n\n    poa_global : array-like\n        Monthly plane of array insolation. [Wh/m2]\n\n    slant_height : float\n        Row length in the slanted plane of array dimension. [m]\n\n    lower_edge_height : float\n        Distance from array lower edge to the ground. [m]\n\n    angle_of_repose : float, default 40\n        Piled snow angle, assumed to stabilize at 40°, the midpoint of\n        25°-55° avalanching slope angles. [deg]\n\n    Returns\n    -------\n    loss : array-like\n        Monthly average DC capacity loss fraction due to snow coverage.\n\n    Notes\n    -----\n    This model has not been validated for tracking arrays; however, for\n    tracking arrays [1]_ suggests using the maximum rotation angle in place\n    of ``surface_tilt``.\n\n    References\n    ----------\n    .. [1] Townsend, Tim & Powers, Loren. (2011). Photovoltaics and snow: An\n       update from two winters of measurements in the SIERRA. 37th IEEE\n       Photovoltaic Specialists Conference, Seattle, WA, USA.\n       :doi:`10.1109/PVSC.2011.6186627`\n    '''\n\n    C1 = 5.7e04\n    C2 = 0.51\n\n    snow_total_prev = np.roll(snow_total, 1)\n    snow_events_prev = np.roll(snow_events, 1)\n\n    effective_snow = _townsend_effective_snow(snow_total, snow_events)\n    effective_snow_prev = _townsend_effective_snow(\n        snow_total_prev,\n        snow_events_prev\n    )\n    effective_snow_weighted = (\n        1 / 3 * effective_snow_prev\n        + 2 / 3 * effective_snow\n    )\n    effective_snow_weighted_m = effective_snow_weighted / 100\n\n    lower_edge_height_clipped = np.maximum(lower_edge_height, 0.01)\n    gamma = (\n        slant_height\n        * effective_snow_weighted_m\n        * cosd(surface_tilt)\n        / (lower_edge_height_clipped**2 - effective_snow_weighted_m**2)\n        * 2\n        * tand(angle_of_repose)\n    )\n\n    ground_interference_term = 1 - C2 * np.exp(-gamma)\n    relative_humidity_fraction = relative_humidity / 100\n    temp_air_kelvin = temp_air + 273.15\n    effective_snow_weighted_in = effective_snow_weighted / 2.54\n    poa_global_kWh = poa_global / 1000\n\n    # Calculate Eqn. 3 in the reference.\n    # Although the reference says Eqn. 3 calculates percentage loss, the y-axis\n    # of Figure 7 indicates Eqn. 3 calculates fractional loss. Since the slope\n    # of the line in Figure 7 is the same as C1 in Eqn. 3, it is assumed that\n    # Eqn. 3 calculates fractional loss.\n    loss_fraction = (\n        C1\n        * effective_snow_weighted_in\n        * cosd(surface_tilt)**2\n        * ground_interference_term\n        * relative_humidity_fraction\n        / temp_air_kelvin**2\n        / poa_global_kWh**0.67\n    )\n\n    return np.clip(loss_fraction, 0, 1)\n", "tokens": ["pvlib", "snow", "py", "def", "loss_townsend", "snow_total", "snow_events", "surface_tilt", "relative_humidity", "temp_air", "poa_global", "slant_height", "lower_edge_height", "angle_of_repose", "40", "calculates", "monthly", "snow", "loss", "based", "on", "the", "townsend", "monthly", "snow", "loss", "model", "1", "_", "parameters", "snow_total", "array", "like", "snow", "received", "each", "month", "referred", "to", "as", "s", "in", "1", "_", "cm", "snow_events", "array", "like", "number", "of", "snowfall", "events", "each", "month", "referred", "to", "as", "n", "in", "1", "_", "surface_tilt", "float", "tilt", "angle", "of", "the", "array", "deg", "relative_humidity", "array", "like", "monthly", "average", "relative", "humidity", "temp_air", "array", "like", "monthly", "average", "ambient", "temperature", "c", "poa_global", "array", "like", "monthly", "plane", "of", "array", "insolation", "wh", "m2", "slant_height", "float", "row", "length", "in", "the", "slanted", "plane", "of", "array", "dimension", "m", "lower_edge_height", "float", "distance", "from", "array", "lower", "edge", "to", "the", "ground", "m", "angle_of_repose", "float", "default", "40", "piled", "snow", "angle", "assumed", "to", "stabilize", "at", "40", "the", "midpoint", "of", "25", "55", "avalanching", "slope", "angles", "deg", "returns", "loss", "array", "like", "monthly", "average", "dc", "capacity", "loss", "fraction", "due", "to", "snow", "coverage", "notes", "this", "model", "has", "not", "been", "validated", "for", "tracking", "arrays", "however", "for", "tracking", "arrays", "1", "_", "suggests", "using", "the", "maximum", "rotation", "angle", "in", "place", "of", "surface_tilt", "references", "1", "townsend", "tim", "powers", "loren", "2011", "photovoltaics", "and", "snow", "an", "update", "from", "two", "winters", "of", "measurements", "in", "the", "sierra", "37th", "ieee", "photovoltaic", "specialists", "conference", "seattle", "wa", "usa", "doi", "10", "1109", "pvsc", "2011", "6186627", "c1", "5", "7e04", "c2", "0", "51", "snow_total_prev", "np", "roll", "snow_total", "1", "snow_events_prev", "np", "roll", "snow_events", "1", "effective_snow", "_townsend_effective_snow", "snow_total", "snow_events", "effective_snow_prev", "_townsend_effective_snow", "snow_total_prev", "snow_events_prev", "effective_snow_weighted", "1", "3", "effective_snow_prev", "2", "3", "effective_snow", "effective_snow_weighted_m", "effective_snow_weighted", "100", "lower_edge_height_clipped", "np", "maximum", "lower_edge_height", "0", "01", "gamma", "slant_height", "effective_snow_weighted_m", "cosd", "surface_tilt", "lower_edge_height_clipped", "2", "effective_snow_weighted_m", "2", "2", "tand", "angle_of_repose", "ground_interference_term", "1", "c2", "np", "exp", "gamma", "relative_humidity_fraction", "relative_humidity", "100", "temp_air_kelvin", "temp_air", "273", "15", "effective_snow_weighted_in", "effective_snow_weighted", "2", "54", "poa_global_kwh", "poa_global", "1000", "calculate", "eqn", "3", "in", "the", "reference", "although", "the", "reference", "says", "eqn", "3", "calculates", "percentage", "loss", "the", "y", "axis", "of", "figure", "7", "indicates", "eqn", "3", "calculates", "fractional", "loss", "since", "the", "slope", "of", "the", "line", "in", "figure", "7", "is", "the", "same", "as", "c1", "in", "eqn", "3", "it", "is", "assumed", "that", "eqn", "3", "calculates", "fractional", "loss", "loss_fraction", "c1", "effective_snow_weighted_in", "cosd", "surface_tilt", "2", "ground_interference_term", "relative_humidity_fraction", "temp_air_kelvin", "2", "poa_global_kwh", "0", "67", "return", "np", "clip", "loss_fraction", "0", "1"], "doc_len": 356}
{"doc_id": "pvlib/soiling.py::hsu", "file_path": "pvlib/soiling.py", "class_name": null, "func_name": "hsu", "text": "文件路径: pvlib/soiling.py\ndef hsu(rainfall, cleaning_threshold, tilt, pm2_5, pm10,\n        depo_veloc=None, rain_accum_period=pd.Timedelta('1h')):\n    \"\"\"\n    Calculates soiling ratio given particulate and rain data using the\n    Fixed Velocity model from Humboldt State University (HSU).\n\n    The HSU soiling model [1]_ returns the soiling ratio, a value between zero\n    and one which is equivalent to (1 - transmission loss). Therefore a soiling\n    ratio of 1.0 is equivalent to zero transmission loss.\n\n    Parameters\n    ----------\n\n    rainfall : Series\n        Rain accumulated in each time period. [mm]\n\n    cleaning_threshold : float\n        Amount of rain in an accumulation period needed to clean the PV\n        modules. [mm]\n\n    tilt : float\n        Tilt of the PV panels from horizontal. [degree]\n\n    pm2_5 : numeric\n        Concentration of airborne particulate matter (PM) with\n        aerodynamic diameter less than 2.5 microns. [g/m^3]\n\n    pm10 : numeric\n        Concentration of airborne particulate matter (PM) with\n        aerodynamicdiameter less than 10 microns. [g/m^3]\n\n    depo_veloc : dict, default {'2_5': 0.0009, '10': 0.004}\n        Deposition or settling velocity of particulates. [m/s]\n\n    rain_accum_period : Timedelta, default 1 hour\n        Period for accumulating rainfall to check against `cleaning_threshold`\n        It is recommended that `rain_accum_period` be between 1 hour and\n        24 hours.\n\n    Returns\n    -------\n    soiling_ratio : Series\n        Values between 0 and 1. Equal to 1 - transmission loss.\n\n    References\n    -----------\n    .. [1] M. Coello and L. Boyle, \"Simple Model For Predicting Time Series\n       Soiling of Photovoltaic Panels,\" in IEEE Journal of Photovoltaics.\n       doi: 10.1109/JPHOTOV.2019.2919628\n    .. [2] Atmospheric Chemistry and Physics: From Air Pollution to Climate\n       Change. J. Seinfeld and S. Pandis. Wiley and Sons 2001.\n\n    \"\"\"\n    # never use mutable input arguments\n    if depo_veloc is None:\n        depo_veloc = {'2_5': 0.0009, '10': 0.004}\n\n    # accumulate rainfall into periods for comparison with threshold\n    accum_rain = rainfall.rolling(rain_accum_period, closed='right').sum()\n    # cleaning is True for intervals with rainfall greater than threshold\n    cleaning_times = accum_rain.index[accum_rain >= cleaning_threshold]\n\n    # determine the time intervals in seconds (dt_sec)\n    dt = rainfall.index\n    # subtract shifted values from original and convert to seconds\n    dt_diff = (dt[1:] - dt[:-1]).total_seconds()\n    # ensure same number of elements in the array, assuming that the interval\n    # prior to the first value is equal in length to the first interval\n    dt_sec = np.append(dt_diff[0], dt_diff).astype('float64')\n\n    horiz_mass_rate = (\n        pm2_5 * depo_veloc['2_5'] + np.maximum(pm10 - pm2_5, 0.)\n        * depo_veloc['10']) * dt_sec\n    tilted_mass_rate = horiz_mass_rate * cosd(tilt)  # assuming no rain\n\n    # tms -> tilt_mass_rate\n    tms_cumsum = np.cumsum(tilted_mass_rate * np.ones(rainfall.shape))\n\n    mass_no_cleaning = pd.Series(index=rainfall.index, data=tms_cumsum)\n    # specify dtype so pandas doesn't assume object\n    mass_removed = pd.Series(index=rainfall.index, dtype='float64')\n    mass_removed[0] = 0.\n    mass_removed[cleaning_times] = mass_no_cleaning[cleaning_times]\n    accum_mass = mass_no_cleaning - mass_removed.ffill()\n\n    soiling_ratio = 1 - 0.3437 * erf(0.17 * accum_mass**0.8473)\n\n    return soiling_ratio\n", "tokens": ["pvlib", "soiling", "py", "def", "hsu", "rainfall", "cleaning_threshold", "tilt", "pm2_5", "pm10", "depo_veloc", "none", "rain_accum_period", "pd", "timedelta", "1h", "calculates", "soiling", "ratio", "given", "particulate", "and", "rain", "data", "using", "the", "fixed", "velocity", "model", "from", "humboldt", "state", "university", "hsu", "the", "hsu", "soiling", "model", "1", "_", "returns", "the", "soiling", "ratio", "a", "value", "between", "zero", "and", "one", "which", "is", "equivalent", "to", "1", "transmission", "loss", "therefore", "a", "soiling", "ratio", "of", "1", "0", "is", "equivalent", "to", "zero", "transmission", "loss", "parameters", "rainfall", "series", "rain", "accumulated", "in", "each", "time", "period", "mm", "cleaning_threshold", "float", "amount", "of", "rain", "in", "an", "accumulation", "period", "needed", "to", "clean", "the", "pv", "modules", "mm", "tilt", "float", "tilt", "of", "the", "pv", "panels", "from", "horizontal", "degree", "pm2_5", "numeric", "concentration", "of", "airborne", "particulate", "matter", "pm", "with", "aerodynamic", "diameter", "less", "than", "2", "5", "microns", "g", "m", "3", "pm10", "numeric", "concentration", "of", "airborne", "particulate", "matter", "pm", "with", "aerodynamicdiameter", "less", "than", "10", "microns", "g", "m", "3", "depo_veloc", "dict", "default", "2_5", "0", "0009", "10", "0", "004", "deposition", "or", "settling", "velocity", "of", "particulates", "m", "s", "rain_accum_period", "timedelta", "default", "1", "hour", "period", "for", "accumulating", "rainfall", "to", "check", "against", "cleaning_threshold", "it", "is", "recommended", "that", "rain_accum_period", "be", "between", "1", "hour", "and", "24", "hours", "returns", "soiling_ratio", "series", "values", "between", "0", "and", "1", "equal", "to", "1", "transmission", "loss", "references", "1", "m", "coello", "and", "l", "boyle", "simple", "model", "for", "predicting", "time", "series", "soiling", "of", "photovoltaic", "panels", "in", "ieee", "journal", "of", "photovoltaics", "doi", "10", "1109", "jphotov", "2019", "2919628", "2", "atmospheric", "chemistry", "and", "physics", "from", "air", "pollution", "to", "climate", "change", "j", "seinfeld", "and", "s", "pandis", "wiley", "and", "sons", "2001", "never", "use", "mutable", "input", "arguments", "if", "depo_veloc", "is", "none", "depo_veloc", "2_5", "0", "0009", "10", "0", "004", "accumulate", "rainfall", "into", "periods", "for", "comparison", "with", "threshold", "accum_rain", "rainfall", "rolling", "rain_accum_period", "closed", "right", "sum", "cleaning", "is", "true", "for", "intervals", "with", "rainfall", "greater", "than", "threshold", "cleaning_times", "accum_rain", "index", "accum_rain", "cleaning_threshold", "determine", "the", "time", "intervals", "in", "seconds", "dt_sec", "dt", "rainfall", "index", "subtract", "shifted", "values", "from", "original", "and", "convert", "to", "seconds", "dt_diff", "dt", "1", "dt", "1", "total_seconds", "ensure", "same", "number", "of", "elements", "in", "the", "array", "assuming", "that", "the", "interval", "prior", "to", "the", "first", "value", "is", "equal", "in", "length", "to", "the", "first", "interval", "dt_sec", "np", "append", "dt_diff", "0", "dt_diff", "astype", "float64", "horiz_mass_rate", "pm2_5", "depo_veloc", "2_5", "np", "maximum", "pm10", "pm2_5", "0", "depo_veloc", "10", "dt_sec", "tilted_mass_rate", "horiz_mass_rate", "cosd", "tilt", "assuming", "no", "rain", "tms", "tilt_mass_rate", "tms_cumsum", "np", "cumsum", "tilted_mass_rate", "np", "ones", "rainfall", "shape", "mass_no_cleaning", "pd", "series", "index", "rainfall", "index", "data", "tms_cumsum", "specify", "dtype", "so", "pandas", "doesn", "t", "assume", "object", "mass_removed", "pd", "series", "index", "rainfall", "index", "dtype", "float64", "mass_removed", "0", "0", "mass_removed", "cleaning_times", "mass_no_cleaning", "cleaning_times", "accum_mass", "mass_no_cleaning", "mass_removed", "ffill", "soiling_ratio", "1", "0", "3437", "erf", "0", "17", "accum_mass", "0", "8473", "return", "soiling_ratio"], "doc_len": 425}
{"doc_id": "pvlib/soiling.py::kimber", "file_path": "pvlib/soiling.py", "class_name": null, "func_name": "kimber", "text": "文件路径: pvlib/soiling.py\ndef kimber(rainfall, cleaning_threshold=6, soiling_loss_rate=0.0015,\n           grace_period=14, max_soiling=0.3, manual_wash_dates=None,\n           initial_soiling=0, rain_accum_period=24):\n    \"\"\"\n    Calculates fraction of energy lost due to soiling given rainfall data and\n    daily loss rate using the Kimber model.\n\n    Kimber soiling model [1]_ assumes soiling builds up at a daily rate unless\n    the daily rainfall is greater than a threshold. The model also assumes that\n    if daily rainfall has exceeded the threshold within a grace period, then\n    the ground is too damp to cause soiling build-up. The model also assumes\n    there is a maximum soiling build-up. Scheduled manual washes and rain\n    events are assumed to reset soiling to zero.\n\n    Parameters\n    ----------\n    rainfall: pandas.Series\n        Accumulated rainfall at the end of each time period. [mm]\n    cleaning_threshold: float, default 6\n        Amount of daily rainfall required to clean the panels. [mm]\n    soiling_loss_rate: float, default 0.0015\n        Fraction of energy lost due to one day of soiling. [unitless]\n    grace_period : int, default 14\n        Number of days after a rainfall event when it's assumed the ground is\n        damp, and so it's assumed there is no soiling. [days]\n    max_soiling : float, default 0.3\n        Maximum fraction of energy lost due to soiling. Soiling will build up\n        until this value. [unitless]\n    manual_wash_dates : sequence or None, default None\n        List or tuple of dates as Python ``datetime.date`` when the panels were\n        washed manually. Note there is no grace period after a manual wash, so\n        soiling begins to build up immediately.\n    initial_soiling : float, default 0\n        Initial fraction of energy lost due to soiling at time zero in the\n        `rainfall` series input. [unitless]\n    rain_accum_period : int, default 24\n        Period for accumulating rainfall to check against `cleaning_threshold`.\n        The Kimber model defines this period as one day. [hours]\n\n    Returns\n    -------\n    pandas.Series\n        fraction of energy lost due to soiling, has same intervals as input\n\n    Notes\n    -----\n    The soiling loss rate depends on both the geographical region and the\n    soiling environment type. Rates measured by Kimber [1]_ are summarized in\n    the following table:\n\n    ===================  =======  =========  ======================\n    Region/Environment   Rural    Suburban   Urban/Highway/Airport\n    ===================  =======  =========  ======================\n    Central Valley       0.0011   0.0019     0.0020\n    Northern CA          0.0011   0.0010     0.0016\n    Southern CA          0        0.0016     0.0019\n    Desert               0.0030   0.0030     0.0030\n    ===================  =======  =========  ======================\n\n    Rainfall thresholds and grace periods may also vary by region. Please\n    consult [1]_ for more information.\n\n    References\n    ----------\n    .. [1] \"The Effect of Soiling on Large Grid-Connected Photovoltaic Systems\n       in California and the Southwest Region of the United States,\" Adrianne\n       Kimber, et al., IEEE 4th World Conference on Photovoltaic Energy\n       Conference, 2006, :doi:`10.1109/WCPEC.2006.279690`\n    \"\"\"\n    # convert rain_accum_period to timedelta\n    rain_accum_period = datetime.timedelta(hours=rain_accum_period)\n\n    # convert grace_period to timedelta\n    grace_period = datetime.timedelta(days=grace_period)\n\n    # get indices as numpy datetime64, calculate timestep as numpy timedelta64,\n    # and convert timestep to fraction of days\n    rain_index_vals = rainfall.index.values\n    timestep_interval = (rain_index_vals[1] - rain_index_vals[0])\n    day_fraction = timestep_interval / np.timedelta64(24, 'h')\n\n    # accumulate rainfall\n    accumulated_rainfall = rainfall.rolling(\n        rain_accum_period, closed='right').sum()\n\n    # soiling rate\n    soiling = np.ones_like(rainfall.values) * soiling_loss_rate * day_fraction\n    soiling[0] = initial_soiling\n    soiling = np.cumsum(soiling)\n    soiling = pd.Series(soiling, index=rainfall.index, name='soiling')\n\n    # rainfall events that clean the panels\n    rain_events = accumulated_rainfall > cleaning_threshold\n\n    # grace periods windows during which ground is assumed damp, so no soiling\n    grace_windows = rain_events.rolling(grace_period, closed='right').sum() > 0\n\n    # clean panels by subtracting soiling for indices in grace period windows\n    cleaning = pd.Series(float('NaN'), index=rainfall.index)\n    cleaning.iloc[0] = 0.0\n    cleaning[grace_windows] = soiling[grace_windows]\n\n    # manual wash dates\n    if manual_wash_dates is not None:\n        rain_tz = rainfall.index.tz\n        # convert manual wash dates to datetime index in the timezone of rain\n        manual_wash_dates = pd.DatetimeIndex(manual_wash_dates, tz=rain_tz)\n        cleaning[manual_wash_dates] = soiling[manual_wash_dates]\n\n    # remove soiling by foward filling cleaning where NaN\n    soiling -= cleaning.ffill()\n\n    # check if soiling has reached the maximum\n    return soiling.where(soiling < max_soiling, max_soiling)\n", "tokens": ["pvlib", "soiling", "py", "def", "kimber", "rainfall", "cleaning_threshold", "6", "soiling_loss_rate", "0", "0015", "grace_period", "14", "max_soiling", "0", "3", "manual_wash_dates", "none", "initial_soiling", "0", "rain_accum_period", "24", "calculates", "fraction", "of", "energy", "lost", "due", "to", "soiling", "given", "rainfall", "data", "and", "daily", "loss", "rate", "using", "the", "kimber", "model", "kimber", "soiling", "model", "1", "_", "assumes", "soiling", "builds", "up", "at", "a", "daily", "rate", "unless", "the", "daily", "rainfall", "is", "greater", "than", "a", "threshold", "the", "model", "also", "assumes", "that", "if", "daily", "rainfall", "has", "exceeded", "the", "threshold", "within", "a", "grace", "period", "then", "the", "ground", "is", "too", "damp", "to", "cause", "soiling", "build", "up", "the", "model", "also", "assumes", "there", "is", "a", "maximum", "soiling", "build", "up", "scheduled", "manual", "washes", "and", "rain", "events", "are", "assumed", "to", "reset", "soiling", "to", "zero", "parameters", "rainfall", "pandas", "series", "accumulated", "rainfall", "at", "the", "end", "of", "each", "time", "period", "mm", "cleaning_threshold", "float", "default", "6", "amount", "of", "daily", "rainfall", "required", "to", "clean", "the", "panels", "mm", "soiling_loss_rate", "float", "default", "0", "0015", "fraction", "of", "energy", "lost", "due", "to", "one", "day", "of", "soiling", "unitless", "grace_period", "int", "default", "14", "number", "of", "days", "after", "a", "rainfall", "event", "when", "it", "s", "assumed", "the", "ground", "is", "damp", "and", "so", "it", "s", "assumed", "there", "is", "no", "soiling", "days", "max_soiling", "float", "default", "0", "3", "maximum", "fraction", "of", "energy", "lost", "due", "to", "soiling", "soiling", "will", "build", "up", "until", "this", "value", "unitless", "manual_wash_dates", "sequence", "or", "none", "default", "none", "list", "or", "tuple", "of", "dates", "as", "python", "datetime", "date", "when", "the", "panels", "were", "washed", "manually", "note", "there", "is", "no", "grace", "period", "after", "a", "manual", "wash", "so", "soiling", "begins", "to", "build", "up", "immediately", "initial_soiling", "float", "default", "0", "initial", "fraction", "of", "energy", "lost", "due", "to", "soiling", "at", "time", "zero", "in", "the", "rainfall", "series", "input", "unitless", "rain_accum_period", "int", "default", "24", "period", "for", "accumulating", "rainfall", "to", "check", "against", "cleaning_threshold", "the", "kimber", "model", "defines", "this", "period", "as", "one", "day", "hours", "returns", "pandas", "series", "fraction", "of", "energy", "lost", "due", "to", "soiling", "has", "same", "intervals", "as", "input", "notes", "the", "soiling", "loss", "rate", "depends", "on", "both", "the", "geographical", "region", "and", "the", "soiling", "environment", "type", "rates", "measured", "by", "kimber", "1", "_", "are", "summarized", "in", "the", "following", "table", "region", "environment", "rural", "suburban", "urban", "highway", "airport", "central", "valley", "0", "0011", "0", "0019", "0", "0020", "northern", "ca", "0", "0011", "0", "0010", "0", "0016", "southern", "ca", "0", "0", "0016", "0", "0019", "desert", "0", "0030", "0", "0030", "0", "0030", "rainfall", "thresholds", "and", "grace", "periods", "may", "also", "vary", "by", "region", "please", "consult", "1", "_", "for", "more", "information", "references", "1", "the", "effect", "of", "soiling", "on", "large", "grid", "connected", "photovoltaic", "systems", "in", "california", "and", "the", "southwest", "region", "of", "the", "united", "states", "adrianne", "kimber", "et", "al", "ieee", "4th", "world", "conference", "on", "photovoltaic", "energy", "conference", "2006", "doi", "10", "1109", "wcpec", "2006", "279690", "convert", "rain_accum_period", "to", "timedelta", "rain_accum_period", "datetime", "timedelta", "hours", "rain_accum_period", "convert", "grace_period", "to", "timedelta", "grace_period", "datetime", "timedelta", "days", "grace_period", "get", "indices", "as", "numpy", "datetime64", "calculate", "timestep", "as", "numpy", "timedelta64", "and", "convert", "timestep", "to", "fraction", "of", "days", "rain_index_vals", "rainfall", "index", "values", "timestep_interval", "rain_index_vals", "1", "rain_index_vals", "0", "day_fraction", "timestep_interval", "np", "timedelta64", "24", "h", "accumulate", "rainfall", "accumulated_rainfall", "rainfall", "rolling", "rain_accum_period", "closed", "right", "sum", "soiling", "rate", "soiling", "np", "ones_like", "rainfall", "values", "soiling_loss_rate", "day_fraction", "soiling", "0", "initial_soiling", "soiling", "np", "cumsum", "soiling", "soiling", "pd", "series", "soiling", "index", "rainfall", "index", "name", "soiling", "rainfall", "events", "that", "clean", "the", "panels", "rain_events", "accumulated_rainfall", "cleaning_threshold", "grace", "periods", "windows", "during", "which", "ground", "is", "assumed", "damp", "so", "no", "soiling", "grace_windows", "rain_events", "rolling", "grace_period", "closed", "right", "sum", "0", "clean", "panels", "by", "subtracting", "soiling", "for", "indices", "in", "grace", "period", "windows", "cleaning", "pd", "series", "float", "nan", "index", "rainfall", "index", "cleaning", "iloc", "0", "0", "0", "cleaning", "grace_windows", "soiling", "grace_windows", "manual", "wash", "dates", "if", "manual_wash_dates", "is", "not", "none", "rain_tz", "rainfall", "index", "tz", "convert", "manual", "wash", "dates", "to", "datetime", "index", "in", "the", "timezone", "of", "rain", "manual_wash_dates", "pd", "datetimeindex", "manual_wash_dates", "tz", "rain_tz", "cleaning", "manual_wash_dates", "soiling", "manual_wash_dates", "remove", "soiling", "by", "foward", "filling", "cleaning", "where", "nan", "soiling", "cleaning", "ffill", "check", "if", "soiling", "has", "reached", "the", "maximum", "return", "soiling", "where", "soiling", "max_soiling", "max_soiling"], "doc_len": 626}
{"doc_id": "pvlib/solarposition.py::get_solarposition", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "get_solarposition", "text": "文件路径: pvlib/solarposition.py\ndef get_solarposition(time, latitude, longitude,\n                      altitude=None, pressure=None,\n                      method='nrel_numpy',\n                      temperature=12, **kwargs):\n    \"\"\"\n    A convenience wrapper for the solar position calculators.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n\n    altitude : None or float, default None\n        If None, computed from pressure. Assumed to be 0 m\n        if pressure is also None.\n\n    pressure : None or float, default None\n        If None, computed from altitude. Assumed to be 101325 Pa\n        if altitude is also None.\n\n    method : string, default 'nrel_numpy'\n        'nrel_numpy' uses an implementation of the NREL SPA algorithm\n        described in [1] (default, recommended): :py:func:`spa_python`\n\n        'nrel_numba' uses an implementation of the NREL SPA algorithm\n        described in [1], but also compiles the code first:\n        :py:func:`spa_python`\n\n        'pyephem' uses the PyEphem package: :py:func:`pyephem`\n\n        'ephemeris' uses the pvlib ephemeris code: :py:func:`ephemeris`\n\n        'nrel_c' uses the NREL SPA C code [3]: :py:func:`spa_c`\n\n    temperature : float, default 12\n        Degrees C.\n\n    kwargs\n        Other keywords are passed to the solar position function\n        specified by the ``method`` argument.\n\n    References\n    ----------\n    .. [1] I. Reda and A. Andreas, Solar position algorithm for solar radiation\n       applications. Solar Energy, vol. 76, no. 5, pp. 577-589, 2004.\n\n    .. [2] I. Reda and A. Andreas, Corrigendum to Solar position algorithm for\n       solar radiation applications. Solar Energy, vol. 81, no. 6, p. 838,\n       2007.\n\n    .. [3] NREL SPA code: http://rredc.nrel.gov/solar/codesandalgorithms/spa/\n    \"\"\"\n\n    if altitude is None and pressure is None:\n        altitude = 0.\n        pressure = 101325.\n    elif altitude is None:\n        altitude = atmosphere.pres2alt(pressure)\n    elif pressure is None:\n        pressure = atmosphere.alt2pres(altitude)\n\n    method = method.lower()\n    if isinstance(time, dt.datetime):\n        time = pd.DatetimeIndex([time, ])\n\n    if method == 'nrel_c':\n        ephem_df = spa_c(time, latitude, longitude, pressure, temperature,\n                         **kwargs)\n    elif method == 'nrel_numba':\n        ephem_df = spa_python(time, latitude, longitude, altitude,\n                              pressure, temperature,\n                              how='numba', **kwargs)\n    elif method == 'nrel_numpy':\n        ephem_df = spa_python(time, latitude, longitude, altitude,\n                              pressure, temperature,\n                              how='numpy', **kwargs)\n    elif method == 'pyephem':\n        ephem_df = pyephem(time, latitude, longitude,\n                           altitude=altitude,\n                           pressure=pressure,\n                           temperature=temperature, **kwargs)\n    elif method == 'ephemeris':\n        ephem_df = ephemeris(time, latitude, longitude, pressure, temperature,\n                             **kwargs)\n    else:\n        raise ValueError('Invalid solar position method')\n\n    return ephem_df\n", "tokens": ["pvlib", "solarposition", "py", "def", "get_solarposition", "time", "latitude", "longitude", "altitude", "none", "pressure", "none", "method", "nrel_numpy", "temperature", "12", "kwargs", "a", "convenience", "wrapper", "for", "the", "solar", "position", "calculators", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "altitude", "none", "or", "float", "default", "none", "if", "none", "computed", "from", "pressure", "assumed", "to", "be", "0", "m", "if", "pressure", "is", "also", "none", "pressure", "none", "or", "float", "default", "none", "if", "none", "computed", "from", "altitude", "assumed", "to", "be", "101325", "pa", "if", "altitude", "is", "also", "none", "method", "string", "default", "nrel_numpy", "nrel_numpy", "uses", "an", "implementation", "of", "the", "nrel", "spa", "algorithm", "described", "in", "1", "default", "recommended", "py", "func", "spa_python", "nrel_numba", "uses", "an", "implementation", "of", "the", "nrel", "spa", "algorithm", "described", "in", "1", "but", "also", "compiles", "the", "code", "first", "py", "func", "spa_python", "pyephem", "uses", "the", "pyephem", "package", "py", "func", "pyephem", "ephemeris", "uses", "the", "pvlib", "ephemeris", "code", "py", "func", "ephemeris", "nrel_c", "uses", "the", "nrel", "spa", "c", "code", "3", "py", "func", "spa_c", "temperature", "float", "default", "12", "degrees", "c", "kwargs", "other", "keywords", "are", "passed", "to", "the", "solar", "position", "function", "specified", "by", "the", "method", "argument", "references", "1", "i", "reda", "and", "a", "andreas", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "76", "no", "5", "pp", "577", "589", "2004", "2", "i", "reda", "and", "a", "andreas", "corrigendum", "to", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "81", "no", "6", "p", "838", "2007", "3", "nrel", "spa", "code", "http", "rredc", "nrel", "gov", "solar", "codesandalgorithms", "spa", "if", "altitude", "is", "none", "and", "pressure", "is", "none", "altitude", "0", "pressure", "101325", "elif", "altitude", "is", "none", "altitude", "atmosphere", "pres2alt", "pressure", "elif", "pressure", "is", "none", "pressure", "atmosphere", "alt2pres", "altitude", "method", "method", "lower", "if", "isinstance", "time", "dt", "datetime", "time", "pd", "datetimeindex", "time", "if", "method", "nrel_c", "ephem_df", "spa_c", "time", "latitude", "longitude", "pressure", "temperature", "kwargs", "elif", "method", "nrel_numba", "ephem_df", "spa_python", "time", "latitude", "longitude", "altitude", "pressure", "temperature", "how", "numba", "kwargs", "elif", "method", "nrel_numpy", "ephem_df", "spa_python", "time", "latitude", "longitude", "altitude", "pressure", "temperature", "how", "numpy", "kwargs", "elif", "method", "pyephem", "ephem_df", "pyephem", "time", "latitude", "longitude", "altitude", "altitude", "pressure", "pressure", "temperature", "temperature", "kwargs", "elif", "method", "ephemeris", "ephem_df", "ephemeris", "time", "latitude", "longitude", "pressure", "temperature", "kwargs", "else", "raise", "valueerror", "invalid", "solar", "position", "method", "return", "ephem_df"], "doc_len": 370}
{"doc_id": "pvlib/solarposition.py::spa_c", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "spa_c", "text": "文件路径: pvlib/solarposition.py\ndef spa_c(time, latitude, longitude, pressure=101325, altitude=0,\n          temperature=12, delta_t=67.0,\n          raw_spa_output=False):\n    \"\"\"\n    Calculate the solar position using the C implementation of the NREL\n    SPA code.\n\n    The source files for this code are located in './spa_c_files/', along with\n    a README file which describes how the C code is wrapped in Python.\n    Due to license restrictions, the C code must be downloaded seperately\n    and used in accordance with it's license.\n\n    This function is slower and no more accurate than :py:func:`spa_python`.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n    pressure : float, default 101325\n        Pressure in Pascals\n    altitude : float, default 0\n        Height above sea level. [m]\n    temperature : float, default 12\n        Temperature in C\n    delta_t : float, default 67.0\n        Difference between terrestrial time and UT1.\n        USNO has previous values and predictions.\n    raw_spa_output : bool, default False\n        If true, returns the raw SPA output.\n\n    Returns\n    -------\n    DataFrame\n        The DataFrame will have the following columns:\n        elevation,\n        azimuth,\n        zenith,\n        apparent_elevation,\n        apparent_zenith.\n\n    References\n    ----------\n    .. [1] NREL SPA reference:\n       http://rredc.nrel.gov/solar/codesandalgorithms/spa/\n       NREL SPA C files: https://midcdmz.nrel.gov/spa/\n\n    Note: The ``timezone`` field in the SPA C files is replaced with\n    ``time_zone`` to avoid a nameclash with the function ``__timezone`` that is\n    redefined by Python>=3.5. This issue is\n    `Python bug 24643 <https://bugs.python.org/issue24643>`_.\n\n    .. [2] USNO delta T:\n       http://www.usno.navy.mil/USNO/earth-orientation/eo-products/long-term\n\n    See also\n    --------\n    pyephem, spa_python, ephemeris\n    \"\"\"\n\n    # Added by Rob Andrews (@Calama-Consulting), Calama Consulting, 2014\n    # Edited by Will Holmgren (@wholmgren), University of Arizona, 2014\n    # Edited by Tony Lorenzo (@alorenzo175), University of Arizona, 2015\n\n    try:\n        from pvlib.spa_c_files.spa_py import spa_calc\n    except ImportError:\n        raise ImportError('Could not import built-in SPA calculator. ' +\n                          'You may need to recompile the SPA code.')\n\n    # if localized, convert to UTC. otherwise, assume UTC.\n    try:\n        time_utc = time.tz_convert('UTC')\n    except TypeError:\n        time_utc = time\n\n    spa_out = []\n\n    for date in time_utc:\n        spa_out.append(spa_calc(year=date.year,\n                                month=date.month,\n                                day=date.day,\n                                hour=date.hour,\n                                minute=date.minute,\n                                second=date.second,\n                                time_zone=0,  # date uses utc time\n                                latitude=latitude,\n                                longitude=longitude,\n                                elevation=altitude,\n                                pressure=pressure / 100,\n                                temperature=temperature,\n                                delta_t=delta_t\n                                ))\n\n    spa_df = pd.DataFrame(spa_out, index=time)\n\n    if raw_spa_output:\n        # rename \"time_zone\" from raw output from spa_c_files.spa_py.spa_calc()\n        # to \"timezone\" to match the API of pvlib.solarposition.spa_c()\n        return spa_df.rename(columns={'time_zone': 'timezone'})\n    else:\n        dfout = pd.DataFrame({'azimuth': spa_df['azimuth'],\n                              'apparent_zenith': spa_df['zenith'],\n                              'apparent_elevation': spa_df['e'],\n                              'elevation': spa_df['e0'],\n                              'zenith': 90 - spa_df['e0']})\n\n        return dfout\n", "tokens": ["pvlib", "solarposition", "py", "def", "spa_c", "time", "latitude", "longitude", "pressure", "101325", "altitude", "0", "temperature", "12", "delta_t", "67", "0", "raw_spa_output", "false", "calculate", "the", "solar", "position", "using", "the", "c", "implementation", "of", "the", "nrel", "spa", "code", "the", "source", "files", "for", "this", "code", "are", "located", "in", "spa_c_files", "along", "with", "a", "readme", "file", "which", "describes", "how", "the", "c", "code", "is", "wrapped", "in", "python", "due", "to", "license", "restrictions", "the", "c", "code", "must", "be", "downloaded", "seperately", "and", "used", "in", "accordance", "with", "it", "s", "license", "this", "function", "is", "slower", "and", "no", "more", "accurate", "than", "py", "func", "spa_python", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "pressure", "float", "default", "101325", "pressure", "in", "pascals", "altitude", "float", "default", "0", "height", "above", "sea", "level", "m", "temperature", "float", "default", "12", "temperature", "in", "c", "delta_t", "float", "default", "67", "0", "difference", "between", "terrestrial", "time", "and", "ut1", "usno", "has", "previous", "values", "and", "predictions", "raw_spa_output", "bool", "default", "false", "if", "true", "returns", "the", "raw", "spa", "output", "returns", "dataframe", "the", "dataframe", "will", "have", "the", "following", "columns", "elevation", "azimuth", "zenith", "apparent_elevation", "apparent_zenith", "references", "1", "nrel", "spa", "reference", "http", "rredc", "nrel", "gov", "solar", "codesandalgorithms", "spa", "nrel", "spa", "c", "files", "https", "midcdmz", "nrel", "gov", "spa", "note", "the", "timezone", "field", "in", "the", "spa", "c", "files", "is", "replaced", "with", "time_zone", "to", "avoid", "a", "nameclash", "with", "the", "function", "__timezone", "that", "is", "redefined", "by", "python", "3", "5", "this", "issue", "is", "python", "bug", "24643", "https", "bugs", "python", "org", "issue24643", "_", "2", "usno", "delta", "t", "http", "www", "usno", "navy", "mil", "usno", "earth", "orientation", "eo", "products", "long", "term", "see", "also", "pyephem", "spa_python", "ephemeris", "added", "by", "rob", "andrews", "calama", "consulting", "calama", "consulting", "2014", "edited", "by", "will", "holmgren", "wholmgren", "university", "of", "arizona", "2014", "edited", "by", "tony", "lorenzo", "alorenzo175", "university", "of", "arizona", "2015", "try", "from", "pvlib", "spa_c_files", "spa_py", "import", "spa_calc", "except", "importerror", "raise", "importerror", "could", "not", "import", "built", "in", "spa", "calculator", "you", "may", "need", "to", "recompile", "the", "spa", "code", "if", "localized", "convert", "to", "utc", "otherwise", "assume", "utc", "try", "time_utc", "time", "tz_convert", "utc", "except", "typeerror", "time_utc", "time", "spa_out", "for", "date", "in", "time_utc", "spa_out", "append", "spa_calc", "year", "date", "year", "month", "date", "month", "day", "date", "day", "hour", "date", "hour", "minute", "date", "minute", "second", "date", "second", "time_zone", "0", "date", "uses", "utc", "time", "latitude", "latitude", "longitude", "longitude", "elevation", "altitude", "pressure", "pressure", "100", "temperature", "temperature", "delta_t", "delta_t", "spa_df", "pd", "dataframe", "spa_out", "index", "time", "if", "raw_spa_output", "rename", "time_zone", "from", "raw", "output", "from", "spa_c_files", "spa_py", "spa_calc", "to", "timezone", "to", "match", "the", "api", "of", "pvlib", "solarposition", "spa_c", "return", "spa_df", "rename", "columns", "time_zone", "timezone", "else", "dfout", "pd", "dataframe", "azimuth", "spa_df", "azimuth", "apparent_zenith", "spa_df", "zenith", "apparent_elevation", "spa_df", "e", "elevation", "spa_df", "e0", "zenith", "90", "spa_df", "e0", "return", "dfout"], "doc_len": 444}
{"doc_id": "pvlib/solarposition.py::_spa_python_import", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_spa_python_import", "text": "文件路径: pvlib/solarposition.py\ndef _spa_python_import(how):\n    \"\"\"Compile spa.py appropriately\"\"\"\n\n    from pvlib import spa\n\n    # check to see if the spa module was compiled with numba\n    using_numba = spa.USE_NUMBA\n\n    if how == 'numpy' and using_numba:\n        # the spa module was compiled to numba code, so we need to\n        # reload the module without compiling\n        # the PVLIB_USE_NUMBA env variable is used to tell the module\n        # to not compile with numba\n        warnings.warn('Reloading spa to use numpy')\n        os.environ['PVLIB_USE_NUMBA'] = '0'\n        spa = reload(spa)\n        del os.environ['PVLIB_USE_NUMBA']\n    elif how == 'numba' and not using_numba:\n        # The spa module was not compiled to numba code, so set\n        # PVLIB_USE_NUMBA so it does compile to numba on reload.\n        warnings.warn('Reloading spa to use numba')\n        os.environ['PVLIB_USE_NUMBA'] = '1'\n        spa = reload(spa)\n        del os.environ['PVLIB_USE_NUMBA']\n    elif how != 'numba' and how != 'numpy':\n        raise ValueError(\"how must be either 'numba' or 'numpy'\")\n\n    return spa\n", "tokens": ["pvlib", "solarposition", "py", "def", "_spa_python_import", "how", "compile", "spa", "py", "appropriately", "from", "pvlib", "import", "spa", "check", "to", "see", "if", "the", "spa", "module", "was", "compiled", "with", "numba", "using_numba", "spa", "use_numba", "if", "how", "numpy", "and", "using_numba", "the", "spa", "module", "was", "compiled", "to", "numba", "code", "so", "we", "need", "to", "reload", "the", "module", "without", "compiling", "the", "pvlib_use_numba", "env", "variable", "is", "used", "to", "tell", "the", "module", "to", "not", "compile", "with", "numba", "warnings", "warn", "reloading", "spa", "to", "use", "numpy", "os", "environ", "pvlib_use_numba", "0", "spa", "reload", "spa", "del", "os", "environ", "pvlib_use_numba", "elif", "how", "numba", "and", "not", "using_numba", "the", "spa", "module", "was", "not", "compiled", "to", "numba", "code", "so", "set", "pvlib_use_numba", "so", "it", "does", "compile", "to", "numba", "on", "reload", "warnings", "warn", "reloading", "spa", "to", "use", "numba", "os", "environ", "pvlib_use_numba", "1", "spa", "reload", "spa", "del", "os", "environ", "pvlib_use_numba", "elif", "how", "numba", "and", "how", "numpy", "raise", "valueerror", "how", "must", "be", "either", "numba", "or", "numpy", "return", "spa"], "doc_len": 144}
{"doc_id": "pvlib/solarposition.py::spa_python", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "spa_python", "text": "文件路径: pvlib/solarposition.py\ndef spa_python(time, latitude, longitude,\n               altitude=0, pressure=101325, temperature=12, delta_t=67.0,\n               atmos_refract=None, how='numpy', numthreads=4):\n    \"\"\"\n    Calculate the solar position using a python implementation of the\n    NREL SPA algorithm.\n\n    The details of the NREL SPA algorithm are described in [1]_.\n\n    If numba is installed, the functions can be compiled to\n    machine code and the function can be multithreaded.\n    Without numba, the function evaluates via numpy with\n    a slight performance hit.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n    altitude : float, default 0\n        Distance above sea level.\n    pressure : int or float, optional, default 101325\n        avg. yearly air pressure in Pascals.\n    temperature : int or float, optional, default 12\n        avg. yearly air temperature in degrees C.\n    delta_t : float, optional, default 67.0\n        Difference between terrestrial time and UT1.\n        If delta_t is None, uses spa.calculate_deltat\n        using time.year and time.month from pandas.DatetimeIndex.\n        For most simulations the default delta_t is sufficient.\n        *Note: delta_t = None will break code using nrel_numba,\n        this will be fixed in a future version.*\n        The USNO has historical and forecasted delta_t [3]_.\n    atmos_refrac : None or float, optional, default None\n        The approximate atmospheric refraction (in degrees)\n        at sunrise and sunset.\n    how : str, optional, default 'numpy'\n        Options are 'numpy' or 'numba'. If numba >= 0.17.0\n        is installed, how='numba' will compile the spa functions\n        to machine code and run them multithreaded.\n    numthreads : int, optional, default 4\n        Number of threads to use if how == 'numba'.\n\n    Returns\n    -------\n    DataFrame\n        The DataFrame will have the following columns:\n        apparent_zenith (degrees),\n        zenith (degrees),\n        apparent_elevation (degrees),\n        elevation (degrees),\n        azimuth (degrees),\n        equation_of_time (minutes).\n\n\n    References\n    ----------\n    .. [1] I. Reda and A. Andreas, Solar position algorithm for solar\n       radiation applications. Solar Energy, vol. 76, no. 5, pp. 577-589, 2004.\n\n    .. [2] I. Reda and A. Andreas, Corrigendum to Solar position algorithm for\n       solar radiation applications. Solar Energy, vol. 81, no. 6, p. 838,\n       2007.\n\n    .. [3] USNO delta T:\n       http://www.usno.navy.mil/USNO/earth-orientation/eo-products/long-term\n\n    See also\n    --------\n    pyephem, spa_c, ephemeris\n    \"\"\"\n\n    # Added by Tony Lorenzo (@alorenzo175), University of Arizona, 2015\n\n    lat = latitude\n    lon = longitude\n    elev = altitude\n    pressure = pressure / 100  # pressure must be in millibars for calculation\n\n    atmos_refract = atmos_refract or 0.5667\n\n    if not isinstance(time, pd.DatetimeIndex):\n        try:\n            time = pd.DatetimeIndex(time)\n        except (TypeError, ValueError):\n            time = pd.DatetimeIndex([time, ])\n\n    unixtime = np.array(time.view(np.int64)/10**9)\n\n    spa = _spa_python_import(how)\n\n    delta_t = delta_t or spa.calculate_deltat(time.year, time.month)\n\n    app_zenith, zenith, app_elevation, elevation, azimuth, eot = \\\n        spa.solar_position(unixtime, lat, lon, elev, pressure, temperature,\n                           delta_t, atmos_refract, numthreads)\n\n    result = pd.DataFrame({'apparent_zenith': app_zenith, 'zenith': zenith,\n                           'apparent_elevation': app_elevation,\n                           'elevation': elevation, 'azimuth': azimuth,\n                           'equation_of_time': eot},\n                          index=time)\n\n    return result\n", "tokens": ["pvlib", "solarposition", "py", "def", "spa_python", "time", "latitude", "longitude", "altitude", "0", "pressure", "101325", "temperature", "12", "delta_t", "67", "0", "atmos_refract", "none", "how", "numpy", "numthreads", "4", "calculate", "the", "solar", "position", "using", "a", "python", "implementation", "of", "the", "nrel", "spa", "algorithm", "the", "details", "of", "the", "nrel", "spa", "algorithm", "are", "described", "in", "1", "_", "if", "numba", "is", "installed", "the", "functions", "can", "be", "compiled", "to", "machine", "code", "and", "the", "function", "can", "be", "multithreaded", "without", "numba", "the", "function", "evaluates", "via", "numpy", "with", "a", "slight", "performance", "hit", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "altitude", "float", "default", "0", "distance", "above", "sea", "level", "pressure", "int", "or", "float", "optional", "default", "101325", "avg", "yearly", "air", "pressure", "in", "pascals", "temperature", "int", "or", "float", "optional", "default", "12", "avg", "yearly", "air", "temperature", "in", "degrees", "c", "delta_t", "float", "optional", "default", "67", "0", "difference", "between", "terrestrial", "time", "and", "ut1", "if", "delta_t", "is", "none", "uses", "spa", "calculate_deltat", "using", "time", "year", "and", "time", "month", "from", "pandas", "datetimeindex", "for", "most", "simulations", "the", "default", "delta_t", "is", "sufficient", "note", "delta_t", "none", "will", "break", "code", "using", "nrel_numba", "this", "will", "be", "fixed", "in", "a", "future", "version", "the", "usno", "has", "historical", "and", "forecasted", "delta_t", "3", "_", "atmos_refrac", "none", "or", "float", "optional", "default", "none", "the", "approximate", "atmospheric", "refraction", "in", "degrees", "at", "sunrise", "and", "sunset", "how", "str", "optional", "default", "numpy", "options", "are", "numpy", "or", "numba", "if", "numba", "0", "17", "0", "is", "installed", "how", "numba", "will", "compile", "the", "spa", "functions", "to", "machine", "code", "and", "run", "them", "multithreaded", "numthreads", "int", "optional", "default", "4", "number", "of", "threads", "to", "use", "if", "how", "numba", "returns", "dataframe", "the", "dataframe", "will", "have", "the", "following", "columns", "apparent_zenith", "degrees", "zenith", "degrees", "apparent_elevation", "degrees", "elevation", "degrees", "azimuth", "degrees", "equation_of_time", "minutes", "references", "1", "i", "reda", "and", "a", "andreas", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "76", "no", "5", "pp", "577", "589", "2004", "2", "i", "reda", "and", "a", "andreas", "corrigendum", "to", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "81", "no", "6", "p", "838", "2007", "3", "usno", "delta", "t", "http", "www", "usno", "navy", "mil", "usno", "earth", "orientation", "eo", "products", "long", "term", "see", "also", "pyephem", "spa_c", "ephemeris", "added", "by", "tony", "lorenzo", "alorenzo175", "university", "of", "arizona", "2015", "lat", "latitude", "lon", "longitude", "elev", "altitude", "pressure", "pressure", "100", "pressure", "must", "be", "in", "millibars", "for", "calculation", "atmos_refract", "atmos_refract", "or", "0", "5667", "if", "not", "isinstance", "time", "pd", "datetimeindex", "try", "time", "pd", "datetimeindex", "time", "except", "typeerror", "valueerror", "time", "pd", "datetimeindex", "time", "unixtime", "np", "array", "time", "view", "np", "int64", "10", "9", "spa", "_spa_python_import", "how", "delta_t", "delta_t", "or", "spa", "calculate_deltat", "time", "year", "time", "month", "app_zenith", "zenith", "app_elevation", "elevation", "azimuth", "eot", "spa", "solar_position", "unixtime", "lat", "lon", "elev", "pressure", "temperature", "delta_t", "atmos_refract", "numthreads", "result", "pd", "dataframe", "apparent_zenith", "app_zenith", "zenith", "zenith", "apparent_elevation", "app_elevation", "elevation", "elevation", "azimuth", "azimuth", "equation_of_time", "eot", "index", "time", "return", "result"], "doc_len": 469}
{"doc_id": "pvlib/solarposition.py::sun_rise_set_transit_spa", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "sun_rise_set_transit_spa", "text": "文件路径: pvlib/solarposition.py\ndef sun_rise_set_transit_spa(times, latitude, longitude, how='numpy',\n                             delta_t=67.0, numthreads=4):\n    \"\"\"\n    Calculate the sunrise, sunset, and sun transit times using the\n    NREL SPA algorithm.\n\n    The details of the NREL SPA algorithm are described in [1]_.\n\n    If numba is installed, the functions can be compiled to\n    machine code and the function can be multithreaded.\n    Without numba, the function evaluates via numpy with\n    a slight performance hit.\n\n    Parameters\n    ----------\n    times : pandas.DatetimeIndex\n        Must be localized to the timezone for ``latitude`` and ``longitude``.\n    latitude : float\n        Latitude in degrees, positive north of equator, negative to south\n    longitude : float\n        Longitude in degrees, positive east of prime meridian, negative to west\n    how : str, optional, default 'numpy'\n        Options are 'numpy' or 'numba'. If numba >= 0.17.0\n        is installed, how='numba' will compile the spa functions\n        to machine code and run them multithreaded.\n    delta_t : float, optional, default 67.0\n        Difference between terrestrial time and UT1.\n        If delta_t is None, uses spa.calculate_deltat\n        using times.year and times.month from pandas.DatetimeIndex.\n        For most simulations the default delta_t is sufficient.\n        *Note: delta_t = None will break code using nrel_numba,\n        this will be fixed in a future version.*\n    numthreads : int, optional, default 4\n        Number of threads to use if how == 'numba'.\n\n    Returns\n    -------\n    pandas.DataFrame\n        index is the same as input `times` argument\n        columns are 'sunrise', 'sunset', and 'transit'\n\n    References\n    ----------\n    .. [1] Reda, I., Andreas, A., 2003. Solar position algorithm for solar\n       radiation applications. Technical report: NREL/TP-560- 34302. Golden,\n       USA, http://www.nrel.gov.\n    \"\"\"\n    # Added by Tony Lorenzo (@alorenzo175), University of Arizona, 2015\n\n    lat = latitude\n    lon = longitude\n\n    # times must be localized\n    if times.tz:\n        tzinfo = times.tz\n    else:\n        raise ValueError('times must be localized')\n\n    # must convert to midnight UTC on day of interest\n    utcday = pd.DatetimeIndex(times.date).tz_localize('UTC')\n    unixtime = np.array(utcday.view(np.int64)/10**9)\n\n    spa = _spa_python_import(how)\n\n    delta_t = delta_t or spa.calculate_deltat(times.year, times.month)\n\n    transit, sunrise, sunset = spa.transit_sunrise_sunset(\n        unixtime, lat, lon, delta_t, numthreads)\n\n    # arrays are in seconds since epoch format, need to conver to timestamps\n    transit = pd.to_datetime(transit*1e9, unit='ns', utc=True).tz_convert(\n        tzinfo).tolist()\n    sunrise = pd.to_datetime(sunrise*1e9, unit='ns', utc=True).tz_convert(\n        tzinfo).tolist()\n    sunset = pd.to_datetime(sunset*1e9, unit='ns', utc=True).tz_convert(\n        tzinfo).tolist()\n\n    return pd.DataFrame(index=times, data={'sunrise': sunrise,\n                                           'sunset': sunset,\n                                           'transit': transit})\n", "tokens": ["pvlib", "solarposition", "py", "def", "sun_rise_set_transit_spa", "times", "latitude", "longitude", "how", "numpy", "delta_t", "67", "0", "numthreads", "4", "calculate", "the", "sunrise", "sunset", "and", "sun", "transit", "times", "using", "the", "nrel", "spa", "algorithm", "the", "details", "of", "the", "nrel", "spa", "algorithm", "are", "described", "in", "1", "_", "if", "numba", "is", "installed", "the", "functions", "can", "be", "compiled", "to", "machine", "code", "and", "the", "function", "can", "be", "multithreaded", "without", "numba", "the", "function", "evaluates", "via", "numpy", "with", "a", "slight", "performance", "hit", "parameters", "times", "pandas", "datetimeindex", "must", "be", "localized", "to", "the", "timezone", "for", "latitude", "and", "longitude", "latitude", "float", "latitude", "in", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "how", "str", "optional", "default", "numpy", "options", "are", "numpy", "or", "numba", "if", "numba", "0", "17", "0", "is", "installed", "how", "numba", "will", "compile", "the", "spa", "functions", "to", "machine", "code", "and", "run", "them", "multithreaded", "delta_t", "float", "optional", "default", "67", "0", "difference", "between", "terrestrial", "time", "and", "ut1", "if", "delta_t", "is", "none", "uses", "spa", "calculate_deltat", "using", "times", "year", "and", "times", "month", "from", "pandas", "datetimeindex", "for", "most", "simulations", "the", "default", "delta_t", "is", "sufficient", "note", "delta_t", "none", "will", "break", "code", "using", "nrel_numba", "this", "will", "be", "fixed", "in", "a", "future", "version", "numthreads", "int", "optional", "default", "4", "number", "of", "threads", "to", "use", "if", "how", "numba", "returns", "pandas", "dataframe", "index", "is", "the", "same", "as", "input", "times", "argument", "columns", "are", "sunrise", "sunset", "and", "transit", "references", "1", "reda", "i", "andreas", "a", "2003", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "technical", "report", "nrel", "tp", "560", "34302", "golden", "usa", "http", "www", "nrel", "gov", "added", "by", "tony", "lorenzo", "alorenzo175", "university", "of", "arizona", "2015", "lat", "latitude", "lon", "longitude", "times", "must", "be", "localized", "if", "times", "tz", "tzinfo", "times", "tz", "else", "raise", "valueerror", "times", "must", "be", "localized", "must", "convert", "to", "midnight", "utc", "on", "day", "of", "interest", "utcday", "pd", "datetimeindex", "times", "date", "tz_localize", "utc", "unixtime", "np", "array", "utcday", "view", "np", "int64", "10", "9", "spa", "_spa_python_import", "how", "delta_t", "delta_t", "or", "spa", "calculate_deltat", "times", "year", "times", "month", "transit", "sunrise", "sunset", "spa", "transit_sunrise_sunset", "unixtime", "lat", "lon", "delta_t", "numthreads", "arrays", "are", "in", "seconds", "since", "epoch", "format", "need", "to", "conver", "to", "timestamps", "transit", "pd", "to_datetime", "transit", "1e9", "unit", "ns", "utc", "true", "tz_convert", "tzinfo", "tolist", "sunrise", "pd", "to_datetime", "sunrise", "1e9", "unit", "ns", "utc", "true", "tz_convert", "tzinfo", "tolist", "sunset", "pd", "to_datetime", "sunset", "1e9", "unit", "ns", "utc", "true", "tz_convert", "tzinfo", "tolist", "return", "pd", "dataframe", "index", "times", "data", "sunrise", "sunrise", "sunset", "sunset", "transit", "transit"], "doc_len": 385}
{"doc_id": "pvlib/solarposition.py::_ephem_convert_to_seconds_and_microseconds", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_ephem_convert_to_seconds_and_microseconds", "text": "文件路径: pvlib/solarposition.py\ndef _ephem_convert_to_seconds_and_microseconds(date):\n    # utility from unreleased PyEphem 3.6.7.1\n    \"\"\"Converts a PyEphem date into seconds\"\"\"\n    microseconds = int(round(24 * 60 * 60 * 1000000 * date))\n    seconds, microseconds = divmod(microseconds, 1000000)\n    seconds -= 2209032000  # difference between epoch 1900 and epoch 1970\n    return seconds, microseconds\n", "tokens": ["pvlib", "solarposition", "py", "def", "_ephem_convert_to_seconds_and_microseconds", "date", "utility", "from", "unreleased", "pyephem", "3", "6", "7", "1", "converts", "a", "pyephem", "date", "into", "seconds", "microseconds", "int", "round", "24", "60", "60", "1000000", "date", "seconds", "microseconds", "divmod", "microseconds", "1000000", "seconds", "2209032000", "difference", "between", "epoch", "1900", "and", "epoch", "1970", "return", "seconds", "microseconds"], "doc_len": 45}
{"doc_id": "pvlib/solarposition.py::_ephem_to_timezone", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_ephem_to_timezone", "text": "文件路径: pvlib/solarposition.py\ndef _ephem_to_timezone(date, tzinfo):\n    # utility from unreleased PyEphem 3.6.7.1\n    \"\"\"\"Convert a PyEphem Date into a timezone aware python datetime\"\"\"\n    seconds, microseconds = _ephem_convert_to_seconds_and_microseconds(date)\n    date = dt.datetime.fromtimestamp(seconds, tzinfo)\n    date = date.replace(microsecond=microseconds)\n    return date\n", "tokens": ["pvlib", "solarposition", "py", "def", "_ephem_to_timezone", "date", "tzinfo", "utility", "from", "unreleased", "pyephem", "3", "6", "7", "1", "convert", "a", "pyephem", "date", "into", "a", "timezone", "aware", "python", "datetime", "seconds", "microseconds", "_ephem_convert_to_seconds_and_microseconds", "date", "date", "dt", "datetime", "fromtimestamp", "seconds", "tzinfo", "date", "date", "replace", "microsecond", "microseconds", "return", "date"], "doc_len": 42}
{"doc_id": "pvlib/solarposition.py::_ephem_setup", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_ephem_setup", "text": "文件路径: pvlib/solarposition.py\ndef _ephem_setup(latitude, longitude, altitude, pressure, temperature,\n                 horizon):\n    import ephem\n    # initialize a PyEphem observer\n    obs = ephem.Observer()\n    obs.lat = str(latitude)\n    obs.lon = str(longitude)\n    obs.elevation = altitude\n    obs.pressure = pressure / 100.  # convert to mBar\n    obs.temp = temperature\n    obs.horizon = horizon\n\n    # the PyEphem sun\n    sun = ephem.Sun()\n    return obs, sun\n", "tokens": ["pvlib", "solarposition", "py", "def", "_ephem_setup", "latitude", "longitude", "altitude", "pressure", "temperature", "horizon", "import", "ephem", "initialize", "a", "pyephem", "observer", "obs", "ephem", "observer", "obs", "lat", "str", "latitude", "obs", "lon", "str", "longitude", "obs", "elevation", "altitude", "obs", "pressure", "pressure", "100", "convert", "to", "mbar", "obs", "temp", "temperature", "obs", "horizon", "horizon", "the", "pyephem", "sun", "sun", "ephem", "sun", "return", "obs", "sun"], "doc_len": 53}
{"doc_id": "pvlib/solarposition.py::sun_rise_set_transit_ephem", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "sun_rise_set_transit_ephem", "text": "文件路径: pvlib/solarposition.py\ndef sun_rise_set_transit_ephem(times, latitude, longitude,\n                               next_or_previous='next',\n                               altitude=0,\n                               pressure=101325,\n                               temperature=12, horizon='0:00'):\n    \"\"\"\n    Calculate the next sunrise and sunset times using the PyEphem package.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized\n    latitude : float\n        Latitude in degrees, positive north of equator, negative to south\n    longitude : float\n        Longitude in degrees, positive east of prime meridian, negative to west\n    next_or_previous : str\n        'next' or 'previous' sunrise and sunset relative to time\n    altitude : float, default 0\n        distance above sea level in meters.\n    pressure : int or float, optional, default 101325\n        air pressure in Pascals.\n    temperature : int or float, optional, default 12\n        air temperature in degrees C.\n    horizon : string, format +/-X:YY\n        arc degrees:arc minutes from geometrical horizon for sunrise and\n        sunset, e.g., horizon='+0:00' to use sun center crossing the\n        geometrical horizon to define sunrise and sunset,\n        horizon='-0:34' for when the sun's upper edge crosses the\n        geometrical horizon\n\n    Returns\n    -------\n    pandas.DataFrame\n        index is the same as input `time` argument\n        columns are 'sunrise', 'sunset', and 'transit'\n\n    See also\n    --------\n    pyephem\n    \"\"\"\n\n    try:\n        import ephem\n    except ImportError:\n        raise ImportError('PyEphem must be installed')\n\n    # times must be localized\n    if times.tz:\n        tzinfo = times.tz\n    else:\n        raise ValueError('times must be localized')\n\n    obs, sun = _ephem_setup(latitude, longitude, altitude,\n                            pressure, temperature, horizon)\n    # create lists of sunrise and sunset time localized to time.tz\n    if next_or_previous.lower() == 'next':\n        rising = obs.next_rising\n        setting = obs.next_setting\n        transit = obs.next_transit\n    elif next_or_previous.lower() == 'previous':\n        rising = obs.previous_rising\n        setting = obs.previous_setting\n        transit = obs.previous_transit\n    else:\n        raise ValueError(\"next_or_previous must be either 'next' or\" +\n                         \" 'previous'\")\n\n    sunrise = []\n    sunset = []\n    trans = []\n    for thetime in times:\n        thetime = thetime.to_pydatetime()\n        # older versions of pyephem ignore timezone when converting to its\n        # internal datetime format, so convert to UTC here to support\n        # all versions.  GH #1449\n        obs.date = ephem.Date(thetime.astimezone(datetime.timezone.utc))\n        sunrise.append(_ephem_to_timezone(rising(sun), tzinfo))\n        sunset.append(_ephem_to_timezone(setting(sun), tzinfo))\n        trans.append(_ephem_to_timezone(transit(sun), tzinfo))\n\n    return pd.DataFrame(index=times, data={'sunrise': sunrise,\n                                           'sunset': sunset,\n                                           'transit': trans})\n", "tokens": ["pvlib", "solarposition", "py", "def", "sun_rise_set_transit_ephem", "times", "latitude", "longitude", "next_or_previous", "next", "altitude", "0", "pressure", "101325", "temperature", "12", "horizon", "0", "00", "calculate", "the", "next", "sunrise", "and", "sunset", "times", "using", "the", "pyephem", "package", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "latitude", "float", "latitude", "in", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "next_or_previous", "str", "next", "or", "previous", "sunrise", "and", "sunset", "relative", "to", "time", "altitude", "float", "default", "0", "distance", "above", "sea", "level", "in", "meters", "pressure", "int", "or", "float", "optional", "default", "101325", "air", "pressure", "in", "pascals", "temperature", "int", "or", "float", "optional", "default", "12", "air", "temperature", "in", "degrees", "c", "horizon", "string", "format", "x", "yy", "arc", "degrees", "arc", "minutes", "from", "geometrical", "horizon", "for", "sunrise", "and", "sunset", "e", "g", "horizon", "0", "00", "to", "use", "sun", "center", "crossing", "the", "geometrical", "horizon", "to", "define", "sunrise", "and", "sunset", "horizon", "0", "34", "for", "when", "the", "sun", "s", "upper", "edge", "crosses", "the", "geometrical", "horizon", "returns", "pandas", "dataframe", "index", "is", "the", "same", "as", "input", "time", "argument", "columns", "are", "sunrise", "sunset", "and", "transit", "see", "also", "pyephem", "try", "import", "ephem", "except", "importerror", "raise", "importerror", "pyephem", "must", "be", "installed", "times", "must", "be", "localized", "if", "times", "tz", "tzinfo", "times", "tz", "else", "raise", "valueerror", "times", "must", "be", "localized", "obs", "sun", "_ephem_setup", "latitude", "longitude", "altitude", "pressure", "temperature", "horizon", "create", "lists", "of", "sunrise", "and", "sunset", "time", "localized", "to", "time", "tz", "if", "next_or_previous", "lower", "next", "rising", "obs", "next_rising", "setting", "obs", "next_setting", "transit", "obs", "next_transit", "elif", "next_or_previous", "lower", "previous", "rising", "obs", "previous_rising", "setting", "obs", "previous_setting", "transit", "obs", "previous_transit", "else", "raise", "valueerror", "next_or_previous", "must", "be", "either", "next", "or", "previous", "sunrise", "sunset", "trans", "for", "thetime", "in", "times", "thetime", "thetime", "to_pydatetime", "older", "versions", "of", "pyephem", "ignore", "timezone", "when", "converting", "to", "its", "internal", "datetime", "format", "so", "convert", "to", "utc", "here", "to", "support", "all", "versions", "gh", "1449", "obs", "date", "ephem", "date", "thetime", "astimezone", "datetime", "timezone", "utc", "sunrise", "append", "_ephem_to_timezone", "rising", "sun", "tzinfo", "sunset", "append", "_ephem_to_timezone", "setting", "sun", "tzinfo", "trans", "append", "_ephem_to_timezone", "transit", "sun", "tzinfo", "return", "pd", "dataframe", "index", "times", "data", "sunrise", "sunrise", "sunset", "sunset", "transit", "trans"], "doc_len": 331}
{"doc_id": "pvlib/solarposition.py::pyephem", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "pyephem", "text": "文件路径: pvlib/solarposition.py\ndef pyephem(time, latitude, longitude, altitude=0, pressure=101325,\n            temperature=12, horizon='+0:00'):\n    \"\"\"\n    Calculate the solar position using the PyEphem package.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n    altitude : float, default 0\n        Height above sea level in meters. [m]\n    pressure : int or float, optional, default 101325\n        air pressure in Pascals.\n    temperature : int or float, optional, default 12\n        air temperature in degrees C.\n    horizon : string, optional, default '+0:00'\n        arc degrees:arc minutes from geometrical horizon for sunrise and\n        sunset, e.g., horizon='+0:00' to use sun center crossing the\n        geometrical horizon to define sunrise and sunset,\n        horizon='-0:34' for when the sun's upper edge crosses the\n        geometrical horizon\n\n    Returns\n    -------\n    pandas.DataFrame\n        index is the same as input `time` argument\n        The DataFrame will have the following columns:\n        apparent_elevation, elevation,\n        apparent_azimuth, azimuth,\n        apparent_zenith, zenith.\n\n    See also\n    --------\n    spa_python, spa_c, ephemeris\n    \"\"\"\n\n    # Written by Will Holmgren (@wholmgren), University of Arizona, 2014\n    try:\n        import ephem\n    except ImportError:\n        raise ImportError('PyEphem must be installed')\n\n    # if localized, convert to UTC. otherwise, assume UTC.\n    try:\n        time_utc = time.tz_convert('UTC')\n    except TypeError:\n        time_utc = time\n\n    sun_coords = pd.DataFrame(index=time)\n\n    obs, sun = _ephem_setup(latitude, longitude, altitude,\n                            pressure, temperature, horizon)\n\n    # make and fill lists of the sun's altitude and azimuth\n    # this is the pressure and temperature corrected apparent alt/az.\n    alts = []\n    azis = []\n    for thetime in time_utc:\n        obs.date = ephem.Date(thetime)\n        sun.compute(obs)\n        alts.append(sun.alt)\n        azis.append(sun.az)\n\n    sun_coords['apparent_elevation'] = alts\n    sun_coords['apparent_azimuth'] = azis\n\n    # redo it for p=0 to get no atmosphere alt/az\n    obs.pressure = 0\n    alts = []\n    azis = []\n    for thetime in time_utc:\n        obs.date = ephem.Date(thetime)\n        sun.compute(obs)\n        alts.append(sun.alt)\n        azis.append(sun.az)\n\n    sun_coords['elevation'] = alts\n    sun_coords['azimuth'] = azis\n\n    # convert to degrees. add zenith\n    sun_coords = np.rad2deg(sun_coords)\n    sun_coords['apparent_zenith'] = 90 - sun_coords['apparent_elevation']\n    sun_coords['zenith'] = 90 - sun_coords['elevation']\n\n    return sun_coords\n", "tokens": ["pvlib", "solarposition", "py", "def", "pyephem", "time", "latitude", "longitude", "altitude", "0", "pressure", "101325", "temperature", "12", "horizon", "0", "00", "calculate", "the", "solar", "position", "using", "the", "pyephem", "package", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "altitude", "float", "default", "0", "height", "above", "sea", "level", "in", "meters", "m", "pressure", "int", "or", "float", "optional", "default", "101325", "air", "pressure", "in", "pascals", "temperature", "int", "or", "float", "optional", "default", "12", "air", "temperature", "in", "degrees", "c", "horizon", "string", "optional", "default", "0", "00", "arc", "degrees", "arc", "minutes", "from", "geometrical", "horizon", "for", "sunrise", "and", "sunset", "e", "g", "horizon", "0", "00", "to", "use", "sun", "center", "crossing", "the", "geometrical", "horizon", "to", "define", "sunrise", "and", "sunset", "horizon", "0", "34", "for", "when", "the", "sun", "s", "upper", "edge", "crosses", "the", "geometrical", "horizon", "returns", "pandas", "dataframe", "index", "is", "the", "same", "as", "input", "time", "argument", "the", "dataframe", "will", "have", "the", "following", "columns", "apparent_elevation", "elevation", "apparent_azimuth", "azimuth", "apparent_zenith", "zenith", "see", "also", "spa_python", "spa_c", "ephemeris", "written", "by", "will", "holmgren", "wholmgren", "university", "of", "arizona", "2014", "try", "import", "ephem", "except", "importerror", "raise", "importerror", "pyephem", "must", "be", "installed", "if", "localized", "convert", "to", "utc", "otherwise", "assume", "utc", "try", "time_utc", "time", "tz_convert", "utc", "except", "typeerror", "time_utc", "time", "sun_coords", "pd", "dataframe", "index", "time", "obs", "sun", "_ephem_setup", "latitude", "longitude", "altitude", "pressure", "temperature", "horizon", "make", "and", "fill", "lists", "of", "the", "sun", "s", "altitude", "and", "azimuth", "this", "is", "the", "pressure", "and", "temperature", "corrected", "apparent", "alt", "az", "alts", "azis", "for", "thetime", "in", "time_utc", "obs", "date", "ephem", "date", "thetime", "sun", "compute", "obs", "alts", "append", "sun", "alt", "azis", "append", "sun", "az", "sun_coords", "apparent_elevation", "alts", "sun_coords", "apparent_azimuth", "azis", "redo", "it", "for", "p", "0", "to", "get", "no", "atmosphere", "alt", "az", "obs", "pressure", "0", "alts", "azis", "for", "thetime", "in", "time_utc", "obs", "date", "ephem", "date", "thetime", "sun", "compute", "obs", "alts", "append", "sun", "alt", "azis", "append", "sun", "az", "sun_coords", "elevation", "alts", "sun_coords", "azimuth", "azis", "convert", "to", "degrees", "add", "zenith", "sun_coords", "np", "rad2deg", "sun_coords", "sun_coords", "apparent_zenith", "90", "sun_coords", "apparent_elevation", "sun_coords", "zenith", "90", "sun_coords", "elevation", "return", "sun_coords"], "doc_len": 339}
{"doc_id": "pvlib/solarposition.py::ephemeris", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "ephemeris", "text": "文件路径: pvlib/solarposition.py\ndef ephemeris(time, latitude, longitude, pressure=101325, temperature=12):\n    \"\"\"\n    Python-native solar position calculator.\n    The accuracy of this code is not guaranteed.\n    Consider using the built-in spa_c code or the PyEphem library.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n    pressure : float or Series, default 101325\n        Ambient pressure (Pascals)\n    temperature : float or Series, default 12\n        Ambient temperature (C)\n\n    Returns\n    -------\n\n    DataFrame with the following columns:\n\n        * apparent_elevation : apparent sun elevation accounting for\n          atmospheric refraction.\n        * elevation : actual elevation (not accounting for refraction)\n          of the sun in decimal degrees, 0 = on horizon.\n          The complement of the zenith angle.\n        * azimuth : Azimuth of the sun in decimal degrees East of North.\n          This is the complement of the apparent zenith angle.\n        * apparent_zenith : apparent sun zenith accounting for atmospheric\n          refraction.\n        * zenith : Solar zenith angle\n        * solar_time : Solar time in decimal hours (solar noon is 12.00).\n\n    References\n    -----------\n\n    .. [1] Grover Hughes' class and related class materials on Engineering\n       Astronomy at Sandia National Laboratories, 1985.\n\n    See also\n    --------\n    pyephem, spa_c, spa_python\n\n    \"\"\"\n\n    # Added by Rob Andrews (@Calama-Consulting), Calama Consulting, 2014\n    # Edited by Will Holmgren (@wholmgren), University of Arizona, 2014\n\n    # Most comments in this function are from PVLIB_MATLAB or from\n    # pvlib-python's attempt to understand and fix problems with the\n    # algorithm. The comments are *not* based on the reference material.\n    # This helps a little bit:\n    # http://www.cv.nrao.edu/~rfisher/Ephemerides/times.html\n\n    # the inversion of longitude is due to the fact that this code was\n    # originally written for the convention that positive longitude were for\n    # locations west of the prime meridian. However, the correct convention (as\n    # of 2009) is to use negative longitudes for locations west of the prime\n    # meridian. Therefore, the user should input longitude values under the\n    # correct convention (e.g. Albuquerque is at -106 longitude), but it needs\n    # to be inverted for use in the code.\n\n    Latitude = latitude\n    Longitude = -1 * longitude\n\n    Abber = 20 / 3600.\n    LatR = np.radians(Latitude)\n\n    # the SPA algorithm needs time to be expressed in terms of\n    # decimal UTC hours of the day of the year.\n\n    # if localized, convert to UTC. otherwise, assume UTC.\n    try:\n        time_utc = time.tz_convert('UTC')\n    except TypeError:\n        time_utc = time\n\n    # strip out the day of the year and calculate the decimal hour\n    DayOfYear = time_utc.dayofyear\n    DecHours = (time_utc.hour + time_utc.minute/60. + time_utc.second/3600. +\n                time_utc.microsecond/3600.e6)\n\n    # np.array needed for pandas > 0.20\n    UnivDate = np.array(DayOfYear)\n    UnivHr = np.array(DecHours)\n\n    Yr = np.array(time_utc.year) - 1900\n    YrBegin = 365 * Yr + np.floor((Yr - 1) / 4.) - 0.5\n\n    Ezero = YrBegin + UnivDate\n    T = Ezero / 36525.\n\n    # Calculate Greenwich Mean Sidereal Time (GMST)\n    GMST0 = 6 / 24. + 38 / 1440. + (\n        45.836 + 8640184.542 * T + 0.0929 * T ** 2) / 86400.\n    GMST0 = 360 * (GMST0 - np.floor(GMST0))\n    GMSTi = np.mod(GMST0 + 360 * (1.0027379093 * UnivHr / 24.), 360)\n\n    # Local apparent sidereal time\n    LocAST = np.mod((360 + GMSTi - Longitude), 360)\n\n    EpochDate = Ezero + UnivHr / 24.\n    T1 = EpochDate / 36525.\n\n    ObliquityR = np.radians(\n        23.452294 - 0.0130125 * T1 - 1.64e-06 * T1 ** 2 + 5.03e-07 * T1 ** 3)\n    MlPerigee = 281.22083 + 4.70684e-05 * EpochDate + 0.000453 * T1 ** 2 + (\n        3e-06 * T1 ** 3)\n    MeanAnom = np.mod((358.47583 + 0.985600267 * EpochDate - 0.00015 *\n                       T1 ** 2 - 3e-06 * T1 ** 3), 360)\n    Eccen = 0.01675104 - 4.18e-05 * T1 - 1.26e-07 * T1 ** 2\n    EccenAnom = MeanAnom\n    E = 0\n\n    while np.max(abs(EccenAnom - E)) > 0.0001:\n        E = EccenAnom\n        EccenAnom = MeanAnom + np.degrees(Eccen)*np.sin(np.radians(E))\n\n    TrueAnom = (\n        2 * np.mod(np.degrees(np.arctan2(((1 + Eccen) / (1 - Eccen)) ** 0.5 *\n                   np.tan(np.radians(EccenAnom) / 2.), 1)), 360))\n    EcLon = np.mod(MlPerigee + TrueAnom, 360) - Abber\n    EcLonR = np.radians(EcLon)\n    DecR = np.arcsin(np.sin(ObliquityR)*np.sin(EcLonR))\n\n    RtAscen = np.degrees(np.arctan2(np.cos(ObliquityR)*np.sin(EcLonR),\n                                    np.cos(EcLonR)))\n\n    HrAngle = LocAST - RtAscen\n    HrAngleR = np.radians(HrAngle)\n    HrAngle = HrAngle - (360 * (abs(HrAngle) > 180))\n\n    SunAz = np.degrees(np.arctan2(-np.sin(HrAngleR),\n                                  np.cos(LatR)*np.tan(DecR) -\n                                  np.sin(LatR)*np.cos(HrAngleR)))\n    SunAz[SunAz < 0] += 360\n\n    SunEl = np.degrees(np.arcsin(\n        np.cos(LatR) * np.cos(DecR) * np.cos(HrAngleR) +\n        np.sin(LatR) * np.sin(DecR)))\n\n    SolarTime = (180 + HrAngle) / 15.\n\n    # Calculate refraction correction\n    Elevation = SunEl\n    TanEl = pd.Series(np.tan(np.radians(Elevation)), index=time_utc)\n    Refract = pd.Series(0, index=time_utc)\n\n    Refract[(Elevation > 5) & (Elevation <= 85)] = (\n        58.1/TanEl - 0.07/(TanEl**3) + 8.6e-05/(TanEl**5))\n\n    Refract[(Elevation > -0.575) & (Elevation <= 5)] = (\n        Elevation *\n        (-518.2 + Elevation*(103.4 + Elevation*(-12.79 + Elevation*0.711))) +\n        1735)\n\n    Refract[(Elevation > -1) & (Elevation <= -0.575)] = -20.774 / TanEl\n\n    Refract *= (283/(273. + temperature)) * (pressure/101325.) / 3600.\n\n    ApparentSunEl = SunEl + Refract\n\n    # make output DataFrame\n    DFOut = pd.DataFrame(index=time_utc)\n    DFOut['apparent_elevation'] = ApparentSunEl\n    DFOut['elevation'] = SunEl\n    DFOut['azimuth'] = SunAz\n    DFOut['apparent_zenith'] = 90 - ApparentSunEl\n    DFOut['zenith'] = 90 - SunEl\n    DFOut['solar_time'] = SolarTime\n    DFOut.index = time\n\n    return DFOut\n", "tokens": ["pvlib", "solarposition", "py", "def", "ephemeris", "time", "latitude", "longitude", "pressure", "101325", "temperature", "12", "python", "native", "solar", "position", "calculator", "the", "accuracy", "of", "this", "code", "is", "not", "guaranteed", "consider", "using", "the", "built", "in", "spa_c", "code", "or", "the", "pyephem", "library", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "pressure", "float", "or", "series", "default", "101325", "ambient", "pressure", "pascals", "temperature", "float", "or", "series", "default", "12", "ambient", "temperature", "c", "returns", "dataframe", "with", "the", "following", "columns", "apparent_elevation", "apparent", "sun", "elevation", "accounting", "for", "atmospheric", "refraction", "elevation", "actual", "elevation", "not", "accounting", "for", "refraction", "of", "the", "sun", "in", "decimal", "degrees", "0", "on", "horizon", "the", "complement", "of", "the", "zenith", "angle", "azimuth", "azimuth", "of", "the", "sun", "in", "decimal", "degrees", "east", "of", "north", "this", "is", "the", "complement", "of", "the", "apparent", "zenith", "angle", "apparent_zenith", "apparent", "sun", "zenith", "accounting", "for", "atmospheric", "refraction", "zenith", "solar", "zenith", "angle", "solar_time", "solar", "time", "in", "decimal", "hours", "solar", "noon", "is", "12", "00", "references", "1", "grover", "hughes", "class", "and", "related", "class", "materials", "on", "engineering", "astronomy", "at", "sandia", "national", "laboratories", "1985", "see", "also", "pyephem", "spa_c", "spa_python", "added", "by", "rob", "andrews", "calama", "consulting", "calama", "consulting", "2014", "edited", "by", "will", "holmgren", "wholmgren", "university", "of", "arizona", "2014", "most", "comments", "in", "this", "function", "are", "from", "pvlib_matlab", "or", "from", "pvlib", "python", "s", "attempt", "to", "understand", "and", "fix", "problems", "with", "the", "algorithm", "the", "comments", "are", "not", "based", "on", "the", "reference", "material", "this", "helps", "a", "little", "bit", "http", "www", "cv", "nrao", "edu", "rfisher", "ephemerides", "times", "html", "the", "inversion", "of", "longitude", "is", "due", "to", "the", "fact", "that", "this", "code", "was", "originally", "written", "for", "the", "convention", "that", "positive", "longitude", "were", "for", "locations", "west", "of", "the", "prime", "meridian", "however", "the", "correct", "convention", "as", "of", "2009", "is", "to", "use", "negative", "longitudes", "for", "locations", "west", "of", "the", "prime", "meridian", "therefore", "the", "user", "should", "input", "longitude", "values", "under", "the", "correct", "convention", "e", "g", "albuquerque", "is", "at", "106", "longitude", "but", "it", "needs", "to", "be", "inverted", "for", "use", "in", "the", "code", "latitude", "latitude", "longitude", "1", "longitude", "abber", "20", "3600", "latr", "np", "radians", "latitude", "the", "spa", "algorithm", "needs", "time", "to", "be", "expressed", "in", "terms", "of", "decimal", "utc", "hours", "of", "the", "day", "of", "the", "year", "if", "localized", "convert", "to", "utc", "otherwise", "assume", "utc", "try", "time_utc", "time", "tz_convert", "utc", "except", "typeerror", "time_utc", "time", "strip", "out", "the", "day", "of", "the", "year", "and", "calculate", "the", "decimal", "hour", "dayofyear", "time_utc", "dayofyear", "dechours", "time_utc", "hour", "time_utc", "minute", "60", "time_utc", "second", "3600", "time_utc", "microsecond", "3600", "e6", "np", "array", "needed", "for", "pandas", "0", "20", "univdate", "np", "array", "dayofyear", "univhr", "np", "array", "dechours", "yr", "np", "array", "time_utc", "year", "1900", "yrbegin", "365", "yr", "np", "floor", "yr", "1", "4", "0", "5", "ezero", "yrbegin", "univdate", "t", "ezero", "36525", "calculate", "greenwich", "mean", "sidereal", "time", "gmst", "gmst0", "6", "24", "38", "1440", "45", "836", "8640184", "542", "t", "0", "0929", "t", "2", "86400", "gmst0", "360", "gmst0", "np", "floor", "gmst0", "gmsti", "np", "mod", "gmst0", "360", "1", "0027379093", "univhr", "24", "360", "local", "apparent", "sidereal", "time", "locast", "np", "mod", "360", "gmsti", "longitude", "360", "epochdate", "ezero", "univhr", "24", "t1", "epochdate", "36525", "obliquityr", "np", "radians", "23", "452294", "0", "0130125", "t1", "1", "64e", "06", "t1", "2", "5", "03e", "07", "t1", "3", "mlperigee", "281", "22083", "4", "70684e", "05", "epochdate", "0", "000453", "t1", "2", "3e", "06", "t1", "3", "meananom", "np", "mod", "358", "47583", "0", "985600267", "epochdate", "0", "00015", "t1", "2", "3e", "06", "t1", "3", "360", "eccen", "0", "01675104", "4", "18e", "05", "t1", "1", "26e", "07", "t1", "2", "eccenanom", "meananom", "e", "0", "while", "np", "max", "abs", "eccenanom", "e", "0", "0001", "e", "eccenanom", "eccenanom", "meananom", "np", "degrees", "eccen", "np", "sin", "np", "radians", "e", "trueanom", "2", "np", "mod", "np", "degrees", "np", "arctan2", "1", "eccen", "1", "eccen", "0", "5", "np", "tan", "np", "radians", "eccenanom", "2", "1", "360", "eclon", "np", "mod", "mlperigee", "trueanom", "360", "abber", "eclonr", "np", "radians", "eclon", "decr", "np", "arcsin", "np", "sin", "obliquityr", "np", "sin", "eclonr", "rtascen", "np", "degrees", "np", "arctan2", "np", "cos", "obliquityr", "np", "sin", "eclonr", "np", "cos", "eclonr", "hrangle", "locast", "rtascen", "hrangler", "np", "radians", "hrangle", "hrangle", "hrangle", "360", "abs", "hrangle", "180", "sunaz", "np", "degrees", "np", "arctan2", "np", "sin", "hrangler", "np", "cos", "latr", "np", "tan", "decr", "np", "sin", "latr", "np", "cos", "hrangler", "sunaz", "sunaz", "0", "360", "sunel", "np", "degrees", "np", "arcsin", "np", "cos", "latr", "np", "cos", "decr", "np", "cos", "hrangler", "np", "sin", "latr", "np", "sin", "decr", "solartime", "180", "hrangle", "15", "calculate", "refraction", "correction", "elevation", "sunel", "tanel", "pd", "series", "np", "tan", "np", "radians", "elevation", "index", "time_utc", "refract", "pd", "series", "0", "index", "time_utc", "refract", "elevation", "5", "elevation", "85", "58", "1", "tanel", "0", "07", "tanel", "3", "8", "6e", "05", "tanel", "5", "refract", "elevation", "0", "575", "elevation", "5", "elevation", "518", "2", "elevation", "103", "4", "elevation", "12", "79", "elevation", "0", "711", "1735", "refract", "elevation", "1", "elevation", "0", "575", "20", "774", "tanel", "refract", "283", "273", "temperature", "pressure", "101325", "3600", "apparentsunel", "sunel", "refract", "make", "output", "dataframe", "dfout", "pd", "dataframe", "index", "time_utc", "dfout", "apparent_elevation", "apparentsunel", "dfout", "elevation", "sunel", "dfout", "azimuth", "sunaz", "dfout", "apparent_zenith", "90", "apparentsunel", "dfout", "zenith", "90", "sunel", "dfout", "solar_time", "solartime", "dfout", "index", "time", "return", "dfout"], "doc_len": 815}
{"doc_id": "pvlib/solarposition.py::calc_time", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "calc_time", "text": "文件路径: pvlib/solarposition.py\ndef calc_time(lower_bound, upper_bound, latitude, longitude, attribute, value,\n              altitude=0, pressure=101325, temperature=12, horizon='+0:00',\n              xtol=1.0e-12):\n    \"\"\"\n    Calculate the time between lower_bound and upper_bound\n    where the attribute is equal to value. Uses PyEphem for\n    solar position calculations.\n\n    Parameters\n    ----------\n    lower_bound : datetime.datetime\n    upper_bound : datetime.datetime\n    latitude : float\n        Latitude in decimal degrees. Positive north of equator, negative\n        to south.\n    longitude : float\n        Longitude in decimal degrees. Positive east of prime meridian,\n        negative to west.\n    attribute : str\n        The attribute of a pyephem.Sun object that\n        you want to solve for. Likely options are 'alt'\n        and 'az' (which must be given in radians).\n    value : int or float\n        The value of the attribute to solve for\n    altitude : float, default 0\n        Distance above sea level.\n    pressure : int or float, optional, default 101325\n        Air pressure in Pascals. Set to 0 for no\n        atmospheric correction.\n    temperature : int or float, optional, default 12\n        Air temperature in degrees C.\n    horizon : string, optional, default '+0:00'\n        arc degrees:arc minutes from geometrical horizon for sunrise and\n        sunset, e.g., horizon='+0:00' to use sun center crossing the\n        geometrical horizon to define sunrise and sunset,\n        horizon='-0:34' for when the sun's upper edge crosses the\n        geometrical horizon\n    xtol : float, optional, default 1.0e-12\n        The allowed error in the result from value\n\n    Returns\n    -------\n    datetime.datetime\n\n    Raises\n    ------\n    ValueError\n        If the value is not contained between the bounds.\n    AttributeError\n        If the given attribute is not an attribute of a\n        PyEphem.Sun object.\n    \"\"\"\n    obs, sun = _ephem_setup(latitude, longitude, altitude,\n                            pressure, temperature, horizon)\n\n    def compute_attr(thetime, target, attr):\n        obs.date = thetime\n        sun.compute(obs)\n        return getattr(sun, attr) - target\n\n    lb = datetime_to_djd(lower_bound)\n    ub = datetime_to_djd(upper_bound)\n\n    djd_root = so.brentq(compute_attr, lb, ub,\n                         (value, attribute), xtol=xtol)\n\n    return djd_to_datetime(djd_root)\n", "tokens": ["pvlib", "solarposition", "py", "def", "calc_time", "lower_bound", "upper_bound", "latitude", "longitude", "attribute", "value", "altitude", "0", "pressure", "101325", "temperature", "12", "horizon", "0", "00", "xtol", "1", "0e", "12", "calculate", "the", "time", "between", "lower_bound", "and", "upper_bound", "where", "the", "attribute", "is", "equal", "to", "value", "uses", "pyephem", "for", "solar", "position", "calculations", "parameters", "lower_bound", "datetime", "datetime", "upper_bound", "datetime", "datetime", "latitude", "float", "latitude", "in", "decimal", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "decimal", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "attribute", "str", "the", "attribute", "of", "a", "pyephem", "sun", "object", "that", "you", "want", "to", "solve", "for", "likely", "options", "are", "alt", "and", "az", "which", "must", "be", "given", "in", "radians", "value", "int", "or", "float", "the", "value", "of", "the", "attribute", "to", "solve", "for", "altitude", "float", "default", "0", "distance", "above", "sea", "level", "pressure", "int", "or", "float", "optional", "default", "101325", "air", "pressure", "in", "pascals", "set", "to", "0", "for", "no", "atmospheric", "correction", "temperature", "int", "or", "float", "optional", "default", "12", "air", "temperature", "in", "degrees", "c", "horizon", "string", "optional", "default", "0", "00", "arc", "degrees", "arc", "minutes", "from", "geometrical", "horizon", "for", "sunrise", "and", "sunset", "e", "g", "horizon", "0", "00", "to", "use", "sun", "center", "crossing", "the", "geometrical", "horizon", "to", "define", "sunrise", "and", "sunset", "horizon", "0", "34", "for", "when", "the", "sun", "s", "upper", "edge", "crosses", "the", "geometrical", "horizon", "xtol", "float", "optional", "default", "1", "0e", "12", "the", "allowed", "error", "in", "the", "result", "from", "value", "returns", "datetime", "datetime", "raises", "valueerror", "if", "the", "value", "is", "not", "contained", "between", "the", "bounds", "attributeerror", "if", "the", "given", "attribute", "is", "not", "an", "attribute", "of", "a", "pyephem", "sun", "object", "obs", "sun", "_ephem_setup", "latitude", "longitude", "altitude", "pressure", "temperature", "horizon", "def", "compute_attr", "thetime", "target", "attr", "obs", "date", "thetime", "sun", "compute", "obs", "return", "getattr", "sun", "attr", "target", "lb", "datetime_to_djd", "lower_bound", "ub", "datetime_to_djd", "upper_bound", "djd_root", "so", "brentq", "compute_attr", "lb", "ub", "value", "attribute", "xtol", "xtol", "return", "djd_to_datetime", "djd_root"], "doc_len": 291}
{"doc_id": "pvlib/solarposition.py::pyephem_earthsun_distance", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "pyephem_earthsun_distance", "text": "文件路径: pvlib/solarposition.py\ndef pyephem_earthsun_distance(time):\n    \"\"\"\n    Calculates the distance from the earth to the sun using pyephem.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n\n    Returns\n    -------\n    pd.Series. Earth-sun distance in AU.\n    \"\"\"\n\n    import ephem\n\n    sun = ephem.Sun()\n    earthsun = []\n    for thetime in time:\n        sun.compute(ephem.Date(thetime))\n        earthsun.append(sun.earth_distance)\n\n    return pd.Series(earthsun, index=time)\n", "tokens": ["pvlib", "solarposition", "py", "def", "pyephem_earthsun_distance", "time", "calculates", "the", "distance", "from", "the", "earth", "to", "the", "sun", "using", "pyephem", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "returns", "pd", "series", "earth", "sun", "distance", "in", "au", "import", "ephem", "sun", "ephem", "sun", "earthsun", "for", "thetime", "in", "time", "sun", "compute", "ephem", "date", "thetime", "earthsun", "append", "sun", "earth_distance", "return", "pd", "series", "earthsun", "index", "time"], "doc_len": 62}
{"doc_id": "pvlib/solarposition.py::nrel_earthsun_distance", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "nrel_earthsun_distance", "text": "文件路径: pvlib/solarposition.py\ndef nrel_earthsun_distance(time, how='numpy', delta_t=67.0, numthreads=4):\n    \"\"\"\n    Calculates the distance from the earth to the sun using the\n    NREL SPA algorithm.\n\n    The details of the NREL SPA algorithm are described in [1]_.\n\n    Parameters\n    ----------\n    time : pandas.DatetimeIndex\n        Must be localized or UTC will be assumed.\n\n    how : str, optional, default 'numpy'\n        Options are 'numpy' or 'numba'. If numba >= 0.17.0\n        is installed, how='numba' will compile the spa functions\n        to machine code and run them multithreaded.\n\n    delta_t : float, optional, default 67.0\n        Difference between terrestrial time and UT1.\n        If delta_t is None, uses spa.calculate_deltat\n        using time.year and time.month from pandas.DatetimeIndex.\n        For most simulations the default delta_t is sufficient.\n        *Note: delta_t = None will break code using nrel_numba,\n        this will be fixed in a future version.*\n\n    numthreads : int, optional, default 4\n        Number of threads to use if how == 'numba'.\n\n    Returns\n    -------\n    dist : pd.Series\n        Earth-sun distance in AU.\n\n    References\n    ----------\n    .. [1] Reda, I., Andreas, A., 2003. Solar position algorithm for solar\n       radiation applications. Technical report: NREL/TP-560- 34302. Golden,\n       USA, http://www.nrel.gov.\n    \"\"\"\n\n    if not isinstance(time, pd.DatetimeIndex):\n        try:\n            time = pd.DatetimeIndex(time)\n        except (TypeError, ValueError):\n            time = pd.DatetimeIndex([time, ])\n\n    unixtime = np.array(time.view(np.int64)/10**9)\n\n    spa = _spa_python_import(how)\n\n    delta_t = delta_t or spa.calculate_deltat(time.year, time.month)\n\n    dist = spa.earthsun_distance(unixtime, delta_t, numthreads)\n\n    dist = pd.Series(dist, index=time)\n\n    return dist\n", "tokens": ["pvlib", "solarposition", "py", "def", "nrel_earthsun_distance", "time", "how", "numpy", "delta_t", "67", "0", "numthreads", "4", "calculates", "the", "distance", "from", "the", "earth", "to", "the", "sun", "using", "the", "nrel", "spa", "algorithm", "the", "details", "of", "the", "nrel", "spa", "algorithm", "are", "described", "in", "1", "_", "parameters", "time", "pandas", "datetimeindex", "must", "be", "localized", "or", "utc", "will", "be", "assumed", "how", "str", "optional", "default", "numpy", "options", "are", "numpy", "or", "numba", "if", "numba", "0", "17", "0", "is", "installed", "how", "numba", "will", "compile", "the", "spa", "functions", "to", "machine", "code", "and", "run", "them", "multithreaded", "delta_t", "float", "optional", "default", "67", "0", "difference", "between", "terrestrial", "time", "and", "ut1", "if", "delta_t", "is", "none", "uses", "spa", "calculate_deltat", "using", "time", "year", "and", "time", "month", "from", "pandas", "datetimeindex", "for", "most", "simulations", "the", "default", "delta_t", "is", "sufficient", "note", "delta_t", "none", "will", "break", "code", "using", "nrel_numba", "this", "will", "be", "fixed", "in", "a", "future", "version", "numthreads", "int", "optional", "default", "4", "number", "of", "threads", "to", "use", "if", "how", "numba", "returns", "dist", "pd", "series", "earth", "sun", "distance", "in", "au", "references", "1", "reda", "i", "andreas", "a", "2003", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "technical", "report", "nrel", "tp", "560", "34302", "golden", "usa", "http", "www", "nrel", "gov", "if", "not", "isinstance", "time", "pd", "datetimeindex", "try", "time", "pd", "datetimeindex", "time", "except", "typeerror", "valueerror", "time", "pd", "datetimeindex", "time", "unixtime", "np", "array", "time", "view", "np", "int64", "10", "9", "spa", "_spa_python_import", "how", "delta_t", "delta_t", "or", "spa", "calculate_deltat", "time", "year", "time", "month", "dist", "spa", "earthsun_distance", "unixtime", "delta_t", "numthreads", "dist", "pd", "series", "dist", "index", "time", "return", "dist"], "doc_len": 235}
{"doc_id": "pvlib/solarposition.py::_calculate_simple_day_angle", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_calculate_simple_day_angle", "text": "文件路径: pvlib/solarposition.py\ndef _calculate_simple_day_angle(dayofyear, offset=1):\n    \"\"\"\n    Calculates the day angle for the Earth's orbit around the Sun.\n\n    Parameters\n    ----------\n    dayofyear : numeric\n    offset : int, default 1\n        For the Spencer method, offset=1; for the ASCE method, offset=0\n\n    Returns\n    -------\n    day_angle : numeric\n    \"\"\"\n    return (2. * np.pi / 365.) * (dayofyear - offset)\n", "tokens": ["pvlib", "solarposition", "py", "def", "_calculate_simple_day_angle", "dayofyear", "offset", "1", "calculates", "the", "day", "angle", "for", "the", "earth", "s", "orbit", "around", "the", "sun", "parameters", "dayofyear", "numeric", "offset", "int", "default", "1", "for", "the", "spencer", "method", "offset", "1", "for", "the", "asce", "method", "offset", "0", "returns", "day_angle", "numeric", "return", "2", "np", "pi", "365", "dayofyear", "offset"], "doc_len": 49}
{"doc_id": "pvlib/solarposition.py::equation_of_time_spencer71", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "equation_of_time_spencer71", "text": "文件路径: pvlib/solarposition.py\ndef equation_of_time_spencer71(dayofyear):\n    \"\"\"\n    Equation of time from Duffie & Beckman and attributed to Spencer\n    (1971) and Iqbal (1983).\n\n    The coefficients correspond to the online copy of the `Fourier\n    paper`_ [1]_ in the Sundial Mailing list that was posted in 1998 by\n    Mac Oglesby from his correspondence with Macquarie University Prof.\n    John Pickard who added the following note.\n\n        In the early 1970s, I contacted Dr Spencer about this method because I\n        was trying to use a hand calculator for calculating solar positions,\n        etc. He was extremely helpful and gave me a reprint of this paper. He\n        also pointed out an error in the original: in the series for E, the\n        constant was printed as 0.000075 rather than 0.0000075. I have\n        corrected the error in this version.\n\n    There appears to be another error in formula as printed in both\n    Duffie & Beckman's [2]_ and Frank Vignola's [3]_ books in which the\n    coefficient 0.04089 is printed instead of 0.040849, corresponding to\n    the value used in the Bird Clear Sky model implemented by Daryl\n    Myers [4]_ and printed in both the Fourier paper from the Sundial\n    Mailing List and R. Hulstrom's [5]_ book.\n\n    .. _Fourier paper: http://www.mail-archive.com/sundial@uni-koeln.de/msg01050.html\n\n    Parameters\n    ----------\n    dayofyear : numeric\n\n    Returns\n    -------\n    equation_of_time : numeric\n        Difference in time between solar time and mean solar time in minutes.\n\n    References\n    ----------\n    .. [1] J. W. Spencer, \"Fourier series representation of the position of the\n       sun\" in Search 2 (5), p. 172 (1971)\n\n    .. [2] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 9-11, J. Wiley and Sons, New York (2006)\n\n    .. [3] Frank Vignola et al., \"Solar And Infrared Radiation Measurements\",\n       p. 13, CRC Press (2012)\n\n    .. [4] Daryl R. Myers, \"Solar Radiation: Practical Modeling for Renewable\n       Energy Applications\", p. 5 CRC Press (2013)\n\n    .. [5] Roland Hulstrom, \"Solar Resources\" p. 66, MIT Press (1989)\n\n    See Also\n    --------\n    equation_of_time_pvcdrom\n    \"\"\"\n    day_angle = _calculate_simple_day_angle(dayofyear)\n    # convert from radians to minutes per day = 24[h/day] * 60[min/h] / 2 / pi\n    eot = (1440.0 / 2 / np.pi) * (\n        0.0000075 +\n        0.001868 * np.cos(day_angle) - 0.032077 * np.sin(day_angle) -\n        0.014615 * np.cos(2.0 * day_angle) - 0.040849 * np.sin(2.0 * day_angle)\n    )\n    return eot\n", "tokens": ["pvlib", "solarposition", "py", "def", "equation_of_time_spencer71", "dayofyear", "equation", "of", "time", "from", "duffie", "beckman", "and", "attributed", "to", "spencer", "1971", "and", "iqbal", "1983", "the", "coefficients", "correspond", "to", "the", "online", "copy", "of", "the", "fourier", "paper", "_", "1", "_", "in", "the", "sundial", "mailing", "list", "that", "was", "posted", "in", "1998", "by", "mac", "oglesby", "from", "his", "correspondence", "with", "macquarie", "university", "prof", "john", "pickard", "who", "added", "the", "following", "note", "in", "the", "early", "1970s", "i", "contacted", "dr", "spencer", "about", "this", "method", "because", "i", "was", "trying", "to", "use", "a", "hand", "calculator", "for", "calculating", "solar", "positions", "etc", "he", "was", "extremely", "helpful", "and", "gave", "me", "a", "reprint", "of", "this", "paper", "he", "also", "pointed", "out", "an", "error", "in", "the", "original", "in", "the", "series", "for", "e", "the", "constant", "was", "printed", "as", "0", "000075", "rather", "than", "0", "0000075", "i", "have", "corrected", "the", "error", "in", "this", "version", "there", "appears", "to", "be", "another", "error", "in", "formula", "as", "printed", "in", "both", "duffie", "beckman", "s", "2", "_", "and", "frank", "vignola", "s", "3", "_", "books", "in", "which", "the", "coefficient", "0", "04089", "is", "printed", "instead", "of", "0", "040849", "corresponding", "to", "the", "value", "used", "in", "the", "bird", "clear", "sky", "model", "implemented", "by", "daryl", "myers", "4", "_", "and", "printed", "in", "both", "the", "fourier", "paper", "from", "the", "sundial", "mailing", "list", "and", "r", "hulstrom", "s", "5", "_", "book", "_fourier", "paper", "http", "www", "mail", "archive", "com", "sundial", "uni", "koeln", "de", "msg01050", "html", "parameters", "dayofyear", "numeric", "returns", "equation_of_time", "numeric", "difference", "in", "time", "between", "solar", "time", "and", "mean", "solar", "time", "in", "minutes", "references", "1", "j", "w", "spencer", "fourier", "series", "representation", "of", "the", "position", "of", "the", "sun", "in", "search", "2", "5", "p", "172", "1971", "2", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "9", "11", "j", "wiley", "and", "sons", "new", "york", "2006", "3", "frank", "vignola", "et", "al", "solar", "and", "infrared", "radiation", "measurements", "p", "13", "crc", "press", "2012", "4", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "p", "5", "crc", "press", "2013", "5", "roland", "hulstrom", "solar", "resources", "p", "66", "mit", "press", "1989", "see", "also", "equation_of_time_pvcdrom", "day_angle", "_calculate_simple_day_angle", "dayofyear", "convert", "from", "radians", "to", "minutes", "per", "day", "24", "h", "day", "60", "min", "h", "2", "pi", "eot", "1440", "0", "2", "np", "pi", "0", "0000075", "0", "001868", "np", "cos", "day_angle", "0", "032077", "np", "sin", "day_angle", "0", "014615", "np", "cos", "2", "0", "day_angle", "0", "040849", "np", "sin", "2", "0", "day_angle", "return", "eot"], "doc_len": 377}
{"doc_id": "pvlib/solarposition.py::equation_of_time_pvcdrom", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "equation_of_time_pvcdrom", "text": "文件路径: pvlib/solarposition.py\ndef equation_of_time_pvcdrom(dayofyear):\n    \"\"\"\n    Equation of time from PVCDROM.\n\n    `PVCDROM`_ is a website by Solar Power Lab at Arizona State\n    University (ASU)\n\n    .. _PVCDROM: http://www.pveducation.org/pvcdrom/2-properties-sunlight/solar-time\n\n    Parameters\n    ----------\n    dayofyear : numeric\n\n    Returns\n    -------\n    equation_of_time : numeric\n        Difference in time between solar time and mean solar time in minutes.\n\n    References\n    ----------\n    .. [1] Soteris A. Kalogirou, \"Solar Energy Engineering Processes and\n       Systems, 2nd Edition\" Elselvier/Academic Press (2009).\n\n    See Also\n    --------\n    equation_of_time_spencer71\n    \"\"\"\n    # day angle relative to Vernal Equinox, typically March 22 (day number 81)\n    bday = \\\n        _calculate_simple_day_angle(dayofyear) - (2.0 * np.pi / 365.0) * 80.0\n    # same value but about 2x faster than Spencer (1971)\n    return 9.87 * np.sin(2.0 * bday) - 7.53 * np.cos(bday) - 1.5 * np.sin(bday)\n", "tokens": ["pvlib", "solarposition", "py", "def", "equation_of_time_pvcdrom", "dayofyear", "equation", "of", "time", "from", "pvcdrom", "pvcdrom", "_", "is", "a", "website", "by", "solar", "power", "lab", "at", "arizona", "state", "university", "asu", "_pvcdrom", "http", "www", "pveducation", "org", "pvcdrom", "2", "properties", "sunlight", "solar", "time", "parameters", "dayofyear", "numeric", "returns", "equation_of_time", "numeric", "difference", "in", "time", "between", "solar", "time", "and", "mean", "solar", "time", "in", "minutes", "references", "1", "soteris", "a", "kalogirou", "solar", "energy", "engineering", "processes", "and", "systems", "2nd", "edition", "elselvier", "academic", "press", "2009", "see", "also", "equation_of_time_spencer71", "day", "angle", "relative", "to", "vernal", "equinox", "typically", "march", "22", "day", "number", "81", "bday", "_calculate_simple_day_angle", "dayofyear", "2", "0", "np", "pi", "365", "0", "80", "0", "same", "value", "but", "about", "2x", "faster", "than", "spencer", "1971", "return", "9", "87", "np", "sin", "2", "0", "bday", "7", "53", "np", "cos", "bday", "1", "5", "np", "sin", "bday"], "doc_len": 124}
{"doc_id": "pvlib/solarposition.py::declination_spencer71", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "declination_spencer71", "text": "文件路径: pvlib/solarposition.py\ndef declination_spencer71(dayofyear):\n    \"\"\"\n    Solar declination from Duffie & Beckman and attributed to\n    Spencer (1971) and Iqbal (1983).\n\n    See [1]_ for details.\n\n    .. warning::\n        Return units are radians, not degrees.\n\n    Parameters\n    ----------\n    dayofyear : numeric\n\n    Returns\n    -------\n    declination (radians) : numeric\n        Angular position of the sun at solar noon relative to the plane of the\n        equator, approximately between +/-23.45 (degrees).\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 13-14, J. Wiley and Sons, New York (2006)\n\n    .. [2] J. W. Spencer, \"Fourier series representation of the position of the\n       sun\" in Search 2 (5), p. 172 (1971)\n\n    .. [3] Daryl R. Myers, \"Solar Radiation: Practical Modeling for Renewable\n       Energy Applications\", p. 4 CRC Press (2013)\n\n    See Also\n    --------\n    declination_cooper69\n    \"\"\"\n    day_angle = _calculate_simple_day_angle(dayofyear)\n    return (\n        0.006918 -\n        0.399912 * np.cos(day_angle) + 0.070257 * np.sin(day_angle) -\n        0.006758 * np.cos(2. * day_angle) + 0.000907 * np.sin(2. * day_angle) -\n        0.002697 * np.cos(3. * day_angle) + 0.00148 * np.sin(3. * day_angle)\n    )\n", "tokens": ["pvlib", "solarposition", "py", "def", "declination_spencer71", "dayofyear", "solar", "declination", "from", "duffie", "beckman", "and", "attributed", "to", "spencer", "1971", "and", "iqbal", "1983", "see", "1", "_", "for", "details", "warning", "return", "units", "are", "radians", "not", "degrees", "parameters", "dayofyear", "numeric", "returns", "declination", "radians", "numeric", "angular", "position", "of", "the", "sun", "at", "solar", "noon", "relative", "to", "the", "plane", "of", "the", "equator", "approximately", "between", "23", "45", "degrees", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "13", "14", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "j", "w", "spencer", "fourier", "series", "representation", "of", "the", "position", "of", "the", "sun", "in", "search", "2", "5", "p", "172", "1971", "3", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "p", "4", "crc", "press", "2013", "see", "also", "declination_cooper69", "day_angle", "_calculate_simple_day_angle", "dayofyear", "return", "0", "006918", "0", "399912", "np", "cos", "day_angle", "0", "070257", "np", "sin", "day_angle", "0", "006758", "np", "cos", "2", "day_angle", "0", "000907", "np", "sin", "2", "day_angle", "0", "002697", "np", "cos", "3", "day_angle", "0", "00148", "np", "sin", "3", "day_angle"], "doc_len": 164}
{"doc_id": "pvlib/solarposition.py::declination_cooper69", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "declination_cooper69", "text": "文件路径: pvlib/solarposition.py\ndef declination_cooper69(dayofyear):\n    \"\"\"\n    Solar declination from Duffie & Beckman and attributed to Cooper (1969).\n\n    See [1]_ for details.\n\n    .. warning::\n        Return units are radians, not degrees.\n\n    Declination can be expressed using either sine or cosine:\n\n    .. math::\n\n       \\\\delta = 23.45 \\\\sin \\\\left( \\\\frac{2 \\\\pi}{365} \\\\left(n_{day} + 284\n       \\\\right) \\\\right) = -23.45 \\\\cos \\\\left( \\\\frac{2 \\\\pi}{365}\n       \\\\left(n_{day} + 10 \\\\right) \\\\right)\n\n    Parameters\n    ----------\n    dayofyear : numeric\n\n    Returns\n    -------\n    declination (radians) : numeric\n        Angular position of the sun at solar noon relative to the plane of the\n        equator, approximately between +/-23.45 (degrees).\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 13-14, J. Wiley and Sons, New York (2006)\n\n    .. [2] J. H. Seinfeld and S. N. Pandis, \"Atmospheric Chemistry and Physics\"\n       p. 129, J. Wiley (1998)\n\n    .. [3] Daryl R. Myers, \"Solar Radiation: Practical Modeling for Renewable\n       Energy Applications\", p. 4 CRC Press (2013)\n\n    See Also\n    --------\n    declination_spencer71\n    \"\"\"\n    day_angle = _calculate_simple_day_angle(dayofyear)\n    dec = np.deg2rad(23.45 * np.sin(day_angle + (2.0 * np.pi / 365.0) * 285.0))\n    return dec\n", "tokens": ["pvlib", "solarposition", "py", "def", "declination_cooper69", "dayofyear", "solar", "declination", "from", "duffie", "beckman", "and", "attributed", "to", "cooper", "1969", "see", "1", "_", "for", "details", "warning", "return", "units", "are", "radians", "not", "degrees", "declination", "can", "be", "expressed", "using", "either", "sine", "or", "cosine", "math", "delta", "23", "45", "sin", "left", "frac", "2", "pi", "365", "left", "n_", "day", "284", "right", "right", "23", "45", "cos", "left", "frac", "2", "pi", "365", "left", "n_", "day", "10", "right", "right", "parameters", "dayofyear", "numeric", "returns", "declination", "radians", "numeric", "angular", "position", "of", "the", "sun", "at", "solar", "noon", "relative", "to", "the", "plane", "of", "the", "equator", "approximately", "between", "23", "45", "degrees", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "13", "14", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "j", "h", "seinfeld", "and", "s", "n", "pandis", "atmospheric", "chemistry", "and", "physics", "p", "129", "j", "wiley", "1998", "3", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "p", "4", "crc", "press", "2013", "see", "also", "declination_spencer71", "day_angle", "_calculate_simple_day_angle", "dayofyear", "dec", "np", "deg2rad", "23", "45", "np", "sin", "day_angle", "2", "0", "np", "pi", "365", "0", "285", "0", "return", "dec"], "doc_len": 178}
{"doc_id": "pvlib/solarposition.py::solar_azimuth_analytical", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "solar_azimuth_analytical", "text": "文件路径: pvlib/solarposition.py\ndef solar_azimuth_analytical(latitude, hourangle, declination, zenith):\n    \"\"\"\n    Analytical expression of solar azimuth angle based on spherical\n    trigonometry.\n\n    Parameters\n    ----------\n    latitude : numeric\n        Latitude of location in radians.\n    hourangle : numeric\n        Hour angle in the local solar time in radians.\n    declination : numeric\n        Declination of the sun in radians.\n    zenith : numeric\n        Solar zenith angle in radians.\n\n    Returns\n    -------\n    azimuth : numeric\n        Solar azimuth angle in radians.\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 14, J. Wiley and Sons, New York (2006)\n\n    .. [2] J. H. Seinfeld and S. N. Pandis, \"Atmospheric Chemistry and Physics\"\n       p. 132, J. Wiley (1998)\n\n    .. [3] `Wikipedia: Solar Azimuth Angle\n       <https://en.wikipedia.org/wiki/Solar_azimuth_angle>`_\n\n    .. [4] `PVCDROM: Azimuth Angle <http://www.pveducation.org/pvcdrom/2-\n       properties-sunlight/azimuth-angle>`_\n\n    See Also\n    --------\n    declination_spencer71\n    declination_cooper69\n    hour_angle\n    solar_zenith_analytical\n    \"\"\"\n\n    numer = (np.cos(zenith) * np.sin(latitude) - np.sin(declination))\n    denom = (np.sin(zenith) * np.cos(latitude))\n\n    # cases that would generate new NaN values are safely ignored here\n    # since they are dealt with further below\n    with np.errstate(invalid='ignore', divide='ignore'):\n        cos_azi = numer / denom\n\n    # when zero division occurs, use the limit value of the analytical\n    # expression\n    cos_azi = \\\n        np.where(np.isclose(denom,    0.0, rtol=0.0, atol=1e-8),  1.0, cos_azi)\n\n    # when too many round-ups in floating point math take cos_azi beyond\n    # 1.0, use 1.0\n    cos_azi = \\\n        np.where(np.isclose(cos_azi,  1.0, rtol=0.0, atol=1e-8),  1.0, cos_azi)\n    cos_azi = \\\n        np.where(np.isclose(cos_azi, -1.0, rtol=0.0, atol=1e-8), -1.0, cos_azi)\n\n    # when NaN values occur in input, ignore and pass to output\n    with np.errstate(invalid='ignore'):\n        sign_ha = np.sign(hourangle)\n\n    return sign_ha * np.arccos(cos_azi) + np.pi\n", "tokens": ["pvlib", "solarposition", "py", "def", "solar_azimuth_analytical", "latitude", "hourangle", "declination", "zenith", "analytical", "expression", "of", "solar", "azimuth", "angle", "based", "on", "spherical", "trigonometry", "parameters", "latitude", "numeric", "latitude", "of", "location", "in", "radians", "hourangle", "numeric", "hour", "angle", "in", "the", "local", "solar", "time", "in", "radians", "declination", "numeric", "declination", "of", "the", "sun", "in", "radians", "zenith", "numeric", "solar", "zenith", "angle", "in", "radians", "returns", "azimuth", "numeric", "solar", "azimuth", "angle", "in", "radians", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "14", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "j", "h", "seinfeld", "and", "s", "n", "pandis", "atmospheric", "chemistry", "and", "physics", "p", "132", "j", "wiley", "1998", "3", "wikipedia", "solar", "azimuth", "angle", "https", "en", "wikipedia", "org", "wiki", "solar_azimuth_angle", "_", "4", "pvcdrom", "azimuth", "angle", "http", "www", "pveducation", "org", "pvcdrom", "2", "properties", "sunlight", "azimuth", "angle", "_", "see", "also", "declination_spencer71", "declination_cooper69", "hour_angle", "solar_zenith_analytical", "numer", "np", "cos", "zenith", "np", "sin", "latitude", "np", "sin", "declination", "denom", "np", "sin", "zenith", "np", "cos", "latitude", "cases", "that", "would", "generate", "new", "nan", "values", "are", "safely", "ignored", "here", "since", "they", "are", "dealt", "with", "further", "below", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "cos_azi", "numer", "denom", "when", "zero", "division", "occurs", "use", "the", "limit", "value", "of", "the", "analytical", "expression", "cos_azi", "np", "where", "np", "isclose", "denom", "0", "0", "rtol", "0", "0", "atol", "1e", "8", "1", "0", "cos_azi", "when", "too", "many", "round", "ups", "in", "floating", "point", "math", "take", "cos_azi", "beyond", "1", "0", "use", "1", "0", "cos_azi", "np", "where", "np", "isclose", "cos_azi", "1", "0", "rtol", "0", "0", "atol", "1e", "8", "1", "0", "cos_azi", "cos_azi", "np", "where", "np", "isclose", "cos_azi", "1", "0", "rtol", "0", "0", "atol", "1e", "8", "1", "0", "cos_azi", "when", "nan", "values", "occur", "in", "input", "ignore", "and", "pass", "to", "output", "with", "np", "errstate", "invalid", "ignore", "sign_ha", "np", "sign", "hourangle", "return", "sign_ha", "np", "arccos", "cos_azi", "np", "pi"], "doc_len": 288}
{"doc_id": "pvlib/solarposition.py::solar_zenith_analytical", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "solar_zenith_analytical", "text": "文件路径: pvlib/solarposition.py\ndef solar_zenith_analytical(latitude, hourangle, declination):\n    \"\"\"\n    Analytical expression of solar zenith angle based on spherical\n    trigonometry.\n\n    .. warning:: The analytic form neglects the effect of atmospheric\n        refraction.\n\n    Parameters\n    ----------\n    latitude : numeric\n        Latitude of location in radians.\n    hourangle : numeric\n        Hour angle in the local solar time in radians.\n    declination : numeric\n        Declination of the sun in radians.\n\n    Returns\n    -------\n    zenith : numeric\n        Solar zenith angle in radians.\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 14, J. Wiley and Sons, New York (2006)\n\n    .. [2] J. H. Seinfeld and S. N. Pandis, \"Atmospheric Chemistry and\n       Physics\" p. 132, J. Wiley (1998)\n\n    .. [3] Daryl R. Myers, \"Solar Radiation: Practical Modeling for\n       Renewable Energy Applications\", p. 5 CRC Press (2013)\n\n    .. [4] `Wikipedia: Solar Zenith Angle\n       <https://en.wikipedia.org/wiki/Solar_zenith_angle>`_\n\n    .. [5] `PVCDROM: Sun's Position\n       <http://www.pveducation.org/pvcdrom/2-properties-sunlight/\n       suns-position>`_\n\n    See Also\n    --------\n    declination_spencer71\n    declination_cooper69\n    hour_angle\n    \"\"\"\n    return np.arccos(\n        np.cos(declination) * np.cos(latitude) * np.cos(hourangle) +\n        np.sin(declination) * np.sin(latitude)\n    )\n", "tokens": ["pvlib", "solarposition", "py", "def", "solar_zenith_analytical", "latitude", "hourangle", "declination", "analytical", "expression", "of", "solar", "zenith", "angle", "based", "on", "spherical", "trigonometry", "warning", "the", "analytic", "form", "neglects", "the", "effect", "of", "atmospheric", "refraction", "parameters", "latitude", "numeric", "latitude", "of", "location", "in", "radians", "hourangle", "numeric", "hour", "angle", "in", "the", "local", "solar", "time", "in", "radians", "declination", "numeric", "declination", "of", "the", "sun", "in", "radians", "returns", "zenith", "numeric", "solar", "zenith", "angle", "in", "radians", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "14", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "j", "h", "seinfeld", "and", "s", "n", "pandis", "atmospheric", "chemistry", "and", "physics", "p", "132", "j", "wiley", "1998", "3", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "p", "5", "crc", "press", "2013", "4", "wikipedia", "solar", "zenith", "angle", "https", "en", "wikipedia", "org", "wiki", "solar_zenith_angle", "_", "5", "pvcdrom", "sun", "s", "position", "http", "www", "pveducation", "org", "pvcdrom", "2", "properties", "sunlight", "suns", "position", "_", "see", "also", "declination_spencer71", "declination_cooper69", "hour_angle", "return", "np", "arccos", "np", "cos", "declination", "np", "cos", "latitude", "np", "cos", "hourangle", "np", "sin", "declination", "np", "sin", "latitude"], "doc_len": 173}
{"doc_id": "pvlib/solarposition.py::hour_angle", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "hour_angle", "text": "文件路径: pvlib/solarposition.py\ndef hour_angle(times, longitude, equation_of_time):\n    \"\"\"\n    Hour angle in local solar time. Zero at local solar noon.\n\n    Parameters\n    ----------\n    times : :class:`pandas.DatetimeIndex`\n        Corresponding timestamps, must be localized to the timezone for the\n        ``longitude``.\n    longitude : numeric\n        Longitude in degrees\n    equation_of_time : numeric\n        Equation of time in minutes.\n\n    Returns\n    -------\n    hour_angle : numeric\n        Hour angle in local solar time in degrees.\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition\" pp. 13, J. Wiley and Sons, New York (2006)\n\n    .. [2] J. H. Seinfeld and S. N. Pandis, \"Atmospheric Chemistry and Physics\"\n       p. 132, J. Wiley (1998)\n\n    .. [3] Daryl R. Myers, \"Solar Radiation: Practical Modeling for Renewable\n       Energy Applications\", p. 5 CRC Press (2013)\n\n    See Also\n    --------\n    equation_of_time_spencer71\n    equation_of_time_pvcdrom\n    \"\"\"\n    naive_times = times.tz_localize(None)  # naive but still localized\n    # hours - timezone = (times - normalized_times) - (naive_times - times)\n    hrs_minus_tzs = 1 / NS_PER_HR * (\n        2 * times.view(np.int64) - times.normalize().view(np.int64) -\n        naive_times.view(np.int64))\n    # ensure array return instead of a version-dependent pandas <T>Index\n    return np.asarray(\n        15. * (hrs_minus_tzs - 12.) + longitude + equation_of_time / 4.)\n", "tokens": ["pvlib", "solarposition", "py", "def", "hour_angle", "times", "longitude", "equation_of_time", "hour", "angle", "in", "local", "solar", "time", "zero", "at", "local", "solar", "noon", "parameters", "times", "class", "pandas", "datetimeindex", "corresponding", "timestamps", "must", "be", "localized", "to", "the", "timezone", "for", "the", "longitude", "longitude", "numeric", "longitude", "in", "degrees", "equation_of_time", "numeric", "equation", "of", "time", "in", "minutes", "returns", "hour_angle", "numeric", "hour", "angle", "in", "local", "solar", "time", "in", "degrees", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "pp", "13", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "j", "h", "seinfeld", "and", "s", "n", "pandis", "atmospheric", "chemistry", "and", "physics", "p", "132", "j", "wiley", "1998", "3", "daryl", "r", "myers", "solar", "radiation", "practical", "modeling", "for", "renewable", "energy", "applications", "p", "5", "crc", "press", "2013", "see", "also", "equation_of_time_spencer71", "equation_of_time_pvcdrom", "naive_times", "times", "tz_localize", "none", "naive", "but", "still", "localized", "hours", "timezone", "times", "normalized_times", "naive_times", "times", "hrs_minus_tzs", "1", "ns_per_hr", "2", "times", "view", "np", "int64", "times", "normalize", "view", "np", "int64", "naive_times", "view", "np", "int64", "ensure", "array", "return", "instead", "of", "a", "version", "dependent", "pandas", "t", "index", "return", "np", "asarray", "15", "hrs_minus_tzs", "12", "longitude", "equation_of_time", "4"], "doc_len": 172}
{"doc_id": "pvlib/solarposition.py::_hour_angle_to_hours", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_hour_angle_to_hours", "text": "文件路径: pvlib/solarposition.py\ndef _hour_angle_to_hours(times, hourangle, longitude, equation_of_time):\n    \"\"\"converts hour angles in degrees to hours as a numpy array\"\"\"\n    naive_times = times.tz_localize(None)  # naive but still localized\n    tzs = 1 / NS_PER_HR * (\n        naive_times.view(np.int64) - times.view(np.int64))\n    hours = (hourangle - longitude - equation_of_time / 4.) / 15. + 12. + tzs\n    return np.asarray(hours)\n", "tokens": ["pvlib", "solarposition", "py", "def", "_hour_angle_to_hours", "times", "hourangle", "longitude", "equation_of_time", "converts", "hour", "angles", "in", "degrees", "to", "hours", "as", "a", "numpy", "array", "naive_times", "times", "tz_localize", "none", "naive", "but", "still", "localized", "tzs", "1", "ns_per_hr", "naive_times", "view", "np", "int64", "times", "view", "np", "int64", "hours", "hourangle", "longitude", "equation_of_time", "4", "15", "12", "tzs", "return", "np", "asarray", "hours"], "doc_len": 51}
{"doc_id": "pvlib/solarposition.py::_local_times_from_hours_since_midnight", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_local_times_from_hours_since_midnight", "text": "文件路径: pvlib/solarposition.py\ndef _local_times_from_hours_since_midnight(times, hours):\n    \"\"\"\n    converts hours since midnight from an array of floats to localized times\n    \"\"\"\n    tz_info = times.tz  # pytz timezone info\n    naive_times = times.tz_localize(None)  # naive but still localized\n    # normalize local, naive times to previous midnight and add the hours until\n    # sunrise, sunset, and transit\n    return pd.DatetimeIndex(\n        (naive_times.normalize().view(np.int64) +\n         (hours * NS_PER_HR).astype(np.int64)).astype('datetime64[ns]'),\n        tz=tz_info)\n", "tokens": ["pvlib", "solarposition", "py", "def", "_local_times_from_hours_since_midnight", "times", "hours", "converts", "hours", "since", "midnight", "from", "an", "array", "of", "floats", "to", "localized", "times", "tz_info", "times", "tz", "pytz", "timezone", "info", "naive_times", "times", "tz_localize", "none", "naive", "but", "still", "localized", "normalize", "local", "naive", "times", "to", "previous", "midnight", "and", "add", "the", "hours", "until", "sunrise", "sunset", "and", "transit", "return", "pd", "datetimeindex", "naive_times", "normalize", "view", "np", "int64", "hours", "ns_per_hr", "astype", "np", "int64", "astype", "datetime64", "ns", "tz", "tz_info"], "doc_len": 67}
{"doc_id": "pvlib/solarposition.py::_times_to_hours_after_local_midnight", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "_times_to_hours_after_local_midnight", "text": "文件路径: pvlib/solarposition.py\ndef _times_to_hours_after_local_midnight(times):\n    \"\"\"convert local pandas datetime indices to array of hours as floats\"\"\"\n    times = times.tz_localize(None)\n    hrs = 1 / NS_PER_HR * (\n        times.view(np.int64) - times.normalize().view(np.int64))\n    return np.array(hrs)\n", "tokens": ["pvlib", "solarposition", "py", "def", "_times_to_hours_after_local_midnight", "times", "convert", "local", "pandas", "datetime", "indices", "to", "array", "of", "hours", "as", "floats", "times", "times", "tz_localize", "none", "hrs", "1", "ns_per_hr", "times", "view", "np", "int64", "times", "normalize", "view", "np", "int64", "return", "np", "array", "hrs"], "doc_len": 37}
{"doc_id": "pvlib/solarposition.py::sun_rise_set_transit_geometric", "file_path": "pvlib/solarposition.py", "class_name": null, "func_name": "sun_rise_set_transit_geometric", "text": "文件路径: pvlib/solarposition.py\ndef sun_rise_set_transit_geometric(times, latitude, longitude, declination,\n                                   equation_of_time):\n    \"\"\"\n    Geometric calculation of solar sunrise, sunset, and transit.\n\n    .. warning:: The geometric calculation assumes a circular earth orbit with\n        the sun as a point source at its center, and neglects the effect of\n        atmospheric refraction on zenith. The error depends on location and\n        time of year but is of order 10 minutes.\n\n    Parameters\n    ----------\n    times : pandas.DatetimeIndex\n        Corresponding timestamps, must be localized to the timezone for the\n        ``latitude`` and ``longitude``.\n    latitude : float\n        Latitude in degrees, positive north of equator, negative to south\n    longitude : float\n        Longitude in degrees, positive east of prime meridian, negative to west\n    declination : numeric\n        declination angle in radians at ``times``\n    equation_of_time : numeric\n        difference in time between solar time and mean solar time in minutes\n\n    Returns\n    -------\n    sunrise : datetime\n        localized sunrise time\n    sunset : datetime\n        localized sunset time\n    transit : datetime\n        localized sun transit time\n\n    References\n    ----------\n    .. [1] J. A. Duffie and W. A. Beckman,  \"Solar Engineering of Thermal\n       Processes, 3rd Edition,\" J. Wiley and Sons, New York (2006)\n\n    .. [2] Frank Vignola et al., \"Solar And Infrared Radiation Measurements,\"\n       CRC Press (2012)\n\n    \"\"\"\n    latitude_rad = np.radians(latitude)  # radians\n    sunset_angle_rad = np.arccos(-np.tan(declination) * np.tan(latitude_rad))\n    sunset_angle = np.degrees(sunset_angle_rad)  # degrees\n    # solar noon is at hour angle zero\n    # so sunrise is just negative of sunset\n    sunrise_angle = -sunset_angle\n    sunrise_hour = _hour_angle_to_hours(\n        times, sunrise_angle, longitude, equation_of_time)\n    sunset_hour = _hour_angle_to_hours(\n        times, sunset_angle, longitude, equation_of_time)\n    transit_hour = _hour_angle_to_hours(times, 0, longitude, equation_of_time)\n    sunrise = _local_times_from_hours_since_midnight(times, sunrise_hour)\n    sunset = _local_times_from_hours_since_midnight(times, sunset_hour)\n    transit = _local_times_from_hours_since_midnight(times, transit_hour)\n    return sunrise, sunset, transit\n", "tokens": ["pvlib", "solarposition", "py", "def", "sun_rise_set_transit_geometric", "times", "latitude", "longitude", "declination", "equation_of_time", "geometric", "calculation", "of", "solar", "sunrise", "sunset", "and", "transit", "warning", "the", "geometric", "calculation", "assumes", "a", "circular", "earth", "orbit", "with", "the", "sun", "as", "a", "point", "source", "at", "its", "center", "and", "neglects", "the", "effect", "of", "atmospheric", "refraction", "on", "zenith", "the", "error", "depends", "on", "location", "and", "time", "of", "year", "but", "is", "of", "order", "10", "minutes", "parameters", "times", "pandas", "datetimeindex", "corresponding", "timestamps", "must", "be", "localized", "to", "the", "timezone", "for", "the", "latitude", "and", "longitude", "latitude", "float", "latitude", "in", "degrees", "positive", "north", "of", "equator", "negative", "to", "south", "longitude", "float", "longitude", "in", "degrees", "positive", "east", "of", "prime", "meridian", "negative", "to", "west", "declination", "numeric", "declination", "angle", "in", "radians", "at", "times", "equation_of_time", "numeric", "difference", "in", "time", "between", "solar", "time", "and", "mean", "solar", "time", "in", "minutes", "returns", "sunrise", "datetime", "localized", "sunrise", "time", "sunset", "datetime", "localized", "sunset", "time", "transit", "datetime", "localized", "sun", "transit", "time", "references", "1", "j", "a", "duffie", "and", "w", "a", "beckman", "solar", "engineering", "of", "thermal", "processes", "3rd", "edition", "j", "wiley", "and", "sons", "new", "york", "2006", "2", "frank", "vignola", "et", "al", "solar", "and", "infrared", "radiation", "measurements", "crc", "press", "2012", "latitude_rad", "np", "radians", "latitude", "radians", "sunset_angle_rad", "np", "arccos", "np", "tan", "declination", "np", "tan", "latitude_rad", "sunset_angle", "np", "degrees", "sunset_angle_rad", "degrees", "solar", "noon", "is", "at", "hour", "angle", "zero", "so", "sunrise", "is", "just", "negative", "of", "sunset", "sunrise_angle", "sunset_angle", "sunrise_hour", "_hour_angle_to_hours", "times", "sunrise_angle", "longitude", "equation_of_time", "sunset_hour", "_hour_angle_to_hours", "times", "sunset_angle", "longitude", "equation_of_time", "transit_hour", "_hour_angle_to_hours", "times", "0", "longitude", "equation_of_time", "sunrise", "_local_times_from_hours_since_midnight", "times", "sunrise_hour", "sunset", "_local_times_from_hours_since_midnight", "times", "sunset_hour", "transit", "_local_times_from_hours_since_midnight", "times", "transit_hour", "return", "sunrise", "sunset", "transit"], "doc_len": 247}
{"doc_id": "pvlib/spa.py::nocompile", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "nocompile", "text": "文件路径: pvlib/spa.py\ndef nocompile(*args, **kwargs):\n    return lambda func: func\n", "tokens": ["pvlib", "spa", "py", "def", "nocompile", "args", "kwargs", "return", "lambda", "func", "func"], "doc_len": 11}
{"doc_id": "pvlib/spa.py::julian_day_dt", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_day_dt", "text": "文件路径: pvlib/spa.py\ndef julian_day_dt(year, month, day, hour, minute, second, microsecond):\n    \"\"\"This is the original way to calculate the julian day from the NREL paper.\n    However, it is much faster to convert to unix/epoch time and then convert\n    to julian day. Note that the date must be UTC.\"\"\"\n    if month <= 2:\n        year = year-1\n        month = month+12\n    a = int(year/100)\n    b = 2 - a + int(a * 0.25)\n    frac_of_day = (microsecond / 1e6 + (second + minute * 60 + hour * 3600)\n                   ) * 1.0 / (3600*24)\n    d = day + frac_of_day\n    jd = (int(365.25 * (year + 4716)) + int(30.6001 * (month + 1)) + d +\n          b - 1524.5)\n    return jd\n", "tokens": ["pvlib", "spa", "py", "def", "julian_day_dt", "year", "month", "day", "hour", "minute", "second", "microsecond", "this", "is", "the", "original", "way", "to", "calculate", "the", "julian", "day", "from", "the", "nrel", "paper", "however", "it", "is", "much", "faster", "to", "convert", "to", "unix", "epoch", "time", "and", "then", "convert", "to", "julian", "day", "note", "that", "the", "date", "must", "be", "utc", "if", "month", "2", "year", "year", "1", "month", "month", "12", "a", "int", "year", "100", "b", "2", "a", "int", "a", "0", "25", "frac_of_day", "microsecond", "1e6", "second", "minute", "60", "hour", "3600", "1", "0", "3600", "24", "d", "day", "frac_of_day", "jd", "int", "365", "25", "year", "4716", "int", "30", "6001", "month", "1", "d", "b", "1524", "5", "return", "jd"], "doc_len": 102}
{"doc_id": "pvlib/spa.py::julian_day", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_day", "text": "文件路径: pvlib/spa.py\ndef julian_day(unixtime):\n    jd = unixtime * 1.0 / 86400 + 2440587.5\n    return jd\n", "tokens": ["pvlib", "spa", "py", "def", "julian_day", "unixtime", "jd", "unixtime", "1", "0", "86400", "2440587", "5", "return", "jd"], "doc_len": 15}
{"doc_id": "pvlib/spa.py::julian_ephemeris_day", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_ephemeris_day", "text": "文件路径: pvlib/spa.py\ndef julian_ephemeris_day(julian_day, delta_t):\n    jde = julian_day + delta_t * 1.0 / 86400\n    return jde\n", "tokens": ["pvlib", "spa", "py", "def", "julian_ephemeris_day", "julian_day", "delta_t", "jde", "julian_day", "delta_t", "1", "0", "86400", "return", "jde"], "doc_len": 15}
{"doc_id": "pvlib/spa.py::julian_century", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_century", "text": "文件路径: pvlib/spa.py\ndef julian_century(julian_day):\n    jc = (julian_day - 2451545) * 1.0 / 36525\n    return jc\n", "tokens": ["pvlib", "spa", "py", "def", "julian_century", "julian_day", "jc", "julian_day", "2451545", "1", "0", "36525", "return", "jc"], "doc_len": 14}
{"doc_id": "pvlib/spa.py::julian_ephemeris_century", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_ephemeris_century", "text": "文件路径: pvlib/spa.py\ndef julian_ephemeris_century(julian_ephemeris_day):\n    jce = (julian_ephemeris_day - 2451545) * 1.0 / 36525\n    return jce\n", "tokens": ["pvlib", "spa", "py", "def", "julian_ephemeris_century", "julian_ephemeris_day", "jce", "julian_ephemeris_day", "2451545", "1", "0", "36525", "return", "jce"], "doc_len": 14}
{"doc_id": "pvlib/spa.py::julian_ephemeris_millennium", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "julian_ephemeris_millennium", "text": "文件路径: pvlib/spa.py\ndef julian_ephemeris_millennium(julian_ephemeris_century):\n    jme = julian_ephemeris_century * 1.0 / 10\n    return jme\n", "tokens": ["pvlib", "spa", "py", "def", "julian_ephemeris_millennium", "julian_ephemeris_century", "jme", "julian_ephemeris_century", "1", "0", "10", "return", "jme"], "doc_len": 13}
{"doc_id": "pvlib/spa.py::heliocentric_longitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "heliocentric_longitude", "text": "文件路径: pvlib/spa.py\ndef heliocentric_longitude(jme):\n    l0 = 0.0\n    l1 = 0.0\n    l2 = 0.0\n    l3 = 0.0\n    l4 = 0.0\n    l5 = 0.0\n\n    for row in range(HELIO_LONG_TABLE.shape[1]):\n        l0 += (HELIO_LONG_TABLE[0, row, 0]\n               * np.cos(HELIO_LONG_TABLE[0, row, 1]\n                        + HELIO_LONG_TABLE[0, row, 2] * jme)\n               )\n        l1 += (HELIO_LONG_TABLE[1, row, 0]\n               * np.cos(HELIO_LONG_TABLE[1, row, 1]\n                        + HELIO_LONG_TABLE[1, row, 2] * jme)\n               )\n        l2 += (HELIO_LONG_TABLE[2, row, 0]\n               * np.cos(HELIO_LONG_TABLE[2, row, 1]\n                        + HELIO_LONG_TABLE[2, row, 2] * jme)\n               )\n        l3 += (HELIO_LONG_TABLE[3, row, 0]\n               * np.cos(HELIO_LONG_TABLE[3, row, 1]\n                        + HELIO_LONG_TABLE[3, row, 2] * jme)\n               )\n        l4 += (HELIO_LONG_TABLE[4, row, 0]\n               * np.cos(HELIO_LONG_TABLE[4, row, 1]\n                        + HELIO_LONG_TABLE[4, row, 2] * jme)\n               )\n        l5 += (HELIO_LONG_TABLE[5, row, 0]\n               * np.cos(HELIO_LONG_TABLE[5, row, 1]\n                        + HELIO_LONG_TABLE[5, row, 2] * jme)\n               )\n\n    l_rad = (l0 + l1 * jme + l2 * jme**2 + l3 * jme**3 + l4 * jme**4 +\n             l5 * jme**5)/10**8\n    l = np.rad2deg(l_rad)\n    return l % 360\n", "tokens": ["pvlib", "spa", "py", "def", "heliocentric_longitude", "jme", "l0", "0", "0", "l1", "0", "0", "l2", "0", "0", "l3", "0", "0", "l4", "0", "0", "l5", "0", "0", "for", "row", "in", "range", "helio_long_table", "shape", "1", "l0", "helio_long_table", "0", "row", "0", "np", "cos", "helio_long_table", "0", "row", "1", "helio_long_table", "0", "row", "2", "jme", "l1", "helio_long_table", "1", "row", "0", "np", "cos", "helio_long_table", "1", "row", "1", "helio_long_table", "1", "row", "2", "jme", "l2", "helio_long_table", "2", "row", "0", "np", "cos", "helio_long_table", "2", "row", "1", "helio_long_table", "2", "row", "2", "jme", "l3", "helio_long_table", "3", "row", "0", "np", "cos", "helio_long_table", "3", "row", "1", "helio_long_table", "3", "row", "2", "jme", "l4", "helio_long_table", "4", "row", "0", "np", "cos", "helio_long_table", "4", "row", "1", "helio_long_table", "4", "row", "2", "jme", "l5", "helio_long_table", "5", "row", "0", "np", "cos", "helio_long_table", "5", "row", "1", "helio_long_table", "5", "row", "2", "jme", "l_rad", "l0", "l1", "jme", "l2", "jme", "2", "l3", "jme", "3", "l4", "jme", "4", "l5", "jme", "5", "10", "8", "l", "np", "rad2deg", "l_rad", "return", "l", "360"], "doc_len": 152}
{"doc_id": "pvlib/spa.py::heliocentric_latitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "heliocentric_latitude", "text": "文件路径: pvlib/spa.py\ndef heliocentric_latitude(jme):\n    b0 = 0.0\n    b1 = 0.0\n    for row in range(HELIO_LAT_TABLE.shape[1]):\n        b0 += (HELIO_LAT_TABLE[0, row, 0]\n               * np.cos(HELIO_LAT_TABLE[0, row, 1]\n                        + HELIO_LAT_TABLE[0, row, 2] * jme)\n               )\n        b1 += (HELIO_LAT_TABLE[1, row, 0]\n               * np.cos(HELIO_LAT_TABLE[1, row, 1]\n                        + HELIO_LAT_TABLE[1, row, 2] * jme)\n               )\n\n    b_rad = (b0 + b1 * jme)/10**8\n    b = np.rad2deg(b_rad)\n    return b\n", "tokens": ["pvlib", "spa", "py", "def", "heliocentric_latitude", "jme", "b0", "0", "0", "b1", "0", "0", "for", "row", "in", "range", "helio_lat_table", "shape", "1", "b0", "helio_lat_table", "0", "row", "0", "np", "cos", "helio_lat_table", "0", "row", "1", "helio_lat_table", "0", "row", "2", "jme", "b1", "helio_lat_table", "1", "row", "0", "np", "cos", "helio_lat_table", "1", "row", "1", "helio_lat_table", "1", "row", "2", "jme", "b_rad", "b0", "b1", "jme", "10", "8", "b", "np", "rad2deg", "b_rad", "return", "b"], "doc_len": 63}
{"doc_id": "pvlib/spa.py::heliocentric_radius_vector", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "heliocentric_radius_vector", "text": "文件路径: pvlib/spa.py\ndef heliocentric_radius_vector(jme):\n    r0 = 0.0\n    r1 = 0.0\n    r2 = 0.0\n    r3 = 0.0\n    r4 = 0.0\n    for row in range(HELIO_RADIUS_TABLE.shape[1]):\n        r0 += (HELIO_RADIUS_TABLE[0, row, 0]\n               * np.cos(HELIO_RADIUS_TABLE[0, row, 1]\n                        + HELIO_RADIUS_TABLE[0, row, 2] * jme)\n               )\n        r1 += (HELIO_RADIUS_TABLE[1, row, 0]\n               * np.cos(HELIO_RADIUS_TABLE[1, row, 1]\n                        + HELIO_RADIUS_TABLE[1, row, 2] * jme)\n               )\n        r2 += (HELIO_RADIUS_TABLE[2, row, 0]\n               * np.cos(HELIO_RADIUS_TABLE[2, row, 1]\n                        + HELIO_RADIUS_TABLE[2, row, 2] * jme)\n               )\n        r3 += (HELIO_RADIUS_TABLE[3, row, 0]\n               * np.cos(HELIO_RADIUS_TABLE[3, row, 1]\n                        + HELIO_RADIUS_TABLE[3, row, 2] * jme)\n               )\n        r4 += (HELIO_RADIUS_TABLE[4, row, 0]\n               * np.cos(HELIO_RADIUS_TABLE[4, row, 1]\n                        + HELIO_RADIUS_TABLE[4, row, 2] * jme)\n               )\n\n    r = (r0 + r1 * jme + r2 * jme**2 + r3 * jme**3 + r4 * jme**4)/10**8\n    return r\n", "tokens": ["pvlib", "spa", "py", "def", "heliocentric_radius_vector", "jme", "r0", "0", "0", "r1", "0", "0", "r2", "0", "0", "r3", "0", "0", "r4", "0", "0", "for", "row", "in", "range", "helio_radius_table", "shape", "1", "r0", "helio_radius_table", "0", "row", "0", "np", "cos", "helio_radius_table", "0", "row", "1", "helio_radius_table", "0", "row", "2", "jme", "r1", "helio_radius_table", "1", "row", "0", "np", "cos", "helio_radius_table", "1", "row", "1", "helio_radius_table", "1", "row", "2", "jme", "r2", "helio_radius_table", "2", "row", "0", "np", "cos", "helio_radius_table", "2", "row", "1", "helio_radius_table", "2", "row", "2", "jme", "r3", "helio_radius_table", "3", "row", "0", "np", "cos", "helio_radius_table", "3", "row", "1", "helio_radius_table", "3", "row", "2", "jme", "r4", "helio_radius_table", "4", "row", "0", "np", "cos", "helio_radius_table", "4", "row", "1", "helio_radius_table", "4", "row", "2", "jme", "r", "r0", "r1", "jme", "r2", "jme", "2", "r3", "jme", "3", "r4", "jme", "4", "10", "8", "return", "r"], "doc_len": 125}
{"doc_id": "pvlib/spa.py::geocentric_longitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "geocentric_longitude", "text": "文件路径: pvlib/spa.py\ndef geocentric_longitude(heliocentric_longitude):\n    theta = heliocentric_longitude + 180.0\n    return theta % 360\n", "tokens": ["pvlib", "spa", "py", "def", "geocentric_longitude", "heliocentric_longitude", "theta", "heliocentric_longitude", "180", "0", "return", "theta", "360"], "doc_len": 13}
{"doc_id": "pvlib/spa.py::geocentric_latitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "geocentric_latitude", "text": "文件路径: pvlib/spa.py\ndef geocentric_latitude(heliocentric_latitude):\n    beta = -1.0*heliocentric_latitude\n    return beta\n", "tokens": ["pvlib", "spa", "py", "def", "geocentric_latitude", "heliocentric_latitude", "beta", "1", "0", "heliocentric_latitude", "return", "beta"], "doc_len": 12}
{"doc_id": "pvlib/spa.py::mean_elongation", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "mean_elongation", "text": "文件路径: pvlib/spa.py\ndef mean_elongation(julian_ephemeris_century):\n    x0 = (297.85036\n          + 445267.111480 * julian_ephemeris_century\n          - 0.0019142 * julian_ephemeris_century**2\n          + julian_ephemeris_century**3 / 189474)\n    return x0\n", "tokens": ["pvlib", "spa", "py", "def", "mean_elongation", "julian_ephemeris_century", "x0", "297", "85036", "445267", "111480", "julian_ephemeris_century", "0", "0019142", "julian_ephemeris_century", "2", "julian_ephemeris_century", "3", "189474", "return", "x0"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::mean_anomaly_sun", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "mean_anomaly_sun", "text": "文件路径: pvlib/spa.py\ndef mean_anomaly_sun(julian_ephemeris_century):\n    x1 = (357.52772\n          + 35999.050340 * julian_ephemeris_century\n          - 0.0001603 * julian_ephemeris_century**2\n          - julian_ephemeris_century**3 / 300000)\n    return x1\n", "tokens": ["pvlib", "spa", "py", "def", "mean_anomaly_sun", "julian_ephemeris_century", "x1", "357", "52772", "35999", "050340", "julian_ephemeris_century", "0", "0001603", "julian_ephemeris_century", "2", "julian_ephemeris_century", "3", "300000", "return", "x1"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::mean_anomaly_moon", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "mean_anomaly_moon", "text": "文件路径: pvlib/spa.py\ndef mean_anomaly_moon(julian_ephemeris_century):\n    x2 = (134.96298\n          + 477198.867398 * julian_ephemeris_century\n          + 0.0086972 * julian_ephemeris_century**2\n          + julian_ephemeris_century**3 / 56250)\n    return x2\n", "tokens": ["pvlib", "spa", "py", "def", "mean_anomaly_moon", "julian_ephemeris_century", "x2", "134", "96298", "477198", "867398", "julian_ephemeris_century", "0", "0086972", "julian_ephemeris_century", "2", "julian_ephemeris_century", "3", "56250", "return", "x2"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::moon_argument_latitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "moon_argument_latitude", "text": "文件路径: pvlib/spa.py\ndef moon_argument_latitude(julian_ephemeris_century):\n    x3 = (93.27191\n          + 483202.017538 * julian_ephemeris_century\n          - 0.0036825 * julian_ephemeris_century**2\n          + julian_ephemeris_century**3 / 327270)\n    return x3\n", "tokens": ["pvlib", "spa", "py", "def", "moon_argument_latitude", "julian_ephemeris_century", "x3", "93", "27191", "483202", "017538", "julian_ephemeris_century", "0", "0036825", "julian_ephemeris_century", "2", "julian_ephemeris_century", "3", "327270", "return", "x3"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::moon_ascending_longitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "moon_ascending_longitude", "text": "文件路径: pvlib/spa.py\ndef moon_ascending_longitude(julian_ephemeris_century):\n    x4 = (125.04452\n          - 1934.136261 * julian_ephemeris_century\n          + 0.0020708 * julian_ephemeris_century**2\n          + julian_ephemeris_century**3 / 450000)\n    return x4\n", "tokens": ["pvlib", "spa", "py", "def", "moon_ascending_longitude", "julian_ephemeris_century", "x4", "125", "04452", "1934", "136261", "julian_ephemeris_century", "0", "0020708", "julian_ephemeris_century", "2", "julian_ephemeris_century", "3", "450000", "return", "x4"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::longitude_nutation", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "longitude_nutation", "text": "文件路径: pvlib/spa.py\ndef longitude_nutation(julian_ephemeris_century, x0, x1, x2, x3, x4):\n    delta_psi_sum = 0\n    for row in range(NUTATION_YTERM_ARRAY.shape[0]):\n        a = NUTATION_ABCD_ARRAY[row, 0]\n        b = NUTATION_ABCD_ARRAY[row, 1]\n        argsin = (NUTATION_YTERM_ARRAY[row, 0]*x0 +\n                  NUTATION_YTERM_ARRAY[row, 1]*x1 +\n                  NUTATION_YTERM_ARRAY[row, 2]*x2 +\n                  NUTATION_YTERM_ARRAY[row, 3]*x3 +\n                  NUTATION_YTERM_ARRAY[row, 4]*x4)\n        term = (a + b * julian_ephemeris_century) * np.sin(np.radians(argsin))\n        delta_psi_sum += term\n    delta_psi = delta_psi_sum*1.0/36000000\n    return delta_psi\n", "tokens": ["pvlib", "spa", "py", "def", "longitude_nutation", "julian_ephemeris_century", "x0", "x1", "x2", "x3", "x4", "delta_psi_sum", "0", "for", "row", "in", "range", "nutation_yterm_array", "shape", "0", "a", "nutation_abcd_array", "row", "0", "b", "nutation_abcd_array", "row", "1", "argsin", "nutation_yterm_array", "row", "0", "x0", "nutation_yterm_array", "row", "1", "x1", "nutation_yterm_array", "row", "2", "x2", "nutation_yterm_array", "row", "3", "x3", "nutation_yterm_array", "row", "4", "x4", "term", "a", "b", "julian_ephemeris_century", "np", "sin", "np", "radians", "argsin", "delta_psi_sum", "term", "delta_psi", "delta_psi_sum", "1", "0", "36000000", "return", "delta_psi"], "doc_len": 67}
{"doc_id": "pvlib/spa.py::obliquity_nutation", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "obliquity_nutation", "text": "文件路径: pvlib/spa.py\ndef obliquity_nutation(julian_ephemeris_century, x0, x1, x2, x3, x4):\n    delta_eps_sum = 0.0\n    for row in range(NUTATION_YTERM_ARRAY.shape[0]):\n        c = NUTATION_ABCD_ARRAY[row, 2]\n        d = NUTATION_ABCD_ARRAY[row, 3]\n        argcos = (NUTATION_YTERM_ARRAY[row, 0]*x0 +\n                  NUTATION_YTERM_ARRAY[row, 1]*x1 +\n                  NUTATION_YTERM_ARRAY[row, 2]*x2 +\n                  NUTATION_YTERM_ARRAY[row, 3]*x3 +\n                  NUTATION_YTERM_ARRAY[row, 4]*x4)\n        term = (c + d * julian_ephemeris_century) * np.cos(np.radians(argcos))\n        delta_eps_sum += term\n    delta_eps = delta_eps_sum*1.0/36000000\n    return delta_eps\n", "tokens": ["pvlib", "spa", "py", "def", "obliquity_nutation", "julian_ephemeris_century", "x0", "x1", "x2", "x3", "x4", "delta_eps_sum", "0", "0", "for", "row", "in", "range", "nutation_yterm_array", "shape", "0", "c", "nutation_abcd_array", "row", "2", "d", "nutation_abcd_array", "row", "3", "argcos", "nutation_yterm_array", "row", "0", "x0", "nutation_yterm_array", "row", "1", "x1", "nutation_yterm_array", "row", "2", "x2", "nutation_yterm_array", "row", "3", "x3", "nutation_yterm_array", "row", "4", "x4", "term", "c", "d", "julian_ephemeris_century", "np", "cos", "np", "radians", "argcos", "delta_eps_sum", "term", "delta_eps", "delta_eps_sum", "1", "0", "36000000", "return", "delta_eps"], "doc_len": 68}
{"doc_id": "pvlib/spa.py::mean_ecliptic_obliquity", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "mean_ecliptic_obliquity", "text": "文件路径: pvlib/spa.py\ndef mean_ecliptic_obliquity(julian_ephemeris_millennium):\n    U = 1.0*julian_ephemeris_millennium/10\n    e0 = (84381.448 - 4680.93 * U - 1.55 * U**2\n          + 1999.25 * U**3 - 51.38 * U**4 - 249.67 * U**5\n          - 39.05 * U**6 + 7.12 * U**7 + 27.87 * U**8\n          + 5.79 * U**9 + 2.45 * U**10)\n    return e0\n", "tokens": ["pvlib", "spa", "py", "def", "mean_ecliptic_obliquity", "julian_ephemeris_millennium", "u", "1", "0", "julian_ephemeris_millennium", "10", "e0", "84381", "448", "4680", "93", "u", "1", "55", "u", "2", "1999", "25", "u", "3", "51", "38", "u", "4", "249", "67", "u", "5", "39", "05", "u", "6", "7", "12", "u", "7", "27", "87", "u", "8", "5", "79", "u", "9", "2", "45", "u", "10", "return", "e0"], "doc_len": 55}
{"doc_id": "pvlib/spa.py::true_ecliptic_obliquity", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "true_ecliptic_obliquity", "text": "文件路径: pvlib/spa.py\ndef true_ecliptic_obliquity(mean_ecliptic_obliquity, obliquity_nutation):\n    e0 = mean_ecliptic_obliquity\n    deleps = obliquity_nutation\n    e = e0*1.0/3600 + deleps\n    return e\n", "tokens": ["pvlib", "spa", "py", "def", "true_ecliptic_obliquity", "mean_ecliptic_obliquity", "obliquity_nutation", "e0", "mean_ecliptic_obliquity", "deleps", "obliquity_nutation", "e", "e0", "1", "0", "3600", "deleps", "return", "e"], "doc_len": 19}
{"doc_id": "pvlib/spa.py::aberration_correction", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "aberration_correction", "text": "文件路径: pvlib/spa.py\ndef aberration_correction(earth_radius_vector):\n    deltau = -20.4898 / (3600 * earth_radius_vector)\n    return deltau\n", "tokens": ["pvlib", "spa", "py", "def", "aberration_correction", "earth_radius_vector", "deltau", "20", "4898", "3600", "earth_radius_vector", "return", "deltau"], "doc_len": 13}
{"doc_id": "pvlib/spa.py::apparent_sun_longitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "apparent_sun_longitude", "text": "文件路径: pvlib/spa.py\ndef apparent_sun_longitude(geocentric_longitude, longitude_nutation,\n                           aberration_correction):\n    lamd = geocentric_longitude + longitude_nutation + aberration_correction\n    return lamd\n", "tokens": ["pvlib", "spa", "py", "def", "apparent_sun_longitude", "geocentric_longitude", "longitude_nutation", "aberration_correction", "lamd", "geocentric_longitude", "longitude_nutation", "aberration_correction", "return", "lamd"], "doc_len": 14}
{"doc_id": "pvlib/spa.py::mean_sidereal_time", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "mean_sidereal_time", "text": "文件路径: pvlib/spa.py\ndef mean_sidereal_time(julian_day, julian_century):\n    v0 = (280.46061837 + 360.98564736629 * (julian_day - 2451545)\n          + 0.000387933 * julian_century**2 - julian_century**3 / 38710000)\n    return v0 % 360.0\n", "tokens": ["pvlib", "spa", "py", "def", "mean_sidereal_time", "julian_day", "julian_century", "v0", "280", "46061837", "360", "98564736629", "julian_day", "2451545", "0", "000387933", "julian_century", "2", "julian_century", "3", "38710000", "return", "v0", "360", "0"], "doc_len": 25}
{"doc_id": "pvlib/spa.py::apparent_sidereal_time", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "apparent_sidereal_time", "text": "文件路径: pvlib/spa.py\ndef apparent_sidereal_time(mean_sidereal_time, longitude_nutation,\n                           true_ecliptic_obliquity):\n    v = mean_sidereal_time + longitude_nutation * np.cos(\n        np.radians(true_ecliptic_obliquity))\n    return v\n", "tokens": ["pvlib", "spa", "py", "def", "apparent_sidereal_time", "mean_sidereal_time", "longitude_nutation", "true_ecliptic_obliquity", "v", "mean_sidereal_time", "longitude_nutation", "np", "cos", "np", "radians", "true_ecliptic_obliquity", "return", "v"], "doc_len": 18}
{"doc_id": "pvlib/spa.py::geocentric_sun_right_ascension", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "geocentric_sun_right_ascension", "text": "文件路径: pvlib/spa.py\ndef geocentric_sun_right_ascension(apparent_sun_longitude,\n                                   true_ecliptic_obliquity,\n                                   geocentric_latitude):\n    num = (np.sin(np.radians(apparent_sun_longitude))\n           * np.cos(np.radians(true_ecliptic_obliquity))\n           - np.tan(np.radians(geocentric_latitude))\n           * np.sin(np.radians(true_ecliptic_obliquity)))\n    alpha = np.degrees(np.arctan2(num, np.cos(\n        np.radians(apparent_sun_longitude))))\n    return alpha % 360\n", "tokens": ["pvlib", "spa", "py", "def", "geocentric_sun_right_ascension", "apparent_sun_longitude", "true_ecliptic_obliquity", "geocentric_latitude", "num", "np", "sin", "np", "radians", "apparent_sun_longitude", "np", "cos", "np", "radians", "true_ecliptic_obliquity", "np", "tan", "np", "radians", "geocentric_latitude", "np", "sin", "np", "radians", "true_ecliptic_obliquity", "alpha", "np", "degrees", "np", "arctan2", "num", "np", "cos", "np", "radians", "apparent_sun_longitude", "return", "alpha", "360"], "doc_len": 43}
{"doc_id": "pvlib/spa.py::geocentric_sun_declination", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "geocentric_sun_declination", "text": "文件路径: pvlib/spa.py\ndef geocentric_sun_declination(apparent_sun_longitude, true_ecliptic_obliquity,\n                               geocentric_latitude):\n    delta = np.degrees(np.arcsin(np.sin(np.radians(geocentric_latitude)) *\n                                 np.cos(np.radians(true_ecliptic_obliquity)) +\n                                 np.cos(np.radians(geocentric_latitude)) *\n                                 np.sin(np.radians(true_ecliptic_obliquity)) *\n                                 np.sin(np.radians(apparent_sun_longitude))))\n    return delta\n", "tokens": ["pvlib", "spa", "py", "def", "geocentric_sun_declination", "apparent_sun_longitude", "true_ecliptic_obliquity", "geocentric_latitude", "delta", "np", "degrees", "np", "arcsin", "np", "sin", "np", "radians", "geocentric_latitude", "np", "cos", "np", "radians", "true_ecliptic_obliquity", "np", "cos", "np", "radians", "geocentric_latitude", "np", "sin", "np", "radians", "true_ecliptic_obliquity", "np", "sin", "np", "radians", "apparent_sun_longitude", "return", "delta"], "doc_len": 40}
{"doc_id": "pvlib/spa.py::local_hour_angle", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "local_hour_angle", "text": "文件路径: pvlib/spa.py\ndef local_hour_angle(apparent_sidereal_time, observer_longitude,\n                     sun_right_ascension):\n    \"\"\"Measured westward from south\"\"\"\n    H = apparent_sidereal_time + observer_longitude - sun_right_ascension\n    return H % 360\n", "tokens": ["pvlib", "spa", "py", "def", "local_hour_angle", "apparent_sidereal_time", "observer_longitude", "sun_right_ascension", "measured", "westward", "from", "south", "h", "apparent_sidereal_time", "observer_longitude", "sun_right_ascension", "return", "h", "360"], "doc_len": 19}
{"doc_id": "pvlib/spa.py::equatorial_horizontal_parallax", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "equatorial_horizontal_parallax", "text": "文件路径: pvlib/spa.py\ndef equatorial_horizontal_parallax(earth_radius_vector):\n    xi = 8.794 / (3600 * earth_radius_vector)\n    return xi\n", "tokens": ["pvlib", "spa", "py", "def", "equatorial_horizontal_parallax", "earth_radius_vector", "xi", "8", "794", "3600", "earth_radius_vector", "return", "xi"], "doc_len": 13}
{"doc_id": "pvlib/spa.py::uterm", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "uterm", "text": "文件路径: pvlib/spa.py\ndef uterm(observer_latitude):\n    u = np.arctan(0.99664719 * np.tan(np.radians(observer_latitude)))\n    return u\n", "tokens": ["pvlib", "spa", "py", "def", "uterm", "observer_latitude", "u", "np", "arctan", "0", "99664719", "np", "tan", "np", "radians", "observer_latitude", "return", "u"], "doc_len": 18}
{"doc_id": "pvlib/spa.py::xterm", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "xterm", "text": "文件路径: pvlib/spa.py\ndef xterm(u, observer_latitude, observer_elevation):\n    x = (np.cos(u) + observer_elevation / 6378140\n         * np.cos(np.radians(observer_latitude)))\n    return x\n", "tokens": ["pvlib", "spa", "py", "def", "xterm", "u", "observer_latitude", "observer_elevation", "x", "np", "cos", "u", "observer_elevation", "6378140", "np", "cos", "np", "radians", "observer_latitude", "return", "x"], "doc_len": 21}
{"doc_id": "pvlib/spa.py::yterm", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "yterm", "text": "文件路径: pvlib/spa.py\ndef yterm(u, observer_latitude, observer_elevation):\n    y = (0.99664719 * np.sin(u) + observer_elevation / 6378140\n         * np.sin(np.radians(observer_latitude)))\n    return y\n", "tokens": ["pvlib", "spa", "py", "def", "yterm", "u", "observer_latitude", "observer_elevation", "y", "0", "99664719", "np", "sin", "u", "observer_elevation", "6378140", "np", "sin", "np", "radians", "observer_latitude", "return", "y"], "doc_len": 23}
{"doc_id": "pvlib/spa.py::parallax_sun_right_ascension", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "parallax_sun_right_ascension", "text": "文件路径: pvlib/spa.py\ndef parallax_sun_right_ascension(xterm, equatorial_horizontal_parallax,\n                                 local_hour_angle, geocentric_sun_declination):\n    num = (-xterm * np.sin(np.radians(equatorial_horizontal_parallax))\n           * np.sin(np.radians(local_hour_angle)))\n    denom = (np.cos(np.radians(geocentric_sun_declination))\n             - xterm * np.sin(np.radians(equatorial_horizontal_parallax))\n             * np.cos(np.radians(local_hour_angle)))\n    delta_alpha = np.degrees(np.arctan2(num, denom))\n    return delta_alpha\n", "tokens": ["pvlib", "spa", "py", "def", "parallax_sun_right_ascension", "xterm", "equatorial_horizontal_parallax", "local_hour_angle", "geocentric_sun_declination", "num", "xterm", "np", "sin", "np", "radians", "equatorial_horizontal_parallax", "np", "sin", "np", "radians", "local_hour_angle", "denom", "np", "cos", "np", "radians", "geocentric_sun_declination", "xterm", "np", "sin", "np", "radians", "equatorial_horizontal_parallax", "np", "cos", "np", "radians", "local_hour_angle", "delta_alpha", "np", "degrees", "np", "arctan2", "num", "denom", "return", "delta_alpha"], "doc_len": 47}
{"doc_id": "pvlib/spa.py::topocentric_sun_right_ascension", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_sun_right_ascension", "text": "文件路径: pvlib/spa.py\ndef topocentric_sun_right_ascension(geocentric_sun_right_ascension,\n                                    parallax_sun_right_ascension):\n    alpha_prime = geocentric_sun_right_ascension + parallax_sun_right_ascension\n    return alpha_prime\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_sun_right_ascension", "geocentric_sun_right_ascension", "parallax_sun_right_ascension", "alpha_prime", "geocentric_sun_right_ascension", "parallax_sun_right_ascension", "return", "alpha_prime"], "doc_len": 12}
{"doc_id": "pvlib/spa.py::topocentric_sun_declination", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_sun_declination", "text": "文件路径: pvlib/spa.py\ndef topocentric_sun_declination(geocentric_sun_declination, xterm, yterm,\n                                equatorial_horizontal_parallax,\n                                parallax_sun_right_ascension,\n                                local_hour_angle):\n    num = ((np.sin(np.radians(geocentric_sun_declination)) - yterm\n            * np.sin(np.radians(equatorial_horizontal_parallax)))\n           * np.cos(np.radians(parallax_sun_right_ascension)))\n    denom = (np.cos(np.radians(geocentric_sun_declination)) - xterm\n             * np.sin(np.radians(equatorial_horizontal_parallax))\n             * np.cos(np.radians(local_hour_angle)))\n    delta = np.degrees(np.arctan2(num, denom))\n    return delta\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_sun_declination", "geocentric_sun_declination", "xterm", "yterm", "equatorial_horizontal_parallax", "parallax_sun_right_ascension", "local_hour_angle", "num", "np", "sin", "np", "radians", "geocentric_sun_declination", "yterm", "np", "sin", "np", "radians", "equatorial_horizontal_parallax", "np", "cos", "np", "radians", "parallax_sun_right_ascension", "denom", "np", "cos", "np", "radians", "geocentric_sun_declination", "xterm", "np", "sin", "np", "radians", "equatorial_horizontal_parallax", "np", "cos", "np", "radians", "local_hour_angle", "delta", "np", "degrees", "np", "arctan2", "num", "denom", "return", "delta"], "doc_len": 54}
{"doc_id": "pvlib/spa.py::topocentric_local_hour_angle", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_local_hour_angle", "text": "文件路径: pvlib/spa.py\ndef topocentric_local_hour_angle(local_hour_angle,\n                                 parallax_sun_right_ascension):\n    H_prime = local_hour_angle - parallax_sun_right_ascension\n    return H_prime\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_local_hour_angle", "local_hour_angle", "parallax_sun_right_ascension", "h_prime", "local_hour_angle", "parallax_sun_right_ascension", "return", "h_prime"], "doc_len": 12}
{"doc_id": "pvlib/spa.py::topocentric_elevation_angle_without_atmosphere", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_elevation_angle_without_atmosphere", "text": "文件路径: pvlib/spa.py\ndef topocentric_elevation_angle_without_atmosphere(observer_latitude,\n                                                   topocentric_sun_declination,\n                                                   topocentric_local_hour_angle\n                                                   ):\n    e0 = np.degrees(np.arcsin(\n        np.sin(np.radians(observer_latitude))\n        * np.sin(np.radians(topocentric_sun_declination))\n        + np.cos(np.radians(observer_latitude))\n        * np.cos(np.radians(topocentric_sun_declination))\n        * np.cos(np.radians(topocentric_local_hour_angle))))\n    return e0\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_elevation_angle_without_atmosphere", "observer_latitude", "topocentric_sun_declination", "topocentric_local_hour_angle", "e0", "np", "degrees", "np", "arcsin", "np", "sin", "np", "radians", "observer_latitude", "np", "sin", "np", "radians", "topocentric_sun_declination", "np", "cos", "np", "radians", "observer_latitude", "np", "cos", "np", "radians", "topocentric_sun_declination", "np", "cos", "np", "radians", "topocentric_local_hour_angle", "return", "e0"], "doc_len": 40}
{"doc_id": "pvlib/spa.py::atmospheric_refraction_correction", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "atmospheric_refraction_correction", "text": "文件路径: pvlib/spa.py\ndef atmospheric_refraction_correction(local_pressure, local_temp,\n                                      topocentric_elevation_angle_wo_atmosphere,\n                                      atmos_refract):\n    # switch sets delta_e when the sun is below the horizon\n    switch = topocentric_elevation_angle_wo_atmosphere >= -1.0 * (\n        0.26667 + atmos_refract)\n    delta_e = ((local_pressure / 1010.0) * (283.0 / (273 + local_temp))\n               * 1.02 / (60 * np.tan(np.radians(\n                   topocentric_elevation_angle_wo_atmosphere\n                   + 10.3 / (topocentric_elevation_angle_wo_atmosphere\n                             + 5.11))))) * switch\n    return delta_e\n", "tokens": ["pvlib", "spa", "py", "def", "atmospheric_refraction_correction", "local_pressure", "local_temp", "topocentric_elevation_angle_wo_atmosphere", "atmos_refract", "switch", "sets", "delta_e", "when", "the", "sun", "is", "below", "the", "horizon", "switch", "topocentric_elevation_angle_wo_atmosphere", "1", "0", "0", "26667", "atmos_refract", "delta_e", "local_pressure", "1010", "0", "283", "0", "273", "local_temp", "1", "02", "60", "np", "tan", "np", "radians", "topocentric_elevation_angle_wo_atmosphere", "10", "3", "topocentric_elevation_angle_wo_atmosphere", "5", "11", "switch", "return", "delta_e"], "doc_len": 50}
{"doc_id": "pvlib/spa.py::topocentric_elevation_angle", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_elevation_angle", "text": "文件路径: pvlib/spa.py\ndef topocentric_elevation_angle(topocentric_elevation_angle_without_atmosphere,\n                                atmospheric_refraction_correction):\n    e = (topocentric_elevation_angle_without_atmosphere\n         + atmospheric_refraction_correction)\n    return e\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_elevation_angle", "topocentric_elevation_angle_without_atmosphere", "atmospheric_refraction_correction", "e", "topocentric_elevation_angle_without_atmosphere", "atmospheric_refraction_correction", "return", "e"], "doc_len": 12}
{"doc_id": "pvlib/spa.py::topocentric_zenith_angle", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_zenith_angle", "text": "文件路径: pvlib/spa.py\ndef topocentric_zenith_angle(topocentric_elevation_angle):\n    theta = 90 - topocentric_elevation_angle\n    return theta\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_zenith_angle", "topocentric_elevation_angle", "theta", "90", "topocentric_elevation_angle", "return", "theta"], "doc_len": 11}
{"doc_id": "pvlib/spa.py::topocentric_astronomers_azimuth", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_astronomers_azimuth", "text": "文件路径: pvlib/spa.py\ndef topocentric_astronomers_azimuth(topocentric_local_hour_angle,\n                                    topocentric_sun_declination,\n                                    observer_latitude):\n    num = np.sin(np.radians(topocentric_local_hour_angle))\n    denom = (np.cos(np.radians(topocentric_local_hour_angle))\n             * np.sin(np.radians(observer_latitude))\n             - np.tan(np.radians(topocentric_sun_declination))\n             * np.cos(np.radians(observer_latitude)))\n    gamma = np.degrees(np.arctan2(num, denom))\n    return gamma % 360\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_astronomers_azimuth", "topocentric_local_hour_angle", "topocentric_sun_declination", "observer_latitude", "num", "np", "sin", "np", "radians", "topocentric_local_hour_angle", "denom", "np", "cos", "np", "radians", "topocentric_local_hour_angle", "np", "sin", "np", "radians", "observer_latitude", "np", "tan", "np", "radians", "topocentric_sun_declination", "np", "cos", "np", "radians", "observer_latitude", "gamma", "np", "degrees", "np", "arctan2", "num", "denom", "return", "gamma", "360"], "doc_len": 45}
{"doc_id": "pvlib/spa.py::topocentric_azimuth_angle", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "topocentric_azimuth_angle", "text": "文件路径: pvlib/spa.py\ndef topocentric_azimuth_angle(topocentric_astronomers_azimuth):\n    phi = topocentric_astronomers_azimuth + 180\n    return phi % 360\n", "tokens": ["pvlib", "spa", "py", "def", "topocentric_azimuth_angle", "topocentric_astronomers_azimuth", "phi", "topocentric_astronomers_azimuth", "180", "return", "phi", "360"], "doc_len": 12}
{"doc_id": "pvlib/spa.py::sun_mean_longitude", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "sun_mean_longitude", "text": "文件路径: pvlib/spa.py\ndef sun_mean_longitude(julian_ephemeris_millennium):\n    M = (280.4664567 + 360007.6982779 * julian_ephemeris_millennium\n         + 0.03032028 * julian_ephemeris_millennium**2\n         + julian_ephemeris_millennium**3 / 49931\n         - julian_ephemeris_millennium**4 / 15300\n         - julian_ephemeris_millennium**5 / 2000000)\n    return M\n", "tokens": ["pvlib", "spa", "py", "def", "sun_mean_longitude", "julian_ephemeris_millennium", "m", "280", "4664567", "360007", "6982779", "julian_ephemeris_millennium", "0", "03032028", "julian_ephemeris_millennium", "2", "julian_ephemeris_millennium", "3", "49931", "julian_ephemeris_millennium", "4", "15300", "julian_ephemeris_millennium", "5", "2000000", "return", "m"], "doc_len": 27}
{"doc_id": "pvlib/spa.py::equation_of_time", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "equation_of_time", "text": "文件路径: pvlib/spa.py\ndef equation_of_time(sun_mean_longitude, geocentric_sun_right_ascension,\n                     longitude_nutation, true_ecliptic_obliquity):\n    E = (sun_mean_longitude - 0.0057183 - geocentric_sun_right_ascension +\n         longitude_nutation * np.cos(np.radians(true_ecliptic_obliquity)))\n    # limit between 0 and 360\n    E = E % 360\n    # convert to minutes\n    E *= 4\n    greater = E > 20\n    less = E < -20\n    other = (E <= 20) & (E >= -20)\n    E = greater * (E - 1440) + less * (E + 1440) + other * E\n    return E\n", "tokens": ["pvlib", "spa", "py", "def", "equation_of_time", "sun_mean_longitude", "geocentric_sun_right_ascension", "longitude_nutation", "true_ecliptic_obliquity", "e", "sun_mean_longitude", "0", "0057183", "geocentric_sun_right_ascension", "longitude_nutation", "np", "cos", "np", "radians", "true_ecliptic_obliquity", "limit", "between", "0", "and", "360", "e", "e", "360", "convert", "to", "minutes", "e", "4", "greater", "e", "20", "less", "e", "20", "other", "e", "20", "e", "20", "e", "greater", "e", "1440", "less", "e", "1440", "other", "e", "return", "e"], "doc_len": 55}
{"doc_id": "pvlib/spa.py::solar_position_loop", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "solar_position_loop", "text": "文件路径: pvlib/spa.py\ndef solar_position_loop(unixtime, loc_args, out):\n    \"\"\"Loop through the time array and calculate the solar position\"\"\"\n    lat = loc_args[0]\n    lon = loc_args[1]\n    elev = loc_args[2]\n    pressure = loc_args[3]\n    temp = loc_args[4]\n    delta_t = loc_args[5]\n    atmos_refract = loc_args[6]\n    sst = loc_args[7]\n    esd = loc_args[8]\n\n    for i in range(unixtime.shape[0]):\n        utime = unixtime[i]\n        jd = julian_day(utime)\n        jde = julian_ephemeris_day(jd, delta_t)\n        jc = julian_century(jd)\n        jce = julian_ephemeris_century(jde)\n        jme = julian_ephemeris_millennium(jce)\n        R = heliocentric_radius_vector(jme)\n        if esd:\n            out[0, i] = R\n            continue\n        L = heliocentric_longitude(jme)\n        B = heliocentric_latitude(jme)\n        Theta = geocentric_longitude(L)\n        beta = geocentric_latitude(B)\n        x0 = mean_elongation(jce)\n        x1 = mean_anomaly_sun(jce)\n        x2 = mean_anomaly_moon(jce)\n        x3 = moon_argument_latitude(jce)\n        x4 = moon_ascending_longitude(jce)\n        delta_psi = longitude_nutation(jce, x0, x1, x2, x3, x4)\n        delta_epsilon = obliquity_nutation(jce, x0, x1, x2, x3, x4)\n        epsilon0 = mean_ecliptic_obliquity(jme)\n        epsilon = true_ecliptic_obliquity(epsilon0, delta_epsilon)\n        delta_tau = aberration_correction(R)\n        lamd = apparent_sun_longitude(Theta, delta_psi, delta_tau)\n        v0 = mean_sidereal_time(jd, jc)\n        v = apparent_sidereal_time(v0, delta_psi, epsilon)\n        alpha = geocentric_sun_right_ascension(lamd, epsilon, beta)\n        delta = geocentric_sun_declination(lamd, epsilon, beta)\n        if sst:\n            out[0, i] = v\n            out[1, i] = alpha\n            out[2, i] = delta\n            continue\n        m = sun_mean_longitude(jme)\n        eot = equation_of_time(m, alpha, delta_psi, epsilon)\n        H = local_hour_angle(v, lon, alpha)\n        xi = equatorial_horizontal_parallax(R)\n        u = uterm(lat)\n        x = xterm(u, lat, elev)\n        y = yterm(u, lat, elev)\n        delta_alpha = parallax_sun_right_ascension(x, xi, H, delta)\n        delta_prime = topocentric_sun_declination(delta, x, y, xi, delta_alpha,\n                                                  H)\n        H_prime = topocentric_local_hour_angle(H, delta_alpha)\n        e0 = topocentric_elevation_angle_without_atmosphere(lat, delta_prime,\n                                                            H_prime)\n        delta_e = atmospheric_refraction_correction(pressure, temp, e0,\n                                                    atmos_refract)\n        e = topocentric_elevation_angle(e0, delta_e)\n        theta = topocentric_zenith_angle(e)\n        theta0 = topocentric_zenith_angle(e0)\n        gamma = topocentric_astronomers_azimuth(H_prime, delta_prime, lat)\n        phi = topocentric_azimuth_angle(gamma)\n        out[0, i] = theta\n        out[1, i] = theta0\n        out[2, i] = e\n        out[3, i] = e0\n        out[4, i] = phi\n        out[5, i] = eot\n", "tokens": ["pvlib", "spa", "py", "def", "solar_position_loop", "unixtime", "loc_args", "out", "loop", "through", "the", "time", "array", "and", "calculate", "the", "solar", "position", "lat", "loc_args", "0", "lon", "loc_args", "1", "elev", "loc_args", "2", "pressure", "loc_args", "3", "temp", "loc_args", "4", "delta_t", "loc_args", "5", "atmos_refract", "loc_args", "6", "sst", "loc_args", "7", "esd", "loc_args", "8", "for", "i", "in", "range", "unixtime", "shape", "0", "utime", "unixtime", "i", "jd", "julian_day", "utime", "jde", "julian_ephemeris_day", "jd", "delta_t", "jc", "julian_century", "jd", "jce", "julian_ephemeris_century", "jde", "jme", "julian_ephemeris_millennium", "jce", "r", "heliocentric_radius_vector", "jme", "if", "esd", "out", "0", "i", "r", "continue", "l", "heliocentric_longitude", "jme", "b", "heliocentric_latitude", "jme", "theta", "geocentric_longitude", "l", "beta", "geocentric_latitude", "b", "x0", "mean_elongation", "jce", "x1", "mean_anomaly_sun", "jce", "x2", "mean_anomaly_moon", "jce", "x3", "moon_argument_latitude", "jce", "x4", "moon_ascending_longitude", "jce", "delta_psi", "longitude_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "delta_epsilon", "obliquity_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "epsilon0", "mean_ecliptic_obliquity", "jme", "epsilon", "true_ecliptic_obliquity", "epsilon0", "delta_epsilon", "delta_tau", "aberration_correction", "r", "lamd", "apparent_sun_longitude", "theta", "delta_psi", "delta_tau", "v0", "mean_sidereal_time", "jd", "jc", "v", "apparent_sidereal_time", "v0", "delta_psi", "epsilon", "alpha", "geocentric_sun_right_ascension", "lamd", "epsilon", "beta", "delta", "geocentric_sun_declination", "lamd", "epsilon", "beta", "if", "sst", "out", "0", "i", "v", "out", "1", "i", "alpha", "out", "2", "i", "delta", "continue", "m", "sun_mean_longitude", "jme", "eot", "equation_of_time", "m", "alpha", "delta_psi", "epsilon", "h", "local_hour_angle", "v", "lon", "alpha", "xi", "equatorial_horizontal_parallax", "r", "u", "uterm", "lat", "x", "xterm", "u", "lat", "elev", "y", "yterm", "u", "lat", "elev", "delta_alpha", "parallax_sun_right_ascension", "x", "xi", "h", "delta", "delta_prime", "topocentric_sun_declination", "delta", "x", "y", "xi", "delta_alpha", "h", "h_prime", "topocentric_local_hour_angle", "h", "delta_alpha", "e0", "topocentric_elevation_angle_without_atmosphere", "lat", "delta_prime", "h_prime", "delta_e", "atmospheric_refraction_correction", "pressure", "temp", "e0", "atmos_refract", "e", "topocentric_elevation_angle", "e0", "delta_e", "theta", "topocentric_zenith_angle", "e", "theta0", "topocentric_zenith_angle", "e0", "gamma", "topocentric_astronomers_azimuth", "h_prime", "delta_prime", "lat", "phi", "topocentric_azimuth_angle", "gamma", "out", "0", "i", "theta", "out", "1", "i", "theta0", "out", "2", "i", "e", "out", "3", "i", "e0", "out", "4", "i", "phi", "out", "5", "i", "eot"], "doc_len": 274}
{"doc_id": "pvlib/spa.py::solar_position_numba", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "solar_position_numba", "text": "文件路径: pvlib/spa.py\ndef solar_position_numba(unixtime, lat, lon, elev, pressure, temp, delta_t,\n                         atmos_refract, numthreads, sst=False, esd=False):\n    \"\"\"Calculate the solar position using the numba compiled functions\n    and multiple threads. Very slow if functions are not numba compiled.\n    \"\"\"\n    # these args are the same for each thread\n    loc_args = np.array([lat, lon, elev, pressure, temp, delta_t,\n                         atmos_refract, sst, esd])\n\n    # construct dims x ulength array to put the results in\n    ulength = unixtime.shape[0]\n    if sst:\n        dims = 3\n    elif esd:\n        dims = 1\n    else:\n        dims = 6\n    result = np.empty((dims, ulength), dtype=np.float64)\n\n    if unixtime.dtype != np.float64:\n        unixtime = unixtime.astype(np.float64)\n\n    if ulength < numthreads:\n        warnings.warn('The number of threads is more than the length of '\n                      'the time array. Only using %s threads.'.format(ulength))\n        numthreads = ulength\n\n    if numthreads <= 1:\n        solar_position_loop(unixtime, loc_args, result)\n        return result\n\n    # split the input and output arrays into numthreads chunks\n    split0 = np.array_split(unixtime, numthreads)\n    split2 = np.array_split(result, numthreads, axis=1)\n    chunks = [[a0, loc_args, split2[i]] for i, a0 in enumerate(split0)]\n    # Spawn one thread per chunk\n    threads = [threading.Thread(target=solar_position_loop, args=chunk)\n               for chunk in chunks]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    return result\n", "tokens": ["pvlib", "spa", "py", "def", "solar_position_numba", "unixtime", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "sst", "false", "esd", "false", "calculate", "the", "solar", "position", "using", "the", "numba", "compiled", "functions", "and", "multiple", "threads", "very", "slow", "if", "functions", "are", "not", "numba", "compiled", "these", "args", "are", "the", "same", "for", "each", "thread", "loc_args", "np", "array", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "sst", "esd", "construct", "dims", "x", "ulength", "array", "to", "put", "the", "results", "in", "ulength", "unixtime", "shape", "0", "if", "sst", "dims", "3", "elif", "esd", "dims", "1", "else", "dims", "6", "result", "np", "empty", "dims", "ulength", "dtype", "np", "float64", "if", "unixtime", "dtype", "np", "float64", "unixtime", "unixtime", "astype", "np", "float64", "if", "ulength", "numthreads", "warnings", "warn", "the", "number", "of", "threads", "is", "more", "than", "the", "length", "of", "the", "time", "array", "only", "using", "s", "threads", "format", "ulength", "numthreads", "ulength", "if", "numthreads", "1", "solar_position_loop", "unixtime", "loc_args", "result", "return", "result", "split", "the", "input", "and", "output", "arrays", "into", "numthreads", "chunks", "split0", "np", "array_split", "unixtime", "numthreads", "split2", "np", "array_split", "result", "numthreads", "axis", "1", "chunks", "a0", "loc_args", "split2", "i", "for", "i", "a0", "in", "enumerate", "split0", "spawn", "one", "thread", "per", "chunk", "threads", "threading", "thread", "target", "solar_position_loop", "args", "chunk", "for", "chunk", "in", "chunks", "for", "thread", "in", "threads", "thread", "start", "for", "thread", "in", "threads", "thread", "join", "return", "result"], "doc_len": 198}
{"doc_id": "pvlib/spa.py::solar_position_numpy", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "solar_position_numpy", "text": "文件路径: pvlib/spa.py\ndef solar_position_numpy(unixtime, lat, lon, elev, pressure, temp, delta_t,\n                         atmos_refract, numthreads, sst=False, esd=False):\n    \"\"\"Calculate the solar position assuming unixtime is a numpy array. Note\n    this function will not work if the solar position functions were\n    compiled with numba.\n    \"\"\"\n\n    jd = julian_day(unixtime)\n    jde = julian_ephemeris_day(jd, delta_t)\n    jc = julian_century(jd)\n    jce = julian_ephemeris_century(jde)\n    jme = julian_ephemeris_millennium(jce)\n    R = heliocentric_radius_vector(jme)\n    if esd:\n        return (R, )\n    L = heliocentric_longitude(jme)\n    B = heliocentric_latitude(jme)\n    Theta = geocentric_longitude(L)\n    beta = geocentric_latitude(B)\n    x0 = mean_elongation(jce)\n    x1 = mean_anomaly_sun(jce)\n    x2 = mean_anomaly_moon(jce)\n    x3 = moon_argument_latitude(jce)\n    x4 = moon_ascending_longitude(jce)\n    delta_psi = longitude_nutation(jce, x0, x1, x2, x3, x4)\n    delta_epsilon = obliquity_nutation(jce, x0, x1, x2, x3, x4)\n    epsilon0 = mean_ecliptic_obliquity(jme)\n    epsilon = true_ecliptic_obliquity(epsilon0, delta_epsilon)\n    delta_tau = aberration_correction(R)\n    lamd = apparent_sun_longitude(Theta, delta_psi, delta_tau)\n    v0 = mean_sidereal_time(jd, jc)\n    v = apparent_sidereal_time(v0, delta_psi, epsilon)\n    alpha = geocentric_sun_right_ascension(lamd, epsilon, beta)\n    delta = geocentric_sun_declination(lamd, epsilon, beta)\n    if sst:\n        return v, alpha, delta\n    m = sun_mean_longitude(jme)\n    eot = equation_of_time(m, alpha, delta_psi, epsilon)\n    H = local_hour_angle(v, lon, alpha)\n    xi = equatorial_horizontal_parallax(R)\n    u = uterm(lat)\n    x = xterm(u, lat, elev)\n    y = yterm(u, lat, elev)\n    delta_alpha = parallax_sun_right_ascension(x, xi, H, delta)\n    delta_prime = topocentric_sun_declination(delta, x, y, xi, delta_alpha, H)\n    H_prime = topocentric_local_hour_angle(H, delta_alpha)\n    e0 = topocentric_elevation_angle_without_atmosphere(lat, delta_prime,\n                                                        H_prime)\n    delta_e = atmospheric_refraction_correction(pressure, temp, e0,\n                                                atmos_refract)\n    e = topocentric_elevation_angle(e0, delta_e)\n    theta = topocentric_zenith_angle(e)\n    theta0 = topocentric_zenith_angle(e0)\n    gamma = topocentric_astronomers_azimuth(H_prime, delta_prime, lat)\n    phi = topocentric_azimuth_angle(gamma)\n    return theta, theta0, e, e0, phi, eot\n", "tokens": ["pvlib", "spa", "py", "def", "solar_position_numpy", "unixtime", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "sst", "false", "esd", "false", "calculate", "the", "solar", "position", "assuming", "unixtime", "is", "a", "numpy", "array", "note", "this", "function", "will", "not", "work", "if", "the", "solar", "position", "functions", "were", "compiled", "with", "numba", "jd", "julian_day", "unixtime", "jde", "julian_ephemeris_day", "jd", "delta_t", "jc", "julian_century", "jd", "jce", "julian_ephemeris_century", "jde", "jme", "julian_ephemeris_millennium", "jce", "r", "heliocentric_radius_vector", "jme", "if", "esd", "return", "r", "l", "heliocentric_longitude", "jme", "b", "heliocentric_latitude", "jme", "theta", "geocentric_longitude", "l", "beta", "geocentric_latitude", "b", "x0", "mean_elongation", "jce", "x1", "mean_anomaly_sun", "jce", "x2", "mean_anomaly_moon", "jce", "x3", "moon_argument_latitude", "jce", "x4", "moon_ascending_longitude", "jce", "delta_psi", "longitude_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "delta_epsilon", "obliquity_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "epsilon0", "mean_ecliptic_obliquity", "jme", "epsilon", "true_ecliptic_obliquity", "epsilon0", "delta_epsilon", "delta_tau", "aberration_correction", "r", "lamd", "apparent_sun_longitude", "theta", "delta_psi", "delta_tau", "v0", "mean_sidereal_time", "jd", "jc", "v", "apparent_sidereal_time", "v0", "delta_psi", "epsilon", "alpha", "geocentric_sun_right_ascension", "lamd", "epsilon", "beta", "delta", "geocentric_sun_declination", "lamd", "epsilon", "beta", "if", "sst", "return", "v", "alpha", "delta", "m", "sun_mean_longitude", "jme", "eot", "equation_of_time", "m", "alpha", "delta_psi", "epsilon", "h", "local_hour_angle", "v", "lon", "alpha", "xi", "equatorial_horizontal_parallax", "r", "u", "uterm", "lat", "x", "xterm", "u", "lat", "elev", "y", "yterm", "u", "lat", "elev", "delta_alpha", "parallax_sun_right_ascension", "x", "xi", "h", "delta", "delta_prime", "topocentric_sun_declination", "delta", "x", "y", "xi", "delta_alpha", "h", "h_prime", "topocentric_local_hour_angle", "h", "delta_alpha", "e0", "topocentric_elevation_angle_without_atmosphere", "lat", "delta_prime", "h_prime", "delta_e", "atmospheric_refraction_correction", "pressure", "temp", "e0", "atmos_refract", "e", "topocentric_elevation_angle", "e0", "delta_e", "theta", "topocentric_zenith_angle", "e", "theta0", "topocentric_zenith_angle", "e0", "gamma", "topocentric_astronomers_azimuth", "h_prime", "delta_prime", "lat", "phi", "topocentric_azimuth_angle", "gamma", "return", "theta", "theta0", "e", "e0", "phi", "eot"], "doc_len": 233}
{"doc_id": "pvlib/spa.py::solar_position", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "solar_position", "text": "文件路径: pvlib/spa.py\ndef solar_position(unixtime, lat, lon, elev, pressure, temp, delta_t,\n                   atmos_refract, numthreads=8, sst=False, esd=False):\n\n    \"\"\"\n    Calculate the solar position using the\n    NREL SPA algorithm described in [1].\n\n    If numba is installed, the functions can be compiled\n    and the code runs quickly. If not, the functions\n    still evaluate but use numpy instead.\n\n    Parameters\n    ----------\n    unixtime : numpy array\n        Array of unix/epoch timestamps to calculate solar position for.\n        Unixtime is the number of seconds since Jan. 1, 1970 00:00:00 UTC.\n        A pandas.DatetimeIndex is easily converted using .astype(np.int64)/10**9\n    lat : float\n        Latitude to calculate solar position for\n    lon : float\n        Longitude to calculate solar position for\n    elev : float\n        Elevation of location in meters\n    pressure : int or float\n        avg. yearly pressure at location in millibars;\n        used for atmospheric correction\n    temp : int or float\n        avg. yearly temperature at location in\n        degrees C; used for atmospheric correction\n    delta_t : float\n        Difference between terrestrial time and UT1.\n    atmos_refrac : float\n        The approximate atmospheric refraction (in degrees)\n        at sunrise and sunset.\n    numthreads: int, optional, default 8\n        Number of threads to use for computation if numba>=0.17\n        is installed.\n    sst : bool, default False\n        If True, return only data needed for sunrise, sunset, and transit\n        calculations.\n    esd : bool, default False\n        If True, return only Earth-Sun distance in AU\n\n    Returns\n    -------\n    Numpy Array with elements:\n        apparent zenith,\n        zenith,\n        elevation,\n        apparent_elevation,\n        azimuth,\n        equation_of_time\n\n    References\n    ----------\n    [1] I. Reda and A. Andreas, Solar position algorithm for solar radiation\n    applications. Solar Energy, vol. 76, no. 5, pp. 577-589, 2004.\n\n    [2] I. Reda and A. Andreas, Corrigendum to Solar position algorithm for\n    solar radiation applications. Solar Energy, vol. 81, no. 6, p. 838, 2007.\n    \"\"\"\n    if USE_NUMBA:\n        do_calc = solar_position_numba\n    else:\n        do_calc = solar_position_numpy\n\n    result = do_calc(unixtime, lat, lon, elev, pressure,\n                     temp, delta_t, atmos_refract, numthreads,\n                     sst, esd)\n\n    if not isinstance(result, np.ndarray):\n        try:\n            result = np.array(result)\n        except Exception:\n            pass\n\n    return result\n", "tokens": ["pvlib", "spa", "py", "def", "solar_position", "unixtime", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "8", "sst", "false", "esd", "false", "calculate", "the", "solar", "position", "using", "the", "nrel", "spa", "algorithm", "described", "in", "1", "if", "numba", "is", "installed", "the", "functions", "can", "be", "compiled", "and", "the", "code", "runs", "quickly", "if", "not", "the", "functions", "still", "evaluate", "but", "use", "numpy", "instead", "parameters", "unixtime", "numpy", "array", "array", "of", "unix", "epoch", "timestamps", "to", "calculate", "solar", "position", "for", "unixtime", "is", "the", "number", "of", "seconds", "since", "jan", "1", "1970", "00", "00", "00", "utc", "a", "pandas", "datetimeindex", "is", "easily", "converted", "using", "astype", "np", "int64", "10", "9", "lat", "float", "latitude", "to", "calculate", "solar", "position", "for", "lon", "float", "longitude", "to", "calculate", "solar", "position", "for", "elev", "float", "elevation", "of", "location", "in", "meters", "pressure", "int", "or", "float", "avg", "yearly", "pressure", "at", "location", "in", "millibars", "used", "for", "atmospheric", "correction", "temp", "int", "or", "float", "avg", "yearly", "temperature", "at", "location", "in", "degrees", "c", "used", "for", "atmospheric", "correction", "delta_t", "float", "difference", "between", "terrestrial", "time", "and", "ut1", "atmos_refrac", "float", "the", "approximate", "atmospheric", "refraction", "in", "degrees", "at", "sunrise", "and", "sunset", "numthreads", "int", "optional", "default", "8", "number", "of", "threads", "to", "use", "for", "computation", "if", "numba", "0", "17", "is", "installed", "sst", "bool", "default", "false", "if", "true", "return", "only", "data", "needed", "for", "sunrise", "sunset", "and", "transit", "calculations", "esd", "bool", "default", "false", "if", "true", "return", "only", "earth", "sun", "distance", "in", "au", "returns", "numpy", "array", "with", "elements", "apparent", "zenith", "zenith", "elevation", "apparent_elevation", "azimuth", "equation_of_time", "references", "1", "i", "reda", "and", "a", "andreas", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "76", "no", "5", "pp", "577", "589", "2004", "2", "i", "reda", "and", "a", "andreas", "corrigendum", "to", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "solar", "energy", "vol", "81", "no", "6", "p", "838", "2007", "if", "use_numba", "do_calc", "solar_position_numba", "else", "do_calc", "solar_position_numpy", "result", "do_calc", "unixtime", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "sst", "esd", "if", "not", "isinstance", "result", "np", "ndarray", "try", "result", "np", "array", "result", "except", "exception", "pass", "return", "result"], "doc_len": 312}
{"doc_id": "pvlib/spa.py::transit_sunrise_sunset", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "transit_sunrise_sunset", "text": "文件路径: pvlib/spa.py\ndef transit_sunrise_sunset(dates, lat, lon, delta_t, numthreads):\n    \"\"\"\n    Calculate the sun transit, sunrise, and sunset\n    for a set of dates at a given location.\n\n    Parameters\n    ----------\n    dates : array\n        Numpy array of ints/floats corresponding to the Unix time\n        for the dates of interest, must be midnight UTC (00:00+00:00)\n        on the day of interest.\n    lat : float\n        Latitude of location to perform calculation for\n    lon : float\n        Longitude of location\n    delta_t : float\n        Difference between terrestrial time and UT. USNO has tables.\n    numthreads : int\n        Number to threads to use for calculation (if using numba)\n\n    Returns\n    -------\n    tuple : (transit, sunrise, sunset) localized to UTC\n\n    \"\"\"\n\n    if ((dates % 86400) != 0.0).any():\n        raise ValueError('Input dates must be at 00:00 UTC')\n\n    utday = (dates // 86400) * 86400\n    ttday0 = utday - delta_t\n    ttdayn1 = ttday0 - 86400\n    ttdayp1 = ttday0 + 86400\n\n    # index 0 is v, 1 is alpha, 2 is delta\n    utday_res = solar_position(utday, 0, 0, 0, 0, 0, delta_t,\n                               0, numthreads, sst=True)\n    v = utday_res[0]\n\n    ttday0_res = solar_position(ttday0, 0, 0, 0, 0, 0, delta_t,\n                                0, numthreads, sst=True)\n    ttdayn1_res = solar_position(ttdayn1, 0, 0, 0, 0, 0, delta_t,\n                                 0, numthreads, sst=True)\n    ttdayp1_res = solar_position(ttdayp1, 0, 0, 0, 0, 0, delta_t,\n                                 0, numthreads, sst=True)\n    m0 = (ttday0_res[1] - lon - v) / 360\n    cos_arg = ((np.sin(np.radians(-0.8333)) - np.sin(np.radians(lat))\n               * np.sin(np.radians(ttday0_res[2]))) /\n               (np.cos(np.radians(lat)) * np.cos(np.radians(ttday0_res[2]))))\n    cos_arg[abs(cos_arg) > 1] = np.nan\n    H0 = np.degrees(np.arccos(cos_arg)) % 180\n\n    m = np.empty((3, len(utday)))\n    m[0] = m0 % 1\n    m[1] = (m[0] - H0 / 360)\n    m[2] = (m[0] + H0 / 360)\n\n    # need to account for fractions of day that may be the next or previous\n    # day in UTC\n    add_a_day = m[2] >= 1\n    sub_a_day = m[1] < 0\n    m[1] = m[1] % 1\n    m[2] = m[2] % 1\n    vs = v + 360.985647 * m\n    n = m + delta_t / 86400\n\n    a = ttday0_res[1] - ttdayn1_res[1]\n    a[abs(a) > 2] = a[abs(a) > 2] % 1\n    ap = ttday0_res[2] - ttdayn1_res[2]\n    ap[abs(ap) > 2] = ap[abs(ap) > 2] % 1\n    b = ttdayp1_res[1] - ttday0_res[1]\n    b[abs(b) > 2] = b[abs(b) > 2] % 1\n    bp = ttdayp1_res[2] - ttday0_res[2]\n    bp[abs(bp) > 2] = bp[abs(bp) > 2] % 1\n    c = b - a\n    cp = bp - ap\n\n    alpha_prime = ttday0_res[1] + (n * (a + b + c * n)) / 2\n    delta_prime = ttday0_res[2] + (n * (ap + bp + cp * n)) / 2\n    Hp = (vs + lon - alpha_prime) % 360\n    Hp[Hp >= 180] = Hp[Hp >= 180] - 360\n\n    h = np.degrees(np.arcsin(np.sin(np.radians(lat)) *\n                             np.sin(np.radians(delta_prime)) +\n                             np.cos(np.radians(lat)) *\n                             np.cos(np.radians(delta_prime))\n                             * np.cos(np.radians(Hp))))\n\n    T = (m[0] - Hp[0] / 360) * 86400\n    R = (m[1] + (h[1] + 0.8333) / (360 * np.cos(np.radians(delta_prime[1])) *\n                                   np.cos(np.radians(lat)) *\n                                   np.sin(np.radians(Hp[1])))) * 86400\n    S = (m[2] + (h[2] + 0.8333) / (360 * np.cos(np.radians(delta_prime[2])) *\n                                   np.cos(np.radians(lat)) *\n                                   np.sin(np.radians(Hp[2])))) * 86400\n\n    S[add_a_day] += 86400\n    R[sub_a_day] -= 86400\n\n    transit = T + utday\n    sunrise = R + utday\n    sunset = S + utday\n\n    return transit, sunrise, sunset\n", "tokens": ["pvlib", "spa", "py", "def", "transit_sunrise_sunset", "dates", "lat", "lon", "delta_t", "numthreads", "calculate", "the", "sun", "transit", "sunrise", "and", "sunset", "for", "a", "set", "of", "dates", "at", "a", "given", "location", "parameters", "dates", "array", "numpy", "array", "of", "ints", "floats", "corresponding", "to", "the", "unix", "time", "for", "the", "dates", "of", "interest", "must", "be", "midnight", "utc", "00", "00", "00", "00", "on", "the", "day", "of", "interest", "lat", "float", "latitude", "of", "location", "to", "perform", "calculation", "for", "lon", "float", "longitude", "of", "location", "delta_t", "float", "difference", "between", "terrestrial", "time", "and", "ut", "usno", "has", "tables", "numthreads", "int", "number", "to", "threads", "to", "use", "for", "calculation", "if", "using", "numba", "returns", "tuple", "transit", "sunrise", "sunset", "localized", "to", "utc", "if", "dates", "86400", "0", "0", "any", "raise", "valueerror", "input", "dates", "must", "be", "at", "00", "00", "utc", "utday", "dates", "86400", "86400", "ttday0", "utday", "delta_t", "ttdayn1", "ttday0", "86400", "ttdayp1", "ttday0", "86400", "index", "0", "is", "v", "1", "is", "alpha", "2", "is", "delta", "utday_res", "solar_position", "utday", "0", "0", "0", "0", "0", "delta_t", "0", "numthreads", "sst", "true", "v", "utday_res", "0", "ttday0_res", "solar_position", "ttday0", "0", "0", "0", "0", "0", "delta_t", "0", "numthreads", "sst", "true", "ttdayn1_res", "solar_position", "ttdayn1", "0", "0", "0", "0", "0", "delta_t", "0", "numthreads", "sst", "true", "ttdayp1_res", "solar_position", "ttdayp1", "0", "0", "0", "0", "0", "delta_t", "0", "numthreads", "sst", "true", "m0", "ttday0_res", "1", "lon", "v", "360", "cos_arg", "np", "sin", "np", "radians", "0", "8333", "np", "sin", "np", "radians", "lat", "np", "sin", "np", "radians", "ttday0_res", "2", "np", "cos", "np", "radians", "lat", "np", "cos", "np", "radians", "ttday0_res", "2", "cos_arg", "abs", "cos_arg", "1", "np", "nan", "h0", "np", "degrees", "np", "arccos", "cos_arg", "180", "m", "np", "empty", "3", "len", "utday", "m", "0", "m0", "1", "m", "1", "m", "0", "h0", "360", "m", "2", "m", "0", "h0", "360", "need", "to", "account", "for", "fractions", "of", "day", "that", "may", "be", "the", "next", "or", "previous", "day", "in", "utc", "add_a_day", "m", "2", "1", "sub_a_day", "m", "1", "0", "m", "1", "m", "1", "1", "m", "2", "m", "2", "1", "vs", "v", "360", "985647", "m", "n", "m", "delta_t", "86400", "a", "ttday0_res", "1", "ttdayn1_res", "1", "a", "abs", "a", "2", "a", "abs", "a", "2", "1", "ap", "ttday0_res", "2", "ttdayn1_res", "2", "ap", "abs", "ap", "2", "ap", "abs", "ap", "2", "1", "b", "ttdayp1_res", "1", "ttday0_res", "1", "b", "abs", "b", "2", "b", "abs", "b", "2", "1", "bp", "ttdayp1_res", "2", "ttday0_res", "2", "bp", "abs", "bp", "2", "bp", "abs", "bp", "2", "1", "c", "b", "a", "cp", "bp", "ap", "alpha_prime", "ttday0_res", "1", "n", "a", "b", "c", "n", "2", "delta_prime", "ttday0_res", "2", "n", "ap", "bp", "cp", "n", "2", "hp", "vs", "lon", "alpha_prime", "360", "hp", "hp", "180", "hp", "hp", "180", "360", "h", "np", "degrees", "np", "arcsin", "np", "sin", "np", "radians", "lat", "np", "sin", "np", "radians", "delta_prime", "np", "cos", "np", "radians", "lat", "np", "cos", "np", "radians", "delta_prime", "np", "cos", "np", "radians", "hp", "t", "m", "0", "hp", "0", "360", "86400", "r", "m", "1", "h", "1", "0", "8333", "360", "np", "cos", "np", "radians", "delta_prime", "1", "np", "cos", "np", "radians", "lat", "np", "sin", "np", "radians", "hp", "1", "86400", "s", "m", "2", "h", "2", "0", "8333", "360", "np", "cos", "np", "radians", "delta_prime", "2", "np", "cos", "np", "radians", "lat", "np", "sin", "np", "radians", "hp", "2", "86400", "s", "add_a_day", "86400", "r", "sub_a_day", "86400", "transit", "t", "utday", "sunrise", "r", "utday", "sunset", "s", "utday", "return", "transit", "sunrise", "sunset"], "doc_len": 510}
{"doc_id": "pvlib/spa.py::earthsun_distance", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "earthsun_distance", "text": "文件路径: pvlib/spa.py\ndef earthsun_distance(unixtime, delta_t, numthreads):\n    \"\"\"\n    Calculates the distance from the earth to the sun using the\n    NREL SPA algorithm described in [1].\n\n    Parameters\n    ----------\n    unixtime : numpy array\n        Array of unix/epoch timestamps to calculate solar position for.\n        Unixtime is the number of seconds since Jan. 1, 1970 00:00:00 UTC.\n        A pandas.DatetimeIndex is easily converted using .astype(np.int64)/10**9\n    delta_t : float\n        Difference between terrestrial time and UT. USNO has tables.\n    numthreads : int\n        Number to threads to use for calculation (if using numba)\n\n    Returns\n    -------\n    R : array\n        Earth-Sun distance in AU.\n\n    References\n    ----------\n    [1] Reda, I., Andreas, A., 2003. Solar position algorithm for solar\n    radiation applications. Technical report: NREL/TP-560- 34302. Golden,\n    USA, http://www.nrel.gov.\n    \"\"\"\n\n    R = solar_position(unixtime, 0, 0, 0, 0, 0, delta_t,\n                       0, numthreads, esd=True)[0]\n\n    return R\n", "tokens": ["pvlib", "spa", "py", "def", "earthsun_distance", "unixtime", "delta_t", "numthreads", "calculates", "the", "distance", "from", "the", "earth", "to", "the", "sun", "using", "the", "nrel", "spa", "algorithm", "described", "in", "1", "parameters", "unixtime", "numpy", "array", "array", "of", "unix", "epoch", "timestamps", "to", "calculate", "solar", "position", "for", "unixtime", "is", "the", "number", "of", "seconds", "since", "jan", "1", "1970", "00", "00", "00", "utc", "a", "pandas", "datetimeindex", "is", "easily", "converted", "using", "astype", "np", "int64", "10", "9", "delta_t", "float", "difference", "between", "terrestrial", "time", "and", "ut", "usno", "has", "tables", "numthreads", "int", "number", "to", "threads", "to", "use", "for", "calculation", "if", "using", "numba", "returns", "r", "array", "earth", "sun", "distance", "in", "au", "references", "1", "reda", "i", "andreas", "a", "2003", "solar", "position", "algorithm", "for", "solar", "radiation", "applications", "technical", "report", "nrel", "tp", "560", "34302", "golden", "usa", "http", "www", "nrel", "gov", "r", "solar_position", "unixtime", "0", "0", "0", "0", "0", "delta_t", "0", "numthreads", "esd", "true", "0", "return", "r"], "doc_len": 138}
{"doc_id": "pvlib/spa.py::calculate_deltat", "file_path": "pvlib/spa.py", "class_name": null, "func_name": "calculate_deltat", "text": "文件路径: pvlib/spa.py\ndef calculate_deltat(year, month):\n    \"\"\"Calculate the difference between Terrestrial Dynamical Time (TD)\n    and Universal Time (UT).\n\n    Note: This function is not yet compatible for calculations using\n    Numba.\n\n    Equations taken from http://eclipse.gsfc.nasa.gov/SEcat5/deltatpoly.html\n    \"\"\"\n\n    plw = 'Deltat is unknown for years before -1999 and after 3000. ' \\\n          'Delta values will be calculated, but the calculations ' \\\n          'are not intended to be used for these years.'\n\n    try:\n        if np.any((year > 3000) | (year < -1999)):\n            warnings.warn(plw)\n    except ValueError:\n        if (year > 3000) | (year < -1999):\n            warnings.warn(plw)\n    except TypeError:\n        return 0\n\n    y = year + (month - 0.5)/12\n\n    deltat = np.where(year < -500,\n\n                      -20+32*((y-1820)/100)**2, 0)\n\n    deltat = np.where((-500 <= year) & (year < 500),\n\n                      10583.6-1014.41*(y/100)\n                      + 33.78311*(y/100)**2\n                      - 5.952053*(y/100)**3\n                      - 0.1798452*(y/100)**4\n                      + 0.022174192*(y/100)**5\n                      + 0.0090316521*(y/100)**6, deltat)\n\n    deltat = np.where((500 <= year) & (year < 1600),\n\n                      1574.2-556.01*((y-1000)/100)\n                      + 71.23472*((y-1000)/100)**2\n                      + 0.319781*((y-1000)/100)**3\n                      - 0.8503463*((y-1000)/100)**4\n                      - 0.005050998*((y-1000)/100)**5\n                      + 0.0083572073*((y-1000)/100)**6, deltat)\n\n    deltat = np.where((1600 <= year) & (year < 1700),\n\n                      120-0.9808*(y-1600)\n                      - 0.01532*(y-1600)**2\n                      + (y-1600)**3/7129, deltat)\n\n    deltat = np.where((1700 <= year) & (year < 1800),\n\n                      8.83+0.1603*(y-1700)\n                      - 0.0059285*(y-1700)**2\n                      + 0.00013336*(y-1700)**3\n                      - (y-1700)**4/1174000, deltat)\n\n    deltat = np.where((1800 <= year) & (year < 1860),\n\n                      13.72-0.332447*(y-1800)\n                      + 0.0068612*(y-1800)**2\n                      + 0.0041116*(y-1800)**3\n                      - 0.00037436*(y-1800)**4\n                      + 0.0000121272*(y-1800)**5\n                      - 0.0000001699*(y-1800)**6\n                      + 0.000000000875*(y-1800)**7, deltat)\n\n    deltat = np.where((1860 <= year) & (year < 1900),\n\n                      7.62+0.5737*(y-1860)\n                      - 0.251754*(y-1860)**2\n                      + 0.01680668*(y-1860)**3\n                      - 0.0004473624*(y-1860)**4\n                      + (y-1860)**5/233174, deltat)\n\n    deltat = np.where((1900 <= year) & (year < 1920),\n\n                      -2.79+1.494119*(y-1900)\n                      - 0.0598939*(y-1900)**2\n                      + 0.0061966*(y-1900)**3\n                      - 0.000197*(y-1900)**4, deltat)\n\n    deltat = np.where((1920 <= year) & (year < 1941),\n\n                      21.20+0.84493*(y-1920)\n                      - 0.076100*(y-1920)**2\n                      + 0.0020936*(y-1920)**3, deltat)\n\n    deltat = np.where((1941 <= year) & (year < 1961),\n\n                      29.07+0.407*(y-1950)\n                      - (y-1950)**2/233\n                      + (y-1950)**3/2547, deltat)\n\n    deltat = np.where((1961 <= year) & (year < 1986),\n\n                      45.45+1.067*(y-1975)\n                      - (y-1975)**2/260\n                      - (y-1975)**3/718, deltat)\n\n    deltat = np.where((1986 <= year) & (year < 2005),\n\n                      63.86+0.3345*(y-2000)\n                      - 0.060374*(y-2000)**2\n                      + 0.0017275*(y-2000)**3\n                      + 0.000651814*(y-2000)**4\n                      + 0.00002373599*(y-2000)**5, deltat)\n\n    deltat = np.where((2005 <= year) & (year < 2050),\n\n                      62.92+0.32217*(y-2000)\n                      + 0.005589*(y-2000)**2, deltat)\n\n    deltat = np.where((2050 <= year) & (year < 2150),\n\n                      -20+32*((y-1820)/100)**2\n                      - 0.5628*(2150-y), deltat)\n\n    deltat = np.where(year >= 2150,\n\n                      -20+32*((y-1820)/100)**2, deltat)\n\n    deltat = deltat.item() if np.isscalar(year) & np.isscalar(month)\\\n        else deltat\n\n    return deltat\n", "tokens": ["pvlib", "spa", "py", "def", "calculate_deltat", "year", "month", "calculate", "the", "difference", "between", "terrestrial", "dynamical", "time", "td", "and", "universal", "time", "ut", "note", "this", "function", "is", "not", "yet", "compatible", "for", "calculations", "using", "numba", "equations", "taken", "from", "http", "eclipse", "gsfc", "nasa", "gov", "secat5", "deltatpoly", "html", "plw", "deltat", "is", "unknown", "for", "years", "before", "1999", "and", "after", "3000", "delta", "values", "will", "be", "calculated", "but", "the", "calculations", "are", "not", "intended", "to", "be", "used", "for", "these", "years", "try", "if", "np", "any", "year", "3000", "year", "1999", "warnings", "warn", "plw", "except", "valueerror", "if", "year", "3000", "year", "1999", "warnings", "warn", "plw", "except", "typeerror", "return", "0", "y", "year", "month", "0", "5", "12", "deltat", "np", "where", "year", "500", "20", "32", "y", "1820", "100", "2", "0", "deltat", "np", "where", "500", "year", "year", "500", "10583", "6", "1014", "41", "y", "100", "33", "78311", "y", "100", "2", "5", "952053", "y", "100", "3", "0", "1798452", "y", "100", "4", "0", "022174192", "y", "100", "5", "0", "0090316521", "y", "100", "6", "deltat", "deltat", "np", "where", "500", "year", "year", "1600", "1574", "2", "556", "01", "y", "1000", "100", "71", "23472", "y", "1000", "100", "2", "0", "319781", "y", "1000", "100", "3", "0", "8503463", "y", "1000", "100", "4", "0", "005050998", "y", "1000", "100", "5", "0", "0083572073", "y", "1000", "100", "6", "deltat", "deltat", "np", "where", "1600", "year", "year", "1700", "120", "0", "9808", "y", "1600", "0", "01532", "y", "1600", "2", "y", "1600", "3", "7129", "deltat", "deltat", "np", "where", "1700", "year", "year", "1800", "8", "83", "0", "1603", "y", "1700", "0", "0059285", "y", "1700", "2", "0", "00013336", "y", "1700", "3", "y", "1700", "4", "1174000", "deltat", "deltat", "np", "where", "1800", "year", "year", "1860", "13", "72", "0", "332447", "y", "1800", "0", "0068612", "y", "1800", "2", "0", "0041116", "y", "1800", "3", "0", "00037436", "y", "1800", "4", "0", "0000121272", "y", "1800", "5", "0", "0000001699", "y", "1800", "6", "0", "000000000875", "y", "1800", "7", "deltat", "deltat", "np", "where", "1860", "year", "year", "1900", "7", "62", "0", "5737", "y", "1860", "0", "251754", "y", "1860", "2", "0", "01680668", "y", "1860", "3", "0", "0004473624", "y", "1860", "4", "y", "1860", "5", "233174", "deltat", "deltat", "np", "where", "1900", "year", "year", "1920", "2", "79", "1", "494119", "y", "1900", "0", "0598939", "y", "1900", "2", "0", "0061966", "y", "1900", "3", "0", "000197", "y", "1900", "4", "deltat", "deltat", "np", "where", "1920", "year", "year", "1941", "21", "20", "0", "84493", "y", "1920", "0", "076100", "y", "1920", "2", "0", "0020936", "y", "1920", "3", "deltat", "deltat", "np", "where", "1941", "year", "year", "1961", "29", "07", "0", "407", "y", "1950", "y", "1950", "2", "233", "y", "1950", "3", "2547", "deltat", "deltat", "np", "where", "1961", "year", "year", "1986", "45", "45", "1", "067", "y", "1975", "y", "1975", "2", "260", "y", "1975", "3", "718", "deltat", "deltat", "np", "where", "1986", "year", "year", "2005", "63", "86", "0", "3345", "y", "2000", "0", "060374", "y", "2000", "2", "0", "0017275", "y", "2000", "3", "0", "000651814", "y", "2000", "4", "0", "00002373599", "y", "2000", "5", "deltat", "deltat", "np", "where", "2005", "year", "year", "2050", "62", "92", "0", "32217", "y", "2000", "0", "005589", "y", "2000", "2", "deltat", "deltat", "np", "where", "2050", "year", "year", "2150", "20", "32", "y", "1820", "100", "2", "0", "5628", "2150", "y", "deltat", "deltat", "np", "where", "year", "2150", "20", "32", "y", "1820", "100", "2", "deltat", "deltat", "deltat", "item", "if", "np", "isscalar", "year", "np", "isscalar", "month", "else", "deltat", "return", "deltat"], "doc_len": 517}
{"doc_id": "pvlib/temperature.py::_temperature_model_params", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "_temperature_model_params", "text": "文件路径: pvlib/temperature.py\ndef _temperature_model_params(model, parameter_set):\n    try:\n        params = TEMPERATURE_MODEL_PARAMETERS[model]\n        return params[parameter_set]\n    except KeyError:\n        msg = ('{} is not a named set of parameters for the {} cell'\n               ' temperature model.'\n               ' See pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS'\n               ' for names'.format(parameter_set, model))\n        raise KeyError(msg)\n", "tokens": ["pvlib", "temperature", "py", "def", "_temperature_model_params", "model", "parameter_set", "try", "params", "temperature_model_parameters", "model", "return", "params", "parameter_set", "except", "keyerror", "msg", "is", "not", "a", "named", "set", "of", "parameters", "for", "the", "cell", "temperature", "model", "see", "pvlib", "temperature", "temperature_model_parameters", "for", "names", "format", "parameter_set", "model", "raise", "keyerror", "msg"], "doc_len": 41}
{"doc_id": "pvlib/temperature.py::sapm_cell", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "sapm_cell", "text": "文件路径: pvlib/temperature.py\ndef sapm_cell(poa_global, temp_air, wind_speed, a, b, deltaT,\n              irrad_ref=1000.):\n    r'''\n    Calculate cell temperature per the Sandia Array Performance Model.\n\n    See [1]_ for details on the Sandia Array Performance Model.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    temp_air : numeric\n        Ambient dry bulb temperature [C].\n\n    wind_speed : numeric\n        Wind speed at a height of 10 meters [m/s].\n\n    a : float\n        Parameter :math:`a` in :eq:`sapm1`.\n\n    b : float\n        Parameter :math:`b` in :eq:`sapm1`.\n\n    deltaT : float\n        Parameter :math:`\\Delta T` in :eq:`sapm2` [C].\n\n    irrad_ref : float, default 1000\n        Reference irradiance, parameter :math:`E_{0}` in\n        :eq:`sapm2` [W/m^2].\n\n    Returns\n    -------\n    numeric, values in degrees C.\n\n    Notes\n    -----\n    The model for cell temperature :math:`T_{C}` is given by a pair of\n    equations (Eq. 11 and 12 in [1]_).\n\n    .. math::\n       :label: sapm1\n\n       T_{m} = E \\times \\exp (a + b \\times WS) + T_{a}\n\n    .. math::\n       :label: sapm2\n\n       T_{C} = T_{m} + \\frac{E}{E_{0}} \\Delta T\n\n    The module back surface temperature :math:`T_{m}` is implemented in\n    :py:func:`~pvlib.temperature.sapm_module`.\n\n    Inputs to the model are plane-of-array irradiance :math:`E` (W/m2) and\n    ambient air temperature :math:`T_{a}` (C). Model parameters depend both on\n    the module construction and its mounting. Parameter sets are provided in\n    [1]_ for representative modules and mounting, and are coded for convenience\n    in :data:`~pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS`.\n\n    +---------------+----------------+-------+---------+---------------------+\n    | Module        | Mounting       | a     | b       | :math:`\\Delta T [C]`|\n    +===============+================+=======+=========+=====================+\n    | glass/glass   | open rack      | -3.47 | -0.0594 | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/glass   | close roof     | -2.98 | -0.0471 | 1                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | open rack      | -3.56 | -0.075  | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | insulated back | -2.81 | -0.0455 | 0                   |\n    +---------------+----------------+-------+---------+---------------------+\n\n    References\n    ----------\n    .. [1] King, D. et al, 2004, \"Sandia Photovoltaic Array Performance\n       Model\", SAND Report 3535, Sandia National Laboratories, Albuquerque,\n       NM.\n\n    See also\n    --------\n    sapm_cell_from_module\n    sapm_module\n\n    Examples\n    --------\n    >>> from pvlib.temperature import sapm_cell, TEMPERATURE_MODEL_PARAMETERS\n    >>> params = TEMPERATURE_MODEL_PARAMETERS['sapm']['open_rack_glass_glass']\n    >>> sapm_cell(1000, 10, 0, **params)\n    44.11703066106086\n    '''\n    module_temperature = sapm_module(poa_global, temp_air, wind_speed,\n                                     a, b)\n    return sapm_cell_from_module(module_temperature, poa_global, deltaT,\n                                 irrad_ref)\n", "tokens": ["pvlib", "temperature", "py", "def", "sapm_cell", "poa_global", "temp_air", "wind_speed", "a", "b", "deltat", "irrad_ref", "1000", "r", "calculate", "cell", "temperature", "per", "the", "sandia", "array", "performance", "model", "see", "1", "_", "for", "details", "on", "the", "sandia", "array", "performance", "model", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "at", "a", "height", "of", "10", "meters", "m", "s", "a", "float", "parameter", "math", "a", "in", "eq", "sapm1", "b", "float", "parameter", "math", "b", "in", "eq", "sapm1", "deltat", "float", "parameter", "math", "delta", "t", "in", "eq", "sapm2", "c", "irrad_ref", "float", "default", "1000", "reference", "irradiance", "parameter", "math", "e_", "0", "in", "eq", "sapm2", "w", "m", "2", "returns", "numeric", "values", "in", "degrees", "c", "notes", "the", "model", "for", "cell", "temperature", "math", "t_", "c", "is", "given", "by", "a", "pair", "of", "equations", "eq", "11", "and", "12", "in", "1", "_", "math", "label", "sapm1", "t_", "m", "e", "times", "exp", "a", "b", "times", "ws", "t_", "a", "math", "label", "sapm2", "t_", "c", "t_", "m", "frac", "e", "e_", "0", "delta", "t", "the", "module", "back", "surface", "temperature", "math", "t_", "m", "is", "implemented", "in", "py", "func", "pvlib", "temperature", "sapm_module", "inputs", "to", "the", "model", "are", "plane", "of", "array", "irradiance", "math", "e", "w", "m2", "and", "ambient", "air", "temperature", "math", "t_", "a", "c", "model", "parameters", "depend", "both", "on", "the", "module", "construction", "and", "its", "mounting", "parameter", "sets", "are", "provided", "in", "1", "_", "for", "representative", "modules", "and", "mounting", "and", "are", "coded", "for", "convenience", "in", "data", "pvlib", "temperature", "temperature_model_parameters", "module", "mounting", "a", "b", "math", "delta", "t", "c", "glass", "glass", "open", "rack", "3", "47", "0", "0594", "3", "glass", "glass", "close", "roof", "2", "98", "0", "0471", "1", "glass", "polymer", "open", "rack", "3", "56", "0", "075", "3", "glass", "polymer", "insulated", "back", "2", "81", "0", "0455", "0", "references", "1", "king", "d", "et", "al", "2004", "sandia", "photovoltaic", "array", "performance", "model", "sand", "report", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "see", "also", "sapm_cell_from_module", "sapm_module", "examples", "from", "pvlib", "temperature", "import", "sapm_cell", "temperature_model_parameters", "params", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "sapm_cell", "1000", "10", "0", "params", "44", "11703066106086", "module_temperature", "sapm_module", "poa_global", "temp_air", "wind_speed", "a", "b", "return", "sapm_cell_from_module", "module_temperature", "poa_global", "deltat", "irrad_ref"], "doc_len": 329}
{"doc_id": "pvlib/temperature.py::sapm_module", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "sapm_module", "text": "文件路径: pvlib/temperature.py\ndef sapm_module(poa_global, temp_air, wind_speed, a, b):\n    r'''\n    Calculate module back surface temperature per the Sandia Array\n    Performance Model.\n\n    See [1]_ for details on the Sandia Array Performance Model.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    temp_air : numeric\n        Ambient dry bulb temperature [C].\n\n    wind_speed : numeric\n        Wind speed at a height of 10 meters [m/s].\n\n    a : float\n        Parameter :math:`a` in :eq:`sapm1mod`.\n\n    b : float\n        Parameter :math:`b` in :eq:`sapm1mod`.\n\n    Returns\n    -------\n    numeric, values in degrees C.\n\n    Notes\n    -----\n    The model for module temperature :math:`T_{m}` is given by Eq. 11 in [1]_.\n\n    .. math::\n       :label: sapm1mod\n\n       T_{m} = E \\times \\exp (a + b \\times WS) + T_{a}\n\n    Inputs to the model are plane-of-array irradiance :math:`E` (W/m2) and\n    ambient air temperature :math:`T_{a}` (C). Model outputs are surface\n    temperature at the back of the module :math:`T_{m}` and cell temperature\n    :math:`T_{C}`. Model parameters depend both on the module construction and\n    its mounting. Parameter sets are provided in [1]_ for representative\n    modules and mounting, and are coded for convenience in\n    :data:`~pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS`.\n\n    +---------------+----------------+-------+---------+---------------------+\n    | Module        | Mounting       | a     | b       | :math:`\\Delta T [C]`|\n    +===============+================+=======+=========+=====================+\n    | glass/glass   | open rack      | -3.47 | -0.0594 | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/glass   | close roof     | -2.98 | -0.0471 | 1                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | open rack      | -3.56 | -0.075  | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | insulated back | -2.81 | -0.0455 | 0                   |\n    +---------------+----------------+-------+---------+---------------------+\n\n    References\n    ----------\n    .. [1] King, D. et al, 2004, \"Sandia Photovoltaic Array Performance\n       Model\", SAND Report 3535, Sandia National Laboratories, Albuquerque,\n       NM.\n\n    See also\n    --------\n    sapm_cell\n    sapm_cell_from_module\n    '''\n    return poa_global * np.exp(a + b * wind_speed) + temp_air\n", "tokens": ["pvlib", "temperature", "py", "def", "sapm_module", "poa_global", "temp_air", "wind_speed", "a", "b", "r", "calculate", "module", "back", "surface", "temperature", "per", "the", "sandia", "array", "performance", "model", "see", "1", "_", "for", "details", "on", "the", "sandia", "array", "performance", "model", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "at", "a", "height", "of", "10", "meters", "m", "s", "a", "float", "parameter", "math", "a", "in", "eq", "sapm1mod", "b", "float", "parameter", "math", "b", "in", "eq", "sapm1mod", "returns", "numeric", "values", "in", "degrees", "c", "notes", "the", "model", "for", "module", "temperature", "math", "t_", "m", "is", "given", "by", "eq", "11", "in", "1", "_", "math", "label", "sapm1mod", "t_", "m", "e", "times", "exp", "a", "b", "times", "ws", "t_", "a", "inputs", "to", "the", "model", "are", "plane", "of", "array", "irradiance", "math", "e", "w", "m2", "and", "ambient", "air", "temperature", "math", "t_", "a", "c", "model", "outputs", "are", "surface", "temperature", "at", "the", "back", "of", "the", "module", "math", "t_", "m", "and", "cell", "temperature", "math", "t_", "c", "model", "parameters", "depend", "both", "on", "the", "module", "construction", "and", "its", "mounting", "parameter", "sets", "are", "provided", "in", "1", "_", "for", "representative", "modules", "and", "mounting", "and", "are", "coded", "for", "convenience", "in", "data", "pvlib", "temperature", "temperature_model_parameters", "module", "mounting", "a", "b", "math", "delta", "t", "c", "glass", "glass", "open", "rack", "3", "47", "0", "0594", "3", "glass", "glass", "close", "roof", "2", "98", "0", "0471", "1", "glass", "polymer", "open", "rack", "3", "56", "0", "075", "3", "glass", "polymer", "insulated", "back", "2", "81", "0", "0455", "0", "references", "1", "king", "d", "et", "al", "2004", "sandia", "photovoltaic", "array", "performance", "model", "sand", "report", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "see", "also", "sapm_cell", "sapm_cell_from_module", "return", "poa_global", "np", "exp", "a", "b", "wind_speed", "temp_air"], "doc_len": 264}
{"doc_id": "pvlib/temperature.py::sapm_cell_from_module", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "sapm_cell_from_module", "text": "文件路径: pvlib/temperature.py\ndef sapm_cell_from_module(module_temperature, poa_global, deltaT,\n                          irrad_ref=1000.):\n    r'''\n    Calculate cell temperature from module temperature using the Sandia Array\n    Performance Model.\n\n    See [1]_ for details on the Sandia Array Performance Model.\n\n    Parameters\n    ----------\n    module_temperature : numeric\n        Temperature of back of module surface [C].\n\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    deltaT : float\n        Parameter :math:`\\Delta T` in :eq:`sapm2_cell_from_mod` [C].\n\n    irrad_ref : float, default 1000\n        Reference irradiance, parameter :math:`E_{0}` in\n        :eq:`sapm2` [W/m^2].\n\n    Returns\n    -------\n    numeric, values in degrees C.\n\n    Notes\n    -----\n    The model for cell temperature :math:`T_{C}` is given by Eq. 12 in [1]_.\n\n    .. math::\n       :label: sapm2_cell_from_mod\n\n       T_{C} = T_{m} + \\frac{E}{E_{0}} \\Delta T\n\n    The module back surface temperature :math:`T_{m}` is implemented in\n    :py:func:`~pvlib.temperature.sapm_module`.\n\n    Model parameters depend both on the module construction and its mounting.\n    Parameter sets are provided in [1]_ for representative modules and\n    mounting, and are coded for convenience in\n    :data:`~pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS`.\n\n    +---------------+----------------+-------+---------+---------------------+\n    | Module        | Mounting       | a     | b       | :math:`\\Delta T [C]`|\n    +===============+================+=======+=========+=====================+\n    | glass/glass   | open rack      | -3.47 | -0.0594 | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/glass   | close roof     | -2.98 | -0.0471 | 1                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | open rack      | -3.56 | -0.075  | 3                   |\n    +---------------+----------------+-------+---------+---------------------+\n    | glass/polymer | insulated back | -2.81 | -0.0455 | 0                   |\n    +---------------+----------------+-------+---------+---------------------+\n\n    References\n    ----------\n    .. [1] King, D. et al, 2004, \"Sandia Photovoltaic Array Performance\n       Model\", SAND Report 3535, Sandia National Laboratories, Albuquerque,\n       NM.\n\n    See also\n    --------\n    sapm_cell\n    sapm_module\n    '''\n    return module_temperature + (poa_global / irrad_ref) * deltaT\n", "tokens": ["pvlib", "temperature", "py", "def", "sapm_cell_from_module", "module_temperature", "poa_global", "deltat", "irrad_ref", "1000", "r", "calculate", "cell", "temperature", "from", "module", "temperature", "using", "the", "sandia", "array", "performance", "model", "see", "1", "_", "for", "details", "on", "the", "sandia", "array", "performance", "model", "parameters", "module_temperature", "numeric", "temperature", "of", "back", "of", "module", "surface", "c", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "deltat", "float", "parameter", "math", "delta", "t", "in", "eq", "sapm2_cell_from_mod", "c", "irrad_ref", "float", "default", "1000", "reference", "irradiance", "parameter", "math", "e_", "0", "in", "eq", "sapm2", "w", "m", "2", "returns", "numeric", "values", "in", "degrees", "c", "notes", "the", "model", "for", "cell", "temperature", "math", "t_", "c", "is", "given", "by", "eq", "12", "in", "1", "_", "math", "label", "sapm2_cell_from_mod", "t_", "c", "t_", "m", "frac", "e", "e_", "0", "delta", "t", "the", "module", "back", "surface", "temperature", "math", "t_", "m", "is", "implemented", "in", "py", "func", "pvlib", "temperature", "sapm_module", "model", "parameters", "depend", "both", "on", "the", "module", "construction", "and", "its", "mounting", "parameter", "sets", "are", "provided", "in", "1", "_", "for", "representative", "modules", "and", "mounting", "and", "are", "coded", "for", "convenience", "in", "data", "pvlib", "temperature", "temperature_model_parameters", "module", "mounting", "a", "b", "math", "delta", "t", "c", "glass", "glass", "open", "rack", "3", "47", "0", "0594", "3", "glass", "glass", "close", "roof", "2", "98", "0", "0471", "1", "glass", "polymer", "open", "rack", "3", "56", "0", "075", "3", "glass", "polymer", "insulated", "back", "2", "81", "0", "0455", "0", "references", "1", "king", "d", "et", "al", "2004", "sandia", "photovoltaic", "array", "performance", "model", "sand", "report", "3535", "sandia", "national", "laboratories", "albuquerque", "nm", "see", "also", "sapm_cell", "sapm_module", "return", "module_temperature", "poa_global", "irrad_ref", "deltat"], "doc_len": 236}
{"doc_id": "pvlib/temperature.py::pvsyst_cell", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "pvsyst_cell", "text": "文件路径: pvlib/temperature.py\ndef pvsyst_cell(poa_global, temp_air, wind_speed=1.0, u_c=29.0, u_v=0.0,\n                eta_m=None, module_efficiency=0.1, alpha_absorption=0.9):\n    r\"\"\"\n    Calculate cell temperature using an empirical heat loss factor model\n    as implemented in PVsyst.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    temp_air : numeric\n        Ambient dry bulb temperature [C].\n\n    wind_speed : numeric, default 1.0\n        Wind speed in m/s measured at the same height for which the wind loss\n        factor was determined.  The default value 1.0 m/s is the wind\n        speed at module height used to determine NOCT. [m/s]\n\n    u_c : float, default 29.0\n        Combined heat loss factor coefficient. The default value is\n        representative of freestanding modules with the rear surfaces exposed\n        to open air (e.g., rack mounted). Parameter :math:`U_{c}` in\n        :eq:`pvsyst`.\n        :math:`\\left[\\frac{\\text{W}/{\\text{m}^2}}{\\text{C}}\\right]`\n\n    u_v : float, default 0.0\n        Combined heat loss factor influenced by wind. Parameter :math:`U_{v}`\n        in :eq:`pvsyst`.\n        :math:`\\left[ \\frac{\\text{W}/\\text{m}^2}{\\text{C}\\ \\left( \\text{m/s} \\right)} \\right]`  # noQA: E501\n\n    eta_m : numeric, default None (deprecated, use module_efficiency instead)\n\n    module_efficiency : numeric, default 0.1\n        Module external efficiency as a fraction. Parameter :math:`\\eta_{m}`\n        in :eq:`pvsyst`. Calculate as\n        :math:`\\eta_{m} = DC\\ power / (POA\\ irradiance \\times module\\ area)`.\n\n    alpha_absorption : numeric, default 0.9\n        Absorption coefficient. Parameter :math:`\\alpha` in :eq:`pvsyst`.\n\n    Returns\n    -------\n    numeric, values in degrees Celsius\n\n    Notes\n    -----\n    The Pvsyst model for cell temperature :math:`T_{C}` is given by\n\n    .. math::\n       :label: pvsyst\n\n        T_{C} = T_{a} + \\frac{\\alpha E (1 - \\eta_{m})}{U_{c} + U_{v} \\times WS}\n\n    Inputs to the model are plane-of-array irradiance :math:`E` (W/m2), ambient\n    air temperature :math:`T_{a}` (C) and wind speed :math:`WS` (m/s). Model\n    output is cell temperature :math:`T_{C}`. Model parameters depend both on\n    the module construction and its mounting. Parameters are provided in\n    [1]_ for open (freestanding) and close (insulated) mounting configurations,\n    , and are coded for convenience in\n    :data:`~pvlib.temperature.TEMPERATURE_MODEL_PARAMETERS`. The heat loss\n    factors provided represent the combined effect of convection, radiation and\n    conduction, and their values are experimentally determined.\n\n    +--------------+---------------+---------------+\n    | Mounting     | :math:`U_{c}` | :math:`U_{v}` |\n    +==============+===============+===============+\n    | freestanding | 29.0          | 0.0           |\n    +--------------+---------------+---------------+\n    | insulated    | 15.0          | 0.0           |\n    +--------------+---------------+---------------+\n\n    References\n    ----------\n    .. [1] \"PVsyst 6 Help\", Files.pvsyst.com, 2018. [Online]. Available:\n       http://files.pvsyst.com/help/index.html. [Accessed: 10- Dec- 2018].\n\n    .. [2] Faiman, D. (2008). \"Assessing the outdoor operating temperature of\n       photovoltaic modules.\" Progress in Photovoltaics 16(4): 307-315.\n\n    Examples\n    --------\n    >>> from pvlib.temperature import pvsyst_cell, TEMPERATURE_MODEL_PARAMETERS\n    >>> params = TEMPERATURE_MODEL_PARAMETERS['pvsyst']['freestanding']\n    >>> pvsyst_cell(1000, 10, **params)\n    37.93103448275862\n    \"\"\"\n\n    if eta_m:\n        warn_deprecated(\n            since='v0.9', message='eta_m overwriting module_efficiency',\n            name='eta_m', alternative='module_efficiency', removal='v0.10')\n        module_efficiency = eta_m\n    total_loss_factor = u_c + u_v * wind_speed\n    heat_input = poa_global * alpha_absorption * (1 - module_efficiency)\n    temp_difference = heat_input / total_loss_factor\n    return temp_air + temp_difference\n", "tokens": ["pvlib", "temperature", "py", "def", "pvsyst_cell", "poa_global", "temp_air", "wind_speed", "1", "0", "u_c", "29", "0", "u_v", "0", "0", "eta_m", "none", "module_efficiency", "0", "1", "alpha_absorption", "0", "9", "r", "calculate", "cell", "temperature", "using", "an", "empirical", "heat", "loss", "factor", "model", "as", "implemented", "in", "pvsyst", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "default", "1", "0", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "the", "default", "value", "1", "0", "m", "s", "is", "the", "wind", "speed", "at", "module", "height", "used", "to", "determine", "noct", "m", "s", "u_c", "float", "default", "29", "0", "combined", "heat", "loss", "factor", "coefficient", "the", "default", "value", "is", "representative", "of", "freestanding", "modules", "with", "the", "rear", "surfaces", "exposed", "to", "open", "air", "e", "g", "rack", "mounted", "parameter", "math", "u_", "c", "in", "eq", "pvsyst", "math", "left", "frac", "text", "w", "text", "m", "2", "text", "c", "right", "u_v", "float", "default", "0", "0", "combined", "heat", "loss", "factor", "influenced", "by", "wind", "parameter", "math", "u_", "v", "in", "eq", "pvsyst", "math", "left", "frac", "text", "w", "text", "m", "2", "text", "c", "left", "text", "m", "s", "right", "right", "noqa", "e501", "eta_m", "numeric", "default", "none", "deprecated", "use", "module_efficiency", "instead", "module_efficiency", "numeric", "default", "0", "1", "module", "external", "efficiency", "as", "a", "fraction", "parameter", "math", "eta_", "m", "in", "eq", "pvsyst", "calculate", "as", "math", "eta_", "m", "dc", "power", "poa", "irradiance", "times", "module", "area", "alpha_absorption", "numeric", "default", "0", "9", "absorption", "coefficient", "parameter", "math", "alpha", "in", "eq", "pvsyst", "returns", "numeric", "values", "in", "degrees", "celsius", "notes", "the", "pvsyst", "model", "for", "cell", "temperature", "math", "t_", "c", "is", "given", "by", "math", "label", "pvsyst", "t_", "c", "t_", "a", "frac", "alpha", "e", "1", "eta_", "m", "u_", "c", "u_", "v", "times", "ws", "inputs", "to", "the", "model", "are", "plane", "of", "array", "irradiance", "math", "e", "w", "m2", "ambient", "air", "temperature", "math", "t_", "a", "c", "and", "wind", "speed", "math", "ws", "m", "s", "model", "output", "is", "cell", "temperature", "math", "t_", "c", "model", "parameters", "depend", "both", "on", "the", "module", "construction", "and", "its", "mounting", "parameters", "are", "provided", "in", "1", "_", "for", "open", "freestanding", "and", "close", "insulated", "mounting", "configurations", "and", "are", "coded", "for", "convenience", "in", "data", "pvlib", "temperature", "temperature_model_parameters", "the", "heat", "loss", "factors", "provided", "represent", "the", "combined", "effect", "of", "convection", "radiation", "and", "conduction", "and", "their", "values", "are", "experimentally", "determined", "mounting", "math", "u_", "c", "math", "u_", "v", "freestanding", "29", "0", "0", "0", "insulated", "15", "0", "0", "0", "references", "1", "pvsyst", "6", "help", "files", "pvsyst", "com", "2018", "online", "available", "http", "files", "pvsyst", "com", "help", "index", "html", "accessed", "10", "dec", "2018", "2", "faiman", "d", "2008", "assessing", "the", "outdoor", "operating", "temperature", "of", "photovoltaic", "modules", "progress", "in", "photovoltaics", "16", "4", "307", "315", "examples", "from", "pvlib", "temperature", "import", "pvsyst_cell", "temperature_model_parameters", "params", "temperature_model_parameters", "pvsyst", "freestanding", "pvsyst_cell", "1000", "10", "params", "37", "93103448275862", "if", "eta_m", "warn_deprecated", "since", "v0", "9", "message", "eta_m", "overwriting", "module_efficiency", "name", "eta_m", "alternative", "module_efficiency", "removal", "v0", "10", "module_efficiency", "eta_m", "total_loss_factor", "u_c", "u_v", "wind_speed", "heat_input", "poa_global", "alpha_absorption", "1", "module_efficiency", "temp_difference", "heat_input", "total_loss_factor", "return", "temp_air", "temp_difference"], "doc_len": 471}
{"doc_id": "pvlib/temperature.py::faiman", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "faiman", "text": "文件路径: pvlib/temperature.py\ndef faiman(poa_global, temp_air, wind_speed=1.0, u0=25.0, u1=6.84):\n    r'''\n    Calculate cell or module temperature using the Faiman model.\n\n    The Faiman model uses an empirical heat loss factor model [1]_ and is\n    adopted in the IEC 61853 standards [2]_ and [3]_.\n\n    Usage of this model in the IEC 61853 standard does not distinguish\n    between cell and module temperature.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    temp_air : numeric\n        Ambient dry bulb temperature [C].\n\n    wind_speed : numeric, default 1.0\n        Wind speed in m/s measured at the same height for which the wind loss\n        factor was determined.  The default value 1.0 m/s is the wind\n        speed at module height used to determine NOCT. [m/s]\n\n    u0 : numeric, default 25.0\n        Combined heat loss factor coefficient. The default value is one\n        determined by Faiman for 7 silicon modules.\n        :math:`\\left[\\frac{\\text{W}/{\\text{m}^2}}{\\text{C}}\\right]`\n\n    u1 : numeric, default 6.84\n        Combined heat loss factor influenced by wind. The default value is one\n        determined by Faiman for 7 silicon modules.\n        :math:`\\left[ \\frac{\\text{W}/\\text{m}^2}{\\text{C}\\ \\left( \\text{m/s} \\right)} \\right]`\n\n    Returns\n    -------\n    numeric, values in degrees Celsius\n\n    Notes\n    -----\n    All arguments may be scalars or vectors. If multiple arguments\n    are vectors they must be the same length.\n\n    References\n    ----------\n    .. [1] Faiman, D. (2008). \"Assessing the outdoor operating temperature of\n       photovoltaic modules.\" Progress in Photovoltaics 16(4): 307-315.\n\n    .. [2] \"IEC 61853-2 Photovoltaic (PV) module performance testing and energy\n       rating - Part 2: Spectral responsivity, incidence angle and module\n       operating temperature measurements\". IEC, Geneva, 2018.\n\n    .. [3] \"IEC 61853-3 Photovoltaic (PV) module performance testing and energy\n       rating - Part 3: Energy rating of PV modules\". IEC, Geneva, 2018.\n\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Dec., 2019\n\n    # The following lines may seem odd since u0 & u1 are probably scalar,\n    # but it serves an indirect and easy way of allowing lists and\n    # tuples for the other function arguments.\n    u0 = np.asanyarray(u0)\n    u1 = np.asanyarray(u1)\n\n    total_loss_factor = u0 + u1 * wind_speed\n    heat_input = poa_global\n    temp_difference = heat_input / total_loss_factor\n    return temp_air + temp_difference\n", "tokens": ["pvlib", "temperature", "py", "def", "faiman", "poa_global", "temp_air", "wind_speed", "1", "0", "u0", "25", "0", "u1", "6", "84", "r", "calculate", "cell", "or", "module", "temperature", "using", "the", "faiman", "model", "the", "faiman", "model", "uses", "an", "empirical", "heat", "loss", "factor", "model", "1", "_", "and", "is", "adopted", "in", "the", "iec", "61853", "standards", "2", "_", "and", "3", "_", "usage", "of", "this", "model", "in", "the", "iec", "61853", "standard", "does", "not", "distinguish", "between", "cell", "and", "module", "temperature", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "default", "1", "0", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "the", "default", "value", "1", "0", "m", "s", "is", "the", "wind", "speed", "at", "module", "height", "used", "to", "determine", "noct", "m", "s", "u0", "numeric", "default", "25", "0", "combined", "heat", "loss", "factor", "coefficient", "the", "default", "value", "is", "one", "determined", "by", "faiman", "for", "7", "silicon", "modules", "math", "left", "frac", "text", "w", "text", "m", "2", "text", "c", "right", "u1", "numeric", "default", "6", "84", "combined", "heat", "loss", "factor", "influenced", "by", "wind", "the", "default", "value", "is", "one", "determined", "by", "faiman", "for", "7", "silicon", "modules", "math", "left", "frac", "text", "w", "text", "m", "2", "text", "c", "left", "text", "m", "s", "right", "right", "returns", "numeric", "values", "in", "degrees", "celsius", "notes", "all", "arguments", "may", "be", "scalars", "or", "vectors", "if", "multiple", "arguments", "are", "vectors", "they", "must", "be", "the", "same", "length", "references", "1", "faiman", "d", "2008", "assessing", "the", "outdoor", "operating", "temperature", "of", "photovoltaic", "modules", "progress", "in", "photovoltaics", "16", "4", "307", "315", "2", "iec", "61853", "2", "photovoltaic", "pv", "module", "performance", "testing", "and", "energy", "rating", "part", "2", "spectral", "responsivity", "incidence", "angle", "and", "module", "operating", "temperature", "measurements", "iec", "geneva", "2018", "3", "iec", "61853", "3", "photovoltaic", "pv", "module", "performance", "testing", "and", "energy", "rating", "part", "3", "energy", "rating", "of", "pv", "modules", "iec", "geneva", "2018", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "dec", "2019", "the", "following", "lines", "may", "seem", "odd", "since", "u0", "u1", "are", "probably", "scalar", "but", "it", "serves", "an", "indirect", "and", "easy", "way", "of", "allowing", "lists", "and", "tuples", "for", "the", "other", "function", "arguments", "u0", "np", "asanyarray", "u0", "u1", "np", "asanyarray", "u1", "total_loss_factor", "u0", "u1", "wind_speed", "heat_input", "poa_global", "temp_difference", "heat_input", "total_loss_factor", "return", "temp_air", "temp_difference"], "doc_len": 353}
{"doc_id": "pvlib/temperature.py::ross", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "ross", "text": "文件路径: pvlib/temperature.py\ndef ross(poa_global, temp_air, noct):\n    r'''\n    Calculate cell temperature using the Ross model.\n\n    The Ross model [1]_ assumes the difference between cell temperature\n    and ambient temperature is proportional to the plane of array irradiance,\n    and assumes wind speed of 1 m/s. The model implicitly assumes steady or\n    slowly changing irradiance conditions.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance. [W/m^2]\n\n    temp_air : numeric\n        Ambient dry bulb temperature. [C]\n\n    noct : numeric\n        Nominal operating cell temperature [C], determined at conditions of\n        800 W/m^2 irradiance, 20 C ambient air temperature and 1 m/s wind.\n\n    Returns\n    -------\n    cell_temperature : numeric\n        Cell temperature. [C]\n\n    Notes\n    -----\n    The Ross model for cell temperature :math:`T_{C}` is given in [1]_ as\n\n    .. math::\n\n        T_{C} = T_{a} + \\frac{NOCT - 20}{80} S\n\n    where :math:`S` is the plane of array irradiance in :math:`mW/{cm}^2`.\n    This function expects irradiance in :math:`W/m^2`.\n\n    References\n    ----------\n    .. [1] Ross, R. G. Jr., (1981). \"Design Techniques for Flat-Plate\n       Photovoltaic Arrays\". 15th IEEE Photovoltaic Specialist Conference,\n       Orlando, FL.\n    '''\n    # factor of 0.1 converts irradiance from W/m2 to mW/cm2\n    return temp_air + (noct - 20.) / 80. * poa_global * 0.1\n", "tokens": ["pvlib", "temperature", "py", "def", "ross", "poa_global", "temp_air", "noct", "r", "calculate", "cell", "temperature", "using", "the", "ross", "model", "the", "ross", "model", "1", "_", "assumes", "the", "difference", "between", "cell", "temperature", "and", "ambient", "temperature", "is", "proportional", "to", "the", "plane", "of", "array", "irradiance", "and", "assumes", "wind", "speed", "of", "1", "m", "s", "the", "model", "implicitly", "assumes", "steady", "or", "slowly", "changing", "irradiance", "conditions", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "noct", "numeric", "nominal", "operating", "cell", "temperature", "c", "determined", "at", "conditions", "of", "800", "w", "m", "2", "irradiance", "20", "c", "ambient", "air", "temperature", "and", "1", "m", "s", "wind", "returns", "cell_temperature", "numeric", "cell", "temperature", "c", "notes", "the", "ross", "model", "for", "cell", "temperature", "math", "t_", "c", "is", "given", "in", "1", "_", "as", "math", "t_", "c", "t_", "a", "frac", "noct", "20", "80", "s", "where", "math", "s", "is", "the", "plane", "of", "array", "irradiance", "in", "math", "mw", "cm", "2", "this", "function", "expects", "irradiance", "in", "math", "w", "m", "2", "references", "1", "ross", "r", "g", "jr", "1981", "design", "techniques", "for", "flat", "plate", "photovoltaic", "arrays", "15th", "ieee", "photovoltaic", "specialist", "conference", "orlando", "fl", "factor", "of", "0", "1", "converts", "irradiance", "from", "w", "m2", "to", "mw", "cm2", "return", "temp_air", "noct", "20", "80", "poa_global", "0", "1"], "doc_len": 194}
{"doc_id": "pvlib/temperature.py::_fuentes_hconv", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "_fuentes_hconv", "text": "文件路径: pvlib/temperature.py\ndef _fuentes_hconv(tave, windmod, tinoct, temp_delta, xlen, tilt,\n                   check_reynold):\n    # Calculate the convective coefficient as in Fuentes 1987 -- a mixture of\n    # free, laminar, and turbulent convection.\n    densair = 0.003484 * 101325.0 / tave  # density\n    visair = 0.24237e-6 * tave**0.76 / densair  # kinematic viscosity\n    condair = 2.1695e-4 * tave**0.84  # thermal conductivity\n    reynold = windmod * xlen / visair\n    # the boundary between laminar and turbulent is modeled as an abrupt\n    # change at Re = 1.2e5:\n    if check_reynold and reynold > 1.2e5:\n        # turbulent convection\n        hforce = 0.0282 / reynold**0.2 * densair * windmod * 1007 / 0.71**0.4\n    else:\n        # laminar convection\n        hforce = 0.8600 / reynold**0.5 * densair * windmod * 1007 / 0.71**0.67\n    # free convection via Grashof number\n    # NB: Fuentes hardwires sind(tilt) as 0.5 for tilt=30\n    grashof = 9.8 / tave * temp_delta * xlen**3 / visair**2 * sind(tilt)\n    # product of Nusselt number and (k/l)\n    hfree = 0.21 * (grashof * 0.71)**0.32 * condair / xlen\n    # combine free and forced components\n    hconv = (hfree**3 + hforce**3)**(1/3)\n    return hconv\n", "tokens": ["pvlib", "temperature", "py", "def", "_fuentes_hconv", "tave", "windmod", "tinoct", "temp_delta", "xlen", "tilt", "check_reynold", "calculate", "the", "convective", "coefficient", "as", "in", "fuentes", "1987", "a", "mixture", "of", "free", "laminar", "and", "turbulent", "convection", "densair", "0", "003484", "101325", "0", "tave", "density", "visair", "0", "24237e", "6", "tave", "0", "76", "densair", "kinematic", "viscosity", "condair", "2", "1695e", "4", "tave", "0", "84", "thermal", "conductivity", "reynold", "windmod", "xlen", "visair", "the", "boundary", "between", "laminar", "and", "turbulent", "is", "modeled", "as", "an", "abrupt", "change", "at", "re", "1", "2e5", "if", "check_reynold", "and", "reynold", "1", "2e5", "turbulent", "convection", "hforce", "0", "0282", "reynold", "0", "2", "densair", "windmod", "1007", "0", "71", "0", "4", "else", "laminar", "convection", "hforce", "0", "8600", "reynold", "0", "5", "densair", "windmod", "1007", "0", "71", "0", "67", "free", "convection", "via", "grashof", "number", "nb", "fuentes", "hardwires", "sind", "tilt", "as", "0", "5", "for", "tilt", "30", "grashof", "9", "8", "tave", "temp_delta", "xlen", "3", "visair", "2", "sind", "tilt", "product", "of", "nusselt", "number", "and", "k", "l", "hfree", "0", "21", "grashof", "0", "71", "0", "32", "condair", "xlen", "combine", "free", "and", "forced", "components", "hconv", "hfree", "3", "hforce", "3", "1", "3", "return", "hconv"], "doc_len": 169}
{"doc_id": "pvlib/temperature.py::_hydraulic_diameter", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "_hydraulic_diameter", "text": "文件路径: pvlib/temperature.py\ndef _hydraulic_diameter(width, height):\n    # calculate the hydraulic diameter of a rectangle\n    return 2 * (width * height) / (width + height)\n", "tokens": ["pvlib", "temperature", "py", "def", "_hydraulic_diameter", "width", "height", "calculate", "the", "hydraulic", "diameter", "of", "a", "rectangle", "return", "2", "width", "height", "width", "height"], "doc_len": 20}
{"doc_id": "pvlib/temperature.py::fuentes", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "fuentes", "text": "文件路径: pvlib/temperature.py\ndef fuentes(poa_global, temp_air, wind_speed, noct_installed, module_height=5,\n            wind_height=9.144, emissivity=0.84, absorption=0.83,\n            surface_tilt=30, module_width=0.31579, module_length=1.2):\n    \"\"\"\n    Calculate cell or module temperature using the Fuentes model.\n\n    The Fuentes model is a first-principles heat transfer energy balance\n    model [1]_ that is used in PVWatts for cell temperature modeling [2]_.\n\n    Parameters\n    ----------\n    poa_global : pandas Series\n        Total incident irradiance [W/m^2]\n\n    temp_air : pandas Series\n        Ambient dry bulb temperature [C]\n\n    wind_speed : pandas Series\n        Wind speed [m/s]\n\n    noct_installed : float\n        The \"installed\" nominal operating cell temperature as defined in [1]_.\n        PVWatts assumes this value to be 45 C for rack-mounted arrays and\n        49 C for roof mount systems with restricted air flow around the\n        module.  [C]\n\n    module_height : float, default 5.0\n        The height above ground of the center of the module. The PVWatts\n        default is 5.0 [m]\n\n    wind_height : float, default 9.144\n        The height above ground at which ``wind_speed`` is measured. The\n        PVWatts defauls is 9.144 [m]\n\n    emissivity : float, default 0.84\n        The effectiveness of the module at radiating thermal energy. [unitless]\n\n    absorption : float, default 0.83\n        The fraction of incident irradiance that is converted to thermal\n        energy in the module. [unitless]\n\n    surface_tilt : float, default 30\n        Module tilt from horizontal. If not provided, the default value\n        of 30 degrees from [1]_ and [2]_ is used. [degrees]\n\n    module_width : float, default 0.31579\n        Module width. The default value of 0.31579 meters in combination with\n        the default `module_length` gives a hydraulic diameter of 0.5 as\n        assumed in [1]_ and [2]_. [m]\n\n    module_length : float, default 1.2\n        Module length. The default value of 1.2 meters in combination with\n        the default `module_width` gives a hydraulic diameter of 0.5 as\n        assumed in [1]_ and [2]_. [m]\n\n    Returns\n    -------\n    temperature_cell : pandas Series\n        The modeled cell temperature [C]\n\n    Notes\n    -----\n    This function returns slightly different values from PVWatts at night\n    and just after dawn. This is because the SAM SSC assumes that module\n    temperature equals ambient temperature when irradiance is zero so it can\n    skip the heat balance calculation at night.\n\n    References\n    ----------\n    .. [1] Fuentes, M. K., 1987, \"A Simplifed Thermal Model for Flat-Plate\n           Photovoltaic Arrays\", SAND85-0330, Sandia National Laboratories,\n           Albuquerque NM.\n           http://prod.sandia.gov/techlib/access-control.cgi/1985/850330.pdf\n    .. [2] Dobos, A. P., 2014, \"PVWatts Version 5 Manual\", NREL/TP-6A20-62641,\n           National Renewable Energy Laboratory, Golden CO.\n           doi:10.2172/1158421.\n    \"\"\"\n    # ported from the FORTRAN77 code provided in Appendix A of Fuentes 1987;\n    # nearly all variable names are kept the same for ease of comparison.\n\n    boltz = 5.669e-8\n    emiss = emissivity\n    absorp = absorption\n    xlen = _hydraulic_diameter(module_width, module_length)\n    # cap0 has units of [J / (m^2 K)], equal to mass per unit area times\n    # specific heat of the module.\n    cap0 = 11000\n    tinoct = noct_installed + 273.15\n\n    # convective coefficient of top surface of module at NOCT\n    windmod = 1.0\n    tave = (tinoct + 293.15) / 2\n    hconv = _fuentes_hconv(tave, windmod, tinoct, tinoct - 293.15, xlen,\n                           surface_tilt, False)\n\n    # determine the ground temperature ratio and the ratio of the total\n    # convection to the top side convection\n    hground = emiss * boltz * (tinoct**2 + 293.15**2) * (tinoct + 293.15)\n    backrat = (\n        absorp * 800.0\n        - emiss * boltz * (tinoct**4 - 282.21**4)\n        - hconv * (tinoct - 293.15)\n    ) / ((hground + hconv) * (tinoct - 293.15))\n    tground = (tinoct**4 - backrat * (tinoct**4 - 293.15**4))**0.25\n    tground = np.clip(tground, 293.15, tinoct)\n\n    tgrat = (tground - 293.15) / (tinoct - 293.15)\n    convrat = (absorp * 800 - emiss * boltz * (\n        2 * tinoct**4 - 282.21**4 - tground**4)) / (hconv * (tinoct - 293.15))\n\n    # adjust the capacitance (thermal mass) of the module based on the INOCT.\n    # It is a function of INOCT because high INOCT implies thermal coupling\n    # with the racking (e.g. roofmount), so the thermal mass is increased.\n    # `cap` has units J/(m^2 C) -- see Table 3, Equations 26 & 27\n    cap = cap0\n    if tinoct > 321.15:\n        cap = cap * (1 + (tinoct - 321.15) / 12)\n\n    # iterate through timeseries inputs\n    sun0 = 0\n\n    # n.b. the way Fuentes calculates the first timedelta makes it seem like\n    # the value doesn't matter -- rather than recreate it here, just assume\n    # it's the same as the second timedelta:\n    timedelta_seconds = poa_global.index.to_series().diff().dt.total_seconds()\n    timedelta_hours = timedelta_seconds / 3600\n    timedelta_hours.iloc[0] = timedelta_hours.iloc[1]\n\n    tamb_array = temp_air + 273.15\n    sun_array = poa_global * absorp\n\n    # Two of the calculations are easily vectorized, so precalculate them:\n    # sky temperature -- Equation 24\n    tsky_array = 0.68 * (0.0552 * tamb_array**1.5) + 0.32 * tamb_array\n    # wind speed at module height -- Equation 22\n    # not sure why the 1e-4 factor is included -- maybe the equations don't\n    # behave well if wind == 0?\n    windmod_array = wind_speed * (module_height/wind_height)**0.2 + 1e-4\n\n    tmod0 = 293.15\n    tmod_array = np.zeros_like(poa_global)\n\n    iterator = zip(tamb_array, sun_array, windmod_array, tsky_array,\n                   timedelta_hours)\n    for i, (tamb, sun, windmod, tsky, dtime) in enumerate(iterator):\n        # solve the heat transfer equation, iterating because the heat loss\n        # terms depend on tmod. NB Fuentes doesn't show that 10 iterations is\n        # sufficient for convergence.\n        tmod = tmod0\n        for j in range(10):\n            # overall convective coefficient\n            tave = (tmod + tamb) / 2\n            hconv = convrat * _fuentes_hconv(tave, windmod, tinoct,\n                                             abs(tmod-tamb), xlen,\n                                             surface_tilt, True)\n            # sky radiation coefficient (Equation 3)\n            hsky = emiss * boltz * (tmod**2 + tsky**2) * (tmod + tsky)\n            # ground radiation coeffieicient (Equation 4)\n            tground = tamb + tgrat * (tmod - tamb)\n            hground = emiss * boltz * (tmod**2 + tground**2) * (tmod + tground)\n            # thermal lag -- Equation 8\n            eigen = - (hconv + hsky + hground) / cap * dtime * 3600\n            # not sure why this check is done, maybe as a speed optimization?\n            if eigen > -10:\n                ex = np.exp(eigen)\n            else:\n                ex = 0\n            # Equation 7 -- note that `sun` and `sun0` already account for\n            # absorption (alpha)\n            tmod = tmod0 * ex + (\n                (1 - ex) * (\n                    hconv * tamb\n                    + hsky * tsky\n                    + hground * tground\n                    + sun0\n                    + (sun - sun0) / eigen\n                ) + sun - sun0\n            ) / (hconv + hsky + hground)\n        tmod_array[i] = tmod\n        tmod0 = tmod\n        sun0 = sun\n\n    return pd.Series(tmod_array - 273.15, index=poa_global.index, name='tmod')\n", "tokens": ["pvlib", "temperature", "py", "def", "fuentes", "poa_global", "temp_air", "wind_speed", "noct_installed", "module_height", "5", "wind_height", "9", "144", "emissivity", "0", "84", "absorption", "0", "83", "surface_tilt", "30", "module_width", "0", "31579", "module_length", "1", "2", "calculate", "cell", "or", "module", "temperature", "using", "the", "fuentes", "model", "the", "fuentes", "model", "is", "a", "first", "principles", "heat", "transfer", "energy", "balance", "model", "1", "_", "that", "is", "used", "in", "pvwatts", "for", "cell", "temperature", "modeling", "2", "_", "parameters", "poa_global", "pandas", "series", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "pandas", "series", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "pandas", "series", "wind", "speed", "m", "s", "noct_installed", "float", "the", "installed", "nominal", "operating", "cell", "temperature", "as", "defined", "in", "1", "_", "pvwatts", "assumes", "this", "value", "to", "be", "45", "c", "for", "rack", "mounted", "arrays", "and", "49", "c", "for", "roof", "mount", "systems", "with", "restricted", "air", "flow", "around", "the", "module", "c", "module_height", "float", "default", "5", "0", "the", "height", "above", "ground", "of", "the", "center", "of", "the", "module", "the", "pvwatts", "default", "is", "5", "0", "m", "wind_height", "float", "default", "9", "144", "the", "height", "above", "ground", "at", "which", "wind_speed", "is", "measured", "the", "pvwatts", "defauls", "is", "9", "144", "m", "emissivity", "float", "default", "0", "84", "the", "effectiveness", "of", "the", "module", "at", "radiating", "thermal", "energy", "unitless", "absorption", "float", "default", "0", "83", "the", "fraction", "of", "incident", "irradiance", "that", "is", "converted", "to", "thermal", "energy", "in", "the", "module", "unitless", "surface_tilt", "float", "default", "30", "module", "tilt", "from", "horizontal", "if", "not", "provided", "the", "default", "value", "of", "30", "degrees", "from", "1", "_", "and", "2", "_", "is", "used", "degrees", "module_width", "float", "default", "0", "31579", "module", "width", "the", "default", "value", "of", "0", "31579", "meters", "in", "combination", "with", "the", "default", "module_length", "gives", "a", "hydraulic", "diameter", "of", "0", "5", "as", "assumed", "in", "1", "_", "and", "2", "_", "m", "module_length", "float", "default", "1", "2", "module", "length", "the", "default", "value", "of", "1", "2", "meters", "in", "combination", "with", "the", "default", "module_width", "gives", "a", "hydraulic", "diameter", "of", "0", "5", "as", "assumed", "in", "1", "_", "and", "2", "_", "m", "returns", "temperature_cell", "pandas", "series", "the", "modeled", "cell", "temperature", "c", "notes", "this", "function", "returns", "slightly", "different", "values", "from", "pvwatts", "at", "night", "and", "just", "after", "dawn", "this", "is", "because", "the", "sam", "ssc", "assumes", "that", "module", "temperature", "equals", "ambient", "temperature", "when", "irradiance", "is", "zero", "so", "it", "can", "skip", "the", "heat", "balance", "calculation", "at", "night", "references", "1", "fuentes", "m", "k", "1987", "a", "simplifed", "thermal", "model", "for", "flat", "plate", "photovoltaic", "arrays", "sand85", "0330", "sandia", "national", "laboratories", "albuquerque", "nm", "http", "prod", "sandia", "gov", "techlib", "access", "control", "cgi", "1985", "850330", "pdf", "2", "dobos", "a", "p", "2014", "pvwatts", "version", "5", "manual", "nrel", "tp", "6a20", "62641", "national", "renewable", "energy", "laboratory", "golden", "co", "doi", "10", "2172", "1158421", "ported", "from", "the", "fortran77", "code", "provided", "in", "appendix", "a", "of", "fuentes", "1987", "nearly", "all", "variable", "names", "are", "kept", "the", "same", "for", "ease", "of", "comparison", "boltz", "5", "669e", "8", "emiss", "emissivity", "absorp", "absorption", "xlen", "_hydraulic_diameter", "module_width", "module_length", "cap0", "has", "units", "of", "j", "m", "2", "k", "equal", "to", "mass", "per", "unit", "area", "times", "specific", "heat", "of", "the", "module", "cap0", "11000", "tinoct", "noct_installed", "273", "15", "convective", "coefficient", "of", "top", "surface", "of", "module", "at", "noct", "windmod", "1", "0", "tave", "tinoct", "293", "15", "2", "hconv", "_fuentes_hconv", "tave", "windmod", "tinoct", "tinoct", "293", "15", "xlen", "surface_tilt", "false", "determine", "the", "ground", "temperature", "ratio", "and", "the", "ratio", "of", "the", "total", "convection", "to", "the", "top", "side", "convection", "hground", "emiss", "boltz", "tinoct", "2", "293", "15", "2", "tinoct", "293", "15", "backrat", "absorp", "800", "0", "emiss", "boltz", "tinoct", "4", "282", "21", "4", "hconv", "tinoct", "293", "15", "hground", "hconv", "tinoct", "293", "15", "tground", "tinoct", "4", "backrat", "tinoct", "4", "293", "15", "4", "0", "25", "tground", "np", "clip", "tground", "293", "15", "tinoct", "tgrat", "tground", "293", "15", "tinoct", "293", "15", "convrat", "absorp", "800", "emiss", "boltz", "2", "tinoct", "4", "282", "21", "4", "tground", "4", "hconv", "tinoct", "293", "15", "adjust", "the", "capacitance", "thermal", "mass", "of", "the", "module", "based", "on", "the", "inoct", "it", "is", "a", "function", "of", "inoct", "because", "high", "inoct", "implies", "thermal", "coupling", "with", "the", "racking", "e", "g", "roofmount", "so", "the", "thermal", "mass", "is", "increased", "cap", "has", "units", "j", "m", "2", "c", "see", "table", "3", "equations", "26", "27", "cap", "cap0", "if", "tinoct", "321", "15", "cap", "cap", "1", "tinoct", "321", "15", "12", "iterate", "through", "timeseries", "inputs", "sun0", "0", "n", "b", "the", "way", "fuentes", "calculates", "the", "first", "timedelta", "makes", "it", "seem", "like", "the", "value", "doesn", "t", "matter", "rather", "than", "recreate", "it", "here", "just", "assume", "it", "s", "the", "same", "as", "the", "second", "timedelta", "timedelta_seconds", "poa_global", "index", "to_series", "diff", "dt", "total_seconds", "timedelta_hours", "timedelta_seconds", "3600", "timedelta_hours", "iloc", "0", "timedelta_hours", "iloc", "1", "tamb_array", "temp_air", "273", "15", "sun_array", "poa_global", "absorp", "two", "of", "the", "calculations", "are", "easily", "vectorized", "so", "precalculate", "them", "sky", "temperature", "equation", "24", "tsky_array", "0", "68", "0", "0552", "tamb_array", "1", "5", "0", "32", "tamb_array", "wind", "speed", "at", "module", "height", "equation", "22", "not", "sure", "why", "the", "1e", "4", "factor", "is", "included", "maybe", "the", "equations", "don", "t", "behave", "well", "if", "wind", "0", "windmod_array", "wind_speed", "module_height", "wind_height", "0", "2", "1e", "4", "tmod0", "293", "15", "tmod_array", "np", "zeros_like", "poa_global", "iterator", "zip", "tamb_array", "sun_array", "windmod_array", "tsky_array", "timedelta_hours", "for", "i", "tamb", "sun", "windmod", "tsky", "dtime", "in", "enumerate", "iterator", "solve", "the", "heat", "transfer", "equation", "iterating", "because", "the", "heat", "loss", "terms", "depend", "on", "tmod", "nb", "fuentes", "doesn", "t", "show", "that", "10", "iterations", "is", "sufficient", "for", "convergence", "tmod", "tmod0", "for", "j", "in", "range", "10", "overall", "convective", "coefficient", "tave", "tmod", "tamb", "2", "hconv", "convrat", "_fuentes_hconv", "tave", "windmod", "tinoct", "abs", "tmod", "tamb", "xlen", "surface_tilt", "true", "sky", "radiation", "coefficient", "equation", "3", "hsky", "emiss", "boltz", "tmod", "2", "tsky", "2", "tmod", "tsky", "ground", "radiation", "coeffieicient", "equation", "4", "tground", "tamb", "tgrat", "tmod", "tamb", "hground", "emiss", "boltz", "tmod", "2", "tground", "2", "tmod", "tground", "thermal", "lag", "equation", "8", "eigen", "hconv", "hsky", "hground", "cap", "dtime", "3600", "not", "sure", "why", "this", "check", "is", "done", "maybe", "as", "a", "speed", "optimization", "if", "eigen", "10", "ex", "np", "exp", "eigen", "else", "ex", "0", "equation", "7", "note", "that", "sun", "and", "sun0", "already", "account", "for", "absorption", "alpha", "tmod", "tmod0", "ex", "1", "ex", "hconv", "tamb", "hsky", "tsky", "hground", "tground", "sun0", "sun", "sun0", "eigen", "sun", "sun0", "hconv", "hsky", "hground", "tmod_array", "i", "tmod", "tmod0", "tmod", "sun0", "sun", "return", "pd", "series", "tmod_array", "273", "15", "index", "poa_global", "index", "name", "tmod"], "doc_len": 965}
{"doc_id": "pvlib/temperature.py::_adj_for_mounting_standoff", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "_adj_for_mounting_standoff", "text": "文件路径: pvlib/temperature.py\ndef _adj_for_mounting_standoff(x):\n    # supports noct cell temperature function. Except for x > 3.5, the SAM code\n    # and documentation aren't clear on the precise intervals. The choice of\n    # < or <= here is pvlib's.\n    return np.piecewise(x, [x <= 0, (x > 0) & (x < 0.5),\n                            (x >= 0.5) & (x < 1.5), (x >= 1.5) & (x < 2.5),\n                            (x >= 2.5) & (x <= 3.5), x > 3.5],\n                        [0., 18., 11., 6., 2., 0.])\n", "tokens": ["pvlib", "temperature", "py", "def", "_adj_for_mounting_standoff", "x", "supports", "noct", "cell", "temperature", "function", "except", "for", "x", "3", "5", "the", "sam", "code", "and", "documentation", "aren", "t", "clear", "on", "the", "precise", "intervals", "the", "choice", "of", "or", "here", "is", "pvlib", "s", "return", "np", "piecewise", "x", "x", "0", "x", "0", "x", "0", "5", "x", "0", "5", "x", "1", "5", "x", "1", "5", "x", "2", "5", "x", "2", "5", "x", "3", "5", "x", "3", "5", "0", "18", "11", "6", "2", "0"], "doc_len": 74}
{"doc_id": "pvlib/temperature.py::noct_sam", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "noct_sam", "text": "文件路径: pvlib/temperature.py\ndef noct_sam(poa_global, temp_air, wind_speed, noct, module_efficiency,\n             effective_irradiance=None, transmittance_absorptance=0.9,\n             array_height=1, mount_standoff=4):\n    r'''\n    Cell temperature model from the System Advisor Model (SAM).\n\n    The model is described in [1]_, Section 10.6.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance. [W/m^2]\n\n    temp_air : numeric\n        Ambient dry bulb temperature. [C]\n\n    wind_speed : numeric\n        Wind speed in m/s measured at the same height for which the wind loss\n        factor was determined.  The default value 1.0 m/s is the wind\n        speed at module height used to determine NOCT. [m/s]\n\n    noct : float\n        Nominal operating cell temperature [C], determined at conditions of\n        800 W/m^2 irradiance, 20 C ambient air temperature and 1 m/s wind.\n\n    module_efficiency : float\n        Module external efficiency [unitless] at reference conditions of\n        1000 W/m^2 and 20C. Denoted as :math:`eta_{m}` in [1]_. Calculate as\n        :math:`\\eta_{m} = \\frac{V_{mp} I_{mp}}{A \\times 1000 W/m^2}`\n        where A is module area [m^2].\n\n    effective_irradiance : numeric, default None.\n        The irradiance that is converted to photocurrent. If None,\n        assumed equal to poa_global. [W/m^2]\n\n    transmittance_absorptance : numeric, default 0.9\n        Coefficient for combined transmittance and absorptance effects.\n        [unitless]\n\n    array_height : int, default 1\n        Height of array above ground in stories (one story is about 3m). Must\n        be either 1 or 2. For systems elevated less than one story, use 1.\n        If system is elevated more than two stories, use 2.\n\n    mount_standoff : numeric, default 4\n        Distance between array mounting and mounting surface. Use default\n        if system is ground-mounted. [inches]\n\n    Returns\n    -------\n    cell_temperature : numeric\n        Cell temperature. [C]\n\n    Raises\n    ------\n    ValueError\n        If array_height is an invalid value (must be 1 or 2).\n\n    References\n    ----------\n    .. [1] Gilman, P., Dobos, A., DiOrio, N., Freeman, J., Janzou, S.,\n           Ryberg, D., 2018, \"SAM Photovoltaic Model Technical Reference\n           Update\", National Renewable Energy Laboratory Report\n           NREL/TP-6A20-67399.\n    '''\n    # in [1] the denominator for irr_ratio isn't precisely clear. From\n    # reproducing output of the SAM function noct_celltemp_t, we determined\n    # that:\n    #  - G_total (SAM) is broadband plane-of-array irradiance before\n    #    reflections. Equivalent to pvlib variable poa_global\n    #  - Geff_total (SAM) is POA irradiance after reflections and\n    #    adjustment for spectrum. Equivalent to effective_irradiance\n    if effective_irradiance is None:\n        irr_ratio = 1.\n    else:\n        irr_ratio = effective_irradiance / poa_global\n\n    if array_height == 1:\n        wind_adj = 0.51 * wind_speed\n    elif array_height == 2:\n        wind_adj = 0.61 * wind_speed\n    else:\n        raise ValueError(\n            f'array_height must be 1 or 2, {array_height} was given')\n\n    noct_adj = noct + _adj_for_mounting_standoff(mount_standoff)\n    tau_alpha = transmittance_absorptance * irr_ratio\n\n    # [1] Eq. 10.37 isn't clear on exactly what \"G\" is. SAM SSC code uses\n    # poa_global where G appears\n    cell_temp_init = poa_global / 800. * (noct_adj - 20.)\n    heat_loss = 1 - module_efficiency / tau_alpha\n    wind_loss = 9.5 / (5.7 + 3.8 * wind_adj)\n    return temp_air + cell_temp_init * heat_loss * wind_loss\n", "tokens": ["pvlib", "temperature", "py", "def", "noct_sam", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "effective_irradiance", "none", "transmittance_absorptance", "0", "9", "array_height", "1", "mount_standoff", "4", "r", "cell", "temperature", "model", "from", "the", "system", "advisor", "model", "sam", "the", "model", "is", "described", "in", "1", "_", "section", "10", "6", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "the", "default", "value", "1", "0", "m", "s", "is", "the", "wind", "speed", "at", "module", "height", "used", "to", "determine", "noct", "m", "s", "noct", "float", "nominal", "operating", "cell", "temperature", "c", "determined", "at", "conditions", "of", "800", "w", "m", "2", "irradiance", "20", "c", "ambient", "air", "temperature", "and", "1", "m", "s", "wind", "module_efficiency", "float", "module", "external", "efficiency", "unitless", "at", "reference", "conditions", "of", "1000", "w", "m", "2", "and", "20c", "denoted", "as", "math", "eta_", "m", "in", "1", "_", "calculate", "as", "math", "eta_", "m", "frac", "v_", "mp", "i_", "mp", "a", "times", "1000", "w", "m", "2", "where", "a", "is", "module", "area", "m", "2", "effective_irradiance", "numeric", "default", "none", "the", "irradiance", "that", "is", "converted", "to", "photocurrent", "if", "none", "assumed", "equal", "to", "poa_global", "w", "m", "2", "transmittance_absorptance", "numeric", "default", "0", "9", "coefficient", "for", "combined", "transmittance", "and", "absorptance", "effects", "unitless", "array_height", "int", "default", "1", "height", "of", "array", "above", "ground", "in", "stories", "one", "story", "is", "about", "3m", "must", "be", "either", "1", "or", "2", "for", "systems", "elevated", "less", "than", "one", "story", "use", "1", "if", "system", "is", "elevated", "more", "than", "two", "stories", "use", "2", "mount_standoff", "numeric", "default", "4", "distance", "between", "array", "mounting", "and", "mounting", "surface", "use", "default", "if", "system", "is", "ground", "mounted", "inches", "returns", "cell_temperature", "numeric", "cell", "temperature", "c", "raises", "valueerror", "if", "array_height", "is", "an", "invalid", "value", "must", "be", "1", "or", "2", "references", "1", "gilman", "p", "dobos", "a", "diorio", "n", "freeman", "j", "janzou", "s", "ryberg", "d", "2018", "sam", "photovoltaic", "model", "technical", "reference", "update", "national", "renewable", "energy", "laboratory", "report", "nrel", "tp", "6a20", "67399", "in", "1", "the", "denominator", "for", "irr_ratio", "isn", "t", "precisely", "clear", "from", "reproducing", "output", "of", "the", "sam", "function", "noct_celltemp_t", "we", "determined", "that", "g_total", "sam", "is", "broadband", "plane", "of", "array", "irradiance", "before", "reflections", "equivalent", "to", "pvlib", "variable", "poa_global", "geff_total", "sam", "is", "poa", "irradiance", "after", "reflections", "and", "adjustment", "for", "spectrum", "equivalent", "to", "effective_irradiance", "if", "effective_irradiance", "is", "none", "irr_ratio", "1", "else", "irr_ratio", "effective_irradiance", "poa_global", "if", "array_height", "1", "wind_adj", "0", "51", "wind_speed", "elif", "array_height", "2", "wind_adj", "0", "61", "wind_speed", "else", "raise", "valueerror", "f", "array_height", "must", "be", "1", "or", "2", "array_height", "was", "given", "noct_adj", "noct", "_adj_for_mounting_standoff", "mount_standoff", "tau_alpha", "transmittance_absorptance", "irr_ratio", "1", "eq", "10", "37", "isn", "t", "clear", "on", "exactly", "what", "g", "is", "sam", "ssc", "code", "uses", "poa_global", "where", "g", "appears", "cell_temp_init", "poa_global", "800", "noct_adj", "20", "heat_loss", "1", "module_efficiency", "tau_alpha", "wind_loss", "9", "5", "5", "7", "3", "8", "wind_adj", "return", "temp_air", "cell_temp_init", "heat_loss", "wind_loss"], "doc_len": 446}
{"doc_id": "pvlib/temperature.py::prilliman", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "prilliman", "text": "文件路径: pvlib/temperature.py\ndef prilliman(temp_cell, wind_speed, unit_mass=11.1, coefficients=None):\n    \"\"\"\n    Smooth short-term cell temperature transients using the Prilliman model.\n\n    The Prilliman et al. model [1]_ applies a weighted moving average to\n    the output of a steady-state cell temperature model to account for\n    a module's thermal inertia by smoothing the cell temperature's\n    response to changing weather conditions.\n\n    .. warning::\n        This implementation requires the time series inputs to be regularly\n        sampled in time with frequency less than 20 minutes.  Data with\n        irregular time steps (including from data gaps, missing leap days,\n        etc) should be resampled prior to using this function.\n\n    Parameters\n    ----------\n    temp_cell : pandas.Series with DatetimeIndex\n        Cell temperature modeled with steady-state assumptions. [C]\n\n    wind_speed : pandas.Series\n        Wind speed, adjusted to correspond to array height [m/s]\n\n    unit_mass : float, default 11.1\n        Total mass of module divided by its one-sided surface area [kg/m^2]\n\n    coefficients : 4-element list-like, optional\n        Values for coefficients a_0 through a_3, see Eq. 9 of [1]_\n\n    Returns\n    -------\n    temp_cell : pandas.Series\n        Smoothed version of the input cell temperature. Input temperature\n        with sampling interval >= 20 minutes is returned unchanged. [C]\n\n    Notes\n    -----\n    This smoothing model was developed and validated using the SAPM\n    cell temperature model for the steady-state input.\n\n    Smoothing is done using the 20 minute window behind each temperature\n    value. At the beginning of the series where a full 20 minute window is not\n    possible, partial windows are used instead.\n\n    Output ``temp_cell[k]`` is NaN when input ``wind_speed[k]`` is NaN, or\n    when no non-NaN data are in the input temperature for the 20 minute window\n    preceding index ``k``.\n\n    References\n    ----------\n    .. [1] M. Prilliman, J. S. Stein, D. Riley and G. Tamizhmani,\n       \"Transient Weighted Moving-Average Model of Photovoltaic Module\n       Back-Surface Temperature,\" IEEE Journal of Photovoltaics, 2020.\n       :doi:`10.1109/JPHOTOV.2020.2992351`\n    \"\"\"\n\n    # `sample_interval` in minutes:\n    sample_interval, samples_per_window = \\\n        _get_sample_intervals(times=temp_cell.index, win_length=20)\n\n    if sample_interval >= 20:\n        warnings.warn(\"temperature.prilliman only applies smoothing when \"\n                      \"the sampling interval is shorter than 20 minutes \"\n                      f\"(input sampling interval: {sample_interval} minutes);\"\n                      \" returning input temperature series unchanged\")\n        # too coarsely sampled for smoothing to be relevant\n        return temp_cell\n\n    # handle cases where the time series is shorter than 20 minutes total\n    samples_per_window = min(samples_per_window, len(temp_cell))\n\n    # prefix with NaNs so that the rolling window is \"full\",\n    # even for the first actual value:\n    prefix = np.full(samples_per_window, np.nan)\n    temp_cell_prefixed = np.append(prefix, temp_cell.values)\n\n    # generate matrix of integers for creating windows with indexing\n    H = scipy.linalg.hankel(np.arange(samples_per_window),\n                            np.arange(samples_per_window - 1,\n                                      len(temp_cell_prefixed) - 1))\n    # each row of `subsets` is the values in one window\n    subsets = temp_cell_prefixed[H].T\n\n    # `subsets` now looks like this (for 5-minute data, so 4 samples/window)\n    # where \"1.\" is a stand-in for the actual temperature values\n    # [[nan, nan, nan, nan],\n    #  [nan, nan, nan,  1.],\n    #  [nan, nan,  1.,  1.],\n    #  [nan,  1.,  1.,  1.],\n    #  [ 1.,  1.,  1.,  1.],\n    #  [ 1.,  1.,  1.,  1.],\n    #  [ 1.,  1.,  1.,  1.],\n    #  ...\n\n    # calculate weights for the values in each window\n    if coefficients is not None:\n        a = coefficients\n    else:\n        # values from [1], Table II\n        a = [0.0046, 0.00046, -0.00023, -1.6e-5]\n\n    wind_speed = wind_speed.values\n    p = a[0] + a[1]*wind_speed + a[2]*unit_mass + a[3]*wind_speed*unit_mass\n    # calculate the time lag for each sample in the window, paying attention\n    # to units (seconds for `timedeltas`, minutes for `sample_interval`)\n    timedeltas = np.arange(samples_per_window, 0, -1) * sample_interval * 60\n    weights = np.exp(-p[:, np.newaxis] * timedeltas)\n\n    # Set weights corresponding to the prefix values to zero; otherwise the\n    # denominator of the weighted average below would be wrong.\n    # Weights corresponding to (non-prefix) NaN values must be zero too\n    # for the same reason.\n\n    # Right now `weights` is something like this\n    # (using 5-minute inputs, so 4 samples per window -> 4 values per row):\n    # [[0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  ...\n\n    # After the next line, the NaNs in `subsets` will be zeros in `weights`,\n    # like this (with more zeros for any NaNs in the input temperature):\n\n    # [[0.    , 0.    , 0.    , 0.    ],\n    #  [0.    , 0.    , 0.    , 0.4972],\n    #  [0.    , 0.    , 0.2472, 0.4972],\n    #  [0.    , 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  [0.0611, 0.1229, 0.2472, 0.4972],\n    #  ...\n\n    weights[np.isnan(subsets)] = 0\n\n    # change the first row of weights from zero to nan -- this is a\n    # trick to prevent div by zero warning when dividing by summed weights\n    weights[0, :] = np.nan\n\n    # finally, take the weighted average of each window:\n    # use np.nansum for numerator to ignore nans in input temperature, but\n    # np.sum for denominator to propagate nans in input wind speed.\n    numerator = np.nansum(subsets * weights, axis=1)\n    denominator = np.sum(weights, axis=1)\n    smoothed = numerator / denominator\n    smoothed[0] = temp_cell.values[0]\n    smoothed = pd.Series(smoothed, index=temp_cell.index)\n    return smoothed\n", "tokens": ["pvlib", "temperature", "py", "def", "prilliman", "temp_cell", "wind_speed", "unit_mass", "11", "1", "coefficients", "none", "smooth", "short", "term", "cell", "temperature", "transients", "using", "the", "prilliman", "model", "the", "prilliman", "et", "al", "model", "1", "_", "applies", "a", "weighted", "moving", "average", "to", "the", "output", "of", "a", "steady", "state", "cell", "temperature", "model", "to", "account", "for", "a", "module", "s", "thermal", "inertia", "by", "smoothing", "the", "cell", "temperature", "s", "response", "to", "changing", "weather", "conditions", "warning", "this", "implementation", "requires", "the", "time", "series", "inputs", "to", "be", "regularly", "sampled", "in", "time", "with", "frequency", "less", "than", "20", "minutes", "data", "with", "irregular", "time", "steps", "including", "from", "data", "gaps", "missing", "leap", "days", "etc", "should", "be", "resampled", "prior", "to", "using", "this", "function", "parameters", "temp_cell", "pandas", "series", "with", "datetimeindex", "cell", "temperature", "modeled", "with", "steady", "state", "assumptions", "c", "wind_speed", "pandas", "series", "wind", "speed", "adjusted", "to", "correspond", "to", "array", "height", "m", "s", "unit_mass", "float", "default", "11", "1", "total", "mass", "of", "module", "divided", "by", "its", "one", "sided", "surface", "area", "kg", "m", "2", "coefficients", "4", "element", "list", "like", "optional", "values", "for", "coefficients", "a_0", "through", "a_3", "see", "eq", "9", "of", "1", "_", "returns", "temp_cell", "pandas", "series", "smoothed", "version", "of", "the", "input", "cell", "temperature", "input", "temperature", "with", "sampling", "interval", "20", "minutes", "is", "returned", "unchanged", "c", "notes", "this", "smoothing", "model", "was", "developed", "and", "validated", "using", "the", "sapm", "cell", "temperature", "model", "for", "the", "steady", "state", "input", "smoothing", "is", "done", "using", "the", "20", "minute", "window", "behind", "each", "temperature", "value", "at", "the", "beginning", "of", "the", "series", "where", "a", "full", "20", "minute", "window", "is", "not", "possible", "partial", "windows", "are", "used", "instead", "output", "temp_cell", "k", "is", "nan", "when", "input", "wind_speed", "k", "is", "nan", "or", "when", "no", "non", "nan", "data", "are", "in", "the", "input", "temperature", "for", "the", "20", "minute", "window", "preceding", "index", "k", "references", "1", "m", "prilliman", "j", "s", "stein", "d", "riley", "and", "g", "tamizhmani", "transient", "weighted", "moving", "average", "model", "of", "photovoltaic", "module", "back", "surface", "temperature", "ieee", "journal", "of", "photovoltaics", "2020", "doi", "10", "1109", "jphotov", "2020", "2992351", "sample_interval", "in", "minutes", "sample_interval", "samples_per_window", "_get_sample_intervals", "times", "temp_cell", "index", "win_length", "20", "if", "sample_interval", "20", "warnings", "warn", "temperature", "prilliman", "only", "applies", "smoothing", "when", "the", "sampling", "interval", "is", "shorter", "than", "20", "minutes", "f", "input", "sampling", "interval", "sample_interval", "minutes", "returning", "input", "temperature", "series", "unchanged", "too", "coarsely", "sampled", "for", "smoothing", "to", "be", "relevant", "return", "temp_cell", "handle", "cases", "where", "the", "time", "series", "is", "shorter", "than", "20", "minutes", "total", "samples_per_window", "min", "samples_per_window", "len", "temp_cell", "prefix", "with", "nans", "so", "that", "the", "rolling", "window", "is", "full", "even", "for", "the", "first", "actual", "value", "prefix", "np", "full", "samples_per_window", "np", "nan", "temp_cell_prefixed", "np", "append", "prefix", "temp_cell", "values", "generate", "matrix", "of", "integers", "for", "creating", "windows", "with", "indexing", "h", "scipy", "linalg", "hankel", "np", "arange", "samples_per_window", "np", "arange", "samples_per_window", "1", "len", "temp_cell_prefixed", "1", "each", "row", "of", "subsets", "is", "the", "values", "in", "one", "window", "subsets", "temp_cell_prefixed", "h", "t", "subsets", "now", "looks", "like", "this", "for", "5", "minute", "data", "so", "4", "samples", "window", "where", "1", "is", "a", "stand", "in", "for", "the", "actual", "temperature", "values", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "1", "nan", "nan", "1", "1", "nan", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "calculate", "weights", "for", "the", "values", "in", "each", "window", "if", "coefficients", "is", "not", "none", "a", "coefficients", "else", "values", "from", "1", "table", "ii", "a", "0", "0046", "0", "00046", "0", "00023", "1", "6e", "5", "wind_speed", "wind_speed", "values", "p", "a", "0", "a", "1", "wind_speed", "a", "2", "unit_mass", "a", "3", "wind_speed", "unit_mass", "calculate", "the", "time", "lag", "for", "each", "sample", "in", "the", "window", "paying", "attention", "to", "units", "seconds", "for", "timedeltas", "minutes", "for", "sample_interval", "timedeltas", "np", "arange", "samples_per_window", "0", "1", "sample_interval", "60", "weights", "np", "exp", "p", "np", "newaxis", "timedeltas", "set", "weights", "corresponding", "to", "the", "prefix", "values", "to", "zero", "otherwise", "the", "denominator", "of", "the", "weighted", "average", "below", "would", "be", "wrong", "weights", "corresponding", "to", "non", "prefix", "nan", "values", "must", "be", "zero", "too", "for", "the", "same", "reason", "right", "now", "weights", "is", "something", "like", "this", "using", "5", "minute", "inputs", "so", "4", "samples", "per", "window", "4", "values", "per", "row", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "after", "the", "next", "line", "the", "nans", "in", "subsets", "will", "be", "zeros", "in", "weights", "like", "this", "with", "more", "zeros", "for", "any", "nans", "in", "the", "input", "temperature", "0", "0", "0", "0", "0", "0", "0", "0", "4972", "0", "0", "0", "2472", "0", "4972", "0", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "0", "0611", "0", "1229", "0", "2472", "0", "4972", "weights", "np", "isnan", "subsets", "0", "change", "the", "first", "row", "of", "weights", "from", "zero", "to", "nan", "this", "is", "a", "trick", "to", "prevent", "div", "by", "zero", "warning", "when", "dividing", "by", "summed", "weights", "weights", "0", "np", "nan", "finally", "take", "the", "weighted", "average", "of", "each", "window", "use", "np", "nansum", "for", "numerator", "to", "ignore", "nans", "in", "input", "temperature", "but", "np", "sum", "for", "denominator", "to", "propagate", "nans", "in", "input", "wind", "speed", "numerator", "np", "nansum", "subsets", "weights", "axis", "1", "denominator", "np", "sum", "weights", "axis", "1", "smoothed", "numerator", "denominator", "smoothed", "0", "temp_cell", "values", "0", "smoothed", "pd", "series", "smoothed", "index", "temp_cell", "index", "return", "smoothed"], "doc_len": 849}
{"doc_id": "pvlib/temperature.py::generic_linear", "file_path": "pvlib/temperature.py", "class_name": null, "func_name": "generic_linear", "text": "文件路径: pvlib/temperature.py\ndef generic_linear(poa_global, temp_air, wind_speed, u_const, du_wind,\n                   module_efficiency, absorptance):\n    \"\"\"\n    Calculate cell temperature using a generic linear heat loss factor model.\n\n    The parameters for this model can be obtained from other model\n    parameters using :py:class:`GenericLinearModel`.  A description of this\n    model and its relationship to other temperature models is found in [1]_.\n\n    Parameters\n    ----------\n    poa_global : numeric\n        Total incident irradiance [W/m^2].\n\n    temp_air : numeric\n        Ambient dry bulb temperature [C].\n\n    wind_speed : numeric\n        Wind speed at a height of 10 meters [m/s].\n\n    u_const : float\n        Combined heat transfer coefficient at zero wind speed [(W/m^2)/C]\n\n    du_wind : float\n        Influence of wind speed on combined heat transfer coefficient\n        [(W/m^2)/C/(m/s)]\n\n    module_efficiency : float\n        The electrical efficiency of the module. [-]\n\n    absorptance : float\n        The light absorptance of the module. [-]\n\n    Returns\n    -------\n    numeric, values in degrees C.\n\n    References\n    ----------\n    .. [1] A. Driesse et al, \"PV Module Operating Temperature\n       Model Equivalence and Parameter Translation\". 2022 IEEE\n       Photovoltaic Specialists Conference (PVSC), 2022.\n\n    See also\n    --------\n    pvlib.temperature.GenericLinearModel\n    \"\"\"\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs, Sept. 2022\n\n    heat_input = poa_global * (absorptance - module_efficiency)\n    total_loss_factor = u_const + du_wind * wind_speed\n    temp_difference = heat_input / total_loss_factor\n\n    return temp_air + temp_difference\n", "tokens": ["pvlib", "temperature", "py", "def", "generic_linear", "poa_global", "temp_air", "wind_speed", "u_const", "du_wind", "module_efficiency", "absorptance", "calculate", "cell", "temperature", "using", "a", "generic", "linear", "heat", "loss", "factor", "model", "the", "parameters", "for", "this", "model", "can", "be", "obtained", "from", "other", "model", "parameters", "using", "py", "class", "genericlinearmodel", "a", "description", "of", "this", "model", "and", "its", "relationship", "to", "other", "temperature", "models", "is", "found", "in", "1", "_", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "at", "a", "height", "of", "10", "meters", "m", "s", "u_const", "float", "combined", "heat", "transfer", "coefficient", "at", "zero", "wind", "speed", "w", "m", "2", "c", "du_wind", "float", "influence", "of", "wind", "speed", "on", "combined", "heat", "transfer", "coefficient", "w", "m", "2", "c", "m", "s", "module_efficiency", "float", "the", "electrical", "efficiency", "of", "the", "module", "absorptance", "float", "the", "light", "absorptance", "of", "the", "module", "returns", "numeric", "values", "in", "degrees", "c", "references", "1", "a", "driesse", "et", "al", "pv", "module", "operating", "temperature", "model", "equivalence", "and", "parameter", "translation", "2022", "ieee", "photovoltaic", "specialists", "conference", "pvsc", "2022", "see", "also", "pvlib", "temperature", "genericlinearmodel", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "sept", "2022", "heat_input", "poa_global", "absorptance", "module_efficiency", "total_loss_factor", "u_const", "du_wind", "wind_speed", "temp_difference", "heat_input", "total_loss_factor", "return", "temp_air", "temp_difference"], "doc_len": 188}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.__init__", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "__init__", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def __init__(self, module_efficiency, absorptance):\n\n        self.u_const = np.nan\n        self.du_wind = np.nan\n        self.eta = module_efficiency\n        self.alpha = absorptance\n\n        return None\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "__init__", "self", "module_efficiency", "absorptance", "self", "u_const", "np", "nan", "self", "du_wind", "np", "nan", "self", "eta", "module_efficiency", "self", "alpha", "absorptance", "return", "none"], "doc_len": 25}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.__repr__", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "__repr__", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def __repr__(self):\n\n        return self.__class__.__name__ + ': ' + vars(self).__repr__()\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "__repr__", "self", "return", "self", "__class__", "__name__", "vars", "self", "__repr__"], "doc_len": 14}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.__call__", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "__call__", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def __call__(self, poa_global, temp_air, wind_speed,\n                 module_efficiency=None):\n        '''\n        Calculate module temperature using the generic_linear model and\n        previously initialized parameters.\n\n        Parameters\n        ----------\n        poa_global : numeric\n            Total incident irradiance [W/m^2].\n\n        temp_air : numeric\n            Ambient dry bulb temperature [C].\n\n        wind_speed : numeric\n            Wind speed in m/s measured at the same height for which the wind\n            loss factor was determined.  [m/s]\n\n        module_efficiency : numeric, optional\n            Module electrical efficiency.  The default value is the one\n            that was specified initially. [-]\n\n        Returns\n        -------\n        numeric, values in degrees Celsius\n\n        See also\n        --------\n        get_generic\n        pvlib.temperature.generic_linear\n        '''\n        if module_efficiency is None:\n            module_efficiency = self.eta\n\n        return generic_linear(poa_global, temp_air, wind_speed,\n                              self.u_const, self.du_wind,\n                              module_efficiency, self.alpha)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "__call__", "self", "poa_global", "temp_air", "wind_speed", "module_efficiency", "none", "calculate", "module", "temperature", "using", "the", "generic_linear", "model", "and", "previously", "initialized", "parameters", "parameters", "poa_global", "numeric", "total", "incident", "irradiance", "w", "m", "2", "temp_air", "numeric", "ambient", "dry", "bulb", "temperature", "c", "wind_speed", "numeric", "wind", "speed", "in", "m", "s", "measured", "at", "the", "same", "height", "for", "which", "the", "wind", "loss", "factor", "was", "determined", "m", "s", "module_efficiency", "numeric", "optional", "module", "electrical", "efficiency", "the", "default", "value", "is", "the", "one", "that", "was", "specified", "initially", "returns", "numeric", "values", "in", "degrees", "celsius", "see", "also", "get_generic", "pvlib", "temperature", "generic_linear", "if", "module_efficiency", "is", "none", "module_efficiency", "self", "eta", "return", "generic_linear", "poa_global", "temp_air", "wind_speed", "self", "u_const", "self", "du_wind", "module_efficiency", "self", "alpha"], "doc_len": 108}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.get_generic_linear", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "get_generic_linear", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def get_generic_linear(self):\n        '''\n        Get the generic linear model parameters to use with the separate\n        generic linear module temperature calculation function.\n\n        Returns\n        -------\n        model_parameters : dict\n\n        See also\n        --------\n        pvlib.temperature.generic_linear\n        '''\n        return dict(u_const=self.u_const,\n                    du_wind=self.du_wind,\n                    module_efficiency=self.eta,\n                    absorptance=self.alpha)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "get_generic_linear", "self", "get", "the", "generic", "linear", "model", "parameters", "to", "use", "with", "the", "separate", "generic", "linear", "module", "temperature", "calculation", "function", "returns", "model_parameters", "dict", "see", "also", "pvlib", "temperature", "generic_linear", "return", "dict", "u_const", "self", "u_const", "du_wind", "self", "du_wind", "module_efficiency", "self", "eta", "absorptance", "self", "alpha"], "doc_len": 46}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.use_faiman", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "use_faiman", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def use_faiman(self, u0, u1):\n        '''\n        Use the Faiman model parameters to set the generic_model equivalents.\n\n        Parameters\n        ----------\n        u0, u1 : float\n            See :py:func:`pvlib.temperature.faiman` for details.\n        '''\n        net_absorptance = self.alpha - self.eta\n        self.u_const = u0 * net_absorptance\n        self.du_wind = u1 * net_absorptance\n\n        return self\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "use_faiman", "self", "u0", "u1", "use", "the", "faiman", "model", "parameters", "to", "set", "the", "generic_model", "equivalents", "parameters", "u0", "u1", "float", "see", "py", "func", "pvlib", "temperature", "faiman", "for", "details", "net_absorptance", "self", "alpha", "self", "eta", "self", "u_const", "u0", "net_absorptance", "self", "du_wind", "u1", "net_absorptance", "return", "self"], "doc_len": 46}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.to_faiman", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "to_faiman", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def to_faiman(self):\n        '''\n        Convert the generic model parameters to Faiman equivalents.\n\n        Returns\n        ----------\n        model_parameters : dict\n            See :py:func:`pvlib.temperature.faiman` for\n            model parameter details.\n        '''\n        net_absorptance = self.alpha - self.eta\n        u0 = self.u_const / net_absorptance\n        u1 = self.du_wind / net_absorptance\n\n        return dict(u0=u0, u1=u1)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "to_faiman", "self", "convert", "the", "generic", "model", "parameters", "to", "faiman", "equivalents", "returns", "model_parameters", "dict", "see", "py", "func", "pvlib", "temperature", "faiman", "for", "model", "parameter", "details", "net_absorptance", "self", "alpha", "self", "eta", "u0", "self", "u_const", "net_absorptance", "u1", "self", "du_wind", "net_absorptance", "return", "dict", "u0", "u0", "u1", "u1"], "doc_len": 47}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.use_pvsyst", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "use_pvsyst", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def use_pvsyst(self, u_c, u_v, module_efficiency=None,\n                   alpha_absorption=None):\n        '''\n        Use the PVsyst model parameters to set the generic_model equivalents.\n\n        Parameters\n        ----------\n        u_c, u_v : float\n            See :py:func:`pvlib.temperature.pvsyst_cell` for details.\n\n        module_efficiency, alpha_absorption : float, optional\n            See :py:func:`pvlib.temperature.pvsyst_cell` for details.\n\n        Notes\n        -----\n        The optional parameters are primarily for convenient compatibility\n        with existing function signatures.\n        '''\n        if module_efficiency is not None:\n            self.eta = module_efficiency\n\n        if alpha_absorption is not None:\n            self.alpha = alpha_absorption\n\n        net_absorptance_glm = self.alpha - self.eta\n        net_absorptance_pvsyst = self.alpha * (1.0 - self.eta)\n        absorptance_ratio = net_absorptance_glm / net_absorptance_pvsyst\n\n        self.u_const = u_c * absorptance_ratio\n        self.du_wind = u_v * absorptance_ratio\n\n        return self\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "use_pvsyst", "self", "u_c", "u_v", "module_efficiency", "none", "alpha_absorption", "none", "use", "the", "pvsyst", "model", "parameters", "to", "set", "the", "generic_model", "equivalents", "parameters", "u_c", "u_v", "float", "see", "py", "func", "pvlib", "temperature", "pvsyst_cell", "for", "details", "module_efficiency", "alpha_absorption", "float", "optional", "see", "py", "func", "pvlib", "temperature", "pvsyst_cell", "for", "details", "notes", "the", "optional", "parameters", "are", "primarily", "for", "convenient", "compatibility", "with", "existing", "function", "signatures", "if", "module_efficiency", "is", "not", "none", "self", "eta", "module_efficiency", "if", "alpha_absorption", "is", "not", "none", "self", "alpha", "alpha_absorption", "net_absorptance_glm", "self", "alpha", "self", "eta", "net_absorptance_pvsyst", "self", "alpha", "1", "0", "self", "eta", "absorptance_ratio", "net_absorptance_glm", "net_absorptance_pvsyst", "self", "u_const", "u_c", "absorptance_ratio", "self", "du_wind", "u_v", "absorptance_ratio", "return", "self"], "doc_len": 101}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.to_pvsyst", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "to_pvsyst", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def to_pvsyst(self):\n        '''\n        Convert the generic model parameters to PVsyst model equivalents.\n\n        Returns\n        ----------\n        model_parameters : dict\n            See :py:func:`pvlib.temperature.pvsyst_cell` for\n            model parameter details.\n        '''\n        net_absorptance_glm = self.alpha - self.eta\n        net_absorptance_pvsyst = self.alpha * (1.0 - self.eta)\n        absorptance_ratio = net_absorptance_glm / net_absorptance_pvsyst\n\n        u_c = self.u_const / absorptance_ratio\n        u_v = self.du_wind / absorptance_ratio\n\n        return dict(u_c=u_c,\n                    u_v=u_v,\n                    module_efficiency=self.eta,\n                    alpha_absorption=self.alpha)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "to_pvsyst", "self", "convert", "the", "generic", "model", "parameters", "to", "pvsyst", "model", "equivalents", "returns", "model_parameters", "dict", "see", "py", "func", "pvlib", "temperature", "pvsyst_cell", "for", "model", "parameter", "details", "net_absorptance_glm", "self", "alpha", "self", "eta", "net_absorptance_pvsyst", "self", "alpha", "1", "0", "self", "eta", "absorptance_ratio", "net_absorptance_glm", "net_absorptance_pvsyst", "u_c", "self", "u_const", "absorptance_ratio", "u_v", "self", "du_wind", "absorptance_ratio", "return", "dict", "u_c", "u_c", "u_v", "u_v", "module_efficiency", "self", "eta", "alpha_absorption", "self", "alpha"], "doc_len": 64}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.use_noct_sam", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "use_noct_sam", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def use_noct_sam(self, noct, module_efficiency=None,\n                     transmittance_absorptance=None):\n        '''\n        Use the NOCT SAM model parameters to set the generic_model equivalents.\n\n        Parameters\n        ----------\n        noct : float\n            See :py:func:`pvlib.temperature.noct_sam` for details.\n\n        module_efficiency, transmittance_absorptance : float, optional\n            See :py:func:`pvlib.temperature.noct_sam` for details.\n\n        Notes\n        -----\n        The optional parameters are primarily for convenient compatibility\n        with existing function signatures.\n        '''\n        if module_efficiency is not None:\n            self.eta = module_efficiency\n\n        if transmittance_absorptance is not None:\n            self.alpha = transmittance_absorptance\n\n        # NOCT is determined with wind speed near module height\n        # the adjustment reduces the wind coefficient for use with 10m wind\n        wind_adj = 0.51\n        u_noct = 800.0 * self.alpha / (noct - 20.0)\n        self.u_const = u_noct * 0.6\n        self.du_wind = u_noct * 0.4 * wind_adj\n\n        return self\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "use_noct_sam", "self", "noct", "module_efficiency", "none", "transmittance_absorptance", "none", "use", "the", "noct", "sam", "model", "parameters", "to", "set", "the", "generic_model", "equivalents", "parameters", "noct", "float", "see", "py", "func", "pvlib", "temperature", "noct_sam", "for", "details", "module_efficiency", "transmittance_absorptance", "float", "optional", "see", "py", "func", "pvlib", "temperature", "noct_sam", "for", "details", "notes", "the", "optional", "parameters", "are", "primarily", "for", "convenient", "compatibility", "with", "existing", "function", "signatures", "if", "module_efficiency", "is", "not", "none", "self", "eta", "module_efficiency", "if", "transmittance_absorptance", "is", "not", "none", "self", "alpha", "transmittance_absorptance", "noct", "is", "determined", "with", "wind", "speed", "near", "module", "height", "the", "adjustment", "reduces", "the", "wind", "coefficient", "for", "use", "with", "10m", "wind", "wind_adj", "0", "51", "u_noct", "800", "0", "self", "alpha", "noct", "20", "0", "self", "u_const", "u_noct", "0", "6", "self", "du_wind", "u_noct", "0", "4", "wind_adj", "return", "self"], "doc_len": 119}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.to_noct_sam", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "to_noct_sam", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def to_noct_sam(self):\n        '''\n        Convert the generic model parameters to NOCT SAM model equivalents.\n\n        Returns\n        ----------\n        model_parameters : dict\n            See :py:func:`pvlib.temperature.noct_sam` for\n            model parameter details.\n        '''\n        # NOCT is determined with wind speed near module height\n        # the adjustment reduces the wind coefficient for use with 10m wind\n        wind_adj = 0.51\n        u_noct = self.u_const + self.du_wind / wind_adj\n        noct = 20.0 + (800.0 * self.alpha) / u_noct\n\n        return dict(noct=noct,\n                    module_efficiency=self.eta,\n                    transmittance_absorptance=self.alpha)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "to_noct_sam", "self", "convert", "the", "generic", "model", "parameters", "to", "noct", "sam", "model", "equivalents", "returns", "model_parameters", "dict", "see", "py", "func", "pvlib", "temperature", "noct_sam", "for", "model", "parameter", "details", "noct", "is", "determined", "with", "wind", "speed", "near", "module", "height", "the", "adjustment", "reduces", "the", "wind", "coefficient", "for", "use", "with", "10m", "wind", "wind_adj", "0", "51", "u_noct", "self", "u_const", "self", "du_wind", "wind_adj", "noct", "20", "0", "800", "0", "self", "alpha", "u_noct", "return", "dict", "noct", "noct", "module_efficiency", "self", "eta", "transmittance_absorptance", "self", "alpha"], "doc_len": 77}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.use_sapm", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "use_sapm", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def use_sapm(self, a, b, wind_fit_low=1.4, wind_fit_high=5.4):\n        '''\n        Use the SAPM model parameters to set the generic_model equivalents.\n\n        In the SAPM the heat transfer coefficient increases exponentially\n        with windspeed, whereas in the other models the increase is linear.\n        This function equates the generic linear model to SAPM at two\n        specified winds speeds, thereby defining a linear approximation\n        for the exponential behavior.\n\n        Parameters\n        ----------\n        a, b : float\n            See :py:func:`pvlib.temperature.sapm_module` for details.\n\n        wind_fit_low : float, optional\n            First wind speed value at which the generic linear model\n            must be equal to the SAPM model. [m/s]\n\n        wind_fit_high : float, optional\n            Second wind speed value at which the generic linear model\n            must be equal to the SAPM model. [m/s]\n\n        Notes\n        -----\n        The two default wind speed values are based on measurements\n        at 10 m height.  Both the SAPM model and the conversion\n        functions can work with wind speed data at different heights as\n        long as the same height is used consistently throughout.\n        '''\n        u_low = 1.0 / np.exp(a + b * wind_fit_low)\n        u_high = 1.0 / np.exp(a + b * wind_fit_high)\n\n        du_wind = (u_high - u_low) / (wind_fit_high - wind_fit_low)\n        u_const = u_low - du_wind * wind_fit_low\n\n        net_absorptance = self.alpha - self.eta\n        self.u_const = u_const * net_absorptance\n        self.du_wind = du_wind * net_absorptance\n\n        return self\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "use_sapm", "self", "a", "b", "wind_fit_low", "1", "4", "wind_fit_high", "5", "4", "use", "the", "sapm", "model", "parameters", "to", "set", "the", "generic_model", "equivalents", "in", "the", "sapm", "the", "heat", "transfer", "coefficient", "increases", "exponentially", "with", "windspeed", "whereas", "in", "the", "other", "models", "the", "increase", "is", "linear", "this", "function", "equates", "the", "generic", "linear", "model", "to", "sapm", "at", "two", "specified", "winds", "speeds", "thereby", "defining", "a", "linear", "approximation", "for", "the", "exponential", "behavior", "parameters", "a", "b", "float", "see", "py", "func", "pvlib", "temperature", "sapm_module", "for", "details", "wind_fit_low", "float", "optional", "first", "wind", "speed", "value", "at", "which", "the", "generic", "linear", "model", "must", "be", "equal", "to", "the", "sapm", "model", "m", "s", "wind_fit_high", "float", "optional", "second", "wind", "speed", "value", "at", "which", "the", "generic", "linear", "model", "must", "be", "equal", "to", "the", "sapm", "model", "m", "s", "notes", "the", "two", "default", "wind", "speed", "values", "are", "based", "on", "measurements", "at", "10", "m", "height", "both", "the", "sapm", "model", "and", "the", "conversion", "functions", "can", "work", "with", "wind", "speed", "data", "at", "different", "heights", "as", "long", "as", "the", "same", "height", "is", "used", "consistently", "throughout", "u_low", "1", "0", "np", "exp", "a", "b", "wind_fit_low", "u_high", "1", "0", "np", "exp", "a", "b", "wind_fit_high", "du_wind", "u_high", "u_low", "wind_fit_high", "wind_fit_low", "u_const", "u_low", "du_wind", "wind_fit_low", "net_absorptance", "self", "alpha", "self", "eta", "self", "u_const", "u_const", "net_absorptance", "self", "du_wind", "du_wind", "net_absorptance", "return", "self"], "doc_len": 206}
{"doc_id": "pvlib/temperature.py::GenericLinearModel.to_sapm", "file_path": "pvlib/temperature.py", "class_name": "GenericLinearModel", "func_name": "to_sapm", "text": "文件路径: pvlib/temperature.py, 类名: GenericLinearModel\n    def to_sapm(self, wind_fit_low=1.4, wind_fit_high=5.4):\n        '''\n        Convert the generic model parameters to SAPM model equivalents.\n\n        In the SAPM the heat transfer coefficient increases exponentially\n        with windspeed, whereas in the other models the increase is linear.\n        This function equates SAPM to the generic linear model at two\n        specified winds speeds, thereby defining an exponential approximation\n        for the linear behavior.\n\n        Parameters\n        ----------\n        wind_fit_low : float, optional\n            First wind speed value at which the generic linear model\n            must be equal to the SAPM model. [m/s]\n\n        wind_fit_high : float, optional\n            Second wind speed value at which the generic linear model\n            must be equal to the SAPM model. [m/s]\n\n        Returns\n        ----------\n        model_parameters : dict\n            See :py:func:`pvlib.temperature.sapm_module` for\n            model parameter details.\n\n        Notes\n        -----\n        The two default wind speed values are based on measurements\n        at 10 m height.  Both the SAPM model and the conversion\n        functions can work with wind speed data at different heights as\n        long as the same height is used consistently throughout.\n        '''\n        net_absorptance = self.alpha - self.eta\n        u_const = self.u_const / net_absorptance\n        du_wind = self.du_wind / net_absorptance\n\n        u_low = u_const + du_wind * wind_fit_low\n        u_high = u_const + du_wind * wind_fit_high\n\n        b = - ((np.log(u_high) - np.log(u_low)) /\n               (wind_fit_high - wind_fit_low))\n        a = - (np.log(u_low) + b * wind_fit_low)\n\n        return dict(a=a, b=b)\n", "tokens": ["pvlib", "temperature", "py", "genericlinearmodel", "def", "to_sapm", "self", "wind_fit_low", "1", "4", "wind_fit_high", "5", "4", "convert", "the", "generic", "model", "parameters", "to", "sapm", "model", "equivalents", "in", "the", "sapm", "the", "heat", "transfer", "coefficient", "increases", "exponentially", "with", "windspeed", "whereas", "in", "the", "other", "models", "the", "increase", "is", "linear", "this", "function", "equates", "sapm", "to", "the", "generic", "linear", "model", "at", "two", "specified", "winds", "speeds", "thereby", "defining", "an", "exponential", "approximation", "for", "the", "linear", "behavior", "parameters", "wind_fit_low", "float", "optional", "first", "wind", "speed", "value", "at", "which", "the", "generic", "linear", "model", "must", "be", "equal", "to", "the", "sapm", "model", "m", "s", "wind_fit_high", "float", "optional", "second", "wind", "speed", "value", "at", "which", "the", "generic", "linear", "model", "must", "be", "equal", "to", "the", "sapm", "model", "m", "s", "returns", "model_parameters", "dict", "see", "py", "func", "pvlib", "temperature", "sapm_module", "for", "model", "parameter", "details", "notes", "the", "two", "default", "wind", "speed", "values", "are", "based", "on", "measurements", "at", "10", "m", "height", "both", "the", "sapm", "model", "and", "the", "conversion", "functions", "can", "work", "with", "wind", "speed", "data", "at", "different", "heights", "as", "long", "as", "the", "same", "height", "is", "used", "consistently", "throughout", "net_absorptance", "self", "alpha", "self", "eta", "u_const", "self", "u_const", "net_absorptance", "du_wind", "self", "du_wind", "net_absorptance", "u_low", "u_const", "du_wind", "wind_fit_low", "u_high", "u_const", "du_wind", "wind_fit_high", "b", "np", "log", "u_high", "np", "log", "u_low", "wind_fit_high", "wind_fit_low", "a", "np", "log", "u_low", "b", "wind_fit_low", "return", "dict", "a", "a", "b", "b"], "doc_len": 207}
{"doc_id": "pvlib/tools.py::cosd", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "cosd", "text": "文件路径: pvlib/tools.py\ndef cosd(angle):\n    \"\"\"\n    Cosine with angle input in degrees\n\n    Parameters\n    ----------\n    angle : float or array-like\n        Angle in degrees\n\n    Returns\n    -------\n    result : float or array-like\n        Cosine of the angle\n    \"\"\"\n\n    res = np.cos(np.radians(angle))\n    return res\n", "tokens": ["pvlib", "tools", "py", "def", "cosd", "angle", "cosine", "with", "angle", "input", "in", "degrees", "parameters", "angle", "float", "or", "array", "like", "angle", "in", "degrees", "returns", "result", "float", "or", "array", "like", "cosine", "of", "the", "angle", "res", "np", "cos", "np", "radians", "angle", "return", "res"], "doc_len": 39}
{"doc_id": "pvlib/tools.py::sind", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "sind", "text": "文件路径: pvlib/tools.py\ndef sind(angle):\n    \"\"\"\n    Sine with angle input in degrees\n\n    Parameters\n    ----------\n    angle : float\n        Angle in degrees\n\n    Returns\n    -------\n    result : float\n        Sin of the angle\n    \"\"\"\n\n    res = np.sin(np.radians(angle))\n    return res\n", "tokens": ["pvlib", "tools", "py", "def", "sind", "angle", "sine", "with", "angle", "input", "in", "degrees", "parameters", "angle", "float", "angle", "in", "degrees", "returns", "result", "float", "sin", "of", "the", "angle", "res", "np", "sin", "np", "radians", "angle", "return", "res"], "doc_len": 33}
{"doc_id": "pvlib/tools.py::tand", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "tand", "text": "文件路径: pvlib/tools.py\ndef tand(angle):\n    \"\"\"\n    Tan with angle input in degrees\n\n    Parameters\n    ----------\n    angle : float\n        Angle in degrees\n\n    Returns\n    -------\n    result : float\n        Tan of the angle\n    \"\"\"\n\n    res = np.tan(np.radians(angle))\n    return res\n", "tokens": ["pvlib", "tools", "py", "def", "tand", "angle", "tan", "with", "angle", "input", "in", "degrees", "parameters", "angle", "float", "angle", "in", "degrees", "returns", "result", "float", "tan", "of", "the", "angle", "res", "np", "tan", "np", "radians", "angle", "return", "res"], "doc_len": 33}
{"doc_id": "pvlib/tools.py::asind", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "asind", "text": "文件路径: pvlib/tools.py\ndef asind(number):\n    \"\"\"\n    Inverse Sine returning an angle in degrees\n\n    Parameters\n    ----------\n    number : float\n        Input number\n\n    Returns\n    -------\n    result : float\n        arcsin result\n    \"\"\"\n\n    res = np.degrees(np.arcsin(number))\n    return res\n", "tokens": ["pvlib", "tools", "py", "def", "asind", "number", "inverse", "sine", "returning", "an", "angle", "in", "degrees", "parameters", "number", "float", "input", "number", "returns", "result", "float", "arcsin", "result", "res", "np", "degrees", "np", "arcsin", "number", "return", "res"], "doc_len": 31}
{"doc_id": "pvlib/tools.py::acosd", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "acosd", "text": "文件路径: pvlib/tools.py\ndef acosd(number):\n    \"\"\"\n    Inverse Cosine returning an angle in degrees\n\n    Parameters\n    ----------\n    number : float\n        Input number\n\n    Returns\n    -------\n    result : float\n        arccos result\n    \"\"\"\n\n    res = np.degrees(np.arccos(number))\n    return res\n", "tokens": ["pvlib", "tools", "py", "def", "acosd", "number", "inverse", "cosine", "returning", "an", "angle", "in", "degrees", "parameters", "number", "float", "input", "number", "returns", "result", "float", "arccos", "result", "res", "np", "degrees", "np", "arccos", "number", "return", "res"], "doc_len": 31}
{"doc_id": "pvlib/tools.py::localize_to_utc", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "localize_to_utc", "text": "文件路径: pvlib/tools.py\ndef localize_to_utc(time, location):\n    \"\"\"\n    Converts or localizes a time series to UTC.\n\n    Parameters\n    ----------\n    time : datetime.datetime, pandas.DatetimeIndex,\n           or pandas.Series/DataFrame with a DatetimeIndex.\n    location : pvlib.Location object\n\n    Returns\n    -------\n    pandas object localized to UTC.\n    \"\"\"\n    if isinstance(time, dt.datetime):\n        if time.tzinfo is None:\n            time = pytz.timezone(location.tz).localize(time)\n        time_utc = time.astimezone(pytz.utc)\n    else:\n        try:\n            time_utc = time.tz_convert('UTC')\n        except TypeError:\n            time_utc = time.tz_localize(location.tz).tz_convert('UTC')\n\n    return time_utc\n", "tokens": ["pvlib", "tools", "py", "def", "localize_to_utc", "time", "location", "converts", "or", "localizes", "a", "time", "series", "to", "utc", "parameters", "time", "datetime", "datetime", "pandas", "datetimeindex", "or", "pandas", "series", "dataframe", "with", "a", "datetimeindex", "location", "pvlib", "location", "object", "returns", "pandas", "object", "localized", "to", "utc", "if", "isinstance", "time", "dt", "datetime", "if", "time", "tzinfo", "is", "none", "time", "pytz", "timezone", "location", "tz", "localize", "time", "time_utc", "time", "astimezone", "pytz", "utc", "else", "try", "time_utc", "time", "tz_convert", "utc", "except", "typeerror", "time_utc", "time", "tz_localize", "location", "tz", "tz_convert", "utc", "return", "time_utc"], "doc_len": 77}
{"doc_id": "pvlib/tools.py::datetime_to_djd", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "datetime_to_djd", "text": "文件路径: pvlib/tools.py\ndef datetime_to_djd(time):\n    \"\"\"\n    Converts a datetime to the Dublin Julian Day\n\n    Parameters\n    ----------\n    time : datetime.datetime\n        time to convert\n\n    Returns\n    -------\n    float\n        fractional days since 12/31/1899+0000\n    \"\"\"\n\n    if time.tzinfo is None:\n        time_utc = pytz.utc.localize(time)\n    else:\n        time_utc = time.astimezone(pytz.utc)\n\n    djd_start = pytz.utc.localize(dt.datetime(1899, 12, 31, 12))\n    djd = (time_utc - djd_start).total_seconds() * 1.0/(60 * 60 * 24)\n\n    return djd\n", "tokens": ["pvlib", "tools", "py", "def", "datetime_to_djd", "time", "converts", "a", "datetime", "to", "the", "dublin", "julian", "day", "parameters", "time", "datetime", "datetime", "time", "to", "convert", "returns", "float", "fractional", "days", "since", "12", "31", "1899", "0000", "if", "time", "tzinfo", "is", "none", "time_utc", "pytz", "utc", "localize", "time", "else", "time_utc", "time", "astimezone", "pytz", "utc", "djd_start", "pytz", "utc", "localize", "dt", "datetime", "1899", "12", "31", "12", "djd", "time_utc", "djd_start", "total_seconds", "1", "0", "60", "60", "24", "return", "djd"], "doc_len": 67}
{"doc_id": "pvlib/tools.py::djd_to_datetime", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "djd_to_datetime", "text": "文件路径: pvlib/tools.py\ndef djd_to_datetime(djd, tz='UTC'):\n    \"\"\"\n    Converts a Dublin Julian Day float to a datetime.datetime object\n\n    Parameters\n    ----------\n    djd : float\n        fractional days since 12/31/1899+0000\n    tz : str, default 'UTC'\n        timezone to localize the result to\n\n    Returns\n    -------\n    datetime.datetime\n       The resultant datetime localized to tz\n    \"\"\"\n\n    djd_start = pytz.utc.localize(dt.datetime(1899, 12, 31, 12))\n\n    utc_time = djd_start + dt.timedelta(days=djd)\n    return utc_time.astimezone(pytz.timezone(tz))\n", "tokens": ["pvlib", "tools", "py", "def", "djd_to_datetime", "djd", "tz", "utc", "converts", "a", "dublin", "julian", "day", "float", "to", "a", "datetime", "datetime", "object", "parameters", "djd", "float", "fractional", "days", "since", "12", "31", "1899", "0000", "tz", "str", "default", "utc", "timezone", "to", "localize", "the", "result", "to", "returns", "datetime", "datetime", "the", "resultant", "datetime", "localized", "to", "tz", "djd_start", "pytz", "utc", "localize", "dt", "datetime", "1899", "12", "31", "12", "utc_time", "djd_start", "dt", "timedelta", "days", "djd", "return", "utc_time", "astimezone", "pytz", "timezone", "tz"], "doc_len": 70}
{"doc_id": "pvlib/tools.py::_pandas_to_doy", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_pandas_to_doy", "text": "文件路径: pvlib/tools.py\ndef _pandas_to_doy(pd_object):\n    \"\"\"\n    Finds the day of year for a pandas datetime-like object.\n\n    Useful for delayed evaluation of the dayofyear attribute.\n\n    Parameters\n    ----------\n    pd_object : DatetimeIndex or Timestamp\n\n    Returns\n    -------\n    dayofyear\n    \"\"\"\n    return pd_object.dayofyear\n", "tokens": ["pvlib", "tools", "py", "def", "_pandas_to_doy", "pd_object", "finds", "the", "day", "of", "year", "for", "a", "pandas", "datetime", "like", "object", "useful", "for", "delayed", "evaluation", "of", "the", "dayofyear", "attribute", "parameters", "pd_object", "datetimeindex", "or", "timestamp", "returns", "dayofyear", "return", "pd_object", "dayofyear"], "doc_len": 35}
{"doc_id": "pvlib/tools.py::_doy_to_datetimeindex", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_doy_to_datetimeindex", "text": "文件路径: pvlib/tools.py\ndef _doy_to_datetimeindex(doy, epoch_year=2014):\n    \"\"\"\n    Convert a day of year scalar or array to a pd.DatetimeIndex.\n\n    Parameters\n    ----------\n    doy : numeric\n        Contains days of the year\n\n    Returns\n    -------\n    pd.DatetimeIndex\n    \"\"\"\n    doy = np.atleast_1d(doy).astype('float')\n    epoch = pd.Timestamp('{}-12-31'.format(epoch_year - 1))\n    timestamps = [epoch + dt.timedelta(days=adoy) for adoy in doy]\n    return pd.DatetimeIndex(timestamps)\n", "tokens": ["pvlib", "tools", "py", "def", "_doy_to_datetimeindex", "doy", "epoch_year", "2014", "convert", "a", "day", "of", "year", "scalar", "or", "array", "to", "a", "pd", "datetimeindex", "parameters", "doy", "numeric", "contains", "days", "of", "the", "year", "returns", "pd", "datetimeindex", "doy", "np", "atleast_1d", "doy", "astype", "float", "epoch", "pd", "timestamp", "12", "31", "format", "epoch_year", "1", "timestamps", "epoch", "dt", "timedelta", "days", "adoy", "for", "adoy", "in", "doy", "return", "pd", "datetimeindex", "timestamps"], "doc_len": 59}
{"doc_id": "pvlib/tools.py::_datetimelike_scalar_to_doy", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_datetimelike_scalar_to_doy", "text": "文件路径: pvlib/tools.py\ndef _datetimelike_scalar_to_doy(time):\n    return pd.DatetimeIndex([pd.Timestamp(time)]).dayofyear\n", "tokens": ["pvlib", "tools", "py", "def", "_datetimelike_scalar_to_doy", "time", "return", "pd", "datetimeindex", "pd", "timestamp", "time", "dayofyear"], "doc_len": 13}
{"doc_id": "pvlib/tools.py::_datetimelike_scalar_to_datetimeindex", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_datetimelike_scalar_to_datetimeindex", "text": "文件路径: pvlib/tools.py\ndef _datetimelike_scalar_to_datetimeindex(time):\n    return pd.DatetimeIndex([pd.Timestamp(time)])\n", "tokens": ["pvlib", "tools", "py", "def", "_datetimelike_scalar_to_datetimeindex", "time", "return", "pd", "datetimeindex", "pd", "timestamp", "time"], "doc_len": 12}
{"doc_id": "pvlib/tools.py::_scalar_out", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_scalar_out", "text": "文件路径: pvlib/tools.py\ndef _scalar_out(arg):\n    if np.isscalar(arg):\n        output = arg\n    else:  #\n        # works if it's a 1 length array and\n        # will throw a ValueError otherwise\n        output = np.asarray(arg).item()\n\n    return output\n", "tokens": ["pvlib", "tools", "py", "def", "_scalar_out", "arg", "if", "np", "isscalar", "arg", "output", "arg", "else", "works", "if", "it", "s", "a", "1", "length", "array", "and", "will", "throw", "a", "valueerror", "otherwise", "output", "np", "asarray", "arg", "item", "return", "output"], "doc_len": 34}
{"doc_id": "pvlib/tools.py::_array_out", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_array_out", "text": "文件路径: pvlib/tools.py\ndef _array_out(arg):\n    if isinstance(arg, pd.Series):\n        output = arg.values\n    else:\n        output = arg\n\n    return output\n", "tokens": ["pvlib", "tools", "py", "def", "_array_out", "arg", "if", "isinstance", "arg", "pd", "series", "output", "arg", "values", "else", "output", "arg", "return", "output"], "doc_len": 19}
{"doc_id": "pvlib/tools.py::_build_kwargs", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_build_kwargs", "text": "文件路径: pvlib/tools.py\ndef _build_kwargs(keys, input_dict):\n    \"\"\"\n    Parameters\n    ----------\n    keys : iterable\n        Typically a list of strings.\n    input_dict : dict-like\n        A dictionary from which to attempt to pull each key.\n\n    Returns\n    -------\n    kwargs : dict\n        A dictionary with only the keys that were in input_dict\n    \"\"\"\n\n    kwargs = {}\n    for key in keys:\n        try:\n            kwargs[key] = input_dict[key]\n        except KeyError:\n            pass\n\n    return kwargs\n", "tokens": ["pvlib", "tools", "py", "def", "_build_kwargs", "keys", "input_dict", "parameters", "keys", "iterable", "typically", "a", "list", "of", "strings", "input_dict", "dict", "like", "a", "dictionary", "from", "which", "to", "attempt", "to", "pull", "each", "key", "returns", "kwargs", "dict", "a", "dictionary", "with", "only", "the", "keys", "that", "were", "in", "input_dict", "kwargs", "for", "key", "in", "keys", "try", "kwargs", "key", "input_dict", "key", "except", "keyerror", "pass", "return", "kwargs"], "doc_len": 56}
{"doc_id": "pvlib/tools.py::_build_args", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_build_args", "text": "文件路径: pvlib/tools.py\ndef _build_args(keys, input_dict, dict_name):\n    \"\"\"\n    Parameters\n    ----------\n    keys : iterable\n        Typically a list of strings.\n    input_dict : dict-like\n        A dictionary from which to pull each key.\n    dict_name : str\n        A variable name to include in an error message for missing keys\n\n    Returns\n    -------\n    kwargs : list\n        A list with values corresponding to keys\n    \"\"\"\n    try:\n        args = [input_dict[key] for key in keys]\n    except KeyError as e:\n        missing_key = e.args[0]\n        msg = (f\"Missing required parameter '{missing_key}'. Found \"\n               f\"{input_dict} in {dict_name}.\")\n        raise KeyError(msg)\n    return args\n", "tokens": ["pvlib", "tools", "py", "def", "_build_args", "keys", "input_dict", "dict_name", "parameters", "keys", "iterable", "typically", "a", "list", "of", "strings", "input_dict", "dict", "like", "a", "dictionary", "from", "which", "to", "pull", "each", "key", "dict_name", "str", "a", "variable", "name", "to", "include", "in", "an", "error", "message", "for", "missing", "keys", "returns", "kwargs", "list", "a", "list", "with", "values", "corresponding", "to", "keys", "try", "args", "input_dict", "key", "for", "key", "in", "keys", "except", "keyerror", "as", "e", "missing_key", "e", "args", "0", "msg", "f", "missing", "required", "parameter", "missing_key", "found", "f", "input_dict", "in", "dict_name", "raise", "keyerror", "msg", "return", "args"], "doc_len": 83}
{"doc_id": "pvlib/tools.py::_golden_sect_DataFrame", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_golden_sect_DataFrame", "text": "文件路径: pvlib/tools.py\ndef _golden_sect_DataFrame(params, lower, upper, func, atol=1e-8):\n    \"\"\"\n    Vectorized golden section search for finding maximum of a function of a\n    single variable.\n\n    Parameters\n    ----------\n    params : dict of numeric\n        Parameters to be passed to `func`. Each entry must be of the same\n        length.\n\n    lower: numeric\n        Lower bound for the optimization. Must be the same length as each\n        entry of params.\n\n    upper: numeric\n        Upper bound for the optimization. Must be the same length as each\n        entry of params.\n\n    func: function\n        Function to be optimized. Must be in the form\n        result = f(dict or DataFrame, str), where result is a dict or DataFrame\n        that also contains the function output, and str is the key\n        corresponding to the function's input variable.\n\n    Returns\n    -------\n    numeric\n        function evaluated at the optimal points\n\n    numeric\n        optimal points\n\n    Notes\n    -----\n    This function will find the points where the function is maximized.\n    Returns nan where lower or upper is nan, or where func evaluates to nan.\n\n    See also\n    --------\n    pvlib.singlediode._pwr_optfcn\n    \"\"\"\n\n    phim1 = (np.sqrt(5) - 1) / 2\n\n    df = params\n    df['VH'] = upper\n    df['VL'] = lower\n\n    converged = False\n    iterations = 0\n\n    # handle all NaN case gracefully\n    with warnings.catch_warnings():\n        warnings.filterwarnings(action='ignore',\n                                message='All-NaN slice encountered')\n        iterlimit = 1 + np.nanmax(\n            np.trunc(np.log(atol / (df['VH'] - df['VL'])) / np.log(phim1)))\n\n    while not converged and (iterations <= iterlimit):\n\n        phi = phim1 * (df['VH'] - df['VL'])\n        df['V1'] = df['VL'] + phi\n        df['V2'] = df['VH'] - phi\n\n        df['f1'] = func(df, 'V1')\n        df['f2'] = func(df, 'V2')\n        df['SW_Flag'] = df['f1'] > df['f2']\n\n        df['VL'] = df['V2']*df['SW_Flag'] + df['VL']*(~df['SW_Flag'])\n        df['VH'] = df['V1']*~df['SW_Flag'] + df['VH']*(df['SW_Flag'])\n\n        err = abs(df['V2'] - df['V1'])\n\n        # works with single value because err is np.float64\n        converged = (err[~np.isnan(err)] < atol).all()\n        # err will be less than atol before iterations hit the limit\n        # but just to be safe\n        iterations += 1\n\n    if iterations > iterlimit:\n        raise Exception(\"Iterations exceeded maximum. Check that func\",\n                        \" is not NaN in (lower, upper)\")  # pragma: no cover\n\n    try:\n        func_result = func(df, 'V1')\n        x = np.where(np.isnan(func_result), np.nan, df['V1'])\n    except KeyError:\n        func_result = np.full_like(upper, np.nan)\n        x = func_result.copy()\n\n    return func_result, x\n", "tokens": ["pvlib", "tools", "py", "def", "_golden_sect_dataframe", "params", "lower", "upper", "func", "atol", "1e", "8", "vectorized", "golden", "section", "search", "for", "finding", "maximum", "of", "a", "function", "of", "a", "single", "variable", "parameters", "params", "dict", "of", "numeric", "parameters", "to", "be", "passed", "to", "func", "each", "entry", "must", "be", "of", "the", "same", "length", "lower", "numeric", "lower", "bound", "for", "the", "optimization", "must", "be", "the", "same", "length", "as", "each", "entry", "of", "params", "upper", "numeric", "upper", "bound", "for", "the", "optimization", "must", "be", "the", "same", "length", "as", "each", "entry", "of", "params", "func", "function", "function", "to", "be", "optimized", "must", "be", "in", "the", "form", "result", "f", "dict", "or", "dataframe", "str", "where", "result", "is", "a", "dict", "or", "dataframe", "that", "also", "contains", "the", "function", "output", "and", "str", "is", "the", "key", "corresponding", "to", "the", "function", "s", "input", "variable", "returns", "numeric", "function", "evaluated", "at", "the", "optimal", "points", "numeric", "optimal", "points", "notes", "this", "function", "will", "find", "the", "points", "where", "the", "function", "is", "maximized", "returns", "nan", "where", "lower", "or", "upper", "is", "nan", "or", "where", "func", "evaluates", "to", "nan", "see", "also", "pvlib", "singlediode", "_pwr_optfcn", "phim1", "np", "sqrt", "5", "1", "2", "df", "params", "df", "vh", "upper", "df", "vl", "lower", "converged", "false", "iterations", "0", "handle", "all", "nan", "case", "gracefully", "with", "warnings", "catch_warnings", "warnings", "filterwarnings", "action", "ignore", "message", "all", "nan", "slice", "encountered", "iterlimit", "1", "np", "nanmax", "np", "trunc", "np", "log", "atol", "df", "vh", "df", "vl", "np", "log", "phim1", "while", "not", "converged", "and", "iterations", "iterlimit", "phi", "phim1", "df", "vh", "df", "vl", "df", "v1", "df", "vl", "phi", "df", "v2", "df", "vh", "phi", "df", "f1", "func", "df", "v1", "df", "f2", "func", "df", "v2", "df", "sw_flag", "df", "f1", "df", "f2", "df", "vl", "df", "v2", "df", "sw_flag", "df", "vl", "df", "sw_flag", "df", "vh", "df", "v1", "df", "sw_flag", "df", "vh", "df", "sw_flag", "err", "abs", "df", "v2", "df", "v1", "works", "with", "single", "value", "because", "err", "is", "np", "float64", "converged", "err", "np", "isnan", "err", "atol", "all", "err", "will", "be", "less", "than", "atol", "before", "iterations", "hit", "the", "limit", "but", "just", "to", "be", "safe", "iterations", "1", "if", "iterations", "iterlimit", "raise", "exception", "iterations", "exceeded", "maximum", "check", "that", "func", "is", "not", "nan", "in", "lower", "upper", "pragma", "no", "cover", "try", "func_result", "func", "df", "v1", "x", "np", "where", "np", "isnan", "func_result", "np", "nan", "df", "v1", "except", "keyerror", "func_result", "np", "full_like", "upper", "np", "nan", "x", "func_result", "copy", "return", "func_result", "x"], "doc_len": 361}
{"doc_id": "pvlib/tools.py::_get_sample_intervals", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_get_sample_intervals", "text": "文件路径: pvlib/tools.py\ndef _get_sample_intervals(times, win_length):\n    \"\"\" Calculates time interval and samples per window for Reno-style clear\n    sky detection functions\n    \"\"\"\n    deltas = np.diff(times.values) / np.timedelta64(1, '60s')\n\n    # determine if we can proceed\n    if times.inferred_freq and len(np.unique(deltas)) == 1:\n        sample_interval = times[1] - times[0]\n        sample_interval = sample_interval.seconds / 60  # in minutes\n        samples_per_window = int(win_length / sample_interval)\n        return sample_interval, samples_per_window\n    else:\n        message = (\n            'algorithm does not yet support unequal time intervals. consider '\n            'resampling your data and checking for gaps from missing '\n            'periods, leap days, etc.'\n        )\n        raise NotImplementedError(message)\n", "tokens": ["pvlib", "tools", "py", "def", "_get_sample_intervals", "times", "win_length", "calculates", "time", "interval", "and", "samples", "per", "window", "for", "reno", "style", "clear", "sky", "detection", "functions", "deltas", "np", "diff", "times", "values", "np", "timedelta64", "1", "60s", "determine", "if", "we", "can", "proceed", "if", "times", "inferred_freq", "and", "len", "np", "unique", "deltas", "1", "sample_interval", "times", "1", "times", "0", "sample_interval", "sample_interval", "seconds", "60", "in", "minutes", "samples_per_window", "int", "win_length", "sample_interval", "return", "sample_interval", "samples_per_window", "else", "message", "algorithm", "does", "not", "yet", "support", "unequal", "time", "intervals", "consider", "resampling", "your", "data", "and", "checking", "for", "gaps", "from", "missing", "periods", "leap", "days", "etc", "raise", "notimplementederror", "message"], "doc_len": 89}
{"doc_id": "pvlib/tools.py::_degrees_to_index", "file_path": "pvlib/tools.py", "class_name": null, "func_name": "_degrees_to_index", "text": "文件路径: pvlib/tools.py\ndef _degrees_to_index(degrees, coordinate):\n    \"\"\"Transform input degrees to an output index integer.\n    Specify a degree value and either 'latitude' or 'longitude' to get\n    the appropriate index number for these two index numbers.\n    Parameters\n    ----------\n    degrees : float or int\n        Degrees of either latitude or longitude.\n    coordinate : string\n        Specify whether degrees arg is latitude or longitude. Must be set to\n        either 'latitude' or 'longitude' or an error will be raised.\n    Returns\n    -------\n    index : np.int16\n        The latitude or longitude index number to use when looking up values\n        in the Linke turbidity lookup table.\n    \"\"\"\n    # Assign inputmin, inputmax, and outputmax based on degree type.\n    if coordinate == 'latitude':\n        inputmin = 90\n        inputmax = -90\n        outputmax = 2160\n    elif coordinate == 'longitude':\n        inputmin = -180\n        inputmax = 180\n        outputmax = 4320\n    else:\n        raise IndexError(\"coordinate must be 'latitude' or 'longitude'.\")\n\n    inputrange = inputmax - inputmin\n    scale = outputmax/inputrange  # number of indices per degree\n    center = inputmin + 1 / scale / 2  # shift to center of index\n    outputmax -= 1  # shift index to zero indexing\n    index = (degrees - center) * scale\n    err = IndexError('Input, %g, is out of range (%g, %g).' %\n                     (degrees, inputmin, inputmax))\n\n    # If the index is still out of bounds after rounding, raise an error.\n    # 0.500001 is used in comparisons instead of 0.5 to allow for a small\n    # margin of error which can occur when dealing with floating point numbers.\n    if index > outputmax:\n        if index - outputmax <= 0.500001:\n            index = outputmax\n        else:\n            raise err\n    elif index < 0:\n        if -index <= 0.500001:\n            index = 0\n        else:\n            raise err\n    # If the index wasn't set to outputmax or 0, round it and cast it as an\n    # integer so it can be used in integer-based indexing.\n    else:\n        index = int(np.around(index))\n\n    return index\n", "tokens": ["pvlib", "tools", "py", "def", "_degrees_to_index", "degrees", "coordinate", "transform", "input", "degrees", "to", "an", "output", "index", "integer", "specify", "a", "degree", "value", "and", "either", "latitude", "or", "longitude", "to", "get", "the", "appropriate", "index", "number", "for", "these", "two", "index", "numbers", "parameters", "degrees", "float", "or", "int", "degrees", "of", "either", "latitude", "or", "longitude", "coordinate", "string", "specify", "whether", "degrees", "arg", "is", "latitude", "or", "longitude", "must", "be", "set", "to", "either", "latitude", "or", "longitude", "or", "an", "error", "will", "be", "raised", "returns", "index", "np", "int16", "the", "latitude", "or", "longitude", "index", "number", "to", "use", "when", "looking", "up", "values", "in", "the", "linke", "turbidity", "lookup", "table", "assign", "inputmin", "inputmax", "and", "outputmax", "based", "on", "degree", "type", "if", "coordinate", "latitude", "inputmin", "90", "inputmax", "90", "outputmax", "2160", "elif", "coordinate", "longitude", "inputmin", "180", "inputmax", "180", "outputmax", "4320", "else", "raise", "indexerror", "coordinate", "must", "be", "latitude", "or", "longitude", "inputrange", "inputmax", "inputmin", "scale", "outputmax", "inputrange", "number", "of", "indices", "per", "degree", "center", "inputmin", "1", "scale", "2", "shift", "to", "center", "of", "index", "outputmax", "1", "shift", "index", "to", "zero", "indexing", "index", "degrees", "center", "scale", "err", "indexerror", "input", "g", "is", "out", "of", "range", "g", "g", "degrees", "inputmin", "inputmax", "if", "the", "index", "is", "still", "out", "of", "bounds", "after", "rounding", "raise", "an", "error", "0", "500001", "is", "used", "in", "comparisons", "instead", "of", "0", "5", "to", "allow", "for", "a", "small", "margin", "of", "error", "which", "can", "occur", "when", "dealing", "with", "floating", "point", "numbers", "if", "index", "outputmax", "if", "index", "outputmax", "0", "500001", "index", "outputmax", "else", "raise", "err", "elif", "index", "0", "if", "index", "0", "500001", "index", "0", "else", "raise", "err", "if", "the", "index", "wasn", "t", "set", "to", "outputmax", "or", "0", "round", "it", "and", "cast", "it", "as", "an", "integer", "so", "it", "can", "be", "used", "in", "integer", "based", "indexing", "else", "index", "int", "np", "around", "index", "return", "index"], "doc_len": 273}
{"doc_id": "pvlib/tracking.py::SingleAxisTracker.__init__", "file_path": "pvlib/tracking.py", "class_name": "SingleAxisTracker", "func_name": "__init__", "text": "文件路径: pvlib/tracking.py, 类名: SingleAxisTracker\n    def __init__(self, axis_tilt=0, axis_azimuth=0, max_angle=90,\n                 backtrack=True, gcr=2.0/7.0, cross_axis_tilt=0.0, **kwargs):\n\n        mount_kwargs = {\n            k: kwargs.pop(k) for k in ['racking_model', 'module_height']\n            if k in kwargs\n        }\n        mount = SingleAxisTrackerMount(axis_tilt, axis_azimuth, max_angle,\n                                       backtrack, gcr, cross_axis_tilt,\n                                       **mount_kwargs)\n\n        array_defaults = {\n            'albedo': None, 'surface_type': None, 'module': None,\n            'module_type': None, 'module_parameters': None,\n            'temperature_model_parameters': None,\n            'modules_per_string': 1,\n        }\n        array_kwargs = {\n            key: kwargs.get(key, array_defaults[key]) for key in array_defaults\n        }\n        # strings/strings_per_inverter is a special case\n        array_kwargs['strings'] = kwargs.get('strings_per_inverter', 1)\n\n        array = Array(mount=mount, **array_kwargs)\n        pass_through_kwargs = {  # other args to pass to PVSystem()\n            k: v for k, v in kwargs.items() if k not in array_defaults\n        }\n        # leave these in case someone is using them\n        self.axis_tilt = axis_tilt\n        self.axis_azimuth = axis_azimuth\n        self.max_angle = max_angle\n        self.backtrack = backtrack\n        self.gcr = gcr\n        self.cross_axis_tilt = cross_axis_tilt\n\n        pass_through_kwargs['surface_tilt'] = None\n        pass_through_kwargs['surface_azimuth'] = None\n\n        super().__init__(arrays=[array], **pass_through_kwargs)\n", "tokens": ["pvlib", "tracking", "py", "singleaxistracker", "def", "__init__", "self", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "cross_axis_tilt", "0", "0", "kwargs", "mount_kwargs", "k", "kwargs", "pop", "k", "for", "k", "in", "racking_model", "module_height", "if", "k", "in", "kwargs", "mount", "singleaxistrackermount", "axis_tilt", "axis_azimuth", "max_angle", "backtrack", "gcr", "cross_axis_tilt", "mount_kwargs", "array_defaults", "albedo", "none", "surface_type", "none", "module", "none", "module_type", "none", "module_parameters", "none", "temperature_model_parameters", "none", "modules_per_string", "1", "array_kwargs", "key", "kwargs", "get", "key", "array_defaults", "key", "for", "key", "in", "array_defaults", "strings", "strings_per_inverter", "is", "a", "special", "case", "array_kwargs", "strings", "kwargs", "get", "strings_per_inverter", "1", "array", "array", "mount", "mount", "array_kwargs", "pass_through_kwargs", "other", "args", "to", "pass", "to", "pvsystem", "k", "v", "for", "k", "v", "in", "kwargs", "items", "if", "k", "not", "in", "array_defaults", "leave", "these", "in", "case", "someone", "is", "using", "them", "self", "axis_tilt", "axis_tilt", "self", "axis_azimuth", "axis_azimuth", "self", "max_angle", "max_angle", "self", "backtrack", "backtrack", "self", "gcr", "gcr", "self", "cross_axis_tilt", "cross_axis_tilt", "pass_through_kwargs", "surface_tilt", "none", "pass_through_kwargs", "surface_azimuth", "none", "super", "__init__", "arrays", "array", "pass_through_kwargs"], "doc_len": 147}
{"doc_id": "pvlib/tracking.py::SingleAxisTracker.__repr__", "file_path": "pvlib/tracking.py", "class_name": "SingleAxisTracker", "func_name": "__repr__", "text": "文件路径: pvlib/tracking.py, 类名: SingleAxisTracker\n    def __repr__(self):\n        attrs = ['axis_tilt', 'axis_azimuth', 'max_angle', 'backtrack', 'gcr',\n                 'cross_axis_tilt']\n        sat_repr = ('SingleAxisTracker:\\n  ' + '\\n  '.join(\n            f'{attr}: {getattr(self, attr)}' for attr in attrs))\n        # get the parent PVSystem info\n        pvsystem_repr = super().__repr__()\n        # remove the first line (contains 'PVSystem: \\n')\n        pvsystem_repr = '\\n'.join(pvsystem_repr.split('\\n')[1:])\n        return sat_repr + '\\n' + pvsystem_repr\n", "tokens": ["pvlib", "tracking", "py", "singleaxistracker", "def", "__repr__", "self", "attrs", "axis_tilt", "axis_azimuth", "max_angle", "backtrack", "gcr", "cross_axis_tilt", "sat_repr", "singleaxistracker", "n", "n", "join", "f", "attr", "getattr", "self", "attr", "for", "attr", "in", "attrs", "get", "the", "parent", "pvsystem", "info", "pvsystem_repr", "super", "__repr__", "remove", "the", "first", "line", "contains", "pvsystem", "n", "pvsystem_repr", "n", "join", "pvsystem_repr", "split", "n", "1", "return", "sat_repr", "n", "pvsystem_repr"], "doc_len": 54}
{"doc_id": "pvlib/tracking.py::SingleAxisTracker.singleaxis", "file_path": "pvlib/tracking.py", "class_name": "SingleAxisTracker", "func_name": "singleaxis", "text": "文件路径: pvlib/tracking.py, 类名: SingleAxisTracker\n    def singleaxis(self, apparent_zenith, apparent_azimuth):\n        \"\"\"\n        Get tracking data. See :py:func:`pvlib.tracking.singleaxis` more\n        detail.\n\n        Parameters\n        ----------\n        apparent_zenith : float, 1d array, or Series\n            Solar apparent zenith angles in decimal degrees.\n\n        apparent_azimuth : float, 1d array, or Series\n            Solar apparent azimuth angles in decimal degrees.\n\n        Returns\n        -------\n        tracking data\n        \"\"\"\n        tracking_data = singleaxis(apparent_zenith, apparent_azimuth,\n                                   self.axis_tilt, self.axis_azimuth,\n                                   self.max_angle, self.backtrack,\n                                   self.gcr, self.cross_axis_tilt)\n\n        return tracking_data\n", "tokens": ["pvlib", "tracking", "py", "singleaxistracker", "def", "singleaxis", "self", "apparent_zenith", "apparent_azimuth", "get", "tracking", "data", "see", "py", "func", "pvlib", "tracking", "singleaxis", "more", "detail", "parameters", "apparent_zenith", "float", "1d", "array", "or", "series", "solar", "apparent", "zenith", "angles", "in", "decimal", "degrees", "apparent_azimuth", "float", "1d", "array", "or", "series", "solar", "apparent", "azimuth", "angles", "in", "decimal", "degrees", "returns", "tracking", "data", "tracking_data", "singleaxis", "apparent_zenith", "apparent_azimuth", "self", "axis_tilt", "self", "axis_azimuth", "self", "max_angle", "self", "backtrack", "self", "gcr", "self", "cross_axis_tilt", "return", "tracking_data"], "doc_len": 68}
{"doc_id": "pvlib/tracking.py::SingleAxisTracker.get_aoi", "file_path": "pvlib/tracking.py", "class_name": "SingleAxisTracker", "func_name": "get_aoi", "text": "文件路径: pvlib/tracking.py, 类名: SingleAxisTracker\n    def get_aoi(self, surface_tilt, surface_azimuth, solar_zenith,\n                solar_azimuth):\n        \"\"\"Get the angle of incidence on the system.\n\n        For a given set of solar zenith and azimuth angles, the\n        surface tilt and azimuth parameters are typically determined\n        by :py:meth:`~SingleAxisTracker.singleaxis`. The\n        :py:meth:`~SingleAxisTracker.singleaxis` method also returns\n        the angle of incidence, so this method is only needed\n        if using a different tracking algorithm.\n\n        Parameters\n        ----------\n        surface_tilt : numeric\n            Panel tilt from horizontal.\n        surface_azimuth : numeric\n            Panel azimuth from north\n        solar_zenith : float or Series.\n            Solar zenith angle.\n        solar_azimuth : float or Series.\n            Solar azimuth angle.\n\n        Returns\n        -------\n        aoi : Series\n            The angle of incidence in degrees from normal.\n        \"\"\"\n\n        aoi = irradiance.aoi(surface_tilt, surface_azimuth,\n                             solar_zenith, solar_azimuth)\n        return aoi\n", "tokens": ["pvlib", "tracking", "py", "singleaxistracker", "def", "get_aoi", "self", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "get", "the", "angle", "of", "incidence", "on", "the", "system", "for", "a", "given", "set", "of", "solar", "zenith", "and", "azimuth", "angles", "the", "surface", "tilt", "and", "azimuth", "parameters", "are", "typically", "determined", "by", "py", "meth", "singleaxistracker", "singleaxis", "the", "py", "meth", "singleaxistracker", "singleaxis", "method", "also", "returns", "the", "angle", "of", "incidence", "so", "this", "method", "is", "only", "needed", "if", "using", "a", "different", "tracking", "algorithm", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "float", "or", "series", "solar", "zenith", "angle", "solar_azimuth", "float", "or", "series", "solar", "azimuth", "angle", "returns", "aoi", "series", "the", "angle", "of", "incidence", "in", "degrees", "from", "normal", "aoi", "irradiance", "aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "return", "aoi"], "doc_len": 114}
{"doc_id": "pvlib/tracking.py::SingleAxisTracker.get_irradiance", "file_path": "pvlib/tracking.py", "class_name": "SingleAxisTracker", "func_name": "get_irradiance", "text": "文件路径: pvlib/tracking.py, 类名: SingleAxisTracker\n    def get_irradiance(self, surface_tilt, surface_azimuth,\n                       solar_zenith, solar_azimuth, dni, ghi, dhi,\n                       albedo=None, dni_extra=None, airmass=None,\n                       model='haydavies',\n                       **kwargs):\n        \"\"\"\n        Uses the :func:`irradiance.get_total_irradiance` function to\n        calculate the plane of array irradiance components on a tilted\n        surface defined by the input data and ``self.albedo``.\n\n        For a given set of solar zenith and azimuth angles, the\n        surface tilt and azimuth parameters are typically determined\n        by :py:meth:`~SingleAxisTracker.singleaxis`.\n\n        Parameters\n        ----------\n        surface_tilt : numeric\n            Panel tilt from horizontal.\n        surface_azimuth : numeric\n            Panel azimuth from north\n        solar_zenith : numeric\n            Solar zenith angle.\n        solar_azimuth : numeric\n            Solar azimuth angle.\n        dni : float or Series\n            Direct Normal Irradiance\n        ghi : float or Series\n            Global horizontal irradiance\n        dhi : float or Series\n            Diffuse horizontal irradiance\n        albedo : None, float or Series, default None\n            Ground surface albedo. [unitless]\n        dni_extra : float or Series, default None\n            Extraterrestrial direct normal irradiance\n        airmass : float or Series, default None\n            Airmass\n        model : String, default 'haydavies'\n            Irradiance model.\n\n        **kwargs\n            Passed to :func:`irradiance.get_total_irradiance`.\n\n        Returns\n        -------\n        poa_irradiance : DataFrame\n            Column names are: ``total, beam, sky, ground``.\n        \"\"\"\n\n        # not needed for all models, but this is easier\n        if dni_extra is None:\n            dni_extra = irradiance.get_extra_radiation(solar_zenith.index)\n\n        if airmass is None:\n            airmass = atmosphere.get_relative_airmass(solar_zenith)\n\n        # SingleAxisTracker only supports a single Array, but we need the\n        # validate/iterate machinery so that single length tuple input/output\n        # is handled the same as PVSystem.get_irradiance. GH 1159\n        dni = self._validate_per_array(dni, system_wide=True)\n        ghi = self._validate_per_array(ghi, system_wide=True)\n        dhi = self._validate_per_array(dhi, system_wide=True)\n\n        if albedo is None:\n            # assign default albedo here because SingleAxisTracker\n            # initializes albedo to None\n            albedo = 0.25\n\n        albedo = self._validate_per_array(albedo, system_wide=True)\n\n        return tuple(\n            irradiance.get_total_irradiance(\n                surface_tilt,\n                surface_azimuth,\n                solar_zenith,\n                solar_azimuth,\n                dni, ghi, dhi,\n                dni_extra=dni_extra,\n                airmass=airmass,\n                model=model,\n                albedo=albedo,\n                **kwargs)\n            for array, dni, ghi, dhi, albedo in zip(\n                self.arrays, dni, ghi, dhi, albedo\n            )\n        )\n", "tokens": ["pvlib", "tracking", "py", "singleaxistracker", "def", "get_irradiance", "self", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "albedo", "none", "dni_extra", "none", "airmass", "none", "model", "haydavies", "kwargs", "uses", "the", "func", "irradiance", "get_total_irradiance", "function", "to", "calculate", "the", "plane", "of", "array", "irradiance", "components", "on", "a", "tilted", "surface", "defined", "by", "the", "input", "data", "and", "self", "albedo", "for", "a", "given", "set", "of", "solar", "zenith", "and", "azimuth", "angles", "the", "surface", "tilt", "and", "azimuth", "parameters", "are", "typically", "determined", "by", "py", "meth", "singleaxistracker", "singleaxis", "parameters", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "surface_azimuth", "numeric", "panel", "azimuth", "from", "north", "solar_zenith", "numeric", "solar", "zenith", "angle", "solar_azimuth", "numeric", "solar", "azimuth", "angle", "dni", "float", "or", "series", "direct", "normal", "irradiance", "ghi", "float", "or", "series", "global", "horizontal", "irradiance", "dhi", "float", "or", "series", "diffuse", "horizontal", "irradiance", "albedo", "none", "float", "or", "series", "default", "none", "ground", "surface", "albedo", "unitless", "dni_extra", "float", "or", "series", "default", "none", "extraterrestrial", "direct", "normal", "irradiance", "airmass", "float", "or", "series", "default", "none", "airmass", "model", "string", "default", "haydavies", "irradiance", "model", "kwargs", "passed", "to", "func", "irradiance", "get_total_irradiance", "returns", "poa_irradiance", "dataframe", "column", "names", "are", "total", "beam", "sky", "ground", "not", "needed", "for", "all", "models", "but", "this", "is", "easier", "if", "dni_extra", "is", "none", "dni_extra", "irradiance", "get_extra_radiation", "solar_zenith", "index", "if", "airmass", "is", "none", "airmass", "atmosphere", "get_relative_airmass", "solar_zenith", "singleaxistracker", "only", "supports", "a", "single", "array", "but", "we", "need", "the", "validate", "iterate", "machinery", "so", "that", "single", "length", "tuple", "input", "output", "is", "handled", "the", "same", "as", "pvsystem", "get_irradiance", "gh", "1159", "dni", "self", "_validate_per_array", "dni", "system_wide", "true", "ghi", "self", "_validate_per_array", "ghi", "system_wide", "true", "dhi", "self", "_validate_per_array", "dhi", "system_wide", "true", "if", "albedo", "is", "none", "assign", "default", "albedo", "here", "because", "singleaxistracker", "initializes", "albedo", "to", "none", "albedo", "0", "25", "albedo", "self", "_validate_per_array", "albedo", "system_wide", "true", "return", "tuple", "irradiance", "get_total_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "ghi", "dhi", "dni_extra", "dni_extra", "airmass", "airmass", "model", "model", "albedo", "albedo", "kwargs", "for", "array", "dni", "ghi", "dhi", "albedo", "in", "zip", "self", "arrays", "dni", "ghi", "dhi", "albedo"], "doc_len": 297}
{"doc_id": "pvlib/tracking.py::singleaxis", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "singleaxis", "text": "文件路径: pvlib/tracking.py\ndef singleaxis(apparent_zenith, apparent_azimuth,\n               axis_tilt=0, axis_azimuth=0, max_angle=90,\n               backtrack=True, gcr=2.0/7.0, cross_axis_tilt=0):\n    \"\"\"\n    Determine the rotation angle of a single-axis tracker when given particular\n    solar zenith and azimuth angles.\n\n    See [1]_ for details about the equations. Backtracking may be specified,\n    and if so, a ground coverage ratio is required.\n\n    Rotation angle is determined in a right-handed coordinate system. The\n    tracker `axis_azimuth` defines the positive y-axis, the positive x-axis is\n    90 degrees clockwise from the y-axis and parallel to the Earth's surface,\n    and the positive z-axis is normal to both x & y-axes and oriented skyward.\n    Rotation angle `tracker_theta` is a right-handed rotation around the y-axis\n    in the x, y, z coordinate system and indicates tracker position relative to\n    horizontal. For example, if tracker `axis_azimuth` is 180 (oriented south)\n    and `axis_tilt` is zero, then a `tracker_theta` of zero is horizontal, a\n    `tracker_theta` of 30 degrees is a rotation of 30 degrees towards the west,\n    and a `tracker_theta` of -90 degrees is a rotation to the vertical plane\n    facing east.\n\n    Parameters\n    ----------\n    apparent_zenith : float, 1d array, or Series\n        Solar apparent zenith angles in decimal degrees.\n\n    apparent_azimuth : float, 1d array, or Series\n        Solar apparent azimuth angles in decimal degrees.\n\n    axis_tilt : float, default 0\n        The tilt of the axis of rotation (i.e, the y-axis defined by\n        ``axis_azimuth``) with respect to horizontal.\n        ``axis_tilt`` must be >= 0 and <= 90. [degree]\n\n    axis_azimuth : float, default 0\n        A value denoting the compass direction along which the axis of\n        rotation lies. Measured in decimal degrees east of north.\n\n    max_angle : float, default 90\n        A value denoting the maximum rotation angle, in decimal degrees,\n        of the one-axis tracker from its horizontal position (horizontal\n        if axis_tilt = 0). A max_angle of 90 degrees allows the tracker\n        to rotate to a vertical position to point the panel towards a\n        horizon. max_angle of 180 degrees allows for full rotation.\n\n    backtrack : bool, default True\n        Controls whether the tracker has the capability to \"backtrack\"\n        to avoid row-to-row shading. False denotes no backtrack\n        capability. True denotes backtrack capability.\n\n    gcr : float, default 2.0/7.0\n        A value denoting the ground coverage ratio of a tracker system\n        which utilizes backtracking; i.e. the ratio between the PV array\n        surface area to total ground area. A tracker system with modules\n        2 meters wide, centered on the tracking axis, with 6 meters\n        between the tracking axes has a gcr of 2/6=0.333. If gcr is not\n        provided, a gcr of 2/7 is default. gcr must be <=1.\n\n    cross_axis_tilt : float, default 0.0\n        The angle, relative to horizontal, of the line formed by the\n        intersection between the slope containing the tracker axes and a plane\n        perpendicular to the tracker axes. Cross-axis tilt should be specified\n        using a right-handed convention. For example, trackers with axis\n        azimuth of 180 degrees (heading south) will have a negative cross-axis\n        tilt if the tracker axes plane slopes down to the east and positive\n        cross-axis tilt if the tracker axes plane slopes down to the west. Use\n        :func:`~pvlib.tracking.calc_cross_axis_tilt` to calculate\n        `cross_axis_tilt`. [degrees]\n\n    Returns\n    -------\n    dict or DataFrame with the following columns:\n        * `tracker_theta`: The rotation angle of the tracker is a right-handed\n          rotation defined by `axis_azimuth`.\n          tracker_theta = 0 is horizontal. [degrees]\n        * `aoi`: The angle-of-incidence of direct irradiance onto the\n          rotated panel surface. [degrees]\n        * `surface_tilt`: The angle between the panel surface and the earth\n          surface, accounting for panel rotation. [degrees]\n        * `surface_azimuth`: The azimuth of the rotated panel, determined by\n          projecting the vector normal to the panel's surface to the earth's\n          surface. [degrees]\n\n    See also\n    --------\n    pvlib.tracking.calc_axis_tilt\n    pvlib.tracking.calc_cross_axis_tilt\n    pvlib.tracking.calc_surface_orientation\n\n    References\n    ----------\n    .. [1] Kevin Anderson and Mark Mikofski, \"Slope-Aware Backtracking for\n       Single-Axis Trackers\", Technical Report NREL/TP-5K00-76626, July 2020.\n       https://www.nrel.gov/docs/fy20osti/76626.pdf\n    \"\"\"\n\n    # MATLAB to Python conversion by\n    # Will Holmgren (@wholmgren), U. Arizona. March, 2015.\n\n    if isinstance(apparent_zenith, pd.Series):\n        index = apparent_zenith.index\n    else:\n        index = None\n\n    # convert scalars to arrays\n    apparent_azimuth = np.atleast_1d(apparent_azimuth)\n    apparent_zenith = np.atleast_1d(apparent_zenith)\n\n    if apparent_azimuth.ndim > 1 or apparent_zenith.ndim > 1:\n        raise ValueError('Input dimensions must not exceed 1')\n\n    # Calculate sun position x, y, z using coordinate system as in [1], Eq 1.\n\n    # NOTE: solar elevation = 90 - solar zenith, then use trig identities:\n    # sin(90-x) = cos(x) & cos(90-x) = sin(x)\n    sin_zenith = sind(apparent_zenith)\n    x = sin_zenith * sind(apparent_azimuth)\n    y = sin_zenith * cosd(apparent_azimuth)\n    z = cosd(apparent_zenith)\n\n    # Assume the tracker reference frame is right-handed. Positive y-axis is\n    # oriented along tracking axis; from north, the y-axis is rotated clockwise\n    # by the axis azimuth and tilted from horizontal by the axis tilt. The\n    # positive x-axis is 90 deg clockwise from the y-axis and parallel to\n    # horizontal (e.g., if the y-axis is south, the x-axis is west); the\n    # positive z-axis is normal to the x and y axes, pointed upward.\n\n    # Calculate sun position (xp, yp, zp) in tracker coordinate system using\n    # [1] Eq 4.\n\n    cos_axis_azimuth = cosd(axis_azimuth)\n    sin_axis_azimuth = sind(axis_azimuth)\n    cos_axis_tilt = cosd(axis_tilt)\n    sin_axis_tilt = sind(axis_tilt)\n    xp = x*cos_axis_azimuth - y*sin_axis_azimuth\n    # not necessary to calculate y'\n    # yp = (x*cos_axis_tilt*sin_axis_azimuth\n    #       + y*cos_axis_tilt*cos_axis_azimuth\n    #       - z*sin_axis_tilt)\n    zp = (x*sin_axis_tilt*sin_axis_azimuth\n          + y*sin_axis_tilt*cos_axis_azimuth\n          + z*cos_axis_tilt)\n\n    # The ideal tracking angle wid is the rotation to place the sun position\n    # vector (xp, yp, zp) in the (y, z) plane, which is normal to the panel and\n    # contains the axis of rotation.  wid = 0 indicates that the panel is\n    # horizontal. Here, our convention is that a clockwise rotation is\n    # positive, to view rotation angles in the same frame of reference as\n    # azimuth. For example, for a system with tracking axis oriented south, a\n    # rotation toward the east is negative, and a rotation to the west is\n    # positive. This is a right-handed rotation around the tracker y-axis.\n\n    # Calculate angle from x-y plane to projection of sun vector onto x-z plane\n    # using [1] Eq. 5.\n\n    wid = np.degrees(np.arctan2(xp, zp))\n\n    # filter for sun above panel horizon\n    zen_gt_90 = apparent_zenith > 90\n    wid[zen_gt_90] = np.nan\n\n    # Account for backtracking\n    if backtrack:\n        # distance between rows in terms of rack lengths relative to cross-axis\n        # tilt\n        axes_distance = 1/(gcr * cosd(cross_axis_tilt))\n\n        # NOTE: account for rare angles below array, see GH 824\n        temp = np.abs(axes_distance * cosd(wid - cross_axis_tilt))\n\n        # backtrack angle using [1], Eq. 14\n        with np.errstate(invalid='ignore'):\n            wc = np.degrees(-np.sign(wid)*np.arccos(temp))\n\n        # NOTE: in the middle of the day, arccos(temp) is out of range because\n        # there's no row-to-row shade to avoid, & backtracking is unnecessary\n        # [1], Eqs. 15-16\n        with np.errstate(invalid='ignore'):\n            tracker_theta = wid + np.where(temp < 1, wc, 0)\n    else:\n        tracker_theta = wid\n\n    # NOTE: max_angle defined relative to zero-point rotation, not the\n    # system-plane normal\n    tracker_theta = np.clip(tracker_theta, -max_angle, max_angle)\n\n    # Calculate auxiliary angles\n    surface = calc_surface_orientation(tracker_theta, axis_tilt, axis_azimuth)\n    surface_tilt = surface['surface_tilt']\n    surface_azimuth = surface['surface_azimuth']\n    aoi = irradiance.aoi(surface_tilt, surface_azimuth,\n                         apparent_zenith, apparent_azimuth)\n\n    # Bundle DataFrame for return values and filter for sun below horizon.\n    out = {'tracker_theta': tracker_theta, 'aoi': aoi,\n           'surface_azimuth': surface_azimuth, 'surface_tilt': surface_tilt}\n    if index is not None:\n        out = pd.DataFrame(out, index=index)\n        out[zen_gt_90] = np.nan\n    else:\n        out = {k: np.where(zen_gt_90, np.nan, v) for k, v in out.items()}\n\n    return out\n", "tokens": ["pvlib", "tracking", "py", "def", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "cross_axis_tilt", "0", "determine", "the", "rotation", "angle", "of", "a", "single", "axis", "tracker", "when", "given", "particular", "solar", "zenith", "and", "azimuth", "angles", "see", "1", "_", "for", "details", "about", "the", "equations", "backtracking", "may", "be", "specified", "and", "if", "so", "a", "ground", "coverage", "ratio", "is", "required", "rotation", "angle", "is", "determined", "in", "a", "right", "handed", "coordinate", "system", "the", "tracker", "axis_azimuth", "defines", "the", "positive", "y", "axis", "the", "positive", "x", "axis", "is", "90", "degrees", "clockwise", "from", "the", "y", "axis", "and", "parallel", "to", "the", "earth", "s", "surface", "and", "the", "positive", "z", "axis", "is", "normal", "to", "both", "x", "y", "axes", "and", "oriented", "skyward", "rotation", "angle", "tracker_theta", "is", "a", "right", "handed", "rotation", "around", "the", "y", "axis", "in", "the", "x", "y", "z", "coordinate", "system", "and", "indicates", "tracker", "position", "relative", "to", "horizontal", "for", "example", "if", "tracker", "axis_azimuth", "is", "180", "oriented", "south", "and", "axis_tilt", "is", "zero", "then", "a", "tracker_theta", "of", "zero", "is", "horizontal", "a", "tracker_theta", "of", "30", "degrees", "is", "a", "rotation", "of", "30", "degrees", "towards", "the", "west", "and", "a", "tracker_theta", "of", "90", "degrees", "is", "a", "rotation", "to", "the", "vertical", "plane", "facing", "east", "parameters", "apparent_zenith", "float", "1d", "array", "or", "series", "solar", "apparent", "zenith", "angles", "in", "decimal", "degrees", "apparent_azimuth", "float", "1d", "array", "or", "series", "solar", "apparent", "azimuth", "angles", "in", "decimal", "degrees", "axis_tilt", "float", "default", "0", "the", "tilt", "of", "the", "axis", "of", "rotation", "i", "e", "the", "y", "axis", "defined", "by", "axis_azimuth", "with", "respect", "to", "horizontal", "axis_tilt", "must", "be", "0", "and", "90", "degree", "axis_azimuth", "float", "default", "0", "a", "value", "denoting", "the", "compass", "direction", "along", "which", "the", "axis", "of", "rotation", "lies", "measured", "in", "decimal", "degrees", "east", "of", "north", "max_angle", "float", "default", "90", "a", "value", "denoting", "the", "maximum", "rotation", "angle", "in", "decimal", "degrees", "of", "the", "one", "axis", "tracker", "from", "its", "horizontal", "position", "horizontal", "if", "axis_tilt", "0", "a", "max_angle", "of", "90", "degrees", "allows", "the", "tracker", "to", "rotate", "to", "a", "vertical", "position", "to", "point", "the", "panel", "towards", "a", "horizon", "max_angle", "of", "180", "degrees", "allows", "for", "full", "rotation", "backtrack", "bool", "default", "true", "controls", "whether", "the", "tracker", "has", "the", "capability", "to", "backtrack", "to", "avoid", "row", "to", "row", "shading", "false", "denotes", "no", "backtrack", "capability", "true", "denotes", "backtrack", "capability", "gcr", "float", "default", "2", "0", "7", "0", "a", "value", "denoting", "the", "ground", "coverage", "ratio", "of", "a", "tracker", "system", "which", "utilizes", "backtracking", "i", "e", "the", "ratio", "between", "the", "pv", "array", "surface", "area", "to", "total", "ground", "area", "a", "tracker", "system", "with", "modules", "2", "meters", "wide", "centered", "on", "the", "tracking", "axis", "with", "6", "meters", "between", "the", "tracking", "axes", "has", "a", "gcr", "of", "2", "6", "0", "333", "if", "gcr", "is", "not", "provided", "a", "gcr", "of", "2", "7", "is", "default", "gcr", "must", "be", "1", "cross_axis_tilt", "float", "default", "0", "0", "the", "angle", "relative", "to", "horizontal", "of", "the", "line", "formed", "by", "the", "intersection", "between", "the", "slope", "containing", "the", "tracker", "axes", "and", "a", "plane", "perpendicular", "to", "the", "tracker", "axes", "cross", "axis", "tilt", "should", "be", "specified", "using", "a", "right", "handed", "convention", "for", "example", "trackers", "with", "axis", "azimuth", "of", "180", "degrees", "heading", "south", "will", "have", "a", "negative", "cross", "axis", "tilt", "if", "the", "tracker", "axes", "plane", "slopes", "down", "to", "the", "east", "and", "positive", "cross", "axis", "tilt", "if", "the", "tracker", "axes", "plane", "slopes", "down", "to", "the", "west", "use", "func", "pvlib", "tracking", "calc_cross_axis_tilt", "to", "calculate", "cross_axis_tilt", "degrees", "returns", "dict", "or", "dataframe", "with", "the", "following", "columns", "tracker_theta", "the", "rotation", "angle", "of", "the", "tracker", "is", "a", "right", "handed", "rotation", "defined", "by", "axis_azimuth", "tracker_theta", "0", "is", "horizontal", "degrees", "aoi", "the", "angle", "of", "incidence", "of", "direct", "irradiance", "onto", "the", "rotated", "panel", "surface", "degrees", "surface_tilt", "the", "angle", "between", "the", "panel", "surface", "and", "the", "earth", "surface", "accounting", "for", "panel", "rotation", "degrees", "surface_azimuth", "the", "azimuth", "of", "the", "rotated", "panel", "determined", "by", "projecting", "the", "vector", "normal", "to", "the", "panel", "s", "surface", "to", "the", "earth", "s", "surface", "degrees", "see", "also", "pvlib", "tracking", "calc_axis_tilt", "pvlib", "tracking", "calc_cross_axis_tilt", "pvlib", "tracking", "calc_surface_orientation", "references", "1", "kevin", "anderson", "and", "mark", "mikofski", "slope", "aware", "backtracking", "for", "single", "axis", "trackers", "technical", "report", "nrel", "tp", "5k00", "76626", "july", "2020", "https", "www", "nrel", "gov", "docs", "fy20osti", "76626", "pdf", "matlab", "to", "python", "conversion", "by", "will", "holmgren", "wholmgren", "u", "arizona", "march", "2015", "if", "isinstance", "apparent_zenith", "pd", "series", "index", "apparent_zenith", "index", "else", "index", "none", "convert", "scalars", "to", "arrays", "apparent_azimuth", "np", "atleast_1d", "apparent_azimuth", "apparent_zenith", "np", "atleast_1d", "apparent_zenith", "if", "apparent_azimuth", "ndim", "1", "or", "apparent_zenith", "ndim", "1", "raise", "valueerror", "input", "dimensions", "must", "not", "exceed", "1", "calculate", "sun", "position", "x", "y", "z", "using", "coordinate", "system", "as", "in", "1", "eq", "1", "note", "solar", "elevation", "90", "solar", "zenith", "then", "use", "trig", "identities", "sin", "90", "x", "cos", "x", "cos", "90", "x", "sin", "x", "sin_zenith", "sind", "apparent_zenith", "x", "sin_zenith", "sind", "apparent_azimuth", "y", "sin_zenith", "cosd", "apparent_azimuth", "z", "cosd", "apparent_zenith", "assume", "the", "tracker", "reference", "frame", "is", "right", "handed", "positive", "y", "axis", "is", "oriented", "along", "tracking", "axis", "from", "north", "the", "y", "axis", "is", "rotated", "clockwise", "by", "the", "axis", "azimuth", "and", "tilted", "from", "horizontal", "by", "the", "axis", "tilt", "the", "positive", "x", "axis", "is", "90", "deg", "clockwise", "from", "the", "y", "axis", "and", "parallel", "to", "horizontal", "e", "g", "if", "the", "y", "axis", "is", "south", "the", "x", "axis", "is", "west", "the", "positive", "z", "axis", "is", "normal", "to", "the", "x", "and", "y", "axes", "pointed", "upward", "calculate", "sun", "position", "xp", "yp", "zp", "in", "tracker", "coordinate", "system", "using", "1", "eq", "4", "cos_axis_azimuth", "cosd", "axis_azimuth", "sin_axis_azimuth", "sind", "axis_azimuth", "cos_axis_tilt", "cosd", "axis_tilt", "sin_axis_tilt", "sind", "axis_tilt", "xp", "x", "cos_axis_azimuth", "y", "sin_axis_azimuth", "not", "necessary", "to", "calculate", "y", "yp", "x", "cos_axis_tilt", "sin_axis_azimuth", "y", "cos_axis_tilt", "cos_axis_azimuth", "z", "sin_axis_tilt", "zp", "x", "sin_axis_tilt", "sin_axis_azimuth", "y", "sin_axis_tilt", "cos_axis_azimuth", "z", "cos_axis_tilt", "the", "ideal", "tracking", "angle", "wid", "is", "the", "rotation", "to", "place", "the", "sun", "position", "vector", "xp", "yp", "zp", "in", "the", "y", "z", "plane", "which", "is", "normal", "to", "the", "panel", "and", "contains", "the", "axis", "of", "rotation", "wid", "0", "indicates", "that", "the", "panel", "is", "horizontal", "here", "our", "convention", "is", "that", "a", "clockwise", "rotation", "is", "positive", "to", "view", "rotation", "angles", "in", "the", "same", "frame", "of", "reference", "as", "azimuth", "for", "example", "for", "a", "system", "with", "tracking", "axis", "oriented", "south", "a", "rotation", "toward", "the", "east", "is", "negative", "and", "a", "rotation", "to", "the", "west", "is", "positive", "this", "is", "a", "right", "handed", "rotation", "around", "the", "tracker", "y", "axis", "calculate", "angle", "from", "x", "y", "plane", "to", "projection", "of", "sun", "vector", "onto", "x", "z", "plane", "using", "1", "eq", "5", "wid", "np", "degrees", "np", "arctan2", "xp", "zp", "filter", "for", "sun", "above", "panel", "horizon", "zen_gt_90", "apparent_zenith", "90", "wid", "zen_gt_90", "np", "nan", "account", "for", "backtracking", "if", "backtrack", "distance", "between", "rows", "in", "terms", "of", "rack", "lengths", "relative", "to", "cross", "axis", "tilt", "axes_distance", "1", "gcr", "cosd", "cross_axis_tilt", "note", "account", "for", "rare", "angles", "below", "array", "see", "gh", "824", "temp", "np", "abs", "axes_distance", "cosd", "wid", "cross_axis_tilt", "backtrack", "angle", "using", "1", "eq", "14", "with", "np", "errstate", "invalid", "ignore", "wc", "np", "degrees", "np", "sign", "wid", "np", "arccos", "temp", "note", "in", "the", "middle", "of", "the", "day", "arccos", "temp", "is", "out", "of", "range", "because", "there", "s", "no", "row", "to", "row", "shade", "to", "avoid", "backtracking", "is", "unnecessary", "1", "eqs", "15", "16", "with", "np", "errstate", "invalid", "ignore", "tracker_theta", "wid", "np", "where", "temp", "1", "wc", "0", "else", "tracker_theta", "wid", "note", "max_angle", "defined", "relative", "to", "zero", "point", "rotation", "not", "the", "system", "plane", "normal", "tracker_theta", "np", "clip", "tracker_theta", "max_angle", "max_angle", "calculate", "auxiliary", "angles", "surface", "calc_surface_orientation", "tracker_theta", "axis_tilt", "axis_azimuth", "surface_tilt", "surface", "surface_tilt", "surface_azimuth", "surface", "surface_azimuth", "aoi", "irradiance", "aoi", "surface_tilt", "surface_azimuth", "apparent_zenith", "apparent_azimuth", "bundle", "dataframe", "for", "return", "values", "and", "filter", "for", "sun", "below", "horizon", "out", "tracker_theta", "tracker_theta", "aoi", "aoi", "surface_azimuth", "surface_azimuth", "surface_tilt", "surface_tilt", "if", "index", "is", "not", "none", "out", "pd", "dataframe", "out", "index", "index", "out", "zen_gt_90", "np", "nan", "else", "out", "k", "np", "where", "zen_gt_90", "np", "nan", "v", "for", "k", "v", "in", "out", "items", "return", "out"], "doc_len": 1218}
{"doc_id": "pvlib/tracking.py::calc_surface_orientation", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "calc_surface_orientation", "text": "文件路径: pvlib/tracking.py\ndef calc_surface_orientation(tracker_theta, axis_tilt=0, axis_azimuth=0):\n    \"\"\"\n    Calculate the surface tilt and azimuth angles for a given tracker rotation.\n\n    Parameters\n    ----------\n    tracker_theta : numeric\n        Tracker rotation angle as a right-handed rotation around\n        the axis defined by ``axis_tilt`` and ``axis_azimuth``.  For example,\n        with ``axis_tilt=0`` and ``axis_azimuth=180``, ``tracker_theta > 0``\n        results in ``surface_azimuth`` to the West while ``tracker_theta < 0``\n        results in ``surface_azimuth`` to the East. [degree]\n    axis_tilt : float, default 0\n        The tilt of the axis of rotation with respect to horizontal.\n        ``axis_tilt`` must be >= 0 and <= 90.  [degree]\n    axis_azimuth : float, default 0\n        A value denoting the compass direction along which the axis of\n        rotation lies. Measured east of north. [degree]\n\n    Returns\n    -------\n    dict or DataFrame\n        Contains keys ``'surface_tilt'`` and ``'surface_azimuth'`` representing\n        the module orientation accounting for tracker rotation and axis\n        orientation. [degree]\n\n    References\n    ----------\n    .. [1] William F. Marion and Aron P. Dobos, \"Rotation Angle for the Optimum\n       Tracking of One-Axis Trackers\", Technical Report NREL/TP-6A20-58891,\n       July 2013. :doi:`10.2172/1089596`\n    \"\"\"\n    with np.errstate(invalid='ignore', divide='ignore'):\n        surface_tilt = acosd(cosd(tracker_theta) * cosd(axis_tilt))\n\n        # clip(..., -1, +1) to prevent arcsin(1 + epsilon) issues:\n        azimuth_delta = asind(np.clip(sind(tracker_theta) / sind(surface_tilt),\n                                      a_min=-1, a_max=1))\n        # Combine Eqs 2, 3, and 4:\n        azimuth_delta = np.where(abs(tracker_theta) < 90,\n                                 azimuth_delta,\n                                 -azimuth_delta + np.sign(tracker_theta) * 180)\n        # handle surface_tilt=0 case:\n        azimuth_delta = np.where(sind(surface_tilt) != 0, azimuth_delta, 90)\n        surface_azimuth = (axis_azimuth + azimuth_delta) % 360\n\n    out = {\n        'surface_tilt': surface_tilt,\n        'surface_azimuth': surface_azimuth,\n    }\n    if hasattr(tracker_theta, 'index'):\n        out = pd.DataFrame(out)\n    return out\n", "tokens": ["pvlib", "tracking", "py", "def", "calc_surface_orientation", "tracker_theta", "axis_tilt", "0", "axis_azimuth", "0", "calculate", "the", "surface", "tilt", "and", "azimuth", "angles", "for", "a", "given", "tracker", "rotation", "parameters", "tracker_theta", "numeric", "tracker", "rotation", "angle", "as", "a", "right", "handed", "rotation", "around", "the", "axis", "defined", "by", "axis_tilt", "and", "axis_azimuth", "for", "example", "with", "axis_tilt", "0", "and", "axis_azimuth", "180", "tracker_theta", "0", "results", "in", "surface_azimuth", "to", "the", "west", "while", "tracker_theta", "0", "results", "in", "surface_azimuth", "to", "the", "east", "degree", "axis_tilt", "float", "default", "0", "the", "tilt", "of", "the", "axis", "of", "rotation", "with", "respect", "to", "horizontal", "axis_tilt", "must", "be", "0", "and", "90", "degree", "axis_azimuth", "float", "default", "0", "a", "value", "denoting", "the", "compass", "direction", "along", "which", "the", "axis", "of", "rotation", "lies", "measured", "east", "of", "north", "degree", "returns", "dict", "or", "dataframe", "contains", "keys", "surface_tilt", "and", "surface_azimuth", "representing", "the", "module", "orientation", "accounting", "for", "tracker", "rotation", "and", "axis", "orientation", "degree", "references", "1", "william", "f", "marion", "and", "aron", "p", "dobos", "rotation", "angle", "for", "the", "optimum", "tracking", "of", "one", "axis", "trackers", "technical", "report", "nrel", "tp", "6a20", "58891", "july", "2013", "doi", "10", "2172", "1089596", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "surface_tilt", "acosd", "cosd", "tracker_theta", "cosd", "axis_tilt", "clip", "1", "1", "to", "prevent", "arcsin", "1", "epsilon", "issues", "azimuth_delta", "asind", "np", "clip", "sind", "tracker_theta", "sind", "surface_tilt", "a_min", "1", "a_max", "1", "combine", "eqs", "2", "3", "and", "4", "azimuth_delta", "np", "where", "abs", "tracker_theta", "90", "azimuth_delta", "azimuth_delta", "np", "sign", "tracker_theta", "180", "handle", "surface_tilt", "0", "case", "azimuth_delta", "np", "where", "sind", "surface_tilt", "0", "azimuth_delta", "90", "surface_azimuth", "axis_azimuth", "azimuth_delta", "360", "out", "surface_tilt", "surface_tilt", "surface_azimuth", "surface_azimuth", "if", "hasattr", "tracker_theta", "index", "out", "pd", "dataframe", "out", "return", "out"], "doc_len": 246}
{"doc_id": "pvlib/tracking.py::calc_axis_tilt", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "calc_axis_tilt", "text": "文件路径: pvlib/tracking.py\ndef calc_axis_tilt(slope_azimuth, slope_tilt, axis_azimuth):\n    \"\"\"\n    Calculate tracker axis tilt in the global reference frame when on a sloped\n    plane. Axis tilt is the inclination of the tracker rotation axis with\n    respect to horizontal, ranging from 0 degrees (horizontal axis) to 90\n    degrees (vertical axis).\n\n    Parameters\n    ----------\n    slope_azimuth : float\n        direction of normal to slope on horizontal [degrees]\n    slope_tilt : float\n        tilt of normal to slope relative to vertical [degrees]\n    axis_azimuth : float\n        direction of tracker axes on horizontal [degrees]\n\n    Returns\n    -------\n    axis_tilt : float\n        tilt of tracker [degrees]\n\n    See also\n    --------\n    pvlib.tracking.singleaxis\n    pvlib.tracking.calc_cross_axis_tilt\n\n    Notes\n    -----\n    See [1]_ for derivation of equations.\n\n    References\n    ----------\n    .. [1] Kevin Anderson and Mark Mikofski, \"Slope-Aware Backtracking for\n       Single-Axis Trackers\", Technical Report NREL/TP-5K00-76626, July 2020.\n       https://www.nrel.gov/docs/fy20osti/76626.pdf\n    \"\"\"\n    delta_gamma = axis_azimuth - slope_azimuth\n    # equations 18-19\n    tan_axis_tilt = cosd(delta_gamma) * tand(slope_tilt)\n    return np.degrees(np.arctan(tan_axis_tilt))\n", "tokens": ["pvlib", "tracking", "py", "def", "calc_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "calculate", "tracker", "axis", "tilt", "in", "the", "global", "reference", "frame", "when", "on", "a", "sloped", "plane", "axis", "tilt", "is", "the", "inclination", "of", "the", "tracker", "rotation", "axis", "with", "respect", "to", "horizontal", "ranging", "from", "0", "degrees", "horizontal", "axis", "to", "90", "degrees", "vertical", "axis", "parameters", "slope_azimuth", "float", "direction", "of", "normal", "to", "slope", "on", "horizontal", "degrees", "slope_tilt", "float", "tilt", "of", "normal", "to", "slope", "relative", "to", "vertical", "degrees", "axis_azimuth", "float", "direction", "of", "tracker", "axes", "on", "horizontal", "degrees", "returns", "axis_tilt", "float", "tilt", "of", "tracker", "degrees", "see", "also", "pvlib", "tracking", "singleaxis", "pvlib", "tracking", "calc_cross_axis_tilt", "notes", "see", "1", "_", "for", "derivation", "of", "equations", "references", "1", "kevin", "anderson", "and", "mark", "mikofski", "slope", "aware", "backtracking", "for", "single", "axis", "trackers", "technical", "report", "nrel", "tp", "5k00", "76626", "july", "2020", "https", "www", "nrel", "gov", "docs", "fy20osti", "76626", "pdf", "delta_gamma", "axis_azimuth", "slope_azimuth", "equations", "18", "19", "tan_axis_tilt", "cosd", "delta_gamma", "tand", "slope_tilt", "return", "np", "degrees", "np", "arctan", "tan_axis_tilt"], "doc_len": 148}
{"doc_id": "pvlib/tracking.py::_calc_tracker_norm", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "_calc_tracker_norm", "text": "文件路径: pvlib/tracking.py\ndef _calc_tracker_norm(ba, bg, dg):\n    \"\"\"\n    Calculate tracker normal, v, cross product of tracker axis and unit normal,\n    N, to the system slope plane.\n\n    Parameters\n    ----------\n    ba : float\n        axis tilt [degrees]\n    bg : float\n        ground tilt [degrees]\n    dg : float\n        delta gamma, difference between axis and ground azimuths [degrees]\n\n    Returns\n    -------\n    vector : tuple\n        vx, vy, vz\n    \"\"\"\n    cos_ba = cosd(ba)\n    cos_bg = cosd(bg)\n    sin_bg = sind(bg)\n    sin_dg = sind(dg)\n    vx = sin_dg * cos_ba * cos_bg\n    vy = sind(ba)*sin_bg + cosd(dg)*cos_ba*cos_bg\n    vz = -sin_dg*sin_bg*cos_ba\n    return vx, vy, vz\n", "tokens": ["pvlib", "tracking", "py", "def", "_calc_tracker_norm", "ba", "bg", "dg", "calculate", "tracker", "normal", "v", "cross", "product", "of", "tracker", "axis", "and", "unit", "normal", "n", "to", "the", "system", "slope", "plane", "parameters", "ba", "float", "axis", "tilt", "degrees", "bg", "float", "ground", "tilt", "degrees", "dg", "float", "delta", "gamma", "difference", "between", "axis", "and", "ground", "azimuths", "degrees", "returns", "vector", "tuple", "vx", "vy", "vz", "cos_ba", "cosd", "ba", "cos_bg", "cosd", "bg", "sin_bg", "sind", "bg", "sin_dg", "sind", "dg", "vx", "sin_dg", "cos_ba", "cos_bg", "vy", "sind", "ba", "sin_bg", "cosd", "dg", "cos_ba", "cos_bg", "vz", "sin_dg", "sin_bg", "cos_ba", "return", "vx", "vy", "vz"], "doc_len": 86}
{"doc_id": "pvlib/tracking.py::_calc_beta_c", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "_calc_beta_c", "text": "文件路径: pvlib/tracking.py\ndef _calc_beta_c(v, dg, ba):\n    \"\"\"\n    Calculate the cross-axis tilt angle.\n\n    Parameters\n    ----------\n    v : tuple\n        tracker normal\n    dg : float\n        delta gamma, difference between axis and ground azimuths [degrees]\n    ba : float\n        axis tilt [degrees]\n\n    Returns\n    -------\n    beta_c : float\n        cross-axis tilt angle [radians]\n    \"\"\"\n    vnorm = np.sqrt(np.dot(v, v))\n    beta_c = np.arcsin(\n        ((v[0]*cosd(dg) - v[1]*sind(dg)) * sind(ba) + v[2]*cosd(ba)) / vnorm)\n    return beta_c\n", "tokens": ["pvlib", "tracking", "py", "def", "_calc_beta_c", "v", "dg", "ba", "calculate", "the", "cross", "axis", "tilt", "angle", "parameters", "v", "tuple", "tracker", "normal", "dg", "float", "delta", "gamma", "difference", "between", "axis", "and", "ground", "azimuths", "degrees", "ba", "float", "axis", "tilt", "degrees", "returns", "beta_c", "float", "cross", "axis", "tilt", "angle", "radians", "vnorm", "np", "sqrt", "np", "dot", "v", "v", "beta_c", "np", "arcsin", "v", "0", "cosd", "dg", "v", "1", "sind", "dg", "sind", "ba", "v", "2", "cosd", "ba", "vnorm", "return", "beta_c"], "doc_len": 70}
{"doc_id": "pvlib/tracking.py::calc_cross_axis_tilt", "file_path": "pvlib/tracking.py", "class_name": null, "func_name": "calc_cross_axis_tilt", "text": "文件路径: pvlib/tracking.py\ndef calc_cross_axis_tilt(\n        slope_azimuth, slope_tilt, axis_azimuth, axis_tilt):\n    \"\"\"\n    Calculate the angle, relative to horizontal, of the line formed by the\n    intersection between the slope containing the tracker axes and a plane\n    perpendicular to the tracker axes.\n\n    Use the cross-axis tilt to avoid row-to-row shade when backtracking on a\n    slope not parallel with the axis azimuth. Cross-axis tilt should be\n    specified using a right-handed convention. For example, trackers with axis\n    azimuth of 180 degrees (heading south) will have a negative cross-axis tilt\n    if the tracker axes plane slopes down to the east and positive cross-axis\n    tilt if the tracker axes plane slopes down to the west.\n\n    Parameters\n    ----------\n    slope_azimuth : float\n        direction of the normal to the slope containing the tracker axes, when\n        projected on the horizontal [degrees]\n    slope_tilt : float\n        angle of the slope containing the tracker axes, relative to horizontal\n        [degrees]\n    axis_azimuth : float\n        direction of tracker axes projected on the horizontal [degrees]\n    axis_tilt : float\n        tilt of trackers relative to horizontal.  ``axis_tilt`` must be >= 0\n        and <= 90. [degree]\n\n    Returns\n    -------\n    cross_axis_tilt : float\n        angle, relative to horizontal, of the line formed by the intersection\n        between the slope containing the tracker axes and a plane perpendicular\n        to the tracker axes [degrees]\n\n    See also\n    --------\n    pvlib.tracking.singleaxis\n    pvlib.tracking.calc_axis_tilt\n\n    Notes\n    -----\n    See [1]_ for derivation of equations.\n\n    References\n    ----------\n    .. [1] Kevin Anderson and Mark Mikofski, \"Slope-Aware Backtracking for\n       Single-Axis Trackers\", Technical Report NREL/TP-5K00-76626, July 2020.\n       https://www.nrel.gov/docs/fy20osti/76626.pdf\n    \"\"\"\n    # delta-gamma, difference between axis and slope azimuths\n    delta_gamma = axis_azimuth - slope_azimuth\n    # equation 22\n    v = _calc_tracker_norm(axis_tilt, slope_tilt, delta_gamma)\n    # equation 26\n    beta_c = _calc_beta_c(v, delta_gamma, axis_tilt)\n    return np.degrees(beta_c)\n", "tokens": ["pvlib", "tracking", "py", "def", "calc_cross_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "axis_tilt", "calculate", "the", "angle", "relative", "to", "horizontal", "of", "the", "line", "formed", "by", "the", "intersection", "between", "the", "slope", "containing", "the", "tracker", "axes", "and", "a", "plane", "perpendicular", "to", "the", "tracker", "axes", "use", "the", "cross", "axis", "tilt", "to", "avoid", "row", "to", "row", "shade", "when", "backtracking", "on", "a", "slope", "not", "parallel", "with", "the", "axis", "azimuth", "cross", "axis", "tilt", "should", "be", "specified", "using", "a", "right", "handed", "convention", "for", "example", "trackers", "with", "axis", "azimuth", "of", "180", "degrees", "heading", "south", "will", "have", "a", "negative", "cross", "axis", "tilt", "if", "the", "tracker", "axes", "plane", "slopes", "down", "to", "the", "east", "and", "positive", "cross", "axis", "tilt", "if", "the", "tracker", "axes", "plane", "slopes", "down", "to", "the", "west", "parameters", "slope_azimuth", "float", "direction", "of", "the", "normal", "to", "the", "slope", "containing", "the", "tracker", "axes", "when", "projected", "on", "the", "horizontal", "degrees", "slope_tilt", "float", "angle", "of", "the", "slope", "containing", "the", "tracker", "axes", "relative", "to", "horizontal", "degrees", "axis_azimuth", "float", "direction", "of", "tracker", "axes", "projected", "on", "the", "horizontal", "degrees", "axis_tilt", "float", "tilt", "of", "trackers", "relative", "to", "horizontal", "axis_tilt", "must", "be", "0", "and", "90", "degree", "returns", "cross_axis_tilt", "float", "angle", "relative", "to", "horizontal", "of", "the", "line", "formed", "by", "the", "intersection", "between", "the", "slope", "containing", "the", "tracker", "axes", "and", "a", "plane", "perpendicular", "to", "the", "tracker", "axes", "degrees", "see", "also", "pvlib", "tracking", "singleaxis", "pvlib", "tracking", "calc_axis_tilt", "notes", "see", "1", "_", "for", "derivation", "of", "equations", "references", "1", "kevin", "anderson", "and", "mark", "mikofski", "slope", "aware", "backtracking", "for", "single", "axis", "trackers", "technical", "report", "nrel", "tp", "5k00", "76626", "july", "2020", "https", "www", "nrel", "gov", "docs", "fy20osti", "76626", "pdf", "delta", "gamma", "difference", "between", "axis", "and", "slope", "azimuths", "delta_gamma", "axis_azimuth", "slope_azimuth", "equation", "22", "v", "_calc_tracker_norm", "axis_tilt", "slope_tilt", "delta_gamma", "equation", "26", "beta_c", "_calc_beta_c", "v", "delta_gamma", "axis_tilt", "return", "np", "degrees", "beta_c"], "doc_len": 278}
{"doc_id": "pvlib/_deprecation.py::_generate_deprecation_message", "file_path": "pvlib/_deprecation.py", "class_name": null, "func_name": "_generate_deprecation_message", "text": "文件路径: pvlib/_deprecation.py\ndef _generate_deprecation_message(\n        since, message='', name='', alternative='', pending=False,\n        obj_type='attribute', addendum='', removal=''):\n\n    if removal == \"\":\n        removal = \"soon\"\n    elif removal:\n        if pending:\n            raise ValueError(\n                \"A pending deprecation cannot have a scheduled removal\")\n        removal = \"in {}\".format(removal)\n\n    if not message:\n        message = (\n            \"The %(name)s %(obj_type)s\"\n            + (\" will be deprecated in a future version\"\n               if pending else\n               (\" was deprecated in %(projectName)s %(since)s\"\n                + (\" and will be removed %(removal)s\"\n                   if removal else\n                   \"\")))\n            + \".\"\n            + (\" Use %(alternative)s instead.\" if alternative else \"\")\n            + (\" %(addendum)s\" if addendum else \"\"))\n\n    return message % dict(\n        func=name, name=name, obj_type=obj_type, since=since, removal=removal,\n        alternative=alternative, addendum=addendum, projectName=_projectName)\n", "tokens": ["pvlib", "_deprecation", "py", "def", "_generate_deprecation_message", "since", "message", "name", "alternative", "pending", "false", "obj_type", "attribute", "addendum", "removal", "if", "removal", "removal", "soon", "elif", "removal", "if", "pending", "raise", "valueerror", "a", "pending", "deprecation", "cannot", "have", "a", "scheduled", "removal", "removal", "in", "format", "removal", "if", "not", "message", "message", "the", "name", "s", "obj_type", "s", "will", "be", "deprecated", "in", "a", "future", "version", "if", "pending", "else", "was", "deprecated", "in", "projectname", "s", "since", "s", "and", "will", "be", "removed", "removal", "s", "if", "removal", "else", "use", "alternative", "s", "instead", "if", "alternative", "else", "addendum", "s", "if", "addendum", "else", "return", "message", "dict", "func", "name", "name", "name", "obj_type", "obj_type", "since", "since", "removal", "removal", "alternative", "alternative", "addendum", "addendum", "projectname", "_projectname"], "doc_len": 103}
{"doc_id": "pvlib/_deprecation.py::warn_deprecated", "file_path": "pvlib/_deprecation.py", "class_name": null, "func_name": "warn_deprecated", "text": "文件路径: pvlib/_deprecation.py\ndef warn_deprecated(\n        since, message='', name='', alternative='', pending=False,\n        obj_type='attribute', addendum='', removal=''):\n    \"\"\"\n    Used to display deprecation in a standard way.\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.\n    message : str, optional\n        Override the default deprecation message.  The format\n        specifier `%(name)s` may be used for the name of the function,\n        and `%(alternative)s` may be used in the deprecation message\n        to insert the name of an alternative to the deprecated\n        function.  `%(obj_type)s` may be used to insert a friendly name\n        for the type of object being deprecated.\n    name : str, optional\n        The name of the deprecated object.\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n    obj_type : str, optional\n        The object type being deprecated.\n    addendum : str, optional\n        Additional text appended directly to the final message.\n    Examples\n    --------\n        Basic example::\n            # To warn of the deprecation of \"matplotlib.name_of_module\"\n            warn_deprecated('1.4.0', name='matplotlib.name_of_module',\n                            obj_type='module')\n    \"\"\"\n    message = '\\n' + _generate_deprecation_message(\n        since, message, name, alternative, pending, obj_type, addendum,\n        removal=removal)\n    category = (PendingDeprecationWarning if pending\n                else _projectWarning)\n    warnings.warn(message, category, stacklevel=2)\n", "tokens": ["pvlib", "_deprecation", "py", "def", "warn_deprecated", "since", "message", "name", "alternative", "pending", "false", "obj_type", "attribute", "addendum", "removal", "used", "to", "display", "deprecation", "in", "a", "standard", "way", "parameters", "since", "str", "the", "release", "at", "which", "this", "api", "became", "deprecated", "message", "str", "optional", "override", "the", "default", "deprecation", "message", "the", "format", "specifier", "name", "s", "may", "be", "used", "for", "the", "name", "of", "the", "function", "and", "alternative", "s", "may", "be", "used", "in", "the", "deprecation", "message", "to", "insert", "the", "name", "of", "an", "alternative", "to", "the", "deprecated", "function", "obj_type", "s", "may", "be", "used", "to", "insert", "a", "friendly", "name", "for", "the", "type", "of", "object", "being", "deprecated", "name", "str", "optional", "the", "name", "of", "the", "deprecated", "object", "alternative", "str", "optional", "an", "alternative", "api", "that", "the", "user", "may", "use", "in", "place", "of", "the", "deprecated", "api", "the", "deprecation", "warning", "will", "tell", "the", "user", "about", "this", "alternative", "if", "provided", "pending", "bool", "optional", "if", "true", "uses", "a", "pendingdeprecationwarning", "instead", "of", "a", "deprecationwarning", "cannot", "be", "used", "together", "with", "removal", "removal", "str", "optional", "the", "expected", "removal", "version", "with", "the", "default", "an", "empty", "string", "a", "removal", "version", "is", "automatically", "computed", "from", "since", "set", "to", "other", "falsy", "values", "to", "not", "schedule", "a", "removal", "date", "cannot", "be", "used", "together", "with", "pending", "obj_type", "str", "optional", "the", "object", "type", "being", "deprecated", "addendum", "str", "optional", "additional", "text", "appended", "directly", "to", "the", "final", "message", "examples", "basic", "example", "to", "warn", "of", "the", "deprecation", "of", "matplotlib", "name_of_module", "warn_deprecated", "1", "4", "0", "name", "matplotlib", "name_of_module", "obj_type", "module", "message", "n", "_generate_deprecation_message", "since", "message", "name", "alternative", "pending", "obj_type", "addendum", "removal", "removal", "category", "pendingdeprecationwarning", "if", "pending", "else", "_projectwarning", "warnings", "warn", "message", "category", "stacklevel", "2"], "doc_len": 251}
{"doc_id": "pvlib/_deprecation.py::deprecated", "file_path": "pvlib/_deprecation.py", "class_name": null, "func_name": "deprecated", "text": "文件路径: pvlib/_deprecation.py\ndef deprecated(since, message='', name='', alternative='', pending=False,\n               addendum='', removal=''):\n    \"\"\"\n    Decorator to mark a function or a class as deprecated.\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.  This is\n        required.\n    message : str, optional\n        Override the default deprecation message.  The format\n        specifier `%(name)s` may be used for the name of the object,\n        and `%(alternative)s` may be used in the deprecation message\n        to insert the name of an alternative to the deprecated\n        object.\n    name : str, optional\n        The name of the deprecated object; if not provided the name\n        is automatically determined from the passed in object,\n        though this is useful in the case of renamed functions, where\n        the new function is just assigned to the name of the\n        deprecated function.  For example::\n            def new_function():\n                ...\n            oldFunction = new_function\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n    addendum : str, optional\n        Additional text appended directly to the final message.\n    Examples\n    --------\n        Basic example::\n            @deprecated('1.4.0')\n            def the_function_to_deprecate():\n                pass\n    \"\"\"\n\n    def deprecate(obj, message=message, name=name, alternative=alternative,\n                  pending=pending, addendum=addendum):\n\n        if not name:\n            name = obj.__name__\n\n        if isinstance(obj, type):\n            obj_type = \"class\"\n            old_doc = obj.__doc__\n            func = obj.__init__\n\n            def finalize(wrapper, new_doc):\n                obj.__doc__ = new_doc\n                obj.__init__ = wrapper\n                return obj\n        else:\n            obj_type = \"function\"\n            if isinstance(obj, classmethod):\n                func = obj.__func__\n                old_doc = func.__doc__\n\n                def finalize(wrapper, new_doc):\n                    wrapper = functools.wraps(func)(wrapper)\n                    wrapper.__doc__ = new_doc\n                    return classmethod(wrapper)\n            else:\n                func = obj\n                old_doc = func.__doc__\n\n                def finalize(wrapper, new_doc):\n                    wrapper = functools.wraps(func)(wrapper)\n                    wrapper.__doc__ = new_doc\n                    return wrapper\n\n        message = _generate_deprecation_message(\n            since, message, name, alternative, pending, obj_type, addendum,\n            removal=removal)\n        category = (PendingDeprecationWarning if pending\n                    else _projectWarning)\n\n        def wrapper(*args, **kwargs):\n            warnings.warn(message, category, stacklevel=2)\n            return func(*args, **kwargs)\n\n        old_doc = textwrap.dedent(old_doc or '').strip('\\n')\n        message = message.strip()\n        new_doc = (('\\n.. deprecated:: %(since)s'\n                    '\\n    %(message)s\\n\\n' %\n                    {'since': since, 'message': message}) + old_doc)\n        if not old_doc:\n            # This is to prevent a spurious 'unexected unindent' warning from\n            # docutils when the original docstring was blank.\n            new_doc += r'\\ '\n\n        return finalize(wrapper, new_doc)\n\n    return deprecate\n", "tokens": ["pvlib", "_deprecation", "py", "def", "deprecated", "since", "message", "name", "alternative", "pending", "false", "addendum", "removal", "decorator", "to", "mark", "a", "function", "or", "a", "class", "as", "deprecated", "parameters", "since", "str", "the", "release", "at", "which", "this", "api", "became", "deprecated", "this", "is", "required", "message", "str", "optional", "override", "the", "default", "deprecation", "message", "the", "format", "specifier", "name", "s", "may", "be", "used", "for", "the", "name", "of", "the", "object", "and", "alternative", "s", "may", "be", "used", "in", "the", "deprecation", "message", "to", "insert", "the", "name", "of", "an", "alternative", "to", "the", "deprecated", "object", "name", "str", "optional", "the", "name", "of", "the", "deprecated", "object", "if", "not", "provided", "the", "name", "is", "automatically", "determined", "from", "the", "passed", "in", "object", "though", "this", "is", "useful", "in", "the", "case", "of", "renamed", "functions", "where", "the", "new", "function", "is", "just", "assigned", "to", "the", "name", "of", "the", "deprecated", "function", "for", "example", "def", "new_function", "oldfunction", "new_function", "alternative", "str", "optional", "an", "alternative", "api", "that", "the", "user", "may", "use", "in", "place", "of", "the", "deprecated", "api", "the", "deprecation", "warning", "will", "tell", "the", "user", "about", "this", "alternative", "if", "provided", "pending", "bool", "optional", "if", "true", "uses", "a", "pendingdeprecationwarning", "instead", "of", "a", "deprecationwarning", "cannot", "be", "used", "together", "with", "removal", "removal", "str", "optional", "the", "expected", "removal", "version", "with", "the", "default", "an", "empty", "string", "a", "removal", "version", "is", "automatically", "computed", "from", "since", "set", "to", "other", "falsy", "values", "to", "not", "schedule", "a", "removal", "date", "cannot", "be", "used", "together", "with", "pending", "addendum", "str", "optional", "additional", "text", "appended", "directly", "to", "the", "final", "message", "examples", "basic", "example", "deprecated", "1", "4", "0", "def", "the_function_to_deprecate", "pass", "def", "deprecate", "obj", "message", "message", "name", "name", "alternative", "alternative", "pending", "pending", "addendum", "addendum", "if", "not", "name", "name", "obj", "__name__", "if", "isinstance", "obj", "type", "obj_type", "class", "old_doc", "obj", "__doc__", "func", "obj", "__init__", "def", "finalize", "wrapper", "new_doc", "obj", "__doc__", "new_doc", "obj", "__init__", "wrapper", "return", "obj", "else", "obj_type", "function", "if", "isinstance", "obj", "classmethod", "func", "obj", "__func__", "old_doc", "func", "__doc__", "def", "finalize", "wrapper", "new_doc", "wrapper", "functools", "wraps", "func", "wrapper", "wrapper", "__doc__", "new_doc", "return", "classmethod", "wrapper", "else", "func", "obj", "old_doc", "func", "__doc__", "def", "finalize", "wrapper", "new_doc", "wrapper", "functools", "wraps", "func", "wrapper", "wrapper", "__doc__", "new_doc", "return", "wrapper", "message", "_generate_deprecation_message", "since", "message", "name", "alternative", "pending", "obj_type", "addendum", "removal", "removal", "category", "pendingdeprecationwarning", "if", "pending", "else", "_projectwarning", "def", "wrapper", "args", "kwargs", "warnings", "warn", "message", "category", "stacklevel", "2", "return", "func", "args", "kwargs", "old_doc", "textwrap", "dedent", "old_doc", "or", "strip", "n", "message", "message", "strip", "new_doc", "n", "deprecated", "since", "s", "n", "message", "s", "n", "n", "since", "since", "message", "message", "old_doc", "if", "not", "old_doc", "this", "is", "to", "prevent", "a", "spurious", "unexected", "unindent", "warning", "from", "docutils", "when", "the", "original", "docstring", "was", "blank", "new_doc", "r", "return", "finalize", "wrapper", "new_doc", "return", "deprecate"], "doc_len": 413}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_vf_ground_sky_integ", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_vf_ground_sky_integ", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _vf_ground_sky_integ(surface_tilt, surface_azimuth, gcr, height,\n                         pitch, max_rows=10, npoints=100):\n    \"\"\"\n    Integrated and per-point view factors from the ground to the sky at points\n    between interior rows of the array.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angle in degrees from horizontal, e.g., surface facing up\n        = 0, surface facing horizon = 90. [degree]\n    surface_azimuth : numeric\n        Surface azimuth angles in decimal degrees east of north\n        (e.g. North = 0, South = 180, East = 90, West = 270).\n        ``surface_azimuth`` must be >=0 and <=360.\n    gcr : float\n        Ratio of row slant length to row spacing (pitch). [unitless]\n    height : float\n        Height of the center point of the row above the ground; must be in the\n        same units as ``pitch``.\n    pitch : float\n        Distance between two rows. Must be in the same units as ``height``.\n    max_rows : int, default 10\n        Maximum number of rows to consider in front and behind the current row.\n    npoints : int, default 100\n        Number of points used to discretize distance along the ground.\n\n    Returns\n    -------\n    fgnd_sky : float\n        Integration of view factor over the length between adjacent, interior\n        rows. [unitless]\n    fz : ndarray\n        Fraction of distance from the previous row to the next row. [unitless]\n    fz_sky : ndarray\n        View factors at discrete points between adjacent, interior rows.\n        [unitless]\n\n    \"\"\"\n    # TODO: vectorize over surface_tilt\n    # Abuse utils._vf_ground_sky_2d by supplying surface_tilt in place\n    # of a signed rotation. This is OK because\n    # 1) z span the full distance between 2 rows, and\n    # 2) max_rows is set to be large upstream, and\n    # 3) _vf_ground_sky_2d considers [-max_rows, +max_rows]\n    # The VFs to the sky will thus be symmetric around z=0.5\n    z = np.linspace(0, 1, npoints)\n    rotation = np.atleast_1d(surface_tilt)\n    fz_sky = np.zeros((len(rotation), npoints))\n    for k, r in enumerate(rotation):\n        vf, _ = utils._vf_ground_sky_2d(z, r, gcr, pitch, height, max_rows)\n        fz_sky[k, :] = vf\n    # calculate the integrated view factor for all of the ground between rows\n    return np.trapz(fz_sky, z, axis=1)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_vf_ground_sky_integ", "surface_tilt", "surface_azimuth", "gcr", "height", "pitch", "max_rows", "10", "npoints", "100", "integrated", "and", "per", "point", "view", "factors", "from", "the", "ground", "to", "the", "sky", "at", "points", "between", "interior", "rows", "of", "the", "array", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "surface_azimuth", "numeric", "surface", "azimuth", "angles", "in", "decimal", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "surface_azimuth", "must", "be", "0", "and", "360", "gcr", "float", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "pitch", "unitless", "height", "float", "height", "of", "the", "center", "point", "of", "the", "row", "above", "the", "ground", "must", "be", "in", "the", "same", "units", "as", "pitch", "pitch", "float", "distance", "between", "two", "rows", "must", "be", "in", "the", "same", "units", "as", "height", "max_rows", "int", "default", "10", "maximum", "number", "of", "rows", "to", "consider", "in", "front", "and", "behind", "the", "current", "row", "npoints", "int", "default", "100", "number", "of", "points", "used", "to", "discretize", "distance", "along", "the", "ground", "returns", "fgnd_sky", "float", "integration", "of", "view", "factor", "over", "the", "length", "between", "adjacent", "interior", "rows", "unitless", "fz", "ndarray", "fraction", "of", "distance", "from", "the", "previous", "row", "to", "the", "next", "row", "unitless", "fz_sky", "ndarray", "view", "factors", "at", "discrete", "points", "between", "adjacent", "interior", "rows", "unitless", "todo", "vectorize", "over", "surface_tilt", "abuse", "utils", "_vf_ground_sky_2d", "by", "supplying", "surface_tilt", "in", "place", "of", "a", "signed", "rotation", "this", "is", "ok", "because", "1", "z", "span", "the", "full", "distance", "between", "2", "rows", "and", "2", "max_rows", "is", "set", "to", "be", "large", "upstream", "and", "3", "_vf_ground_sky_2d", "considers", "max_rows", "max_rows", "the", "vfs", "to", "the", "sky", "will", "thus", "be", "symmetric", "around", "z", "0", "5", "z", "np", "linspace", "0", "1", "npoints", "rotation", "np", "atleast_1d", "surface_tilt", "fz_sky", "np", "zeros", "len", "rotation", "npoints", "for", "k", "r", "in", "enumerate", "rotation", "vf", "_", "utils", "_vf_ground_sky_2d", "z", "r", "gcr", "pitch", "height", "max_rows", "fz_sky", "k", "vf", "calculate", "the", "integrated", "view", "factor", "for", "all", "of", "the", "ground", "between", "rows", "return", "np", "trapz", "fz_sky", "z", "axis", "1"], "doc_len": 313}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_poa_ground_shadows", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_poa_ground_shadows", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _poa_ground_shadows(poa_ground, f_gnd_beam, df, vf_gnd_sky):\n    \"\"\"\n    Reduce ground-reflected irradiance to the tilted plane (poa_ground) to\n    account for shadows on the ground.\n\n    Parameters\n    ----------\n    poa_ground : numeric\n        Ground reflected irradiance on the tilted surface, assuming full GHI\n        illumination on all of the ground. [W/m^2]\n    f_gnd_beam : numeric\n        Fraction of the distance between rows that is illuminated (unshaded).\n        [unitless]\n    df : numeric\n        Diffuse fraction, the ratio of DHI to GHI. [unitless]\n    vf_gnd_sky : numeric\n        View factor from the ground to the sky, integrated along the distance\n        between rows. [unitless]\n\n    Returns\n    -------\n    poa_gnd_sky : numeric\n        Adjusted ground-reflected irradiance accounting for shadows on the\n        ground. [W/m^2]\n\n    \"\"\"\n    return poa_ground * (f_gnd_beam*(1 - df) + df*vf_gnd_sky)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_poa_ground_shadows", "poa_ground", "f_gnd_beam", "df", "vf_gnd_sky", "reduce", "ground", "reflected", "irradiance", "to", "the", "tilted", "plane", "poa_ground", "to", "account", "for", "shadows", "on", "the", "ground", "parameters", "poa_ground", "numeric", "ground", "reflected", "irradiance", "on", "the", "tilted", "surface", "assuming", "full", "ghi", "illumination", "on", "all", "of", "the", "ground", "w", "m", "2", "f_gnd_beam", "numeric", "fraction", "of", "the", "distance", "between", "rows", "that", "is", "illuminated", "unshaded", "unitless", "df", "numeric", "diffuse", "fraction", "the", "ratio", "of", "dhi", "to", "ghi", "unitless", "vf_gnd_sky", "numeric", "view", "factor", "from", "the", "ground", "to", "the", "sky", "integrated", "along", "the", "distance", "between", "rows", "unitless", "returns", "poa_gnd_sky", "numeric", "adjusted", "ground", "reflected", "irradiance", "accounting", "for", "shadows", "on", "the", "ground", "w", "m", "2", "return", "poa_ground", "f_gnd_beam", "1", "df", "df", "vf_gnd_sky"], "doc_len": 112}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_vf_row_sky_integ", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_vf_row_sky_integ", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _vf_row_sky_integ(f_x, surface_tilt, gcr, npoints=100):\n    \"\"\"\n    Integrated view factors from the shaded and unshaded parts of\n    the row slant height to the sky.\n\n    Parameters\n    ----------\n    f_x : numeric\n        Fraction of row slant height from the bottom that is shaded. [unitless]\n    surface_tilt : numeric\n        Surface tilt angle in degrees from horizontal, e.g., surface facing up\n        = 0, surface facing horizon = 90. [degree]\n    gcr : float\n        Ratio of row slant length to row spacing (pitch). [unitless]\n    npoints : int, default 100\n        Number of points for integration. [unitless]\n\n    Returns\n    -------\n    vf_shade_sky_integ : numeric\n        Integrated view factor from the shaded part of the row to the sky.\n        [unitless]\n    vf_noshade_sky_integ : numeric\n        Integrated view factor from the unshaded part of the row to the sky.\n        [unitless]\n\n    Notes\n    -----\n    The view factor to the sky at a point x along the row slant height is\n    given by\n\n    .. math ::\n        \\\\large{f_{sky} = \\frac{1}{2} \\\\left(\\\\cos\\\\left(\\\\psi_t\\\\right) +\n        \\\\cos \\\\left(\\\\beta\\\\right) \\\\right)\n\n    where :math:`\\\\psi_t` is the angle from horizontal of the line from point\n    x to the top of the facing row, and :math:`\\\\beta` is the surface tilt.\n\n    View factors are integrated separately over shaded and unshaded portions\n    of the row slant height.\n\n    \"\"\"\n    # handle Series inputs\n    surface_tilt = np.array(surface_tilt)\n    cst = cosd(surface_tilt)\n    # shaded portion\n    x = np.linspace(0, f_x, num=npoints)\n    psi_t_shaded = masking_angle(surface_tilt, gcr, x)\n    y = 0.5 * (cosd(psi_t_shaded) + cst)\n    # integrate view factors from each point in the discretization. This is an\n    # improvement over the algorithm described in [2]\n    vf_shade_sky_integ = np.trapz(y, x, axis=0)\n    # unshaded portion\n    x = np.linspace(f_x, 1., num=npoints)\n    psi_t_unshaded = masking_angle(surface_tilt, gcr, x)\n    y = 0.5 * (cosd(psi_t_unshaded) + cst)\n    vf_noshade_sky_integ = np.trapz(y, x, axis=0)\n    return vf_shade_sky_integ, vf_noshade_sky_integ\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_vf_row_sky_integ", "f_x", "surface_tilt", "gcr", "npoints", "100", "integrated", "view", "factors", "from", "the", "shaded", "and", "unshaded", "parts", "of", "the", "row", "slant", "height", "to", "the", "sky", "parameters", "f_x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "that", "is", "shaded", "unitless", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "gcr", "float", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "pitch", "unitless", "npoints", "int", "default", "100", "number", "of", "points", "for", "integration", "unitless", "returns", "vf_shade_sky_integ", "numeric", "integrated", "view", "factor", "from", "the", "shaded", "part", "of", "the", "row", "to", "the", "sky", "unitless", "vf_noshade_sky_integ", "numeric", "integrated", "view", "factor", "from", "the", "unshaded", "part", "of", "the", "row", "to", "the", "sky", "unitless", "notes", "the", "view", "factor", "to", "the", "sky", "at", "a", "point", "x", "along", "the", "row", "slant", "height", "is", "given", "by", "math", "large", "f_", "sky", "frac", "1", "2", "left", "cos", "left", "psi_t", "right", "cos", "left", "beta", "right", "right", "where", "math", "psi_t", "is", "the", "angle", "from", "horizontal", "of", "the", "line", "from", "point", "x", "to", "the", "top", "of", "the", "facing", "row", "and", "math", "beta", "is", "the", "surface", "tilt", "view", "factors", "are", "integrated", "separately", "over", "shaded", "and", "unshaded", "portions", "of", "the", "row", "slant", "height", "handle", "series", "inputs", "surface_tilt", "np", "array", "surface_tilt", "cst", "cosd", "surface_tilt", "shaded", "portion", "x", "np", "linspace", "0", "f_x", "num", "npoints", "psi_t_shaded", "masking_angle", "surface_tilt", "gcr", "x", "y", "0", "5", "cosd", "psi_t_shaded", "cst", "integrate", "view", "factors", "from", "each", "point", "in", "the", "discretization", "this", "is", "an", "improvement", "over", "the", "algorithm", "described", "in", "2", "vf_shade_sky_integ", "np", "trapz", "y", "x", "axis", "0", "unshaded", "portion", "x", "np", "linspace", "f_x", "1", "num", "npoints", "psi_t_unshaded", "masking_angle", "surface_tilt", "gcr", "x", "y", "0", "5", "cosd", "psi_t_unshaded", "cst", "vf_noshade_sky_integ", "np", "trapz", "y", "x", "axis", "0", "return", "vf_shade_sky_integ", "vf_noshade_sky_integ"], "doc_len": 283}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_poa_sky_diffuse_pv", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_poa_sky_diffuse_pv", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _poa_sky_diffuse_pv(f_x, dhi, vf_shade_sky_integ, vf_noshade_sky_integ):\n    \"\"\"\n    Sky diffuse POA from integrated view factors combined for both shaded and\n    unshaded parts of the surface.\n\n    Parameters\n    ----------\n    f_x : numeric\n        Fraction of row slant height from the bottom that is shaded. [unitless]\n    dhi : numeric\n        Diffuse horizontal irradiance (DHI). [W/m^2]\n    vf_shade_sky_integ : numeric\n        Integrated view factor from the shaded part of the row to the sky.\n        [unitless]\n    vf_noshade_sky_integ : numeric\n        Integrated view factor from the unshaded part of the row to the sky.\n        [unitless]\n\n    Returns\n    -------\n    poa_sky_diffuse_pv : numeric\n        Total sky diffuse irradiance incident on the PV surface. [W/m^2]\n    \"\"\"\n    return dhi * (f_x * vf_shade_sky_integ + (1 - f_x) * vf_noshade_sky_integ)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_poa_sky_diffuse_pv", "f_x", "dhi", "vf_shade_sky_integ", "vf_noshade_sky_integ", "sky", "diffuse", "poa", "from", "integrated", "view", "factors", "combined", "for", "both", "shaded", "and", "unshaded", "parts", "of", "the", "surface", "parameters", "f_x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "that", "is", "shaded", "unitless", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "dhi", "w", "m", "2", "vf_shade_sky_integ", "numeric", "integrated", "view", "factor", "from", "the", "shaded", "part", "of", "the", "row", "to", "the", "sky", "unitless", "vf_noshade_sky_integ", "numeric", "integrated", "view", "factor", "from", "the", "unshaded", "part", "of", "the", "row", "to", "the", "sky", "unitless", "returns", "poa_sky_diffuse_pv", "numeric", "total", "sky", "diffuse", "irradiance", "incident", "on", "the", "pv", "surface", "w", "m", "2", "return", "dhi", "f_x", "vf_shade_sky_integ", "1", "f_x", "vf_noshade_sky_integ"], "doc_len": 105}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_ground_angle", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_ground_angle", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _ground_angle(x, surface_tilt, gcr):\n    \"\"\"\n    Angle from horizontal of the line from a point x on the row slant length\n    to the bottom of the facing row.\n\n    The angles are clockwise from horizontal, rather than the usual\n    counterclockwise direction.\n\n    Parameters\n    ----------\n    x : numeric\n        fraction of row slant length from bottom, ``x = 0`` is at the row\n        bottom, ``x = 1`` is at the top of the row.\n    surface_tilt : numeric\n        Surface tilt angle in degrees from horizontal, e.g., surface facing up\n        = 0, surface facing horizon = 90. [degree]\n    gcr : float\n        ground coverage ratio, ratio of row slant length to row spacing.\n        [unitless]\n\n    Returns\n    -------\n    psi : numeric\n        Angle [degree].\n    \"\"\"\n    #  : \\\\            \\\n    #  :  \\\\            \\\n    #  :   \\\\            \\\n    #  :    \\\\            \\  facing row\n    #  :     \\\\.___________\\\n    #  :       \\  ^*-.  psi \\\n    #  :        \\  x   *-.   \\\n    #  :         \\  v      *-.\\\n    #  :          \\<-----P---->\\\n\n    x1 = gcr * x * sind(surface_tilt)\n    x2 = gcr * x * cosd(surface_tilt) + 1\n    psi = np.arctan2(x1, x2)  # do this first because it handles 0 / 0\n    return np.rad2deg(psi)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_ground_angle", "x", "surface_tilt", "gcr", "angle", "from", "horizontal", "of", "the", "line", "from", "a", "point", "x", "on", "the", "row", "slant", "length", "to", "the", "bottom", "of", "the", "facing", "row", "the", "angles", "are", "clockwise", "from", "horizontal", "rather", "than", "the", "usual", "counterclockwise", "direction", "parameters", "x", "numeric", "fraction", "of", "row", "slant", "length", "from", "bottom", "x", "0", "is", "at", "the", "row", "bottom", "x", "1", "is", "at", "the", "top", "of", "the", "row", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "gcr", "float", "ground", "coverage", "ratio", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "unitless", "returns", "psi", "numeric", "angle", "degree", "facing", "row", "___________", "psi", "x", "v", "p", "x1", "gcr", "x", "sind", "surface_tilt", "x2", "gcr", "x", "cosd", "surface_tilt", "1", "psi", "np", "arctan2", "x1", "x2", "do", "this", "first", "because", "it", "handles", "0", "0", "return", "np", "rad2deg", "psi"], "doc_len": 143}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_vf_row_ground", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_vf_row_ground", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _vf_row_ground(x, surface_tilt, gcr):\n    \"\"\"\n    View factor from a point x on the row to the ground.\n\n    Parameters\n    ----------\n    x : numeric\n        Fraction of row slant height from the bottom. [unitless]\n    surface_tilt : numeric\n        Surface tilt angle in degrees from horizontal, e.g., surface facing up\n        = 0, surface facing horizon = 90. [degree]\n    gcr : float\n        Ground coverage ratio, ratio of row slant length to row spacing.\n        [unitless]\n\n    Returns\n    -------\n    vf : numeric\n        View factor from the point at x to the ground. [unitless]\n\n    \"\"\"\n    cst = cosd(surface_tilt)\n    # angle from horizontal at the point x on the row slant height to the\n    # bottom of the facing row\n    psi_t_shaded = _ground_angle(x, surface_tilt, gcr)\n    # view factor from the point on the row to the ground\n    return 0.5 * (cosd(psi_t_shaded) - cst)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_vf_row_ground", "x", "surface_tilt", "gcr", "view", "factor", "from", "a", "point", "x", "on", "the", "row", "to", "the", "ground", "parameters", "x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "unitless", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "gcr", "float", "ground", "coverage", "ratio", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "unitless", "returns", "vf", "numeric", "view", "factor", "from", "the", "point", "at", "x", "to", "the", "ground", "unitless", "cst", "cosd", "surface_tilt", "angle", "from", "horizontal", "at", "the", "point", "x", "on", "the", "row", "slant", "height", "to", "the", "bottom", "of", "the", "facing", "row", "psi_t_shaded", "_ground_angle", "x", "surface_tilt", "gcr", "view", "factor", "from", "the", "point", "on", "the", "row", "to", "the", "ground", "return", "0", "5", "cosd", "psi_t_shaded", "cst"], "doc_len": 125}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_vf_row_ground_integ", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_vf_row_ground_integ", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _vf_row_ground_integ(f_x, surface_tilt, gcr, npoints=100):\n    \"\"\"\n    View factors to the ground from shaded and unshaded parts of a row.\n\n    Parameters\n    ----------\n    f_x : numeric\n        Fraction of row slant height from the bottom that is shaded. [unitless]\n    surface_tilt : numeric\n        Surface tilt angle in degrees from horizontal, e.g., surface facing up\n        = 0, surface facing horizon = 90. [degree]\n    gcr : float\n        Ground coverage ratio, ratio of row slant length to row spacing.\n        [unitless]\n    npoints : int, default 100\n        Number of points for integration. [unitless]\n\n    Returns\n    -------\n    vf_shade_ground_integ : numeric\n        View factor from the shaded portion of the row to the ground.\n        [unitless]\n    vf_noshade_ground_integ : numeric\n        View factor from the unshaded portion of the row to the ground.\n        [unitless]\n\n    Notes\n    -----\n    The view factor to the ground at a point x along the row slant height is\n    given by\n\n    .. math ::\n        \\\\large{f_{gr} = \\frac{1}{2} \\\\left(\\\\cos\\\\left(\\\\psi_t\\\\right) -\n        \\\\cos \\\\left(\\\\beta\\\\right) \\\\right)\n\n    where :math:`\\\\psi_t` is the angle from horizontal of the line from point\n    x to the bottom of the facing row, and :math:`\\\\beta` is the surface tilt.\n\n    Each view factor is integrated over the relevant portion of the row\n    slant height.\n    \"\"\"\n    # handle Series inputs\n    surface_tilt = np.array(surface_tilt)\n    # shaded portion of row slant height\n    x = np.linspace(0, f_x, num=npoints)\n    # view factor from the point on the row to the ground\n    y = _vf_row_ground(x, surface_tilt, gcr)\n    # integrate view factors along the shaded portion of the row slant height.\n    # This is an improvement over the algorithm described in [2]\n    vf_shade_ground_integ = np.trapz(y, x, axis=0)\n\n    # unshaded portion of row slant height\n    x = np.linspace(f_x, 1., num=npoints)\n    # view factor from the point on the row to the ground\n    y = _vf_row_ground(x, surface_tilt, gcr)\n    # integrate view factors along the unshaded portion.\n    # This is an improvement over the algorithm described in [2]\n    vf_noshade_ground_integ = np.trapz(y, x, axis=0)\n\n    return vf_shade_ground_integ, vf_noshade_ground_integ\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_vf_row_ground_integ", "f_x", "surface_tilt", "gcr", "npoints", "100", "view", "factors", "to", "the", "ground", "from", "shaded", "and", "unshaded", "parts", "of", "a", "row", "parameters", "f_x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "that", "is", "shaded", "unitless", "surface_tilt", "numeric", "surface", "tilt", "angle", "in", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "gcr", "float", "ground", "coverage", "ratio", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "unitless", "npoints", "int", "default", "100", "number", "of", "points", "for", "integration", "unitless", "returns", "vf_shade_ground_integ", "numeric", "view", "factor", "from", "the", "shaded", "portion", "of", "the", "row", "to", "the", "ground", "unitless", "vf_noshade_ground_integ", "numeric", "view", "factor", "from", "the", "unshaded", "portion", "of", "the", "row", "to", "the", "ground", "unitless", "notes", "the", "view", "factor", "to", "the", "ground", "at", "a", "point", "x", "along", "the", "row", "slant", "height", "is", "given", "by", "math", "large", "f_", "gr", "frac", "1", "2", "left", "cos", "left", "psi_t", "right", "cos", "left", "beta", "right", "right", "where", "math", "psi_t", "is", "the", "angle", "from", "horizontal", "of", "the", "line", "from", "point", "x", "to", "the", "bottom", "of", "the", "facing", "row", "and", "math", "beta", "is", "the", "surface", "tilt", "each", "view", "factor", "is", "integrated", "over", "the", "relevant", "portion", "of", "the", "row", "slant", "height", "handle", "series", "inputs", "surface_tilt", "np", "array", "surface_tilt", "shaded", "portion", "of", "row", "slant", "height", "x", "np", "linspace", "0", "f_x", "num", "npoints", "view", "factor", "from", "the", "point", "on", "the", "row", "to", "the", "ground", "y", "_vf_row_ground", "x", "surface_tilt", "gcr", "integrate", "view", "factors", "along", "the", "shaded", "portion", "of", "the", "row", "slant", "height", "this", "is", "an", "improvement", "over", "the", "algorithm", "described", "in", "2", "vf_shade_ground_integ", "np", "trapz", "y", "x", "axis", "0", "unshaded", "portion", "of", "row", "slant", "height", "x", "np", "linspace", "f_x", "1", "num", "npoints", "view", "factor", "from", "the", "point", "on", "the", "row", "to", "the", "ground", "y", "_vf_row_ground", "x", "surface_tilt", "gcr", "integrate", "view", "factors", "along", "the", "unshaded", "portion", "this", "is", "an", "improvement", "over", "the", "algorithm", "described", "in", "2", "vf_noshade_ground_integ", "np", "trapz", "y", "x", "axis", "0", "return", "vf_shade_ground_integ", "vf_noshade_ground_integ"], "doc_len": 313}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_poa_ground_pv", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_poa_ground_pv", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _poa_ground_pv(f_x, poa_ground, f_gnd_pv_shade, f_gnd_pv_noshade):\n    \"\"\"\n    Reduce ground-reflected irradiance to account for limited view of the\n    ground from the row surface.\n\n    Parameters\n    ----------\n    f_x : numeric\n        Fraction of row slant height from the bottom that is shaded. [unitless]\n    poa_ground : numeric\n        Ground-reflected irradiance that would reach the row surface if the\n        full ground was visible. poa_gnd_sky accounts for limited view of the\n        sky from the ground. [W/m^2]\n    f_gnd_pv_shade : numeric\n        fraction of ground visible from shaded part of PV surface. [unitless]\n    f_gnd_pv_noshade : numeric\n        fraction of ground visible from unshaded part of PV surface. [unitless]\n\n    Returns\n    -------\n    numeric\n        Ground diffuse irradiance on the row plane. [W/m^2]\n    \"\"\"\n    return poa_ground * (f_x * f_gnd_pv_shade + (1 - f_x) * f_gnd_pv_noshade)\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_poa_ground_pv", "f_x", "poa_ground", "f_gnd_pv_shade", "f_gnd_pv_noshade", "reduce", "ground", "reflected", "irradiance", "to", "account", "for", "limited", "view", "of", "the", "ground", "from", "the", "row", "surface", "parameters", "f_x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "that", "is", "shaded", "unitless", "poa_ground", "numeric", "ground", "reflected", "irradiance", "that", "would", "reach", "the", "row", "surface", "if", "the", "full", "ground", "was", "visible", "poa_gnd_sky", "accounts", "for", "limited", "view", "of", "the", "sky", "from", "the", "ground", "w", "m", "2", "f_gnd_pv_shade", "numeric", "fraction", "of", "ground", "visible", "from", "shaded", "part", "of", "pv", "surface", "unitless", "f_gnd_pv_noshade", "numeric", "fraction", "of", "ground", "visible", "from", "unshaded", "part", "of", "pv", "surface", "unitless", "returns", "numeric", "ground", "diffuse", "irradiance", "on", "the", "row", "plane", "w", "m", "2", "return", "poa_ground", "f_x", "f_gnd_pv_shade", "1", "f_x", "f_gnd_pv_noshade"], "doc_len": 117}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_shaded_fraction", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_shaded_fraction", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _shaded_fraction(solar_zenith, solar_azimuth, surface_tilt,\n                     surface_azimuth, gcr):\n    \"\"\"\n    Calculate fraction (from the bottom) of row slant height that is shaded\n    from direct irradiance by the row in front toward the sun.\n\n    See [1], Eq. 14 and also [2], Eq. 32.\n\n    .. math::\n        F_x = \\\\max \\\\left( 0, \\\\min \\\\left(\\\\frac{\\\\text{GCR} \\\\cos \\\\theta\n        + \\\\left( \\\\text{GCR} \\\\sin \\\\theta - \\\\tan \\\\beta_{c} \\\\right)\n        \\\\tan Z - 1}\n        {\\\\text{GCR} \\\\left( \\\\cos \\\\theta + \\\\sin \\\\theta \\\\tan Z \\\\right)},\n        1 \\\\right) \\\\right)\n\n    Parameters\n    ----------\n    solar_zenith : numeric\n        Apparent (refraction-corrected) solar zenith. [degrees]\n    solar_azimuth : numeric\n        Solar azimuth. [degrees]\n    surface_tilt : numeric\n        Row tilt from horizontal, e.g. surface facing up = 0, surface facing\n        horizon = 90. [degrees]\n    surface_azimuth : numeric\n        Azimuth angle of the row surface. North=0, East=90, South=180,\n        West=270. [degrees]\n    gcr : numeric\n        Ground coverage ratio, which is the ratio of row slant length to row\n        spacing (pitch). [unitless]\n\n    Returns\n    -------\n    f_x : numeric\n        Fraction of row slant height from the bottom that is shaded from\n        direct irradiance.\n\n    References\n    ----------\n    .. [1] Mikofski, M., Darawali, R., Hamer, M., Neubert, A., and Newmiller,\n       J. \"Bifacial Performance Modeling in Large Arrays\". 2019 IEEE 46th\n       Photovoltaic Specialists Conference (PVSC), 2019, pp. 1282-1287.\n       :doi:`10.1109/PVSC40753.2019.8980572`.\n    .. [2] Kevin Anderson and Mark Mikofski, \"Slope-Aware Backtracking for\n       Single-Axis Trackers\", Technical Report NREL/TP-5K00-76626, July 2020.\n       https://www.nrel.gov/docs/fy20osti/76626.pdf\n    \"\"\"\n    tan_phi = utils._solar_projection_tangent(\n        solar_zenith, solar_azimuth, surface_azimuth)\n    # length of shadow behind a row as a fraction of pitch\n    x = gcr * (sind(surface_tilt) * tan_phi + cosd(surface_tilt))\n    f_x = 1 - 1. / x\n    # set f_x to be 1 when sun is behind the array\n    ao = aoi(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth)\n    f_x = np.where(ao < 90, f_x, 1.)\n    # when x < 1, the shadow is not long enough to fall on the row surface\n    f_x = np.where(x > 1., f_x, 0.)\n    return f_x\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_shaded_fraction", "solar_zenith", "solar_azimuth", "surface_tilt", "surface_azimuth", "gcr", "calculate", "fraction", "from", "the", "bottom", "of", "row", "slant", "height", "that", "is", "shaded", "from", "direct", "irradiance", "by", "the", "row", "in", "front", "toward", "the", "sun", "see", "1", "eq", "14", "and", "also", "2", "eq", "32", "math", "f_x", "max", "left", "0", "min", "left", "frac", "text", "gcr", "cos", "theta", "left", "text", "gcr", "sin", "theta", "tan", "beta_", "c", "right", "tan", "z", "1", "text", "gcr", "left", "cos", "theta", "sin", "theta", "tan", "z", "right", "1", "right", "right", "parameters", "solar_zenith", "numeric", "apparent", "refraction", "corrected", "solar", "zenith", "degrees", "solar_azimuth", "numeric", "solar", "azimuth", "degrees", "surface_tilt", "numeric", "row", "tilt", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degrees", "surface_azimuth", "numeric", "azimuth", "angle", "of", "the", "row", "surface", "north", "0", "east", "90", "south", "180", "west", "270", "degrees", "gcr", "numeric", "ground", "coverage", "ratio", "which", "is", "the", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "pitch", "unitless", "returns", "f_x", "numeric", "fraction", "of", "row", "slant", "height", "from", "the", "bottom", "that", "is", "shaded", "from", "direct", "irradiance", "references", "1", "mikofski", "m", "darawali", "r", "hamer", "m", "neubert", "a", "and", "newmiller", "j", "bifacial", "performance", "modeling", "in", "large", "arrays", "2019", "ieee", "46th", "photovoltaic", "specialists", "conference", "pvsc", "2019", "pp", "1282", "1287", "doi", "10", "1109", "pvsc40753", "2019", "8980572", "2", "kevin", "anderson", "and", "mark", "mikofski", "slope", "aware", "backtracking", "for", "single", "axis", "trackers", "technical", "report", "nrel", "tp", "5k00", "76626", "july", "2020", "https", "www", "nrel", "gov", "docs", "fy20osti", "76626", "pdf", "tan_phi", "utils", "_solar_projection_tangent", "solar_zenith", "solar_azimuth", "surface_azimuth", "length", "of", "shadow", "behind", "a", "row", "as", "a", "fraction", "of", "pitch", "x", "gcr", "sind", "surface_tilt", "tan_phi", "cosd", "surface_tilt", "f_x", "1", "1", "x", "set", "f_x", "to", "be", "1", "when", "sun", "is", "behind", "the", "array", "ao", "aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "f_x", "np", "where", "ao", "90", "f_x", "1", "when", "x", "1", "the", "shadow", "is", "not", "long", "enough", "to", "fall", "on", "the", "row", "surface", "f_x", "np", "where", "x", "1", "f_x", "0", "return", "f_x"], "doc_len": 304}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::get_irradiance_poa", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "get_irradiance_poa", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef get_irradiance_poa(surface_tilt, surface_azimuth, solar_zenith,\n                       solar_azimuth, gcr, height, pitch, ghi, dhi, dni,\n                       albedo, iam=1.0, npoints=100):\n    r\"\"\"\n    Calculate plane-of-array (POA) irradiance on one side of a row of modules.\n\n    The infinite sheds model [1] assumes the PV system comprises parallel,\n    evenly spaced rows on a level, horizontal surface. Rows can be on fixed\n    racking or single axis trackers. The model calculates irradiance at a\n    location far from the ends of any rows, in effect, assuming that the\n    rows (sheds) are infinitely long.\n\n    POA irradiance components include direct, diffuse and global (total).\n    Irradiance values are reduced to account for reflection of direct light,\n    but are not adjusted for solar spectrum or reduced by a module's\n    bifaciality factor.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Tilt of the surface from horizontal. Must be between 0 and 180. For\n        example, for a fixed tilt module mounted at 30 degrees from\n        horizontal, use ``surface_tilt=30`` to get front-side irradiance and\n        ``surface_tilt=150`` to get rear-side irradiance. [degree]\n\n    surface_azimuth : numeric\n        Surface azimuth in decimal degrees east of north\n        (e.g. North = 0, South = 180, East = 90, West = 270). [degree]\n\n    solar_zenith : numeric\n        Refraction-corrected solar zenith. [degree]\n\n    solar_azimuth : numeric\n        Solar azimuth. [degree]\n\n    gcr : float\n        Ground coverage ratio, ratio of row slant length to row spacing.\n        [unitless]\n\n    height : float\n        Height of the center point of the row above the ground; must be in the\n        same units as ``pitch``.\n\n    pitch : float\n        Distance between two rows; must be in the same units as ``height``.\n\n    ghi : numeric\n        Global horizontal irradiance. [W/m2]\n\n    dhi : numeric\n        Diffuse horizontal irradiance. [W/m2]\n\n    dni : numeric\n        Direct normal irradiance. [W/m2]\n\n    albedo : numeric\n        Surface albedo. [unitless]\n\n    iam : numeric, default 1.0\n        Incidence angle modifier, the fraction of direct irradiance incident\n        on the surface that is not reflected away. [unitless]\n\n    npoints : int, default 100\n        Number of points used to discretize distance along the ground.\n\n    Returns\n    -------\n    output : dict or DataFrame\n        Output is a DataFrame when input ghi is a Series. See Notes for\n        descriptions of content.\n\n    Notes\n    -----\n    Input parameters ``height`` and ``pitch`` must have the same unit.\n\n    ``output`` always includes:\n\n    - ``poa_global`` : total POA irradiance. [W/m^2]\n    - ``poa_diffuse`` : total diffuse POA irradiance from all sources. [W/m^2]\n    - ``poa_direct`` : total direct POA irradiance. [W/m^2]\n    - ``poa_sky_diffuse`` : total sky diffuse irradiance on the plane of array.\n      [W/m^2]\n    - ``poa_ground_diffuse`` : total ground-reflected diffuse irradiance on the\n      plane of array. [W/m^2]\n\n    References\n    ----------\n    .. [1] Mikofski, M., Darawali, R., Hamer, M., Neubert, A., and Newmiller,\n       J. \"Bifacial Performance Modeling in Large Arrays\". 2019 IEEE 46th\n       Photovoltaic Specialists Conference (PVSC), 2019, pp. 1282-1287.\n       :doi:`10.1109/PVSC40753.2019.8980572`.\n\n    See also\n    --------\n    get_irradiance\n    \"\"\"\n    # Calculate some geometric quantities\n    # rows to consider in front and behind current row\n    # ensures that view factors to the sky are computed to within 5 degrees\n    # of the horizon\n    max_rows = np.ceil(height / (pitch * tand(5)))\n    # fraction of ground between rows that is illuminated accounting for\n    # shade from panels. [1], Eq. 4\n    f_gnd_beam = utils._unshaded_ground_fraction(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth, gcr)\n    # integrated view factor from the ground to the sky, integrated between\n    # adjacent rows interior to the array\n    # method differs from [1], Eq. 7 and Eq. 8; height is defined at row\n    # center rather than at row lower edge as in [1].\n    vf_gnd_sky = _vf_ground_sky_integ(\n        surface_tilt, surface_azimuth, gcr, height, pitch, max_rows, npoints)\n    # fraction of row slant height that is shaded from direct irradiance\n    f_x = _shaded_fraction(solar_zenith, solar_azimuth, surface_tilt,\n                           surface_azimuth, gcr)\n\n    # Integrated view factors to the sky from the shaded and unshaded parts of\n    # the row slant height\n    # Differs from [1] Eq. 15 and Eq. 16. Here, we integrate over each\n    # interval (shaded or unshaded) rather than averaging values at each\n    # interval's end points.\n    vf_shade_sky, vf_noshade_sky = _vf_row_sky_integ(\n        f_x, surface_tilt, gcr, npoints)\n\n    # view factors from the ground to shaded and unshaded portions of the row\n    # slant height\n    # Differs from [1] Eq. 17 and Eq. 18. Here, we integrate over each\n    # interval (shaded or unshaded) rather than averaging values at each\n    # interval's end points.\n    f_gnd_pv_shade, f_gnd_pv_noshade = _vf_row_ground_integ(\n        f_x, surface_tilt, gcr, npoints)\n\n    # Total sky diffuse received by both shaded and unshaded portions\n    poa_sky_pv = _poa_sky_diffuse_pv(\n        f_x, dhi, vf_shade_sky, vf_noshade_sky)\n\n    # irradiance reflected from the ground before accounting for shadows\n    # and restricted views\n    # this is a deviation from [1], because the row to ground view factor\n    # is accounted for in a different manner\n    ground_diffuse = ghi * albedo\n\n    # diffuse fraction\n    diffuse_fraction = np.clip(dhi / ghi, 0., 1.)\n    # make diffuse fraction 0 when ghi is small\n    diffuse_fraction = np.where(ghi < 0.0001, 0., diffuse_fraction)\n\n    # Reduce ground-reflected irradiance because other rows in the array\n    # block irradiance from reaching the ground.\n    # [2], Eq. 9\n    ground_diffuse = _poa_ground_shadows(\n        ground_diffuse, f_gnd_beam, diffuse_fraction, vf_gnd_sky)\n\n    # Ground-reflected irradiance on the row surface accounting for\n    # the view to the ground. This deviates from [1], Eq. 10, 11 and\n    # subsequent. Here, the row to ground view factor is computed. In [1],\n    # the usual ground-reflected irradiance includes the single row to ground\n    # view factor (1 - cos(tilt))/2, and Eq. 10, 11 and later multiply\n    # this quantity by a ratio of view factors.\n    poa_gnd_pv = _poa_ground_pv(\n        f_x, ground_diffuse, f_gnd_pv_shade, f_gnd_pv_noshade)\n\n    # add sky and ground-reflected irradiance on the row by irradiance\n    # component\n    poa_diffuse = poa_gnd_pv + poa_sky_pv\n    # beam on plane, make an array for consistency with poa_diffuse\n    poa_beam = np.atleast_1d(beam_component(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth, dni))\n    poa_direct = poa_beam * (1 - f_x) * iam  # direct only on the unshaded part\n    poa_global = poa_direct + poa_diffuse\n\n    output = {\n        'poa_global': poa_global, 'poa_direct': poa_direct,\n        'poa_diffuse': poa_diffuse, 'poa_ground_diffuse': poa_gnd_pv,\n        'poa_sky_diffuse': poa_sky_pv}\n    if isinstance(poa_global, pd.Series):\n        output = pd.DataFrame(output)\n    return output\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "get_irradiance_poa", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam", "1", "0", "npoints", "100", "r", "calculate", "plane", "of", "array", "poa", "irradiance", "on", "one", "side", "of", "a", "row", "of", "modules", "the", "infinite", "sheds", "model", "1", "assumes", "the", "pv", "system", "comprises", "parallel", "evenly", "spaced", "rows", "on", "a", "level", "horizontal", "surface", "rows", "can", "be", "on", "fixed", "racking", "or", "single", "axis", "trackers", "the", "model", "calculates", "irradiance", "at", "a", "location", "far", "from", "the", "ends", "of", "any", "rows", "in", "effect", "assuming", "that", "the", "rows", "sheds", "are", "infinitely", "long", "poa", "irradiance", "components", "include", "direct", "diffuse", "and", "global", "total", "irradiance", "values", "are", "reduced", "to", "account", "for", "reflection", "of", "direct", "light", "but", "are", "not", "adjusted", "for", "solar", "spectrum", "or", "reduced", "by", "a", "module", "s", "bifaciality", "factor", "parameters", "surface_tilt", "numeric", "tilt", "of", "the", "surface", "from", "horizontal", "must", "be", "between", "0", "and", "180", "for", "example", "for", "a", "fixed", "tilt", "module", "mounted", "at", "30", "degrees", "from", "horizontal", "use", "surface_tilt", "30", "to", "get", "front", "side", "irradiance", "and", "surface_tilt", "150", "to", "get", "rear", "side", "irradiance", "degree", "surface_azimuth", "numeric", "surface", "azimuth", "in", "decimal", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "degree", "solar_zenith", "numeric", "refraction", "corrected", "solar", "zenith", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "degree", "gcr", "float", "ground", "coverage", "ratio", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "unitless", "height", "float", "height", "of", "the", "center", "point", "of", "the", "row", "above", "the", "ground", "must", "be", "in", "the", "same", "units", "as", "pitch", "pitch", "float", "distance", "between", "two", "rows", "must", "be", "in", "the", "same", "units", "as", "height", "ghi", "numeric", "global", "horizontal", "irradiance", "w", "m2", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "w", "m2", "dni", "numeric", "direct", "normal", "irradiance", "w", "m2", "albedo", "numeric", "surface", "albedo", "unitless", "iam", "numeric", "default", "1", "0", "incidence", "angle", "modifier", "the", "fraction", "of", "direct", "irradiance", "incident", "on", "the", "surface", "that", "is", "not", "reflected", "away", "unitless", "npoints", "int", "default", "100", "number", "of", "points", "used", "to", "discretize", "distance", "along", "the", "ground", "returns", "output", "dict", "or", "dataframe", "output", "is", "a", "dataframe", "when", "input", "ghi", "is", "a", "series", "see", "notes", "for", "descriptions", "of", "content", "notes", "input", "parameters", "height", "and", "pitch", "must", "have", "the", "same", "unit", "output", "always", "includes", "poa_global", "total", "poa", "irradiance", "w", "m", "2", "poa_diffuse", "total", "diffuse", "poa", "irradiance", "from", "all", "sources", "w", "m", "2", "poa_direct", "total", "direct", "poa", "irradiance", "w", "m", "2", "poa_sky_diffuse", "total", "sky", "diffuse", "irradiance", "on", "the", "plane", "of", "array", "w", "m", "2", "poa_ground_diffuse", "total", "ground", "reflected", "diffuse", "irradiance", "on", "the", "plane", "of", "array", "w", "m", "2", "references", "1", "mikofski", "m", "darawali", "r", "hamer", "m", "neubert", "a", "and", "newmiller", "j", "bifacial", "performance", "modeling", "in", "large", "arrays", "2019", "ieee", "46th", "photovoltaic", "specialists", "conference", "pvsc", "2019", "pp", "1282", "1287", "doi", "10", "1109", "pvsc40753", "2019", "8980572", "see", "also", "get_irradiance", "calculate", "some", "geometric", "quantities", "rows", "to", "consider", "in", "front", "and", "behind", "current", "row", "ensures", "that", "view", "factors", "to", "the", "sky", "are", "computed", "to", "within", "5", "degrees", "of", "the", "horizon", "max_rows", "np", "ceil", "height", "pitch", "tand", "5", "fraction", "of", "ground", "between", "rows", "that", "is", "illuminated", "accounting", "for", "shade", "from", "panels", "1", "eq", "4", "f_gnd_beam", "utils", "_unshaded_ground_fraction", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "integrated", "view", "factor", "from", "the", "ground", "to", "the", "sky", "integrated", "between", "adjacent", "rows", "interior", "to", "the", "array", "method", "differs", "from", "1", "eq", "7", "and", "eq", "8", "height", "is", "defined", "at", "row", "center", "rather", "than", "at", "row", "lower", "edge", "as", "in", "1", "vf_gnd_sky", "_vf_ground_sky_integ", "surface_tilt", "surface_azimuth", "gcr", "height", "pitch", "max_rows", "npoints", "fraction", "of", "row", "slant", "height", "that", "is", "shaded", "from", "direct", "irradiance", "f_x", "_shaded_fraction", "solar_zenith", "solar_azimuth", "surface_tilt", "surface_azimuth", "gcr", "integrated", "view", "factors", "to", "the", "sky", "from", "the", "shaded", "and", "unshaded", "parts", "of", "the", "row", "slant", "height", "differs", "from", "1", "eq", "15", "and", "eq", "16", "here", "we", "integrate", "over", "each", "interval", "shaded", "or", "unshaded", "rather", "than", "averaging", "values", "at", "each", "interval", "s", "end", "points", "vf_shade_sky", "vf_noshade_sky", "_vf_row_sky_integ", "f_x", "surface_tilt", "gcr", "npoints", "view", "factors", "from", "the", "ground", "to", "shaded", "and", "unshaded", "portions", "of", "the", "row", "slant", "height", "differs", "from", "1", "eq", "17", "and", "eq", "18", "here", "we", "integrate", "over", "each", "interval", "shaded", "or", "unshaded", "rather", "than", "averaging", "values", "at", "each", "interval", "s", "end", "points", "f_gnd_pv_shade", "f_gnd_pv_noshade", "_vf_row_ground_integ", "f_x", "surface_tilt", "gcr", "npoints", "total", "sky", "diffuse", "received", "by", "both", "shaded", "and", "unshaded", "portions", "poa_sky_pv", "_poa_sky_diffuse_pv", "f_x", "dhi", "vf_shade_sky", "vf_noshade_sky", "irradiance", "reflected", "from", "the", "ground", "before", "accounting", "for", "shadows", "and", "restricted", "views", "this", "is", "a", "deviation", "from", "1", "because", "the", "row", "to", "ground", "view", "factor", "is", "accounted", "for", "in", "a", "different", "manner", "ground_diffuse", "ghi", "albedo", "diffuse", "fraction", "diffuse_fraction", "np", "clip", "dhi", "ghi", "0", "1", "make", "diffuse", "fraction", "0", "when", "ghi", "is", "small", "diffuse_fraction", "np", "where", "ghi", "0", "0001", "0", "diffuse_fraction", "reduce", "ground", "reflected", "irradiance", "because", "other", "rows", "in", "the", "array", "block", "irradiance", "from", "reaching", "the", "ground", "2", "eq", "9", "ground_diffuse", "_poa_ground_shadows", "ground_diffuse", "f_gnd_beam", "diffuse_fraction", "vf_gnd_sky", "ground", "reflected", "irradiance", "on", "the", "row", "surface", "accounting", "for", "the", "view", "to", "the", "ground", "this", "deviates", "from", "1", "eq", "10", "11", "and", "subsequent", "here", "the", "row", "to", "ground", "view", "factor", "is", "computed", "in", "1", "the", "usual", "ground", "reflected", "irradiance", "includes", "the", "single", "row", "to", "ground", "view", "factor", "1", "cos", "tilt", "2", "and", "eq", "10", "11", "and", "later", "multiply", "this", "quantity", "by", "a", "ratio", "of", "view", "factors", "poa_gnd_pv", "_poa_ground_pv", "f_x", "ground_diffuse", "f_gnd_pv_shade", "f_gnd_pv_noshade", "add", "sky", "and", "ground", "reflected", "irradiance", "on", "the", "row", "by", "irradiance", "component", "poa_diffuse", "poa_gnd_pv", "poa_sky_pv", "beam", "on", "plane", "make", "an", "array", "for", "consistency", "with", "poa_diffuse", "poa_beam", "np", "atleast_1d", "beam_component", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "dni", "poa_direct", "poa_beam", "1", "f_x", "iam", "direct", "only", "on", "the", "unshaded", "part", "poa_global", "poa_direct", "poa_diffuse", "output", "poa_global", "poa_global", "poa_direct", "poa_direct", "poa_diffuse", "poa_diffuse", "poa_ground_diffuse", "poa_gnd_pv", "poa_sky_diffuse", "poa_sky_pv", "if", "isinstance", "poa_global", "pd", "series", "output", "pd", "dataframe", "output", "return", "output"], "doc_len": 913}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::get_irradiance", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "get_irradiance", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef get_irradiance(surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n                   gcr, height, pitch, ghi, dhi, dni,\n                   albedo, iam_front=1.0, iam_back=1.0,\n                   bifaciality=0.8, shade_factor=-0.02,\n                   transmission_factor=0, npoints=100):\n    \"\"\"\n    Get front and rear irradiance using the infinite sheds model.\n\n    The infinite sheds model [1] assumes the PV system comprises parallel,\n    evenly spaced rows on a level, horizontal surface. Rows can be on fixed\n    racking or single axis trackers. The model calculates irradiance at a\n    location far from the ends of any rows, in effect, assuming that the\n    rows (sheds) are infinitely long.\n\n    The model accounts for the following effects:\n\n    - restricted view of the sky from module surfaces due to the nearby rows.\n    - restricted view of the ground from module surfaces due to nearby rows.\n    - restricted view of the sky from the ground due to rows.\n    - shading of module surfaces by nearby rows.\n    - shading of rear cells of a module by mounting structure and by\n      module features.\n\n    The model implicitly assumes that diffuse irradiance from the sky is\n    isotropic, and that module surfaces do not allow irradiance to transmit\n    through the module to the ground through gaps between cells.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Tilt from horizontal of the front-side surface. [degree]\n\n    surface_azimuth : numeric\n        Surface azimuth in decimal degrees east of north\n        (e.g. North = 0, South = 180, East = 90, West = 270). [degree]\n\n    solar_zenith : numeric\n        Refraction-corrected solar zenith. [degree]\n\n    solar_azimuth : numeric\n        Solar azimuth. [degree]\n\n    gcr : float\n        Ground coverage ratio, ratio of row slant length to row spacing.\n        [unitless]\n\n    height : float\n        Height of the center point of the row above the ground; must be in the\n        same units as ``pitch``.\n\n    pitch : float\n        Distance between two rows; must be in the same units as ``height``.\n\n    ghi : numeric\n        Global horizontal irradiance. [W/m2]\n\n    dhi : numeric\n        Diffuse horizontal irradiance. [W/m2]\n\n    dni : numeric\n        Direct normal irradiance. [W/m2]\n\n    albedo : numeric\n        Surface albedo. [unitless]\n\n    iam_front : numeric, default 1.0\n        Incidence angle modifier, the fraction of direct irradiance incident\n        on the front surface that is not reflected away. [unitless]\n\n    iam_back : numeric, default 1.0\n        Incidence angle modifier, the fraction of direct irradiance incident\n        on the back surface that is not reflected away. [unitless]\n\n    bifaciality : numeric, default 0.8\n        Ratio of the efficiency of the module's rear surface to the efficiency\n        of the front surface. [unitless]\n\n    shade_factor : numeric, default -0.02\n        Fraction of back surface irradiance that is blocked by array mounting\n        structures. Negative value is a reduction in back irradiance.\n        [unitless]\n\n    transmission_factor : numeric, default 0.0\n        Fraction of irradiance on the back surface that does not reach the\n        module's cells due to module features such as busbars, junction box,\n        etc. A negative value is a reduction in back irradiance. [unitless]\n\n    npoints : int, default 100\n        Number of points used to discretize distance along the ground.\n\n    Returns\n    -------\n    output : dict or DataFrame\n        Output is a DataFrame when input ghi is a Series. See Notes for\n        descriptions of content.\n\n    Notes\n    -----\n\n    ``output`` includes:\n\n    - ``poa_global`` : total irradiance reaching the module cells from both\n      front and back surfaces. [W/m^2]\n    - ``poa_front`` : total irradiance reaching the module cells from the front\n      surface. [W/m^2]\n    - ``poa_back`` : total irradiance reaching the module cells from the back\n      surface. [W/m^2]\n    - ``poa_front_direct`` : direct irradiance reaching the module cells from\n      the front surface. [W/m^2]\n    - ``poa_front_diffuse`` : total diffuse irradiance reaching the module\n      cells from the front surface. [W/m^2]\n    - ``poa_front_sky_diffuse`` : sky diffuse irradiance reaching the module\n      cells from the front surface. [W/m^2]\n    - ``poa_front_ground_diffuse`` : ground-reflected diffuse irradiance\n      reaching the module cells from the front surface. [W/m^2]\n    - ``poa_back_direct`` : direct irradiance reaching the module cells from\n      the back surface. [W/m^2]\n    - ``poa_back_diffuse`` : total diffuse irradiance reaching the module\n      cells from the back surface. [W/m^2]\n    - ``poa_back_sky_diffuse`` : sky diffuse irradiance reaching the module\n      cells from the back surface. [W/m^2]\n    - ``poa_back_ground_diffuse`` : ground-reflected diffuse irradiance\n      reaching the module cells from the back surface. [W/m^2]\n\n    References\n    ----------\n    .. [1] Mikofski, M., Darawali, R., Hamer, M., Neubert, A., and Newmiller,\n       J. \"Bifacial Performance Modeling in Large Arrays\". 2019 IEEE 46th\n       Photovoltaic Specialists Conference (PVSC), 2019, pp. 1282-1287.\n       :doi:`10.1109/PVSC40753.2019.8980572`.\n\n    See also\n    --------\n    get_irradiance_poa\n    \"\"\"\n    # backside is rotated and flipped relative to front\n    backside_tilt, backside_sysaz = _backside(surface_tilt, surface_azimuth)\n    # front side POA irradiance\n    irrad_front = get_irradiance_poa(\n        surface_tilt=surface_tilt, surface_azimuth=surface_azimuth,\n        solar_zenith=solar_zenith, solar_azimuth=solar_azimuth,\n        gcr=gcr, height=height, pitch=pitch, ghi=ghi, dhi=dhi, dni=dni,\n        albedo=albedo, iam=iam_front, npoints=npoints)\n    # back side POA irradiance\n    irrad_back = get_irradiance_poa(\n        surface_tilt=backside_tilt, surface_azimuth=backside_sysaz,\n        solar_zenith=solar_zenith, solar_azimuth=solar_azimuth,\n        gcr=gcr, height=height, pitch=pitch, ghi=ghi, dhi=dhi, dni=dni,\n        albedo=albedo, iam=iam_back, npoints=npoints)\n\n    colmap_front = {\n        'poa_global': 'poa_front',\n        'poa_direct': 'poa_front_direct',\n        'poa_diffuse': 'poa_front_diffuse',\n        'poa_sky_diffuse': 'poa_front_sky_diffuse',\n        'poa_ground_diffuse': 'poa_front_ground_diffuse',\n    }\n    colmap_back = {\n        'poa_global': 'poa_back',\n        'poa_direct': 'poa_back_direct',\n        'poa_diffuse': 'poa_back_diffuse',\n        'poa_sky_diffuse': 'poa_back_sky_diffuse',\n        'poa_ground_diffuse': 'poa_back_ground_diffuse',\n    }\n\n    if isinstance(ghi, pd.Series):\n        irrad_front = irrad_front.rename(columns=colmap_front)\n        irrad_back = irrad_back.rename(columns=colmap_back)\n        output = pd.concat([irrad_front, irrad_back], axis=1)\n    else:\n        for old_key, new_key in colmap_front.items():\n            irrad_front[new_key] = irrad_front.pop(old_key)\n        for old_key, new_key in colmap_back.items():\n            irrad_back[new_key] = irrad_back.pop(old_key)\n        irrad_front.update(irrad_back)\n        output = irrad_front\n\n    effects = (1 + shade_factor) * (1 + transmission_factor)\n    output['poa_global'] = output['poa_front'] + \\\n        output['poa_back'] * bifaciality * effects\n    return output\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "get_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam_front", "1", "0", "iam_back", "1", "0", "bifaciality", "0", "8", "shade_factor", "0", "02", "transmission_factor", "0", "npoints", "100", "get", "front", "and", "rear", "irradiance", "using", "the", "infinite", "sheds", "model", "the", "infinite", "sheds", "model", "1", "assumes", "the", "pv", "system", "comprises", "parallel", "evenly", "spaced", "rows", "on", "a", "level", "horizontal", "surface", "rows", "can", "be", "on", "fixed", "racking", "or", "single", "axis", "trackers", "the", "model", "calculates", "irradiance", "at", "a", "location", "far", "from", "the", "ends", "of", "any", "rows", "in", "effect", "assuming", "that", "the", "rows", "sheds", "are", "infinitely", "long", "the", "model", "accounts", "for", "the", "following", "effects", "restricted", "view", "of", "the", "sky", "from", "module", "surfaces", "due", "to", "the", "nearby", "rows", "restricted", "view", "of", "the", "ground", "from", "module", "surfaces", "due", "to", "nearby", "rows", "restricted", "view", "of", "the", "sky", "from", "the", "ground", "due", "to", "rows", "shading", "of", "module", "surfaces", "by", "nearby", "rows", "shading", "of", "rear", "cells", "of", "a", "module", "by", "mounting", "structure", "and", "by", "module", "features", "the", "model", "implicitly", "assumes", "that", "diffuse", "irradiance", "from", "the", "sky", "is", "isotropic", "and", "that", "module", "surfaces", "do", "not", "allow", "irradiance", "to", "transmit", "through", "the", "module", "to", "the", "ground", "through", "gaps", "between", "cells", "parameters", "surface_tilt", "numeric", "tilt", "from", "horizontal", "of", "the", "front", "side", "surface", "degree", "surface_azimuth", "numeric", "surface", "azimuth", "in", "decimal", "degrees", "east", "of", "north", "e", "g", "north", "0", "south", "180", "east", "90", "west", "270", "degree", "solar_zenith", "numeric", "refraction", "corrected", "solar", "zenith", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "degree", "gcr", "float", "ground", "coverage", "ratio", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "unitless", "height", "float", "height", "of", "the", "center", "point", "of", "the", "row", "above", "the", "ground", "must", "be", "in", "the", "same", "units", "as", "pitch", "pitch", "float", "distance", "between", "two", "rows", "must", "be", "in", "the", "same", "units", "as", "height", "ghi", "numeric", "global", "horizontal", "irradiance", "w", "m2", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "w", "m2", "dni", "numeric", "direct", "normal", "irradiance", "w", "m2", "albedo", "numeric", "surface", "albedo", "unitless", "iam_front", "numeric", "default", "1", "0", "incidence", "angle", "modifier", "the", "fraction", "of", "direct", "irradiance", "incident", "on", "the", "front", "surface", "that", "is", "not", "reflected", "away", "unitless", "iam_back", "numeric", "default", "1", "0", "incidence", "angle", "modifier", "the", "fraction", "of", "direct", "irradiance", "incident", "on", "the", "back", "surface", "that", "is", "not", "reflected", "away", "unitless", "bifaciality", "numeric", "default", "0", "8", "ratio", "of", "the", "efficiency", "of", "the", "module", "s", "rear", "surface", "to", "the", "efficiency", "of", "the", "front", "surface", "unitless", "shade_factor", "numeric", "default", "0", "02", "fraction", "of", "back", "surface", "irradiance", "that", "is", "blocked", "by", "array", "mounting", "structures", "negative", "value", "is", "a", "reduction", "in", "back", "irradiance", "unitless", "transmission_factor", "numeric", "default", "0", "0", "fraction", "of", "irradiance", "on", "the", "back", "surface", "that", "does", "not", "reach", "the", "module", "s", "cells", "due", "to", "module", "features", "such", "as", "busbars", "junction", "box", "etc", "a", "negative", "value", "is", "a", "reduction", "in", "back", "irradiance", "unitless", "npoints", "int", "default", "100", "number", "of", "points", "used", "to", "discretize", "distance", "along", "the", "ground", "returns", "output", "dict", "or", "dataframe", "output", "is", "a", "dataframe", "when", "input", "ghi", "is", "a", "series", "see", "notes", "for", "descriptions", "of", "content", "notes", "output", "includes", "poa_global", "total", "irradiance", "reaching", "the", "module", "cells", "from", "both", "front", "and", "back", "surfaces", "w", "m", "2", "poa_front", "total", "irradiance", "reaching", "the", "module", "cells", "from", "the", "front", "surface", "w", "m", "2", "poa_back", "total", "irradiance", "reaching", "the", "module", "cells", "from", "the", "back", "surface", "w", "m", "2", "poa_front_direct", "direct", "irradiance", "reaching", "the", "module", "cells", "from", "the", "front", "surface", "w", "m", "2", "poa_front_diffuse", "total", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "front", "surface", "w", "m", "2", "poa_front_sky_diffuse", "sky", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "front", "surface", "w", "m", "2", "poa_front_ground_diffuse", "ground", "reflected", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "front", "surface", "w", "m", "2", "poa_back_direct", "direct", "irradiance", "reaching", "the", "module", "cells", "from", "the", "back", "surface", "w", "m", "2", "poa_back_diffuse", "total", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "back", "surface", "w", "m", "2", "poa_back_sky_diffuse", "sky", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "back", "surface", "w", "m", "2", "poa_back_ground_diffuse", "ground", "reflected", "diffuse", "irradiance", "reaching", "the", "module", "cells", "from", "the", "back", "surface", "w", "m", "2", "references", "1", "mikofski", "m", "darawali", "r", "hamer", "m", "neubert", "a", "and", "newmiller", "j", "bifacial", "performance", "modeling", "in", "large", "arrays", "2019", "ieee", "46th", "photovoltaic", "specialists", "conference", "pvsc", "2019", "pp", "1282", "1287", "doi", "10", "1109", "pvsc40753", "2019", "8980572", "see", "also", "get_irradiance_poa", "backside", "is", "rotated", "and", "flipped", "relative", "to", "front", "backside_tilt", "backside_sysaz", "_backside", "surface_tilt", "surface_azimuth", "front", "side", "poa", "irradiance", "irrad_front", "get_irradiance_poa", "surface_tilt", "surface_tilt", "surface_azimuth", "surface_azimuth", "solar_zenith", "solar_zenith", "solar_azimuth", "solar_azimuth", "gcr", "gcr", "height", "height", "pitch", "pitch", "ghi", "ghi", "dhi", "dhi", "dni", "dni", "albedo", "albedo", "iam", "iam_front", "npoints", "npoints", "back", "side", "poa", "irradiance", "irrad_back", "get_irradiance_poa", "surface_tilt", "backside_tilt", "surface_azimuth", "backside_sysaz", "solar_zenith", "solar_zenith", "solar_azimuth", "solar_azimuth", "gcr", "gcr", "height", "height", "pitch", "pitch", "ghi", "ghi", "dhi", "dhi", "dni", "dni", "albedo", "albedo", "iam", "iam_back", "npoints", "npoints", "colmap_front", "poa_global", "poa_front", "poa_direct", "poa_front_direct", "poa_diffuse", "poa_front_diffuse", "poa_sky_diffuse", "poa_front_sky_diffuse", "poa_ground_diffuse", "poa_front_ground_diffuse", "colmap_back", "poa_global", "poa_back", "poa_direct", "poa_back_direct", "poa_diffuse", "poa_back_diffuse", "poa_sky_diffuse", "poa_back_sky_diffuse", "poa_ground_diffuse", "poa_back_ground_diffuse", "if", "isinstance", "ghi", "pd", "series", "irrad_front", "irrad_front", "rename", "columns", "colmap_front", "irrad_back", "irrad_back", "rename", "columns", "colmap_back", "output", "pd", "concat", "irrad_front", "irrad_back", "axis", "1", "else", "for", "old_key", "new_key", "in", "colmap_front", "items", "irrad_front", "new_key", "irrad_front", "pop", "old_key", "for", "old_key", "new_key", "in", "colmap_back", "items", "irrad_back", "new_key", "irrad_back", "pop", "old_key", "irrad_front", "update", "irrad_back", "output", "irrad_front", "effects", "1", "shade_factor", "1", "transmission_factor", "output", "poa_global", "output", "poa_front", "output", "poa_back", "bifaciality", "effects", "return", "output"], "doc_len": 854}
{"doc_id": "pvlib/bifacial/infinite_sheds.py::_backside", "file_path": "pvlib/bifacial/infinite_sheds.py", "class_name": null, "func_name": "_backside", "text": "文件路径: pvlib/bifacial/infinite_sheds.py\ndef _backside(tilt, surface_azimuth):\n    backside_tilt = 180. - tilt\n    backside_sysaz = (180. + surface_azimuth) % 360.\n    return backside_tilt, backside_sysaz\n", "tokens": ["pvlib", "bifacial", "infinite_sheds", "py", "def", "_backside", "tilt", "surface_azimuth", "backside_tilt", "180", "tilt", "backside_sysaz", "180", "surface_azimuth", "360", "return", "backside_tilt", "backside_sysaz"], "doc_len": 18}
{"doc_id": "pvlib/bifacial/pvfactors.py::pvfactors_timeseries", "file_path": "pvlib/bifacial/pvfactors.py", "class_name": null, "func_name": "pvfactors_timeseries", "text": "文件路径: pvlib/bifacial/pvfactors.py\ndef pvfactors_timeseries(\n        solar_azimuth, solar_zenith, surface_azimuth, surface_tilt,\n        axis_azimuth, timestamps, dni, dhi, gcr, pvrow_height, pvrow_width,\n        albedo, n_pvrows=3, index_observed_pvrow=1,\n        rho_front_pvrow=0.03, rho_back_pvrow=0.05,\n        horizon_band_angle=15.):\n    \"\"\"\n    Calculate front and back surface plane-of-array irradiance on\n    a fixed tilt or single-axis tracker PV array configuration, and using\n    the open-source \"pvfactors\" package.  pvfactors implements the model\n    described in [1]_.\n    Please refer to pvfactors online documentation for more details:\n    https://sunpower.github.io/pvfactors/\n\n    Parameters\n    ----------\n    solar_azimuth: numeric\n        Sun's azimuth angles using pvlib's azimuth convention (deg)\n    solar_zenith: numeric\n        Sun's zenith angles (deg)\n    surface_azimuth: numeric\n        Azimuth angle of the front surface of the PV modules, using pvlib's\n        convention (deg)\n    surface_tilt: numeric\n        Tilt angle of the PV modules, going from 0 to 180 (deg)\n    axis_azimuth: float\n        Azimuth angle of the rotation axis of the PV modules, using pvlib's\n        convention (deg). This is supposed to be fixed for all timestamps.\n        When modeling fixed-tilt arrays, set this value to be 90 degrees\n        clockwise from ``surface_azimuth``.\n    timestamps: datetime or DatetimeIndex\n        List of simulation timestamps\n    dni: numeric\n        Direct normal irradiance (W/m2)\n    dhi: numeric\n        Diffuse horizontal irradiance (W/m2)\n    gcr: float\n        Ground coverage ratio of the pv array\n    pvrow_height: float\n        Height of the pv rows, measured at their center (m)\n    pvrow_width: float\n        Width of the pv rows in the considered 2D plane (m)\n    albedo: float\n        Ground albedo\n    n_pvrows: int, default 3\n        Number of PV rows to consider in the PV array\n    index_observed_pvrow: int, default 1\n        Index of the PV row whose incident irradiance will be returned. Indices\n        of PV rows go from 0 to n_pvrows-1.\n    rho_front_pvrow: float, default 0.03\n        Front surface reflectivity of PV rows\n    rho_back_pvrow: float, default 0.05\n        Back surface reflectivity of PV rows\n    horizon_band_angle: float, default 15\n        Elevation angle of the sky dome's diffuse horizon band (deg)\n\n    Returns\n    -------\n    poa_front: numeric\n        Calculated incident irradiance on the front surface of the PV modules\n        (W/m2)\n    poa_back: numeric\n        Calculated incident irradiance on the back surface of the PV modules\n        (W/m2)\n    poa_front_absorbed: numeric\n        Calculated absorbed irradiance on the front surface of the PV modules\n        (W/m2), after AOI losses\n    poa_back_absorbed: numeric\n        Calculated absorbed irradiance on the back surface of the PV modules\n        (W/m2), after AOI losses\n\n    References\n    ----------\n    .. [1] Anoma, Marc Abou, et al. \"View Factor Model and Validation for\n        Bifacial PV and Diffuse Shade on Single-Axis Trackers.\" 44th IEEE\n        Photovoltaic Specialist Conference. 2017.\n    \"\"\"\n    # Convert Series, list, float inputs to numpy arrays\n    solar_azimuth = np.array(solar_azimuth)\n    solar_zenith = np.array(solar_zenith)\n    dni = np.array(dni)\n    dhi = np.array(dhi)\n    # GH 1127, GH 1332\n    surface_tilt = np.full_like(solar_zenith, surface_tilt)\n    surface_azimuth = np.full_like(solar_zenith, surface_azimuth)\n\n    # Import pvfactors functions for timeseries calculations.\n    from pvfactors.run import run_timeseries_engine\n\n    # Build up pv array configuration parameters\n    pvarray_parameters = {\n        'n_pvrows': n_pvrows,\n        'axis_azimuth': axis_azimuth,\n        'pvrow_height': pvrow_height,\n        'pvrow_width': pvrow_width,\n        'gcr': gcr\n    }\n\n    irradiance_model_params = {\n        'rho_front': rho_front_pvrow,\n        'rho_back': rho_back_pvrow,\n        'horizon_band_angle': horizon_band_angle\n    }\n\n    # Create report function\n    def fn_build_report(pvarray):\n        return {'total_inc_back': pvarray.ts_pvrows[index_observed_pvrow]\n                .back.get_param_weighted('qinc'),\n                'total_inc_front': pvarray.ts_pvrows[index_observed_pvrow]\n                .front.get_param_weighted('qinc'),\n                'total_abs_back': pvarray.ts_pvrows[index_observed_pvrow]\n                .back.get_param_weighted('qabs'),\n                'total_abs_front': pvarray.ts_pvrows[index_observed_pvrow]\n                .front.get_param_weighted('qabs')}\n\n    # Run pvfactors calculations\n    report = run_timeseries_engine(\n        fn_build_report, pvarray_parameters,\n        timestamps, dni, dhi, solar_zenith, solar_azimuth,\n        surface_tilt, surface_azimuth, albedo,\n        irradiance_model_params=irradiance_model_params)\n\n    # Turn report into dataframe\n    df_report = pd.DataFrame(report, index=timestamps)\n\n    return (df_report.total_inc_front, df_report.total_inc_back,\n            df_report.total_abs_front, df_report.total_abs_back)\n", "tokens": ["pvlib", "bifacial", "pvfactors", "py", "def", "pvfactors_timeseries", "solar_azimuth", "solar_zenith", "surface_azimuth", "surface_tilt", "axis_azimuth", "timestamps", "dni", "dhi", "gcr", "pvrow_height", "pvrow_width", "albedo", "n_pvrows", "3", "index_observed_pvrow", "1", "rho_front_pvrow", "0", "03", "rho_back_pvrow", "0", "05", "horizon_band_angle", "15", "calculate", "front", "and", "back", "surface", "plane", "of", "array", "irradiance", "on", "a", "fixed", "tilt", "or", "single", "axis", "tracker", "pv", "array", "configuration", "and", "using", "the", "open", "source", "pvfactors", "package", "pvfactors", "implements", "the", "model", "described", "in", "1", "_", "please", "refer", "to", "pvfactors", "online", "documentation", "for", "more", "details", "https", "sunpower", "github", "io", "pvfactors", "parameters", "solar_azimuth", "numeric", "sun", "s", "azimuth", "angles", "using", "pvlib", "s", "azimuth", "convention", "deg", "solar_zenith", "numeric", "sun", "s", "zenith", "angles", "deg", "surface_azimuth", "numeric", "azimuth", "angle", "of", "the", "front", "surface", "of", "the", "pv", "modules", "using", "pvlib", "s", "convention", "deg", "surface_tilt", "numeric", "tilt", "angle", "of", "the", "pv", "modules", "going", "from", "0", "to", "180", "deg", "axis_azimuth", "float", "azimuth", "angle", "of", "the", "rotation", "axis", "of", "the", "pv", "modules", "using", "pvlib", "s", "convention", "deg", "this", "is", "supposed", "to", "be", "fixed", "for", "all", "timestamps", "when", "modeling", "fixed", "tilt", "arrays", "set", "this", "value", "to", "be", "90", "degrees", "clockwise", "from", "surface_azimuth", "timestamps", "datetime", "or", "datetimeindex", "list", "of", "simulation", "timestamps", "dni", "numeric", "direct", "normal", "irradiance", "w", "m2", "dhi", "numeric", "diffuse", "horizontal", "irradiance", "w", "m2", "gcr", "float", "ground", "coverage", "ratio", "of", "the", "pv", "array", "pvrow_height", "float", "height", "of", "the", "pv", "rows", "measured", "at", "their", "center", "m", "pvrow_width", "float", "width", "of", "the", "pv", "rows", "in", "the", "considered", "2d", "plane", "m", "albedo", "float", "ground", "albedo", "n_pvrows", "int", "default", "3", "number", "of", "pv", "rows", "to", "consider", "in", "the", "pv", "array", "index_observed_pvrow", "int", "default", "1", "index", "of", "the", "pv", "row", "whose", "incident", "irradiance", "will", "be", "returned", "indices", "of", "pv", "rows", "go", "from", "0", "to", "n_pvrows", "1", "rho_front_pvrow", "float", "default", "0", "03", "front", "surface", "reflectivity", "of", "pv", "rows", "rho_back_pvrow", "float", "default", "0", "05", "back", "surface", "reflectivity", "of", "pv", "rows", "horizon_band_angle", "float", "default", "15", "elevation", "angle", "of", "the", "sky", "dome", "s", "diffuse", "horizon", "band", "deg", "returns", "poa_front", "numeric", "calculated", "incident", "irradiance", "on", "the", "front", "surface", "of", "the", "pv", "modules", "w", "m2", "poa_back", "numeric", "calculated", "incident", "irradiance", "on", "the", "back", "surface", "of", "the", "pv", "modules", "w", "m2", "poa_front_absorbed", "numeric", "calculated", "absorbed", "irradiance", "on", "the", "front", "surface", "of", "the", "pv", "modules", "w", "m2", "after", "aoi", "losses", "poa_back_absorbed", "numeric", "calculated", "absorbed", "irradiance", "on", "the", "back", "surface", "of", "the", "pv", "modules", "w", "m2", "after", "aoi", "losses", "references", "1", "anoma", "marc", "abou", "et", "al", "view", "factor", "model", "and", "validation", "for", "bifacial", "pv", "and", "diffuse", "shade", "on", "single", "axis", "trackers", "44th", "ieee", "photovoltaic", "specialist", "conference", "2017", "convert", "series", "list", "float", "inputs", "to", "numpy", "arrays", "solar_azimuth", "np", "array", "solar_azimuth", "solar_zenith", "np", "array", "solar_zenith", "dni", "np", "array", "dni", "dhi", "np", "array", "dhi", "gh", "1127", "gh", "1332", "surface_tilt", "np", "full_like", "solar_zenith", "surface_tilt", "surface_azimuth", "np", "full_like", "solar_zenith", "surface_azimuth", "import", "pvfactors", "functions", "for", "timeseries", "calculations", "from", "pvfactors", "run", "import", "run_timeseries_engine", "build", "up", "pv", "array", "configuration", "parameters", "pvarray_parameters", "n_pvrows", "n_pvrows", "axis_azimuth", "axis_azimuth", "pvrow_height", "pvrow_height", "pvrow_width", "pvrow_width", "gcr", "gcr", "irradiance_model_params", "rho_front", "rho_front_pvrow", "rho_back", "rho_back_pvrow", "horizon_band_angle", "horizon_band_angle", "create", "report", "function", "def", "fn_build_report", "pvarray", "return", "total_inc_back", "pvarray", "ts_pvrows", "index_observed_pvrow", "back", "get_param_weighted", "qinc", "total_inc_front", "pvarray", "ts_pvrows", "index_observed_pvrow", "front", "get_param_weighted", "qinc", "total_abs_back", "pvarray", "ts_pvrows", "index_observed_pvrow", "back", "get_param_weighted", "qabs", "total_abs_front", "pvarray", "ts_pvrows", "index_observed_pvrow", "front", "get_param_weighted", "qabs", "run", "pvfactors", "calculations", "report", "run_timeseries_engine", "fn_build_report", "pvarray_parameters", "timestamps", "dni", "dhi", "solar_zenith", "solar_azimuth", "surface_tilt", "surface_azimuth", "albedo", "irradiance_model_params", "irradiance_model_params", "turn", "report", "into", "dataframe", "df_report", "pd", "dataframe", "report", "index", "timestamps", "return", "df_report", "total_inc_front", "df_report", "total_inc_back", "df_report", "total_abs_front", "df_report", "total_abs_back"], "doc_len": 546}
{"doc_id": "pvlib/bifacial/utils.py::_solar_projection_tangent", "file_path": "pvlib/bifacial/utils.py", "class_name": null, "func_name": "_solar_projection_tangent", "text": "文件路径: pvlib/bifacial/utils.py\ndef _solar_projection_tangent(solar_zenith, solar_azimuth, surface_azimuth):\n    \"\"\"\n    Tangent of the angle between the zenith vector and the sun vector\n    projected to the plane defined by the zenith vector and surface_azimuth.\n\n    .. math::\n        \\\\tan \\\\phi = \\\\cos\\\\left(\\\\text{solar azimuth}-\\\\text{system azimuth}\n        \\\\right)\\\\tan\\\\left(\\\\text{solar zenith}\\\\right)\n\n    Parameters\n    ----------\n    solar_zenith : numeric\n        Solar zenith angle. [degree].\n    solar_azimuth : numeric\n        Solar azimuth. [degree].\n    surface_azimuth : numeric\n        Azimuth of the module surface, i.e., North=0, East=90, South=180,\n        West=270. [degree]\n\n    Returns\n    -------\n    tan_phi : numeric\n        Tangent of the angle between vertical and the projection of the\n        sun direction onto the YZ plane.\n    \"\"\"\n    rotation = solar_azimuth - surface_azimuth\n    tan_phi = cosd(rotation) * tand(solar_zenith)\n    return tan_phi\n", "tokens": ["pvlib", "bifacial", "utils", "py", "def", "_solar_projection_tangent", "solar_zenith", "solar_azimuth", "surface_azimuth", "tangent", "of", "the", "angle", "between", "the", "zenith", "vector", "and", "the", "sun", "vector", "projected", "to", "the", "plane", "defined", "by", "the", "zenith", "vector", "and", "surface_azimuth", "math", "tan", "phi", "cos", "left", "text", "solar", "azimuth", "text", "system", "azimuth", "right", "tan", "left", "text", "solar", "zenith", "right", "parameters", "solar_zenith", "numeric", "solar", "zenith", "angle", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "degree", "surface_azimuth", "numeric", "azimuth", "of", "the", "module", "surface", "i", "e", "north", "0", "east", "90", "south", "180", "west", "270", "degree", "returns", "tan_phi", "numeric", "tangent", "of", "the", "angle", "between", "vertical", "and", "the", "projection", "of", "the", "sun", "direction", "onto", "the", "yz", "plane", "rotation", "solar_azimuth", "surface_azimuth", "tan_phi", "cosd", "rotation", "tand", "solar_zenith", "return", "tan_phi"], "doc_len": 110}
{"doc_id": "pvlib/bifacial/utils.py::_unshaded_ground_fraction", "file_path": "pvlib/bifacial/utils.py", "class_name": null, "func_name": "_unshaded_ground_fraction", "text": "文件路径: pvlib/bifacial/utils.py\ndef _unshaded_ground_fraction(surface_tilt, surface_azimuth, solar_zenith,\n                              solar_azimuth, gcr, max_zenith=87):\n    r\"\"\"\n    Calculate the fraction of the ground with incident direct irradiance.\n\n    .. math::\n        F_{gnd,sky} = 1 - \\min{\\left(1, \\text{GCR} \\left|\\cos \\beta +\n        \\sin \\beta \\tan \\phi \\right|\\right)}\n\n    where :math:`\\beta` is the surface tilt and :math:`\\phi` is the angle\n    from vertical of the sun vector projected to a vertical plane that\n    contains the row azimuth `surface_azimuth`.\n\n    Parameters\n    ----------\n    surface_tilt : numeric\n        Surface tilt angle. The tilt angle is defined as\n        degrees from horizontal, e.g., surface facing up = 0, surface facing\n        horizon = 90. [degree]\n    surface_azimuth : numeric\n        Azimuth of the module surface, i.e., North=0, East=90, South=180,\n        West=270. [degree]\n    solar_zenith : numeric\n        Solar zenith angle. [degree].\n    solar_azimuth : numeric\n        Solar azimuth. [degree].\n    gcr : float\n        Ground coverage ratio, which is the ratio of row slant length to row\n        spacing (pitch). [unitless]\n    max_zenith : numeric, default 87\n        Maximum zenith angle. For solar_zenith > max_zenith, unshaded ground\n        fraction is set to 0. [degree]\n\n    Returns\n    -------\n    f_gnd_beam : numeric\n        Fraction of distance betwen rows (pitch) with direct irradiance\n        (unshaded). [unitless]\n\n    References\n    ----------\n    .. [1] Mikofski, M., Darawali, R., Hamer, M., Neubert, A., and Newmiller,\n       J. \"Bifacial Performance Modeling in Large Arrays\". 2019 IEEE 46th\n       Photovoltaic Specialists Conference (PVSC), 2019, pp. 1282-1287.\n       doi: 10.1109/PVSC40753.2019.8980572.\n    \"\"\"\n    tan_phi = _solar_projection_tangent(solar_zenith, solar_azimuth,\n                                        surface_azimuth)\n    f_gnd_beam = 1.0 - np.minimum(\n        1.0, gcr * np.abs(cosd(surface_tilt) + sind(surface_tilt) * tan_phi))\n    np.where(solar_zenith > max_zenith, 0., f_gnd_beam)  # [1], Eq. 4\n    return f_gnd_beam  # 1 - min(1, abs()) < 1 always\n", "tokens": ["pvlib", "bifacial", "utils", "py", "def", "_unshaded_ground_fraction", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "max_zenith", "87", "r", "calculate", "the", "fraction", "of", "the", "ground", "with", "incident", "direct", "irradiance", "math", "f_", "gnd", "sky", "1", "min", "left", "1", "text", "gcr", "left", "cos", "beta", "sin", "beta", "tan", "phi", "right", "right", "where", "math", "beta", "is", "the", "surface", "tilt", "and", "math", "phi", "is", "the", "angle", "from", "vertical", "of", "the", "sun", "vector", "projected", "to", "a", "vertical", "plane", "that", "contains", "the", "row", "azimuth", "surface_azimuth", "parameters", "surface_tilt", "numeric", "surface", "tilt", "angle", "the", "tilt", "angle", "is", "defined", "as", "degrees", "from", "horizontal", "e", "g", "surface", "facing", "up", "0", "surface", "facing", "horizon", "90", "degree", "surface_azimuth", "numeric", "azimuth", "of", "the", "module", "surface", "i", "e", "north", "0", "east", "90", "south", "180", "west", "270", "degree", "solar_zenith", "numeric", "solar", "zenith", "angle", "degree", "solar_azimuth", "numeric", "solar", "azimuth", "degree", "gcr", "float", "ground", "coverage", "ratio", "which", "is", "the", "ratio", "of", "row", "slant", "length", "to", "row", "spacing", "pitch", "unitless", "max_zenith", "numeric", "default", "87", "maximum", "zenith", "angle", "for", "solar_zenith", "max_zenith", "unshaded", "ground", "fraction", "is", "set", "to", "0", "degree", "returns", "f_gnd_beam", "numeric", "fraction", "of", "distance", "betwen", "rows", "pitch", "with", "direct", "irradiance", "unshaded", "unitless", "references", "1", "mikofski", "m", "darawali", "r", "hamer", "m", "neubert", "a", "and", "newmiller", "j", "bifacial", "performance", "modeling", "in", "large", "arrays", "2019", "ieee", "46th", "photovoltaic", "specialists", "conference", "pvsc", "2019", "pp", "1282", "1287", "doi", "10", "1109", "pvsc40753", "2019", "8980572", "tan_phi", "_solar_projection_tangent", "solar_zenith", "solar_azimuth", "surface_azimuth", "f_gnd_beam", "1", "0", "np", "minimum", "1", "0", "gcr", "np", "abs", "cosd", "surface_tilt", "sind", "surface_tilt", "tan_phi", "np", "where", "solar_zenith", "max_zenith", "0", "f_gnd_beam", "1", "eq", "4", "return", "f_gnd_beam", "1", "min", "1", "abs", "1", "always"], "doc_len": 251}
{"doc_id": "pvlib/bifacial/utils.py::_vf_ground_sky_2d", "file_path": "pvlib/bifacial/utils.py", "class_name": null, "func_name": "_vf_ground_sky_2d", "text": "文件路径: pvlib/bifacial/utils.py\ndef _vf_ground_sky_2d(x, rotation, gcr, pitch, height, max_rows=10):\n    r\"\"\"\n    Calculate the fraction of the sky dome visible from point x on the ground.\n\n    The view factor accounts for the obstruction of the sky by array rows that\n    are assumed to be infinitely long.  View factors are thus calculated in\n    a 2D geometry. The ground is assumed to be flat and level.\n\n    Parameters\n    ----------\n    x : numeric\n        Position on the ground between two rows, as a fraction of the pitch.\n        x = 0 corresponds to the point on the ground directly below the\n        center point of a row. Positive x is towards the right. [unitless]\n    rotation : float\n        Rotation angle of the row's right edge relative to row center.\n        [degree]\n    gcr : float\n        Ratio of the row slant length to the row spacing (pitch). [unitless]\n    height : float\n        Height of the center point of the row above the ground; must be in the\n        same units as ``pitch``.\n    pitch : float\n        Distance between two rows; must be in the same units as ``height``.\n    max_rows : int, default 10\n        Maximum number of rows to consider on either side of the current\n        row. [unitless]\n\n    Returns\n    -------\n    vf : numeric\n        Fraction of sky dome visible from each point on the ground. [unitless]\n    wedge_angles : array\n        Angles defining each wedge of sky that is blocked by a row. Shape is\n        (2, len(x), 2*max_rows+1). ``wedge_angles[0,:,:]`` is the\n        starting angle of each wedge, ``wedge_angles[1,:,:]`` is the end angle.\n        [degree]\n    \"\"\"\n    x = np.atleast_1d(x)  # handle float\n    all_k = np.arange(-max_rows, max_rows + 1)\n    width = gcr * pitch / 2.\n    # angles from x to right edge of each row\n    a1 = height + width * sind(rotation)\n    b1 = (all_k - x[:, np.newaxis]) * pitch + width * cosd(rotation)\n    phi_1 = np.degrees(np.arctan2(a1, b1))\n    # angles from x to left edge of each row\n    a2 = height - width * sind(rotation)\n    b2 = (all_k - x[:, np.newaxis]) * pitch - width * cosd(rotation)\n    phi_2 = np.degrees(np.arctan2(a2, b2))\n    phi = np.stack([phi_1, phi_2])\n    swap = phi[0, :, :] > phi[1, :, :]\n    # swap where phi_1 > phi_2 so that phi_1[0,:,:] is the lesser angle\n    phi = np.where(swap, phi[::-1], phi)\n    # right edge of next row - left edge of previous row\n    wedge_vfs = 0.5 * (cosd(phi[1, :, 1:]) - cosd(phi[0, :, :-1]))\n    vf = np.sum(np.where(wedge_vfs > 0, wedge_vfs, 0.), axis=1)\n    return vf, phi\n", "tokens": ["pvlib", "bifacial", "utils", "py", "def", "_vf_ground_sky_2d", "x", "rotation", "gcr", "pitch", "height", "max_rows", "10", "r", "calculate", "the", "fraction", "of", "the", "sky", "dome", "visible", "from", "point", "x", "on", "the", "ground", "the", "view", "factor", "accounts", "for", "the", "obstruction", "of", "the", "sky", "by", "array", "rows", "that", "are", "assumed", "to", "be", "infinitely", "long", "view", "factors", "are", "thus", "calculated", "in", "a", "2d", "geometry", "the", "ground", "is", "assumed", "to", "be", "flat", "and", "level", "parameters", "x", "numeric", "position", "on", "the", "ground", "between", "two", "rows", "as", "a", "fraction", "of", "the", "pitch", "x", "0", "corresponds", "to", "the", "point", "on", "the", "ground", "directly", "below", "the", "center", "point", "of", "a", "row", "positive", "x", "is", "towards", "the", "right", "unitless", "rotation", "float", "rotation", "angle", "of", "the", "row", "s", "right", "edge", "relative", "to", "row", "center", "degree", "gcr", "float", "ratio", "of", "the", "row", "slant", "length", "to", "the", "row", "spacing", "pitch", "unitless", "height", "float", "height", "of", "the", "center", "point", "of", "the", "row", "above", "the", "ground", "must", "be", "in", "the", "same", "units", "as", "pitch", "pitch", "float", "distance", "between", "two", "rows", "must", "be", "in", "the", "same", "units", "as", "height", "max_rows", "int", "default", "10", "maximum", "number", "of", "rows", "to", "consider", "on", "either", "side", "of", "the", "current", "row", "unitless", "returns", "vf", "numeric", "fraction", "of", "sky", "dome", "visible", "from", "each", "point", "on", "the", "ground", "unitless", "wedge_angles", "array", "angles", "defining", "each", "wedge", "of", "sky", "that", "is", "blocked", "by", "a", "row", "shape", "is", "2", "len", "x", "2", "max_rows", "1", "wedge_angles", "0", "is", "the", "starting", "angle", "of", "each", "wedge", "wedge_angles", "1", "is", "the", "end", "angle", "degree", "x", "np", "atleast_1d", "x", "handle", "float", "all_k", "np", "arange", "max_rows", "max_rows", "1", "width", "gcr", "pitch", "2", "angles", "from", "x", "to", "right", "edge", "of", "each", "row", "a1", "height", "width", "sind", "rotation", "b1", "all_k", "x", "np", "newaxis", "pitch", "width", "cosd", "rotation", "phi_1", "np", "degrees", "np", "arctan2", "a1", "b1", "angles", "from", "x", "to", "left", "edge", "of", "each", "row", "a2", "height", "width", "sind", "rotation", "b2", "all_k", "x", "np", "newaxis", "pitch", "width", "cosd", "rotation", "phi_2", "np", "degrees", "np", "arctan2", "a2", "b2", "phi", "np", "stack", "phi_1", "phi_2", "swap", "phi", "0", "phi", "1", "swap", "where", "phi_1", "phi_2", "so", "that", "phi_1", "0", "is", "the", "lesser", "angle", "phi", "np", "where", "swap", "phi", "1", "phi", "right", "edge", "of", "next", "row", "left", "edge", "of", "previous", "row", "wedge_vfs", "0", "5", "cosd", "phi", "1", "1", "cosd", "phi", "0", "1", "vf", "np", "sum", "np", "where", "wedge_vfs", "0", "wedge_vfs", "0", "axis", "1", "return", "vf", "phi"], "doc_len": 381}
{"doc_id": "pvlib/iotools/bsrn.py::_empty_dataframe_from_logical_records", "file_path": "pvlib/iotools/bsrn.py", "class_name": null, "func_name": "_empty_dataframe_from_logical_records", "text": "文件路径: pvlib/iotools/bsrn.py\ndef _empty_dataframe_from_logical_records(logical_records):\n    # Create an empty DataFrame with the column names corresponding to the\n    # requested logical records\n    columns = []\n    for lr in logical_records:\n        columns += BSRN_COLUMNS[lr][2:]\n    columns = [c for c in columns if c != 'empty']\n    return pd.DataFrame(columns=columns)\n", "tokens": ["pvlib", "iotools", "bsrn", "py", "def", "_empty_dataframe_from_logical_records", "logical_records", "create", "an", "empty", "dataframe", "with", "the", "column", "names", "corresponding", "to", "the", "requested", "logical", "records", "columns", "for", "lr", "in", "logical_records", "columns", "bsrn_columns", "lr", "2", "columns", "c", "for", "c", "in", "columns", "if", "c", "empty", "return", "pd", "dataframe", "columns", "columns"], "doc_len": 44}
{"doc_id": "pvlib/iotools/bsrn.py::get_bsrn", "file_path": "pvlib/iotools/bsrn.py", "class_name": null, "func_name": "get_bsrn", "text": "文件路径: pvlib/iotools/bsrn.py\ndef get_bsrn(station, start, end, username, password,\n             logical_records=('0100',), save_path=None):\n    \"\"\"\n    Retrieve ground measured irradiance data from the BSRN FTP server.\n\n    The BSRN (Baseline Surface Radiation Network) is a world wide network\n    of high-quality solar radiation monitoring stations as described in [1]_.\n    Data is retrieved from the BSRN FTP server [2]_.\n\n    Data is returned for the entire months between and including start and end.\n\n    Parameters\n    ----------\n    station: str\n        3-letter BSRN station abbreviation\n    start: datetime-like\n        First day of the requested period\n    end: datetime-like\n        Last day of the requested period\n    username: str\n        username for accessing the BSRN FTP server\n    password: str\n        password for accessing the BSRN FTP server\n    logical_records: list or tuple, default: ('0100',)\n        List of the logical records (LR) to parse. Options include: '0100',\n        '0300', and '0500'.\n    save_path: str or path-like, optional\n        If specified, a directory path of where to save each monthly file.\n\n    Returns\n    -------\n    data: DataFrame\n        timeseries data from the BSRN archive, see\n        :func:`pvlib.iotools.read_bsrn` for fields. An empty DataFrame is\n        returned if no data was found for the time period.\n    metadata: dict\n        metadata for the last available monthly file.\n\n    Raises\n    ------\n    KeyError\n        If the specified station does not exist on the FTP server.\n\n    Warns\n    -----\n    UserWarning\n        If one or more requested files are missing a UserWarning is returned\n        with a list of the filenames missing. If no files match the specified\n        station and timeframe a seperate UserWarning is given.\n\n    Notes\n    -----\n    The username and password for the BSRN FTP server can be obtained for free\n    as described in the BSRN's Data Release Guidelines [3]_.\n\n    Currently only parsing of logical records 0100, 0300 and 0500 is supported.\n    Note not all stations measure LR0300 and LR0500. However, LR0100 is\n    mandatory as it contains the basic irradiance and auxillary measurements.\n    See [4]_ for a description of the different logical records. Future updates\n    may include parsing of additional data and metadata.\n\n    Important\n    ---------\n    While data from the BSRN is generally of high-quality, measurement data\n    should always be quality controlled before usage!\n\n    Examples\n    --------\n    >>> # Retrieve two months irradiance data from the Cabauw BSRN station\n    >>> data, metadata = pvlib.iotools.get_bsrn(  # doctest: +SKIP\n    >>>     start=pd.Timestamp(2020,1,1), end=pd.Timestamp(2020,12,1),   # doctest: +SKIP\n    >>>     station='cab', username='yourusername', password='yourpassword')  # doctest: +SKIP\n\n    See Also\n    --------\n    pvlib.iotools.read_bsrn, pvlib.iotools.parse_bsrn\n\n    References\n    ----------\n    .. [1] `World Radiation Monitoring Center - Baseline Surface Radiation\n        Network (BSRN)\n        <https://bsrn.awi.de/>`_\n    .. [2] `BSRN Data Retrieval via FTP\n       <https://bsrn.awi.de/data/data-retrieval-via-ftp/>`_\n    .. [4] `BSRN Data Release Guidelines\n       <https://bsrn.awi.de/data/conditions-of-data-release/>`_\n    .. [3] `Update of the Technical Plan for BSRN Data Management, 2013,\n       Global Climate Observing System (GCOS) GCOS-174.\n       <https://bsrn.awi.de/fileadmin/user_upload/bsrn.awi.de/Publications/gcos-174.pdf>`_\n    \"\"\"  # noqa: E501\n    # The FTP server uses lowercase station abbreviations\n    station = station.lower()\n\n    # Generate list files to download based on start/end (SSSMMYY.dat.gz)\n    filenames = pd.date_range(\n        start, end.replace(day=1) + pd.DateOffset(months=1), freq='1M')\\\n        .strftime(f\"{station}%m%y.dat.gz\").tolist()\n\n    # Create FTP connection\n    with ftplib.FTP(BSRN_FTP_URL, username, password) as ftp:\n        # Change to station sub-directory (checks that the station exists)\n        try:\n            ftp.cwd(f'/{station}')\n        except ftplib.error_perm as e:\n            raise KeyError('Station sub-directory does not exist. Specified '\n                           'station is probably not a proper three letter '\n                           'station abbreviation.') from e\n        dfs = []  # Initialize list for monthly dataframes\n        non_existing_files = []  # Initilize list of files that were not found\n        for filename in filenames:\n            try:\n                bio = io.BytesIO()  # Initialize BytesIO object\n                # Retrieve binary file from server and write to BytesIO object\n                response = ftp.retrbinary(f'RETR {filename}', bio.write)\n                # Check that transfer was successfull\n                if not response.startswith('226 Transfer complete'):\n                    raise ftplib.Error(response)\n                # Save file locally if save_path is specified\n                if save_path is not None:\n                    # Create local file\n                    with open(os.path.join(save_path, filename), 'wb') as f:\n                        f.write(bio.getbuffer())  # Write local file\n                # Open gzip file and convert to StringIO\n                bio.seek(0)  # reset buffer to start of file\n                gzip_file = io.TextIOWrapper(gzip.GzipFile(fileobj=bio),\n                                             encoding='latin1')\n                dfi, metadata = parse_bsrn(gzip_file, logical_records)\n                dfs.append(dfi)\n            # FTP client raises an error if the file does not exist on server\n            except ftplib.error_perm as e:\n                if str(e) == '550 Failed to open file.':\n                    non_existing_files.append(filename)\n                else:\n                    raise ftplib.error_perm(e)\n        ftp.quit()  # Close and exit FTP connection\n\n    # Raise user warnings\n    if not dfs:  # If no files were found\n        warnings.warn('No files were available for the specified timeframe.')\n    elif non_existing_files:  # If only some files were missing\n        warnings.warn(f'The following files were not found: {non_existing_files}')  # noqa: E501\n\n    # Concatenate monthly dataframes to one dataframe\n    if len(dfs):\n        data = pd.concat(dfs, axis='rows')\n    else:  # Return empty dataframe\n        data = _empty_dataframe_from_logical_records(logical_records)\n        metadata = {}\n    # Return dataframe and metadata (metadata belongs to last available file)\n    return data, metadata\n", "tokens": ["pvlib", "iotools", "bsrn", "py", "def", "get_bsrn", "station", "start", "end", "username", "password", "logical_records", "0100", "save_path", "none", "retrieve", "ground", "measured", "irradiance", "data", "from", "the", "bsrn", "ftp", "server", "the", "bsrn", "baseline", "surface", "radiation", "network", "is", "a", "world", "wide", "network", "of", "high", "quality", "solar", "radiation", "monitoring", "stations", "as", "described", "in", "1", "_", "data", "is", "retrieved", "from", "the", "bsrn", "ftp", "server", "2", "_", "data", "is", "returned", "for", "the", "entire", "months", "between", "and", "including", "start", "and", "end", "parameters", "station", "str", "3", "letter", "bsrn", "station", "abbreviation", "start", "datetime", "like", "first", "day", "of", "the", "requested", "period", "end", "datetime", "like", "last", "day", "of", "the", "requested", "period", "username", "str", "username", "for", "accessing", "the", "bsrn", "ftp", "server", "password", "str", "password", "for", "accessing", "the", "bsrn", "ftp", "server", "logical_records", "list", "or", "tuple", "default", "0100", "list", "of", "the", "logical", "records", "lr", "to", "parse", "options", "include", "0100", "0300", "and", "0500", "save_path", "str", "or", "path", "like", "optional", "if", "specified", "a", "directory", "path", "of", "where", "to", "save", "each", "monthly", "file", "returns", "data", "dataframe", "timeseries", "data", "from", "the", "bsrn", "archive", "see", "func", "pvlib", "iotools", "read_bsrn", "for", "fields", "an", "empty", "dataframe", "is", "returned", "if", "no", "data", "was", "found", "for", "the", "time", "period", "metadata", "dict", "metadata", "for", "the", "last", "available", "monthly", "file", "raises", "keyerror", "if", "the", "specified", "station", "does", "not", "exist", "on", "the", "ftp", "server", "warns", "userwarning", "if", "one", "or", "more", "requested", "files", "are", "missing", "a", "userwarning", "is", "returned", "with", "a", "list", "of", "the", "filenames", "missing", "if", "no", "files", "match", "the", "specified", "station", "and", "timeframe", "a", "seperate", "userwarning", "is", "given", "notes", "the", "username", "and", "password", "for", "the", "bsrn", "ftp", "server", "can", "be", "obtained", "for", "free", "as", "described", "in", "the", "bsrn", "s", "data", "release", "guidelines", "3", "_", "currently", "only", "parsing", "of", "logical", "records", "0100", "0300", "and", "0500", "is", "supported", "note", "not", "all", "stations", "measure", "lr0300", "and", "lr0500", "however", "lr0100", "is", "mandatory", "as", "it", "contains", "the", "basic", "irradiance", "and", "auxillary", "measurements", "see", "4", "_", "for", "a", "description", "of", "the", "different", "logical", "records", "future", "updates", "may", "include", "parsing", "of", "additional", "data", "and", "metadata", "important", "while", "data", "from", "the", "bsrn", "is", "generally", "of", "high", "quality", "measurement", "data", "should", "always", "be", "quality", "controlled", "before", "usage", "examples", "retrieve", "two", "months", "irradiance", "data", "from", "the", "cabauw", "bsrn", "station", "data", "metadata", "pvlib", "iotools", "get_bsrn", "doctest", "skip", "start", "pd", "timestamp", "2020", "1", "1", "end", "pd", "timestamp", "2020", "12", "1", "doctest", "skip", "station", "cab", "username", "yourusername", "password", "yourpassword", "doctest", "skip", "see", "also", "pvlib", "iotools", "read_bsrn", "pvlib", "iotools", "parse_bsrn", "references", "1", "world", "radiation", "monitoring", "center", "baseline", "surface", "radiation", "network", "bsrn", "https", "bsrn", "awi", "de", "_", "2", "bsrn", "data", "retrieval", "via", "ftp", "https", "bsrn", "awi", "de", "data", "data", "retrieval", "via", "ftp", "_", "4", "bsrn", "data", "release", "guidelines", "https", "bsrn", "awi", "de", "data", "conditions", "of", "data", "release", "_", "3", "update", "of", "the", "technical", "plan", "for", "bsrn", "data", "management", "2013", "global", "climate", "observing", "system", "gcos", "gcos", "174", "https", "bsrn", "awi", "de", "fileadmin", "user_upload", "bsrn", "awi", "de", "publications", "gcos", "174", "pdf", "_", "noqa", "e501", "the", "ftp", "server", "uses", "lowercase", "station", "abbreviations", "station", "station", "lower", "generate", "list", "files", "to", "download", "based", "on", "start", "end", "sssmmyy", "dat", "gz", "filenames", "pd", "date_range", "start", "end", "replace", "day", "1", "pd", "dateoffset", "months", "1", "freq", "1m", "strftime", "f", "station", "m", "y", "dat", "gz", "tolist", "create", "ftp", "connection", "with", "ftplib", "ftp", "bsrn_ftp_url", "username", "password", "as", "ftp", "change", "to", "station", "sub", "directory", "checks", "that", "the", "station", "exists", "try", "ftp", "cwd", "f", "station", "except", "ftplib", "error_perm", "as", "e", "raise", "keyerror", "station", "sub", "directory", "does", "not", "exist", "specified", "station", "is", "probably", "not", "a", "proper", "three", "letter", "station", "abbreviation", "from", "e", "dfs", "initialize", "list", "for", "monthly", "dataframes", "non_existing_files", "initilize", "list", "of", "files", "that", "were", "not", "found", "for", "filename", "in", "filenames", "try", "bio", "io", "bytesio", "initialize", "bytesio", "object", "retrieve", "binary", "file", "from", "server", "and", "write", "to", "bytesio", "object", "response", "ftp", "retrbinary", "f", "retr", "filename", "bio", "write", "check", "that", "transfer", "was", "successfull", "if", "not", "response", "startswith", "226", "transfer", "complete", "raise", "ftplib", "error", "response", "save", "file", "locally", "if", "save_path", "is", "specified", "if", "save_path", "is", "not", "none", "create", "local", "file", "with", "open", "os", "path", "join", "save_path", "filename", "wb", "as", "f", "f", "write", "bio", "getbuffer", "write", "local", "file", "open", "gzip", "file", "and", "convert", "to", "stringio", "bio", "seek", "0", "reset", "buffer", "to", "start", "of", "file", "gzip_file", "io", "textiowrapper", "gzip", "gzipfile", "fileobj", "bio", "encoding", "latin1", "dfi", "metadata", "parse_bsrn", "gzip_file", "logical_records", "dfs", "append", "dfi", "ftp", "client", "raises", "an", "error", "if", "the", "file", "does", "not", "exist", "on", "server", "except", "ftplib", "error_perm", "as", "e", "if", "str", "e", "550", "failed", "to", "open", "file", "non_existing_files", "append", "filename", "else", "raise", "ftplib", "error_perm", "e", "ftp", "quit", "close", "and", "exit", "ftp", "connection", "raise", "user", "warnings", "if", "not", "dfs", "if", "no", "files", "were", "found", "warnings", "warn", "no", "files", "were", "available", "for", "the", "specified", "timeframe", "elif", "non_existing_files", "if", "only", "some", "files", "were", "missing", "warnings", "warn", "f", "the", "following", "files", "were", "not", "found", "non_existing_files", "noqa", "e501", "concatenate", "monthly", "dataframes", "to", "one", "dataframe", "if", "len", "dfs", "data", "pd", "concat", "dfs", "axis", "rows", "else", "return", "empty", "dataframe", "data", "_empty_dataframe_from_logical_records", "logical_records", "metadata", "return", "dataframe", "and", "metadata", "metadata", "belongs", "to", "last", "available", "file", "return", "data", "metadata"], "doc_len": 808}
{"doc_id": "pvlib/iotools/bsrn.py::parse_bsrn", "file_path": "pvlib/iotools/bsrn.py", "class_name": null, "func_name": "parse_bsrn", "text": "文件路径: pvlib/iotools/bsrn.py\ndef parse_bsrn(fbuf, logical_records=('0100',)):\n    \"\"\"\n    Parse a file-like buffer of a BSRN station-to-archive file.\n\n    Parameters\n    ----------\n    fbuf: file-like buffer\n        Buffer of a BSRN station-to-archive data file\n    logical_records: list or tuple, default: ('0100',)\n        List of the logical records (LR) to parse. Options include: '0100',\n        '0300', and '0500'.\n\n    Returns\n    -------\n    data: DataFrame\n        timeseries data from the BSRN archive, see\n        :func:`pvlib.iotools.read_bsrn` for fields. An empty DataFrame is\n        returned if the specified logical records were not found.\n    metadata: dict\n        Dictionary containing metadata (primarily from LR0004).\n\n    See Also\n    --------\n    pvlib.iotools.read_bsrn, pvlib.iotools.get_bsrn\n\n    \"\"\"\n    # Parse metadata\n    fbuf.readline()  # first line should be *U0001, so read it and discard\n    date_line = fbuf.readline()  # second line contains important metadata\n    start_date = pd.Timestamp(year=int(date_line[7:11]),\n                              month=int(date_line[3:6]), day=1,\n                              tz='UTC')  # BSRN timestamps are UTC\n\n    metadata = {}  # Initilize dictionary containing metadata\n    metadata['start date'] = start_date\n    metadata['station identification number'] = int(date_line[:3])\n    metadata['version of data'] = int(date_line.split()[-1])\n    for line in fbuf:\n        if line[2:6] == '0004':  # stop once LR0004 has been reached\n            break\n        elif line == '':\n            raise ValueError('Mandatory record LR0004 not found.')\n    metadata['date when station description changed'] = fbuf.readline().strip()\n    metadata['surface type'] = int(fbuf.readline(3))\n    metadata['topography type'] = int(fbuf.readline())\n    metadata['address'] = fbuf.readline().strip()\n    metadata['telephone no. of station'] = fbuf.readline(20).strip()\n    metadata['FAX no. of station'] = fbuf.readline().strip()\n    metadata['TCP/IP no. of station'] = fbuf.readline(15).strip()\n    metadata['e-mail address of station'] = fbuf.readline().strip()\n    metadata['latitude_bsrn'] = float(fbuf.readline(8))  # BSRN convention\n    metadata['latitude'] = metadata['latitude_bsrn'] - 90  # ISO 19115\n    metadata['longitude_bsrn'] = float(fbuf.readline(8))  # BSRN convention\n    metadata['longitude'] = metadata['longitude_bsrn'] - 180  # ISO 19115\n    metadata['altitude'] = int(fbuf.readline(5))\n    metadata['identification of \"SYNOP\" station'] = fbuf.readline().strip()\n    metadata['date when horizon changed'] = fbuf.readline().strip()\n    # Pass last section of LR0004 containing the horizon elevation data\n    horizon = []  # list for raw horizon elevation data\n    while True:\n        line = fbuf.readline()\n        if ('*' in line) | (line == ''):\n            break\n        else:\n            horizon += [int(i) for i in line.split()]\n    horizon = pd.Series(horizon[1::2], horizon[::2], name='horizon_elevation',\n                        dtype=int).drop(-1, errors='ignore').sort_index()\n    horizon.index.name = 'azimuth'\n    metadata['horizon'] = horizon\n\n    # Read file and store the starting line number and number of lines for\n    # each logical record (LR)\n    fbuf.seek(0)  # reset buffer to start of file\n    lr_startrow = {}  # Dictionary of starting line number for each LR\n    lr_nrows = {}  # Dictionary of end line number for each LR\n    for num, line in enumerate(fbuf):\n        if line.startswith('*'):  # Find start of all logical records\n            if len(lr_startrow) >= 1:\n                lr_nrows[lr] = num - lr_startrow[lr] - 1  # noqa: F821\n            lr = line[2:6]  # string of 4 digit LR number\n            lr_startrow[lr] = num\n    lr_nrows[lr] = num - lr_startrow[lr]\n\n    for lr in logical_records:\n        if lr not in ['0100', '0300', '0500']:\n            raise ValueError(f\"Logical record {lr} not in \"\n                             \"['0100', '0300','0500'].\")\n    dfs = []  # Initialize empty list for dataframe\n\n    # Parse LR0100 - basic measurements including GHI, DNI, DHI and temperature\n    if ('0100' in lr_startrow.keys()) & ('0100' in logical_records):\n        fbuf.seek(0)  # reset buffer to start of file\n        LR_0100 = pd.read_fwf(fbuf, skiprows=lr_startrow['0100'] + 1,\n                              nrows=lr_nrows['0100'], header=None,\n                              colspecs=BSRN_LR0100_COL_SPECS,\n                              na_values=[-999.0, -99.9])\n        # Create multi-index and unstack, resulting in 1 col for each variable\n        LR_0100 = LR_0100.set_index([LR_0100.index // 2, LR_0100.index % 2])\n        LR_0100 = LR_0100.unstack(level=1).swaplevel(i=0, j=1, axis='columns')\n        # Sort columns to match original order and assign column names\n        LR_0100 = LR_0100.reindex(sorted(LR_0100.columns), axis='columns')\n        LR_0100.columns = BSRN_LR0100_COLUMNS\n        # Set datetime index\n        LR_0100.index = (start_date+pd.to_timedelta(LR_0100['day']-1, unit='d')\n                         + pd.to_timedelta(LR_0100['minute'], unit='T'))\n        # Drop empty, minute, and day columns\n        LR_0100 = LR_0100.drop(columns=['empty', 'day', 'minute'])\n        dfs.append(LR_0100)\n\n    # Parse LR0300 - other time series data, including upward and net radiation\n    if ('0300' in lr_startrow.keys()) & ('0300' in logical_records):\n        fbuf.seek(0)  # reset buffer to start of file\n        LR_0300 = pd.read_fwf(fbuf, skiprows=lr_startrow['0300']+1,\n                              nrows=lr_nrows['0300'], header=None,\n                              na_values=[-999.0, -99.9],\n                              colspecs=BSRN_LR0300_COL_SPECS,\n                              names=BSRN_LR0300_COLUMNS)\n        LR_0300.index = (start_date+pd.to_timedelta(LR_0300['day']-1, unit='d')\n                         + pd.to_timedelta(LR_0300['minute'], unit='T'))\n        LR_0300 = LR_0300.drop(columns=['day', 'minute']).astype(float)\n        dfs.append(LR_0300)\n\n    # Parse LR0500 - UV measurements\n    if ('0500' in lr_startrow.keys()) & ('0500' in logical_records):\n        fbuf.seek(0)  # reset buffer to start of file\n        LR_0500 = pd.read_fwf(fbuf, skiprows=lr_startrow['0500']+1,\n                              nrows=lr_nrows['0500'], na_values=[-99.9],\n                              header=None, colspecs=BSRN_LR0500_COL_SPECS)\n        # Create multi-index and unstack, resulting in 1 col for each variable\n        LR_0500 = LR_0500.set_index([LR_0500.index // 2, LR_0500.index % 2])\n        LR_0500 = LR_0500.unstack(level=1).swaplevel(i=0, j=1, axis='columns')\n        # Sort columns to match original order and assign column names\n        LR_0500 = LR_0500.reindex(sorted(LR_0500.columns), axis='columns')\n        LR_0500.columns = BSRN_LR0500_COLUMNS\n        LR_0500.index = (start_date+pd.to_timedelta(LR_0500['day']-1, unit='d')\n                         + pd.to_timedelta(LR_0500['minute'], unit='T'))\n        LR_0500 = LR_0500.drop(columns=['empty', 'day', 'minute'])\n        dfs.append(LR_0500)\n\n    if len(dfs):\n        data = pd.concat(dfs, axis='columns')\n    else:\n        data = _empty_dataframe_from_logical_records(logical_records)\n        metadata = {}\n    return data, metadata\n", "tokens": ["pvlib", "iotools", "bsrn", "py", "def", "parse_bsrn", "fbuf", "logical_records", "0100", "parse", "a", "file", "like", "buffer", "of", "a", "bsrn", "station", "to", "archive", "file", "parameters", "fbuf", "file", "like", "buffer", "buffer", "of", "a", "bsrn", "station", "to", "archive", "data", "file", "logical_records", "list", "or", "tuple", "default", "0100", "list", "of", "the", "logical", "records", "lr", "to", "parse", "options", "include", "0100", "0300", "and", "0500", "returns", "data", "dataframe", "timeseries", "data", "from", "the", "bsrn", "archive", "see", "func", "pvlib", "iotools", "read_bsrn", "for", "fields", "an", "empty", "dataframe", "is", "returned", "if", "the", "specified", "logical", "records", "were", "not", "found", "metadata", "dict", "dictionary", "containing", "metadata", "primarily", "from", "lr0004", "see", "also", "pvlib", "iotools", "read_bsrn", "pvlib", "iotools", "get_bsrn", "parse", "metadata", "fbuf", "readline", "first", "line", "should", "be", "u0001", "so", "read", "it", "and", "discard", "date_line", "fbuf", "readline", "second", "line", "contains", "important", "metadata", "start_date", "pd", "timestamp", "year", "int", "date_line", "7", "11", "month", "int", "date_line", "3", "6", "day", "1", "tz", "utc", "bsrn", "timestamps", "are", "utc", "metadata", "initilize", "dictionary", "containing", "metadata", "metadata", "start", "date", "start_date", "metadata", "station", "identification", "number", "int", "date_line", "3", "metadata", "version", "of", "data", "int", "date_line", "split", "1", "for", "line", "in", "fbuf", "if", "line", "2", "6", "0004", "stop", "once", "lr0004", "has", "been", "reached", "break", "elif", "line", "raise", "valueerror", "mandatory", "record", "lr0004", "not", "found", "metadata", "date", "when", "station", "description", "changed", "fbuf", "readline", "strip", "metadata", "surface", "type", "int", "fbuf", "readline", "3", "metadata", "topography", "type", "int", "fbuf", "readline", "metadata", "address", "fbuf", "readline", "strip", "metadata", "telephone", "no", "of", "station", "fbuf", "readline", "20", "strip", "metadata", "fax", "no", "of", "station", "fbuf", "readline", "strip", "metadata", "tcp", "ip", "no", "of", "station", "fbuf", "readline", "15", "strip", "metadata", "e", "mail", "address", "of", "station", "fbuf", "readline", "strip", "metadata", "latitude_bsrn", "float", "fbuf", "readline", "8", "bsrn", "convention", "metadata", "latitude", "metadata", "latitude_bsrn", "90", "iso", "19115", "metadata", "longitude_bsrn", "float", "fbuf", "readline", "8", "bsrn", "convention", "metadata", "longitude", "metadata", "longitude_bsrn", "180", "iso", "19115", "metadata", "altitude", "int", "fbuf", "readline", "5", "metadata", "identification", "of", "synop", "station", "fbuf", "readline", "strip", "metadata", "date", "when", "horizon", "changed", "fbuf", "readline", "strip", "pass", "last", "section", "of", "lr0004", "containing", "the", "horizon", "elevation", "data", "horizon", "list", "for", "raw", "horizon", "elevation", "data", "while", "true", "line", "fbuf", "readline", "if", "in", "line", "line", "break", "else", "horizon", "int", "i", "for", "i", "in", "line", "split", "horizon", "pd", "series", "horizon", "1", "2", "horizon", "2", "name", "horizon_elevation", "dtype", "int", "drop", "1", "errors", "ignore", "sort_index", "horizon", "index", "name", "azimuth", "metadata", "horizon", "horizon", "read", "file", "and", "store", "the", "starting", "line", "number", "and", "number", "of", "lines", "for", "each", "logical", "record", "lr", "fbuf", "seek", "0", "reset", "buffer", "to", "start", "of", "file", "lr_startrow", "dictionary", "of", "starting", "line", "number", "for", "each", "lr", "lr_nrows", "dictionary", "of", "end", "line", "number", "for", "each", "lr", "for", "num", "line", "in", "enumerate", "fbuf", "if", "line", "startswith", "find", "start", "of", "all", "logical", "records", "if", "len", "lr_startrow", "1", "lr_nrows", "lr", "num", "lr_startrow", "lr", "1", "noqa", "f821", "lr", "line", "2", "6", "string", "of", "4", "digit", "lr", "number", "lr_startrow", "lr", "num", "lr_nrows", "lr", "num", "lr_startrow", "lr", "for", "lr", "in", "logical_records", "if", "lr", "not", "in", "0100", "0300", "0500", "raise", "valueerror", "f", "logical", "record", "lr", "not", "in", "0100", "0300", "0500", "dfs", "initialize", "empty", "list", "for", "dataframe", "parse", "lr0100", "basic", "measurements", "including", "ghi", "dni", "dhi", "and", "temperature", "if", "0100", "in", "lr_startrow", "keys", "0100", "in", "logical_records", "fbuf", "seek", "0", "reset", "buffer", "to", "start", "of", "file", "lr_0100", "pd", "read_fwf", "fbuf", "skiprows", "lr_startrow", "0100", "1", "nrows", "lr_nrows", "0100", "header", "none", "colspecs", "bsrn_lr0100_col_specs", "na_values", "999", "0", "99", "9", "create", "multi", "index", "and", "unstack", "resulting", "in", "1", "col", "for", "each", "variable", "lr_0100", "lr_0100", "set_index", "lr_0100", "index", "2", "lr_0100", "index", "2", "lr_0100", "lr_0100", "unstack", "level", "1", "swaplevel", "i", "0", "j", "1", "axis", "columns", "sort", "columns", "to", "match", "original", "order", "and", "assign", "column", "names", "lr_0100", "lr_0100", "reindex", "sorted", "lr_0100", "columns", "axis", "columns", "lr_0100", "columns", "bsrn_lr0100_columns", "set", "datetime", "index", "lr_0100", "index", "start_date", "pd", "to_timedelta", "lr_0100", "day", "1", "unit", "d", "pd", "to_timedelta", "lr_0100", "minute", "unit", "t", "drop", "empty", "minute", "and", "day", "columns", "lr_0100", "lr_0100", "drop", "columns", "empty", "day", "minute", "dfs", "append", "lr_0100", "parse", "lr0300", "other", "time", "series", "data", "including", "upward", "and", "net", "radiation", "if", "0300", "in", "lr_startrow", "keys", "0300", "in", "logical_records", "fbuf", "seek", "0", "reset", "buffer", "to", "start", "of", "file", "lr_0300", "pd", "read_fwf", "fbuf", "skiprows", "lr_startrow", "0300", "1", "nrows", "lr_nrows", "0300", "header", "none", "na_values", "999", "0", "99", "9", "colspecs", "bsrn_lr0300_col_specs", "names", "bsrn_lr0300_columns", "lr_0300", "index", "start_date", "pd", "to_timedelta", "lr_0300", "day", "1", "unit", "d", "pd", "to_timedelta", "lr_0300", "minute", "unit", "t", "lr_0300", "lr_0300", "drop", "columns", "day", "minute", "astype", "float", "dfs", "append", "lr_0300", "parse", "lr0500", "uv", "measurements", "if", "0500", "in", "lr_startrow", "keys", "0500", "in", "logical_records", "fbuf", "seek", "0", "reset", "buffer", "to", "start", "of", "file", "lr_0500", "pd", "read_fwf", "fbuf", "skiprows", "lr_startrow", "0500", "1", "nrows", "lr_nrows", "0500", "na_values", "99", "9", "header", "none", "colspecs", "bsrn_lr0500_col_specs", "create", "multi", "index", "and", "unstack", "resulting", "in", "1", "col", "for", "each", "variable", "lr_0500", "lr_0500", "set_index", "lr_0500", "index", "2", "lr_0500", "index", "2", "lr_0500", "lr_0500", "unstack", "level", "1", "swaplevel", "i", "0", "j", "1", "axis", "columns", "sort", "columns", "to", "match", "original", "order", "and", "assign", "column", "names", "lr_0500", "lr_0500", "reindex", "sorted", "lr_0500", "columns", "axis", "columns", "lr_0500", "columns", "bsrn_lr0500_columns", "lr_0500", "index", "start_date", "pd", "to_timedelta", "lr_0500", "day", "1", "unit", "d", "pd", "to_timedelta", "lr_0500", "minute", "unit", "t", "lr_0500", "lr_0500", "drop", "columns", "empty", "day", "minute", "dfs", "append", "lr_0500", "if", "len", "dfs", "data", "pd", "concat", "dfs", "axis", "columns", "else", "data", "_empty_dataframe_from_logical_records", "logical_records", "metadata", "return", "data", "metadata"], "doc_len": 833}
{"doc_id": "pvlib/iotools/bsrn.py::read_bsrn", "file_path": "pvlib/iotools/bsrn.py", "class_name": null, "func_name": "read_bsrn", "text": "文件路径: pvlib/iotools/bsrn.py\ndef read_bsrn(filename, logical_records=('0100',)):\n    \"\"\"\n    Read a BSRN station-to-archive file into a DataFrame.\n\n    The BSRN (Baseline Surface Radiation Network) is a world wide network\n    of high-quality solar radiation monitoring stations as described in [1]_.\n    The function is able to parse logical records (LR) 0100, 0300, and 0500.\n    LR0100 contains the basic measurements, which include global, diffuse, and\n    direct irradiance, as well as downwelling long-wave radiation [2]_. Future\n    updates may include parsing of additional data and metadata.\n\n    BSRN files are freely available and can be accessed via FTP [3]_. The\n    username and password for the BSRN FTP server can be obtained for free as\n    described in the BSRN's Data Release Guidelines [3]_.\n\n    Parameters\n    ----------\n    filename: str or path-like\n        Name or path of a BSRN station-to-archive data file\n    logical_records: list or tuple, default: ('0100',)\n        List of the logical records (LR) to parse. Options include: '0100',\n        '0300', and '0500'.\n\n    Returns\n    -------\n    data: DataFrame\n        A DataFrame with the columns as described below. For a more extensive\n        description of the variables, consult [2]_. An empty DataFrame is\n        returned if the specified logical records were not found.\n    metadata: dict\n        Dictionary containing metadata (primarily from LR0004).\n\n    Notes\n    -----\n    The data DataFrame for LR0100 includes the following fields:\n\n    =======================  ======  ==========================================\n    Key                      Format  Description\n    =======================  ======  ==========================================\n    **Logical record 0100**\n    ---------------------------------------------------------------------------\n    ghi†                     float   Mean global horizontal irradiance [W/m^2]\n    dni†                     float   Mean direct normal irradiance [W/m^2]\n    dhi†                     float   Mean diffuse horizontal irradiance [W/m^2]\n    lwd†                     float   Mean. downward long-wave radiation [W/m^2]\n    temp_air                 float   Air temperature [°C]\n    relative_humidity        float   Relative humidity [%]\n    pressure                 float   Atmospheric pressure [hPa]\n    -----------------------  ------  ------------------------------------------\n    **Logical record 0300**\n    ---------------------------------------------------------------------------\n    gri†                     float   Mean ground-reflected irradiance [W/m^2]\n    lwu†                     float   Mean long-wave upwelling irradiance [W/m^2]\n    net_radiation†           float   Mean net radiation (net radiometer) [W/m^2]\n    -----------------------  ------  ------------------------------------------\n    **Logical record 0500**\n    ---------------------------------------------------------------------------\n    uva_global†              float   Mean UV-A global irradiance [W/m^2]\n    uvb_direct†              float   Mean UV-B direct irradiance [W/m^2]\n    uvb_global†              float   Mean UV-B global irradiance [W/m^2]\n    uvb_diffuse†             float   Mean UV-B diffuse irradiance [W/m^2]\n    uvb_reflected†           float   Mean UV-B reflected irradiance [W/m^2]\n    =======================  ======  ==========================================\n\n    † Marked variables have corresponding columns for the standard deviation\n    (_std), minimum (_min), and maximum (_max) calculated from the 60 samples\n    that are average into each 1-minute measurement.\n\n    Hint\n    ----\n    According to [2]_ \"All time labels in the station-to-archive files denote\n    the start of a time interval.\" This corresponds to left bin edge labeling.\n\n    See Also\n    --------\n    pvlib.iotools.parse_bsrn, pvlib.iotools.get_bsrn\n\n    References\n    ----------\n    .. [1] `World Radiation Monitoring Center - Baseline Surface Radiation\n        Network (BSRN)\n        <https://bsrn.awi.de/>`_\n    .. [2] `Update of the Technical Plan for BSRN Data Management, 2013,\n       Global Climate Observing System (GCOS) GCOS-174.\n       <https://bsrn.awi.de/fileadmin/user_upload/bsrn.awi.de/Publications/gcos-174.pdf>`_\n    .. [3] `BSRN Data Retrieval via FTP\n       <https://bsrn.awi.de/data/data-retrieval-via-ftp/>`_\n    .. [4] `BSRN Data Release Guidelines\n       <https://bsrn.awi.de/data/conditions-of-data-release/>`_\n    \"\"\"  # noqa: E501\n    if str(filename).endswith('.gz'):  # check if file is a gzipped (.gz) file\n        open_func, mode = gzip.open, 'rt'\n    else:\n        open_func, mode = open, 'r'\n    with open_func(filename, mode) as f:\n        content = parse_bsrn(f, logical_records)\n    return content\n", "tokens": ["pvlib", "iotools", "bsrn", "py", "def", "read_bsrn", "filename", "logical_records", "0100", "read", "a", "bsrn", "station", "to", "archive", "file", "into", "a", "dataframe", "the", "bsrn", "baseline", "surface", "radiation", "network", "is", "a", "world", "wide", "network", "of", "high", "quality", "solar", "radiation", "monitoring", "stations", "as", "described", "in", "1", "_", "the", "function", "is", "able", "to", "parse", "logical", "records", "lr", "0100", "0300", "and", "0500", "lr0100", "contains", "the", "basic", "measurements", "which", "include", "global", "diffuse", "and", "direct", "irradiance", "as", "well", "as", "downwelling", "long", "wave", "radiation", "2", "_", "future", "updates", "may", "include", "parsing", "of", "additional", "data", "and", "metadata", "bsrn", "files", "are", "freely", "available", "and", "can", "be", "accessed", "via", "ftp", "3", "_", "the", "username", "and", "password", "for", "the", "bsrn", "ftp", "server", "can", "be", "obtained", "for", "free", "as", "described", "in", "the", "bsrn", "s", "data", "release", "guidelines", "3", "_", "parameters", "filename", "str", "or", "path", "like", "name", "or", "path", "of", "a", "bsrn", "station", "to", "archive", "data", "file", "logical_records", "list", "or", "tuple", "default", "0100", "list", "of", "the", "logical", "records", "lr", "to", "parse", "options", "include", "0100", "0300", "and", "0500", "returns", "data", "dataframe", "a", "dataframe", "with", "the", "columns", "as", "described", "below", "for", "a", "more", "extensive", "description", "of", "the", "variables", "consult", "2", "_", "an", "empty", "dataframe", "is", "returned", "if", "the", "specified", "logical", "records", "were", "not", "found", "metadata", "dict", "dictionary", "containing", "metadata", "primarily", "from", "lr0004", "notes", "the", "data", "dataframe", "for", "lr0100", "includes", "the", "following", "fields", "key", "format", "description", "logical", "record", "0100", "ghi", "float", "mean", "global", "horizontal", "irradiance", "w", "m", "2", "dni", "float", "mean", "direct", "normal", "irradiance", "w", "m", "2", "dhi", "float", "mean", "diffuse", "horizontal", "irradiance", "w", "m", "2", "lwd", "float", "mean", "downward", "long", "wave", "radiation", "w", "m", "2", "temp_air", "float", "air", "temperature", "c", "relative_humidity", "float", "relative", "humidity", "pressure", "float", "atmospheric", "pressure", "hpa", "logical", "record", "0300", "gri", "float", "mean", "ground", "reflected", "irradiance", "w", "m", "2", "lwu", "float", "mean", "long", "wave", "upwelling", "irradiance", "w", "m", "2", "net_radiation", "float", "mean", "net", "radiation", "net", "radiometer", "w", "m", "2", "logical", "record", "0500", "uva_global", "float", "mean", "uv", "a", "global", "irradiance", "w", "m", "2", "uvb_direct", "float", "mean", "uv", "b", "direct", "irradiance", "w", "m", "2", "uvb_global", "float", "mean", "uv", "b", "global", "irradiance", "w", "m", "2", "uvb_diffuse", "float", "mean", "uv", "b", "diffuse", "irradiance", "w", "m", "2", "uvb_reflected", "float", "mean", "uv", "b", "reflected", "irradiance", "w", "m", "2", "marked", "variables", "have", "corresponding", "columns", "for", "the", "standard", "deviation", "_std", "minimum", "_min", "and", "maximum", "_max", "calculated", "from", "the", "60", "samples", "that", "are", "average", "into", "each", "1", "minute", "measurement", "hint", "according", "to", "2", "_", "all", "time", "labels", "in", "the", "station", "to", "archive", "files", "denote", "the", "start", "of", "a", "time", "interval", "this", "corresponds", "to", "left", "bin", "edge", "labeling", "see", "also", "pvlib", "iotools", "parse_bsrn", "pvlib", "iotools", "get_bsrn", "references", "1", "world", "radiation", "monitoring", "center", "baseline", "surface", "radiation", "network", "bsrn", "https", "bsrn", "awi", "de", "_", "2", "update", "of", "the", "technical", "plan", "for", "bsrn", "data", "management", "2013", "global", "climate", "observing", "system", "gcos", "gcos", "174", "https", "bsrn", "awi", "de", "fileadmin", "user_upload", "bsrn", "awi", "de", "publications", "gcos", "174", "pdf", "_", "3", "bsrn", "data", "retrieval", "via", "ftp", "https", "bsrn", "awi", "de", "data", "data", "retrieval", "via", "ftp", "_", "4", "bsrn", "data", "release", "guidelines", "https", "bsrn", "awi", "de", "data", "conditions", "of", "data", "release", "_", "noqa", "e501", "if", "str", "filename", "endswith", "gz", "check", "if", "file", "is", "a", "gzipped", "gz", "file", "open_func", "mode", "gzip", "open", "rt", "else", "open_func", "mode", "open", "r", "with", "open_func", "filename", "mode", "as", "f", "content", "parse_bsrn", "f", "logical_records", "return", "content"], "doc_len": 536}
{"doc_id": "pvlib/iotools/crn.py::read_crn", "file_path": "pvlib/iotools/crn.py", "class_name": null, "func_name": "read_crn", "text": "文件路径: pvlib/iotools/crn.py\ndef read_crn(filename, map_variables=True):\n    \"\"\"Read a NOAA USCRN fixed-width file into a pandas dataframe.\n\n    The CRN network consists of over 100 meteorological stations covering the\n    U.S. and is described in [1]_ and [2]_. The primary goal of CRN is to\n    provide long-term measurements of temperature, precipitation, and soil\n    moisture and temperature. Additionally, global horizontal irradiance (GHI)\n    is measured at each site using a photodiode pyranometer.\n\n    Parameters\n    ----------\n    filename: str, path object, or file-like\n        filepath or url to read for the fixed-width file.\n    map_variables: boolean, default: True\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n\n    Returns\n    -------\n    data: Dataframe\n        A dataframe with DatetimeIndex and all of the variables in the\n        file.\n\n    Notes\n    -----\n    CRN files contain 5 minute averages labeled by the interval ending\n    time. Here, missing data is flagged as NaN, rather than the lowest\n    possible integer for a field (e.g. -999 or -99). Air temperature is in\n    deg C and wind speed is in m/s at a height of 1.5 m above ground level.\n\n    Variables corresponding to standard pvlib variables are by default renamed,\n    e.g. `SOLAR_RADIATION` becomes `ghi`. See the\n    :const:`pvlib.iotools.crn.VARIABLE_MAP` dict for the complete mapping.\n\n    CRN files occasionally have a set of null characters on a line\n    instead of valid data. This function drops those lines. Sometimes\n    these null characters appear on a line of their own and sometimes\n    they occur on the same line as valid data. In the latter case, the\n    valid data will not be returned. Users may manually remove the null\n    characters and reparse the file if they need that line.\n\n    References\n    ----------\n    .. [1] U.S. Climate Reference Network\n       `https://www.ncdc.noaa.gov/crn/qcdatasets.html\n       <https://www.ncdc.noaa.gov/crn/qcdatasets.html>`_\n\n    .. [2] Diamond, H. J. et. al., 2013: U.S. Climate Reference Network\n       after one decade of operations: status and assessment. Bull.\n       Amer. Meteor. Soc., 94, 489-498. :doi:`10.1175/BAMS-D-12-00170.1`\n    \"\"\"\n\n    # read in data\n    # TODO: instead of parsing as strings and then post-processing, switch to\n    # pd.read_fwf(..., dtype=dict(zip(HEADERS, DTYPES)), skip_blank_lines=True)\n    # when our minimum pandas >= 1.2.0 (skip_blank_lines bug for <1.2.0).\n    # As a workaround, parse all values as strings, then drop NaN, then cast\n    # to the appropriate dtypes, and mask \"sentinal\" NaN (e.g. -9999.0)\n    data = pd.read_fwf(filename, header=None, names=HEADERS, widths=WIDTHS,\n                       dtype=str)\n\n    # drop empty (bad) lines\n    data = data.dropna(axis=0, how='all')\n\n    # can't set dtypes in read_fwf because int cols can't contain NaN, so\n    # do it here instead\n    data = data.astype(dict(zip(HEADERS, DTYPES)))\n\n    # finally, replace -999 values with NaN\n    data = data.replace(NAN_DICT, value=np.nan)\n\n    # set index\n    # UTC_TIME does not have leading 0s, so must zfill(4) to comply\n    # with %H%M format\n    dts = data[['UTC_DATE', 'UTC_TIME']].astype(str)\n    dtindex = pd.to_datetime(dts['UTC_DATE'] + dts['UTC_TIME'].str.zfill(4),\n                             format='%Y%m%d%H%M', utc=True)\n    data = data.set_index(dtindex)\n\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n\n    return data\n", "tokens": ["pvlib", "iotools", "crn", "py", "def", "read_crn", "filename", "map_variables", "true", "read", "a", "noaa", "uscrn", "fixed", "width", "file", "into", "a", "pandas", "dataframe", "the", "crn", "network", "consists", "of", "over", "100", "meteorological", "stations", "covering", "the", "u", "s", "and", "is", "described", "in", "1", "_", "and", "2", "_", "the", "primary", "goal", "of", "crn", "is", "to", "provide", "long", "term", "measurements", "of", "temperature", "precipitation", "and", "soil", "moisture", "and", "temperature", "additionally", "global", "horizontal", "irradiance", "ghi", "is", "measured", "at", "each", "site", "using", "a", "photodiode", "pyranometer", "parameters", "filename", "str", "path", "object", "or", "file", "like", "filepath", "or", "url", "to", "read", "for", "the", "fixed", "width", "file", "map_variables", "boolean", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "returns", "data", "dataframe", "a", "dataframe", "with", "datetimeindex", "and", "all", "of", "the", "variables", "in", "the", "file", "notes", "crn", "files", "contain", "5", "minute", "averages", "labeled", "by", "the", "interval", "ending", "time", "here", "missing", "data", "is", "flagged", "as", "nan", "rather", "than", "the", "lowest", "possible", "integer", "for", "a", "field", "e", "g", "999", "or", "99", "air", "temperature", "is", "in", "deg", "c", "and", "wind", "speed", "is", "in", "m", "s", "at", "a", "height", "of", "1", "5", "m", "above", "ground", "level", "variables", "corresponding", "to", "standard", "pvlib", "variables", "are", "by", "default", "renamed", "e", "g", "solar_radiation", "becomes", "ghi", "see", "the", "const", "pvlib", "iotools", "crn", "variable_map", "dict", "for", "the", "complete", "mapping", "crn", "files", "occasionally", "have", "a", "set", "of", "null", "characters", "on", "a", "line", "instead", "of", "valid", "data", "this", "function", "drops", "those", "lines", "sometimes", "these", "null", "characters", "appear", "on", "a", "line", "of", "their", "own", "and", "sometimes", "they", "occur", "on", "the", "same", "line", "as", "valid", "data", "in", "the", "latter", "case", "the", "valid", "data", "will", "not", "be", "returned", "users", "may", "manually", "remove", "the", "null", "characters", "and", "reparse", "the", "file", "if", "they", "need", "that", "line", "references", "1", "u", "s", "climate", "reference", "network", "https", "www", "ncdc", "noaa", "gov", "crn", "qcdatasets", "html", "https", "www", "ncdc", "noaa", "gov", "crn", "qcdatasets", "html", "_", "2", "diamond", "h", "j", "et", "al", "2013", "u", "s", "climate", "reference", "network", "after", "one", "decade", "of", "operations", "status", "and", "assessment", "bull", "amer", "meteor", "soc", "94", "489", "498", "doi", "10", "1175", "bams", "d", "12", "00170", "1", "read", "in", "data", "todo", "instead", "of", "parsing", "as", "strings", "and", "then", "post", "processing", "switch", "to", "pd", "read_fwf", "dtype", "dict", "zip", "headers", "dtypes", "skip_blank_lines", "true", "when", "our", "minimum", "pandas", "1", "2", "0", "skip_blank_lines", "bug", "for", "1", "2", "0", "as", "a", "workaround", "parse", "all", "values", "as", "strings", "then", "drop", "nan", "then", "cast", "to", "the", "appropriate", "dtypes", "and", "mask", "sentinal", "nan", "e", "g", "9999", "0", "data", "pd", "read_fwf", "filename", "header", "none", "names", "headers", "widths", "widths", "dtype", "str", "drop", "empty", "bad", "lines", "data", "data", "dropna", "axis", "0", "how", "all", "can", "t", "set", "dtypes", "in", "read_fwf", "because", "int", "cols", "can", "t", "contain", "nan", "so", "do", "it", "here", "instead", "data", "data", "astype", "dict", "zip", "headers", "dtypes", "finally", "replace", "999", "values", "with", "nan", "data", "data", "replace", "nan_dict", "value", "np", "nan", "set", "index", "utc_time", "does", "not", "have", "leading", "0s", "so", "must", "zfill", "4", "to", "comply", "with", "h", "m", "format", "dts", "data", "utc_date", "utc_time", "astype", "str", "dtindex", "pd", "to_datetime", "dts", "utc_date", "dts", "utc_time", "str", "zfill", "4", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "set_index", "dtindex", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "return", "data"], "doc_len": 520}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::_ecmwf", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": null, "func_name": "_ecmwf", "text": "文件路径: pvlib/iotools/ecmwf_macc.py\ndef _ecmwf(server, startdate, enddate, params, targetname):\n    # see http://apps.ecmwf.int/datasets/data/macc-reanalysis/levtype=sfc/\n    server.retrieve({\n        \"class\": \"mc\",\n        \"dataset\": \"macc\",\n        \"date\": \"%s/to/%s\" % (startdate, enddate),\n        \"expver\": \"rean\",\n        \"grid\": \"0.75/0.75\",\n        \"levtype\": \"sfc\",\n        \"param\": params,\n        \"step\": \"3/6/9/12/15/18/21/24\",\n        \"stream\": \"oper\",\n        \"format\": \"netcdf\",\n        \"time\": \"00:00:00\",\n        \"type\": \"fc\",\n        \"target\": targetname,\n    })\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "def", "_ecmwf", "server", "startdate", "enddate", "params", "targetname", "see", "http", "apps", "ecmwf", "int", "datasets", "data", "macc", "reanalysis", "levtype", "sfc", "server", "retrieve", "class", "mc", "dataset", "macc", "date", "s", "to", "s", "startdate", "enddate", "expver", "rean", "grid", "0", "75", "0", "75", "levtype", "sfc", "param", "params", "step", "3", "6", "9", "12", "15", "18", "21", "24", "stream", "oper", "format", "netcdf", "time", "00", "00", "00", "type", "fc", "target", "targetname"], "doc_len": 66}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::get_ecmwf_macc", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": null, "func_name": "get_ecmwf_macc", "text": "文件路径: pvlib/iotools/ecmwf_macc.py\ndef get_ecmwf_macc(filename, params, start, end, lookup_params=True,\n                   server=None, target=_ecmwf):\n    \"\"\"\n    Download data from ECMWF MACC Reanalysis API.\n\n    Parameters\n    ----------\n    filename : str\n        full path of file where to save data, ``.nc`` appended if not given\n    params : str or sequence of str\n        keynames of parameter[s] to download\n    start : datetime.datetime or datetime.date\n        UTC date\n    end : datetime.datetime or datetime.date\n        UTC date\n    lookup_params : bool, default True\n        optional flag, if ``False``, then codes are already formatted\n    server : ecmwfapi.api.ECMWFDataServer\n        optionally provide a server object, default is ``None``\n    target : callable\n        optional function that calls ``server.retrieve`` to pass to thread\n\n    Returns\n    -------\n    t : thread\n        a thread object, use it to check status by calling `t.is_alive()`\n\n    Notes\n    -----\n    To download data from ECMWF requires the API client and a registration\n    key. Please read the documentation in `Access ECMWF Public Datasets\n    <https://confluence.ecmwf.int/display/WEBAPI/Access+ECMWF+Public+Datasets>`_.\n    Follow the instructions in step 4 and save the ECMWF registration key\n    as `$HOME/.ecmwfapirc` or set `ECMWF_API_KEY` as the path to the key.\n\n    This function returns a daemon thread that runs in the background. Exiting\n    Python will kill this thread, however this thread will not block the main\n    thread or other threads. This thread will terminate when the file is\n    downloaded or if the thread raises an unhandled exception. You may submit\n    multiple requests simultaneously to break up large downloads. You can also\n    check the status and retrieve downloads online at\n    http://apps.ecmwf.int/webmars/joblist/. This is useful if you kill the\n    thread. Downloads expire after 24 hours.\n\n    .. warning:: Your request may be queued online for an hour or more before\n        it begins to download\n\n    Precipitable water :math:`P_{wat}` is equivalent to the total column of\n    water vapor (TCWV), but the units given by ECMWF MACC Reanalysis are kg/m^2\n    at STP (1-atm, 25-C). Divide by ten to convert to centimeters of\n    precipitable water:\n\n    .. math::\n        P_{wat} \\\\left( \\\\text{cm} \\\\right) \\\n        = TCWV \\\\left( \\\\frac{\\\\text{kg}}{\\\\text{m}^2} \\\\right) \\\n        \\\\frac{100 \\\\frac{\\\\text{cm}}{\\\\text{m}}} \\\n        {1000 \\\\frac{\\\\text{kg}}{\\\\text{m}^3}}\n\n    The keynames available for the ``params`` argument are given by\n    :const:`pvlib.iotools.ecmwf_macc.PARAMS` which maps the keys to codes used\n    in the API. The following keynames are available:\n\n    =======  =========================================\n    keyname  description\n    =======  =========================================\n    tcwv     total column water vapor in kg/m^2 at STP\n    aod550   aerosol optical depth measured at 550-nm\n    aod469   aerosol optical depth measured at 469-nm\n    aod670   aerosol optical depth measured at 670-nm\n    aod865   aerosol optical depth measured at 865-nm\n    aod1240  aerosol optical depth measured at 1240-nm\n    =======  =========================================\n\n    If ``lookup_params`` is ``False`` then ``params`` must contain the codes\n    preformatted according to the ECMWF MACC Reanalysis API. This is useful if\n    you want to retrieve codes that are not mapped in\n    :const:`pvlib.iotools.ecmwf_macc.PARAMS`.\n\n    Specify a custom ``target`` function to modify how the ECMWF API function\n    ``server.retrieve`` is called. The ``target`` function must have the\n    following signature in which the parameter definitions are similar to\n    :func:`pvlib.iotools.get_ecmwf_macc`. ::\n\n\n        target(server, startdate, enddate, params, filename) -> None\n\n    Examples\n    --------\n    Retrieve the AOD measured at 550-nm and the total column of water vapor for\n    November 1, 2012.\n\n    >>> from datetime import date\n    >>> from pvlib.iotools import get_ecmwf_macc\n    >>> filename = 'aod_tcwv_20121101.nc'  # .nc extension added if missing\n    >>> params = ('aod550', 'tcwv')\n    >>> start = end = date(2012, 11, 1)\n    >>> t = get_ecmwf_macc(filename, params, start, end)\n    >>> t.is_alive()\n    True\n\n    \"\"\"\n    if not filename.endswith('nc'):\n        filename += '.nc'\n    if lookup_params:\n        try:\n            params = '/'.join(PARAMS.get(p) for p in params)\n        except TypeError:\n            params = PARAMS.get(params)\n    startdate = start.strftime('%Y-%m-%d')\n    enddate = end.strftime('%Y-%m-%d')\n    if not server:\n        server = ECMWFDataServer()\n    t = threading.Thread(target=target, daemon=True,\n                         args=(server, startdate, enddate, params, filename))\n    t.start()\n    return t\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "def", "get_ecmwf_macc", "filename", "params", "start", "end", "lookup_params", "true", "server", "none", "target", "_ecmwf", "download", "data", "from", "ecmwf", "macc", "reanalysis", "api", "parameters", "filename", "str", "full", "path", "of", "file", "where", "to", "save", "data", "nc", "appended", "if", "not", "given", "params", "str", "or", "sequence", "of", "str", "keynames", "of", "parameter", "s", "to", "download", "start", "datetime", "datetime", "or", "datetime", "date", "utc", "date", "end", "datetime", "datetime", "or", "datetime", "date", "utc", "date", "lookup_params", "bool", "default", "true", "optional", "flag", "if", "false", "then", "codes", "are", "already", "formatted", "server", "ecmwfapi", "api", "ecmwfdataserver", "optionally", "provide", "a", "server", "object", "default", "is", "none", "target", "callable", "optional", "function", "that", "calls", "server", "retrieve", "to", "pass", "to", "thread", "returns", "t", "thread", "a", "thread", "object", "use", "it", "to", "check", "status", "by", "calling", "t", "is_alive", "notes", "to", "download", "data", "from", "ecmwf", "requires", "the", "api", "client", "and", "a", "registration", "key", "please", "read", "the", "documentation", "in", "access", "ecmwf", "public", "datasets", "https", "confluence", "ecmwf", "int", "display", "webapi", "access", "ecmwf", "public", "datasets", "_", "follow", "the", "instructions", "in", "step", "4", "and", "save", "the", "ecmwf", "registration", "key", "as", "home", "ecmwfapirc", "or", "set", "ecmwf_api_key", "as", "the", "path", "to", "the", "key", "this", "function", "returns", "a", "daemon", "thread", "that", "runs", "in", "the", "background", "exiting", "python", "will", "kill", "this", "thread", "however", "this", "thread", "will", "not", "block", "the", "main", "thread", "or", "other", "threads", "this", "thread", "will", "terminate", "when", "the", "file", "is", "downloaded", "or", "if", "the", "thread", "raises", "an", "unhandled", "exception", "you", "may", "submit", "multiple", "requests", "simultaneously", "to", "break", "up", "large", "downloads", "you", "can", "also", "check", "the", "status", "and", "retrieve", "downloads", "online", "at", "http", "apps", "ecmwf", "int", "webmars", "joblist", "this", "is", "useful", "if", "you", "kill", "the", "thread", "downloads", "expire", "after", "24", "hours", "warning", "your", "request", "may", "be", "queued", "online", "for", "an", "hour", "or", "more", "before", "it", "begins", "to", "download", "precipitable", "water", "math", "p_", "wat", "is", "equivalent", "to", "the", "total", "column", "of", "water", "vapor", "tcwv", "but", "the", "units", "given", "by", "ecmwf", "macc", "reanalysis", "are", "kg", "m", "2", "at", "stp", "1", "atm", "25", "c", "divide", "by", "ten", "to", "convert", "to", "centimeters", "of", "precipitable", "water", "math", "p_", "wat", "left", "text", "cm", "right", "tcwv", "left", "frac", "text", "kg", "text", "m", "2", "right", "frac", "100", "frac", "text", "cm", "text", "m", "1000", "frac", "text", "kg", "text", "m", "3", "the", "keynames", "available", "for", "the", "params", "argument", "are", "given", "by", "const", "pvlib", "iotools", "ecmwf_macc", "params", "which", "maps", "the", "keys", "to", "codes", "used", "in", "the", "api", "the", "following", "keynames", "are", "available", "keyname", "description", "tcwv", "total", "column", "water", "vapor", "in", "kg", "m", "2", "at", "stp", "aod550", "aerosol", "optical", "depth", "measured", "at", "550", "nm", "aod469", "aerosol", "optical", "depth", "measured", "at", "469", "nm", "aod670", "aerosol", "optical", "depth", "measured", "at", "670", "nm", "aod865", "aerosol", "optical", "depth", "measured", "at", "865", "nm", "aod1240", "aerosol", "optical", "depth", "measured", "at", "1240", "nm", "if", "lookup_params", "is", "false", "then", "params", "must", "contain", "the", "codes", "preformatted", "according", "to", "the", "ecmwf", "macc", "reanalysis", "api", "this", "is", "useful", "if", "you", "want", "to", "retrieve", "codes", "that", "are", "not", "mapped", "in", "const", "pvlib", "iotools", "ecmwf_macc", "params", "specify", "a", "custom", "target", "function", "to", "modify", "how", "the", "ecmwf", "api", "function", "server", "retrieve", "is", "called", "the", "target", "function", "must", "have", "the", "following", "signature", "in", "which", "the", "parameter", "definitions", "are", "similar", "to", "func", "pvlib", "iotools", "get_ecmwf_macc", "target", "server", "startdate", "enddate", "params", "filename", "none", "examples", "retrieve", "the", "aod", "measured", "at", "550", "nm", "and", "the", "total", "column", "of", "water", "vapor", "for", "november", "1", "2012", "from", "datetime", "import", "date", "from", "pvlib", "iotools", "import", "get_ecmwf_macc", "filename", "aod_tcwv_20121101", "nc", "nc", "extension", "added", "if", "missing", "params", "aod550", "tcwv", "start", "end", "date", "2012", "11", "1", "t", "get_ecmwf_macc", "filename", "params", "start", "end", "t", "is_alive", "true", "if", "not", "filename", "endswith", "nc", "filename", "nc", "if", "lookup_params", "try", "params", "join", "params", "get", "p", "for", "p", "in", "params", "except", "typeerror", "params", "params", "get", "params", "startdate", "start", "strftime", "y", "m", "d", "enddate", "end", "strftime", "y", "m", "d", "if", "not", "server", "server", "ecmwfdataserver", "t", "threading", "thread", "target", "target", "daemon", "true", "args", "server", "startdate", "enddate", "params", "filename", "t", "start", "return", "t"], "doc_len": 630}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::ECMWF_MACC.__init__", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": "ECMWF_MACC", "func_name": "__init__", "text": "文件路径: pvlib/iotools/ecmwf_macc.py, 类名: ECMWF_MACC\n    def __init__(self, filename):\n        self.data = netCDF4.Dataset(filename)\n        # data variables and dimensions\n        variables = set(self.data.variables.keys())\n        dimensions = set(self.data.dimensions.keys())\n        self.keys = tuple(variables - dimensions)\n        # size of lat/lon dimensions\n        self.lat_size = self.data.dimensions['latitude'].size\n        self.lon_size = self.data.dimensions['longitude'].size\n        # spatial resolution in degrees\n        self.delta_lat = -180.0 / (self.lat_size - 1)  # from north to south\n        self.delta_lon = 360.0 / self.lon_size  # from west to east\n        # time resolution in hours\n        self.time_size = self.data.dimensions['time'].size\n        self.start_time = self.data['time'][0]\n        self.end_time = self.data['time'][-1]\n        self.time_range = self.end_time - self.start_time\n        self.delta_time = self.time_range / (self.time_size - 1)\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "ecmwf_macc", "def", "__init__", "self", "filename", "self", "data", "netcdf4", "dataset", "filename", "data", "variables", "and", "dimensions", "variables", "set", "self", "data", "variables", "keys", "dimensions", "set", "self", "data", "dimensions", "keys", "self", "keys", "tuple", "variables", "dimensions", "size", "of", "lat", "lon", "dimensions", "self", "lat_size", "self", "data", "dimensions", "latitude", "size", "self", "lon_size", "self", "data", "dimensions", "longitude", "size", "spatial", "resolution", "in", "degrees", "self", "delta_lat", "180", "0", "self", "lat_size", "1", "from", "north", "to", "south", "self", "delta_lon", "360", "0", "self", "lon_size", "from", "west", "to", "east", "time", "resolution", "in", "hours", "self", "time_size", "self", "data", "dimensions", "time", "size", "self", "start_time", "self", "data", "time", "0", "self", "end_time", "self", "data", "time", "1", "self", "time_range", "self", "end_time", "self", "start_time", "self", "delta_time", "self", "time_range", "self", "time_size", "1"], "doc_len": 115}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::ECMWF_MACC.get_nearest_indices", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": "ECMWF_MACC", "func_name": "get_nearest_indices", "text": "文件路径: pvlib/iotools/ecmwf_macc.py, 类名: ECMWF_MACC\n    def get_nearest_indices(self, latitude, longitude):\n        \"\"\"\n        Get nearest indices to (latitude, longitude).\n\n        Parmaeters\n        ----------\n        latitude : float\n            Latitude in degrees\n        longitude : float\n            Longitude in degrees\n\n        Returns\n        -------\n        idx_lat : int\n            index of nearest latitude\n        idx_lon : int\n            index of nearest longitude\n        \"\"\"\n        # index of nearest latitude\n        idx_lat = int(round((latitude - 90.0) / self.delta_lat))\n        # avoid out of bounds latitudes\n        if idx_lat < 0:\n            idx_lat = 0  # if latitude == 90, north pole\n        elif idx_lat > self.lat_size:\n            idx_lat = self.lat_size  # if latitude == -90, south pole\n        # adjust longitude from -180/180 to 0/360\n        longitude = longitude % 360.0\n        # index of nearest longitude\n        idx_lon = int(round(longitude / self.delta_lon)) % self.lon_size\n        return idx_lat, idx_lon\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "ecmwf_macc", "def", "get_nearest_indices", "self", "latitude", "longitude", "get", "nearest", "indices", "to", "latitude", "longitude", "parmaeters", "latitude", "float", "latitude", "in", "degrees", "longitude", "float", "longitude", "in", "degrees", "returns", "idx_lat", "int", "index", "of", "nearest", "latitude", "idx_lon", "int", "index", "of", "nearest", "longitude", "index", "of", "nearest", "latitude", "idx_lat", "int", "round", "latitude", "90", "0", "self", "delta_lat", "avoid", "out", "of", "bounds", "latitudes", "if", "idx_lat", "0", "idx_lat", "0", "if", "latitude", "90", "north", "pole", "elif", "idx_lat", "self", "lat_size", "idx_lat", "self", "lat_size", "if", "latitude", "90", "south", "pole", "adjust", "longitude", "from", "180", "180", "to", "0", "360", "longitude", "longitude", "360", "0", "index", "of", "nearest", "longitude", "idx_lon", "int", "round", "longitude", "self", "delta_lon", "self", "lon_size", "return", "idx_lat", "idx_lon"], "doc_len": 106}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::ECMWF_MACC.interp_data", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": "ECMWF_MACC", "func_name": "interp_data", "text": "文件路径: pvlib/iotools/ecmwf_macc.py, 类名: ECMWF_MACC\n    def interp_data(self, latitude, longitude, utc_time, param):\n        \"\"\"\n        Interpolate ``param`` values to ``utc_time`` using indices nearest to\n        (``latitude, longitude``).\n\n        Parmaeters\n        ----------\n        latitude : float\n            Latitude in degrees\n        longitude : float\n            Longitude in degrees\n        utc_time : datetime.datetime or datetime.date\n            Naive or UTC date or datetime to interpolate\n        param : str\n            Name of the parameter to interpolate from the data\n\n        Returns\n        -------\n        Interpolated ``param`` value at (``utc_time, latitude, longitude``)\n\n        Examples\n        --------\n        Use this to get a single value of a parameter in the data at a specific\n        time and set of (latitude, longitude) coordinates.\n\n        >>> from datetime import datetime\n        >>> from pvlib.iotools import ecmwf_macc\n        >>> data = ecmwf_macc.ECMWF_MACC('aod_tcwv_20121101.nc')\n        >>> dt = datetime(2012, 11, 1, 11, 33, 1)\n        >>> data.interp_data(38.2, -122.1, dt, 'aod550')\n        \"\"\"\n        nctime = self.data['time']  # time\n        ilat, ilon = self.get_nearest_indices(latitude, longitude)\n        # time index before\n        before = netCDF4.date2index(utc_time, nctime, select='before')\n        fbefore = self.data[param][before, ilat, ilon]\n        fafter = self.data[param][before + 1, ilat, ilon]\n        dt_num = netCDF4.date2num(utc_time, nctime.units)\n        time_ratio = (dt_num - nctime[before]) / self.delta_time\n        return fbefore + (fafter - fbefore) * time_ratio\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "ecmwf_macc", "def", "interp_data", "self", "latitude", "longitude", "utc_time", "param", "interpolate", "param", "values", "to", "utc_time", "using", "indices", "nearest", "to", "latitude", "longitude", "parmaeters", "latitude", "float", "latitude", "in", "degrees", "longitude", "float", "longitude", "in", "degrees", "utc_time", "datetime", "datetime", "or", "datetime", "date", "naive", "or", "utc", "date", "or", "datetime", "to", "interpolate", "param", "str", "name", "of", "the", "parameter", "to", "interpolate", "from", "the", "data", "returns", "interpolated", "param", "value", "at", "utc_time", "latitude", "longitude", "examples", "use", "this", "to", "get", "a", "single", "value", "of", "a", "parameter", "in", "the", "data", "at", "a", "specific", "time", "and", "set", "of", "latitude", "longitude", "coordinates", "from", "datetime", "import", "datetime", "from", "pvlib", "iotools", "import", "ecmwf_macc", "data", "ecmwf_macc", "ecmwf_macc", "aod_tcwv_20121101", "nc", "dt", "datetime", "2012", "11", "1", "11", "33", "1", "data", "interp_data", "38", "2", "122", "1", "dt", "aod550", "nctime", "self", "data", "time", "time", "ilat", "ilon", "self", "get_nearest_indices", "latitude", "longitude", "time", "index", "before", "before", "netcdf4", "date2index", "utc_time", "nctime", "select", "before", "fbefore", "self", "data", "param", "before", "ilat", "ilon", "fafter", "self", "data", "param", "before", "1", "ilat", "ilon", "dt_num", "netcdf4", "date2num", "utc_time", "nctime", "units", "time_ratio", "dt_num", "nctime", "before", "self", "delta_time", "return", "fbefore", "fafter", "fbefore", "time_ratio"], "doc_len": 174}
{"doc_id": "pvlib/iotools/ecmwf_macc.py::read_ecmwf_macc", "file_path": "pvlib/iotools/ecmwf_macc.py", "class_name": null, "func_name": "read_ecmwf_macc", "text": "文件路径: pvlib/iotools/ecmwf_macc.py\ndef read_ecmwf_macc(filename, latitude, longitude, utc_time_range=None):\n    \"\"\"\n    Read data from ECMWF MACC reanalysis netCDF4 file.\n\n    Parameters\n    ----------\n    filename : string\n        full path to netCDF4 data file.\n    latitude : float\n        latitude in degrees\n    longitude : float\n        longitude in degrees\n    utc_time_range : sequence of datetime.datetime\n        pair of start and end naive or UTC date-times\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        dataframe for specified range of UTC date-times\n    \"\"\"\n    ecmwf_macc = ECMWF_MACC(filename)\n    try:\n        ilat, ilon = ecmwf_macc.get_nearest_indices(latitude, longitude)\n        nctime = ecmwf_macc.data['time']\n        if utc_time_range:\n            start_idx = netCDF4.date2index(\n                utc_time_range[0], nctime, select='before')\n            end_idx = netCDF4.date2index(\n                utc_time_range[-1], nctime, select='after')\n            time_slice = slice(start_idx, end_idx + 1)\n        else:\n            time_slice = slice(0, ecmwf_macc.time_size)\n        times = netCDF4.num2date(nctime[time_slice], nctime.units)\n        df = {k: ecmwf_macc.data[k][time_slice, ilat, ilon]\n              for k in ecmwf_macc.keys}\n        if ECMWF_MACC.TCWV in df:\n            # convert total column water vapor in kg/m^2 at (1-atm, 25-degC) to\n            # precipitable water in cm\n            df['precipitable_water'] = df[ECMWF_MACC.TCWV] / 10.0\n    finally:\n        ecmwf_macc.data.close()\n    return pd.DataFrame(df, index=times.astype('datetime64[s]'))\n", "tokens": ["pvlib", "iotools", "ecmwf_macc", "py", "def", "read_ecmwf_macc", "filename", "latitude", "longitude", "utc_time_range", "none", "read", "data", "from", "ecmwf", "macc", "reanalysis", "netcdf4", "file", "parameters", "filename", "string", "full", "path", "to", "netcdf4", "data", "file", "latitude", "float", "latitude", "in", "degrees", "longitude", "float", "longitude", "in", "degrees", "utc_time_range", "sequence", "of", "datetime", "datetime", "pair", "of", "start", "and", "end", "naive", "or", "utc", "date", "times", "returns", "data", "pandas", "dataframe", "dataframe", "for", "specified", "range", "of", "utc", "date", "times", "ecmwf_macc", "ecmwf_macc", "filename", "try", "ilat", "ilon", "ecmwf_macc", "get_nearest_indices", "latitude", "longitude", "nctime", "ecmwf_macc", "data", "time", "if", "utc_time_range", "start_idx", "netcdf4", "date2index", "utc_time_range", "0", "nctime", "select", "before", "end_idx", "netcdf4", "date2index", "utc_time_range", "1", "nctime", "select", "after", "time_slice", "slice", "start_idx", "end_idx", "1", "else", "time_slice", "slice", "0", "ecmwf_macc", "time_size", "times", "netcdf4", "num2date", "nctime", "time_slice", "nctime", "units", "df", "k", "ecmwf_macc", "data", "k", "time_slice", "ilat", "ilon", "for", "k", "in", "ecmwf_macc", "keys", "if", "ecmwf_macc", "tcwv", "in", "df", "convert", "total", "column", "water", "vapor", "in", "kg", "m", "2", "at", "1", "atm", "25", "degc", "to", "precipitable", "water", "in", "cm", "df", "precipitable_water", "df", "ecmwf_macc", "tcwv", "10", "0", "finally", "ecmwf_macc", "data", "close", "return", "pd", "dataframe", "df", "index", "times", "astype", "datetime64", "s"], "doc_len": 172}
{"doc_id": "pvlib/iotools/epw.py::read_epw", "file_path": "pvlib/iotools/epw.py", "class_name": null, "func_name": "read_epw", "text": "文件路径: pvlib/iotools/epw.py\ndef read_epw(filename, coerce_year=None):\n    r'''\n    Read an EPW file in to a pandas dataframe.\n\n    Note that values contained in the metadata dictionary are unchanged\n    from the EPW file.\n\n    EPW files are commonly used by building simulation professionals\n    and are widely available on the web. For example via:\n    https://energyplus.net/weather , http://climate.onebuilding.org or\n    http://www.ladybug.tools/epwmap/\n\n\n    Parameters\n    ----------\n    filename : String\n        Can be a relative file path, absolute file path, or url.\n\n    coerce_year : None or int, default None\n        If supplied, the year of the data will be set to this value. This can\n        be a useful feature because EPW data is composed of data from\n        different years.\n        Warning: EPW files always have 365*24 = 8760 data rows;\n        be careful with the use of leap years.\n\n\n    Returns\n    -------\n    data : DataFrame\n        A pandas dataframe with the columns described in the table\n        below. For more detailed descriptions of each component, please\n        consult the EnergyPlus Auxiliary Programs documentation [1]_\n\n    metadata : dict\n        The site metadata available in the file.\n\n    See Also\n    --------\n    pvlib.iotools.parse_epw\n\n    Notes\n    -----\n\n    The returned structures have the following fields.\n\n    ===============   ======  =========================================\n    key               format  description\n    ===============   ======  =========================================\n    loc               String  default identifier, not used\n    city              String  site loccation\n    state-prov        String  state, province or region (if available)\n    country           String  site country code\n    data_type         String  type of original data source\n    WMO_code          String  WMO identifier\n    latitude          Float   site latitude\n    longitude         Float   site longitude\n    TZ                Float   UTC offset\n    altitude          Float   site elevation\n    ===============   ======  =========================================\n\n\n    +-------------------------------+-----------------------------------------+\n    | EPWData field                 | description                             |\n    +===============================+=========================================+\n    | index                         | A pandas datetime index. NOTE, times are|\n    |                               | set to local standard time (daylight    |\n    |                               | savings is not included). Days run from |\n    |                               | 0-23h to comply with PVLIB's convention.|\n    +-------------------------------+-----------------------------------------+\n    | year                          | Year, from original EPW file. Can be    |\n    |                               | overwritten using coerce function.      |\n    +-------------------------------+-----------------------------------------+\n    | month                         | Month, from original EPW file.          |\n    +-------------------------------+-----------------------------------------+\n    | day                           | Day of the month, from original EPW     |\n    |                               | file.                                   |\n    +-------------------------------+-----------------------------------------+\n    | hour                          | Hour of the day from original EPW file. |\n    |                               | Note that EPW's convention of 1-24h is  |\n    |                               | not taken over in the index dataframe   |\n    |                               | used in PVLIB.                          |\n    +-------------------------------+-----------------------------------------+\n    | minute                        | Minute, from original EPW file. Not     |\n    |                               | used.                                   |\n    +-------------------------------+-----------------------------------------+\n    | data_source_unct              | Data source and uncertainty flags. See  |\n    |                               | [1]_, chapter 2.13                      |\n    +-------------------------------+-----------------------------------------+\n    | temp_air                      | Dry bulb temperature at the time        |\n    |                               | indicated, deg C                        |\n    +-------------------------------+-----------------------------------------+\n    | temp_dew                      | Dew-point temperature at the time       |\n    |                               | indicated, deg C                        |\n    +-------------------------------+-----------------------------------------+\n    | relative_humidity             | Relative humidity at the time indicated,|\n    |                               | percent                                 |\n    +-------------------------------+-----------------------------------------+\n    | atmospheric_pressure          | Station pressure at the time indicated, |\n    |                               | Pa                                      |\n    +-------------------------------+-----------------------------------------+\n    | etr                           | Extraterrestrial horizontal radiation   |\n    |                               | recv'd during 60 minutes prior to       |\n    |                               | timestamp, Wh/m^2                       |\n    +-------------------------------+-----------------------------------------+\n    | etrn                          | Extraterrestrial normal radiation recv'd|\n    |                               | during 60 minutes prior to timestamp,   |\n    |                               | Wh/m^2                                  |\n    +-------------------------------+-----------------------------------------+\n    | ghi_infrared                  | Horizontal infrared radiation recv'd    |\n    |                               | during 60 minutes prior to timestamp,   |\n    |                               | Wh/m^2                                  |\n    +-------------------------------+-----------------------------------------+\n    | ghi                           | Direct and diffuse horizontal radiation |\n    |                               | recv'd during 60 minutes prior to       |\n    |                               | timestamp, Wh/m^2                       |\n    +-------------------------------+-----------------------------------------+\n    | dni                           | Amount of direct normal radiation       |\n    |                               | (modeled) recv'd during 60 minutes prior|\n    |                               | to timestamp, Wh/m^2                    |\n    +-------------------------------+-----------------------------------------+\n    | dhi                           | Amount of diffuse horizontal radiation  |\n    |                               | recv'd during 60 minutes prior to       |\n    |                               | timestamp, Wh/m^2                       |\n    +-------------------------------+-----------------------------------------+\n    | global_hor_illum              | Avg. total horizontal illuminance recv'd|\n    |                               | during the 60 minutes prior to          |\n    |                               | timestamp, lx                           |\n    +-------------------------------+-----------------------------------------+\n    | direct_normal_illum           | Avg. direct normal illuminance recv'd   |\n    |                               | during the 60 minutes prior to          |\n    |                               | timestamp, lx                           |\n    +-------------------------------+-----------------------------------------+\n    | diffuse_horizontal_illum      | Avg. horizontal diffuse illuminance     |\n    |                               | recv'd during the 60 minutes prior to   |\n    |                               | timestamp, lx                           |\n    +-------------------------------+-----------------------------------------+\n    | zenith_luminance              | Avg. luminance at the sky's zenith      |\n    |                               | during the 60 minutes prior to          |\n    |                               | timestamp, cd/m^2                       |\n    +-------------------------------+-----------------------------------------+\n    | wind_direction                | Wind direction at time indicated,       |\n    |                               | degrees from north (360 = north; 0 =    |\n    |                               | undefined,calm)                         |\n    +-------------------------------+-----------------------------------------+\n    | wind_speed                    | Wind speed at the time indicated, m/s   |\n    +-------------------------------+-----------------------------------------+\n    | total_sky_cover               | Amount of sky dome covered by clouds or |\n    |                               | obscuring phenomena at time stamp,      |\n    |                               | tenths of sky                           |\n    +-------------------------------+-----------------------------------------+\n    | opaque_sky_cover              | Amount of sky dome covered by clouds or |\n    |                               | obscuring phenomena that prevent        |\n    |                               | observing the sky at time stamp, tenths |\n    |                               | of sky                                  |\n    +-------------------------------+-----------------------------------------+\n    | visibility                    | Horizontal visibility at the time       |\n    |                               | indicated, km                           |\n    +-------------------------------+-----------------------------------------+\n    | ceiling_height                | Height of cloud base above local terrain|\n    |                               | (7777=unlimited), meter                 |\n    +-------------------------------+-----------------------------------------+\n    | present_weather_observation   | Indicator for remaining fields: If 0,   |\n    |                               | then the observed weather codes are     |\n    |                               | taken from the following field. If 9,   |\n    |                               | then missing weather is assumed.        |\n    +-------------------------------+-----------------------------------------+\n    | present_weather_codes         | Present weather code, see [1], chapter  |\n    |                               | 2.9.1.28                                |\n    +-------------------------------+-----------------------------------------+\n    | precipitable_water            | Total precipitable water contained in a |\n    |                               | column of unit cross section from earth |\n    |                               | to top of atmosphere, cm. Note that some|\n    |                               | old \\*_TMY3.epw files may have incorrect|\n    |                               | unit if it was retrieved from           |\n    |                               | www.energyplus.net.                     |\n    +-------------------------------+-----------------------------------------+\n    | aerosol_optical_depth         | The broadband aerosol optical depth per |\n    |                               | unit of air mass due to extinction by   |\n    |                               | aerosol component of atmosphere,        |\n    |                               | unitless                                |\n    +-------------------------------+-----------------------------------------+\n    | snow_depth                    | Snow depth in centimeters on the day    |\n    |                               | indicated, (999 = missing data)         |\n    +-------------------------------+-----------------------------------------+\n    | days_since_last_snowfall      | Number of days since last snowfall      |\n    |                               | (maximum value of 88, where 88 = 88 or  |\n    |                               | greater days; 99 = missing data)        |\n    +-------------------------------+-----------------------------------------+\n    | albedo                        | The ratio of reflected solar irradiance |\n    |                               | to global horizontal irradiance,        |\n    |                               | unitless                                |\n    +-------------------------------+-----------------------------------------+\n    | liquid_precipitation_depth    | The amount of liquid precipitation      |\n    |                               | observed at indicated time for the      |\n    |                               | period indicated in the liquid          |\n    |                               | precipitation quantity field,           |\n    |                               | millimeter                              |\n    +-------------------------------+-----------------------------------------+\n    | liquid_precipitation_quantity | The period of accumulation for the      |\n    |                               | liquid precipitation depth field, hour  |\n    +-------------------------------+-----------------------------------------+\n\n\n    References\n    ----------\n\n    .. [1] `EnergyPlus documentation, Auxiliary Programs\n       <https://energyplus.net/documentation>`_\n    '''\n\n    if str(filename).startswith('http'):\n        # Attempts to download online EPW file\n        # See comments above for possible online sources\n        request = Request(filename, headers={'User-Agent': (\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) '\n            'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 '\n            'Safari/537.36')})\n        response = urlopen(request)\n        with io.StringIO(response.read().decode(errors='ignore')) as csvdata:\n            data, meta = parse_epw(csvdata, coerce_year)\n\n    else:\n        # Assume it's accessible via the file system\n        with open(str(filename), 'r') as csvdata:\n            data, meta = parse_epw(csvdata, coerce_year)\n\n\n    return data, meta\n", "tokens": ["pvlib", "iotools", "epw", "py", "def", "read_epw", "filename", "coerce_year", "none", "r", "read", "an", "epw", "file", "in", "to", "a", "pandas", "dataframe", "note", "that", "values", "contained", "in", "the", "metadata", "dictionary", "are", "unchanged", "from", "the", "epw", "file", "epw", "files", "are", "commonly", "used", "by", "building", "simulation", "professionals", "and", "are", "widely", "available", "on", "the", "web", "for", "example", "via", "https", "energyplus", "net", "weather", "http", "climate", "onebuilding", "org", "or", "http", "www", "ladybug", "tools", "epwmap", "parameters", "filename", "string", "can", "be", "a", "relative", "file", "path", "absolute", "file", "path", "or", "url", "coerce_year", "none", "or", "int", "default", "none", "if", "supplied", "the", "year", "of", "the", "data", "will", "be", "set", "to", "this", "value", "this", "can", "be", "a", "useful", "feature", "because", "epw", "data", "is", "composed", "of", "data", "from", "different", "years", "warning", "epw", "files", "always", "have", "365", "24", "8760", "data", "rows", "be", "careful", "with", "the", "use", "of", "leap", "years", "returns", "data", "dataframe", "a", "pandas", "dataframe", "with", "the", "columns", "described", "in", "the", "table", "below", "for", "more", "detailed", "descriptions", "of", "each", "component", "please", "consult", "the", "energyplus", "auxiliary", "programs", "documentation", "1", "_", "metadata", "dict", "the", "site", "metadata", "available", "in", "the", "file", "see", "also", "pvlib", "iotools", "parse_epw", "notes", "the", "returned", "structures", "have", "the", "following", "fields", "key", "format", "description", "loc", "string", "default", "identifier", "not", "used", "city", "string", "site", "loccation", "state", "prov", "string", "state", "province", "or", "region", "if", "available", "country", "string", "site", "country", "code", "data_type", "string", "type", "of", "original", "data", "source", "wmo_code", "string", "wmo", "identifier", "latitude", "float", "site", "latitude", "longitude", "float", "site", "longitude", "tz", "float", "utc", "offset", "altitude", "float", "site", "elevation", "epwdata", "field", "description", "index", "a", "pandas", "datetime", "index", "note", "times", "are", "set", "to", "local", "standard", "time", "daylight", "savings", "is", "not", "included", "days", "run", "from", "0", "23h", "to", "comply", "with", "pvlib", "s", "convention", "year", "year", "from", "original", "epw", "file", "can", "be", "overwritten", "using", "coerce", "function", "month", "month", "from", "original", "epw", "file", "day", "day", "of", "the", "month", "from", "original", "epw", "file", "hour", "hour", "of", "the", "day", "from", "original", "epw", "file", "note", "that", "epw", "s", "convention", "of", "1", "24h", "is", "not", "taken", "over", "in", "the", "index", "dataframe", "used", "in", "pvlib", "minute", "minute", "from", "original", "epw", "file", "not", "used", "data_source_unct", "data", "source", "and", "uncertainty", "flags", "see", "1", "_", "chapter", "2", "13", "temp_air", "dry", "bulb", "temperature", "at", "the", "time", "indicated", "deg", "c", "temp_dew", "dew", "point", "temperature", "at", "the", "time", "indicated", "deg", "c", "relative_humidity", "relative", "humidity", "at", "the", "time", "indicated", "percent", "atmospheric_pressure", "station", "pressure", "at", "the", "time", "indicated", "pa", "etr", "extraterrestrial", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "etrn", "extraterrestrial", "normal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghi_infrared", "horizontal", "infrared", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghi", "direct", "and", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "dni", "amount", "of", "direct", "normal", "radiation", "modeled", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "dhi", "amount", "of", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "global_hor_illum", "avg", "total", "horizontal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "direct_normal_illum", "avg", "direct", "normal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "diffuse_horizontal_illum", "avg", "horizontal", "diffuse", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "zenith_luminance", "avg", "luminance", "at", "the", "sky", "s", "zenith", "during", "the", "60", "minutes", "prior", "to", "timestamp", "cd", "m", "2", "wind_direction", "wind", "direction", "at", "time", "indicated", "degrees", "from", "north", "360", "north", "0", "undefined", "calm", "wind_speed", "wind", "speed", "at", "the", "time", "indicated", "m", "s", "total_sky_cover", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenomena", "at", "time", "stamp", "tenths", "of", "sky", "opaque_sky_cover", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenomena", "that", "prevent", "observing", "the", "sky", "at", "time", "stamp", "tenths", "of", "sky", "visibility", "horizontal", "visibility", "at", "the", "time", "indicated", "km", "ceiling_height", "height", "of", "cloud", "base", "above", "local", "terrain", "7777", "unlimited", "meter", "present_weather_observation", "indicator", "for", "remaining", "fields", "if", "0", "then", "the", "observed", "weather", "codes", "are", "taken", "from", "the", "following", "field", "if", "9", "then", "missing", "weather", "is", "assumed", "present_weather_codes", "present", "weather", "code", "see", "1", "chapter", "2", "9", "1", "28", "precipitable_water", "total", "precipitable", "water", "contained", "in", "a", "column", "of", "unit", "cross", "section", "from", "earth", "to", "top", "of", "atmosphere", "cm", "note", "that", "some", "old", "_tmy3", "epw", "files", "may", "have", "incorrect", "unit", "if", "it", "was", "retrieved", "from", "www", "energyplus", "net", "aerosol_optical_depth", "the", "broadband", "aerosol", "optical", "depth", "per", "unit", "of", "air", "mass", "due", "to", "extinction", "by", "aerosol", "component", "of", "atmosphere", "unitless", "snow_depth", "snow", "depth", "in", "centimeters", "on", "the", "day", "indicated", "999", "missing", "data", "days_since_last_snowfall", "number", "of", "days", "since", "last", "snowfall", "maximum", "value", "of", "88", "where", "88", "88", "or", "greater", "days", "99", "missing", "data", "albedo", "the", "ratio", "of", "reflected", "solar", "irradiance", "to", "global", "horizontal", "irradiance", "unitless", "liquid_precipitation_depth", "the", "amount", "of", "liquid", "precipitation", "observed", "at", "indicated", "time", "for", "the", "period", "indicated", "in", "the", "liquid", "precipitation", "quantity", "field", "millimeter", "liquid_precipitation_quantity", "the", "period", "of", "accumulation", "for", "the", "liquid", "precipitation", "depth", "field", "hour", "references", "1", "energyplus", "documentation", "auxiliary", "programs", "https", "energyplus", "net", "documentation", "_", "if", "str", "filename", "startswith", "http", "attempts", "to", "download", "online", "epw", "file", "see", "comments", "above", "for", "possible", "online", "sources", "request", "request", "filename", "headers", "user", "agent", "mozilla", "5", "0", "macintosh", "intel", "mac", "os", "x", "10_13_5", "applewebkit", "537", "36", "khtml", "like", "gecko", "chrome", "67", "0", "3396", "87", "safari", "537", "36", "response", "urlopen", "request", "with", "io", "stringio", "response", "read", "decode", "errors", "ignore", "as", "csvdata", "data", "meta", "parse_epw", "csvdata", "coerce_year", "else", "assume", "it", "s", "accessible", "via", "the", "file", "system", "with", "open", "str", "filename", "r", "as", "csvdata", "data", "meta", "parse_epw", "csvdata", "coerce_year", "return", "data", "meta"], "doc_len": 894}
{"doc_id": "pvlib/iotools/epw.py::parse_epw", "file_path": "pvlib/iotools/epw.py", "class_name": null, "func_name": "parse_epw", "text": "文件路径: pvlib/iotools/epw.py\ndef parse_epw(csvdata, coerce_year=None):\n    \"\"\"\n    Given a file-like buffer with data in Energy Plus Weather (EPW) format,\n    parse the data into a dataframe.\n\n    Parameters\n    ----------\n    csvdata : file-like buffer\n        a file-like buffer containing data in the EPW format\n\n    coerce_year : None or int, default None\n        If supplied, the year of the data will be set to this value. This can\n        be a useful feature because EPW data is composed of data from\n        different years.\n        Warning: EPW files always have 365*24 = 8760 data rows;\n        be careful with the use of leap years.\n\n    Returns\n    -------\n    data : DataFrame\n        A pandas dataframe with the columns described in the table\n        below. For more detailed descriptions of each component, please\n        consult the EnergyPlus Auxiliary Programs documentation\n        available at: https://energyplus.net/documentation.\n\n    metadata : dict\n        The site metadata available in the file.\n\n    See Also\n    --------\n    pvlib.iotools.read_epw\n    \"\"\"\n    # Read line with metadata\n    firstline = csvdata.readline()\n\n    head = ['loc', 'city', 'state-prov', 'country', 'data_type', 'WMO_code',\n            'latitude', 'longitude', 'TZ', 'altitude']\n    meta = dict(zip(head, firstline.rstrip('\\n').split(\",\")))\n\n    meta['altitude'] = float(meta['altitude'])\n    meta['latitude'] = float(meta['latitude'])\n    meta['longitude'] = float(meta['longitude'])\n    meta['TZ'] = float(meta['TZ'])\n\n    colnames = ['year', 'month', 'day', 'hour', 'minute', 'data_source_unct',\n                'temp_air', 'temp_dew', 'relative_humidity',\n                'atmospheric_pressure', 'etr', 'etrn', 'ghi_infrared', 'ghi',\n                'dni', 'dhi', 'global_hor_illum', 'direct_normal_illum',\n                'diffuse_horizontal_illum', 'zenith_luminance',\n                'wind_direction', 'wind_speed', 'total_sky_cover',\n                'opaque_sky_cover', 'visibility', 'ceiling_height',\n                'present_weather_observation', 'present_weather_codes',\n                'precipitable_water', 'aerosol_optical_depth', 'snow_depth',\n                'days_since_last_snowfall', 'albedo',\n                'liquid_precipitation_depth', 'liquid_precipitation_quantity']\n\n    # We only have to skip 6 rows instead of 7 because we have already used\n    # the realine call above.\n    data = pd.read_csv(csvdata, skiprows=6, header=0, names=colnames)\n\n    # Change to single year if requested\n    if coerce_year is not None:\n        data[\"year\"] = coerce_year\n\n    # create index that supplies correct date and time zone information\n    dts = data[['month', 'day']].astype(str).apply(lambda x: x.str.zfill(2))\n    hrs = (data['hour'] - 1).astype(str).str.zfill(2)\n    dtscat = data['year'].astype(str) + dts['month'] + dts['day'] + hrs\n    idx = pd.to_datetime(dtscat, format='%Y%m%d%H')\n    idx = idx.dt.tz_localize(int(meta['TZ'] * 3600))\n    data.index = idx\n\n    return data, meta\n", "tokens": ["pvlib", "iotools", "epw", "py", "def", "parse_epw", "csvdata", "coerce_year", "none", "given", "a", "file", "like", "buffer", "with", "data", "in", "energy", "plus", "weather", "epw", "format", "parse", "the", "data", "into", "a", "dataframe", "parameters", "csvdata", "file", "like", "buffer", "a", "file", "like", "buffer", "containing", "data", "in", "the", "epw", "format", "coerce_year", "none", "or", "int", "default", "none", "if", "supplied", "the", "year", "of", "the", "data", "will", "be", "set", "to", "this", "value", "this", "can", "be", "a", "useful", "feature", "because", "epw", "data", "is", "composed", "of", "data", "from", "different", "years", "warning", "epw", "files", "always", "have", "365", "24", "8760", "data", "rows", "be", "careful", "with", "the", "use", "of", "leap", "years", "returns", "data", "dataframe", "a", "pandas", "dataframe", "with", "the", "columns", "described", "in", "the", "table", "below", "for", "more", "detailed", "descriptions", "of", "each", "component", "please", "consult", "the", "energyplus", "auxiliary", "programs", "documentation", "available", "at", "https", "energyplus", "net", "documentation", "metadata", "dict", "the", "site", "metadata", "available", "in", "the", "file", "see", "also", "pvlib", "iotools", "read_epw", "read", "line", "with", "metadata", "firstline", "csvdata", "readline", "head", "loc", "city", "state", "prov", "country", "data_type", "wmo_code", "latitude", "longitude", "tz", "altitude", "meta", "dict", "zip", "head", "firstline", "rstrip", "n", "split", "meta", "altitude", "float", "meta", "altitude", "meta", "latitude", "float", "meta", "latitude", "meta", "longitude", "float", "meta", "longitude", "meta", "tz", "float", "meta", "tz", "colnames", "year", "month", "day", "hour", "minute", "data_source_unct", "temp_air", "temp_dew", "relative_humidity", "atmospheric_pressure", "etr", "etrn", "ghi_infrared", "ghi", "dni", "dhi", "global_hor_illum", "direct_normal_illum", "diffuse_horizontal_illum", "zenith_luminance", "wind_direction", "wind_speed", "total_sky_cover", "opaque_sky_cover", "visibility", "ceiling_height", "present_weather_observation", "present_weather_codes", "precipitable_water", "aerosol_optical_depth", "snow_depth", "days_since_last_snowfall", "albedo", "liquid_precipitation_depth", "liquid_precipitation_quantity", "we", "only", "have", "to", "skip", "6", "rows", "instead", "of", "7", "because", "we", "have", "already", "used", "the", "realine", "call", "above", "data", "pd", "read_csv", "csvdata", "skiprows", "6", "header", "0", "names", "colnames", "change", "to", "single", "year", "if", "requested", "if", "coerce_year", "is", "not", "none", "data", "year", "coerce_year", "create", "index", "that", "supplies", "correct", "date", "and", "time", "zone", "information", "dts", "data", "month", "day", "astype", "str", "apply", "lambda", "x", "x", "str", "zfill", "2", "hrs", "data", "hour", "1", "astype", "str", "str", "zfill", "2", "dtscat", "data", "year", "astype", "str", "dts", "month", "dts", "day", "hrs", "idx", "pd", "to_datetime", "dtscat", "format", "y", "m", "d", "h", "idx", "idx", "dt", "tz_localize", "int", "meta", "tz", "3600", "data", "index", "idx", "return", "data", "meta"], "doc_len": 335}
{"doc_id": "pvlib/iotools/midc.py::format_index", "file_path": "pvlib/iotools/midc.py", "class_name": null, "func_name": "format_index", "text": "文件路径: pvlib/iotools/midc.py\ndef format_index(data):\n    \"\"\"Create DatetimeIndex for the Dataframe localized to the timezone provided\n    as the label of the second (time) column.\n\n    Parameters\n    ----------\n    data: Dataframe\n        Must contain 'DATE (MM/DD/YYYY)' column, second column must be labeled\n        with the timezone and contain times in 'HH:MM' format.\n\n    Returns\n    -------\n    data: Dataframe\n        Dataframe with DatetimeIndex localized to the provided timezone.\n    \"\"\"\n    tz_raw = data.columns[1]\n    timezone = TZ_MAP.get(tz_raw, tz_raw)\n    datetime = data['DATE (MM/DD/YYYY)'] + data[tz_raw]\n    datetime = pd.to_datetime(datetime, format='%m/%d/%Y%H:%M')\n    data = data.set_index(datetime)\n    data = data.tz_localize(timezone)\n    return data\n", "tokens": ["pvlib", "iotools", "midc", "py", "def", "format_index", "data", "create", "datetimeindex", "for", "the", "dataframe", "localized", "to", "the", "timezone", "provided", "as", "the", "label", "of", "the", "second", "time", "column", "parameters", "data", "dataframe", "must", "contain", "date", "mm", "dd", "yyyy", "column", "second", "column", "must", "be", "labeled", "with", "the", "timezone", "and", "contain", "times", "in", "hh", "mm", "format", "returns", "data", "dataframe", "dataframe", "with", "datetimeindex", "localized", "to", "the", "provided", "timezone", "tz_raw", "data", "columns", "1", "timezone", "tz_map", "get", "tz_raw", "tz_raw", "datetime", "data", "date", "mm", "dd", "yyyy", "data", "tz_raw", "datetime", "pd", "to_datetime", "datetime", "format", "m", "d", "y", "h", "m", "data", "data", "set_index", "datetime", "data", "data", "tz_localize", "timezone", "return", "data"], "doc_len": 98}
{"doc_id": "pvlib/iotools/midc.py::format_index_raw", "file_path": "pvlib/iotools/midc.py", "class_name": null, "func_name": "format_index_raw", "text": "文件路径: pvlib/iotools/midc.py\ndef format_index_raw(data):\n    \"\"\"Create DatetimeIndex for the Dataframe localized to the timezone provided\n    as the label of the third column.\n\n    Parameters\n    ----------\n    data: Dataframe\n        Must contain columns 'Year' and 'DOY'. Timezone must be found as the\n        label of the third (time) column.\n\n    Returns\n    -------\n    data: Dataframe\n        The data with a Datetime index localized to the provided timezone.\n    \"\"\"\n    tz_raw = data.columns[3]\n    timezone = TZ_MAP.get(tz_raw, tz_raw)\n    year = data.Year.apply(str)\n    jday = data.DOY.apply(lambda x: '{:03d}'.format(x))\n    time = data[tz_raw].apply(lambda x: '{:04d}'.format(x))\n    index = pd.to_datetime(year + jday + time, format=\"%Y%j%H%M\")\n    data = data.set_index(index)\n    data = data.tz_localize(timezone)\n    return data\n", "tokens": ["pvlib", "iotools", "midc", "py", "def", "format_index_raw", "data", "create", "datetimeindex", "for", "the", "dataframe", "localized", "to", "the", "timezone", "provided", "as", "the", "label", "of", "the", "third", "column", "parameters", "data", "dataframe", "must", "contain", "columns", "year", "and", "doy", "timezone", "must", "be", "found", "as", "the", "label", "of", "the", "third", "time", "column", "returns", "data", "dataframe", "the", "data", "with", "a", "datetime", "index", "localized", "to", "the", "provided", "timezone", "tz_raw", "data", "columns", "3", "timezone", "tz_map", "get", "tz_raw", "tz_raw", "year", "data", "year", "apply", "str", "jday", "data", "doy", "apply", "lambda", "x", "03d", "format", "x", "time", "data", "tz_raw", "apply", "lambda", "x", "04d", "format", "x", "index", "pd", "to_datetime", "year", "jday", "time", "format", "y", "j", "h", "m", "data", "data", "set_index", "index", "data", "data", "tz_localize", "timezone", "return", "data"], "doc_len": 112}
{"doc_id": "pvlib/iotools/midc.py::read_midc", "file_path": "pvlib/iotools/midc.py", "class_name": null, "func_name": "read_midc", "text": "文件路径: pvlib/iotools/midc.py\ndef read_midc(filename, variable_map={}, raw_data=False, **kwargs):\n    \"\"\"Read in National Renewable Energy Laboratory Measurement and\n    Instrumentation Data Center weather data.  The MIDC is described in [1]_.\n\n    Parameters\n    ----------\n    filename: string or file-like object\n        Filename, url, or file-like object of data to read.\n    variable_map: dictionary\n        Dictionary for mapping MIDC field names to pvlib names. Used to rename\n        the columns of the resulting DataFrame. Does not map names by default.\n        See Notes for an example.\n    raw_data: boolean\n        Set to true to use format_index_raw to correctly format the date/time\n        columns of MIDC raw data files.\n    kwargs : dict\n       Additional keyword arguments to pass to `pandas.read_csv`\n\n    Returns\n    -------\n    data: Dataframe\n        A dataframe with DatetimeIndex localized to the provided timezone.\n\n    Notes\n    -----\n    The `variable_map` argument should map fields from MIDC data to pvlib\n    names.\n\n    E.g. if a MIDC file contains the variable 'Global Horizontal [W/m^2]',\n    passing the dictionary below will rename the column to 'ghi' in\n    the returned Dataframe.\n\n             {'Global Horizontal [W/m^2]': 'ghi'}\n\n    See the MIDC_VARIABLE_MAP for collection of mappings by site.\n    For a full list of pvlib variable names see the\n    :ref:`variables_style_rules`.\n\n    Be sure to check the units for the variables you will use on the\n    `MIDC site <https://midcdmz.nrel.gov/>`_.\n\n    References\n    ----------\n    .. [1] NREL: Measurement and Instrumentation Data Center\n        `https://midcdmz.nrel.gov/ <https://midcdmz.nrel.gov/>`_\n    \"\"\"\n    data = pd.read_csv(filename, **kwargs)\n    if raw_data:\n        data = format_index_raw(data)\n    else:\n        data = format_index(data)\n    data = data.rename(columns=variable_map)\n    return data\n", "tokens": ["pvlib", "iotools", "midc", "py", "def", "read_midc", "filename", "variable_map", "raw_data", "false", "kwargs", "read", "in", "national", "renewable", "energy", "laboratory", "measurement", "and", "instrumentation", "data", "center", "weather", "data", "the", "midc", "is", "described", "in", "1", "_", "parameters", "filename", "string", "or", "file", "like", "object", "filename", "url", "or", "file", "like", "object", "of", "data", "to", "read", "variable_map", "dictionary", "dictionary", "for", "mapping", "midc", "field", "names", "to", "pvlib", "names", "used", "to", "rename", "the", "columns", "of", "the", "resulting", "dataframe", "does", "not", "map", "names", "by", "default", "see", "notes", "for", "an", "example", "raw_data", "boolean", "set", "to", "true", "to", "use", "format_index_raw", "to", "correctly", "format", "the", "date", "time", "columns", "of", "midc", "raw", "data", "files", "kwargs", "dict", "additional", "keyword", "arguments", "to", "pass", "to", "pandas", "read_csv", "returns", "data", "dataframe", "a", "dataframe", "with", "datetimeindex", "localized", "to", "the", "provided", "timezone", "notes", "the", "variable_map", "argument", "should", "map", "fields", "from", "midc", "data", "to", "pvlib", "names", "e", "g", "if", "a", "midc", "file", "contains", "the", "variable", "global", "horizontal", "w", "m", "2", "passing", "the", "dictionary", "below", "will", "rename", "the", "column", "to", "ghi", "in", "the", "returned", "dataframe", "global", "horizontal", "w", "m", "2", "ghi", "see", "the", "midc_variable_map", "for", "collection", "of", "mappings", "by", "site", "for", "a", "full", "list", "of", "pvlib", "variable", "names", "see", "the", "ref", "variables_style_rules", "be", "sure", "to", "check", "the", "units", "for", "the", "variables", "you", "will", "use", "on", "the", "midc", "site", "https", "midcdmz", "nrel", "gov", "_", "references", "1", "nrel", "measurement", "and", "instrumentation", "data", "center", "https", "midcdmz", "nrel", "gov", "https", "midcdmz", "nrel", "gov", "_", "data", "pd", "read_csv", "filename", "kwargs", "if", "raw_data", "data", "format_index_raw", "data", "else", "data", "format_index", "data", "data", "data", "rename", "columns", "variable_map", "return", "data"], "doc_len": 248}
{"doc_id": "pvlib/iotools/midc.py::read_midc_raw_data_from_nrel", "file_path": "pvlib/iotools/midc.py", "class_name": null, "func_name": "read_midc_raw_data_from_nrel", "text": "文件路径: pvlib/iotools/midc.py\ndef read_midc_raw_data_from_nrel(site, start, end, variable_map={},\n                                 timeout=30):\n    \"\"\"Request and read MIDC data directly from the raw data api.\n\n    Parameters\n    ----------\n    site: string\n        The MIDC station id.\n    start: datetime\n        Start date for requested data.\n    end: datetime\n        End date for requested data.\n    variable_map: dict\n        A dictionary mapping MIDC field names to pvlib names. Used to\n        rename columns of the resulting DataFrame. See Notes of\n        :py:func:`pvlib.iotools.read_midc` for example.\n    timeout : float, default 30\n        Number of seconds to wait to connect/read from the API before\n        failing.\n\n    Returns\n    -------\n    data:\n        Dataframe with DatetimeIndex localized to the station location.\n\n    Raises\n    ------\n    requests.HTTPError\n       For any error in retrieving the CSV file from the MIDC API\n    requests.Timeout\n       If data is not received in within ``timeout`` seconds\n\n    Notes\n    -----\n    Requests spanning an instrumentation change will yield an error. See the\n    MIDC raw data api page\n    `here <https://midcdmz.nrel.gov/apps/data_api_doc.pl?_idtextlist>`_\n    for more details and considerations.\n    \"\"\"\n    args = {'site': site,\n            'begin': start.strftime('%Y%m%d'),\n            'end': end.strftime('%Y%m%d')}\n    url = 'https://midcdmz.nrel.gov/apps/data_api.pl'\n    # NOTE: just use requests.get(url, params=args) to build querystring\n    # number of header columns and data columns do not always match,\n    # so first parse the header to determine the number of data columns\n    # to parse\n    csv_request = requests.get(url, timeout=timeout, params=args)\n    csv_request.raise_for_status()\n    raw_csv = io.StringIO(csv_request.text)\n    first_row = pd.read_csv(raw_csv, nrows=0)\n    col_length = len(first_row.columns)\n    raw_csv.seek(0)\n    return read_midc(raw_csv, variable_map=variable_map, raw_data=True,\n                     usecols=range(col_length))\n", "tokens": ["pvlib", "iotools", "midc", "py", "def", "read_midc_raw_data_from_nrel", "site", "start", "end", "variable_map", "timeout", "30", "request", "and", "read", "midc", "data", "directly", "from", "the", "raw", "data", "api", "parameters", "site", "string", "the", "midc", "station", "id", "start", "datetime", "start", "date", "for", "requested", "data", "end", "datetime", "end", "date", "for", "requested", "data", "variable_map", "dict", "a", "dictionary", "mapping", "midc", "field", "names", "to", "pvlib", "names", "used", "to", "rename", "columns", "of", "the", "resulting", "dataframe", "see", "notes", "of", "py", "func", "pvlib", "iotools", "read_midc", "for", "example", "timeout", "float", "default", "30", "number", "of", "seconds", "to", "wait", "to", "connect", "read", "from", "the", "api", "before", "failing", "returns", "data", "dataframe", "with", "datetimeindex", "localized", "to", "the", "station", "location", "raises", "requests", "httperror", "for", "any", "error", "in", "retrieving", "the", "csv", "file", "from", "the", "midc", "api", "requests", "timeout", "if", "data", "is", "not", "received", "in", "within", "timeout", "seconds", "notes", "requests", "spanning", "an", "instrumentation", "change", "will", "yield", "an", "error", "see", "the", "midc", "raw", "data", "api", "page", "here", "https", "midcdmz", "nrel", "gov", "apps", "data_api_doc", "pl", "_idtextlist", "_", "for", "more", "details", "and", "considerations", "args", "site", "site", "begin", "start", "strftime", "y", "m", "d", "end", "end", "strftime", "y", "m", "d", "url", "https", "midcdmz", "nrel", "gov", "apps", "data_api", "pl", "note", "just", "use", "requests", "get", "url", "params", "args", "to", "build", "querystring", "number", "of", "header", "columns", "and", "data", "columns", "do", "not", "always", "match", "so", "first", "parse", "the", "header", "to", "determine", "the", "number", "of", "data", "columns", "to", "parse", "csv_request", "requests", "get", "url", "timeout", "timeout", "params", "args", "csv_request", "raise_for_status", "raw_csv", "io", "stringio", "csv_request", "text", "first_row", "pd", "read_csv", "raw_csv", "nrows", "0", "col_length", "len", "first_row", "columns", "raw_csv", "seek", "0", "return", "read_midc", "raw_csv", "variable_map", "variable_map", "raw_data", "true", "usecols", "range", "col_length"], "doc_len": 255}
{"doc_id": "pvlib/iotools/psm3.py::get_psm3", "file_path": "pvlib/iotools/psm3.py", "class_name": null, "func_name": "get_psm3", "text": "文件路径: pvlib/iotools/psm3.py\ndef get_psm3(latitude, longitude, api_key, email, names='tmy', interval=60,\n             attributes=ATTRIBUTES, leap_day=None, full_name=PVLIB_PYTHON,\n             affiliation=PVLIB_PYTHON, map_variables=None, timeout=30):\n    \"\"\"\n    Retrieve NSRDB PSM3 timeseries weather data from the PSM3 API. The NSRDB\n    is described in [1]_ and the PSM3 API is described in [2]_, [3]_, and [4]_.\n\n    .. versionchanged:: 0.9.0\n       The function now returns a tuple where the first element is a dataframe\n       and the second element is a dictionary containing metadata. Previous\n       versions of this function had the return values switched.\n\n    Parameters\n    ----------\n    latitude : float or int\n        in decimal degrees, between -90 and 90, north is positive\n    longitude : float or int\n        in decimal degrees, between -180 and 180, east is positive\n    api_key : str\n        NREL Developer Network API key\n    email : str\n        NREL API uses this to automatically communicate messages back\n        to the user only if necessary\n    names : str, default 'tmy'\n        PSM3 API parameter specifing year or TMY variant to download, see notes\n        below for options\n    interval : int, {60, 5, 15, 30}\n        interval size in minutes, must be 5, 15, 30 or 60. Only used for\n        single-year requests (i.e., it is ignored for tmy/tgy/tdy requests).\n    attributes : list of str, optional\n        meteorological fields to fetch. If not specified, defaults to\n        ``pvlib.iotools.psm3.ATTRIBUTES``. See references [2]_, [3]_, and [4]_\n        for lists of available fields. Alternatively, pvlib names may also be\n        used (e.g. 'ghi' rather than 'GHI'); see :const:`VARIABLE_MAP`.\n    leap_day : boolean, default False\n        include leap day in the results. Only used for single-year requests\n        (i.e., it is ignored for tmy/tgy/tdy requests).\n    full_name : str, default 'pvlib python'\n        optional\n    affiliation : str, default 'pvlib python'\n        optional\n    map_variables: boolean, optional\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n    timeout : int, default 30\n        time in seconds to wait for server response before timeout\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        timeseries data from NREL PSM3\n    metadata : dict\n        metadata from NREL PSM3 about the record, see\n        :func:`pvlib.iotools.parse_psm3` for fields\n\n    Raises\n    ------\n    requests.HTTPError\n        if the request response status is not ok, then the ``'errors'`` field\n        from the JSON response or any error message in the content will be\n        raised as an exception, for example if the `api_key` was rejected or if\n        the coordinates were not found in the NSRDB\n\n    Notes\n    -----\n    The required NREL developer key, `api_key`, is available for free by\n    registering at the `NREL Developer Network <https://developer.nrel.gov/>`_.\n\n    .. warning:: The \"DEMO_KEY\" `api_key` is severely rate limited and may\n        result in rejected requests.\n\n    The PSM3 API `names` parameter must be a single value from one of these\n    lists:\n\n    +-----------+-------------------------------------------------------------+\n    | Category  | Allowed values                                              |\n    +===========+=============================================================+\n    | Year      | 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, |\n    |           | 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, |\n    |           | 2018, 2019, 2020                                            |\n    +-----------+-------------------------------------------------------------+\n    | TMY       | tmy, tmy-2016, tmy-2017, tdy-2017, tgy-2017,                |\n    |           | tmy-2018, tdy-2018, tgy-2018, tmy-2019, tdy-2019, tgy-2019  |\n    |           | tmy-2020, tdy-2020, tgy-2020                                |\n    +-----------+-------------------------------------------------------------+\n\n    .. warning:: PSM3 is limited to data found in the NSRDB, please consult the\n        references below for locations with available data. Additionally,\n        querying data with < 30-minute resolution uses a different API endpoint\n        with fewer available fields (see [4]_).\n\n    See Also\n    --------\n    pvlib.iotools.read_psm3, pvlib.iotools.parse_psm3\n\n    References\n    ----------\n\n    .. [1] `NREL National Solar Radiation Database (NSRDB)\n       <https://nsrdb.nrel.gov/>`_\n    .. [2] `Physical Solar Model (PSM) v3\n       <https://developer.nrel.gov/docs/solar/nsrdb/psm3-download/>`_\n    .. [3] `Physical Solar Model (PSM) v3 TMY\n       <https://developer.nrel.gov/docs/solar/nsrdb/psm3-tmy-download/>`_\n    .. [4] `Physical Solar Model (PSM) v3 - Five Minute Temporal Resolution\n       <https://developer.nrel.gov/docs/solar/nsrdb/psm3-5min-download/>`_\n    \"\"\"\n    # The well know text (WKT) representation of geometry notation is strict.\n    # A POINT object is a string with longitude first, then the latitude, with\n    # four decimals each, and exactly one space between them.\n    longitude = ('%9.4f' % longitude).strip()\n    latitude = ('%8.4f' % latitude).strip()\n    # TODO: make format_WKT(object_type, *args) in tools.py\n\n    # convert to string to accomodate integer years being passed in\n    names = str(names)\n\n    # convert pvlib names in attributes to psm3 convention (reverse mapping)\n    # unlike psm3 columns, attributes are lower case and with underscores\n    amap = {value: key.lower().replace(' ', '_') for (key, value) in\n            VARIABLE_MAP.items()}\n    attributes = [amap.get(a, a) for a in attributes]\n    attributes = list(set(attributes))  # remove duplicate values\n\n    if (leap_day is None) and (not names.startswith('t')):\n        warnings.warn(\n            'The ``get_psm3`` function will default to leap_day=True '\n            'starting in pvlib 0.11.0. Specify leap_day=True '\n            'to enable this behavior now, or specify leap_day=False '\n            'to hide this warning.', pvlibDeprecationWarning)\n        leap_day = False\n\n    # required query-string parameters for request to PSM3 API\n    params = {\n        'api_key': api_key,\n        'full_name': full_name,\n        'email': email,\n        'affiliation': affiliation,\n        'reason': PVLIB_PYTHON,\n        'mailing_list': 'false',\n        'wkt': 'POINT(%s %s)' % (longitude, latitude),\n        'names': names,\n        'attributes':  ','.join(attributes),\n        'leap_day': str(leap_day).lower(),\n        'utc': 'false',\n        'interval': interval\n    }\n    # request CSV download from NREL PSM3\n    if any(prefix in names for prefix in ('tmy', 'tgy', 'tdy')):\n        URL = TMY_URL\n    elif interval in (5, 15):\n        URL = PSM5MIN_URL\n    else:\n        URL = PSM_URL\n    response = requests.get(URL, params=params, timeout=timeout)\n    if not response.ok:\n        # if the API key is rejected, then the response status will be 403\n        # Forbidden, and then the error is in the content and there is no JSON\n        try:\n            errors = response.json()['errors']\n        except JSONDecodeError:\n            errors = response.content.decode('utf-8')\n        raise requests.HTTPError(errors, response=response)\n    # the CSV is in the response content as a UTF-8 bytestring\n    # to use pandas we need to create a file buffer from the response\n    fbuf = io.StringIO(response.content.decode('utf-8'))\n    return parse_psm3(fbuf, map_variables)\n", "tokens": ["pvlib", "iotools", "psm3", "py", "def", "get_psm3", "latitude", "longitude", "api_key", "email", "names", "tmy", "interval", "60", "attributes", "attributes", "leap_day", "none", "full_name", "pvlib_python", "affiliation", "pvlib_python", "map_variables", "none", "timeout", "30", "retrieve", "nsrdb", "psm3", "timeseries", "weather", "data", "from", "the", "psm3", "api", "the", "nsrdb", "is", "described", "in", "1", "_", "and", "the", "psm3", "api", "is", "described", "in", "2", "_", "3", "_", "and", "4", "_", "versionchanged", "0", "9", "0", "the", "function", "now", "returns", "a", "tuple", "where", "the", "first", "element", "is", "a", "dataframe", "and", "the", "second", "element", "is", "a", "dictionary", "containing", "metadata", "previous", "versions", "of", "this", "function", "had", "the", "return", "values", "switched", "parameters", "latitude", "float", "or", "int", "in", "decimal", "degrees", "between", "90", "and", "90", "north", "is", "positive", "longitude", "float", "or", "int", "in", "decimal", "degrees", "between", "180", "and", "180", "east", "is", "positive", "api_key", "str", "nrel", "developer", "network", "api", "key", "email", "str", "nrel", "api", "uses", "this", "to", "automatically", "communicate", "messages", "back", "to", "the", "user", "only", "if", "necessary", "names", "str", "default", "tmy", "psm3", "api", "parameter", "specifing", "year", "or", "tmy", "variant", "to", "download", "see", "notes", "below", "for", "options", "interval", "int", "60", "5", "15", "30", "interval", "size", "in", "minutes", "must", "be", "5", "15", "30", "or", "60", "only", "used", "for", "single", "year", "requests", "i", "e", "it", "is", "ignored", "for", "tmy", "tgy", "tdy", "requests", "attributes", "list", "of", "str", "optional", "meteorological", "fields", "to", "fetch", "if", "not", "specified", "defaults", "to", "pvlib", "iotools", "psm3", "attributes", "see", "references", "2", "_", "3", "_", "and", "4", "_", "for", "lists", "of", "available", "fields", "alternatively", "pvlib", "names", "may", "also", "be", "used", "e", "g", "ghi", "rather", "than", "ghi", "see", "const", "variable_map", "leap_day", "boolean", "default", "false", "include", "leap", "day", "in", "the", "results", "only", "used", "for", "single", "year", "requests", "i", "e", "it", "is", "ignored", "for", "tmy", "tgy", "tdy", "requests", "full_name", "str", "default", "pvlib", "python", "optional", "affiliation", "str", "default", "pvlib", "python", "optional", "map_variables", "boolean", "optional", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "timeout", "int", "default", "30", "time", "in", "seconds", "to", "wait", "for", "server", "response", "before", "timeout", "returns", "data", "pandas", "dataframe", "timeseries", "data", "from", "nrel", "psm3", "metadata", "dict", "metadata", "from", "nrel", "psm3", "about", "the", "record", "see", "func", "pvlib", "iotools", "parse_psm3", "for", "fields", "raises", "requests", "httperror", "if", "the", "request", "response", "status", "is", "not", "ok", "then", "the", "errors", "field", "from", "the", "json", "response", "or", "any", "error", "message", "in", "the", "content", "will", "be", "raised", "as", "an", "exception", "for", "example", "if", "the", "api_key", "was", "rejected", "or", "if", "the", "coordinates", "were", "not", "found", "in", "the", "nsrdb", "notes", "the", "required", "nrel", "developer", "key", "api_key", "is", "available", "for", "free", "by", "registering", "at", "the", "nrel", "developer", "network", "https", "developer", "nrel", "gov", "_", "warning", "the", "demo_key", "api_key", "is", "severely", "rate", "limited", "and", "may", "result", "in", "rejected", "requests", "the", "psm3", "api", "names", "parameter", "must", "be", "a", "single", "value", "from", "one", "of", "these", "lists", "category", "allowed", "values", "year", "1998", "1999", "2000", "2001", "2002", "2003", "2004", "2005", "2006", "2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020", "tmy", "tmy", "tmy", "2016", "tmy", "2017", "tdy", "2017", "tgy", "2017", "tmy", "2018", "tdy", "2018", "tgy", "2018", "tmy", "2019", "tdy", "2019", "tgy", "2019", "tmy", "2020", "tdy", "2020", "tgy", "2020", "warning", "psm3", "is", "limited", "to", "data", "found", "in", "the", "nsrdb", "please", "consult", "the", "references", "below", "for", "locations", "with", "available", "data", "additionally", "querying", "data", "with", "30", "minute", "resolution", "uses", "a", "different", "api", "endpoint", "with", "fewer", "available", "fields", "see", "4", "_", "see", "also", "pvlib", "iotools", "read_psm3", "pvlib", "iotools", "parse_psm3", "references", "1", "nrel", "national", "solar", "radiation", "database", "nsrdb", "https", "nsrdb", "nrel", "gov", "_", "2", "physical", "solar", "model", "psm", "v3", "https", "developer", "nrel", "gov", "docs", "solar", "nsrdb", "psm3", "download", "_", "3", "physical", "solar", "model", "psm", "v3", "tmy", "https", "developer", "nrel", "gov", "docs", "solar", "nsrdb", "psm3", "tmy", "download", "_", "4", "physical", "solar", "model", "psm", "v3", "five", "minute", "temporal", "resolution", "https", "developer", "nrel", "gov", "docs", "solar", "nsrdb", "psm3", "5min", "download", "_", "the", "well", "know", "text", "wkt", "representation", "of", "geometry", "notation", "is", "strict", "a", "point", "object", "is", "a", "string", "with", "longitude", "first", "then", "the", "latitude", "with", "four", "decimals", "each", "and", "exactly", "one", "space", "between", "them", "longitude", "9", "4f", "longitude", "strip", "latitude", "8", "4f", "latitude", "strip", "todo", "make", "format_wkt", "object_type", "args", "in", "tools", "py", "convert", "to", "string", "to", "accomodate", "integer", "years", "being", "passed", "in", "names", "str", "names", "convert", "pvlib", "names", "in", "attributes", "to", "psm3", "convention", "reverse", "mapping", "unlike", "psm3", "columns", "attributes", "are", "lower", "case", "and", "with", "underscores", "amap", "value", "key", "lower", "replace", "_", "for", "key", "value", "in", "variable_map", "items", "attributes", "amap", "get", "a", "a", "for", "a", "in", "attributes", "attributes", "list", "set", "attributes", "remove", "duplicate", "values", "if", "leap_day", "is", "none", "and", "not", "names", "startswith", "t", "warnings", "warn", "the", "get_psm3", "function", "will", "default", "to", "leap_day", "true", "starting", "in", "pvlib", "0", "11", "0", "specify", "leap_day", "true", "to", "enable", "this", "behavior", "now", "or", "specify", "leap_day", "false", "to", "hide", "this", "warning", "pvlibdeprecationwarning", "leap_day", "false", "required", "query", "string", "parameters", "for", "request", "to", "psm3", "api", "params", "api_key", "api_key", "full_name", "full_name", "email", "email", "affiliation", "affiliation", "reason", "pvlib_python", "mailing_list", "false", "wkt", "point", "s", "s", "longitude", "latitude", "names", "names", "attributes", "join", "attributes", "leap_day", "str", "leap_day", "lower", "utc", "false", "interval", "interval", "request", "csv", "download", "from", "nrel", "psm3", "if", "any", "prefix", "in", "names", "for", "prefix", "in", "tmy", "tgy", "tdy", "url", "tmy_url", "elif", "interval", "in", "5", "15", "url", "psm5min_url", "else", "url", "psm_url", "response", "requests", "get", "url", "params", "params", "timeout", "timeout", "if", "not", "response", "ok", "if", "the", "api", "key", "is", "rejected", "then", "the", "response", "status", "will", "be", "403", "forbidden", "and", "then", "the", "error", "is", "in", "the", "content", "and", "there", "is", "no", "json", "try", "errors", "response", "json", "errors", "except", "jsondecodeerror", "errors", "response", "content", "decode", "utf", "8", "raise", "requests", "httperror", "errors", "response", "response", "the", "csv", "is", "in", "the", "response", "content", "as", "a", "utf", "8", "bytestring", "to", "use", "pandas", "we", "need", "to", "create", "a", "file", "buffer", "from", "the", "response", "fbuf", "io", "stringio", "response", "content", "decode", "utf", "8", "return", "parse_psm3", "fbuf", "map_variables"], "doc_len": 935}
{"doc_id": "pvlib/iotools/psm3.py::parse_psm3", "file_path": "pvlib/iotools/psm3.py", "class_name": null, "func_name": "parse_psm3", "text": "文件路径: pvlib/iotools/psm3.py\ndef parse_psm3(fbuf, map_variables=None):\n    \"\"\"\n    Parse an NSRDB PSM3 weather file (formatted as SAM CSV). The NSRDB\n    is described in [1]_ and the SAM CSV format is described in [2]_.\n\n    .. versionchanged:: 0.9.0\n       The function now returns a tuple where the first element is a dataframe\n       and the second element is a dictionary containing metadata. Previous\n       versions of this function had the return values switched.\n\n    Parameters\n    ----------\n    fbuf: file-like object\n        File-like object containing data to read.\n    map_variables: bool\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable VARIABLE_MAP.\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        timeseries data from NREL PSM3\n    metadata : dict\n        metadata from NREL PSM3 about the record, see notes for fields\n\n    Notes\n    -----\n    The return is a tuple with two items. The first item is a dataframe with\n    the PSM3 timeseries data.\n\n    The second item is a dictionary with metadata from NREL PSM3 about the\n    record containing the following fields:\n\n    * Source\n    * Location ID\n    * City\n    * State\n    * Country\n    * Latitude\n    * Longitude\n    * Time Zone\n    * Elevation\n    * Local Time Zone\n    * Clearsky DHI Units\n    * Clearsky DNI Units\n    * Clearsky GHI Units\n    * Dew Point Units\n    * DHI Units\n    * DNI Units\n    * GHI Units\n    * Solar Zenith Angle Units\n    * Temperature Units\n    * Pressure Units\n    * Relative Humidity Units\n    * Precipitable Water Units\n    * Wind Direction Units\n    * Wind Speed Units\n    * Cloud Type -15\n    * Cloud Type 0\n    * Cloud Type 1\n    * Cloud Type 2\n    * Cloud Type 3\n    * Cloud Type 4\n    * Cloud Type 5\n    * Cloud Type 6\n    * Cloud Type 7\n    * Cloud Type 8\n    * Cloud Type 9\n    * Cloud Type 10\n    * Cloud Type 11\n    * Cloud Type 12\n    * Fill Flag 0\n    * Fill Flag 1\n    * Fill Flag 2\n    * Fill Flag 3\n    * Fill Flag 4\n    * Fill Flag 5\n    * Surface Albedo Units\n    * Version\n\n    Examples\n    --------\n    >>> # Read a local PSM3 file:\n    >>> with open(filename, 'r') as f:  # doctest: +SKIP\n    ...     df, metadata = iotools.parse_psm3(f)  # doctest: +SKIP\n\n    See Also\n    --------\n    pvlib.iotools.read_psm3, pvlib.iotools.get_psm3\n\n    References\n    ----------\n    .. [1] `NREL National Solar Radiation Database (NSRDB)\n       <https://nsrdb.nrel.gov/>`_\n    .. [2] `Standard Time Series Data File Format\n       <https://web.archive.org/web/20170207203107/https://sam.nrel.gov/sites/default/files/content/documents/pdf/wfcsv.pdf>`_\n    \"\"\"\n    # The first 2 lines of the response are headers with metadata\n    metadata_fields = fbuf.readline().split(',')\n    metadata_fields[-1] = metadata_fields[-1].strip()  # strip trailing newline\n    metadata_values = fbuf.readline().split(',')\n    metadata_values[-1] = metadata_values[-1].strip()  # strip trailing newline\n    metadata = dict(zip(metadata_fields, metadata_values))\n    # the response is all strings, so set some metadata types to numbers\n    metadata['Local Time Zone'] = int(metadata['Local Time Zone'])\n    metadata['Time Zone'] = int(metadata['Time Zone'])\n    metadata['Latitude'] = float(metadata['Latitude'])\n    metadata['Longitude'] = float(metadata['Longitude'])\n    metadata['Elevation'] = int(metadata['Elevation'])\n    # get the column names so we can set the dtypes\n    columns = fbuf.readline().split(',')\n    columns[-1] = columns[-1].strip()  # strip trailing newline\n    # Since the header has so many columns, excel saves blank cols in the\n    # data below the header lines.\n    columns = [col for col in columns if col != '']\n    dtypes = dict.fromkeys(columns, float)  # all floats except datevec\n    dtypes.update(Year=int, Month=int, Day=int, Hour=int, Minute=int)\n    dtypes['Cloud Type'] = int\n    dtypes['Fill Flag'] = int\n    data = pd.read_csv(\n        fbuf, header=None, names=columns, usecols=columns, dtype=dtypes,\n        delimiter=',', lineterminator='\\n')  # skip carriage returns \\r\n    # the response 1st 5 columns are a date vector, convert to datetime\n    dtidx = pd.to_datetime(\n        data[['Year', 'Month', 'Day', 'Hour', 'Minute']])\n    # in USA all timezones are integers\n    tz = 'Etc/GMT%+d' % -metadata['Time Zone']\n    data.index = pd.DatetimeIndex(dtidx).tz_localize(tz)\n\n    if map_variables is None:\n        warnings.warn(\n            'PSM3 variable names will be renamed to pvlib conventions by '\n            'default starting in pvlib 0.11.0. Specify map_variables=True '\n            'to enable that behavior now, or specify map_variables=False '\n            'to hide this warning.', pvlibDeprecationWarning)\n        map_variables = False\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n        metadata['latitude'] = metadata.pop('Latitude')\n        metadata['longitude'] = metadata.pop('Longitude')\n        metadata['altitude'] = metadata.pop('Elevation')\n\n    return data, metadata\n", "tokens": ["pvlib", "iotools", "psm3", "py", "def", "parse_psm3", "fbuf", "map_variables", "none", "parse", "an", "nsrdb", "psm3", "weather", "file", "formatted", "as", "sam", "csv", "the", "nsrdb", "is", "described", "in", "1", "_", "and", "the", "sam", "csv", "format", "is", "described", "in", "2", "_", "versionchanged", "0", "9", "0", "the", "function", "now", "returns", "a", "tuple", "where", "the", "first", "element", "is", "a", "dataframe", "and", "the", "second", "element", "is", "a", "dictionary", "containing", "metadata", "previous", "versions", "of", "this", "function", "had", "the", "return", "values", "switched", "parameters", "fbuf", "file", "like", "object", "file", "like", "object", "containing", "data", "to", "read", "map_variables", "bool", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "variable_map", "returns", "data", "pandas", "dataframe", "timeseries", "data", "from", "nrel", "psm3", "metadata", "dict", "metadata", "from", "nrel", "psm3", "about", "the", "record", "see", "notes", "for", "fields", "notes", "the", "return", "is", "a", "tuple", "with", "two", "items", "the", "first", "item", "is", "a", "dataframe", "with", "the", "psm3", "timeseries", "data", "the", "second", "item", "is", "a", "dictionary", "with", "metadata", "from", "nrel", "psm3", "about", "the", "record", "containing", "the", "following", "fields", "source", "location", "id", "city", "state", "country", "latitude", "longitude", "time", "zone", "elevation", "local", "time", "zone", "clearsky", "dhi", "units", "clearsky", "dni", "units", "clearsky", "ghi", "units", "dew", "point", "units", "dhi", "units", "dni", "units", "ghi", "units", "solar", "zenith", "angle", "units", "temperature", "units", "pressure", "units", "relative", "humidity", "units", "precipitable", "water", "units", "wind", "direction", "units", "wind", "speed", "units", "cloud", "type", "15", "cloud", "type", "0", "cloud", "type", "1", "cloud", "type", "2", "cloud", "type", "3", "cloud", "type", "4", "cloud", "type", "5", "cloud", "type", "6", "cloud", "type", "7", "cloud", "type", "8", "cloud", "type", "9", "cloud", "type", "10", "cloud", "type", "11", "cloud", "type", "12", "fill", "flag", "0", "fill", "flag", "1", "fill", "flag", "2", "fill", "flag", "3", "fill", "flag", "4", "fill", "flag", "5", "surface", "albedo", "units", "version", "examples", "read", "a", "local", "psm3", "file", "with", "open", "filename", "r", "as", "f", "doctest", "skip", "df", "metadata", "iotools", "parse_psm3", "f", "doctest", "skip", "see", "also", "pvlib", "iotools", "read_psm3", "pvlib", "iotools", "get_psm3", "references", "1", "nrel", "national", "solar", "radiation", "database", "nsrdb", "https", "nsrdb", "nrel", "gov", "_", "2", "standard", "time", "series", "data", "file", "format", "https", "web", "archive", "org", "web", "20170207203107", "https", "sam", "nrel", "gov", "sites", "default", "files", "content", "documents", "pdf", "wfcsv", "pdf", "_", "the", "first", "2", "lines", "of", "the", "response", "are", "headers", "with", "metadata", "metadata_fields", "fbuf", "readline", "split", "metadata_fields", "1", "metadata_fields", "1", "strip", "strip", "trailing", "newline", "metadata_values", "fbuf", "readline", "split", "metadata_values", "1", "metadata_values", "1", "strip", "strip", "trailing", "newline", "metadata", "dict", "zip", "metadata_fields", "metadata_values", "the", "response", "is", "all", "strings", "so", "set", "some", "metadata", "types", "to", "numbers", "metadata", "local", "time", "zone", "int", "metadata", "local", "time", "zone", "metadata", "time", "zone", "int", "metadata", "time", "zone", "metadata", "latitude", "float", "metadata", "latitude", "metadata", "longitude", "float", "metadata", "longitude", "metadata", "elevation", "int", "metadata", "elevation", "get", "the", "column", "names", "so", "we", "can", "set", "the", "dtypes", "columns", "fbuf", "readline", "split", "columns", "1", "columns", "1", "strip", "strip", "trailing", "newline", "since", "the", "header", "has", "so", "many", "columns", "excel", "saves", "blank", "cols", "in", "the", "data", "below", "the", "header", "lines", "columns", "col", "for", "col", "in", "columns", "if", "col", "dtypes", "dict", "fromkeys", "columns", "float", "all", "floats", "except", "datevec", "dtypes", "update", "year", "int", "month", "int", "day", "int", "hour", "int", "minute", "int", "dtypes", "cloud", "type", "int", "dtypes", "fill", "flag", "int", "data", "pd", "read_csv", "fbuf", "header", "none", "names", "columns", "usecols", "columns", "dtype", "dtypes", "delimiter", "lineterminator", "n", "skip", "carriage", "returns", "r", "the", "response", "1st", "5", "columns", "are", "a", "date", "vector", "convert", "to", "datetime", "dtidx", "pd", "to_datetime", "data", "year", "month", "day", "hour", "minute", "in", "usa", "all", "timezones", "are", "integers", "tz", "etc", "gmt", "d", "metadata", "time", "zone", "data", "index", "pd", "datetimeindex", "dtidx", "tz_localize", "tz", "if", "map_variables", "is", "none", "warnings", "warn", "psm3", "variable", "names", "will", "be", "renamed", "to", "pvlib", "conventions", "by", "default", "starting", "in", "pvlib", "0", "11", "0", "specify", "map_variables", "true", "to", "enable", "that", "behavior", "now", "or", "specify", "map_variables", "false", "to", "hide", "this", "warning", "pvlibdeprecationwarning", "map_variables", "false", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "metadata", "latitude", "metadata", "pop", "latitude", "metadata", "longitude", "metadata", "pop", "longitude", "metadata", "altitude", "metadata", "pop", "elevation", "return", "data", "metadata"], "doc_len": 633}
{"doc_id": "pvlib/iotools/psm3.py::read_psm3", "file_path": "pvlib/iotools/psm3.py", "class_name": null, "func_name": "read_psm3", "text": "文件路径: pvlib/iotools/psm3.py\ndef read_psm3(filename, map_variables=None):\n    \"\"\"\n    Read an NSRDB PSM3 weather file (formatted as SAM CSV). The NSRDB\n    is described in [1]_ and the SAM CSV format is described in [2]_.\n\n    .. versionchanged:: 0.9.0\n       The function now returns a tuple where the first element is a dataframe\n       and the second element is a dictionary containing metadata. Previous\n       versions of this function had the return values switched.\n\n    Parameters\n    ----------\n    filename: str\n        Filename of a file containing data to read.\n    map_variables: bool\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable VARIABLE_MAP.\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        timeseries data from NREL PSM3\n    metadata : dict\n        metadata from NREL PSM3 about the record, see\n        :func:`pvlib.iotools.parse_psm3` for fields\n\n    See Also\n    --------\n    pvlib.iotools.parse_psm3, pvlib.iotools.get_psm3\n\n    References\n    ----------\n    .. [1] `NREL National Solar Radiation Database (NSRDB)\n       <https://nsrdb.nrel.gov/>`_\n    .. [2] `Standard Time Series Data File Format\n       <https://web.archive.org/web/20170207203107/https://sam.nrel.gov/sites/default/files/content/documents/pdf/wfcsv.pdf>`_\n    \"\"\"\n    with open(str(filename), 'r') as fbuf:\n        content = parse_psm3(fbuf, map_variables)\n    return content\n", "tokens": ["pvlib", "iotools", "psm3", "py", "def", "read_psm3", "filename", "map_variables", "none", "read", "an", "nsrdb", "psm3", "weather", "file", "formatted", "as", "sam", "csv", "the", "nsrdb", "is", "described", "in", "1", "_", "and", "the", "sam", "csv", "format", "is", "described", "in", "2", "_", "versionchanged", "0", "9", "0", "the", "function", "now", "returns", "a", "tuple", "where", "the", "first", "element", "is", "a", "dataframe", "and", "the", "second", "element", "is", "a", "dictionary", "containing", "metadata", "previous", "versions", "of", "this", "function", "had", "the", "return", "values", "switched", "parameters", "filename", "str", "filename", "of", "a", "file", "containing", "data", "to", "read", "map_variables", "bool", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "variable_map", "returns", "data", "pandas", "dataframe", "timeseries", "data", "from", "nrel", "psm3", "metadata", "dict", "metadata", "from", "nrel", "psm3", "about", "the", "record", "see", "func", "pvlib", "iotools", "parse_psm3", "for", "fields", "see", "also", "pvlib", "iotools", "parse_psm3", "pvlib", "iotools", "get_psm3", "references", "1", "nrel", "national", "solar", "radiation", "database", "nsrdb", "https", "nsrdb", "nrel", "gov", "_", "2", "standard", "time", "series", "data", "file", "format", "https", "web", "archive", "org", "web", "20170207203107", "https", "sam", "nrel", "gov", "sites", "default", "files", "content", "documents", "pdf", "wfcsv", "pdf", "_", "with", "open", "str", "filename", "r", "as", "fbuf", "content", "parse_psm3", "fbuf", "map_variables", "return", "content"], "doc_len": 186}
{"doc_id": "pvlib/iotools/pvgis.py::get_pvgis_hourly", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "get_pvgis_hourly", "text": "文件路径: pvlib/iotools/pvgis.py\ndef get_pvgis_hourly(latitude, longitude, start=None, end=None,\n                     raddatabase=None, components=True,\n                     surface_tilt=0, surface_azimuth=0,\n                     outputformat='json',\n                     usehorizon=True, userhorizon=None,\n                     pvcalculation=False,\n                     peakpower=None, pvtechchoice='crystSi',\n                     mountingplace='free', loss=0, trackingtype=0,\n                     optimal_surface_tilt=False, optimalangles=False,\n                     url=URL, map_variables=True, timeout=30):\n    \"\"\"Get hourly solar irradiation and modeled PV power output from PVGIS.\n\n    PVGIS data is freely available at [1]_.\n\n    Parameters\n    ----------\n    latitude: float\n        In decimal degrees, between -90 and 90, north is positive (ISO 19115)\n    longitude: float\n        In decimal degrees, between -180 and 180, east is positive (ISO 19115)\n    start: int or datetime like, default: None\n        First year of the radiation time series. Defaults to first year\n        available.\n    end: int or datetime like, default: None\n        Last year of the radiation time series. Defaults to last year\n        available.\n    raddatabase: str, default: None\n        Name of radiation database. Options depend on location, see [3]_.\n    components: bool, default: True\n        Output solar radiation components (beam, diffuse, and reflected).\n        Otherwise only global irradiance is returned.\n    surface_tilt: float, default: 0\n        Tilt angle from horizontal plane. Ignored for two-axis tracking.\n    surface_azimuth: float, default: 0\n        Orientation (azimuth angle) of the (fixed) plane. 0=south, 90=west,\n        -90: east. Ignored for tracking systems.\n    usehorizon: bool, default: True\n        Include effects of horizon\n    userhorizon: list of float, default: None\n        Optional user specified elevation of horizon in degrees, at equally\n        spaced azimuth clockwise from north, only valid if ``usehorizon`` is\n        true, if ``usehorizon`` is true but ``userhorizon`` is ``None`` then\n        PVGIS will calculate the horizon [4]_\n    pvcalculation: bool, default: False\n        Return estimate of hourly PV production.\n    peakpower: float, default: None\n        Nominal power of PV system in kW. Required if pvcalculation=True.\n    pvtechchoice: {'crystSi', 'CIS', 'CdTe', 'Unknown'}, default: 'crystSi'\n        PV technology.\n    mountingplace: {'free', 'building'}, default: free\n        Type of mounting for PV system. Options of 'free' for free-standing\n        and 'building' for building-integrated.\n    loss: float, default: 0\n        Sum of PV system losses in percent. Required if pvcalculation=True\n    trackingtype: {0, 1, 2, 3, 4, 5}, default: 0\n        Type of suntracking. 0=fixed, 1=single horizontal axis aligned\n        north-south, 2=two-axis tracking, 3=vertical axis tracking, 4=single\n        horizontal axis aligned east-west, 5=single inclined axis aligned\n        north-south.\n    optimal_surface_tilt: bool, default: False\n        Calculate the optimum tilt angle. Ignored for two-axis tracking\n    optimalangles: bool, default: False\n        Calculate the optimum tilt and azimuth angles. Ignored for two-axis\n        tracking.\n    outputformat: str, default: 'json'\n        Must be in ``['json', 'csv']``. See PVGIS hourly data\n        documentation [2]_ for more info.\n    url: str, default: :const:`pvlib.iotools.pvgis.URL`\n        Base url of PVGIS API. ``seriescalc`` is appended to get hourly data\n        endpoint. Note, a specific PVGIS version can be specified, e.g.,\n        https://re.jrc.ec.europa.eu/api/v5_2/\n    map_variables: bool, default: True\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n    timeout: int, default: 30\n        Time in seconds to wait for server response before timeout\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        Time-series of hourly data, see Notes for fields\n    inputs : dict\n        Dictionary of the request input parameters\n    metadata : dict\n        Dictionary containing metadata\n\n    Raises\n    ------\n    requests.HTTPError\n        If the request response status is ``HTTP/1.1 400 BAD REQUEST``, then\n        the error message in the response will be raised as an exception,\n        otherwise raise whatever ``HTTP/1.1`` error occurred\n\n    Hint\n    ----\n    PVGIS provides access to a number of different solar radiation datasets,\n    including satellite-based (SARAH, SARAH2, and NSRDB PSM3) and re-analysis\n    products (ERA5). Each data source has a different geographical coverage and\n    time stamp convention, e.g., SARAH and SARAH2 provide instantaneous values,\n    whereas values from ERA5 are averages for the hour.\n\n    Notes\n    -----\n    data includes the following fields:\n\n    ===========================  ======  ======================================\n    raw, mapped                  Format  Description\n    ===========================  ======  ======================================\n    *Mapped field names are returned when the map_variables argument is True*\n    ---------------------------------------------------------------------------\n    P†                           float   PV system power (W)\n    G(i), poa_global‡            float   Global irradiance on inclined plane (W/m^2)\n    Gb(i), poa_direct‡           float   Beam (direct) irradiance on inclined plane (W/m^2)\n    Gd(i), poa_sky_diffuse‡      float   Diffuse irradiance on inclined plane (W/m^2)\n    Gr(i), poa_ground_diffuse‡   float   Reflected irradiance on inclined plane (W/m^2)\n    H_sun, solar_elevation       float   Sun height/elevation (degrees)\n    T2m, temp_air                float   Air temperature at 2 m (degrees Celsius)\n    WS10m, wind_speed            float   Wind speed at 10 m (m/s)\n    Int                          int     Solar radiation reconstructed (1/0)\n    ===========================  ======  ======================================\n\n    †P (PV system power) is only returned when pvcalculation=True.\n\n    ‡Gb(i), Gd(i), and Gr(i) are returned when components=True, otherwise the\n    sum of the three components, G(i), is returned.\n\n    See Also\n    --------\n    pvlib.iotools.read_pvgis_hourly, pvlib.iotools.get_pvgis_tmy\n\n    Examples\n    --------\n    >>> # Retrieve two years of irradiance data from PVGIS:\n    >>> data, meta, inputs = pvlib.iotools.get_pvgis_hourly(  # doctest: +SKIP\n    >>>    latitude=45, longitude=8, start=2015, end=2016)  # doctest: +SKIP\n\n    References\n    ----------\n    .. [1] `PVGIS <https://ec.europa.eu/jrc/en/pvgis>`_\n    .. [2] `PVGIS Hourly Radiation\n       <https://ec.europa.eu/jrc/en/PVGIS/tools/hourly-radiation>`_\n    .. [3] `PVGIS Non-interactive service\n       <https://ec.europa.eu/jrc/en/PVGIS/docs/noninteractive>`_\n    .. [4] `PVGIS horizon profile tool\n       <https://ec.europa.eu/jrc/en/PVGIS/tools/horizon>`_\n    \"\"\"  # noqa: E501\n    # use requests to format the query string by passing params dictionary\n    params = {'lat': latitude, 'lon': longitude, 'outputformat': outputformat,\n              'angle': surface_tilt, 'aspect': surface_azimuth,\n              'pvcalculation': int(pvcalculation),\n              'pvtechchoice': pvtechchoice, 'mountingplace': mountingplace,\n              'trackingtype': trackingtype, 'components': int(components),\n              'usehorizon': int(usehorizon),\n              'optimalangles': int(optimalangles),\n              'optimalinclination': int(optimal_surface_tilt), 'loss': loss}\n    # pvgis only takes 0 for False, and 1 for True, not strings\n    if userhorizon is not None:\n        params['userhorizon'] = ','.join(str(x) for x in userhorizon)\n    if raddatabase is not None:\n        params['raddatabase'] = raddatabase\n    if start is not None:\n        params['startyear'] = start if isinstance(start, int) else start.year\n    if end is not None:\n        params['endyear'] = end if isinstance(end, int) else end.year\n    if peakpower is not None:\n        params['peakpower'] = peakpower\n\n    # The url endpoint for hourly radiation is 'seriescalc'\n    res = requests.get(url + 'seriescalc', params=params, timeout=timeout)\n    # PVGIS returns really well formatted error messages in JSON for HTTP/1.1\n    # 400 BAD REQUEST so try to return that if possible, otherwise raise the\n    # HTTP/1.1 error caught by requests\n    if not res.ok:\n        try:\n            err_msg = res.json()\n        except Exception:\n            res.raise_for_status()\n        else:\n            raise requests.HTTPError(err_msg['message'])\n\n    return read_pvgis_hourly(io.StringIO(res.text), pvgis_format=outputformat,\n                             map_variables=map_variables)\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "get_pvgis_hourly", "latitude", "longitude", "start", "none", "end", "none", "raddatabase", "none", "components", "true", "surface_tilt", "0", "surface_azimuth", "0", "outputformat", "json", "usehorizon", "true", "userhorizon", "none", "pvcalculation", "false", "peakpower", "none", "pvtechchoice", "crystsi", "mountingplace", "free", "loss", "0", "trackingtype", "0", "optimal_surface_tilt", "false", "optimalangles", "false", "url", "url", "map_variables", "true", "timeout", "30", "get", "hourly", "solar", "irradiation", "and", "modeled", "pv", "power", "output", "from", "pvgis", "pvgis", "data", "is", "freely", "available", "at", "1", "_", "parameters", "latitude", "float", "in", "decimal", "degrees", "between", "90", "and", "90", "north", "is", "positive", "iso", "19115", "longitude", "float", "in", "decimal", "degrees", "between", "180", "and", "180", "east", "is", "positive", "iso", "19115", "start", "int", "or", "datetime", "like", "default", "none", "first", "year", "of", "the", "radiation", "time", "series", "defaults", "to", "first", "year", "available", "end", "int", "or", "datetime", "like", "default", "none", "last", "year", "of", "the", "radiation", "time", "series", "defaults", "to", "last", "year", "available", "raddatabase", "str", "default", "none", "name", "of", "radiation", "database", "options", "depend", "on", "location", "see", "3", "_", "components", "bool", "default", "true", "output", "solar", "radiation", "components", "beam", "diffuse", "and", "reflected", "otherwise", "only", "global", "irradiance", "is", "returned", "surface_tilt", "float", "default", "0", "tilt", "angle", "from", "horizontal", "plane", "ignored", "for", "two", "axis", "tracking", "surface_azimuth", "float", "default", "0", "orientation", "azimuth", "angle", "of", "the", "fixed", "plane", "0", "south", "90", "west", "90", "east", "ignored", "for", "tracking", "systems", "usehorizon", "bool", "default", "true", "include", "effects", "of", "horizon", "userhorizon", "list", "of", "float", "default", "none", "optional", "user", "specified", "elevation", "of", "horizon", "in", "degrees", "at", "equally", "spaced", "azimuth", "clockwise", "from", "north", "only", "valid", "if", "usehorizon", "is", "true", "if", "usehorizon", "is", "true", "but", "userhorizon", "is", "none", "then", "pvgis", "will", "calculate", "the", "horizon", "4", "_", "pvcalculation", "bool", "default", "false", "return", "estimate", "of", "hourly", "pv", "production", "peakpower", "float", "default", "none", "nominal", "power", "of", "pv", "system", "in", "kw", "required", "if", "pvcalculation", "true", "pvtechchoice", "crystsi", "cis", "cdte", "unknown", "default", "crystsi", "pv", "technology", "mountingplace", "free", "building", "default", "free", "type", "of", "mounting", "for", "pv", "system", "options", "of", "free", "for", "free", "standing", "and", "building", "for", "building", "integrated", "loss", "float", "default", "0", "sum", "of", "pv", "system", "losses", "in", "percent", "required", "if", "pvcalculation", "true", "trackingtype", "0", "1", "2", "3", "4", "5", "default", "0", "type", "of", "suntracking", "0", "fixed", "1", "single", "horizontal", "axis", "aligned", "north", "south", "2", "two", "axis", "tracking", "3", "vertical", "axis", "tracking", "4", "single", "horizontal", "axis", "aligned", "east", "west", "5", "single", "inclined", "axis", "aligned", "north", "south", "optimal_surface_tilt", "bool", "default", "false", "calculate", "the", "optimum", "tilt", "angle", "ignored", "for", "two", "axis", "tracking", "optimalangles", "bool", "default", "false", "calculate", "the", "optimum", "tilt", "and", "azimuth", "angles", "ignored", "for", "two", "axis", "tracking", "outputformat", "str", "default", "json", "must", "be", "in", "json", "csv", "see", "pvgis", "hourly", "data", "documentation", "2", "_", "for", "more", "info", "url", "str", "default", "const", "pvlib", "iotools", "pvgis", "url", "base", "url", "of", "pvgis", "api", "seriescalc", "is", "appended", "to", "get", "hourly", "data", "endpoint", "note", "a", "specific", "pvgis", "version", "can", "be", "specified", "e", "g", "https", "re", "jrc", "ec", "europa", "eu", "api", "v5_2", "map_variables", "bool", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "timeout", "int", "default", "30", "time", "in", "seconds", "to", "wait", "for", "server", "response", "before", "timeout", "returns", "data", "pandas", "dataframe", "time", "series", "of", "hourly", "data", "see", "notes", "for", "fields", "inputs", "dict", "dictionary", "of", "the", "request", "input", "parameters", "metadata", "dict", "dictionary", "containing", "metadata", "raises", "requests", "httperror", "if", "the", "request", "response", "status", "is", "http", "1", "1", "400", "bad", "request", "then", "the", "error", "message", "in", "the", "response", "will", "be", "raised", "as", "an", "exception", "otherwise", "raise", "whatever", "http", "1", "1", "error", "occurred", "hint", "pvgis", "provides", "access", "to", "a", "number", "of", "different", "solar", "radiation", "datasets", "including", "satellite", "based", "sarah", "sarah2", "and", "nsrdb", "psm3", "and", "re", "analysis", "products", "era5", "each", "data", "source", "has", "a", "different", "geographical", "coverage", "and", "time", "stamp", "convention", "e", "g", "sarah", "and", "sarah2", "provide", "instantaneous", "values", "whereas", "values", "from", "era5", "are", "averages", "for", "the", "hour", "notes", "data", "includes", "the", "following", "fields", "raw", "mapped", "format", "description", "mapped", "field", "names", "are", "returned", "when", "the", "map_variables", "argument", "is", "true", "p", "float", "pv", "system", "power", "w", "g", "i", "poa_global", "float", "global", "irradiance", "on", "inclined", "plane", "w", "m", "2", "gb", "i", "poa_direct", "float", "beam", "direct", "irradiance", "on", "inclined", "plane", "w", "m", "2", "gd", "i", "poa_sky_diffuse", "float", "diffuse", "irradiance", "on", "inclined", "plane", "w", "m", "2", "gr", "i", "poa_ground_diffuse", "float", "reflected", "irradiance", "on", "inclined", "plane", "w", "m", "2", "h_sun", "solar_elevation", "float", "sun", "height", "elevation", "degrees", "t2m", "temp_air", "float", "air", "temperature", "at", "2", "m", "degrees", "celsius", "ws10m", "wind_speed", "float", "wind", "speed", "at", "10", "m", "m", "s", "int", "int", "solar", "radiation", "reconstructed", "1", "0", "p", "pv", "system", "power", "is", "only", "returned", "when", "pvcalculation", "true", "gb", "i", "gd", "i", "and", "gr", "i", "are", "returned", "when", "components", "true", "otherwise", "the", "sum", "of", "the", "three", "components", "g", "i", "is", "returned", "see", "also", "pvlib", "iotools", "read_pvgis_hourly", "pvlib", "iotools", "get_pvgis_tmy", "examples", "retrieve", "two", "years", "of", "irradiance", "data", "from", "pvgis", "data", "meta", "inputs", "pvlib", "iotools", "get_pvgis_hourly", "doctest", "skip", "latitude", "45", "longitude", "8", "start", "2015", "end", "2016", "doctest", "skip", "references", "1", "pvgis", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "_", "2", "pvgis", "hourly", "radiation", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "tools", "hourly", "radiation", "_", "3", "pvgis", "non", "interactive", "service", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "docs", "noninteractive", "_", "4", "pvgis", "horizon", "profile", "tool", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "tools", "horizon", "_", "noqa", "e501", "use", "requests", "to", "format", "the", "query", "string", "by", "passing", "params", "dictionary", "params", "lat", "latitude", "lon", "longitude", "outputformat", "outputformat", "angle", "surface_tilt", "aspect", "surface_azimuth", "pvcalculation", "int", "pvcalculation", "pvtechchoice", "pvtechchoice", "mountingplace", "mountingplace", "trackingtype", "trackingtype", "components", "int", "components", "usehorizon", "int", "usehorizon", "optimalangles", "int", "optimalangles", "optimalinclination", "int", "optimal_surface_tilt", "loss", "loss", "pvgis", "only", "takes", "0", "for", "false", "and", "1", "for", "true", "not", "strings", "if", "userhorizon", "is", "not", "none", "params", "userhorizon", "join", "str", "x", "for", "x", "in", "userhorizon", "if", "raddatabase", "is", "not", "none", "params", "raddatabase", "raddatabase", "if", "start", "is", "not", "none", "params", "startyear", "start", "if", "isinstance", "start", "int", "else", "start", "year", "if", "end", "is", "not", "none", "params", "endyear", "end", "if", "isinstance", "end", "int", "else", "end", "year", "if", "peakpower", "is", "not", "none", "params", "peakpower", "peakpower", "the", "url", "endpoint", "for", "hourly", "radiation", "is", "seriescalc", "res", "requests", "get", "url", "seriescalc", "params", "params", "timeout", "timeout", "pvgis", "returns", "really", "well", "formatted", "error", "messages", "in", "json", "for", "http", "1", "1", "400", "bad", "request", "so", "try", "to", "return", "that", "if", "possible", "otherwise", "raise", "the", "http", "1", "1", "error", "caught", "by", "requests", "if", "not", "res", "ok", "try", "err_msg", "res", "json", "except", "exception", "res", "raise_for_status", "else", "raise", "requests", "httperror", "err_msg", "message", "return", "read_pvgis_hourly", "io", "stringio", "res", "text", "pvgis_format", "outputformat", "map_variables", "map_variables"], "doc_len": 1037}
{"doc_id": "pvlib/iotools/pvgis.py::_parse_pvgis_hourly_json", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "_parse_pvgis_hourly_json", "text": "文件路径: pvlib/iotools/pvgis.py\ndef _parse_pvgis_hourly_json(src, map_variables):\n    inputs = src['inputs']\n    metadata = src['meta']\n    data = pd.DataFrame(src['outputs']['hourly'])\n    data.index = pd.to_datetime(data['time'], format='%Y%m%d:%H%M', utc=True)\n    data = data.drop('time', axis=1)\n    data = data.astype(dtype={'Int': 'int'})  # The 'Int' column to be integer\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n    return data, inputs, metadata\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "_parse_pvgis_hourly_json", "src", "map_variables", "inputs", "src", "inputs", "metadata", "src", "meta", "data", "pd", "dataframe", "src", "outputs", "hourly", "data", "index", "pd", "to_datetime", "data", "time", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "drop", "time", "axis", "1", "data", "data", "astype", "dtype", "int", "int", "the", "int", "column", "to", "be", "integer", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "return", "data", "inputs", "metadata"], "doc_len": 63}
{"doc_id": "pvlib/iotools/pvgis.py::_parse_pvgis_hourly_csv", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "_parse_pvgis_hourly_csv", "text": "文件路径: pvlib/iotools/pvgis.py\ndef _parse_pvgis_hourly_csv(src, map_variables):\n    # The first 4 rows are latitude, longitude, elevation, radiation database\n    inputs = {}\n    # 'Latitude (decimal degrees): 45.000\\r\\n'\n    inputs['latitude'] = float(src.readline().split(':')[1])\n    # 'Longitude (decimal degrees): 8.000\\r\\n'\n    inputs['longitude'] = float(src.readline().split(':')[1])\n    # Elevation (m): 1389.0\\r\\n\n    inputs['elevation'] = float(src.readline().split(':')[1])\n    # 'Radiation database: \\tPVGIS-SARAH\\r\\n'\n    inputs['radiation_database'] = src.readline().split(':')[1].strip()\n    # Parse through the remaining metadata section (the number of lines for\n    # this section depends on the requested parameters)\n    while True:\n        line = src.readline()\n        if line.startswith('time,'):  # The data header starts with 'time,'\n            # The last line of the metadata section contains the column names\n            names = line.strip().split(',')\n            break\n        # Only retrieve metadata from non-empty lines\n        elif line.strip() != '':\n            inputs[line.split(':')[0]] = line.split(':')[1].strip()\n        elif line == '':  # If end of file is reached\n            raise ValueError('No data section was detected. File has probably '\n                             'been modified since being downloaded from PVGIS')\n    # Save the entries from the data section to a list, until an empty line is\n    # reached an empty line. The length of the section depends on the request\n    data_lines = []\n    while True:\n        line = src.readline()\n        if line.strip() == '':\n            break\n        else:\n            data_lines.append(line.strip().split(','))\n    data = pd.DataFrame(data_lines, columns=names)\n    data.index = pd.to_datetime(data['time'], format='%Y%m%d:%H%M', utc=True)\n    data = data.drop('time', axis=1)\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n    # All columns should have the dtype=float, except 'Int' which should be\n    # integer. It is necessary to convert to float, before converting to int\n    data = data.astype(float).astype(dtype={'Int': 'int'})\n    # Generate metadata dictionary containing description of parameters\n    metadata = {}\n    for line in src.readlines():\n        if ':' in line:\n            metadata[line.split(':')[0]] = line.split(':')[1].strip()\n    return data, inputs, metadata\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "_parse_pvgis_hourly_csv", "src", "map_variables", "the", "first", "4", "rows", "are", "latitude", "longitude", "elevation", "radiation", "database", "inputs", "latitude", "decimal", "degrees", "45", "000", "r", "n", "inputs", "latitude", "float", "src", "readline", "split", "1", "longitude", "decimal", "degrees", "8", "000", "r", "n", "inputs", "longitude", "float", "src", "readline", "split", "1", "elevation", "m", "1389", "0", "r", "n", "inputs", "elevation", "float", "src", "readline", "split", "1", "radiation", "database", "tpvgis", "sarah", "r", "n", "inputs", "radiation_database", "src", "readline", "split", "1", "strip", "parse", "through", "the", "remaining", "metadata", "section", "the", "number", "of", "lines", "for", "this", "section", "depends", "on", "the", "requested", "parameters", "while", "true", "line", "src", "readline", "if", "line", "startswith", "time", "the", "data", "header", "starts", "with", "time", "the", "last", "line", "of", "the", "metadata", "section", "contains", "the", "column", "names", "names", "line", "strip", "split", "break", "only", "retrieve", "metadata", "from", "non", "empty", "lines", "elif", "line", "strip", "inputs", "line", "split", "0", "line", "split", "1", "strip", "elif", "line", "if", "end", "of", "file", "is", "reached", "raise", "valueerror", "no", "data", "section", "was", "detected", "file", "has", "probably", "been", "modified", "since", "being", "downloaded", "from", "pvgis", "save", "the", "entries", "from", "the", "data", "section", "to", "a", "list", "until", "an", "empty", "line", "is", "reached", "an", "empty", "line", "the", "length", "of", "the", "section", "depends", "on", "the", "request", "data_lines", "while", "true", "line", "src", "readline", "if", "line", "strip", "break", "else", "data_lines", "append", "line", "strip", "split", "data", "pd", "dataframe", "data_lines", "columns", "names", "data", "index", "pd", "to_datetime", "data", "time", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "drop", "time", "axis", "1", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "all", "columns", "should", "have", "the", "dtype", "float", "except", "int", "which", "should", "be", "integer", "it", "is", "necessary", "to", "convert", "to", "float", "before", "converting", "to", "int", "data", "data", "astype", "float", "astype", "dtype", "int", "int", "generate", "metadata", "dictionary", "containing", "description", "of", "parameters", "metadata", "for", "line", "in", "src", "readlines", "if", "in", "line", "metadata", "line", "split", "0", "line", "split", "1", "strip", "return", "data", "inputs", "metadata"], "doc_len": 302}
{"doc_id": "pvlib/iotools/pvgis.py::read_pvgis_hourly", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "read_pvgis_hourly", "text": "文件路径: pvlib/iotools/pvgis.py\ndef read_pvgis_hourly(filename, pvgis_format=None, map_variables=True):\n    \"\"\"Read a PVGIS hourly file.\n\n    Parameters\n    ----------\n    filename : str, pathlib.Path, or file-like buffer\n        Name, path, or buffer of hourly data file downloaded from PVGIS.\n    pvgis_format : str, default None\n        Format of PVGIS file or buffer. Equivalent to the ``outputformat``\n        parameter in the PVGIS API. If ``filename`` is a file and\n        ``pvgis_format`` is ``None`` then the file extension will be used to\n        determine the PVGIS format to parse. If ``filename`` is a buffer, then\n        ``pvgis_format`` is required and must be in ``['csv', 'json']``.\n    map_variables: bool, default True\n        When true, renames columns of the DataFrame to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        the time series data\n    inputs : dict\n        the inputs\n    metadata : dict\n        metadata\n\n    Raises\n    ------\n    ValueError\n        if ``pvgis_format`` is ``None`` and the file extension is neither\n        ``.csv`` nor ``.json`` or if ``pvgis_format`` is provided as\n        input but isn't in ``['csv', 'json']``\n    TypeError\n        if ``pvgis_format`` is ``None`` and ``filename`` is a buffer\n\n    See Also\n    --------\n    get_pvgis_hourly, read_pvgis_tmy\n    \"\"\"\n    # get the PVGIS outputformat\n    if pvgis_format is None:\n        # get the file extension from suffix, but remove the dot and make sure\n        # it's lower case to compare with csv, or json\n        # NOTE: basic format is not supported for PVGIS Hourly as the data\n        # format does not include a header\n        # NOTE: raises TypeError if filename is a buffer\n        outputformat = Path(filename).suffix[1:].lower()\n    else:\n        outputformat = pvgis_format\n\n    # parse the pvgis file based on the output format, either 'json' or 'csv'\n    # NOTE: json and csv output formats have parsers defined as private\n    # functions in this module\n\n    # JSON: use Python built-in json module to convert file contents to a\n    # Python dictionary, and pass the dictionary to the\n    # _parse_pvgis_hourly_json() function from this module\n    if outputformat == 'json':\n        try:\n            src = json.load(filename)\n        except AttributeError:  # str/path has no .read() attribute\n            with open(str(filename), 'r') as fbuf:\n                src = json.load(fbuf)\n        return _parse_pvgis_hourly_json(src, map_variables=map_variables)\n\n    # CSV: use _parse_pvgis_hourly_csv()\n    if outputformat == 'csv':\n        try:\n            pvgis_data = _parse_pvgis_hourly_csv(\n                filename, map_variables=map_variables)\n        except AttributeError:  # str/path has no .read() attribute\n            with open(str(filename), 'r') as fbuf:\n                pvgis_data = _parse_pvgis_hourly_csv(\n                    fbuf, map_variables=map_variables)\n        return pvgis_data\n\n    # raise exception if pvgis format isn't in ['csv', 'json']\n    err_msg = (\n        \"pvgis format '{:s}' was unknown, must be either 'json' or 'csv'\")\\\n        .format(outputformat)\n    raise ValueError(err_msg)\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "read_pvgis_hourly", "filename", "pvgis_format", "none", "map_variables", "true", "read", "a", "pvgis", "hourly", "file", "parameters", "filename", "str", "pathlib", "path", "or", "file", "like", "buffer", "name", "path", "or", "buffer", "of", "hourly", "data", "file", "downloaded", "from", "pvgis", "pvgis_format", "str", "default", "none", "format", "of", "pvgis", "file", "or", "buffer", "equivalent", "to", "the", "outputformat", "parameter", "in", "the", "pvgis", "api", "if", "filename", "is", "a", "file", "and", "pvgis_format", "is", "none", "then", "the", "file", "extension", "will", "be", "used", "to", "determine", "the", "pvgis", "format", "to", "parse", "if", "filename", "is", "a", "buffer", "then", "pvgis_format", "is", "required", "and", "must", "be", "in", "csv", "json", "map_variables", "bool", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "returns", "data", "pandas", "dataframe", "the", "time", "series", "data", "inputs", "dict", "the", "inputs", "metadata", "dict", "metadata", "raises", "valueerror", "if", "pvgis_format", "is", "none", "and", "the", "file", "extension", "is", "neither", "csv", "nor", "json", "or", "if", "pvgis_format", "is", "provided", "as", "input", "but", "isn", "t", "in", "csv", "json", "typeerror", "if", "pvgis_format", "is", "none", "and", "filename", "is", "a", "buffer", "see", "also", "get_pvgis_hourly", "read_pvgis_tmy", "get", "the", "pvgis", "outputformat", "if", "pvgis_format", "is", "none", "get", "the", "file", "extension", "from", "suffix", "but", "remove", "the", "dot", "and", "make", "sure", "it", "s", "lower", "case", "to", "compare", "with", "csv", "or", "json", "note", "basic", "format", "is", "not", "supported", "for", "pvgis", "hourly", "as", "the", "data", "format", "does", "not", "include", "a", "header", "note", "raises", "typeerror", "if", "filename", "is", "a", "buffer", "outputformat", "path", "filename", "suffix", "1", "lower", "else", "outputformat", "pvgis_format", "parse", "the", "pvgis", "file", "based", "on", "the", "output", "format", "either", "json", "or", "csv", "note", "json", "and", "csv", "output", "formats", "have", "parsers", "defined", "as", "private", "functions", "in", "this", "module", "json", "use", "python", "built", "in", "json", "module", "to", "convert", "file", "contents", "to", "a", "python", "dictionary", "and", "pass", "the", "dictionary", "to", "the", "_parse_pvgis_hourly_json", "function", "from", "this", "module", "if", "outputformat", "json", "try", "src", "json", "load", "filename", "except", "attributeerror", "str", "path", "has", "no", "read", "attribute", "with", "open", "str", "filename", "r", "as", "fbuf", "src", "json", "load", "fbuf", "return", "_parse_pvgis_hourly_json", "src", "map_variables", "map_variables", "csv", "use", "_parse_pvgis_hourly_csv", "if", "outputformat", "csv", "try", "pvgis_data", "_parse_pvgis_hourly_csv", "filename", "map_variables", "map_variables", "except", "attributeerror", "str", "path", "has", "no", "read", "attribute", "with", "open", "str", "filename", "r", "as", "fbuf", "pvgis_data", "_parse_pvgis_hourly_csv", "fbuf", "map_variables", "map_variables", "return", "pvgis_data", "raise", "exception", "if", "pvgis", "format", "isn", "t", "in", "csv", "json", "err_msg", "pvgis", "format", "s", "was", "unknown", "must", "be", "either", "json", "or", "csv", "format", "outputformat", "raise", "valueerror", "err_msg"], "doc_len": 384}
{"doc_id": "pvlib/iotools/pvgis.py::get_pvgis_tmy", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "get_pvgis_tmy", "text": "文件路径: pvlib/iotools/pvgis.py\ndef get_pvgis_tmy(latitude, longitude, outputformat='json', usehorizon=True,\n                  userhorizon=None, startyear=None, endyear=None, url=URL,\n                  map_variables=None, timeout=30):\n    \"\"\"\n    Get TMY data from PVGIS.\n\n    For more information see the PVGIS [1]_ TMY tool documentation [2]_.\n\n    Parameters\n    ----------\n    latitude : float\n        Latitude in degrees north\n    longitude : float\n        Longitude in degrees east\n    outputformat : str, default 'json'\n        Must be in ``['csv', 'basic', 'epw', 'json']``. See PVGIS TMY tool\n        documentation [2]_ for more info.\n    usehorizon : bool, default True\n        include effects of horizon\n    userhorizon : list of float, default None\n        optional user specified elevation of horizon in degrees, at equally\n        spaced azimuth clockwise from north, only valid if ``usehorizon`` is\n        true, if ``usehorizon`` is true but ``userhorizon`` is ``None`` then\n        PVGIS will calculate the horizon [3]_\n    startyear : int, default None\n        first year to calculate TMY\n    endyear : int, default None\n        last year to calculate TMY, must be at least 10 years from first year\n    url : str, default: :const:`pvlib.iotools.pvgis.URL`\n        base url of PVGIS API, append ``tmy`` to get TMY endpoint\n    map_variables: bool\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable const:`VARIABLE_MAP`.\n    timeout : int, default 30\n        time in seconds to wait for server response before timeout\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        the weather data\n    months_selected : list\n        TMY year for each month, ``None`` for basic and EPW\n    inputs : dict\n        the inputs, ``None`` for basic and EPW\n    metadata : list or dict\n        file metadata, ``None`` for basic\n\n    Note\n    ----\n    The PVGIS website uses 10 years of data to generate the TMY, whereas the\n    API accessed by this function defaults to using all available years. This\n    means that the TMY returned by this function may not be identical to the\n    one generated by the website. To replicate the website requests, specify\n    the corresponding 10 year period using ``startyear`` and ``endyear``.\n    Specifying ``endyear`` also avoids the TMY changing when new data becomes\n    available.\n\n    Raises\n    ------\n    requests.HTTPError\n        if the request response status is ``HTTP/1.1 400 BAD REQUEST``, then\n        the error message in the response will be raised as an exception,\n        otherwise raise whatever ``HTTP/1.1`` error occurred\n\n    See Also\n    --------\n    read_pvgis_tmy\n\n    References\n    ----------\n    .. [1] `PVGIS <https://ec.europa.eu/jrc/en/pvgis>`_\n    .. [2] `PVGIS TMY tool <https://ec.europa.eu/jrc/en/PVGIS/tools/tmy>`_\n    .. [3] `PVGIS horizon profile tool\n       <https://ec.europa.eu/jrc/en/PVGIS/tools/horizon>`_\n    \"\"\"\n    # use requests to format the query string by passing params dictionary\n    params = {'lat': latitude, 'lon': longitude, 'outputformat': outputformat}\n    # pvgis only likes 0 for False, and 1 for True, not strings, also the\n    # default for usehorizon is already 1 (ie: True), so only set if False\n    if not usehorizon:\n        params['usehorizon'] = 0\n    if userhorizon is not None:\n        params['userhorizon'] = ','.join(str(x) for x in userhorizon)\n    if startyear is not None:\n        params['startyear'] = startyear\n    if endyear is not None:\n        params['endyear'] = endyear\n    res = requests.get(url + 'tmy', params=params, timeout=timeout)\n    # PVGIS returns really well formatted error messages in JSON for HTTP/1.1\n    # 400 BAD REQUEST so try to return that if possible, otherwise raise the\n    # HTTP/1.1 error caught by requests\n    if not res.ok:\n        try:\n            err_msg = res.json()\n        except Exception:\n            res.raise_for_status()\n        else:\n            raise requests.HTTPError(err_msg['message'])\n    # initialize data to None in case API fails to respond to bad outputformat\n    data = None, None, None, None\n    if outputformat == 'json':\n        src = res.json()\n        data, months_selected, inputs, meta = _parse_pvgis_tmy_json(src)\n    elif outputformat == 'csv':\n        with io.BytesIO(res.content) as src:\n            data, months_selected, inputs, meta = _parse_pvgis_tmy_csv(src)\n    elif outputformat == 'basic':\n        with io.BytesIO(res.content) as src:\n            data, months_selected, inputs, meta = _parse_pvgis_tmy_basic(src)\n    elif outputformat == 'epw':\n        with io.StringIO(res.content.decode('utf-8')) as src:\n            data, meta = parse_epw(src)\n            months_selected, inputs = None, None\n    else:\n        # this line is never reached because if outputformat is not valid then\n        # the response is HTTP/1.1 400 BAD REQUEST which is handled earlier\n        pass\n\n    if map_variables is None:\n        warnings.warn(\n            'PVGIS variable names will be renamed to pvlib conventions by '\n            'default starting in pvlib 0.10.0. Specify map_variables=True '\n            'to enable that behavior now, or specify map_variables=False '\n            'to hide this warning.', pvlibDeprecationWarning\n        )\n        map_variables = False\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n\n    return data, months_selected, inputs, meta\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "get_pvgis_tmy", "latitude", "longitude", "outputformat", "json", "usehorizon", "true", "userhorizon", "none", "startyear", "none", "endyear", "none", "url", "url", "map_variables", "none", "timeout", "30", "get", "tmy", "data", "from", "pvgis", "for", "more", "information", "see", "the", "pvgis", "1", "_", "tmy", "tool", "documentation", "2", "_", "parameters", "latitude", "float", "latitude", "in", "degrees", "north", "longitude", "float", "longitude", "in", "degrees", "east", "outputformat", "str", "default", "json", "must", "be", "in", "csv", "basic", "epw", "json", "see", "pvgis", "tmy", "tool", "documentation", "2", "_", "for", "more", "info", "usehorizon", "bool", "default", "true", "include", "effects", "of", "horizon", "userhorizon", "list", "of", "float", "default", "none", "optional", "user", "specified", "elevation", "of", "horizon", "in", "degrees", "at", "equally", "spaced", "azimuth", "clockwise", "from", "north", "only", "valid", "if", "usehorizon", "is", "true", "if", "usehorizon", "is", "true", "but", "userhorizon", "is", "none", "then", "pvgis", "will", "calculate", "the", "horizon", "3", "_", "startyear", "int", "default", "none", "first", "year", "to", "calculate", "tmy", "endyear", "int", "default", "none", "last", "year", "to", "calculate", "tmy", "must", "be", "at", "least", "10", "years", "from", "first", "year", "url", "str", "default", "const", "pvlib", "iotools", "pvgis", "url", "base", "url", "of", "pvgis", "api", "append", "tmy", "to", "get", "tmy", "endpoint", "map_variables", "bool", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "timeout", "int", "default", "30", "time", "in", "seconds", "to", "wait", "for", "server", "response", "before", "timeout", "returns", "data", "pandas", "dataframe", "the", "weather", "data", "months_selected", "list", "tmy", "year", "for", "each", "month", "none", "for", "basic", "and", "epw", "inputs", "dict", "the", "inputs", "none", "for", "basic", "and", "epw", "metadata", "list", "or", "dict", "file", "metadata", "none", "for", "basic", "note", "the", "pvgis", "website", "uses", "10", "years", "of", "data", "to", "generate", "the", "tmy", "whereas", "the", "api", "accessed", "by", "this", "function", "defaults", "to", "using", "all", "available", "years", "this", "means", "that", "the", "tmy", "returned", "by", "this", "function", "may", "not", "be", "identical", "to", "the", "one", "generated", "by", "the", "website", "to", "replicate", "the", "website", "requests", "specify", "the", "corresponding", "10", "year", "period", "using", "startyear", "and", "endyear", "specifying", "endyear", "also", "avoids", "the", "tmy", "changing", "when", "new", "data", "becomes", "available", "raises", "requests", "httperror", "if", "the", "request", "response", "status", "is", "http", "1", "1", "400", "bad", "request", "then", "the", "error", "message", "in", "the", "response", "will", "be", "raised", "as", "an", "exception", "otherwise", "raise", "whatever", "http", "1", "1", "error", "occurred", "see", "also", "read_pvgis_tmy", "references", "1", "pvgis", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "_", "2", "pvgis", "tmy", "tool", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "tools", "tmy", "_", "3", "pvgis", "horizon", "profile", "tool", "https", "ec", "europa", "eu", "jrc", "en", "pvgis", "tools", "horizon", "_", "use", "requests", "to", "format", "the", "query", "string", "by", "passing", "params", "dictionary", "params", "lat", "latitude", "lon", "longitude", "outputformat", "outputformat", "pvgis", "only", "likes", "0", "for", "false", "and", "1", "for", "true", "not", "strings", "also", "the", "default", "for", "usehorizon", "is", "already", "1", "ie", "true", "so", "only", "set", "if", "false", "if", "not", "usehorizon", "params", "usehorizon", "0", "if", "userhorizon", "is", "not", "none", "params", "userhorizon", "join", "str", "x", "for", "x", "in", "userhorizon", "if", "startyear", "is", "not", "none", "params", "startyear", "startyear", "if", "endyear", "is", "not", "none", "params", "endyear", "endyear", "res", "requests", "get", "url", "tmy", "params", "params", "timeout", "timeout", "pvgis", "returns", "really", "well", "formatted", "error", "messages", "in", "json", "for", "http", "1", "1", "400", "bad", "request", "so", "try", "to", "return", "that", "if", "possible", "otherwise", "raise", "the", "http", "1", "1", "error", "caught", "by", "requests", "if", "not", "res", "ok", "try", "err_msg", "res", "json", "except", "exception", "res", "raise_for_status", "else", "raise", "requests", "httperror", "err_msg", "message", "initialize", "data", "to", "none", "in", "case", "api", "fails", "to", "respond", "to", "bad", "outputformat", "data", "none", "none", "none", "none", "if", "outputformat", "json", "src", "res", "json", "data", "months_selected", "inputs", "meta", "_parse_pvgis_tmy_json", "src", "elif", "outputformat", "csv", "with", "io", "bytesio", "res", "content", "as", "src", "data", "months_selected", "inputs", "meta", "_parse_pvgis_tmy_csv", "src", "elif", "outputformat", "basic", "with", "io", "bytesio", "res", "content", "as", "src", "data", "months_selected", "inputs", "meta", "_parse_pvgis_tmy_basic", "src", "elif", "outputformat", "epw", "with", "io", "stringio", "res", "content", "decode", "utf", "8", "as", "src", "data", "meta", "parse_epw", "src", "months_selected", "inputs", "none", "none", "else", "this", "line", "is", "never", "reached", "because", "if", "outputformat", "is", "not", "valid", "then", "the", "response", "is", "http", "1", "1", "400", "bad", "request", "which", "is", "handled", "earlier", "pass", "if", "map_variables", "is", "none", "warnings", "warn", "pvgis", "variable", "names", "will", "be", "renamed", "to", "pvlib", "conventions", "by", "default", "starting", "in", "pvlib", "0", "10", "0", "specify", "map_variables", "true", "to", "enable", "that", "behavior", "now", "or", "specify", "map_variables", "false", "to", "hide", "this", "warning", "pvlibdeprecationwarning", "map_variables", "false", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "return", "data", "months_selected", "inputs", "meta"], "doc_len": 700}
{"doc_id": "pvlib/iotools/pvgis.py::_parse_pvgis_tmy_json", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "_parse_pvgis_tmy_json", "text": "文件路径: pvlib/iotools/pvgis.py\ndef _parse_pvgis_tmy_json(src):\n    inputs = src['inputs']\n    meta = src['meta']\n    months_selected = src['outputs']['months_selected']\n    data = pd.DataFrame(src['outputs']['tmy_hourly'])\n    data.index = pd.to_datetime(\n        data['time(UTC)'], format='%Y%m%d:%H%M', utc=True)\n    data = data.drop('time(UTC)', axis=1)\n    return data, months_selected, inputs, meta\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "_parse_pvgis_tmy_json", "src", "inputs", "src", "inputs", "meta", "src", "meta", "months_selected", "src", "outputs", "months_selected", "data", "pd", "dataframe", "src", "outputs", "tmy_hourly", "data", "index", "pd", "to_datetime", "data", "time", "utc", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "drop", "time", "utc", "axis", "1", "return", "data", "months_selected", "inputs", "meta"], "doc_len": 50}
{"doc_id": "pvlib/iotools/pvgis.py::_parse_pvgis_tmy_csv", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "_parse_pvgis_tmy_csv", "text": "文件路径: pvlib/iotools/pvgis.py\ndef _parse_pvgis_tmy_csv(src):\n    # the first 3 rows are latitude, longitude, elevation\n    inputs = {}\n    # 'Latitude (decimal degrees): 45.000\\r\\n'\n    inputs['latitude'] = float(src.readline().split(b':')[1])\n    # 'Longitude (decimal degrees): 8.000\\r\\n'\n    inputs['longitude'] = float(src.readline().split(b':')[1])\n    # Elevation (m): 1389.0\\r\\n\n    inputs['elevation'] = float(src.readline().split(b':')[1])\n    # then there's a 13 row comma separated table with two columns: month, year\n    # which contains the year used for that month in the\n    src.readline()  # get \"month,year\\r\\n\"\n    months_selected = []\n    for month in range(12):\n        months_selected.append(\n            {'month': month+1, 'year': int(src.readline().split(b',')[1])})\n    # then there's the TMY (typical meteorological year) data\n    # first there's a header row:\n    #    time(UTC),T2m,RH,G(h),Gb(n),Gd(h),IR(h),WS10m,WD10m,SP\n    headers = [h.decode('utf-8').strip() for h in src.readline().split(b',')]\n    data = pd.DataFrame(\n        [src.readline().split(b',') for _ in range(8760)], columns=headers)\n    dtidx = data['time(UTC)'].apply(lambda dt: dt.decode('utf-8'))\n    dtidx = pd.to_datetime(dtidx, format='%Y%m%d:%H%M', utc=True)\n    data = data.drop('time(UTC)', axis=1)\n    data = pd.DataFrame(data, dtype=float)\n    data.index = dtidx\n    # finally there's some meta data\n    meta = [line.decode('utf-8').strip() for line in src.readlines()]\n    return data, months_selected, inputs, meta\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "_parse_pvgis_tmy_csv", "src", "the", "first", "3", "rows", "are", "latitude", "longitude", "elevation", "inputs", "latitude", "decimal", "degrees", "45", "000", "r", "n", "inputs", "latitude", "float", "src", "readline", "split", "b", "1", "longitude", "decimal", "degrees", "8", "000", "r", "n", "inputs", "longitude", "float", "src", "readline", "split", "b", "1", "elevation", "m", "1389", "0", "r", "n", "inputs", "elevation", "float", "src", "readline", "split", "b", "1", "then", "there", "s", "a", "13", "row", "comma", "separated", "table", "with", "two", "columns", "month", "year", "which", "contains", "the", "year", "used", "for", "that", "month", "in", "the", "src", "readline", "get", "month", "year", "r", "n", "months_selected", "for", "month", "in", "range", "12", "months_selected", "append", "month", "month", "1", "year", "int", "src", "readline", "split", "b", "1", "then", "there", "s", "the", "tmy", "typical", "meteorological", "year", "data", "first", "there", "s", "a", "header", "row", "time", "utc", "t2m", "rh", "g", "h", "gb", "n", "gd", "h", "ir", "h", "ws10m", "wd10m", "sp", "headers", "h", "decode", "utf", "8", "strip", "for", "h", "in", "src", "readline", "split", "b", "data", "pd", "dataframe", "src", "readline", "split", "b", "for", "_", "in", "range", "8760", "columns", "headers", "dtidx", "data", "time", "utc", "apply", "lambda", "dt", "dt", "decode", "utf", "8", "dtidx", "pd", "to_datetime", "dtidx", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "drop", "time", "utc", "axis", "1", "data", "pd", "dataframe", "data", "dtype", "float", "data", "index", "dtidx", "finally", "there", "s", "some", "meta", "data", "meta", "line", "decode", "utf", "8", "strip", "for", "line", "in", "src", "readlines", "return", "data", "months_selected", "inputs", "meta"], "doc_len": 227}
{"doc_id": "pvlib/iotools/pvgis.py::_parse_pvgis_tmy_basic", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "_parse_pvgis_tmy_basic", "text": "文件路径: pvlib/iotools/pvgis.py\ndef _parse_pvgis_tmy_basic(src):\n    data = pd.read_csv(src)\n    data.index = pd.to_datetime(\n        data['time(UTC)'], format='%Y%m%d:%H%M', utc=True)\n    data = data.drop('time(UTC)', axis=1)\n    return data, None, None, None\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "_parse_pvgis_tmy_basic", "src", "data", "pd", "read_csv", "src", "data", "index", "pd", "to_datetime", "data", "time", "utc", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "drop", "time", "utc", "axis", "1", "return", "data", "none", "none", "none"], "doc_len": 38}
{"doc_id": "pvlib/iotools/pvgis.py::read_pvgis_tmy", "file_path": "pvlib/iotools/pvgis.py", "class_name": null, "func_name": "read_pvgis_tmy", "text": "文件路径: pvlib/iotools/pvgis.py\ndef read_pvgis_tmy(filename, pvgis_format=None, map_variables=None):\n    \"\"\"\n    Read a file downloaded from PVGIS.\n\n    Parameters\n    ----------\n    filename : str, pathlib.Path, or file-like buffer\n        Name, path, or buffer of file downloaded from PVGIS.\n    pvgis_format : str, default None\n        Format of PVGIS file or buffer. Equivalent to the ``outputformat``\n        parameter in the PVGIS TMY API. If ``filename`` is a file and\n        ``pvgis_format`` is ``None`` then the file extension will be used to\n        determine the PVGIS format to parse. For PVGIS files from the API with\n        ``outputformat='basic'``, please set ``pvgis_format`` to ``'basic'``.\n        If ``filename`` is a buffer, then ``pvgis_format`` is required and must\n        be in ``['csv', 'epw', 'json', 'basic']``.\n    map_variables: bool\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n\n\n    Returns\n    -------\n    data : pandas.DataFrame\n        the weather data\n    months_selected : list\n        TMY year for each month, ``None`` for basic and EPW\n    inputs : dict\n        the inputs, ``None`` for basic and EPW\n    metadata : list or dict\n        file metadata, ``None`` for basic\n\n    Raises\n    ------\n    ValueError\n        if ``pvgis_format`` is ``None`` and the file extension is neither\n        ``.csv``, ``.json``, nor ``.epw``, or if ``pvgis_format`` is provided\n        as input but isn't in ``['csv', 'epw', 'json', 'basic']``\n    TypeError\n        if ``pvgis_format`` is ``None`` and ``filename`` is a buffer\n\n    See Also\n    --------\n    get_pvgis_tmy\n    \"\"\"\n    # get the PVGIS outputformat\n    if pvgis_format is None:\n        # get the file extension from suffix, but remove the dot and make sure\n        # it's lower case to compare with epw, csv, or json\n        # NOTE: raises TypeError if filename is a buffer\n        outputformat = Path(filename).suffix[1:].lower()\n    else:\n        outputformat = pvgis_format\n    # parse the pvgis file based on the output format, either 'epw', 'json',\n    # 'csv', or 'basic'\n\n    # EPW: use the EPW parser from the pvlib.iotools epw.py module\n    if outputformat == 'epw':\n        try:\n            data, meta = parse_epw(filename)\n        except AttributeError:  # str/path has no .read() attribute\n            data, meta = read_epw(filename)\n        months_selected, inputs = None, None\n\n    # NOTE: json, csv, and basic output formats have parsers defined as private\n    # functions in this module\n\n    # JSON: use Python built-in json module to convert file contents to a\n    # Python dictionary, and pass the dictionary to the _parse_pvgis_tmy_json()\n    # function from this module\n    elif outputformat == 'json':\n        try:\n            src = json.load(filename)\n        except AttributeError:  # str/path has no .read() attribute\n            with open(str(filename), 'r') as fbuf:\n                src = json.load(fbuf)\n        data, months_selected, inputs, meta = _parse_pvgis_tmy_json(src)\n\n    # CSV or basic: use the correct parser from this module\n    # eg: _parse_pvgis_tmy_csv() or _parse_pvgist_tmy_basic()\n    elif outputformat in ['csv', 'basic']:\n        # get the correct parser function for this output format from globals()\n        pvgis_parser = globals()['_parse_pvgis_tmy_{:s}'.format(outputformat)]\n        # NOTE: pvgis_parse() is a pvgis parser function from this module,\n        # either _parse_pvgis_tmy_csv() or _parse_pvgist_tmy_basic()\n        try:\n            data, months_selected, inputs, meta = pvgis_parser(filename)\n        except AttributeError:  # str/path has no .read() attribute\n            with open(str(filename), 'rb') as fbuf:\n                data, months_selected, inputs, meta = pvgis_parser(fbuf)\n\n    else:\n        # raise exception if pvgis format isn't in ['csv','basic','epw','json']\n        err_msg = (\n            \"pvgis format '{:s}' was unknown, must be either 'epw', 'json', \"\n            \"'csv', or 'basic'\").format(outputformat)\n        raise ValueError(err_msg)\n\n    if map_variables is None:\n        warnings.warn(\n            'PVGIS variable names will be renamed to pvlib conventions by '\n            'default starting in pvlib 0.10.0. Specify map_variables=True '\n            'to enable that behavior now, or specify map_variables=False '\n            'to hide this warning.', pvlibDeprecationWarning\n        )\n        map_variables = False\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n\n    return data, months_selected, inputs, meta\n", "tokens": ["pvlib", "iotools", "pvgis", "py", "def", "read_pvgis_tmy", "filename", "pvgis_format", "none", "map_variables", "none", "read", "a", "file", "downloaded", "from", "pvgis", "parameters", "filename", "str", "pathlib", "path", "or", "file", "like", "buffer", "name", "path", "or", "buffer", "of", "file", "downloaded", "from", "pvgis", "pvgis_format", "str", "default", "none", "format", "of", "pvgis", "file", "or", "buffer", "equivalent", "to", "the", "outputformat", "parameter", "in", "the", "pvgis", "tmy", "api", "if", "filename", "is", "a", "file", "and", "pvgis_format", "is", "none", "then", "the", "file", "extension", "will", "be", "used", "to", "determine", "the", "pvgis", "format", "to", "parse", "for", "pvgis", "files", "from", "the", "api", "with", "outputformat", "basic", "please", "set", "pvgis_format", "to", "basic", "if", "filename", "is", "a", "buffer", "then", "pvgis_format", "is", "required", "and", "must", "be", "in", "csv", "epw", "json", "basic", "map_variables", "bool", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "returns", "data", "pandas", "dataframe", "the", "weather", "data", "months_selected", "list", "tmy", "year", "for", "each", "month", "none", "for", "basic", "and", "epw", "inputs", "dict", "the", "inputs", "none", "for", "basic", "and", "epw", "metadata", "list", "or", "dict", "file", "metadata", "none", "for", "basic", "raises", "valueerror", "if", "pvgis_format", "is", "none", "and", "the", "file", "extension", "is", "neither", "csv", "json", "nor", "epw", "or", "if", "pvgis_format", "is", "provided", "as", "input", "but", "isn", "t", "in", "csv", "epw", "json", "basic", "typeerror", "if", "pvgis_format", "is", "none", "and", "filename", "is", "a", "buffer", "see", "also", "get_pvgis_tmy", "get", "the", "pvgis", "outputformat", "if", "pvgis_format", "is", "none", "get", "the", "file", "extension", "from", "suffix", "but", "remove", "the", "dot", "and", "make", "sure", "it", "s", "lower", "case", "to", "compare", "with", "epw", "csv", "or", "json", "note", "raises", "typeerror", "if", "filename", "is", "a", "buffer", "outputformat", "path", "filename", "suffix", "1", "lower", "else", "outputformat", "pvgis_format", "parse", "the", "pvgis", "file", "based", "on", "the", "output", "format", "either", "epw", "json", "csv", "or", "basic", "epw", "use", "the", "epw", "parser", "from", "the", "pvlib", "iotools", "epw", "py", "module", "if", "outputformat", "epw", "try", "data", "meta", "parse_epw", "filename", "except", "attributeerror", "str", "path", "has", "no", "read", "attribute", "data", "meta", "read_epw", "filename", "months_selected", "inputs", "none", "none", "note", "json", "csv", "and", "basic", "output", "formats", "have", "parsers", "defined", "as", "private", "functions", "in", "this", "module", "json", "use", "python", "built", "in", "json", "module", "to", "convert", "file", "contents", "to", "a", "python", "dictionary", "and", "pass", "the", "dictionary", "to", "the", "_parse_pvgis_tmy_json", "function", "from", "this", "module", "elif", "outputformat", "json", "try", "src", "json", "load", "filename", "except", "attributeerror", "str", "path", "has", "no", "read", "attribute", "with", "open", "str", "filename", "r", "as", "fbuf", "src", "json", "load", "fbuf", "data", "months_selected", "inputs", "meta", "_parse_pvgis_tmy_json", "src", "csv", "or", "basic", "use", "the", "correct", "parser", "from", "this", "module", "eg", "_parse_pvgis_tmy_csv", "or", "_parse_pvgist_tmy_basic", "elif", "outputformat", "in", "csv", "basic", "get", "the", "correct", "parser", "function", "for", "this", "output", "format", "from", "globals", "pvgis_parser", "globals", "_parse_pvgis_tmy_", "s", "format", "outputformat", "note", "pvgis_parse", "is", "a", "pvgis", "parser", "function", "from", "this", "module", "either", "_parse_pvgis_tmy_csv", "or", "_parse_pvgist_tmy_basic", "try", "data", "months_selected", "inputs", "meta", "pvgis_parser", "filename", "except", "attributeerror", "str", "path", "has", "no", "read", "attribute", "with", "open", "str", "filename", "rb", "as", "fbuf", "data", "months_selected", "inputs", "meta", "pvgis_parser", "fbuf", "else", "raise", "exception", "if", "pvgis", "format", "isn", "t", "in", "csv", "basic", "epw", "json", "err_msg", "pvgis", "format", "s", "was", "unknown", "must", "be", "either", "epw", "json", "csv", "or", "basic", "format", "outputformat", "raise", "valueerror", "err_msg", "if", "map_variables", "is", "none", "warnings", "warn", "pvgis", "variable", "names", "will", "be", "renamed", "to", "pvlib", "conventions", "by", "default", "starting", "in", "pvlib", "0", "10", "0", "specify", "map_variables", "true", "to", "enable", "that", "behavior", "now", "or", "specify", "map_variables", "false", "to", "hide", "this", "warning", "pvlibdeprecationwarning", "map_variables", "false", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "return", "data", "months_selected", "inputs", "meta"], "doc_len": 548}
{"doc_id": "pvlib/iotools/sodapro.py::get_cams", "file_path": "pvlib/iotools/sodapro.py", "class_name": null, "func_name": "get_cams", "text": "文件路径: pvlib/iotools/sodapro.py\ndef get_cams(latitude, longitude, start, end, email, identifier='mcclear',\n             altitude=None, time_step='1h', time_ref='UT', verbose=False,\n             integrated=False, label=None, map_variables=True,\n             server='www.soda-is.com', timeout=30):\n    \"\"\"\n    Retrieve time-series of radiation and/or clear-sky global, beam, and\n    diffuse radiation from CAMS (see [1]_). Data is retrieved from SoDa [2]_.\n\n    Time coverage: 2004-01-01 to two days ago\n\n    Access: free, but requires registration, see [2]_\n\n    Requests: max. 100 per day\n    Geographical coverage: worldwide for CAMS McClear and approximately -66° to\n    66° in both latitude and longitude for CAMS Radiation.\n\n    Parameters\n    ----------\n    latitude: float\n        in decimal degrees, between -90 and 90, north is positive (ISO 19115)\n    longitude : float\n        in decimal degrees, between -180 and 180, east is positive (ISO 19115)\n    start: datetime like\n        First day of the requested period\n    end: datetime like\n        Last day of the requested period\n    email: str\n        Email address linked to a SoDa account\n    identifier: {'mcclear', 'cams_radiation'}\n        Specify whether to retrieve CAMS Radiation or McClear parameters\n    altitude: float, optional\n        Altitude in meters. If None, then the altitude is determined from the\n        NASA SRTM database\n    time_step: str, {'1min', '15min', '1h', '1d', '1M'}, default: '1h'\n        Time step of the time series, either 1 minute, 15 minute, hourly,\n        daily, or monthly.\n    time_ref: str, {'UT', 'TST'}, default: 'UT'\n        'UT' (universal time) or 'TST' (True Solar Time)\n    verbose: boolean, default: False\n        Verbose mode outputs additional parameters (aerosols). Only available\n        for 1 minute and universal time. See [1]_ for parameter description.\n    integrated: boolean, default False\n        Whether to return radiation parameters as integrated values (Wh/m^2)\n        or as average irradiance values (W/m^2) (pvlib preferred units)\n    label: {'right', 'left'}, default: None\n        Which bin edge label to label time-step with. The default is 'left' for\n        all time steps except for '1M' which has a default of 'right'.\n    map_variables: bool, default: True\n        When true, renames columns of the DataFrame to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n    server: str, default: 'www.soda-is.com'\n        Main server (www.soda-is.com) or backup mirror server (pro.soda-is.com)\n    timeout : int, default: 30\n        Time in seconds to wait for server response before timeout\n\n    Returns\n    -------\n    data: pandas.DataFrame\n        Timeseries data, see Notes for columns\n    metadata: dict\n        Metadata of the requested time-series\n\n    Notes\n    -----\n    In order to use the CAMS services, users must register for a free SoDa\n    account using an email address [2]_.\n\n    The returned data DataFrame includes the following fields:\n\n    ========================  ======  =========================================\n    Key, mapped key           Format  Description\n    ========================  ======  =========================================\n    **Mapped field names are returned when the map_variables argument is True**\n    ---------------------------------------------------------------------------\n    Observation period        str     Beginning/end of time period\n    TOA, ghi_extra            float   Horizontal radiation at top of atmosphere\n    Clear sky GHI, ghi_clear  float   Clear sky global radiation on horizontal\n    Clear sky BHI, bhi_clear  float   Clear sky beam radiation on horizontal\n    Clear sky DHI, dhi_clear  float   Clear sky diffuse radiation on horizontal\n    Clear sky BNI, dni_clear  float   Clear sky beam radiation normal to sun\n    GHI, ghi†                 float   Global horizontal radiation\n    BHI, bhi†                 float   Beam (direct) radiation on horizontal\n    DHI, dhi†                 float   Diffuse horizontal radiation\n    BNI, dni†                 float   Beam (direct) radiation normal to the sun\n    Reliability†              float   Reliable data fraction in summarization\n    ========================  ======  =========================================\n\n    †Parameters only returned if identifier='cams_radiation'. For description\n    of additional output parameters in verbose mode, see [1]_.\n\n    Note that it is recommended to specify the latitude and longitude to at\n    least the fourth decimal place.\n\n    Variables corresponding to standard pvlib variables are renamed,\n    e.g. `sza` becomes `solar_zenith`. See variable :const:`VARIABLE_MAP` for\n    the complete mapping.\n\n    See Also\n    --------\n    pvlib.iotools.read_cams, pvlib.iotools.parse_cams\n\n    Raises\n    ------\n    requests.HTTPError\n        If the request is invalid, then an XML file is returned by the CAMS\n        service and the error message will be raised as an exception.\n\n    References\n    ----------\n    .. [1] `CAMS solar radiation documentation\n       <https://atmosphere.copernicus.eu/solar-radiation>`_\n    .. [2] `CAMS Radiation Automatic Access (SoDa)\n       <https://www.soda-pro.com/help/cams-services/cams-radiation-service/automatic-access>`_\n    \"\"\"\n    try:\n        time_step_str = TIME_STEPS_MAP[time_step]\n    except KeyError:\n        raise ValueError(f'Time step not recognized. Must be one of '\n                         f'{list(TIME_STEPS_MAP.keys())}')\n\n    if (verbose) and ((time_step != '1min') or (time_ref != 'UT')):\n        verbose = False\n        warnings.warn(\"Verbose mode only supports 1 min. UT time series!\")\n\n    if identifier not in ['mcclear', 'cams_radiation']:\n        raise ValueError('Identifier must be either mcclear or cams_radiation')\n\n    # Format verbose variable to the required format: {'true', 'false'}\n    verbose = str(verbose).lower()\n\n    if altitude is None:  # Let SoDa get elevation from the NASA SRTM database\n        altitude = -999\n\n    # Start and end date should be in the format: yyyy-mm-dd\n    start = start.strftime('%Y-%m-%d')\n    end = end.strftime('%Y-%m-%d')\n\n    email = email.replace('@', '%2540')  # Format email address\n    identifier = 'get_{}'.format(identifier.lower())  # Format identifier str\n\n    base_url = f\"https://{server}/service/wps\"\n\n    data_inputs_dict = {\n        'latitude': latitude,\n        'longitude': longitude,\n        'altitude': altitude,\n        'date_begin': start,\n        'date_end': end,\n        'time_ref': time_ref,\n        'summarization': time_step_str,\n        'username': email,\n        'verbose': verbose}\n\n    # Manual formatting of the input parameters seperating each by a semicolon\n    data_inputs = \";\".join([f\"{key}={value}\" for key, value in\n                            data_inputs_dict.items()])\n\n    params = {'Service': 'WPS',\n              'Request': 'Execute',\n              'Identifier': identifier,\n              'version': '1.0.0',\n              'RawDataOutput': 'irradiation',\n              }\n\n    # The DataInputs parameter of the URL has to be manually formatted and\n    # added to the base URL as it contains sub-parameters seperated by\n    # semi-colons, which gets incorrectly formatted by the requests function\n    # if passed using the params argument.\n    res = requests.get(base_url + '?DataInputs=' + data_inputs, params=params,\n                       timeout=timeout)\n\n    # Invalid requests returns an XML error message and the HTTP staus code 200\n    # as if the request was successful. Therefore, errors cannot be handled\n    # automatic (e.g. res.raise_for_status()) and errors are handled manually\n    if res.headers['Content-Type'] == 'application/xml':\n        errors = res.text.split('ows:ExceptionText')[1][1:-2]\n        raise requests.HTTPError(errors, response=res)\n    # Successful requests returns a csv data file\n    elif res.headers['Content-Type'] == 'application/csv':\n        fbuf = io.StringIO(res.content.decode('utf-8'))\n        data, metadata = parse_cams(fbuf, integrated=integrated, label=label,\n                                    map_variables=map_variables)\n        return data, metadata\n", "tokens": ["pvlib", "iotools", "sodapro", "py", "def", "get_cams", "latitude", "longitude", "start", "end", "email", "identifier", "mcclear", "altitude", "none", "time_step", "1h", "time_ref", "ut", "verbose", "false", "integrated", "false", "label", "none", "map_variables", "true", "server", "www", "soda", "is", "com", "timeout", "30", "retrieve", "time", "series", "of", "radiation", "and", "or", "clear", "sky", "global", "beam", "and", "diffuse", "radiation", "from", "cams", "see", "1", "_", "data", "is", "retrieved", "from", "soda", "2", "_", "time", "coverage", "2004", "01", "01", "to", "two", "days", "ago", "access", "free", "but", "requires", "registration", "see", "2", "_", "requests", "max", "100", "per", "day", "geographical", "coverage", "worldwide", "for", "cams", "mcclear", "and", "approximately", "66", "to", "66", "in", "both", "latitude", "and", "longitude", "for", "cams", "radiation", "parameters", "latitude", "float", "in", "decimal", "degrees", "between", "90", "and", "90", "north", "is", "positive", "iso", "19115", "longitude", "float", "in", "decimal", "degrees", "between", "180", "and", "180", "east", "is", "positive", "iso", "19115", "start", "datetime", "like", "first", "day", "of", "the", "requested", "period", "end", "datetime", "like", "last", "day", "of", "the", "requested", "period", "email", "str", "email", "address", "linked", "to", "a", "soda", "account", "identifier", "mcclear", "cams_radiation", "specify", "whether", "to", "retrieve", "cams", "radiation", "or", "mcclear", "parameters", "altitude", "float", "optional", "altitude", "in", "meters", "if", "none", "then", "the", "altitude", "is", "determined", "from", "the", "nasa", "srtm", "database", "time_step", "str", "1min", "15min", "1h", "1d", "1m", "default", "1h", "time", "step", "of", "the", "time", "series", "either", "1", "minute", "15", "minute", "hourly", "daily", "or", "monthly", "time_ref", "str", "ut", "tst", "default", "ut", "ut", "universal", "time", "or", "tst", "true", "solar", "time", "verbose", "boolean", "default", "false", "verbose", "mode", "outputs", "additional", "parameters", "aerosols", "only", "available", "for", "1", "minute", "and", "universal", "time", "see", "1", "_", "for", "parameter", "description", "integrated", "boolean", "default", "false", "whether", "to", "return", "radiation", "parameters", "as", "integrated", "values", "wh", "m", "2", "or", "as", "average", "irradiance", "values", "w", "m", "2", "pvlib", "preferred", "units", "label", "right", "left", "default", "none", "which", "bin", "edge", "label", "to", "label", "time", "step", "with", "the", "default", "is", "left", "for", "all", "time", "steps", "except", "for", "1m", "which", "has", "a", "default", "of", "right", "map_variables", "bool", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "server", "str", "default", "www", "soda", "is", "com", "main", "server", "www", "soda", "is", "com", "or", "backup", "mirror", "server", "pro", "soda", "is", "com", "timeout", "int", "default", "30", "time", "in", "seconds", "to", "wait", "for", "server", "response", "before", "timeout", "returns", "data", "pandas", "dataframe", "timeseries", "data", "see", "notes", "for", "columns", "metadata", "dict", "metadata", "of", "the", "requested", "time", "series", "notes", "in", "order", "to", "use", "the", "cams", "services", "users", "must", "register", "for", "a", "free", "soda", "account", "using", "an", "email", "address", "2", "_", "the", "returned", "data", "dataframe", "includes", "the", "following", "fields", "key", "mapped", "key", "format", "description", "mapped", "field", "names", "are", "returned", "when", "the", "map_variables", "argument", "is", "true", "observation", "period", "str", "beginning", "end", "of", "time", "period", "toa", "ghi_extra", "float", "horizontal", "radiation", "at", "top", "of", "atmosphere", "clear", "sky", "ghi", "ghi_clear", "float", "clear", "sky", "global", "radiation", "on", "horizontal", "clear", "sky", "bhi", "bhi_clear", "float", "clear", "sky", "beam", "radiation", "on", "horizontal", "clear", "sky", "dhi", "dhi_clear", "float", "clear", "sky", "diffuse", "radiation", "on", "horizontal", "clear", "sky", "bni", "dni_clear", "float", "clear", "sky", "beam", "radiation", "normal", "to", "sun", "ghi", "ghi", "float", "global", "horizontal", "radiation", "bhi", "bhi", "float", "beam", "direct", "radiation", "on", "horizontal", "dhi", "dhi", "float", "diffuse", "horizontal", "radiation", "bni", "dni", "float", "beam", "direct", "radiation", "normal", "to", "the", "sun", "reliability", "float", "reliable", "data", "fraction", "in", "summarization", "parameters", "only", "returned", "if", "identifier", "cams_radiation", "for", "description", "of", "additional", "output", "parameters", "in", "verbose", "mode", "see", "1", "_", "note", "that", "it", "is", "recommended", "to", "specify", "the", "latitude", "and", "longitude", "to", "at", "least", "the", "fourth", "decimal", "place", "variables", "corresponding", "to", "standard", "pvlib", "variables", "are", "renamed", "e", "g", "sza", "becomes", "solar_zenith", "see", "variable", "const", "variable_map", "for", "the", "complete", "mapping", "see", "also", "pvlib", "iotools", "read_cams", "pvlib", "iotools", "parse_cams", "raises", "requests", "httperror", "if", "the", "request", "is", "invalid", "then", "an", "xml", "file", "is", "returned", "by", "the", "cams", "service", "and", "the", "error", "message", "will", "be", "raised", "as", "an", "exception", "references", "1", "cams", "solar", "radiation", "documentation", "https", "atmosphere", "copernicus", "eu", "solar", "radiation", "_", "2", "cams", "radiation", "automatic", "access", "soda", "https", "www", "soda", "pro", "com", "help", "cams", "services", "cams", "radiation", "service", "automatic", "access", "_", "try", "time_step_str", "time_steps_map", "time_step", "except", "keyerror", "raise", "valueerror", "f", "time", "step", "not", "recognized", "must", "be", "one", "of", "f", "list", "time_steps_map", "keys", "if", "verbose", "and", "time_step", "1min", "or", "time_ref", "ut", "verbose", "false", "warnings", "warn", "verbose", "mode", "only", "supports", "1", "min", "ut", "time", "series", "if", "identifier", "not", "in", "mcclear", "cams_radiation", "raise", "valueerror", "identifier", "must", "be", "either", "mcclear", "or", "cams_radiation", "format", "verbose", "variable", "to", "the", "required", "format", "true", "false", "verbose", "str", "verbose", "lower", "if", "altitude", "is", "none", "let", "soda", "get", "elevation", "from", "the", "nasa", "srtm", "database", "altitude", "999", "start", "and", "end", "date", "should", "be", "in", "the", "format", "yyyy", "mm", "dd", "start", "start", "strftime", "y", "m", "d", "end", "end", "strftime", "y", "m", "d", "email", "email", "replace", "2540", "format", "email", "address", "identifier", "get_", "format", "identifier", "lower", "format", "identifier", "str", "base_url", "f", "https", "server", "service", "wps", "data_inputs_dict", "latitude", "latitude", "longitude", "longitude", "altitude", "altitude", "date_begin", "start", "date_end", "end", "time_ref", "time_ref", "summarization", "time_step_str", "username", "email", "verbose", "verbose", "manual", "formatting", "of", "the", "input", "parameters", "seperating", "each", "by", "a", "semicolon", "data_inputs", "join", "f", "key", "value", "for", "key", "value", "in", "data_inputs_dict", "items", "params", "service", "wps", "request", "execute", "identifier", "identifier", "version", "1", "0", "0", "rawdataoutput", "irradiation", "the", "datainputs", "parameter", "of", "the", "url", "has", "to", "be", "manually", "formatted", "and", "added", "to", "the", "base", "url", "as", "it", "contains", "sub", "parameters", "seperated", "by", "semi", "colons", "which", "gets", "incorrectly", "formatted", "by", "the", "requests", "function", "if", "passed", "using", "the", "params", "argument", "res", "requests", "get", "base_url", "datainputs", "data_inputs", "params", "params", "timeout", "timeout", "invalid", "requests", "returns", "an", "xml", "error", "message", "and", "the", "http", "staus", "code", "200", "as", "if", "the", "request", "was", "successful", "therefore", "errors", "cannot", "be", "handled", "automatic", "e", "g", "res", "raise_for_status", "and", "errors", "are", "handled", "manually", "if", "res", "headers", "content", "type", "application", "xml", "errors", "res", "text", "split", "ows", "exceptiontext", "1", "1", "2", "raise", "requests", "httperror", "errors", "response", "res", "successful", "requests", "returns", "a", "csv", "data", "file", "elif", "res", "headers", "content", "type", "application", "csv", "fbuf", "io", "stringio", "res", "content", "decode", "utf", "8", "data", "metadata", "parse_cams", "fbuf", "integrated", "integrated", "label", "label", "map_variables", "map_variables", "return", "data", "metadata"], "doc_len": 976}
{"doc_id": "pvlib/iotools/sodapro.py::parse_cams", "file_path": "pvlib/iotools/sodapro.py", "class_name": null, "func_name": "parse_cams", "text": "文件路径: pvlib/iotools/sodapro.py\ndef parse_cams(fbuf, integrated=False, label=None, map_variables=True):\n    \"\"\"\n    Parse a file-like buffer with data in the format of a CAMS Radiation or\n    McClear file. The CAMS solar radiation services are described in [1]_.\n\n    Parameters\n    ----------\n    fbuf: file-like object\n        File-like object containing data to read.\n    integrated: boolean, default False\n        Whether to return radiation parameters as integrated values (Wh/m^2)\n        or as average irradiance values (W/m^2) (pvlib preferred units)\n    label: {'right', 'left'}, default: None\n        Which bin edge label to label time-step with. The default is 'left' for\n        all time steps except for '1M' which has a default of 'right'.\n    map_variables: bool, default: True\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n\n    Returns\n    -------\n    data: pandas.DataFrame\n        Timeseries data from CAMS Radiation or McClear\n    metadata: dict\n        Metadata available in the file.\n\n    See Also\n    --------\n    pvlib.iotools.read_cams, pvlib.iotools.get_cams\n\n    References\n    ----------\n    .. [1] `CAMS solar radiation documentation\n       <https://atmosphere.copernicus.eu/solar-radiation>`_\n    \"\"\"\n    metadata = {}\n    # Initial lines starting with # contain metadata\n    while True:\n        line = fbuf.readline().rstrip('\\n')\n        if line.startswith('# Observation period'):\n            # The last line of the metadata section contains the column names\n            names = line.lstrip('# ').split(';')\n            break  # End of metadata section has been reached\n        elif ': ' in line:\n            metadata[line.split(': ')[0].lstrip('# ')] = line.split(': ')[1]\n\n    # Convert latitude, longitude, and altitude values from strings to floats\n    for k_old in list(metadata.keys()):\n        k_new = k_old.lstrip().split(' ')[0].lower()\n        if k_new in ['latitude', 'longitude', 'altitude']:\n            metadata[k_new] = float(metadata.pop(k_old))\n\n    metadata['radiation_unit'] = \\\n        {True: 'Wh/m^2', False: 'W/m^2'}[integrated]\n\n    # Determine the time_step from the metadata dictionary\n    time_step = SUMMATION_PERIOD_TO_TIME_STEP[\n        metadata['Summarization (integration) period']]\n    metadata['time_step'] = time_step\n\n    data = pd.read_csv(fbuf, sep=';', comment='#', header=None, names=names)\n\n    obs_period = data['Observation period'].str.split('/')\n\n    # Set index as the start observation time (left) and localize to UTC\n    if (label == 'left') | ((label is None) & (time_step != '1M')):\n        data.index = pd.to_datetime(obs_period.str[0], utc=True)\n    # Set index as the stop observation time (right) and localize to UTC\n    # default label for monthly data is 'right' following Pandas' convention\n    elif (label == 'right') | ((label is None) & (time_step == '1M')):\n        data.index = pd.to_datetime(obs_period.str[1], utc=True)\n\n    # For time_steps '1d' and '1M', drop timezone and round to nearest midnight\n    if (time_step == '1d') | (time_step == '1M'):\n        data.index = pd.DatetimeIndex(data.index.date)\n    # For monthly data with 'right' label, the index should be the last\n    # date of the month and not the first date of the following month\n    if (time_step == '1M') & (label != 'left'):\n        data.index = data.index - pd.Timedelta(days=1)\n\n    if not integrated:  # Convert radiation values from Wh/m2 to W/m2\n        integrated_cols = [c for c in CAMS_INTEGRATED_COLUMNS\n                           if c in data.columns]\n\n        if time_step == '1M':\n            time_delta = (pd.to_datetime(obs_period.str[1])\n                          - pd.to_datetime(obs_period.str[0]))\n            hours = time_delta.dt.total_seconds()/60/60\n            data[integrated_cols] = data[integrated_cols].\\\n                divide(hours.tolist(), axis='rows')\n        else:\n            data[integrated_cols] = (data[integrated_cols] /\n                                     TIME_STEPS_IN_HOURS[time_step])\n    data.index.name = None  # Set index name to None\n    if map_variables:\n        data = data.rename(columns=VARIABLE_MAP)\n\n    return data, metadata\n", "tokens": ["pvlib", "iotools", "sodapro", "py", "def", "parse_cams", "fbuf", "integrated", "false", "label", "none", "map_variables", "true", "parse", "a", "file", "like", "buffer", "with", "data", "in", "the", "format", "of", "a", "cams", "radiation", "or", "mcclear", "file", "the", "cams", "solar", "radiation", "services", "are", "described", "in", "1", "_", "parameters", "fbuf", "file", "like", "object", "file", "like", "object", "containing", "data", "to", "read", "integrated", "boolean", "default", "false", "whether", "to", "return", "radiation", "parameters", "as", "integrated", "values", "wh", "m", "2", "or", "as", "average", "irradiance", "values", "w", "m", "2", "pvlib", "preferred", "units", "label", "right", "left", "default", "none", "which", "bin", "edge", "label", "to", "label", "time", "step", "with", "the", "default", "is", "left", "for", "all", "time", "steps", "except", "for", "1m", "which", "has", "a", "default", "of", "right", "map_variables", "bool", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "returns", "data", "pandas", "dataframe", "timeseries", "data", "from", "cams", "radiation", "or", "mcclear", "metadata", "dict", "metadata", "available", "in", "the", "file", "see", "also", "pvlib", "iotools", "read_cams", "pvlib", "iotools", "get_cams", "references", "1", "cams", "solar", "radiation", "documentation", "https", "atmosphere", "copernicus", "eu", "solar", "radiation", "_", "metadata", "initial", "lines", "starting", "with", "contain", "metadata", "while", "true", "line", "fbuf", "readline", "rstrip", "n", "if", "line", "startswith", "observation", "period", "the", "last", "line", "of", "the", "metadata", "section", "contains", "the", "column", "names", "names", "line", "lstrip", "split", "break", "end", "of", "metadata", "section", "has", "been", "reached", "elif", "in", "line", "metadata", "line", "split", "0", "lstrip", "line", "split", "1", "convert", "latitude", "longitude", "and", "altitude", "values", "from", "strings", "to", "floats", "for", "k_old", "in", "list", "metadata", "keys", "k_new", "k_old", "lstrip", "split", "0", "lower", "if", "k_new", "in", "latitude", "longitude", "altitude", "metadata", "k_new", "float", "metadata", "pop", "k_old", "metadata", "radiation_unit", "true", "wh", "m", "2", "false", "w", "m", "2", "integrated", "determine", "the", "time_step", "from", "the", "metadata", "dictionary", "time_step", "summation_period_to_time_step", "metadata", "summarization", "integration", "period", "metadata", "time_step", "time_step", "data", "pd", "read_csv", "fbuf", "sep", "comment", "header", "none", "names", "names", "obs_period", "data", "observation", "period", "str", "split", "set", "index", "as", "the", "start", "observation", "time", "left", "and", "localize", "to", "utc", "if", "label", "left", "label", "is", "none", "time_step", "1m", "data", "index", "pd", "to_datetime", "obs_period", "str", "0", "utc", "true", "set", "index", "as", "the", "stop", "observation", "time", "right", "and", "localize", "to", "utc", "default", "label", "for", "monthly", "data", "is", "right", "following", "pandas", "convention", "elif", "label", "right", "label", "is", "none", "time_step", "1m", "data", "index", "pd", "to_datetime", "obs_period", "str", "1", "utc", "true", "for", "time_steps", "1d", "and", "1m", "drop", "timezone", "and", "round", "to", "nearest", "midnight", "if", "time_step", "1d", "time_step", "1m", "data", "index", "pd", "datetimeindex", "data", "index", "date", "for", "monthly", "data", "with", "right", "label", "the", "index", "should", "be", "the", "last", "date", "of", "the", "month", "and", "not", "the", "first", "date", "of", "the", "following", "month", "if", "time_step", "1m", "label", "left", "data", "index", "data", "index", "pd", "timedelta", "days", "1", "if", "not", "integrated", "convert", "radiation", "values", "from", "wh", "m2", "to", "w", "m2", "integrated_cols", "c", "for", "c", "in", "cams_integrated_columns", "if", "c", "in", "data", "columns", "if", "time_step", "1m", "time_delta", "pd", "to_datetime", "obs_period", "str", "1", "pd", "to_datetime", "obs_period", "str", "0", "hours", "time_delta", "dt", "total_seconds", "60", "60", "data", "integrated_cols", "data", "integrated_cols", "divide", "hours", "tolist", "axis", "rows", "else", "data", "integrated_cols", "data", "integrated_cols", "time_steps_in_hours", "time_step", "data", "index", "name", "none", "set", "index", "name", "to", "none", "if", "map_variables", "data", "data", "rename", "columns", "variable_map", "return", "data", "metadata"], "doc_len": 507}
{"doc_id": "pvlib/iotools/sodapro.py::read_cams", "file_path": "pvlib/iotools/sodapro.py", "class_name": null, "func_name": "read_cams", "text": "文件路径: pvlib/iotools/sodapro.py\ndef read_cams(filename, integrated=False, label=None, map_variables=True):\n    \"\"\"\n    Read a CAMS Radiation or McClear file into a pandas DataFrame.\n\n    CAMS Radiation and McClear are described in [1]_.\n\n    Parameters\n    ----------\n    filename: str\n        Filename of a file containing data to read.\n    integrated: boolean, default False\n        Whether to return radiation parameters as integrated values (Wh/m^2)\n        or as average irradiance values (W/m^2) (pvlib preferred units)\n    label: {'right', 'left}, default: None\n        Which bin edge label to label time-step with. The default is 'left' for\n        all time steps except for '1M' which has a default of 'right'.\n    map_variables: bool, default: True\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable VARIABLE_MAP.\n\n    Returns\n    -------\n    data: pandas.DataFrame\n        Timeseries data from CAMS Radiation or McClear\n        :func:`pvlib.iotools.get_cams` for fields\n    metadata: dict\n        Metadata available in the file.\n\n    See Also\n    --------\n    pvlib.iotools.parse_cams, pvlib.iotools.get_cams\n\n    References\n    ----------\n    .. [1] `CAMS solar radiation documentation\n       <https://atmosphere.copernicus.eu/solar-radiation>`_\n    \"\"\"\n    with open(str(filename), 'r') as fbuf:\n        content = parse_cams(fbuf, integrated, label, map_variables)\n    return content\n", "tokens": ["pvlib", "iotools", "sodapro", "py", "def", "read_cams", "filename", "integrated", "false", "label", "none", "map_variables", "true", "read", "a", "cams", "radiation", "or", "mcclear", "file", "into", "a", "pandas", "dataframe", "cams", "radiation", "and", "mcclear", "are", "described", "in", "1", "_", "parameters", "filename", "str", "filename", "of", "a", "file", "containing", "data", "to", "read", "integrated", "boolean", "default", "false", "whether", "to", "return", "radiation", "parameters", "as", "integrated", "values", "wh", "m", "2", "or", "as", "average", "irradiance", "values", "w", "m", "2", "pvlib", "preferred", "units", "label", "right", "left", "default", "none", "which", "bin", "edge", "label", "to", "label", "time", "step", "with", "the", "default", "is", "left", "for", "all", "time", "steps", "except", "for", "1m", "which", "has", "a", "default", "of", "right", "map_variables", "bool", "default", "true", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "variable_map", "returns", "data", "pandas", "dataframe", "timeseries", "data", "from", "cams", "radiation", "or", "mcclear", "func", "pvlib", "iotools", "get_cams", "for", "fields", "metadata", "dict", "metadata", "available", "in", "the", "file", "see", "also", "pvlib", "iotools", "parse_cams", "pvlib", "iotools", "get_cams", "references", "1", "cams", "solar", "radiation", "documentation", "https", "atmosphere", "copernicus", "eu", "solar", "radiation", "_", "with", "open", "str", "filename", "r", "as", "fbuf", "content", "parse_cams", "fbuf", "integrated", "label", "map_variables", "return", "content"], "doc_len": 181}
{"doc_id": "pvlib/iotools/solrad.py::read_solrad", "file_path": "pvlib/iotools/solrad.py", "class_name": null, "func_name": "read_solrad", "text": "文件路径: pvlib/iotools/solrad.py\ndef read_solrad(filename):\n    \"\"\"\n    Read NOAA SOLRAD fixed-width file into pandas dataframe.  The SOLRAD\n    network is described in [1]_ and [2]_.\n\n    Parameters\n    ----------\n    filename: str\n        filepath or url to read for the fixed-width file.\n\n    Returns\n    -------\n    data: Dataframe\n        A dataframe with DatetimeIndex and all of the variables in the\n        file.\n\n    Notes\n    -----\n    SOLRAD data resolution is described by the README_SOLRAD.txt:\n    \"Before 1-jan. 2015 the data were reported as 3-min averages;\n    on and after 1-Jan. 2015, SOLRAD data are reported as 1-min.\n    averages of 1-sec. samples.\"\n    Here, missing data is flagged as NaN, rather than -9999.9.\n\n    References\n    ----------\n    .. [1] NOAA SOLRAD Network\n       `https://www.esrl.noaa.gov/gmd/grad/solrad/index.html\n       <https://www.esrl.noaa.gov/gmd/grad/solrad/index.html>`_\n\n    .. [2] B. B. Hicks et. al., (1996), The NOAA Integrated Surface\n       Irradiance Study (ISIS). A New Surface Radiation Monitoring\n       Program. Bull. Amer. Meteor. Soc., 77, 2857-2864.\n       :doi:`10.1175/1520-0477(1996)077<2857:TNISIS>2.0.CO;2`\n    \"\"\"\n    if 'msn' in str(filename):\n        names = MADISON_HEADERS\n        widths = MADISON_WIDTHS\n        dtypes = MADISON_DTYPES\n    else:\n        names = HEADERS\n        widths = WIDTHS\n        dtypes = DTYPES\n\n    # read in data\n    data = pd.read_fwf(filename, header=None, skiprows=2, names=names,\n                       widths=widths, na_values=-9999.9)\n\n    # loop here because dtype kwarg not supported in read_fwf until 0.20\n    for (col, _dtype) in zip(data.columns, dtypes):\n        ser = data[col].astype(_dtype)\n        if _dtype == 'float64':\n            # older verions of pandas/numpy read '-9999.9' as\n            # -9999.8999999999996 and fail to set nan in read_fwf,\n            # so manually set nan\n            ser = ser.where(ser > -9999, other=np.nan)\n        data[col] = ser\n\n    # set index\n    # columns do not have leading 0s, so must zfill(2) to comply\n    # with %m%d%H%M format\n    dts = data[['month', 'day', 'hour', 'minute']].astype(str).apply(\n        lambda x: x.str.zfill(2))\n    dtindex = pd.to_datetime(\n        data['year'].astype(str) + dts['month'] + dts['day'] + dts['hour'] +\n        dts['minute'], format='%Y%m%d%H%M', utc=True)\n    data = data.set_index(dtindex)\n    try:\n        # to_datetime(utc=True) does not work in older versions of pandas\n        data = data.tz_localize('UTC')\n    except TypeError:\n        pass\n\n    return data\n", "tokens": ["pvlib", "iotools", "solrad", "py", "def", "read_solrad", "filename", "read", "noaa", "solrad", "fixed", "width", "file", "into", "pandas", "dataframe", "the", "solrad", "network", "is", "described", "in", "1", "_", "and", "2", "_", "parameters", "filename", "str", "filepath", "or", "url", "to", "read", "for", "the", "fixed", "width", "file", "returns", "data", "dataframe", "a", "dataframe", "with", "datetimeindex", "and", "all", "of", "the", "variables", "in", "the", "file", "notes", "solrad", "data", "resolution", "is", "described", "by", "the", "readme_solrad", "txt", "before", "1", "jan", "2015", "the", "data", "were", "reported", "as", "3", "min", "averages", "on", "and", "after", "1", "jan", "2015", "solrad", "data", "are", "reported", "as", "1", "min", "averages", "of", "1", "sec", "samples", "here", "missing", "data", "is", "flagged", "as", "nan", "rather", "than", "9999", "9", "references", "1", "noaa", "solrad", "network", "https", "www", "esrl", "noaa", "gov", "gmd", "grad", "solrad", "index", "html", "https", "www", "esrl", "noaa", "gov", "gmd", "grad", "solrad", "index", "html", "_", "2", "b", "b", "hicks", "et", "al", "1996", "the", "noaa", "integrated", "surface", "irradiance", "study", "isis", "a", "new", "surface", "radiation", "monitoring", "program", "bull", "amer", "meteor", "soc", "77", "2857", "2864", "doi", "10", "1175", "1520", "0477", "1996", "077", "2857", "tnisis", "2", "0", "co", "2", "if", "msn", "in", "str", "filename", "names", "madison_headers", "widths", "madison_widths", "dtypes", "madison_dtypes", "else", "names", "headers", "widths", "widths", "dtypes", "dtypes", "read", "in", "data", "data", "pd", "read_fwf", "filename", "header", "none", "skiprows", "2", "names", "names", "widths", "widths", "na_values", "9999", "9", "loop", "here", "because", "dtype", "kwarg", "not", "supported", "in", "read_fwf", "until", "0", "20", "for", "col", "_dtype", "in", "zip", "data", "columns", "dtypes", "ser", "data", "col", "astype", "_dtype", "if", "_dtype", "float64", "older", "verions", "of", "pandas", "numpy", "read", "9999", "9", "as", "9999", "8999999999996", "and", "fail", "to", "set", "nan", "in", "read_fwf", "so", "manually", "set", "nan", "ser", "ser", "where", "ser", "9999", "other", "np", "nan", "data", "col", "ser", "set", "index", "columns", "do", "not", "have", "leading", "0s", "so", "must", "zfill", "2", "to", "comply", "with", "m", "d", "h", "m", "format", "dts", "data", "month", "day", "hour", "minute", "astype", "str", "apply", "lambda", "x", "x", "str", "zfill", "2", "dtindex", "pd", "to_datetime", "data", "year", "astype", "str", "dts", "month", "dts", "day", "dts", "hour", "dts", "minute", "format", "y", "m", "d", "h", "m", "utc", "true", "data", "data", "set_index", "dtindex", "try", "to_datetime", "utc", "true", "does", "not", "work", "in", "older", "versions", "of", "pandas", "data", "data", "tz_localize", "utc", "except", "typeerror", "pass", "return", "data"], "doc_len": 352}
{"doc_id": "pvlib/iotools/srml.py::read_srml", "file_path": "pvlib/iotools/srml.py", "class_name": null, "func_name": "read_srml", "text": "文件路径: pvlib/iotools/srml.py\ndef read_srml(filename):\n    \"\"\"\n    Read University of Oregon SRML 1min .tsv file into pandas dataframe.  The\n    SRML is described in [1]_.\n\n    Parameters\n    ----------\n    filename: str\n        filepath or url to read for the tsv file.\n\n    Returns\n    -------\n    data: Dataframe\n        A dataframe with datetime index and all of the variables listed\n        in the `VARIABLE_MAP` dict inside of the map_columns function,\n        along with their associated quality control flags.\n\n    Notes\n    -----\n    The time index is shifted back by one interval to account for the\n    daily endtime of 2400, and to avoid time parsing errors on leap\n    years. The returned data values are labeled by the left endpoint of\n    interval, and should be understood to occur during the interval from\n    the time of the row until the time of the next row. This is consistent\n    with pandas' default labeling behavior.\n\n    See SRML's `Archival Files`_ page for more information.\n\n    .. _Archival Files: http://solardat.uoregon.edu/ArchivalFiles.html\n\n    References\n    ----------\n    .. [1] University of Oregon Solar Radiation Monitoring Laboratory\n       `http://solardat.uoregon.edu/ <http://solardat.uoregon.edu/>`_\n    \"\"\"\n    tsv_data = pd.read_csv(filename, delimiter='\\t')\n    data = format_index(tsv_data)\n    # Drop day of year and time columns\n    data = data[data.columns[2:]]\n\n    data = data.rename(columns=map_columns)\n\n    # Quality flag columns are all labeled 0 in the original data. They\n    # appear immediately after their associated variable and are suffixed\n    # with an integer value when read from the file. So we map flags to\n    # the preceding variable with a '_flag' suffix.\n    #\n    # Example:\n    #   Columns ['ghi_0', '0.1', 'temp_air_2', '0.2']\n    #\n    #   Yields a flag_label_map of:\n    #       { '0.1': 'ghi_0_flag',\n    #         '0.2': 'temp_air_2'}\n    #\n    columns = data.columns\n    flag_label_map = {flag: columns[columns.get_loc(flag) - 1] + '_flag'\n                      for flag in columns[1::2]}\n    data = data.rename(columns=flag_label_map)\n\n    # Mask data marked with quality flag 99 (bad or missing data)\n    for col in columns[::2]:\n        missing = data[col + '_flag'] == 99\n        data[col] = data[col].where(~(missing), np.NaN)\n    return data\n", "tokens": ["pvlib", "iotools", "srml", "py", "def", "read_srml", "filename", "read", "university", "of", "oregon", "srml", "1min", "tsv", "file", "into", "pandas", "dataframe", "the", "srml", "is", "described", "in", "1", "_", "parameters", "filename", "str", "filepath", "or", "url", "to", "read", "for", "the", "tsv", "file", "returns", "data", "dataframe", "a", "dataframe", "with", "datetime", "index", "and", "all", "of", "the", "variables", "listed", "in", "the", "variable_map", "dict", "inside", "of", "the", "map_columns", "function", "along", "with", "their", "associated", "quality", "control", "flags", "notes", "the", "time", "index", "is", "shifted", "back", "by", "one", "interval", "to", "account", "for", "the", "daily", "endtime", "of", "2400", "and", "to", "avoid", "time", "parsing", "errors", "on", "leap", "years", "the", "returned", "data", "values", "are", "labeled", "by", "the", "left", "endpoint", "of", "interval", "and", "should", "be", "understood", "to", "occur", "during", "the", "interval", "from", "the", "time", "of", "the", "row", "until", "the", "time", "of", "the", "next", "row", "this", "is", "consistent", "with", "pandas", "default", "labeling", "behavior", "see", "srml", "s", "archival", "files", "_", "page", "for", "more", "information", "_archival", "files", "http", "solardat", "uoregon", "edu", "archivalfiles", "html", "references", "1", "university", "of", "oregon", "solar", "radiation", "monitoring", "laboratory", "http", "solardat", "uoregon", "edu", "http", "solardat", "uoregon", "edu", "_", "tsv_data", "pd", "read_csv", "filename", "delimiter", "t", "data", "format_index", "tsv_data", "drop", "day", "of", "year", "and", "time", "columns", "data", "data", "data", "columns", "2", "data", "data", "rename", "columns", "map_columns", "quality", "flag", "columns", "are", "all", "labeled", "0", "in", "the", "original", "data", "they", "appear", "immediately", "after", "their", "associated", "variable", "and", "are", "suffixed", "with", "an", "integer", "value", "when", "read", "from", "the", "file", "so", "we", "map", "flags", "to", "the", "preceding", "variable", "with", "a", "_flag", "suffix", "example", "columns", "ghi_0", "0", "1", "temp_air_2", "0", "2", "yields", "a", "flag_label_map", "of", "0", "1", "ghi_0_flag", "0", "2", "temp_air_2", "columns", "data", "columns", "flag_label_map", "flag", "columns", "columns", "get_loc", "flag", "1", "_flag", "for", "flag", "in", "columns", "1", "2", "data", "data", "rename", "columns", "flag_label_map", "mask", "data", "marked", "with", "quality", "flag", "99", "bad", "or", "missing", "data", "for", "col", "in", "columns", "2", "missing", "data", "col", "_flag", "99", "data", "col", "data", "col", "where", "missing", "np", "nan", "return", "data"], "doc_len": 311}
{"doc_id": "pvlib/iotools/srml.py::map_columns", "file_path": "pvlib/iotools/srml.py", "class_name": null, "func_name": "map_columns", "text": "文件路径: pvlib/iotools/srml.py\ndef map_columns(col):\n    \"\"\"Map data element numbers to pvlib names.\n\n    Parameters\n    ----------\n    col: str\n        Column label to be mapped.\n\n    Returns\n    -------\n    str\n        The pvlib label if it was found in the mapping,\n        else the original label.\n    \"\"\"\n    if col.startswith('7'):\n        # spectral data\n        try:\n            return VARIABLE_MAP[col]\n        except KeyError:\n            return col\n    try:\n        variable_name = VARIABLE_MAP[col[:3]]\n        variable_number = col[3:]\n        return variable_name + '_' + variable_number\n    except KeyError:\n        return col\n", "tokens": ["pvlib", "iotools", "srml", "py", "def", "map_columns", "col", "map", "data", "element", "numbers", "to", "pvlib", "names", "parameters", "col", "str", "column", "label", "to", "be", "mapped", "returns", "str", "the", "pvlib", "label", "if", "it", "was", "found", "in", "the", "mapping", "else", "the", "original", "label", "if", "col", "startswith", "7", "spectral", "data", "try", "return", "variable_map", "col", "except", "keyerror", "return", "col", "try", "variable_name", "variable_map", "col", "3", "variable_number", "col", "3", "return", "variable_name", "_", "variable_number", "except", "keyerror", "return", "col"], "doc_len": 68}
{"doc_id": "pvlib/iotools/srml.py::format_index", "file_path": "pvlib/iotools/srml.py", "class_name": null, "func_name": "format_index", "text": "文件路径: pvlib/iotools/srml.py\ndef format_index(df):\n    \"\"\"Create a datetime index from day of year, and time columns.\n\n    Parameters\n    ----------\n    df: pd.Dataframe\n        The srml data to reindex.\n\n    Returns\n    -------\n    df: pd.Dataframe\n        The Dataframe with a DatetimeIndex localized to 'Etc/GMT+8'.\n    \"\"\"\n    # Name of the second column indicates the year of the file, but\n    # the column contains times.\n    year = int(df.columns[1])\n    df_doy = df[df.columns[0]]\n    # Times are expressed as integers from 1-2400, we convert to 0-2359 by\n    # subracting the length of one interval and then correcting the times\n    # at each former hour. interval_length is determined by taking the\n    # difference of the first two rows of the time column.\n    # e.g. The first two rows of hourly data are 100 and 200\n    #      so interval_length is 100.\n    interval_length = df[df.columns[1]][1] - df[df.columns[1]][0]\n    df_time = df[df.columns[1]] - interval_length\n    if interval_length == 100:\n        # Hourly files do not require fixing the former hour timestamps.\n        times = df_time\n    else:\n        # Because hours are represented by some multiple of 100, shifting\n        # results in invalid values.\n        #\n        # e.g. 200 (for 02:00) shifted by 15 minutes becomes 185, the\n        #      desired result is 145 (for 01:45)\n        #\n        # So we find all times with minutes greater than 60 and remove 40\n        # to correct to valid times.\n        old_hours = df_time % 100 > 60\n        times = df_time.where(~old_hours, df_time - 40)\n    times = times.apply(lambda x: '{:04.0f}'.format(x))\n    doy = df_doy.apply(lambda x: '{:03.0f}'.format(x))\n    dts = pd.to_datetime(str(year) + '-' + doy + '-' + times,\n                         format='%Y-%j-%H%M')\n    df.index = dts\n    df = df.tz_localize('Etc/GMT+8')\n    return df\n", "tokens": ["pvlib", "iotools", "srml", "py", "def", "format_index", "df", "create", "a", "datetime", "index", "from", "day", "of", "year", "and", "time", "columns", "parameters", "df", "pd", "dataframe", "the", "srml", "data", "to", "reindex", "returns", "df", "pd", "dataframe", "the", "dataframe", "with", "a", "datetimeindex", "localized", "to", "etc", "gmt", "8", "name", "of", "the", "second", "column", "indicates", "the", "year", "of", "the", "file", "but", "the", "column", "contains", "times", "year", "int", "df", "columns", "1", "df_doy", "df", "df", "columns", "0", "times", "are", "expressed", "as", "integers", "from", "1", "2400", "we", "convert", "to", "0", "2359", "by", "subracting", "the", "length", "of", "one", "interval", "and", "then", "correcting", "the", "times", "at", "each", "former", "hour", "interval_length", "is", "determined", "by", "taking", "the", "difference", "of", "the", "first", "two", "rows", "of", "the", "time", "column", "e", "g", "the", "first", "two", "rows", "of", "hourly", "data", "are", "100", "and", "200", "so", "interval_length", "is", "100", "interval_length", "df", "df", "columns", "1", "1", "df", "df", "columns", "1", "0", "df_time", "df", "df", "columns", "1", "interval_length", "if", "interval_length", "100", "hourly", "files", "do", "not", "require", "fixing", "the", "former", "hour", "timestamps", "times", "df_time", "else", "because", "hours", "are", "represented", "by", "some", "multiple", "of", "100", "shifting", "results", "in", "invalid", "values", "e", "g", "200", "for", "02", "00", "shifted", "by", "15", "minutes", "becomes", "185", "the", "desired", "result", "is", "145", "for", "01", "45", "so", "we", "find", "all", "times", "with", "minutes", "greater", "than", "60", "and", "remove", "40", "to", "correct", "to", "valid", "times", "old_hours", "df_time", "100", "60", "times", "df_time", "where", "old_hours", "df_time", "40", "times", "times", "apply", "lambda", "x", "04", "0f", "format", "x", "doy", "df_doy", "apply", "lambda", "x", "03", "0f", "format", "x", "dts", "pd", "to_datetime", "str", "year", "doy", "times", "format", "y", "j", "h", "m", "df", "index", "dts", "df", "df", "tz_localize", "etc", "gmt", "8", "return", "df"], "doc_len": 265}
{"doc_id": "pvlib/iotools/srml.py::read_srml_month_from_solardat", "file_path": "pvlib/iotools/srml.py", "class_name": null, "func_name": "read_srml_month_from_solardat", "text": "文件路径: pvlib/iotools/srml.py\ndef read_srml_month_from_solardat(station, year, month, filetype='PO'):\n    \"\"\"Request a month of SRML data from solardat and read it into\n    a Dataframe.  The SRML is described in [1]_.\n\n    Parameters\n    ----------\n    station: str\n        The name of the SRML station to request.\n    year: int\n        Year to request data for\n    month: int\n        Month to request data for.\n    filetype: string\n        SRML file type to gather. See notes for explanation.\n\n    Returns\n    -------\n    data: pd.DataFrame\n        One month of data from SRML.\n\n    Notes\n    -----\n    File types designate the time interval of a file and if it contains\n    raw or processed data. For instance, `RO` designates raw, one minute\n    data and `PO` designates processed one minute data. The availability\n    of file types varies between sites. Below is a table of file types\n    and their time intervals. See [1] for site information.\n\n    ============= ============ ==================\n    time interval raw filetype processed filetype\n    ============= ============ ==================\n    1 minute      RO           PO\n    5 minute      RF           PF\n    15 minute     RQ           PQ\n    hourly        RH           PH\n    ============= ============ ==================\n\n    References\n    ----------\n    .. [1] University of Oregon Solar Radiation Measurement Laboratory\n       `http://solardat.uoregon.edu/ <http://solardat.uoregon.edu/>`_\n    \"\"\"\n    file_name = \"{station}{filetype}{year:02d}{month:02d}.txt\".format(\n        station=station,\n        filetype=filetype,\n        year=year % 100,\n        month=month)\n    url = \"http://solardat.uoregon.edu/download/Archive/\"\n    data = read_srml(url + file_name)\n    return data\n", "tokens": ["pvlib", "iotools", "srml", "py", "def", "read_srml_month_from_solardat", "station", "year", "month", "filetype", "po", "request", "a", "month", "of", "srml", "data", "from", "solardat", "and", "read", "it", "into", "a", "dataframe", "the", "srml", "is", "described", "in", "1", "_", "parameters", "station", "str", "the", "name", "of", "the", "srml", "station", "to", "request", "year", "int", "year", "to", "request", "data", "for", "month", "int", "month", "to", "request", "data", "for", "filetype", "string", "srml", "file", "type", "to", "gather", "see", "notes", "for", "explanation", "returns", "data", "pd", "dataframe", "one", "month", "of", "data", "from", "srml", "notes", "file", "types", "designate", "the", "time", "interval", "of", "a", "file", "and", "if", "it", "contains", "raw", "or", "processed", "data", "for", "instance", "ro", "designates", "raw", "one", "minute", "data", "and", "po", "designates", "processed", "one", "minute", "data", "the", "availability", "of", "file", "types", "varies", "between", "sites", "below", "is", "a", "table", "of", "file", "types", "and", "their", "time", "intervals", "see", "1", "for", "site", "information", "time", "interval", "raw", "filetype", "processed", "filetype", "1", "minute", "ro", "po", "5", "minute", "rf", "pf", "15", "minute", "rq", "pq", "hourly", "rh", "ph", "references", "1", "university", "of", "oregon", "solar", "radiation", "measurement", "laboratory", "http", "solardat", "uoregon", "edu", "http", "solardat", "uoregon", "edu", "_", "file_name", "station", "filetype", "year", "02d", "month", "02d", "txt", "format", "station", "station", "filetype", "filetype", "year", "year", "100", "month", "month", "url", "http", "solardat", "uoregon", "edu", "download", "archive", "data", "read_srml", "url", "file_name", "return", "data"], "doc_len": 205}
{"doc_id": "pvlib/iotools/surfrad.py::read_surfrad", "file_path": "pvlib/iotools/surfrad.py", "class_name": null, "func_name": "read_surfrad", "text": "文件路径: pvlib/iotools/surfrad.py\ndef read_surfrad(filename, map_variables=True):\n    \"\"\"Read in a daily NOAA SURFRAD file.  The SURFRAD network is\n    described in [1]_.\n\n    Parameters\n    ----------\n    filename: str\n        Filepath or URL. URL can be either FTP or HTTP.\n    map_variables: bool\n        When true, renames columns of the Dataframe to pvlib variable names\n        where applicable. See variable :const:`VARIABLE_MAP`.\n\n    Returns\n    -------\n    Tuple of the form (data, metadata).\n\n    data: Dataframe\n        Dataframe with the fields found below.\n    metadata: dict\n        Site metadata included in the file.\n\n    Notes\n    -----\n    Metadata dictionary includes the following fields:\n\n    ===============  ======  ===============\n    Key              Format  Description\n    ===============  ======  ===============\n    station          String  site name\n    latitude         Float   site latitude\n    longitude        Float   site longitude\n    elevation        Int     site elevation\n    surfrad_version  Int     surfrad version\n    tz               String  Timezone (UTC)\n    ===============  ======  ===============\n\n    Dataframe includes the following fields:\n\n    =======================  ======  ==========================================\n    raw, mapped              Format  Description\n    =======================  ======  ==========================================\n    **Mapped field names are returned when the map_variables argument is True**\n    ---------------------------------------------------------------------------\n    year                     int     year as 4 digit int\n    jday                     int     day of year 1-365(or 366)\n    month                    int     month (1-12)\n    day                      int     day of month(1-31)\n    hour                     int     hour (0-23)\n    minute                   int     minute (0-59)\n    dt                       float   decimal time i.e. 23.5 = 2330\n    zen, solar_zenith        float   solar zenith angle (deg)\n    **Fields below have associated qc flags labeled <field>_flag.**\n    ---------------------------------------------------------------------------\n    dw_solar, ghi            float   downwelling global solar(W/m^2)\n    uw_solar                 float   updownwelling global solar(W/m^2)\n    direct_n, dni            float   direct normal solar (W/m^2)\n    diffuse, dhi             float   downwelling diffuse solar (W/m^2)\n    dw_ir                    float   downwelling thermal infrared (W/m^2)\n    dw_casetemp              float   downwelling IR case temp (K)\n    dw_dometemp              float   downwelling IR dome temp (K)\n    uw_ir                    float   upwelling thermal infrared (W/m^2)\n    uw_casetemp              float   upwelling IR case temp (K)\n    uw_dometemp              float   upwelling IR case temp (K)\n    uvb                      float   global uvb (miliWatts/m^2)\n    par                      float   photosynthetically active radiation(W/m^2)\n    netsolar                 float   net solar (dw_solar - uw_solar) (W/m^2)\n    netir                    float   net infrared (dw_ir - uw_ir) (W/m^2)\n    totalnet                 float   net radiation (netsolar+netir) (W/m^2)\n    temp, temp_air           float   10-meter air temperature (?C)\n    rh, relative_humidity    float   relative humidity (%)\n    windspd, wind_speed      float   wind speed (m/s)\n    winddir, wind_direction  float   wind direction (deg, clockwise from north)\n    pressure                 float   station pressure (mb)\n    =======================  ======  ==========================================\n\n    See README files located in the station directories in the SURFRAD\n    data archives [2]_ for details on SURFRAD daily data files. In addition to\n    the FTP server, the SURFRAD files are also available via HTTP access [3]_.\n\n    References\n    ----------\n    .. [1] NOAA Earth System Research Laboratory Surface Radiation Budget\n       Network\n       `SURFRAD Homepage <https://www.esrl.noaa.gov/gmd/grad/surfrad/>`_\n    .. [2] NOAA SURFRAD Data Archive\n       `SURFRAD Archive <ftp://aftp.cmdl.noaa.gov/data/radiation/surfrad/>`_\n    .. [3] `NOAA SURFRAD HTTP Index\n       <https://gml.noaa.gov/aftp/data/radiation/surfrad/>`_\n    \"\"\"\n    if str(filename).startswith('ftp') or str(filename).startswith('http'):\n        req = Request(filename)\n        response = urlopen(req)\n        file_buffer = io.StringIO(response.read().decode(errors='ignore'))\n    else:\n        file_buffer = open(str(filename), 'r')\n\n    # Read and parse the first two lines to build the metadata dict.\n    station = file_buffer.readline()\n    file_metadata = file_buffer.readline()\n\n    metadata_list = file_metadata.split()\n    metadata = {}\n    metadata['name'] = station.strip()\n    metadata['latitude'] = float(metadata_list[0])\n    metadata['longitude'] = float(metadata_list[1])\n    metadata['elevation'] = float(metadata_list[2])\n    metadata['surfrad_version'] = int(metadata_list[-1])\n    metadata['tz'] = 'UTC'\n\n    data = pd.read_csv(file_buffer, delim_whitespace=True,\n                       header=None, names=SURFRAD_COLUMNS)\n    file_buffer.close()\n\n    data = format_index(data)\n    missing = data == -9999.9\n    data = data.where(~missing, np.NaN)\n\n    if map_variables:\n        data.rename(columns=VARIABLE_MAP, inplace=True)\n    return data, metadata\n", "tokens": ["pvlib", "iotools", "surfrad", "py", "def", "read_surfrad", "filename", "map_variables", "true", "read", "in", "a", "daily", "noaa", "surfrad", "file", "the", "surfrad", "network", "is", "described", "in", "1", "_", "parameters", "filename", "str", "filepath", "or", "url", "url", "can", "be", "either", "ftp", "or", "http", "map_variables", "bool", "when", "true", "renames", "columns", "of", "the", "dataframe", "to", "pvlib", "variable", "names", "where", "applicable", "see", "variable", "const", "variable_map", "returns", "tuple", "of", "the", "form", "data", "metadata", "data", "dataframe", "dataframe", "with", "the", "fields", "found", "below", "metadata", "dict", "site", "metadata", "included", "in", "the", "file", "notes", "metadata", "dictionary", "includes", "the", "following", "fields", "key", "format", "description", "station", "string", "site", "name", "latitude", "float", "site", "latitude", "longitude", "float", "site", "longitude", "elevation", "int", "site", "elevation", "surfrad_version", "int", "surfrad", "version", "tz", "string", "timezone", "utc", "dataframe", "includes", "the", "following", "fields", "raw", "mapped", "format", "description", "mapped", "field", "names", "are", "returned", "when", "the", "map_variables", "argument", "is", "true", "year", "int", "year", "as", "4", "digit", "int", "jday", "int", "day", "of", "year", "1", "365", "or", "366", "month", "int", "month", "1", "12", "day", "int", "day", "of", "month", "1", "31", "hour", "int", "hour", "0", "23", "minute", "int", "minute", "0", "59", "dt", "float", "decimal", "time", "i", "e", "23", "5", "2330", "zen", "solar_zenith", "float", "solar", "zenith", "angle", "deg", "fields", "below", "have", "associated", "qc", "flags", "labeled", "field", "_flag", "dw_solar", "ghi", "float", "downwelling", "global", "solar", "w", "m", "2", "uw_solar", "float", "updownwelling", "global", "solar", "w", "m", "2", "direct_n", "dni", "float", "direct", "normal", "solar", "w", "m", "2", "diffuse", "dhi", "float", "downwelling", "diffuse", "solar", "w", "m", "2", "dw_ir", "float", "downwelling", "thermal", "infrared", "w", "m", "2", "dw_casetemp", "float", "downwelling", "ir", "case", "temp", "k", "dw_dometemp", "float", "downwelling", "ir", "dome", "temp", "k", "uw_ir", "float", "upwelling", "thermal", "infrared", "w", "m", "2", "uw_casetemp", "float", "upwelling", "ir", "case", "temp", "k", "uw_dometemp", "float", "upwelling", "ir", "case", "temp", "k", "uvb", "float", "global", "uvb", "miliwatts", "m", "2", "par", "float", "photosynthetically", "active", "radiation", "w", "m", "2", "netsolar", "float", "net", "solar", "dw_solar", "uw_solar", "w", "m", "2", "netir", "float", "net", "infrared", "dw_ir", "uw_ir", "w", "m", "2", "totalnet", "float", "net", "radiation", "netsolar", "netir", "w", "m", "2", "temp", "temp_air", "float", "10", "meter", "air", "temperature", "c", "rh", "relative_humidity", "float", "relative", "humidity", "windspd", "wind_speed", "float", "wind", "speed", "m", "s", "winddir", "wind_direction", "float", "wind", "direction", "deg", "clockwise", "from", "north", "pressure", "float", "station", "pressure", "mb", "see", "readme", "files", "located", "in", "the", "station", "directories", "in", "the", "surfrad", "data", "archives", "2", "_", "for", "details", "on", "surfrad", "daily", "data", "files", "in", "addition", "to", "the", "ftp", "server", "the", "surfrad", "files", "are", "also", "available", "via", "http", "access", "3", "_", "references", "1", "noaa", "earth", "system", "research", "laboratory", "surface", "radiation", "budget", "network", "surfrad", "homepage", "https", "www", "esrl", "noaa", "gov", "gmd", "grad", "surfrad", "_", "2", "noaa", "surfrad", "data", "archive", "surfrad", "archive", "ftp", "aftp", "cmdl", "noaa", "gov", "data", "radiation", "surfrad", "_", "3", "noaa", "surfrad", "http", "index", "https", "gml", "noaa", "gov", "aftp", "data", "radiation", "surfrad", "_", "if", "str", "filename", "startswith", "ftp", "or", "str", "filename", "startswith", "http", "req", "request", "filename", "response", "urlopen", "req", "file_buffer", "io", "stringio", "response", "read", "decode", "errors", "ignore", "else", "file_buffer", "open", "str", "filename", "r", "read", "and", "parse", "the", "first", "two", "lines", "to", "build", "the", "metadata", "dict", "station", "file_buffer", "readline", "file_metadata", "file_buffer", "readline", "metadata_list", "file_metadata", "split", "metadata", "metadata", "name", "station", "strip", "metadata", "latitude", "float", "metadata_list", "0", "metadata", "longitude", "float", "metadata_list", "1", "metadata", "elevation", "float", "metadata_list", "2", "metadata", "surfrad_version", "int", "metadata_list", "1", "metadata", "tz", "utc", "data", "pd", "read_csv", "file_buffer", "delim_whitespace", "true", "header", "none", "names", "surfrad_columns", "file_buffer", "close", "data", "format_index", "data", "missing", "data", "9999", "9", "data", "data", "where", "missing", "np", "nan", "if", "map_variables", "data", "rename", "columns", "variable_map", "inplace", "true", "return", "data", "metadata"], "doc_len": 557}
{"doc_id": "pvlib/iotools/surfrad.py::format_index", "file_path": "pvlib/iotools/surfrad.py", "class_name": null, "func_name": "format_index", "text": "文件路径: pvlib/iotools/surfrad.py\ndef format_index(data):\n    \"\"\"Create UTC localized DatetimeIndex for the dataframe.\n\n    Parameters\n    ----------\n    data: Dataframe\n        Must contain columns 'year', 'jday', 'hour' and\n        'minute'.\n\n    Return\n    ------\n    data: Dataframe\n        Dataframe with a DatetimeIndex localized to UTC.\n    \"\"\"\n    year = data.year.apply(str)\n    jday = data.jday.apply(lambda x: '{:03d}'.format(x))\n    hours = data.hour.apply(lambda x: '{:02d}'.format(x))\n    minutes = data.minute.apply(lambda x: '{:02d}'.format(x))\n    index = pd.to_datetime(year + jday + hours + minutes, format=\"%Y%j%H%M\")\n    data.index = index\n    data = data.tz_localize('UTC')\n    return data\n", "tokens": ["pvlib", "iotools", "surfrad", "py", "def", "format_index", "data", "create", "utc", "localized", "datetimeindex", "for", "the", "dataframe", "parameters", "data", "dataframe", "must", "contain", "columns", "year", "jday", "hour", "and", "minute", "return", "data", "dataframe", "dataframe", "with", "a", "datetimeindex", "localized", "to", "utc", "year", "data", "year", "apply", "str", "jday", "data", "jday", "apply", "lambda", "x", "03d", "format", "x", "hours", "data", "hour", "apply", "lambda", "x", "02d", "format", "x", "minutes", "data", "minute", "apply", "lambda", "x", "02d", "format", "x", "index", "pd", "to_datetime", "year", "jday", "hours", "minutes", "format", "y", "j", "h", "m", "data", "index", "index", "data", "data", "tz_localize", "utc", "return", "data"], "doc_len": 88}
{"doc_id": "pvlib/iotools/tmy.py::read_tmy3", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "read_tmy3", "text": "文件路径: pvlib/iotools/tmy.py\ndef read_tmy3(filename, coerce_year=None, recolumn=True):\n    \"\"\"Read a TMY3 file into a pandas dataframe.\n\n    Note that values contained in the metadata dictionary are unchanged\n    from the TMY3 file (i.e. units are retained). In the case of any\n    discrepancies between this documentation and the TMY3 User's Manual\n    [1]_, the TMY3 User's Manual takes precedence.\n\n    The TMY3 files were updated in Jan. 2015. This function requires the\n    use of the updated files.\n\n    Parameters\n    ----------\n    filename : str\n        A relative file path or absolute file path.\n    coerce_year : None or int, default None\n        If supplied, the year of the index will be set to `coerce_year`, except\n        for the last index value which will be set to the *next* year so that\n        the index increases monotonically.\n    recolumn : bool, default True\n        If ``True``, apply standard names to TMY3 columns. Typically this\n        results in stripping the units from the column name.\n\n    Returns\n    -------\n    Tuple of the form (data, metadata).\n\n    data : DataFrame\n        A pandas dataframe with the columns described in the table\n        below. For more detailed descriptions of each component, please\n        consult the TMY3 User's Manual ([1]_), especially tables 1-1\n        through 1-6.\n\n    metadata : dict\n        The site metadata available in the file.\n\n    Notes\n    -----\n    The returned structures have the following fields.\n\n    ===============   ======  ===================\n    key               format  description\n    ===============   ======  ===================\n    altitude          Float   site elevation\n    latitude          Float   site latitudeitude\n    longitude         Float   site longitudeitude\n    Name              String  site name\n    State             String  state\n    TZ                Float   UTC offset\n    USAF              Int     USAF identifier\n    ===============   ======  ===================\n\n    =====================       ======================================================================================================================================================\n    field                       description\n    =====================       ======================================================================================================================================================\n    Index                       A pandas datetime index. NOTE, the index is timezone aware, and times are set to local standard time (daylight savings is not included)\n    ETR                         Extraterrestrial horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    ETRN                        Extraterrestrial normal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    GHI                         Direct and diffuse horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    GHISource                   See [1]_, Table 1-4\n    GHIUncertainty              Uncertainty based on random and bias error estimates see [2]_\n    DNI                         Amount of direct normal radiation (modeled) recv'd during 60 mintues prior to timestamp, Wh/m^2\n    DNISource                   See [1]_, Table 1-4\n    DNIUncertainty              Uncertainty based on random and bias error estimates see [2]_\n    DHI                         Amount of diffuse horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    DHISource                   See [1]_, Table 1-4\n    DHIUncertainty              Uncertainty based on random and bias error estimates see [2]_\n    GHillum                     Avg. total horizontal illuminance recv'd during the 60 minutes prior to timestamp, lx\n    GHillumSource               See [1]_, Table 1-4\n    GHillumUncertainty          Uncertainty based on random and bias error estimates see [2]_\n    DNillum                     Avg. direct normal illuminance recv'd during the 60 minutes prior to timestamp, lx\n    DNillumSource               See [1]_, Table 1-4\n    DNillumUncertainty          Uncertainty based on random and bias error estimates see [2]_\n    DHillum                     Avg. horizontal diffuse illuminance recv'd during the 60 minutes prior to timestamp, lx\n    DHillumSource               See [1]_, Table 1-4\n    DHillumUncertainty          Uncertainty based on random and bias error estimates see [2]_\n    Zenithlum                   Avg. luminance at the sky's zenith during the 60 minutes prior to timestamp, cd/m^2\n    ZenithlumSource             See [1]_, Table 1-4\n    ZenithlumUncertainty        Uncertainty based on random and bias error estimates see [1]_ section 2.10\n    TotCld                      Amount of sky dome covered by clouds or obscuring phenonema at time stamp, tenths of sky\n    TotCldSource                See [1]_, Table 1-5\n    TotCldUncertainty           See [1]_, Table 1-6\n    OpqCld                      Amount of sky dome covered by clouds or obscuring phenonema that prevent observing the sky at time stamp, tenths of sky\n    OpqCldSource                See [1]_, Table 1-5\n    OpqCldUncertainty           See [1]_, Table 1-6\n    DryBulb                     Dry bulb temperature at the time indicated, deg C\n    DryBulbSource               See [1]_, Table 1-5\n    DryBulbUncertainty          See [1]_, Table 1-6\n    DewPoint                    Dew-point temperature at the time indicated, deg C\n    DewPointSource              See [1]_, Table 1-5\n    DewPointUncertainty         See [1]_, Table 1-6\n    RHum                        Relatitudeive humidity at the time indicated, percent\n    RHumSource                  See [1]_, Table 1-5\n    RHumUncertainty             See [1]_, Table 1-6\n    Pressure                    Station pressure at the time indicated, 1 mbar\n    PressureSource              See [1]_, Table 1-5\n    PressureUncertainty         See [1]_, Table 1-6\n    Wdir                        Wind direction at time indicated, degrees from north (360 = north; 0 = undefined,calm)\n    WdirSource                  See [1]_, Table 1-5\n    WdirUncertainty             See [1]_, Table 1-6\n    Wspd                        Wind speed at the time indicated, meter/second\n    WspdSource                  See [1]_, Table 1-5\n    WspdUncertainty             See [1]_, Table 1-6\n    Hvis                        Distance to discernable remote objects at time indicated (7777=unlimited), meter\n    HvisSource                  See [1]_, Table 1-5\n    HvisUncertainty             See [1]_, Table 1-6\n    CeilHgt                     Height of cloud base above local terrain (7777=unlimited), meter\n    CeilHgtSource               See [1]_, Table 1-5\n    CeilHgtUncertainty          See [1]_, Table 1-6\n    Pwat                        Total precipitable water contained in a column of unit cross section from earth to top of atmosphere, cm\n    PwatSource                  See [1]_, Table 1-5\n    PwatUncertainty             See [1]_, Table 1-6\n    AOD                         The broadband aerosol optical depth per unit of air mass due to extinction by aerosol component of atmosphere, unitless\n    AODSource                   See [1]_, Table 1-5\n    AODUncertainty              See [1]_, Table 1-6\n    Alb                         The ratio of reflected solar irradiance to global horizontal irradiance, unitless\n    AlbSource                   See [1]_, Table 1-5\n    AlbUncertainty              See [1]_, Table 1-6\n    Lprecipdepth                The amount of liquid precipitation observed at indicated time for the period indicated in the liquid precipitation quantity field, millimeter\n    Lprecipquantity             The period of accumulatitudeion for the liquid precipitation depth field, hour\n    LprecipSource               See [1]_, Table 1-5\n    LprecipUncertainty          See [1]_, Table 1-6\n    PresWth                     Present weather code, see [2]_.\n    PresWthSource               Present weather code source, see [2]_.\n    PresWthUncertainty          Present weather code uncertainty, see [2]_.\n    =====================       ======================================================================================================================================================\n\n    .. admonition:: Midnight representation\n\n       The function is able to handle midnight represented as 24:00 (NREL TMY3\n       format, see [1]_) and as 00:00 (SolarAnywhere TMY3 format, see [3]_).\n\n    .. warning:: TMY3 irradiance data corresponds to the *previous* hour, so\n        the first index is 1AM, corresponding to the irradiance from midnight\n        to 1AM, and the last index is midnight of the *next* year. For example,\n        if the last index in the TMY3 file was 1988-12-31 24:00:00 this becomes\n        1989-01-01 00:00:00 after calling :func:`~pvlib.iotools.read_tmy3`.\n\n    .. warning:: When coercing the year, the last index in the dataframe will\n        become midnight of the *next* year. For example, if the last index in\n        the TMY3 was 1988-12-31 24:00:00, and year is coerced to 1990 then this\n        becomes 1991-01-01 00:00:00.\n\n    References\n    ----------\n    .. [1] Wilcox, S and Marion, W. \"Users Manual for TMY3 Data Sets\".\n       NREL/TP-581-43156, Revised May 2008.\n    .. [2] Wilcox, S. (2007). National Solar Radiation Database 1991 2005\n       Update: Users Manual. 472 pp.; NREL Report No. TP-581-41364.\n    .. [3] `SolarAnywhere file formats\n       <https://www.solaranywhere.com/support/historical-data/file-formats/>`_\n    \"\"\"  # noqa: E501\n    head = ['USAF', 'Name', 'State', 'TZ', 'latitude', 'longitude', 'altitude']\n\n    try:\n        with open(str(filename), 'r') as fbuf:\n            firstline, data = _parse_tmy3(fbuf)\n    # SolarAnywhere files contain non-UTF8 characters and may require\n    # encoding='iso-8859-1' in order to be parsed\n    except UnicodeDecodeError:\n        with open(str(filename), 'r', encoding='iso-8859-1') as fbuf:\n            firstline, data = _parse_tmy3(fbuf)\n\n    meta = dict(zip(head, firstline.rstrip('\\n').split(\",\")))\n    # convert metadata strings to numeric types\n    meta['altitude'] = float(meta['altitude'])\n    meta['latitude'] = float(meta['latitude'])\n    meta['longitude'] = float(meta['longitude'])\n    meta['TZ'] = float(meta['TZ'])\n    meta['USAF'] = int(meta['USAF'])\n\n    # get the date column as a pd.Series of numpy datetime64\n    data_ymd = pd.to_datetime(data['Date (MM/DD/YYYY)'], format='%m/%d/%Y')\n    # shift the time column so that midnite is 00:00 instead of 24:00\n    shifted_hour = data['Time (HH:MM)'].str[:2].astype(int) % 24\n    # shift the dates at midnight (24:00) so they correspond to the next day.\n    # If midnight is specified as 00:00 do not shift date.\n    data_ymd[data['Time (HH:MM)'].str[:2] == '24'] += datetime.timedelta(days=1)  # noqa: E501\n    # NOTE: as of pandas>=0.24 the pd.Series.array has a month attribute, but\n    # in pandas-0.18.1, only DatetimeIndex has month, but indices are immutable\n    # so we need to continue to work with the panda series of dates `data_ymd`\n    data_index = pd.DatetimeIndex(data_ymd)\n    # use indices to check for a leap day and advance it to March 1st\n    leapday = (data_index.month == 2) & (data_index.day == 29)\n    data_ymd[leapday] += datetime.timedelta(days=1)\n    # shifted_hour is a pd.Series, so use pd.to_timedelta to get a pd.Series of\n    # timedeltas\n    if coerce_year is not None:\n        data_ymd = data_ymd.map(lambda dt: dt.replace(year=coerce_year))\n        data_ymd.iloc[-1] = data_ymd.iloc[-1].replace(year=coerce_year+1)\n    # NOTE: as of pvlib-0.6.3, min req is pandas-0.18.1, so pd.to_timedelta\n    # unit must be in (D,h,m,s,ms,us,ns), but pandas>=0.24 allows unit='hour'\n    data.index = data_ymd + pd.to_timedelta(shifted_hour, unit='h')\n\n    if recolumn:\n        data = _recolumn(data)  # rename to standard column names\n\n    data = data.tz_localize(int(meta['TZ'] * 3600))\n\n    return data, meta\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "read_tmy3", "filename", "coerce_year", "none", "recolumn", "true", "read", "a", "tmy3", "file", "into", "a", "pandas", "dataframe", "note", "that", "values", "contained", "in", "the", "metadata", "dictionary", "are", "unchanged", "from", "the", "tmy3", "file", "i", "e", "units", "are", "retained", "in", "the", "case", "of", "any", "discrepancies", "between", "this", "documentation", "and", "the", "tmy3", "user", "s", "manual", "1", "_", "the", "tmy3", "user", "s", "manual", "takes", "precedence", "the", "tmy3", "files", "were", "updated", "in", "jan", "2015", "this", "function", "requires", "the", "use", "of", "the", "updated", "files", "parameters", "filename", "str", "a", "relative", "file", "path", "or", "absolute", "file", "path", "coerce_year", "none", "or", "int", "default", "none", "if", "supplied", "the", "year", "of", "the", "index", "will", "be", "set", "to", "coerce_year", "except", "for", "the", "last", "index", "value", "which", "will", "be", "set", "to", "the", "next", "year", "so", "that", "the", "index", "increases", "monotonically", "recolumn", "bool", "default", "true", "if", "true", "apply", "standard", "names", "to", "tmy3", "columns", "typically", "this", "results", "in", "stripping", "the", "units", "from", "the", "column", "name", "returns", "tuple", "of", "the", "form", "data", "metadata", "data", "dataframe", "a", "pandas", "dataframe", "with", "the", "columns", "described", "in", "the", "table", "below", "for", "more", "detailed", "descriptions", "of", "each", "component", "please", "consult", "the", "tmy3", "user", "s", "manual", "1", "_", "especially", "tables", "1", "1", "through", "1", "6", "metadata", "dict", "the", "site", "metadata", "available", "in", "the", "file", "notes", "the", "returned", "structures", "have", "the", "following", "fields", "key", "format", "description", "altitude", "float", "site", "elevation", "latitude", "float", "site", "latitudeitude", "longitude", "float", "site", "longitudeitude", "name", "string", "site", "name", "state", "string", "state", "tz", "float", "utc", "offset", "usaf", "int", "usaf", "identifier", "field", "description", "index", "a", "pandas", "datetime", "index", "note", "the", "index", "is", "timezone", "aware", "and", "times", "are", "set", "to", "local", "standard", "time", "daylight", "savings", "is", "not", "included", "etr", "extraterrestrial", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "etrn", "extraterrestrial", "normal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghi", "direct", "and", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghisource", "see", "1", "_", "table", "1", "4", "ghiuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "dni", "amount", "of", "direct", "normal", "radiation", "modeled", "recv", "d", "during", "60", "mintues", "prior", "to", "timestamp", "wh", "m", "2", "dnisource", "see", "1", "_", "table", "1", "4", "dniuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "dhi", "amount", "of", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "dhisource", "see", "1", "_", "table", "1", "4", "dhiuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "ghillum", "avg", "total", "horizontal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "ghillumsource", "see", "1", "_", "table", "1", "4", "ghillumuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "dnillum", "avg", "direct", "normal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "dnillumsource", "see", "1", "_", "table", "1", "4", "dnillumuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "dhillum", "avg", "horizontal", "diffuse", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "lx", "dhillumsource", "see", "1", "_", "table", "1", "4", "dhillumuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "2", "_", "zenithlum", "avg", "luminance", "at", "the", "sky", "s", "zenith", "during", "the", "60", "minutes", "prior", "to", "timestamp", "cd", "m", "2", "zenithlumsource", "see", "1", "_", "table", "1", "4", "zenithlumuncertainty", "uncertainty", "based", "on", "random", "and", "bias", "error", "estimates", "see", "1", "_", "section", "2", "10", "totcld", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenonema", "at", "time", "stamp", "tenths", "of", "sky", "totcldsource", "see", "1", "_", "table", "1", "5", "totclduncertainty", "see", "1", "_", "table", "1", "6", "opqcld", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenonema", "that", "prevent", "observing", "the", "sky", "at", "time", "stamp", "tenths", "of", "sky", "opqcldsource", "see", "1", "_", "table", "1", "5", "opqclduncertainty", "see", "1", "_", "table", "1", "6", "drybulb", "dry", "bulb", "temperature", "at", "the", "time", "indicated", "deg", "c", "drybulbsource", "see", "1", "_", "table", "1", "5", "drybulbuncertainty", "see", "1", "_", "table", "1", "6", "dewpoint", "dew", "point", "temperature", "at", "the", "time", "indicated", "deg", "c", "dewpointsource", "see", "1", "_", "table", "1", "5", "dewpointuncertainty", "see", "1", "_", "table", "1", "6", "rhum", "relatitudeive", "humidity", "at", "the", "time", "indicated", "percent", "rhumsource", "see", "1", "_", "table", "1", "5", "rhumuncertainty", "see", "1", "_", "table", "1", "6", "pressure", "station", "pressure", "at", "the", "time", "indicated", "1", "mbar", "pressuresource", "see", "1", "_", "table", "1", "5", "pressureuncertainty", "see", "1", "_", "table", "1", "6", "wdir", "wind", "direction", "at", "time", "indicated", "degrees", "from", "north", "360", "north", "0", "undefined", "calm", "wdirsource", "see", "1", "_", "table", "1", "5", "wdiruncertainty", "see", "1", "_", "table", "1", "6", "wspd", "wind", "speed", "at", "the", "time", "indicated", "meter", "second", "wspdsource", "see", "1", "_", "table", "1", "5", "wspduncertainty", "see", "1", "_", "table", "1", "6", "hvis", "distance", "to", "discernable", "remote", "objects", "at", "time", "indicated", "7777", "unlimited", "meter", "hvissource", "see", "1", "_", "table", "1", "5", "hvisuncertainty", "see", "1", "_", "table", "1", "6", "ceilhgt", "height", "of", "cloud", "base", "above", "local", "terrain", "7777", "unlimited", "meter", "ceilhgtsource", "see", "1", "_", "table", "1", "5", "ceilhgtuncertainty", "see", "1", "_", "table", "1", "6", "pwat", "total", "precipitable", "water", "contained", "in", "a", "column", "of", "unit", "cross", "section", "from", "earth", "to", "top", "of", "atmosphere", "cm", "pwatsource", "see", "1", "_", "table", "1", "5", "pwatuncertainty", "see", "1", "_", "table", "1", "6", "aod", "the", "broadband", "aerosol", "optical", "depth", "per", "unit", "of", "air", "mass", "due", "to", "extinction", "by", "aerosol", "component", "of", "atmosphere", "unitless", "aodsource", "see", "1", "_", "table", "1", "5", "aoduncertainty", "see", "1", "_", "table", "1", "6", "alb", "the", "ratio", "of", "reflected", "solar", "irradiance", "to", "global", "horizontal", "irradiance", "unitless", "albsource", "see", "1", "_", "table", "1", "5", "albuncertainty", "see", "1", "_", "table", "1", "6", "lprecipdepth", "the", "amount", "of", "liquid", "precipitation", "observed", "at", "indicated", "time", "for", "the", "period", "indicated", "in", "the", "liquid", "precipitation", "quantity", "field", "millimeter", "lprecipquantity", "the", "period", "of", "accumulatitudeion", "for", "the", "liquid", "precipitation", "depth", "field", "hour", "lprecipsource", "see", "1", "_", "table", "1", "5", "lprecipuncertainty", "see", "1", "_", "table", "1", "6", "preswth", "present", "weather", "code", "see", "2", "_", "preswthsource", "present", "weather", "code", "source", "see", "2", "_", "preswthuncertainty", "present", "weather", "code", "uncertainty", "see", "2", "_", "admonition", "midnight", "representation", "the", "function", "is", "able", "to", "handle", "midnight", "represented", "as", "24", "00", "nrel", "tmy3", "format", "see", "1", "_", "and", "as", "00", "00", "solaranywhere", "tmy3", "format", "see", "3", "_", "warning", "tmy3", "irradiance", "data", "corresponds", "to", "the", "previous", "hour", "so", "the", "first", "index", "is", "1am", "corresponding", "to", "the", "irradiance", "from", "midnight", "to", "1am", "and", "the", "last", "index", "is", "midnight", "of", "the", "next", "year", "for", "example", "if", "the", "last", "index", "in", "the", "tmy3", "file", "was", "1988", "12", "31", "24", "00", "00", "this", "becomes", "1989", "01", "01", "00", "00", "00", "after", "calling", "func", "pvlib", "iotools", "read_tmy3", "warning", "when", "coercing", "the", "year", "the", "last", "index", "in", "the", "dataframe", "will", "become", "midnight", "of", "the", "next", "year", "for", "example", "if", "the", "last", "index", "in", "the", "tmy3", "was", "1988", "12", "31", "24", "00", "00", "and", "year", "is", "coerced", "to", "1990", "then", "this", "becomes", "1991", "01", "01", "00", "00", "00", "references", "1", "wilcox", "s", "and", "marion", "w", "users", "manual", "for", "tmy3", "data", "sets", "nrel", "tp", "581", "43156", "revised", "may", "2008", "2", "wilcox", "s", "2007", "national", "solar", "radiation", "database", "1991", "2005", "update", "users", "manual", "472", "pp", "nrel", "report", "no", "tp", "581", "41364", "3", "solaranywhere", "file", "formats", "https", "www", "solaranywhere", "com", "support", "historical", "data", "file", "formats", "_", "noqa", "e501", "head", "usaf", "name", "state", "tz", "latitude", "longitude", "altitude", "try", "with", "open", "str", "filename", "r", "as", "fbuf", "firstline", "data", "_parse_tmy3", "fbuf", "solaranywhere", "files", "contain", "non", "utf8", "characters", "and", "may", "require", "encoding", "iso", "8859", "1", "in", "order", "to", "be", "parsed", "except", "unicodedecodeerror", "with", "open", "str", "filename", "r", "encoding", "iso", "8859", "1", "as", "fbuf", "firstline", "data", "_parse_tmy3", "fbuf", "meta", "dict", "zip", "head", "firstline", "rstrip", "n", "split", "convert", "metadata", "strings", "to", "numeric", "types", "meta", "altitude", "float", "meta", "altitude", "meta", "latitude", "float", "meta", "latitude", "meta", "longitude", "float", "meta", "longitude", "meta", "tz", "float", "meta", "tz", "meta", "usaf", "int", "meta", "usaf", "get", "the", "date", "column", "as", "a", "pd", "series", "of", "numpy", "datetime64", "data_ymd", "pd", "to_datetime", "data", "date", "mm", "dd", "yyyy", "format", "m", "d", "y", "shift", "the", "time", "column", "so", "that", "midnite", "is", "00", "00", "instead", "of", "24", "00", "shifted_hour", "data", "time", "hh", "mm", "str", "2", "astype", "int", "24", "shift", "the", "dates", "at", "midnight", "24", "00", "so", "they", "correspond", "to", "the", "next", "day", "if", "midnight", "is", "specified", "as", "00", "00", "do", "not", "shift", "date", "data_ymd", "data", "time", "hh", "mm", "str", "2", "24", "datetime", "timedelta", "days", "1", "noqa", "e501", "note", "as", "of", "pandas", "0", "24", "the", "pd", "series", "array", "has", "a", "month", "attribute", "but", "in", "pandas", "0", "18", "1", "only", "datetimeindex", "has", "month", "but", "indices", "are", "immutable", "so", "we", "need", "to", "continue", "to", "work", "with", "the", "panda", "series", "of", "dates", "data_ymd", "data_index", "pd", "datetimeindex", "data_ymd", "use", "indices", "to", "check", "for", "a", "leap", "day", "and", "advance", "it", "to", "march", "1st", "leapday", "data_index", "month", "2", "data_index", "day", "29", "data_ymd", "leapday", "datetime", "timedelta", "days", "1", "shifted_hour", "is", "a", "pd", "series", "so", "use", "pd", "to_timedelta", "to", "get", "a", "pd", "series", "of", "timedeltas", "if", "coerce_year", "is", "not", "none", "data_ymd", "data_ymd", "map", "lambda", "dt", "dt", "replace", "year", "coerce_year", "data_ymd", "iloc", "1", "data_ymd", "iloc", "1", "replace", "year", "coerce_year", "1", "note", "as", "of", "pvlib", "0", "6", "3", "min", "req", "is", "pandas", "0", "18", "1", "so", "pd", "to_timedelta", "unit", "must", "be", "in", "d", "h", "m", "s", "ms", "us", "ns", "but", "pandas", "0", "24", "allows", "unit", "hour", "data", "index", "data_ymd", "pd", "to_timedelta", "shifted_hour", "unit", "h", "if", "recolumn", "data", "_recolumn", "data", "rename", "to", "standard", "column", "names", "data", "data", "tz_localize", "int", "meta", "tz", "3600", "return", "data", "meta"], "doc_len": 1529}
{"doc_id": "pvlib/iotools/tmy.py::_parse_tmy3", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "_parse_tmy3", "text": "文件路径: pvlib/iotools/tmy.py\ndef _parse_tmy3(fbuf):\n    # header information on the 1st line (0 indexing)\n    firstline = fbuf.readline()\n    # use pandas to read the csv file buffer\n    # header is actually the second line, but tell pandas to look for\n    data = pd.read_csv(fbuf, header=0)\n    return firstline, data\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "_parse_tmy3", "fbuf", "header", "information", "on", "the", "1st", "line", "0", "indexing", "firstline", "fbuf", "readline", "use", "pandas", "to", "read", "the", "csv", "file", "buffer", "header", "is", "actually", "the", "second", "line", "but", "tell", "pandas", "to", "look", "for", "data", "pd", "read_csv", "fbuf", "header", "0", "return", "firstline", "data"], "doc_len": 47}
{"doc_id": "pvlib/iotools/tmy.py::_recolumn", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "_recolumn", "text": "文件路径: pvlib/iotools/tmy.py\ndef _recolumn(tmy3_dataframe):\n    \"\"\"\n    Rename the columns of the TMY3 DataFrame.\n\n    Parameters\n    ----------\n    tmy3_dataframe : DataFrame\n    inplace : bool\n        passed to DataFrame.rename()\n\n    Returns\n    -------\n    Recolumned DataFrame.\n    \"\"\"\n    # paste in the header as one long line\n    raw_columns = 'ETR (W/m^2),ETRN (W/m^2),GHI (W/m^2),GHI source,GHI uncert (%),DNI (W/m^2),DNI source,DNI uncert (%),DHI (W/m^2),DHI source,DHI uncert (%),GH illum (lx),GH illum source,Global illum uncert (%),DN illum (lx),DN illum source,DN illum uncert (%),DH illum (lx),DH illum source,DH illum uncert (%),Zenith lum (cd/m^2),Zenith lum source,Zenith lum uncert (%),TotCld (tenths),TotCld source,TotCld uncert (code),OpqCld (tenths),OpqCld source,OpqCld uncert (code),Dry-bulb (C),Dry-bulb source,Dry-bulb uncert (code),Dew-point (C),Dew-point source,Dew-point uncert (code),RHum (%),RHum source,RHum uncert (code),Pressure (mbar),Pressure source,Pressure uncert (code),Wdir (degrees),Wdir source,Wdir uncert (code),Wspd (m/s),Wspd source,Wspd uncert (code),Hvis (m),Hvis source,Hvis uncert (code),CeilHgt (m),CeilHgt source,CeilHgt uncert (code),Pwat (cm),Pwat source,Pwat uncert (code),AOD (unitless),AOD source,AOD uncert (code),Alb (unitless),Alb source,Alb uncert (code),Lprecip depth (mm),Lprecip quantity (hr),Lprecip source,Lprecip uncert (code),PresWth (METAR code),PresWth source,PresWth uncert (code)'  # noqa: E501\n\n    new_columns = [\n        'ETR', 'ETRN', 'GHI', 'GHISource', 'GHIUncertainty',\n        'DNI', 'DNISource', 'DNIUncertainty', 'DHI', 'DHISource',\n        'DHIUncertainty', 'GHillum', 'GHillumSource', 'GHillumUncertainty',\n        'DNillum', 'DNillumSource', 'DNillumUncertainty', 'DHillum',\n        'DHillumSource', 'DHillumUncertainty', 'Zenithlum',\n        'ZenithlumSource', 'ZenithlumUncertainty', 'TotCld', 'TotCldSource',\n        'TotCldUncertainty', 'OpqCld', 'OpqCldSource', 'OpqCldUncertainty',\n        'DryBulb', 'DryBulbSource', 'DryBulbUncertainty', 'DewPoint',\n        'DewPointSource', 'DewPointUncertainty', 'RHum', 'RHumSource',\n        'RHumUncertainty', 'Pressure', 'PressureSource',\n        'PressureUncertainty', 'Wdir', 'WdirSource', 'WdirUncertainty',\n        'Wspd', 'WspdSource', 'WspdUncertainty', 'Hvis', 'HvisSource',\n        'HvisUncertainty', 'CeilHgt', 'CeilHgtSource', 'CeilHgtUncertainty',\n        'Pwat', 'PwatSource', 'PwatUncertainty', 'AOD', 'AODSource',\n        'AODUncertainty', 'Alb', 'AlbSource', 'AlbUncertainty',\n        'Lprecipdepth', 'Lprecipquantity', 'LprecipSource',\n        'LprecipUncertainty', 'PresWth', 'PresWthSource',\n        'PresWthUncertainty']\n\n    mapping = dict(zip(raw_columns.split(','), new_columns))\n\n    return tmy3_dataframe.rename(columns=mapping)\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "_recolumn", "tmy3_dataframe", "rename", "the", "columns", "of", "the", "tmy3", "dataframe", "parameters", "tmy3_dataframe", "dataframe", "inplace", "bool", "passed", "to", "dataframe", "rename", "returns", "recolumned", "dataframe", "paste", "in", "the", "header", "as", "one", "long", "line", "raw_columns", "etr", "w", "m", "2", "etrn", "w", "m", "2", "ghi", "w", "m", "2", "ghi", "source", "ghi", "uncert", "dni", "w", "m", "2", "dni", "source", "dni", "uncert", "dhi", "w", "m", "2", "dhi", "source", "dhi", "uncert", "gh", "illum", "lx", "gh", "illum", "source", "global", "illum", "uncert", "dn", "illum", "lx", "dn", "illum", "source", "dn", "illum", "uncert", "dh", "illum", "lx", "dh", "illum", "source", "dh", "illum", "uncert", "zenith", "lum", "cd", "m", "2", "zenith", "lum", "source", "zenith", "lum", "uncert", "totcld", "tenths", "totcld", "source", "totcld", "uncert", "code", "opqcld", "tenths", "opqcld", "source", "opqcld", "uncert", "code", "dry", "bulb", "c", "dry", "bulb", "source", "dry", "bulb", "uncert", "code", "dew", "point", "c", "dew", "point", "source", "dew", "point", "uncert", "code", "rhum", "rhum", "source", "rhum", "uncert", "code", "pressure", "mbar", "pressure", "source", "pressure", "uncert", "code", "wdir", "degrees", "wdir", "source", "wdir", "uncert", "code", "wspd", "m", "s", "wspd", "source", "wspd", "uncert", "code", "hvis", "m", "hvis", "source", "hvis", "uncert", "code", "ceilhgt", "m", "ceilhgt", "source", "ceilhgt", "uncert", "code", "pwat", "cm", "pwat", "source", "pwat", "uncert", "code", "aod", "unitless", "aod", "source", "aod", "uncert", "code", "alb", "unitless", "alb", "source", "alb", "uncert", "code", "lprecip", "depth", "mm", "lprecip", "quantity", "hr", "lprecip", "source", "lprecip", "uncert", "code", "preswth", "metar", "code", "preswth", "source", "preswth", "uncert", "code", "noqa", "e501", "new_columns", "etr", "etrn", "ghi", "ghisource", "ghiuncertainty", "dni", "dnisource", "dniuncertainty", "dhi", "dhisource", "dhiuncertainty", "ghillum", "ghillumsource", "ghillumuncertainty", "dnillum", "dnillumsource", "dnillumuncertainty", "dhillum", "dhillumsource", "dhillumuncertainty", "zenithlum", "zenithlumsource", "zenithlumuncertainty", "totcld", "totcldsource", "totclduncertainty", "opqcld", "opqcldsource", "opqclduncertainty", "drybulb", "drybulbsource", "drybulbuncertainty", "dewpoint", "dewpointsource", "dewpointuncertainty", "rhum", "rhumsource", "rhumuncertainty", "pressure", "pressuresource", "pressureuncertainty", "wdir", "wdirsource", "wdiruncertainty", "wspd", "wspdsource", "wspduncertainty", "hvis", "hvissource", "hvisuncertainty", "ceilhgt", "ceilhgtsource", "ceilhgtuncertainty", "pwat", "pwatsource", "pwatuncertainty", "aod", "aodsource", "aoduncertainty", "alb", "albsource", "albuncertainty", "lprecipdepth", "lprecipquantity", "lprecipsource", "lprecipuncertainty", "preswth", "preswthsource", "preswthuncertainty", "mapping", "dict", "zip", "raw_columns", "split", "new_columns", "return", "tmy3_dataframe", "rename", "columns", "mapping"], "doc_len": 304}
{"doc_id": "pvlib/iotools/tmy.py::read_tmy2", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "read_tmy2", "text": "文件路径: pvlib/iotools/tmy.py\ndef read_tmy2(filename):\n    \"\"\"\n    Read a TMY2 file into a DataFrame.\n\n    Note that values contained in the DataFrame are unchanged from the\n    TMY2 file (i.e. units  are retained). Time/Date and location data\n    imported from the TMY2 file have been modified to a \"friendlier\"\n    form conforming to modern conventions (e.g. N latitude is postive, E\n    longitude is positive, the \"24th\" hour of any day is technically the\n    \"0th\" hour of the next day). In the case of any discrepencies\n    between this documentation and the TMY2 User's Manual [1]_, the TMY2\n    User's Manual takes precedence.\n\n    Parameters\n    ----------\n    filename : str\n        A relative or absolute file path.\n\n    Returns\n    -------\n    Tuple of the form (data, metadata).\n\n    data : DataFrame\n        A dataframe with the columns described in the table below. For a\n        more detailed descriptions of each component, please consult the\n        TMY2 User's Manual ([1]_), especially tables 3-1 through 3-6, and\n        Appendix B.\n\n    metadata : dict\n        The site metadata available in the file.\n\n    Notes\n    -----\n    The returned structures have the following fields.\n\n    =============    ==================================\n    key              description\n    =============    ==================================\n    WBAN             Site identifier code (WBAN number)\n    City             Station name\n    State            Station state 2 letter designator\n    TZ               Hours from Greenwich\n    latitude         Latitude in decimal degrees\n    longitude        Longitude in decimal degrees\n    altitude         Site elevation in meters\n    =============    ==================================\n\n    ============================   ==========================================================================================================================================================================\n    field                           description\n    ============================   ==========================================================================================================================================================================\n    index                           Pandas timeseries object containing timestamps\n    year\n    month\n    day\n    hour\n    ETR                             Extraterrestrial horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    ETRN                            Extraterrestrial normal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    GHI                             Direct and diffuse horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    GHISource                       See [1]_, Table 3-3\n    GHIUncertainty                  See [1]_, Table 3-4\n    DNI                             Amount of direct normal radiation (modeled) recv'd during 60 mintues prior to timestamp, Wh/m^2\n    DNISource                       See [1]_, Table 3-3\n    DNIUncertainty                  See [1]_, Table 3-4\n    DHI                             Amount of diffuse horizontal radiation recv'd during 60 minutes prior to timestamp, Wh/m^2\n    DHISource                       See [1]_, Table 3-3\n    DHIUncertainty                  See [1]_, Table 3-4\n    GHillum                         Avg. total horizontal illuminance recv'd during the 60 minutes prior to timestamp, units of 100 lux (e.g. value of 50 = 5000 lux)\n    GHillumSource                   See [1]_, Table 3-3\n    GHillumUncertainty              See [1]_, Table 3-4\n    DNillum                         Avg. direct normal illuminance recv'd during the 60 minutes prior to timestamp, units of 100 lux\n    DNillumSource                   See [1]_, Table 3-3\n    DNillumUncertainty              See [1]_, Table 3-4\n    DHillum                         Avg. horizontal diffuse illuminance recv'd during the 60 minutes prior to timestamp, units of 100 lux\n    DHillumSource                   See [1]_, Table 3-3\n    DHillumUncertainty              See [1]_, Table 3-4\n    Zenithlum                       Avg. luminance at the sky's zenith during the 60 minutes prior to timestamp, units of 10 Cd/m^2 (e.g. value of 700 = 7,000 Cd/m^2)\n    ZenithlumSource                 See [1]_, Table 3-3\n    ZenithlumUncertainty            See [1]_, Table 3-4\n    TotCld                          Amount of sky dome covered by clouds or obscuring phenonema at time stamp, tenths of sky\n    TotCldSource                    See [1]_, Table 3-5\n    TotCldUncertainty                See [1]_, Table 3-6\n    OpqCld                          Amount of sky dome covered by clouds or obscuring phenonema that prevent observing the sky at time stamp, tenths of sky\n    OpqCldSource                    See [1]_, Table 3-5\n    OpqCldUncertainty               See [1]_, Table 3-6\n    DryBulb                         Dry bulb temperature at the time indicated, in tenths of degree C (e.g. 352 = 35.2 C).\n    DryBulbSource                   See [1]_, Table 3-5\n    DryBulbUncertainty              See [1]_, Table 3-6\n    DewPoint                        Dew-point temperature at the time indicated, in tenths of degree C (e.g. 76 = 7.6 C).\n    DewPointSource                  See [1]_, Table 3-5\n    DewPointUncertainty             See [1]_, Table 3-6\n    RHum                            Relative humidity at the time indicated, percent\n    RHumSource                      See [1]_, Table 3-5\n    RHumUncertainty                 See [1]_, Table 3-6\n    Pressure                        Station pressure at the time indicated, 1 mbar\n    PressureSource                  See [1]_, Table 3-5\n    PressureUncertainty             See [1]_, Table 3-6\n    Wdir                            Wind direction at time indicated, degrees from east of north (360 = 0 = north; 90 = East; 0 = undefined,calm)\n    WdirSource                      See [1]_, Table 3-5\n    WdirUncertainty                 See [1]_, Table 3-6\n    Wspd                            Wind speed at the time indicated, in tenths of meters/second (e.g. 212 = 21.2 m/s)\n    WspdSource                      See [1]_, Table 3-5\n    WspdUncertainty                 See [1]_, Table 3-6\n    Hvis                            Distance to discernable remote objects at time indicated (7777=unlimited, 9999=missing data), in tenths of kilometers (e.g. 341 = 34.1 km).\n    HvisSource                      See [1]_, Table 3-5\n    HvisUncertainty                 See [1]_, Table 3-6\n    CeilHgt                         Height of cloud base above local terrain (7777=unlimited, 88888=cirroform, 99999=missing data), in meters\n    CeilHgtSource                   See [1]_, Table 3-5\n    CeilHgtUncertainty              See [1]_, Table 3-6\n    Pwat                            Total precipitable water contained in a column of unit cross section from Earth to top of atmosphere, in millimeters\n    PwatSource                      See [1]_, Table 3-5\n    PwatUncertainty                 See [1]_, Table 3-6\n    AOD                             The broadband aerosol optical depth (broadband turbidity) in thousandths on the day indicated (e.g. 114 = 0.114)\n    AODSource                       See [1]_, Table 3-5\n    AODUncertainty                  See [1]_, Table 3-6\n    SnowDepth                       Snow depth in centimeters on the day indicated, (999 = missing data).\n    SnowDepthSource                 See [1]_, Table 3-5\n    SnowDepthUncertainty            See [1]_, Table 3-6\n    LastSnowfall                    Number of days since last snowfall (maximum value of 88, where 88 = 88 or greater days; 99 = missing data)\n    LastSnowfallSource              See [1]_, Table 3-5\n    LastSnowfallUncertainty         See [1]_, Table 3-6\n    PresentWeather                  See [1]_, Appendix B. Each string contains 10 numeric values. The string can be parsed to determine each of 10 observed weather metrics.\n    ============================   ==========================================================================================================================================================================\n\n    References\n    ----------\n    .. [1] Marion, W and Urban, K. \"Wilcox, S and Marion, W. \"User's Manual\n       for TMY2s\". NREL 1995.\n    \"\"\"  # noqa: E501\n    # paste in the column info as one long line\n    string = '%2d%2d%2d%2d%4d%4d%4d%1s%1d%4d%1s%1d%4d%1s%1d%4d%1s%1d%4d%1s%1d%4d%1s%1d%4d%1s%1d%2d%1s%1d%2d%1s%1d%4d%1s%1d%4d%1s%1d%3d%1s%1d%4d%1s%1d%3d%1s%1d%3d%1s%1d%4d%1s%1d%5d%1s%1d%10d%3d%1s%1d%3d%1s%1d%3d%1s%1d%2d%1s%1d'  # noqa: E501\n    columns = 'year,month,day,hour,ETR,ETRN,GHI,GHISource,GHIUncertainty,DNI,DNISource,DNIUncertainty,DHI,DHISource,DHIUncertainty,GHillum,GHillumSource,GHillumUncertainty,DNillum,DNillumSource,DNillumUncertainty,DHillum,DHillumSource,DHillumUncertainty,Zenithlum,ZenithlumSource,ZenithlumUncertainty,TotCld,TotCldSource,TotCldUncertainty,OpqCld,OpqCldSource,OpqCldUncertainty,DryBulb,DryBulbSource,DryBulbUncertainty,DewPoint,DewPointSource,DewPointUncertainty,RHum,RHumSource,RHumUncertainty,Pressure,PressureSource,PressureUncertainty,Wdir,WdirSource,WdirUncertainty,Wspd,WspdSource,WspdUncertainty,Hvis,HvisSource,HvisUncertainty,CeilHgt,CeilHgtSource,CeilHgtUncertainty,PresentWeather,Pwat,PwatSource,PwatUncertainty,AOD,AODSource,AODUncertainty,SnowDepth,SnowDepthSource,SnowDepthUncertainty,LastSnowfall,LastSnowfallSource,LastSnowfallUncertaint'  # noqa: E501\n    hdr_columns = 'WBAN,City,State,TZ,latitude,longitude,altitude'\n\n    tmy2, tmy2_meta = _read_tmy2(string, columns, hdr_columns, str(filename))\n\n    return tmy2, tmy2_meta\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "read_tmy2", "filename", "read", "a", "tmy2", "file", "into", "a", "dataframe", "note", "that", "values", "contained", "in", "the", "dataframe", "are", "unchanged", "from", "the", "tmy2", "file", "i", "e", "units", "are", "retained", "time", "date", "and", "location", "data", "imported", "from", "the", "tmy2", "file", "have", "been", "modified", "to", "a", "friendlier", "form", "conforming", "to", "modern", "conventions", "e", "g", "n", "latitude", "is", "postive", "e", "longitude", "is", "positive", "the", "24th", "hour", "of", "any", "day", "is", "technically", "the", "0th", "hour", "of", "the", "next", "day", "in", "the", "case", "of", "any", "discrepencies", "between", "this", "documentation", "and", "the", "tmy2", "user", "s", "manual", "1", "_", "the", "tmy2", "user", "s", "manual", "takes", "precedence", "parameters", "filename", "str", "a", "relative", "or", "absolute", "file", "path", "returns", "tuple", "of", "the", "form", "data", "metadata", "data", "dataframe", "a", "dataframe", "with", "the", "columns", "described", "in", "the", "table", "below", "for", "a", "more", "detailed", "descriptions", "of", "each", "component", "please", "consult", "the", "tmy2", "user", "s", "manual", "1", "_", "especially", "tables", "3", "1", "through", "3", "6", "and", "appendix", "b", "metadata", "dict", "the", "site", "metadata", "available", "in", "the", "file", "notes", "the", "returned", "structures", "have", "the", "following", "fields", "key", "description", "wban", "site", "identifier", "code", "wban", "number", "city", "station", "name", "state", "station", "state", "2", "letter", "designator", "tz", "hours", "from", "greenwich", "latitude", "latitude", "in", "decimal", "degrees", "longitude", "longitude", "in", "decimal", "degrees", "altitude", "site", "elevation", "in", "meters", "field", "description", "index", "pandas", "timeseries", "object", "containing", "timestamps", "year", "month", "day", "hour", "etr", "extraterrestrial", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "etrn", "extraterrestrial", "normal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghi", "direct", "and", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "ghisource", "see", "1", "_", "table", "3", "3", "ghiuncertainty", "see", "1", "_", "table", "3", "4", "dni", "amount", "of", "direct", "normal", "radiation", "modeled", "recv", "d", "during", "60", "mintues", "prior", "to", "timestamp", "wh", "m", "2", "dnisource", "see", "1", "_", "table", "3", "3", "dniuncertainty", "see", "1", "_", "table", "3", "4", "dhi", "amount", "of", "diffuse", "horizontal", "radiation", "recv", "d", "during", "60", "minutes", "prior", "to", "timestamp", "wh", "m", "2", "dhisource", "see", "1", "_", "table", "3", "3", "dhiuncertainty", "see", "1", "_", "table", "3", "4", "ghillum", "avg", "total", "horizontal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "units", "of", "100", "lux", "e", "g", "value", "of", "50", "5000", "lux", "ghillumsource", "see", "1", "_", "table", "3", "3", "ghillumuncertainty", "see", "1", "_", "table", "3", "4", "dnillum", "avg", "direct", "normal", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "units", "of", "100", "lux", "dnillumsource", "see", "1", "_", "table", "3", "3", "dnillumuncertainty", "see", "1", "_", "table", "3", "4", "dhillum", "avg", "horizontal", "diffuse", "illuminance", "recv", "d", "during", "the", "60", "minutes", "prior", "to", "timestamp", "units", "of", "100", "lux", "dhillumsource", "see", "1", "_", "table", "3", "3", "dhillumuncertainty", "see", "1", "_", "table", "3", "4", "zenithlum", "avg", "luminance", "at", "the", "sky", "s", "zenith", "during", "the", "60", "minutes", "prior", "to", "timestamp", "units", "of", "10", "cd", "m", "2", "e", "g", "value", "of", "700", "7", "000", "cd", "m", "2", "zenithlumsource", "see", "1", "_", "table", "3", "3", "zenithlumuncertainty", "see", "1", "_", "table", "3", "4", "totcld", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenonema", "at", "time", "stamp", "tenths", "of", "sky", "totcldsource", "see", "1", "_", "table", "3", "5", "totclduncertainty", "see", "1", "_", "table", "3", "6", "opqcld", "amount", "of", "sky", "dome", "covered", "by", "clouds", "or", "obscuring", "phenonema", "that", "prevent", "observing", "the", "sky", "at", "time", "stamp", "tenths", "of", "sky", "opqcldsource", "see", "1", "_", "table", "3", "5", "opqclduncertainty", "see", "1", "_", "table", "3", "6", "drybulb", "dry", "bulb", "temperature", "at", "the", "time", "indicated", "in", "tenths", "of", "degree", "c", "e", "g", "352", "35", "2", "c", "drybulbsource", "see", "1", "_", "table", "3", "5", "drybulbuncertainty", "see", "1", "_", "table", "3", "6", "dewpoint", "dew", "point", "temperature", "at", "the", "time", "indicated", "in", "tenths", "of", "degree", "c", "e", "g", "76", "7", "6", "c", "dewpointsource", "see", "1", "_", "table", "3", "5", "dewpointuncertainty", "see", "1", "_", "table", "3", "6", "rhum", "relative", "humidity", "at", "the", "time", "indicated", "percent", "rhumsource", "see", "1", "_", "table", "3", "5", "rhumuncertainty", "see", "1", "_", "table", "3", "6", "pressure", "station", "pressure", "at", "the", "time", "indicated", "1", "mbar", "pressuresource", "see", "1", "_", "table", "3", "5", "pressureuncertainty", "see", "1", "_", "table", "3", "6", "wdir", "wind", "direction", "at", "time", "indicated", "degrees", "from", "east", "of", "north", "360", "0", "north", "90", "east", "0", "undefined", "calm", "wdirsource", "see", "1", "_", "table", "3", "5", "wdiruncertainty", "see", "1", "_", "table", "3", "6", "wspd", "wind", "speed", "at", "the", "time", "indicated", "in", "tenths", "of", "meters", "second", "e", "g", "212", "21", "2", "m", "s", "wspdsource", "see", "1", "_", "table", "3", "5", "wspduncertainty", "see", "1", "_", "table", "3", "6", "hvis", "distance", "to", "discernable", "remote", "objects", "at", "time", "indicated", "7777", "unlimited", "9999", "missing", "data", "in", "tenths", "of", "kilometers", "e", "g", "341", "34", "1", "km", "hvissource", "see", "1", "_", "table", "3", "5", "hvisuncertainty", "see", "1", "_", "table", "3", "6", "ceilhgt", "height", "of", "cloud", "base", "above", "local", "terrain", "7777", "unlimited", "88888", "cirroform", "99999", "missing", "data", "in", "meters", "ceilhgtsource", "see", "1", "_", "table", "3", "5", "ceilhgtuncertainty", "see", "1", "_", "table", "3", "6", "pwat", "total", "precipitable", "water", "contained", "in", "a", "column", "of", "unit", "cross", "section", "from", "earth", "to", "top", "of", "atmosphere", "in", "millimeters", "pwatsource", "see", "1", "_", "table", "3", "5", "pwatuncertainty", "see", "1", "_", "table", "3", "6", "aod", "the", "broadband", "aerosol", "optical", "depth", "broadband", "turbidity", "in", "thousandths", "on", "the", "day", "indicated", "e", "g", "114", "0", "114", "aodsource", "see", "1", "_", "table", "3", "5", "aoduncertainty", "see", "1", "_", "table", "3", "6", "snowdepth", "snow", "depth", "in", "centimeters", "on", "the", "day", "indicated", "999", "missing", "data", "snowdepthsource", "see", "1", "_", "table", "3", "5", "snowdepthuncertainty", "see", "1", "_", "table", "3", "6", "lastsnowfall", "number", "of", "days", "since", "last", "snowfall", "maximum", "value", "of", "88", "where", "88", "88", "or", "greater", "days", "99", "missing", "data", "lastsnowfallsource", "see", "1", "_", "table", "3", "5", "lastsnowfalluncertainty", "see", "1", "_", "table", "3", "6", "presentweather", "see", "1", "_", "appendix", "b", "each", "string", "contains", "10", "numeric", "values", "the", "string", "can", "be", "parsed", "to", "determine", "each", "of", "10", "observed", "weather", "metrics", "references", "1", "marion", "w", "and", "urban", "k", "wilcox", "s", "and", "marion", "w", "user", "s", "manual", "for", "tmy2s", "nrel", "1995", "noqa", "e501", "paste", "in", "the", "column", "info", "as", "one", "long", "line", "string", "2d", "2d", "2d", "2d", "4d", "4d", "4d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "2d", "1s", "1d", "2d", "1s", "1d", "4d", "1s", "1d", "4d", "1s", "1d", "3d", "1s", "1d", "4d", "1s", "1d", "3d", "1s", "1d", "3d", "1s", "1d", "4d", "1s", "1d", "5d", "1s", "1d", "10d", "3d", "1s", "1d", "3d", "1s", "1d", "3d", "1s", "1d", "2d", "1s", "1d", "noqa", "e501", "columns", "year", "month", "day", "hour", "etr", "etrn", "ghi", "ghisource", "ghiuncertainty", "dni", "dnisource", "dniuncertainty", "dhi", "dhisource", "dhiuncertainty", "ghillum", "ghillumsource", "ghillumuncertainty", "dnillum", "dnillumsource", "dnillumuncertainty", "dhillum", "dhillumsource", "dhillumuncertainty", "zenithlum", "zenithlumsource", "zenithlumuncertainty", "totcld", "totcldsource", "totclduncertainty", "opqcld", "opqcldsource", "opqclduncertainty", "drybulb", "drybulbsource", "drybulbuncertainty", "dewpoint", "dewpointsource", "dewpointuncertainty", "rhum", "rhumsource", "rhumuncertainty", "pressure", "pressuresource", "pressureuncertainty", "wdir", "wdirsource", "wdiruncertainty", "wspd", "wspdsource", "wspduncertainty", "hvis", "hvissource", "hvisuncertainty", "ceilhgt", "ceilhgtsource", "ceilhgtuncertainty", "presentweather", "pwat", "pwatsource", "pwatuncertainty", "aod", "aodsource", "aoduncertainty", "snowdepth", "snowdepthsource", "snowdepthuncertainty", "lastsnowfall", "lastsnowfallsource", "lastsnowfalluncertaint", "noqa", "e501", "hdr_columns", "wban", "city", "state", "tz", "latitude", "longitude", "altitude", "tmy2", "tmy2_meta", "_read_tmy2", "string", "columns", "hdr_columns", "str", "filename", "return", "tmy2", "tmy2_meta"], "doc_len": 1154}
{"doc_id": "pvlib/iotools/tmy.py::_parsemeta_tmy2", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "_parsemeta_tmy2", "text": "文件路径: pvlib/iotools/tmy.py\ndef _parsemeta_tmy2(columns, line):\n    \"\"\"Retrieve metadata from the top line of the tmy2 file.\n\n    Parameters\n    ----------\n    columns : string\n        String of column headings in the header\n\n    line : string\n        Header string containing DataFrame\n\n    Returns\n    -------\n    meta : Dict of metadata contained in the header string\n    \"\"\"\n    # Remove duplicated spaces, and read in each element\n    rawmeta = \" \".join(line.split()).split(\" \")\n    meta = rawmeta[:3]  # take the first string entries\n    meta.append(int(rawmeta[3]))\n    # Convert to decimal notation with S negative\n    longitude = (\n        float(rawmeta[5]) + float(rawmeta[6])/60) * (2*(rawmeta[4] == 'N') - 1)\n    # Convert to decimal notation with W negative\n    latitude = (\n        float(rawmeta[8]) + float(rawmeta[9])/60) * (2*(rawmeta[7] == 'E') - 1)\n    meta.append(longitude)\n    meta.append(latitude)\n    meta.append(float(rawmeta[10]))\n\n    # Creates a dictionary of metadata\n    meta_dict = dict(zip(columns.split(','), meta))\n    return meta_dict\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "_parsemeta_tmy2", "columns", "line", "retrieve", "metadata", "from", "the", "top", "line", "of", "the", "tmy2", "file", "parameters", "columns", "string", "string", "of", "column", "headings", "in", "the", "header", "line", "string", "header", "string", "containing", "dataframe", "returns", "meta", "dict", "of", "metadata", "contained", "in", "the", "header", "string", "remove", "duplicated", "spaces", "and", "read", "in", "each", "element", "rawmeta", "join", "line", "split", "split", "meta", "rawmeta", "3", "take", "the", "first", "string", "entries", "meta", "append", "int", "rawmeta", "3", "convert", "to", "decimal", "notation", "with", "s", "negative", "longitude", "float", "rawmeta", "5", "float", "rawmeta", "6", "60", "2", "rawmeta", "4", "n", "1", "convert", "to", "decimal", "notation", "with", "w", "negative", "latitude", "float", "rawmeta", "8", "float", "rawmeta", "9", "60", "2", "rawmeta", "7", "e", "1", "meta", "append", "longitude", "meta", "append", "latitude", "meta", "append", "float", "rawmeta", "10", "creates", "a", "dictionary", "of", "metadata", "meta_dict", "dict", "zip", "columns", "split", "meta", "return", "meta_dict"], "doc_len": 134}
{"doc_id": "pvlib/iotools/tmy.py::_read_tmy2", "file_path": "pvlib/iotools/tmy.py", "class_name": null, "func_name": "_read_tmy2", "text": "文件路径: pvlib/iotools/tmy.py\ndef _read_tmy2(string, columns, hdr_columns, fname):\n    head = 1\n    date = []\n    with open(fname) as infile:\n        fline = 0\n        for line in infile:\n            # Skip the header\n            if head != 0:\n                meta = _parsemeta_tmy2(hdr_columns, line)\n                head -= 1\n                continue\n            # Reset the cursor and array for each line\n            cursor = 1\n            part = []\n            for marker in string.split('%'):\n                # Skip the first line of markers\n                if marker == '':\n                    continue\n\n                # Read the next increment from the marker list\n                increment = int(re.findall(r'\\d+', marker)[0])\n                next_cursor = cursor + increment\n\n                # Extract the value from the line in the file\n                val = (line[cursor:next_cursor])\n                # increment the cursor by the length of the read value\n                cursor = next_cursor\n\n                # Determine the datatype from the marker string\n                if marker[-1] == 'd':\n                    try:\n                        val = float(val)\n                    except ValueError:\n                        raise ValueError('WARNING: In {} Read value is not an '\n                                         'integer \" {} \" '.format(fname, val))\n                elif marker[-1] == 's':\n                    try:\n                        val = str(val)\n                    except ValueError:\n                        raise ValueError('WARNING: In {} Read value is not a '\n                                         'string \" {} \" '.format(fname, val))\n                else:\n                    raise Exception('WARNING: In {} Improper column DataFrame '\n                                    '\" %{} \" '.format(__name__, marker))\n\n                part.append(val)\n\n            if fline == 0:\n                axes = [part]\n                year = part[0] + 1900\n                fline = 1\n            else:\n                axes.append(part)\n\n            # Create datetime objects from read data\n            date.append(datetime.datetime(year=int(year),\n                                          month=int(part[1]),\n                                          day=int(part[2]),\n                                          hour=(int(part[3]) - 1)))\n\n    data = pd.DataFrame(\n        axes, index=date,\n        columns=columns.split(',')).tz_localize(int(meta['TZ'] * 3600))\n\n    return data, meta\n", "tokens": ["pvlib", "iotools", "tmy", "py", "def", "_read_tmy2", "string", "columns", "hdr_columns", "fname", "head", "1", "date", "with", "open", "fname", "as", "infile", "fline", "0", "for", "line", "in", "infile", "skip", "the", "header", "if", "head", "0", "meta", "_parsemeta_tmy2", "hdr_columns", "line", "head", "1", "continue", "reset", "the", "cursor", "and", "array", "for", "each", "line", "cursor", "1", "part", "for", "marker", "in", "string", "split", "skip", "the", "first", "line", "of", "markers", "if", "marker", "continue", "read", "the", "next", "increment", "from", "the", "marker", "list", "increment", "int", "re", "findall", "r", "d", "marker", "0", "next_cursor", "cursor", "increment", "extract", "the", "value", "from", "the", "line", "in", "the", "file", "val", "line", "cursor", "next_cursor", "increment", "the", "cursor", "by", "the", "length", "of", "the", "read", "value", "cursor", "next_cursor", "determine", "the", "datatype", "from", "the", "marker", "string", "if", "marker", "1", "d", "try", "val", "float", "val", "except", "valueerror", "raise", "valueerror", "warning", "in", "read", "value", "is", "not", "an", "integer", "format", "fname", "val", "elif", "marker", "1", "s", "try", "val", "str", "val", "except", "valueerror", "raise", "valueerror", "warning", "in", "read", "value", "is", "not", "a", "string", "format", "fname", "val", "else", "raise", "exception", "warning", "in", "improper", "column", "dataframe", "format", "__name__", "marker", "part", "append", "val", "if", "fline", "0", "axes", "part", "year", "part", "0", "1900", "fline", "1", "else", "axes", "append", "part", "create", "datetime", "objects", "from", "read", "data", "date", "append", "datetime", "datetime", "year", "int", "year", "month", "int", "part", "1", "day", "int", "part", "2", "hour", "int", "part", "3", "1", "data", "pd", "dataframe", "axes", "index", "date", "columns", "columns", "split", "tz_localize", "int", "meta", "tz", "3600", "return", "data", "meta"], "doc_len": 231}
{"doc_id": "pvlib/ivtools/sde.py::fit_sandia_simple", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "fit_sandia_simple", "text": "文件路径: pvlib/ivtools/sde.py\ndef fit_sandia_simple(voltage, current, v_oc=None, i_sc=None, v_mp_i_mp=None,\n                      vlim=0.2, ilim=0.1):\n    r\"\"\"\n    Fits the single diode equation (SDE) to an IV curve.\n\n    Parameters\n    ----------\n    voltage : ndarray\n        1D array of `float` type containing voltage at each point on the IV\n        curve, increasing from 0 to ``v_oc`` inclusive. [V]\n\n    current : ndarray\n        1D array of `float` type containing current at each point on the IV\n        curve, from ``i_sc`` to 0 inclusive. [A]\n\n    v_oc : float, default None\n        Open circuit voltage. If not provided, ``v_oc`` is taken as the\n        last point in the ``voltage`` array. [V]\n\n    i_sc : float, default None\n        Short circuit current. If not provided, ``i_sc`` is taken as the\n        first point in the ``current`` array. [A]\n\n    v_mp_i_mp : tuple of float, default None\n        Voltage, current at maximum power point. If not provided, the maximum\n        power point is found at the maximum of ``voltage`` \\times ``current``.\n        [V], [A]\n\n    vlim : float, default 0.2\n        Defines portion of IV curve where the exponential term in the single\n        diode equation can be neglected, i.e.\n        ``voltage`` <= ``vlim`` x ``v_oc``. [V]\n\n    ilim : float, default 0.1\n        Defines portion of the IV curve where the exponential term in the\n        single diode equation is significant, approximately defined by\n        ``current`` < (1 - ``ilim``) x ``i_sc``. [A]\n\n    Returns\n    -------\n    photocurrent : float\n        photocurrent [A]\n    saturation_current : float\n        dark (saturation) current [A]\n    resistance_series : float\n        series resistance [ohm]\n    resistance_shunt : float\n        shunt (parallel) resistance [ohm]\n    nNsVth : float\n        product of thermal voltage ``Vth`` [V], diode ideality factor\n        ``n``, and number of series cells ``Ns``. [V]\n\n    Raises\n    ------\n    RuntimeError if parameter extraction is not successful.\n\n    Notes\n    -----\n    Inputs ``voltage``, ``current``, ``v_oc``, ``i_sc`` and ``v_mp_i_mp`` are\n    assumed to be from a single IV curve at constant irradiance and cell\n    temperature.\n\n    :py:func:`fit_sandia_simple` obtains values for the five parameters for\n    the single diode equation [1]_:\n\n    .. math::\n\n        I = I_{L} - I_{0} (\\exp \\frac{V + I R_{s}}{nNsVth} - 1)\n        - \\frac{V + I R_{s}}{R_{sh}}\n\n    See :py:func:`pvlib.pvsystem.singlediode` for definition of the parameters.\n\n    The extraction method [2]_ proceeds in six steps.\n\n    1. In the single diode equation, replace :math:`R_{sh} = 1/G_{p}` and\n       re-arrange\n\n    .. math::\n\n        I = \\frac{I_{L}}{1 + G_{p} R_{s}} - \\frac{G_{p} V}{1 + G_{p} R_{s}}\n        - \\frac{I_{0}}{1 + G_{p} R_{s}} (\\exp(\\frac{V + I R_{s}}{nN_sV_{th}})\n        - 1)\n\n    2. The linear portion of the IV curve is defined as\n       :math:`V \\le vlim \\times v_{oc}`. Over this portion of the IV curve,\n\n    .. math::\n\n        \\frac{I_{0}}{1 + G_{p} R_{s}} (\\exp(\\frac{V + I R_{s}}{nN_sV_{th}})\n        - 1) \\approx 0\n\n    3. Fit the linear portion of the IV curve with a line.\n\n    .. math::\n\n        I &\\approx \\frac{I_{L}}{1 + G_{p} R_{s}}\n        - \\frac{G_{p}}{1 + G_{p}R_{s}} V\n        &= \\beta_{0} + \\beta_{1} V\n\n    4. The exponential portion of the IV curve is defined by\n       :math:`\\beta_{0} + \\beta_{1} \\times V - I > ilim \\times i_{sc}`.\n       Over this portion of the curve,\n       :math:`\\exp((V + IR_s)/{nN_sV_{th}}) \\gg 1` so that\n\n    .. math::\n\n        \\exp(\\frac{V + I R_{s}}{nN_sV_{th}}) - 1 \\approx\n        \\exp(\\frac{V + I R_{s}}{nN_sV_{th}})\n\n    5. Fit the exponential portion of the IV curve.\n\n    .. math::\n\n        \\log(\\beta_{0} - \\beta_{1} V - I)\n        &\\approx \\log(\\frac{I_{0}}{1 + G_{p} R_{s}} + \\frac{V}{nN_sV_{th}}\n        + \\frac{I R_{s}}{nN_sV_{th}}) \\\\\n        &= \\beta_{2} + \\beta_{3} V + \\beta_{4} I\n\n    6. Calculate values for ``IL, I0, Rs, Rsh,`` and ``nNsVth`` from the\n       regression coefficents :math:`\\beta_{0}, \\beta_{1}, \\beta_{3}` and\n       :math:`\\beta_{4}`.\n\n\n    References\n    ----------\n    .. [1] S.R. Wenham, M.A. Green, M.E. Watt, \"Applied Photovoltaics\" ISBN\n       0 86758 909 4\n    .. [2] C. B. Jones, C. W. Hansen, \"Single Diode Parameter Extraction from\n       In-Field Photovoltaic I-V Curves on a Single Board Computer\", 46th IEEE\n       Photovoltaic Specialist Conference, Chicago, IL, 2019\n    \"\"\"\n\n    # If not provided, extract v_oc, i_sc, v_mp and i_mp from the IV curve data\n    if v_oc is None:\n        v_oc = voltage[-1]\n    if i_sc is None:\n        i_sc = current[0]\n    if v_mp_i_mp is not None:\n        v_mp, i_mp = v_mp_i_mp\n    else:\n        v_mp, i_mp = _find_mp(voltage, current)\n\n    # Find beta0 and beta1 from linear portion of the IV curve\n    beta0, beta1 = _sandia_beta0_beta1(voltage, current, vlim, v_oc)\n\n    # Find beta3 and beta4 from the exponential portion of the IV curve\n    beta3, beta4 = _sandia_beta3_beta4(voltage, current, beta0, beta1, ilim,\n                                       i_sc)\n\n    # calculate single diode parameters from regression coefficients\n    return _sandia_simple_params(beta0, beta1, beta3, beta4, v_mp, i_mp, v_oc)\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "fit_sandia_simple", "voltage", "current", "v_oc", "none", "i_sc", "none", "v_mp_i_mp", "none", "vlim", "0", "2", "ilim", "0", "1", "r", "fits", "the", "single", "diode", "equation", "sde", "to", "an", "iv", "curve", "parameters", "voltage", "ndarray", "1d", "array", "of", "float", "type", "containing", "voltage", "at", "each", "point", "on", "the", "iv", "curve", "increasing", "from", "0", "to", "v_oc", "inclusive", "v", "current", "ndarray", "1d", "array", "of", "float", "type", "containing", "current", "at", "each", "point", "on", "the", "iv", "curve", "from", "i_sc", "to", "0", "inclusive", "a", "v_oc", "float", "default", "none", "open", "circuit", "voltage", "if", "not", "provided", "v_oc", "is", "taken", "as", "the", "last", "point", "in", "the", "voltage", "array", "v", "i_sc", "float", "default", "none", "short", "circuit", "current", "if", "not", "provided", "i_sc", "is", "taken", "as", "the", "first", "point", "in", "the", "current", "array", "a", "v_mp_i_mp", "tuple", "of", "float", "default", "none", "voltage", "current", "at", "maximum", "power", "point", "if", "not", "provided", "the", "maximum", "power", "point", "is", "found", "at", "the", "maximum", "of", "voltage", "times", "current", "v", "a", "vlim", "float", "default", "0", "2", "defines", "portion", "of", "iv", "curve", "where", "the", "exponential", "term", "in", "the", "single", "diode", "equation", "can", "be", "neglected", "i", "e", "voltage", "vlim", "x", "v_oc", "v", "ilim", "float", "default", "0", "1", "defines", "portion", "of", "the", "iv", "curve", "where", "the", "exponential", "term", "in", "the", "single", "diode", "equation", "is", "significant", "approximately", "defined", "by", "current", "1", "ilim", "x", "i_sc", "a", "returns", "photocurrent", "float", "photocurrent", "a", "saturation_current", "float", "dark", "saturation", "current", "a", "resistance_series", "float", "series", "resistance", "ohm", "resistance_shunt", "float", "shunt", "parallel", "resistance", "ohm", "nnsvth", "float", "product", "of", "thermal", "voltage", "vth", "v", "diode", "ideality", "factor", "n", "and", "number", "of", "series", "cells", "ns", "v", "raises", "runtimeerror", "if", "parameter", "extraction", "is", "not", "successful", "notes", "inputs", "voltage", "current", "v_oc", "i_sc", "and", "v_mp_i_mp", "are", "assumed", "to", "be", "from", "a", "single", "iv", "curve", "at", "constant", "irradiance", "and", "cell", "temperature", "py", "func", "fit_sandia_simple", "obtains", "values", "for", "the", "five", "parameters", "for", "the", "single", "diode", "equation", "1", "_", "math", "i", "i_", "l", "i_", "0", "exp", "frac", "v", "i", "r_", "s", "nnsvth", "1", "frac", "v", "i", "r_", "s", "r_", "sh", "see", "py", "func", "pvlib", "pvsystem", "singlediode", "for", "definition", "of", "the", "parameters", "the", "extraction", "method", "2", "_", "proceeds", "in", "six", "steps", "1", "in", "the", "single", "diode", "equation", "replace", "math", "r_", "sh", "1", "g_", "p", "and", "re", "arrange", "math", "i", "frac", "i_", "l", "1", "g_", "p", "r_", "s", "frac", "g_", "p", "v", "1", "g_", "p", "r_", "s", "frac", "i_", "0", "1", "g_", "p", "r_", "s", "exp", "frac", "v", "i", "r_", "s", "nn_sv_", "th", "1", "2", "the", "linear", "portion", "of", "the", "iv", "curve", "is", "defined", "as", "math", "v", "le", "vlim", "times", "v_", "oc", "over", "this", "portion", "of", "the", "iv", "curve", "math", "frac", "i_", "0", "1", "g_", "p", "r_", "s", "exp", "frac", "v", "i", "r_", "s", "nn_sv_", "th", "1", "approx", "0", "3", "fit", "the", "linear", "portion", "of", "the", "iv", "curve", "with", "a", "line", "math", "i", "approx", "frac", "i_", "l", "1", "g_", "p", "r_", "s", "frac", "g_", "p", "1", "g_", "p", "r_", "s", "v", "beta_", "0", "beta_", "1", "v", "4", "the", "exponential", "portion", "of", "the", "iv", "curve", "is", "defined", "by", "math", "beta_", "0", "beta_", "1", "times", "v", "i", "ilim", "times", "i_", "sc", "over", "this", "portion", "of", "the", "curve", "math", "exp", "v", "ir_s", "nn_sv_", "th", "gg", "1", "so", "that", "math", "exp", "frac", "v", "i", "r_", "s", "nn_sv_", "th", "1", "approx", "exp", "frac", "v", "i", "r_", "s", "nn_sv_", "th", "5", "fit", "the", "exponential", "portion", "of", "the", "iv", "curve", "math", "log", "beta_", "0", "beta_", "1", "v", "i", "approx", "log", "frac", "i_", "0", "1", "g_", "p", "r_", "s", "frac", "v", "nn_sv_", "th", "frac", "i", "r_", "s", "nn_sv_", "th", "beta_", "2", "beta_", "3", "v", "beta_", "4", "i", "6", "calculate", "values", "for", "il", "i0", "rs", "rsh", "and", "nnsvth", "from", "the", "regression", "coefficents", "math", "beta_", "0", "beta_", "1", "beta_", "3", "and", "math", "beta_", "4", "references", "1", "s", "r", "wenham", "m", "a", "green", "m", "e", "watt", "applied", "photovoltaics", "isbn", "0", "86758", "909", "4", "2", "c", "b", "jones", "c", "w", "hansen", "single", "diode", "parameter", "extraction", "from", "in", "field", "photovoltaic", "i", "v", "curves", "on", "a", "single", "board", "computer", "46th", "ieee", "photovoltaic", "specialist", "conference", "chicago", "il", "2019", "if", "not", "provided", "extract", "v_oc", "i_sc", "v_mp", "and", "i_mp", "from", "the", "iv", "curve", "data", "if", "v_oc", "is", "none", "v_oc", "voltage", "1", "if", "i_sc", "is", "none", "i_sc", "current", "0", "if", "v_mp_i_mp", "is", "not", "none", "v_mp", "i_mp", "v_mp_i_mp", "else", "v_mp", "i_mp", "_find_mp", "voltage", "current", "find", "beta0", "and", "beta1", "from", "linear", "portion", "of", "the", "iv", "curve", "beta0", "beta1", "_sandia_beta0_beta1", "voltage", "current", "vlim", "v_oc", "find", "beta3", "and", "beta4", "from", "the", "exponential", "portion", "of", "the", "iv", "curve", "beta3", "beta4", "_sandia_beta3_beta4", "voltage", "current", "beta0", "beta1", "ilim", "i_sc", "calculate", "single", "diode", "parameters", "from", "regression", "coefficients", "return", "_sandia_simple_params", "beta0", "beta1", "beta3", "beta4", "v_mp", "i_mp", "v_oc"], "doc_len": 748}
{"doc_id": "pvlib/ivtools/sde.py::_find_mp", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_find_mp", "text": "文件路径: pvlib/ivtools/sde.py\ndef _find_mp(voltage, current):\n    \"\"\"\n    Finds voltage and current at maximum power point.\n\n    Parameters\n    ----------\n    voltage : ndarray\n        1D array containing voltage at each point on the IV curve, increasing\n        from 0 to v_oc inclusive, of `float` type. [V]\n\n    current : ndarray\n        1D array containing current at each point on the IV curve, decreasing\n        from i_sc to 0 inclusive, of `float` type. [A]\n\n    Returns\n    -------\n    v_mp, i_mp : tuple\n        voltage ``v_mp`` and current ``i_mp`` at the maximum power point. [V],\n        [A]\n    \"\"\"\n    p = voltage * current\n    idx = np.argmax(p)\n    return voltage[idx], current[idx]\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_find_mp", "voltage", "current", "finds", "voltage", "and", "current", "at", "maximum", "power", "point", "parameters", "voltage", "ndarray", "1d", "array", "containing", "voltage", "at", "each", "point", "on", "the", "iv", "curve", "increasing", "from", "0", "to", "v_oc", "inclusive", "of", "float", "type", "v", "current", "ndarray", "1d", "array", "containing", "current", "at", "each", "point", "on", "the", "iv", "curve", "decreasing", "from", "i_sc", "to", "0", "inclusive", "of", "float", "type", "a", "returns", "v_mp", "i_mp", "tuple", "voltage", "v_mp", "and", "current", "i_mp", "at", "the", "maximum", "power", "point", "v", "a", "p", "voltage", "current", "idx", "np", "argmax", "p", "return", "voltage", "idx", "current", "idx"], "doc_len": 91}
{"doc_id": "pvlib/ivtools/sde.py::_sandia_beta0_beta1", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_sandia_beta0_beta1", "text": "文件路径: pvlib/ivtools/sde.py\ndef _sandia_beta0_beta1(v, i, vlim, v_oc):\n    # Used by fit_sandia_simple.\n    # Get intercept and slope of linear portion of IV curve.\n    # Start with V =< vlim * v_oc, extend by adding points until slope is\n    # negative (downward).\n    beta0 = np.nan\n    beta1 = np.nan\n    first_idx = np.searchsorted(v, vlim * v_oc)\n    for idx in range(first_idx, len(v)):\n        coef = np.polyfit(v[:idx], i[:idx], deg=1)\n        if coef[0] < 0:\n            # intercept term\n            beta0 = coef[1].item()\n            # sign change of slope to get positive parameter value\n            beta1 = -coef[0].item()\n            break\n    if any(np.isnan([beta0, beta1])):\n        raise RuntimeError(\"Parameter extraction failed: beta0={}, beta1={}\"\n                           .format(beta0, beta1))\n    else:\n        return beta0, beta1\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_sandia_beta0_beta1", "v", "i", "vlim", "v_oc", "used", "by", "fit_sandia_simple", "get", "intercept", "and", "slope", "of", "linear", "portion", "of", "iv", "curve", "start", "with", "v", "vlim", "v_oc", "extend", "by", "adding", "points", "until", "slope", "is", "negative", "downward", "beta0", "np", "nan", "beta1", "np", "nan", "first_idx", "np", "searchsorted", "v", "vlim", "v_oc", "for", "idx", "in", "range", "first_idx", "len", "v", "coef", "np", "polyfit", "v", "idx", "i", "idx", "deg", "1", "if", "coef", "0", "0", "intercept", "term", "beta0", "coef", "1", "item", "sign", "change", "of", "slope", "to", "get", "positive", "parameter", "value", "beta1", "coef", "0", "item", "break", "if", "any", "np", "isnan", "beta0", "beta1", "raise", "runtimeerror", "parameter", "extraction", "failed", "beta0", "beta1", "format", "beta0", "beta1", "else", "return", "beta0", "beta1"], "doc_len": 109}
{"doc_id": "pvlib/ivtools/sde.py::_sandia_beta3_beta4", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_sandia_beta3_beta4", "text": "文件路径: pvlib/ivtools/sde.py\ndef _sandia_beta3_beta4(voltage, current, beta0, beta1, ilim, i_sc):\n    # Used by fit_sde_sandia.\n    # Subtract the IV curve from the linear fit.\n    y = beta0 - beta1 * voltage - current\n    x = np.array([np.ones_like(voltage), voltage, current]).T\n    # Select points where y > ilim * i_sc to regress log(y) onto x\n    idx = (y > ilim * i_sc)\n    result = np.linalg.lstsq(x[idx], np.log(y[idx]), rcond=RCOND)\n    coef = result[0]\n    beta3 = coef[1].item()\n    beta4 = coef[2].item()\n    if any(np.isnan([beta3, beta4])):\n        raise RuntimeError(\"Parameter extraction failed: beta3={}, beta4={}\"\n                           .format(beta3, beta4))\n    else:\n        return beta3, beta4\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_sandia_beta3_beta4", "voltage", "current", "beta0", "beta1", "ilim", "i_sc", "used", "by", "fit_sde_sandia", "subtract", "the", "iv", "curve", "from", "the", "linear", "fit", "y", "beta0", "beta1", "voltage", "current", "x", "np", "array", "np", "ones_like", "voltage", "voltage", "current", "t", "select", "points", "where", "y", "ilim", "i_sc", "to", "regress", "log", "y", "onto", "x", "idx", "y", "ilim", "i_sc", "result", "np", "linalg", "lstsq", "x", "idx", "np", "log", "y", "idx", "rcond", "rcond", "coef", "result", "0", "beta3", "coef", "1", "item", "beta4", "coef", "2", "item", "if", "any", "np", "isnan", "beta3", "beta4", "raise", "runtimeerror", "parameter", "extraction", "failed", "beta3", "beta4", "format", "beta3", "beta4", "else", "return", "beta3", "beta4"], "doc_len": 96}
{"doc_id": "pvlib/ivtools/sde.py::_sandia_simple_params", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_sandia_simple_params", "text": "文件路径: pvlib/ivtools/sde.py\ndef _sandia_simple_params(beta0, beta1, beta3, beta4, v_mp, i_mp, v_oc):\n    # Used by fit_sandia_simple.\n    nNsVth = 1.0 / beta3\n    rs = beta4 / beta3\n    gsh = beta1 / (1.0 - rs * beta1)\n    rsh = 1.0 / gsh\n    iph = (1 + gsh * rs) * beta0\n    # calculate I0\n    io_vmp = _calc_I0(v_mp, i_mp, iph, gsh, rs, nNsVth)\n    io_voc = _calc_I0(v_oc, 0, iph, gsh, rs, nNsVth)\n    if any(np.isnan([io_vmp, io_voc])) or ((io_vmp <= 0) and (io_voc <= 0)):\n        raise RuntimeError(\"Parameter extraction failed: I0 is undetermined.\")\n    elif (io_vmp > 0) and (io_voc > 0):\n        io = 0.5 * (io_vmp + io_voc)\n    elif (io_vmp > 0):\n        io = io_vmp\n    else:  # io_voc > 0\n        io = io_voc\n    return iph, io, rs, rsh, nNsVth\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_sandia_simple_params", "beta0", "beta1", "beta3", "beta4", "v_mp", "i_mp", "v_oc", "used", "by", "fit_sandia_simple", "nnsvth", "1", "0", "beta3", "rs", "beta4", "beta3", "gsh", "beta1", "1", "0", "rs", "beta1", "rsh", "1", "0", "gsh", "iph", "1", "gsh", "rs", "beta0", "calculate", "i0", "io_vmp", "_calc_i0", "v_mp", "i_mp", "iph", "gsh", "rs", "nnsvth", "io_voc", "_calc_i0", "v_oc", "0", "iph", "gsh", "rs", "nnsvth", "if", "any", "np", "isnan", "io_vmp", "io_voc", "or", "io_vmp", "0", "and", "io_voc", "0", "raise", "runtimeerror", "parameter", "extraction", "failed", "i0", "is", "undetermined", "elif", "io_vmp", "0", "and", "io_voc", "0", "io", "0", "5", "io_vmp", "io_voc", "elif", "io_vmp", "0", "io", "io_vmp", "else", "io_voc", "0", "io", "io_voc", "return", "iph", "io", "rs", "rsh", "nnsvth"], "doc_len": 103}
{"doc_id": "pvlib/ivtools/sde.py::_calc_I0", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_calc_I0", "text": "文件路径: pvlib/ivtools/sde.py\ndef _calc_I0(voltage, current, iph, gsh, rs, nNsVth):\n    return (iph - current - gsh * (voltage + rs * current)) / \\\n        np.expm1((voltage + rs * current) / nNsVth)\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_calc_i0", "voltage", "current", "iph", "gsh", "rs", "nnsvth", "return", "iph", "current", "gsh", "voltage", "rs", "current", "np", "expm1", "voltage", "rs", "current", "nnsvth"], "doc_len": 25}
{"doc_id": "pvlib/ivtools/sde.py::_fit_sandia_cocontent", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_fit_sandia_cocontent", "text": "文件路径: pvlib/ivtools/sde.py\ndef _fit_sandia_cocontent(voltage, current, nsvth):\n    \"\"\"\n    Regression technique to fit the single diode equation to data for a single\n    IV curve.\n\n    In general, not reliable for estimating parameters other than Rsh.\n\n    Parameters\n    ----------\n    voltage : numeric\n        voltage for the IV curve in increasing order, the first value must be\n        0, the last value is taken as ``Voc``. [V]\n    current : numeric\n        current for the IV curve corresponding to ``voltage``, the first value\n        is taken as ``Isc``, the last value must be 0. [A]\n    nsvth : numeric\n        the thermal voltage for the module, equal to ``Ns`` (number of cells in\n        series) times ``Vth`` (thermal voltage per cell). [V]\n\n    Returns\n    -------\n    iph : numeric\n        photocurrent [A]\n    io : numeric\n        dark current [A]\n    rs : numeric\n        shunt resistance [ohm]\n    rsh : numeric\n        series resistance [ohm]\n    n : numeric\n        diode (ideality) factor [unitless]\n\n    Raises\n    ------\n    ValueError if ``voltage`` and ``current`` are different lengths.\n    ValueError if ``len(voltage)`` < 6\n\n    Notes\n    -----\n    Ported from PVLib Matlab [1]_. This function uses a regression technique\n    described in [2]_ to fit the single diode equation to data for a single IV\n    curve. The method extends ideas in [3]_ where the co-content is regressed\n    onto predictors involving voltage and current. Here, a principal component\n    transformation of ``(voltage, current)`` prior to regression to reduce the\n    effects of colinearity between voltage and current.\n    Although values for each of the five parameters are returned,\n    testing has shown that values for ``Rs``, ``Io`` and ``n`` may be negative\n    or imaginary even for IV curve data without obvious flaws.\n\n    References\n    ----------\n    .. [1] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    .. [2] C. Hansen, \"Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules\", Sandia National Laboratories Report SAND2015-2065\n    .. [3] A. Ortiz-Conde, F. Garci'a Sa'nchez, J. Murci, \"New method to\n       extract the model parameters of solar cells from the explicit analytic\n       solutions of their illuminated I-V characteristics\", Solar Energy\n       Materials and Solar Cells 90, pp 352 - 361, 2006.\n    \"\"\"\n\n    if len(current) != len(voltage):\n        raise ValueError(\"voltage and current should have the same \"\n                         \"length\")\n    if len(voltage) < 6:\n        raise ValueError(\"at least 6 voltage points are required; ~50 are \"\n                         \"recommended\")\n    isc = current[0]  # short circuit current\n    voc = voltage[-1]  # open circuit voltage\n\n    # Fit quadratic spline to IV curve in order to compute the co-content\n    # (i.e., integral of Isc - I over V) more accurately\n\n    [t, c, yhat, kflag] = _schumaker_qspline(voltage, current)\n\n    # Calculate co-content integral\n    cci = _cocontent(t, c, isc, kflag)\n\n    # Regress co-content onto voltage and current predictors\n    beta = _cocontent_regress(voltage, current, voc, isc, cci)\n\n    # Extract five parameter values from regression coefficients.\n    # Equation 11, [3]\n    betagp = beta[3] * 2.\n\n    # Equation 12, [3]\n    betars = (np.sqrt(1. + 16. * beta[3] * beta[4]) - 1.) / (4. * beta[3])\n\n    # Equation 13, [3]\n    betan = (beta[0] * (np.sqrt(1. + 16. * beta[3] * beta[4]) - 1.) + 4. *\n             beta[1] * beta[3]) / (4. * beta[3] * nsvth)\n\n    # Single diode equation at Voc, approximating Iph + Io by Isc\n    betaio = (isc - voc * betagp) / (np.exp(voc / (betan * nsvth)))\n\n    # Single diode equation at Isc, using Rsh, Rs, n and Io that were\n    # determined above\n    betaiph = isc - betaio + betaio * np.exp(isc / (betan * nsvth)) + \\\n        isc * betars * betagp\n\n    iph = betaiph\n    io = betaio\n    rsh = 1 / betagp\n    rs = betars\n    n = betan\n\n    return iph, io, rs, rsh, n\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_fit_sandia_cocontent", "voltage", "current", "nsvth", "regression", "technique", "to", "fit", "the", "single", "diode", "equation", "to", "data", "for", "a", "single", "iv", "curve", "in", "general", "not", "reliable", "for", "estimating", "parameters", "other", "than", "rsh", "parameters", "voltage", "numeric", "voltage", "for", "the", "iv", "curve", "in", "increasing", "order", "the", "first", "value", "must", "be", "0", "the", "last", "value", "is", "taken", "as", "voc", "v", "current", "numeric", "current", "for", "the", "iv", "curve", "corresponding", "to", "voltage", "the", "first", "value", "is", "taken", "as", "isc", "the", "last", "value", "must", "be", "0", "a", "nsvth", "numeric", "the", "thermal", "voltage", "for", "the", "module", "equal", "to", "ns", "number", "of", "cells", "in", "series", "times", "vth", "thermal", "voltage", "per", "cell", "v", "returns", "iph", "numeric", "photocurrent", "a", "io", "numeric", "dark", "current", "a", "rs", "numeric", "shunt", "resistance", "ohm", "rsh", "numeric", "series", "resistance", "ohm", "n", "numeric", "diode", "ideality", "factor", "unitless", "raises", "valueerror", "if", "voltage", "and", "current", "are", "different", "lengths", "valueerror", "if", "len", "voltage", "6", "notes", "ported", "from", "pvlib", "matlab", "1", "_", "this", "function", "uses", "a", "regression", "technique", "described", "in", "2", "_", "to", "fit", "the", "single", "diode", "equation", "to", "data", "for", "a", "single", "iv", "curve", "the", "method", "extends", "ideas", "in", "3", "_", "where", "the", "co", "content", "is", "regressed", "onto", "predictors", "involving", "voltage", "and", "current", "here", "a", "principal", "component", "transformation", "of", "voltage", "current", "prior", "to", "regression", "to", "reduce", "the", "effects", "of", "colinearity", "between", "voltage", "and", "current", "although", "values", "for", "each", "of", "the", "five", "parameters", "are", "returned", "testing", "has", "shown", "that", "values", "for", "rs", "io", "and", "n", "may", "be", "negative", "or", "imaginary", "even", "for", "iv", "curve", "data", "without", "obvious", "flaws", "references", "1", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "2", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "3", "a", "ortiz", "conde", "f", "garci", "a", "sa", "nchez", "j", "murci", "new", "method", "to", "extract", "the", "model", "parameters", "of", "solar", "cells", "from", "the", "explicit", "analytic", "solutions", "of", "their", "illuminated", "i", "v", "characteristics", "solar", "energy", "materials", "and", "solar", "cells", "90", "pp", "352", "361", "2006", "if", "len", "current", "len", "voltage", "raise", "valueerror", "voltage", "and", "current", "should", "have", "the", "same", "length", "if", "len", "voltage", "6", "raise", "valueerror", "at", "least", "6", "voltage", "points", "are", "required", "50", "are", "recommended", "isc", "current", "0", "short", "circuit", "current", "voc", "voltage", "1", "open", "circuit", "voltage", "fit", "quadratic", "spline", "to", "iv", "curve", "in", "order", "to", "compute", "the", "co", "content", "i", "e", "integral", "of", "isc", "i", "over", "v", "more", "accurately", "t", "c", "yhat", "kflag", "_schumaker_qspline", "voltage", "current", "calculate", "co", "content", "integral", "cci", "_cocontent", "t", "c", "isc", "kflag", "regress", "co", "content", "onto", "voltage", "and", "current", "predictors", "beta", "_cocontent_regress", "voltage", "current", "voc", "isc", "cci", "extract", "five", "parameter", "values", "from", "regression", "coefficients", "equation", "11", "3", "betagp", "beta", "3", "2", "equation", "12", "3", "betars", "np", "sqrt", "1", "16", "beta", "3", "beta", "4", "1", "4", "beta", "3", "equation", "13", "3", "betan", "beta", "0", "np", "sqrt", "1", "16", "beta", "3", "beta", "4", "1", "4", "beta", "1", "beta", "3", "4", "beta", "3", "nsvth", "single", "diode", "equation", "at", "voc", "approximating", "iph", "io", "by", "isc", "betaio", "isc", "voc", "betagp", "np", "exp", "voc", "betan", "nsvth", "single", "diode", "equation", "at", "isc", "using", "rsh", "rs", "n", "and", "io", "that", "were", "determined", "above", "betaiph", "isc", "betaio", "betaio", "np", "exp", "isc", "betan", "nsvth", "isc", "betars", "betagp", "iph", "betaiph", "io", "betaio", "rsh", "1", "betagp", "rs", "betars", "n", "betan", "return", "iph", "io", "rs", "rsh", "n"], "doc_len": 534}
{"doc_id": "pvlib/ivtools/sde.py::_cocontent", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_cocontent", "text": "文件路径: pvlib/ivtools/sde.py\ndef _cocontent(v, c, isc, kflag):\n    # Used by fit_sandia_cocontent\n    # calculate co-content integral by numerical integration of\n    # i = (Isc - I) over v\n    # Here, i = Isc - I is assumed to be represented by the quadratic spline\n    # with coefficients in input c, at the discrete sequence of knots in v\n    xn = len(v)\n    delx = v[1:] - v[:-1]\n    tmp = np.array([1. / 3., .5, 1.])\n    ss = np.tile(tmp, [xn - 1, 1])\n    cc = c * ss  # cast coefficients to a convenient shape\n    # compute integral on each interval\n    tmpint = np.sum(cc * np.array([delx ** 3, delx ** 2, delx]).T, 1)\n    tmpint = np.append(0., tmpint)\n\n    # compute co-content = Int_0^V (Isc - I) dV\n    scc = np.zeros(xn)\n    # Use trapezoid rule for the first 5 intervals due to spline being\n    # unreliable near the left endpoint\n    scc[0:5] = isc * v[0:5] - np.cumsum(tmpint[0:5])  # by spline\n    scc[5:(xn - 5)] = isc * (v[5:(xn - 5)] - v[4]) - \\\n        np.cumsum(tmpint[5:(xn - 5)]) + scc[4]\n\n    # Use trapezoid rule for the last 5 intervals due to spline being\n    # unreliable near the right endpoint\n    scc[(xn - 5):xn] = isc * (v[(xn - 5):xn] - v[xn - 6]) - \\\n        np.cumsum(tmpint[(xn - 5):xn]) + scc[xn - 6]\n\n    # For estimating diode equation parameters only use original data points,\n    # not at any knots added by the quadratic spline fit\n    cci = scc[~kflag.astype(bool)]\n    return cci\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_cocontent", "v", "c", "isc", "kflag", "used", "by", "fit_sandia_cocontent", "calculate", "co", "content", "integral", "by", "numerical", "integration", "of", "i", "isc", "i", "over", "v", "here", "i", "isc", "i", "is", "assumed", "to", "be", "represented", "by", "the", "quadratic", "spline", "with", "coefficients", "in", "input", "c", "at", "the", "discrete", "sequence", "of", "knots", "in", "v", "xn", "len", "v", "delx", "v", "1", "v", "1", "tmp", "np", "array", "1", "3", "5", "1", "ss", "np", "tile", "tmp", "xn", "1", "1", "cc", "c", "ss", "cast", "coefficients", "to", "a", "convenient", "shape", "compute", "integral", "on", "each", "interval", "tmpint", "np", "sum", "cc", "np", "array", "delx", "3", "delx", "2", "delx", "t", "1", "tmpint", "np", "append", "0", "tmpint", "compute", "co", "content", "int_0", "v", "isc", "i", "dv", "scc", "np", "zeros", "xn", "use", "trapezoid", "rule", "for", "the", "first", "5", "intervals", "due", "to", "spline", "being", "unreliable", "near", "the", "left", "endpoint", "scc", "0", "5", "isc", "v", "0", "5", "np", "cumsum", "tmpint", "0", "5", "by", "spline", "scc", "5", "xn", "5", "isc", "v", "5", "xn", "5", "v", "4", "np", "cumsum", "tmpint", "5", "xn", "5", "scc", "4", "use", "trapezoid", "rule", "for", "the", "last", "5", "intervals", "due", "to", "spline", "being", "unreliable", "near", "the", "right", "endpoint", "scc", "xn", "5", "xn", "isc", "v", "xn", "5", "xn", "v", "xn", "6", "np", "cumsum", "tmpint", "xn", "5", "xn", "scc", "xn", "6", "for", "estimating", "diode", "equation", "parameters", "only", "use", "original", "data", "points", "not", "at", "any", "knots", "added", "by", "the", "quadratic", "spline", "fit", "cci", "scc", "kflag", "astype", "bool", "return", "cci"], "doc_len": 233}
{"doc_id": "pvlib/ivtools/sde.py::_cocontent_regress", "file_path": "pvlib/ivtools/sde.py", "class_name": null, "func_name": "_cocontent_regress", "text": "文件路径: pvlib/ivtools/sde.py\ndef _cocontent_regress(v, i, voc, isc, cci):\n    # Used by fit_sandia_content\n    # For the method coded here see Appendix C of [2] SAND2015-2065\n    # predictor variables for regression of CC\n    x = np.vstack((v, isc - i, v * (isc - i), v * v, (i - isc) ** 2)).T\n\n    # define principal components transformation to shift, scale and rotate\n    # V and I before the regression.\n    tmpx = x[:, 0:2]\n    tmpx_length = tmpx.shape[0]\n\n    tmpx_mean = np.mean(tmpx, axis=0)\n    tmpx_std = np.std(tmpx, axis=0, ddof=1)\n    tmpx_zscore = (tmpx - np.tile(tmpx_mean, [tmpx_length, 1])) / \\\n        np.tile(tmpx_std, [tmpx_length, 1])\n\n    tmpx_d, tmpx_v = np.linalg.eig(np.cov(tmpx_zscore.T))\n\n    idx = np.argsort(tmpx_d)[::-1]\n\n    ev1 = tmpx_v[:, idx[0]]\n\n    # Second component set to be orthogonal and rotated counterclockwise by 90.\n    ev2 = np.dot(np.array([[0., -1.], [1., 0.]]), ev1)\n    r = np.array([ev1, ev2])  # principal components transformation\n\n    s = np.dot(tmpx_zscore, r)\n    # [V, I] shift and scaled by zscore, rotated by r\n\n    scc = cci - np.mean(cci, axis=0)  # center co-content values\n    col1 = np.ones(len(scc))\n\n    # predictors. Shifting makes a constant term necessary in the regression\n    # model\n    sx = np.vstack((s[:, 0], s[:, 1], s[:, 0] * s[:, 1], s[:, 0] * s[:, 0],\n                    s[:, 1] * s[:, 1], col1)).T\n\n    gamma = np.linalg.lstsq(sx, scc, rcond=RCOND)[0]\n    # coefficients from regression in rotated coordinates\n\n    # Principle components transformation steps\n    # Matrix which relates principal components transformation R to the mapping\n    # between [V' I' V'I' V'^2 I'^2] and sx, where prime ' indicates shifted\n    # and scaled data. Used to translate from regression coefficients in\n    # rotated coordinates to coefficients in initial V, I coordinates.\n    mb = np.array([[r[0, 0], r[1, 0], 0., 0., 0.], [r[0, 1], r[1, 1], 0., 0.,\n                                                    0.],\n                   [0., 0., r[0, 0] * r[1, 1] + r[0, 1] * r[1, 0], 2. *\n                    r[0, 0] * r[0, 1], 2. * r[1, 0] * r[1, 1]],\n                   [0., 0., r[0, 0] * r[1, 0], r[0, 0] ** 2., r[1, 0] ** 2.],\n                   [0., 0., r[0, 1] * r[1, 1], r[0, 1] ** 2., r[1, 1] ** 2.]])\n\n    # matrix which is used to undo effect of shifting and scaling on regression\n    # coefficients.\n    ma = np.array([[np.std(v, ddof=1), 0., np.std(v, ddof=1) *\n                    np.mean(isc - i), 2. * np.std(v, ddof=1) * np.mean(v),\n                   0.], [0., np.std(isc - i, ddof=1), np.std(isc - i, ddof=1)\n                         * np.mean(v), 0.,\n                   2. * np.std(isc - i, ddof=1) * np.mean(isc - i)],\n                   [0., 0., np.std(v, ddof=1) * np.std(isc - i, ddof=1), 0.,\n                    0.],\n                   [0., 0., 0., np.std(v, ddof=1) ** 2., 0.],\n                   [0., 0., 0., 0., np.std(isc - i, ddof=1) ** 2.]])\n\n    # translate from coefficients in rotated space (gamma) to coefficients in\n    # original coordinates (beta)\n    beta = np.linalg.lstsq(np.dot(mb, ma), gamma[0:5], rcond=RCOND)[0]\n    return beta\n", "tokens": ["pvlib", "ivtools", "sde", "py", "def", "_cocontent_regress", "v", "i", "voc", "isc", "cci", "used", "by", "fit_sandia_content", "for", "the", "method", "coded", "here", "see", "appendix", "c", "of", "2", "sand2015", "2065", "predictor", "variables", "for", "regression", "of", "cc", "x", "np", "vstack", "v", "isc", "i", "v", "isc", "i", "v", "v", "i", "isc", "2", "t", "define", "principal", "components", "transformation", "to", "shift", "scale", "and", "rotate", "v", "and", "i", "before", "the", "regression", "tmpx", "x", "0", "2", "tmpx_length", "tmpx", "shape", "0", "tmpx_mean", "np", "mean", "tmpx", "axis", "0", "tmpx_std", "np", "std", "tmpx", "axis", "0", "ddof", "1", "tmpx_zscore", "tmpx", "np", "tile", "tmpx_mean", "tmpx_length", "1", "np", "tile", "tmpx_std", "tmpx_length", "1", "tmpx_d", "tmpx_v", "np", "linalg", "eig", "np", "cov", "tmpx_zscore", "t", "idx", "np", "argsort", "tmpx_d", "1", "ev1", "tmpx_v", "idx", "0", "second", "component", "set", "to", "be", "orthogonal", "and", "rotated", "counterclockwise", "by", "90", "ev2", "np", "dot", "np", "array", "0", "1", "1", "0", "ev1", "r", "np", "array", "ev1", "ev2", "principal", "components", "transformation", "s", "np", "dot", "tmpx_zscore", "r", "v", "i", "shift", "and", "scaled", "by", "zscore", "rotated", "by", "r", "scc", "cci", "np", "mean", "cci", "axis", "0", "center", "co", "content", "values", "col1", "np", "ones", "len", "scc", "predictors", "shifting", "makes", "a", "constant", "term", "necessary", "in", "the", "regression", "model", "sx", "np", "vstack", "s", "0", "s", "1", "s", "0", "s", "1", "s", "0", "s", "0", "s", "1", "s", "1", "col1", "t", "gamma", "np", "linalg", "lstsq", "sx", "scc", "rcond", "rcond", "0", "coefficients", "from", "regression", "in", "rotated", "coordinates", "principle", "components", "transformation", "steps", "matrix", "which", "relates", "principal", "components", "transformation", "r", "to", "the", "mapping", "between", "v", "i", "v", "i", "v", "2", "i", "2", "and", "sx", "where", "prime", "indicates", "shifted", "and", "scaled", "data", "used", "to", "translate", "from", "regression", "coefficients", "in", "rotated", "coordinates", "to", "coefficients", "in", "initial", "v", "i", "coordinates", "mb", "np", "array", "r", "0", "0", "r", "1", "0", "0", "0", "0", "r", "0", "1", "r", "1", "1", "0", "0", "0", "0", "0", "r", "0", "0", "r", "1", "1", "r", "0", "1", "r", "1", "0", "2", "r", "0", "0", "r", "0", "1", "2", "r", "1", "0", "r", "1", "1", "0", "0", "r", "0", "0", "r", "1", "0", "r", "0", "0", "2", "r", "1", "0", "2", "0", "0", "r", "0", "1", "r", "1", "1", "r", "0", "1", "2", "r", "1", "1", "2", "matrix", "which", "is", "used", "to", "undo", "effect", "of", "shifting", "and", "scaling", "on", "regression", "coefficients", "ma", "np", "array", "np", "std", "v", "ddof", "1", "0", "np", "std", "v", "ddof", "1", "np", "mean", "isc", "i", "2", "np", "std", "v", "ddof", "1", "np", "mean", "v", "0", "0", "np", "std", "isc", "i", "ddof", "1", "np", "std", "isc", "i", "ddof", "1", "np", "mean", "v", "0", "2", "np", "std", "isc", "i", "ddof", "1", "np", "mean", "isc", "i", "0", "0", "np", "std", "v", "ddof", "1", "np", "std", "isc", "i", "ddof", "1", "0", "0", "0", "0", "0", "np", "std", "v", "ddof", "1", "2", "0", "0", "0", "0", "0", "np", "std", "isc", "i", "ddof", "1", "2", "translate", "from", "coefficients", "in", "rotated", "space", "gamma", "to", "coefficients", "in", "original", "coordinates", "beta", "beta", "np", "linalg", "lstsq", "np", "dot", "mb", "ma", "gamma", "0", "5", "rcond", "rcond", "0", "return", "beta"], "doc_len": 485}
{"doc_id": "pvlib/ivtools/sdm.py::fit_cec_sam", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "fit_cec_sam", "text": "文件路径: pvlib/ivtools/sdm.py\ndef fit_cec_sam(celltype, v_mp, i_mp, v_oc, i_sc, alpha_sc, beta_voc,\n                gamma_pmp, cells_in_series, temp_ref=25):\n    \"\"\"\n    Estimates parameters for the CEC single diode model (SDM) using the SAM\n    SDK.\n\n    Parameters\n    ----------\n    celltype : str\n        Value is one of 'monoSi', 'multiSi', 'polySi', 'cis', 'cigs', 'cdte',\n        'amorphous'\n    v_mp : float\n        Voltage at maximum power point [V]\n    i_mp : float\n        Current at maximum power point [A]\n    v_oc : float\n        Open circuit voltage [V]\n    i_sc : float\n        Short circuit current [A]\n    alpha_sc : float\n        Temperature coefficient of short circuit current [A/C]\n    beta_voc : float\n        Temperature coefficient of open circuit voltage [V/C]\n    gamma_pmp : float\n        Temperature coefficient of power at maximum point point [%/C]\n    cells_in_series : int\n        Number of cells in series\n    temp_ref : float, default 25\n        Reference temperature condition [C]\n\n    Returns\n    -------\n    I_L_ref : float\n        The light-generated current (or photocurrent) at reference\n        conditions [A]\n    I_o_ref : float\n        The dark or diode reverse saturation current at reference\n        conditions [A]\n    R_s : float\n        The series resistance at reference conditions, in ohms.\n    R_sh_ref : float\n        The shunt resistance at reference conditions, in ohms.\n    a_ref : float\n        The product of the usual diode ideality factor ``n`` (unitless),\n        number of cells in series ``Ns``, and cell thermal voltage at\n        reference conditions [V]\n    Adjust : float\n        The adjustment to the temperature coefficient for short circuit\n        current, in percent.\n\n    Raises\n    ------\n        ImportError if NREL-PySAM is not installed.\n\n        RuntimeError if parameter extraction is not successful.\n\n    Notes\n    -----\n    The CEC model and estimation method  are described in [1]_.\n    Inputs ``v_mp``, ``i_mp``, ``v_oc`` and ``i_sc`` are assumed to be from a\n    single IV curve at constant irradiance and cell temperature. Irradiance is\n    not explicitly used by the fitting procedure. The irradiance level at which\n    the input IV curve is determined and the specified cell temperature\n    ``temp_ref`` are the reference conditions for the output parameters\n    ``I_L_ref``, ``I_o_ref``, ``R_s``, ``R_sh_ref``, ``a_ref`` and ``Adjust``.\n\n    References\n    ----------\n    .. [1] A. Dobos, \"An Improved Coefficient Calculator for the California\n       Energy Commission 6 Parameter Photovoltaic Module Model\", Journal of\n       Solar Energy Engineering, vol 134, 2012.\n    \"\"\"\n\n    try:\n        from PySAM import PySSC\n    except ImportError:\n        raise ImportError(\"Requires NREL's PySAM package at \"\n                          \"https://pypi.org/project/NREL-PySAM/.\")\n\n    datadict = {'tech_model': '6parsolve', 'financial_model': None,\n                'celltype': celltype, 'Vmp': v_mp,\n                'Imp': i_mp, 'Voc': v_oc, 'Isc': i_sc, 'alpha_isc': alpha_sc,\n                'beta_voc': beta_voc, 'gamma_pmp': gamma_pmp,\n                'Nser': cells_in_series, 'Tref': temp_ref}\n\n    result = PySSC.ssc_sim_from_dict(datadict)\n    if result['cmod_success'] == 1:\n        return tuple([result[k] for k in ['Il', 'Io', 'Rs', 'Rsh', 'a',\n                      'Adj']])\n    else:\n        raise RuntimeError('Parameter estimation failed')\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "fit_cec_sam", "celltype", "v_mp", "i_mp", "v_oc", "i_sc", "alpha_sc", "beta_voc", "gamma_pmp", "cells_in_series", "temp_ref", "25", "estimates", "parameters", "for", "the", "cec", "single", "diode", "model", "sdm", "using", "the", "sam", "sdk", "parameters", "celltype", "str", "value", "is", "one", "of", "monosi", "multisi", "polysi", "cis", "cigs", "cdte", "amorphous", "v_mp", "float", "voltage", "at", "maximum", "power", "point", "v", "i_mp", "float", "current", "at", "maximum", "power", "point", "a", "v_oc", "float", "open", "circuit", "voltage", "v", "i_sc", "float", "short", "circuit", "current", "a", "alpha_sc", "float", "temperature", "coefficient", "of", "short", "circuit", "current", "a", "c", "beta_voc", "float", "temperature", "coefficient", "of", "open", "circuit", "voltage", "v", "c", "gamma_pmp", "float", "temperature", "coefficient", "of", "power", "at", "maximum", "point", "point", "c", "cells_in_series", "int", "number", "of", "cells", "in", "series", "temp_ref", "float", "default", "25", "reference", "temperature", "condition", "c", "returns", "i_l_ref", "float", "the", "light", "generated", "current", "or", "photocurrent", "at", "reference", "conditions", "a", "i_o_ref", "float", "the", "dark", "or", "diode", "reverse", "saturation", "current", "at", "reference", "conditions", "a", "r_s", "float", "the", "series", "resistance", "at", "reference", "conditions", "in", "ohms", "r_sh_ref", "float", "the", "shunt", "resistance", "at", "reference", "conditions", "in", "ohms", "a_ref", "float", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "reference", "conditions", "v", "adjust", "float", "the", "adjustment", "to", "the", "temperature", "coefficient", "for", "short", "circuit", "current", "in", "percent", "raises", "importerror", "if", "nrel", "pysam", "is", "not", "installed", "runtimeerror", "if", "parameter", "extraction", "is", "not", "successful", "notes", "the", "cec", "model", "and", "estimation", "method", "are", "described", "in", "1", "_", "inputs", "v_mp", "i_mp", "v_oc", "and", "i_sc", "are", "assumed", "to", "be", "from", "a", "single", "iv", "curve", "at", "constant", "irradiance", "and", "cell", "temperature", "irradiance", "is", "not", "explicitly", "used", "by", "the", "fitting", "procedure", "the", "irradiance", "level", "at", "which", "the", "input", "iv", "curve", "is", "determined", "and", "the", "specified", "cell", "temperature", "temp_ref", "are", "the", "reference", "conditions", "for", "the", "output", "parameters", "i_l_ref", "i_o_ref", "r_s", "r_sh_ref", "a_ref", "and", "adjust", "references", "1", "a", "dobos", "an", "improved", "coefficient", "calculator", "for", "the", "california", "energy", "commission", "6", "parameter", "photovoltaic", "module", "model", "journal", "of", "solar", "energy", "engineering", "vol", "134", "2012", "try", "from", "pysam", "import", "pyssc", "except", "importerror", "raise", "importerror", "requires", "nrel", "s", "pysam", "package", "at", "https", "pypi", "org", "project", "nrel", "pysam", "datadict", "tech_model", "6parsolve", "financial_model", "none", "celltype", "celltype", "vmp", "v_mp", "imp", "i_mp", "voc", "v_oc", "isc", "i_sc", "alpha_isc", "alpha_sc", "beta_voc", "beta_voc", "gamma_pmp", "gamma_pmp", "nser", "cells_in_series", "tref", "temp_ref", "result", "pyssc", "ssc_sim_from_dict", "datadict", "if", "result", "cmod_success", "1", "return", "tuple", "result", "k", "for", "k", "in", "il", "io", "rs", "rsh", "a", "adj", "else", "raise", "runtimeerror", "parameter", "estimation", "failed"], "doc_len": 392}
{"doc_id": "pvlib/ivtools/sdm.py::fit_desoto", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "fit_desoto", "text": "文件路径: pvlib/ivtools/sdm.py\ndef fit_desoto(v_mp, i_mp, v_oc, i_sc, alpha_sc, beta_voc, cells_in_series,\n               EgRef=1.121, dEgdT=-0.0002677, temp_ref=25, irrad_ref=1000,\n               root_kwargs={}):\n    \"\"\"\n    Calculates the parameters for the De Soto single diode model.\n\n    This procedure (described in [1]_) has the advantage of\n    using common specifications given by manufacturers in the\n    datasheets of PV modules.\n\n    The solution is found using the scipy.optimize.root() function,\n    with the corresponding default solver method 'hybr'.\n    No restriction is put on the fit variables, i.e. series\n    or shunt resistance could go negative. Nevertheless, if it happens,\n    check carefully the inputs and their units; alpha_sc and beta_voc are\n    often given in %/K in manufacturers datasheets and should be given\n    in A/K and V/K here.\n\n    The parameters returned by this function can be used by\n    :py:func:`pvlib.pvsystem.calcparams_desoto` to calculate the values at\n    different irradiance and cell temperature.\n\n    Parameters\n    ----------\n    v_mp: float\n        Module voltage at the maximum-power point at reference conditions [V].\n    i_mp: float\n        Module current at the maximum-power point at reference conditions [A].\n    v_oc: float\n        Open-circuit voltage at reference conditions [V].\n    i_sc: float\n        Short-circuit current at reference conditions [A].\n    alpha_sc: float\n        The short-circuit current (i_sc) temperature coefficient of the\n        module [A/K].\n    beta_voc: float\n        The open-circuit voltage (v_oc) temperature coefficient of the\n        module [V/K].\n    cells_in_series: integer\n        Number of cell in the module.\n    EgRef: float, default 1.121 eV - value for silicon\n        Energy of bandgap of semi-conductor used [eV]\n    dEgdT: float, default -0.0002677 - value for silicon\n        Variation of bandgap according to temperature [eV/K]\n    temp_ref: float, default 25\n        Reference temperature condition [C]\n    irrad_ref: float, default 1000\n        Reference irradiance condition [W/m2]\n    root_kwargs: dictionary, default None\n        Dictionary of arguments to pass onto scipy.optimize.root()\n\n    Returns\n    -------\n    dict with the following elements:\n        I_L_ref: float\n            Light-generated current at reference conditions [A]\n        I_o_ref: float\n            Diode saturation current at reference conditions [A]\n        R_s: float\n            Series resistance [ohm]\n        R_sh_ref: float\n            Shunt resistance at reference conditions [ohm].\n        a_ref: float\n            Modified ideality factor at reference conditions.\n            The product of the usual diode ideality factor (n, unitless),\n            number of cells in series (Ns), and cell thermal voltage at\n            specified effective irradiance and cell temperature.\n        alpha_sc: float\n            The short-circuit current (i_sc) temperature coefficient of the\n            module [A/K].\n        EgRef: float\n            Energy of bandgap of semi-conductor used [eV]\n        dEgdT: float\n            Variation of bandgap according to temperature [eV/K]\n        irrad_ref: float\n            Reference irradiance condition [W/m2]\n        temp_ref: float\n            Reference temperature condition [C]\n\n    scipy.optimize.OptimizeResult\n        Optimization result of scipy.optimize.root().\n        See scipy.optimize.OptimizeResult for more details.\n\n    References\n    ----------\n    .. [1] W. De Soto et al., \"Improvement and validation of a model for\n       photovoltaic array performance\", Solar Energy, vol 80, pp. 78-88,\n       2006.\n    \"\"\"\n\n    # Constants\n    k = scipy.constants.value('Boltzmann constant in eV/K')\n    Tref = temp_ref + 273.15  # [K]\n\n    # initial guesses of variables for computing convergence:\n    # Values are taken from [2], p753\n    Rsh_0 = 100.0\n    a_0 = 1.5*k*Tref*cells_in_series\n    IL_0 = i_sc\n    Io_0 = i_sc * np.exp(-v_oc/a_0)\n    Rs_0 = (a_0*np.log1p((IL_0-i_mp)/Io_0) - v_mp)/i_mp\n    # params_i : initial values vector\n    params_i = np.array([IL_0, Io_0, Rs_0, Rsh_0, a_0])\n\n    # specs of module\n    specs = (i_sc, v_oc, i_mp, v_mp, beta_voc, alpha_sc, EgRef, dEgdT,\n             Tref, k)\n\n    # computing with system of equations described in [1]\n    optimize_result = optimize.root(_system_of_equations_desoto, x0=params_i,\n                                    args=(specs,), **root_kwargs)\n\n    if optimize_result.success:\n        sdm_params = optimize_result.x\n    else:\n        raise RuntimeError(\n            'Parameter estimation failed:\\n' + optimize_result.message)\n\n    # results\n    return ({'I_L_ref': sdm_params[0],\n             'I_o_ref': sdm_params[1],\n             'R_s': sdm_params[2],\n             'R_sh_ref': sdm_params[3],\n             'a_ref': sdm_params[4],\n             'alpha_sc': alpha_sc,\n             'EgRef': EgRef,\n             'dEgdT': dEgdT,\n             'irrad_ref': irrad_ref,\n             'temp_ref': temp_ref},\n            optimize_result)\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "fit_desoto", "v_mp", "i_mp", "v_oc", "i_sc", "alpha_sc", "beta_voc", "cells_in_series", "egref", "1", "121", "degdt", "0", "0002677", "temp_ref", "25", "irrad_ref", "1000", "root_kwargs", "calculates", "the", "parameters", "for", "the", "de", "soto", "single", "diode", "model", "this", "procedure", "described", "in", "1", "_", "has", "the", "advantage", "of", "using", "common", "specifications", "given", "by", "manufacturers", "in", "the", "datasheets", "of", "pv", "modules", "the", "solution", "is", "found", "using", "the", "scipy", "optimize", "root", "function", "with", "the", "corresponding", "default", "solver", "method", "hybr", "no", "restriction", "is", "put", "on", "the", "fit", "variables", "i", "e", "series", "or", "shunt", "resistance", "could", "go", "negative", "nevertheless", "if", "it", "happens", "check", "carefully", "the", "inputs", "and", "their", "units", "alpha_sc", "and", "beta_voc", "are", "often", "given", "in", "k", "in", "manufacturers", "datasheets", "and", "should", "be", "given", "in", "a", "k", "and", "v", "k", "here", "the", "parameters", "returned", "by", "this", "function", "can", "be", "used", "by", "py", "func", "pvlib", "pvsystem", "calcparams_desoto", "to", "calculate", "the", "values", "at", "different", "irradiance", "and", "cell", "temperature", "parameters", "v_mp", "float", "module", "voltage", "at", "the", "maximum", "power", "point", "at", "reference", "conditions", "v", "i_mp", "float", "module", "current", "at", "the", "maximum", "power", "point", "at", "reference", "conditions", "a", "v_oc", "float", "open", "circuit", "voltage", "at", "reference", "conditions", "v", "i_sc", "float", "short", "circuit", "current", "at", "reference", "conditions", "a", "alpha_sc", "float", "the", "short", "circuit", "current", "i_sc", "temperature", "coefficient", "of", "the", "module", "a", "k", "beta_voc", "float", "the", "open", "circuit", "voltage", "v_oc", "temperature", "coefficient", "of", "the", "module", "v", "k", "cells_in_series", "integer", "number", "of", "cell", "in", "the", "module", "egref", "float", "default", "1", "121", "ev", "value", "for", "silicon", "energy", "of", "bandgap", "of", "semi", "conductor", "used", "ev", "degdt", "float", "default", "0", "0002677", "value", "for", "silicon", "variation", "of", "bandgap", "according", "to", "temperature", "ev", "k", "temp_ref", "float", "default", "25", "reference", "temperature", "condition", "c", "irrad_ref", "float", "default", "1000", "reference", "irradiance", "condition", "w", "m2", "root_kwargs", "dictionary", "default", "none", "dictionary", "of", "arguments", "to", "pass", "onto", "scipy", "optimize", "root", "returns", "dict", "with", "the", "following", "elements", "i_l_ref", "float", "light", "generated", "current", "at", "reference", "conditions", "a", "i_o_ref", "float", "diode", "saturation", "current", "at", "reference", "conditions", "a", "r_s", "float", "series", "resistance", "ohm", "r_sh_ref", "float", "shunt", "resistance", "at", "reference", "conditions", "ohm", "a_ref", "float", "modified", "ideality", "factor", "at", "reference", "conditions", "the", "product", "of", "the", "usual", "diode", "ideality", "factor", "n", "unitless", "number", "of", "cells", "in", "series", "ns", "and", "cell", "thermal", "voltage", "at", "specified", "effective", "irradiance", "and", "cell", "temperature", "alpha_sc", "float", "the", "short", "circuit", "current", "i_sc", "temperature", "coefficient", "of", "the", "module", "a", "k", "egref", "float", "energy", "of", "bandgap", "of", "semi", "conductor", "used", "ev", "degdt", "float", "variation", "of", "bandgap", "according", "to", "temperature", "ev", "k", "irrad_ref", "float", "reference", "irradiance", "condition", "w", "m2", "temp_ref", "float", "reference", "temperature", "condition", "c", "scipy", "optimize", "optimizeresult", "optimization", "result", "of", "scipy", "optimize", "root", "see", "scipy", "optimize", "optimizeresult", "for", "more", "details", "references", "1", "w", "de", "soto", "et", "al", "improvement", "and", "validation", "of", "a", "model", "for", "photovoltaic", "array", "performance", "solar", "energy", "vol", "80", "pp", "78", "88", "2006", "constants", "k", "scipy", "constants", "value", "boltzmann", "constant", "in", "ev", "k", "tref", "temp_ref", "273", "15", "k", "initial", "guesses", "of", "variables", "for", "computing", "convergence", "values", "are", "taken", "from", "2", "p753", "rsh_0", "100", "0", "a_0", "1", "5", "k", "tref", "cells_in_series", "il_0", "i_sc", "io_0", "i_sc", "np", "exp", "v_oc", "a_0", "rs_0", "a_0", "np", "log1p", "il_0", "i_mp", "io_0", "v_mp", "i_mp", "params_i", "initial", "values", "vector", "params_i", "np", "array", "il_0", "io_0", "rs_0", "rsh_0", "a_0", "specs", "of", "module", "specs", "i_sc", "v_oc", "i_mp", "v_mp", "beta_voc", "alpha_sc", "egref", "degdt", "tref", "k", "computing", "with", "system", "of", "equations", "described", "in", "1", "optimize_result", "optimize", "root", "_system_of_equations_desoto", "x0", "params_i", "args", "specs", "root_kwargs", "if", "optimize_result", "success", "sdm_params", "optimize_result", "x", "else", "raise", "runtimeerror", "parameter", "estimation", "failed", "n", "optimize_result", "message", "results", "return", "i_l_ref", "sdm_params", "0", "i_o_ref", "sdm_params", "1", "r_s", "sdm_params", "2", "r_sh_ref", "sdm_params", "3", "a_ref", "sdm_params", "4", "alpha_sc", "alpha_sc", "egref", "egref", "degdt", "degdt", "irrad_ref", "irrad_ref", "temp_ref", "temp_ref", "optimize_result"], "doc_len": 592}
{"doc_id": "pvlib/ivtools/sdm.py::_system_of_equations_desoto", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_system_of_equations_desoto", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _system_of_equations_desoto(params, specs):\n    \"\"\"Evaluates the systems of equations used to solve for the single\n    diode equation parameters. Function designed to be used by\n    scipy.optimize.root in fit_desoto.\n\n    Parameters\n    ----------\n    params: ndarray\n        Array with parameters of the De Soto single diode model. Must be\n        given in the following order: IL, Io, a, Rs, Rsh\n    specs: tuple\n        Specifications of pv module given by manufacturer. Must be given\n        in the following order: Isc, Voc, Imp, Vmp, beta_oc, alpha_sc\n\n    Returns\n    -------\n    value of the system of equations to solve with scipy.optimize.root().\n    \"\"\"\n\n    # six input known variables\n    Isc, Voc, Imp, Vmp, beta_oc, alpha_sc, EgRef, dEgdT, Tref, k = specs\n\n    # five parameters vector to find\n    IL, Io, Rs, Rsh, a = params\n\n    # five equation vector\n    y = [0, 0, 0, 0, 0]\n\n    # 1st equation - short-circuit - eq(3) in [1]\n    y[0] = Isc - IL + Io * np.expm1(Isc * Rs / a) + Isc * Rs / Rsh\n\n    # 2nd equation - open-circuit Tref - eq(4) in [1]\n    y[1] = -IL + Io * np.expm1(Voc / a) + Voc / Rsh\n\n    # 3rd equation - Imp & Vmp - eq(5) in [1]\n    y[2] = Imp - IL + Io * np.expm1((Vmp + Imp * Rs) / a) \\\n        + (Vmp + Imp * Rs) / Rsh\n\n    # 4th equation - Pmp derivated=0 - eq23.2.6 in [2]\n    # caution: eq(6) in [1] has a sign error\n    y[3] = Imp \\\n        - Vmp * ((Io / a) * np.exp((Vmp + Imp * Rs) / a) + 1.0 / Rsh) \\\n        / (1.0 + (Io * Rs / a) * np.exp((Vmp + Imp * Rs) / a) + Rs / Rsh)\n\n    # 5th equation - open-circuit T2 - eq (4) at temperature T2 in [1]\n    T2 = Tref + 2\n    Voc2 = (T2 - Tref) * beta_oc + Voc  # eq (7) in [1]\n    a2 = a * T2 / Tref  # eq (8) in [1]\n    IL2 = IL + alpha_sc * (T2 - Tref)  # eq (11) in [1]\n    Eg2 = EgRef * (1 + dEgdT * (T2 - Tref))  # eq (10) in [1]\n    Io2 = Io * (T2 / Tref)**3 * np.exp(1 / k * (EgRef/Tref - Eg2/T2))  # eq (9)\n    y[4] = -IL2 + Io2 * np.expm1(Voc2 / a2) + Voc2 / Rsh  # eq (4) at T2\n\n    return y\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_system_of_equations_desoto", "params", "specs", "evaluates", "the", "systems", "of", "equations", "used", "to", "solve", "for", "the", "single", "diode", "equation", "parameters", "function", "designed", "to", "be", "used", "by", "scipy", "optimize", "root", "in", "fit_desoto", "parameters", "params", "ndarray", "array", "with", "parameters", "of", "the", "de", "soto", "single", "diode", "model", "must", "be", "given", "in", "the", "following", "order", "il", "io", "a", "rs", "rsh", "specs", "tuple", "specifications", "of", "pv", "module", "given", "by", "manufacturer", "must", "be", "given", "in", "the", "following", "order", "isc", "voc", "imp", "vmp", "beta_oc", "alpha_sc", "returns", "value", "of", "the", "system", "of", "equations", "to", "solve", "with", "scipy", "optimize", "root", "six", "input", "known", "variables", "isc", "voc", "imp", "vmp", "beta_oc", "alpha_sc", "egref", "degdt", "tref", "k", "specs", "five", "parameters", "vector", "to", "find", "il", "io", "rs", "rsh", "a", "params", "five", "equation", "vector", "y", "0", "0", "0", "0", "0", "1st", "equation", "short", "circuit", "eq", "3", "in", "1", "y", "0", "isc", "il", "io", "np", "expm1", "isc", "rs", "a", "isc", "rs", "rsh", "2nd", "equation", "open", "circuit", "tref", "eq", "4", "in", "1", "y", "1", "il", "io", "np", "expm1", "voc", "a", "voc", "rsh", "3rd", "equation", "imp", "vmp", "eq", "5", "in", "1", "y", "2", "imp", "il", "io", "np", "expm1", "vmp", "imp", "rs", "a", "vmp", "imp", "rs", "rsh", "4th", "equation", "pmp", "derivated", "0", "eq23", "2", "6", "in", "2", "caution", "eq", "6", "in", "1", "has", "a", "sign", "error", "y", "3", "imp", "vmp", "io", "a", "np", "exp", "vmp", "imp", "rs", "a", "1", "0", "rsh", "1", "0", "io", "rs", "a", "np", "exp", "vmp", "imp", "rs", "a", "rs", "rsh", "5th", "equation", "open", "circuit", "t2", "eq", "4", "at", "temperature", "t2", "in", "1", "t2", "tref", "2", "voc2", "t2", "tref", "beta_oc", "voc", "eq", "7", "in", "1", "a2", "a", "t2", "tref", "eq", "8", "in", "1", "il2", "il", "alpha_sc", "t2", "tref", "eq", "11", "in", "1", "eg2", "egref", "1", "degdt", "t2", "tref", "eq", "10", "in", "1", "io2", "io", "t2", "tref", "3", "np", "exp", "1", "k", "egref", "tref", "eg2", "t2", "eq", "9", "y", "4", "il2", "io2", "np", "expm1", "voc2", "a2", "voc2", "rsh", "eq", "4", "at", "t2", "return", "y"], "doc_len": 320}
{"doc_id": "pvlib/ivtools/sdm.py::fit_pvsyst_sandia", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "fit_pvsyst_sandia", "text": "文件路径: pvlib/ivtools/sdm.py\ndef fit_pvsyst_sandia(ivcurves, specs, const=None, maxiter=5, eps1=1.e-3):\n    \"\"\"\n    Estimate parameters for the PVsyst module performance model.\n\n    Parameters\n    ----------\n    ivcurves : dict\n        i : array\n            One array element for each IV curve. The jth element is itself an\n            array of current for jth IV curve (same length as v[j]) [A]\n        v : array\n            One array element for each IV curve. The jth element is itself an\n            array of voltage for jth IV curve  (same length as i[j]) [V]\n        ee : array\n            effective irradiance for each IV curve, i.e., POA broadband\n            irradiance adjusted by solar spectrum modifier [W / m^2]\n        tc : array\n            cell temperature for each IV curve [C]\n        i_sc : array\n            short circuit current for each IV curve [A]\n        v_oc : array\n            open circuit voltage for each IV curve [V]\n        i_mp : array\n            current at max power point for each IV curve [A]\n        v_mp : array\n            voltage at max power point for each IV curve [V]\n\n    specs : dict\n        cells_in_series : int\n            number of cells in series\n        alpha_sc : float\n            temperature coefficient of isc [A/C]\n\n    const : dict\n        E0 : float\n            effective irradiance at STC, default 1000 [W/m^2]\n        T0 : float\n            cell temperature at STC, default 25 [C]\n        k : float\n            1.38066E-23 J/K (Boltzmann's constant)\n        q : float\n            1.60218E-19 Coulomb (elementary charge)\n\n    maxiter : int, default 5\n        input that sets the maximum number of iterations for the parameter\n        updating part of the algorithm.\n\n    eps1: float, default 1e-3\n        Tolerance for the IV curve fitting. The parameter updating stops when\n        absolute values of the percent change in mean, max and standard\n        deviation of Imp, Vmp and Pmp between iterations are all less than\n        eps1, or when the number of iterations exceeds maxiter.\n\n    Returns\n    -------\n    dict\n        I_L_ref : float\n            light current at STC [A]\n        I_o_ref : float\n            dark current at STC [A]\n        EgRef : float\n            effective band gap at STC [eV]\n        R_s : float\n            series resistance at STC [ohm]\n        R_sh_ref : float\n            shunt resistance at STC [ohm]\n        R_sh_0 : float\n            shunt resistance at zero irradiance [ohm]\n        R_sh_exp : float\n            exponential factor defining decrease in shunt resistance with\n            increasing effective irradiance\n        gamma_ref : float\n            diode (ideality) factor at STC [unitless]\n        mu_gamma : float\n            temperature coefficient for diode (ideality) factor [1/K]\n        cells_in_series : int\n            number of cells in series\n        iph : array\n            light current for each IV curve [A]\n        io : array\n            dark current for each IV curve [A]\n        rs : array\n            series resistance for each IV curve [ohm]\n        rsh : array\n            shunt resistance for each IV curve [ohm]\n        u : array\n            boolean for each IV curve indicating that the parameter values\n            are deemed reasonable by the private function ``_filter_params``\n\n    Notes\n    -----\n    The PVsyst module performance model is described in [1]_, [2]_, and [3]_.\n    The fitting method is documented in [4]_, [5]_, and [6]_.\n    Ported from PVLib Matlab [7]_.\n\n    References\n    ----------\n    .. [1] K. Sauer, T. Roessler, C. W. Hansen, Modeling the Irradiance and\n       Temperature Dependence of Photovoltaic Modules in PVsyst, IEEE Journal\n       of Photovoltaics v5(1), January 2015.\n    .. [2] A. Mermoud, PV Modules modeling, Presentation at the 2nd PV\n       Performance Modeling Workshop, Santa Clara, CA, May 2013\n    .. [3] A. Mermoud, T. Lejeuene, Performance Assessment of a Simulation\n       Model for PV modules of any available technology, 25th European\n       Photovoltaic Solar Energy Conference, Valencia, Spain, Sept. 2010\n    .. [4] C. Hansen, Estimating Parameters for the PVsyst Version 6\n       Photovoltaic Module Performance Model, Sandia National Laboratories\n       Report SAND2015-8598\n    .. [5] C. Hansen, Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n    .. [6] C. Hansen, Estimation of Parameters for Single Diode Models using\n        Measured IV Curves, Proc. of the 39th IEEE PVSC, June 2013.\n    .. [7] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    \"\"\"\n\n    if const is None:\n        const = {'E0': 1000.0, 'T0': 25.0, 'k': 1.38066e-23, 'q': 1.60218e-19}\n\n    ee = ivcurves['ee']\n    tc = ivcurves['tc']\n    tck = tc + 273.15\n    isc = ivcurves['i_sc']\n    voc = ivcurves['v_oc']\n    imp = ivcurves['i_mp']\n    vmp = ivcurves['v_mp']\n\n    # Cell Thermal Voltage\n    vth = const['k'] / const['q'] * tck\n\n    n = len(ivcurves['v_oc'])\n\n    # Initial estimate of Rsh used to obtain the diode factor gamma0 and diode\n    # temperature coefficient mu_gamma. Rsh is estimated using the co-content\n    # integral method.\n\n    rsh = np.ones(n)\n    for j in range(n):\n        voltage, current = rectify_iv_curve(ivcurves['v'][j], ivcurves['i'][j])\n        # initial estimate of Rsh, from integral over voltage regression\n        # [5] Step 3a; [6] Step 3a\n        _, _, _, rsh[j], _ = _fit_sandia_cocontent(\n            voltage, current, vth[j] * specs['cells_in_series'])\n\n    gamma_ref, mu_gamma = _fit_pvsyst_sandia_gamma(voc, isc, rsh, vth, tck,\n                                                   specs, const)\n\n    badgamma = np.isnan(gamma_ref) or np.isnan(mu_gamma) \\\n        or not np.isreal(gamma_ref) or not np.isreal(mu_gamma)\n\n    if badgamma:\n        raise RuntimeError(\n            \"Failed to estimate the diode (ideality) factor parameter;\"\n            \" aborting parameter estimation.\")\n\n    gamma = gamma_ref + mu_gamma * (tc - const['T0'])\n    nnsvth = gamma * (vth * specs['cells_in_series'])\n\n    # For each IV curve, sequentially determine initial values for Io, Rs,\n    # and Iph [5] Step 3a; [6] Step 3\n    iph, io, rs, u = _initial_iv_params(ivcurves, ee, voc, isc, rsh,\n                                        nnsvth)\n\n    # Update values for each IV curve to converge at vmp, imp, voc and isc\n    iph, io, rs, rsh, u = _update_iv_params(voc, isc, vmp, imp, ee,\n                                            iph, io, rs, rsh, nnsvth, u,\n                                            maxiter, eps1)\n\n    # get single diode models from converged values for each IV curve\n    pvsyst = _extract_sdm_params(ee, tc, iph, io, rs, rsh, gamma, u,\n                                 specs, const, model='pvsyst')\n    # Add parameters estimated in this function\n    pvsyst['gamma_ref'] = gamma_ref\n    pvsyst['mu_gamma'] = mu_gamma\n    pvsyst['cells_in_series'] = specs['cells_in_series']\n\n    return pvsyst\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "fit_pvsyst_sandia", "ivcurves", "specs", "const", "none", "maxiter", "5", "eps1", "1", "e", "3", "estimate", "parameters", "for", "the", "pvsyst", "module", "performance", "model", "parameters", "ivcurves", "dict", "i", "array", "one", "array", "element", "for", "each", "iv", "curve", "the", "jth", "element", "is", "itself", "an", "array", "of", "current", "for", "jth", "iv", "curve", "same", "length", "as", "v", "j", "a", "v", "array", "one", "array", "element", "for", "each", "iv", "curve", "the", "jth", "element", "is", "itself", "an", "array", "of", "voltage", "for", "jth", "iv", "curve", "same", "length", "as", "i", "j", "v", "ee", "array", "effective", "irradiance", "for", "each", "iv", "curve", "i", "e", "poa", "broadband", "irradiance", "adjusted", "by", "solar", "spectrum", "modifier", "w", "m", "2", "tc", "array", "cell", "temperature", "for", "each", "iv", "curve", "c", "i_sc", "array", "short", "circuit", "current", "for", "each", "iv", "curve", "a", "v_oc", "array", "open", "circuit", "voltage", "for", "each", "iv", "curve", "v", "i_mp", "array", "current", "at", "max", "power", "point", "for", "each", "iv", "curve", "a", "v_mp", "array", "voltage", "at", "max", "power", "point", "for", "each", "iv", "curve", "v", "specs", "dict", "cells_in_series", "int", "number", "of", "cells", "in", "series", "alpha_sc", "float", "temperature", "coefficient", "of", "isc", "a", "c", "const", "dict", "e0", "float", "effective", "irradiance", "at", "stc", "default", "1000", "w", "m", "2", "t0", "float", "cell", "temperature", "at", "stc", "default", "25", "c", "k", "float", "1", "38066e", "23", "j", "k", "boltzmann", "s", "constant", "q", "float", "1", "60218e", "19", "coulomb", "elementary", "charge", "maxiter", "int", "default", "5", "input", "that", "sets", "the", "maximum", "number", "of", "iterations", "for", "the", "parameter", "updating", "part", "of", "the", "algorithm", "eps1", "float", "default", "1e", "3", "tolerance", "for", "the", "iv", "curve", "fitting", "the", "parameter", "updating", "stops", "when", "absolute", "values", "of", "the", "percent", "change", "in", "mean", "max", "and", "standard", "deviation", "of", "imp", "vmp", "and", "pmp", "between", "iterations", "are", "all", "less", "than", "eps1", "or", "when", "the", "number", "of", "iterations", "exceeds", "maxiter", "returns", "dict", "i_l_ref", "float", "light", "current", "at", "stc", "a", "i_o_ref", "float", "dark", "current", "at", "stc", "a", "egref", "float", "effective", "band", "gap", "at", "stc", "ev", "r_s", "float", "series", "resistance", "at", "stc", "ohm", "r_sh_ref", "float", "shunt", "resistance", "at", "stc", "ohm", "r_sh_0", "float", "shunt", "resistance", "at", "zero", "irradiance", "ohm", "r_sh_exp", "float", "exponential", "factor", "defining", "decrease", "in", "shunt", "resistance", "with", "increasing", "effective", "irradiance", "gamma_ref", "float", "diode", "ideality", "factor", "at", "stc", "unitless", "mu_gamma", "float", "temperature", "coefficient", "for", "diode", "ideality", "factor", "1", "k", "cells_in_series", "int", "number", "of", "cells", "in", "series", "iph", "array", "light", "current", "for", "each", "iv", "curve", "a", "io", "array", "dark", "current", "for", "each", "iv", "curve", "a", "rs", "array", "series", "resistance", "for", "each", "iv", "curve", "ohm", "rsh", "array", "shunt", "resistance", "for", "each", "iv", "curve", "ohm", "u", "array", "boolean", "for", "each", "iv", "curve", "indicating", "that", "the", "parameter", "values", "are", "deemed", "reasonable", "by", "the", "private", "function", "_filter_params", "notes", "the", "pvsyst", "module", "performance", "model", "is", "described", "in", "1", "_", "2", "_", "and", "3", "_", "the", "fitting", "method", "is", "documented", "in", "4", "_", "5", "_", "and", "6", "_", "ported", "from", "pvlib", "matlab", "7", "_", "references", "1", "k", "sauer", "t", "roessler", "c", "w", "hansen", "modeling", "the", "irradiance", "and", "temperature", "dependence", "of", "photovoltaic", "modules", "in", "pvsyst", "ieee", "journal", "of", "photovoltaics", "v5", "1", "january", "2015", "2", "a", "mermoud", "pv", "modules", "modeling", "presentation", "at", "the", "2nd", "pv", "performance", "modeling", "workshop", "santa", "clara", "ca", "may", "2013", "3", "a", "mermoud", "t", "lejeuene", "performance", "assessment", "of", "a", "simulation", "model", "for", "pv", "modules", "of", "any", "available", "technology", "25th", "european", "photovoltaic", "solar", "energy", "conference", "valencia", "spain", "sept", "2010", "4", "c", "hansen", "estimating", "parameters", "for", "the", "pvsyst", "version", "6", "photovoltaic", "module", "performance", "model", "sandia", "national", "laboratories", "report", "sand2015", "8598", "5", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "6", "c", "hansen", "estimation", "of", "parameters", "for", "single", "diode", "models", "using", "measured", "iv", "curves", "proc", "of", "the", "39th", "ieee", "pvsc", "june", "2013", "7", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "if", "const", "is", "none", "const", "e0", "1000", "0", "t0", "25", "0", "k", "1", "38066e", "23", "q", "1", "60218e", "19", "ee", "ivcurves", "ee", "tc", "ivcurves", "tc", "tck", "tc", "273", "15", "isc", "ivcurves", "i_sc", "voc", "ivcurves", "v_oc", "imp", "ivcurves", "i_mp", "vmp", "ivcurves", "v_mp", "cell", "thermal", "voltage", "vth", "const", "k", "const", "q", "tck", "n", "len", "ivcurves", "v_oc", "initial", "estimate", "of", "rsh", "used", "to", "obtain", "the", "diode", "factor", "gamma0", "and", "diode", "temperature", "coefficient", "mu_gamma", "rsh", "is", "estimated", "using", "the", "co", "content", "integral", "method", "rsh", "np", "ones", "n", "for", "j", "in", "range", "n", "voltage", "current", "rectify_iv_curve", "ivcurves", "v", "j", "ivcurves", "i", "j", "initial", "estimate", "of", "rsh", "from", "integral", "over", "voltage", "regression", "5", "step", "3a", "6", "step", "3a", "_", "_", "_", "rsh", "j", "_", "_fit_sandia_cocontent", "voltage", "current", "vth", "j", "specs", "cells_in_series", "gamma_ref", "mu_gamma", "_fit_pvsyst_sandia_gamma", "voc", "isc", "rsh", "vth", "tck", "specs", "const", "badgamma", "np", "isnan", "gamma_ref", "or", "np", "isnan", "mu_gamma", "or", "not", "np", "isreal", "gamma_ref", "or", "not", "np", "isreal", "mu_gamma", "if", "badgamma", "raise", "runtimeerror", "failed", "to", "estimate", "the", "diode", "ideality", "factor", "parameter", "aborting", "parameter", "estimation", "gamma", "gamma_ref", "mu_gamma", "tc", "const", "t0", "nnsvth", "gamma", "vth", "specs", "cells_in_series", "for", "each", "iv", "curve", "sequentially", "determine", "initial", "values", "for", "io", "rs", "and", "iph", "5", "step", "3a", "6", "step", "3", "iph", "io", "rs", "u", "_initial_iv_params", "ivcurves", "ee", "voc", "isc", "rsh", "nnsvth", "update", "values", "for", "each", "iv", "curve", "to", "converge", "at", "vmp", "imp", "voc", "and", "isc", "iph", "io", "rs", "rsh", "u", "_update_iv_params", "voc", "isc", "vmp", "imp", "ee", "iph", "io", "rs", "rsh", "nnsvth", "u", "maxiter", "eps1", "get", "single", "diode", "models", "from", "converged", "values", "for", "each", "iv", "curve", "pvsyst", "_extract_sdm_params", "ee", "tc", "iph", "io", "rs", "rsh", "gamma", "u", "specs", "const", "model", "pvsyst", "add", "parameters", "estimated", "in", "this", "function", "pvsyst", "gamma_ref", "gamma_ref", "pvsyst", "mu_gamma", "mu_gamma", "pvsyst", "cells_in_series", "specs", "cells_in_series", "return", "pvsyst"], "doc_len": 885}
{"doc_id": "pvlib/ivtools/sdm.py::fit_desoto_sandia", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "fit_desoto_sandia", "text": "文件路径: pvlib/ivtools/sdm.py\ndef fit_desoto_sandia(ivcurves, specs, const=None, maxiter=5, eps1=1.e-3):\n    \"\"\"\n    Estimate parameters for the De Soto module performance model.\n\n    Parameters\n    ----------\n    ivcurves : dict\n        i : array\n            One array element for each IV curve. The jth element is itself an\n            array of current for jth IV curve (same length as v[j]) [A]\n        v : array\n            One array element for each IV curve. The jth element is itself an\n            array of voltage for jth IV curve  (same length as i[j]) [V]\n        ee : array\n            effective irradiance for each IV curve, i.e., POA broadband\n            irradiance adjusted by solar spectrum modifier [W / m^2]\n        tc : array\n            cell temperature for each IV curve [C]\n        i_sc : array\n            short circuit current for each IV curve [A]\n        v_oc : array\n            open circuit voltage for each IV curve [V]\n        i_mp : array\n            current at max power point for each IV curve [A]\n        v_mp : array\n            voltage at max power point for each IV curve [V]\n\n    specs : dict\n        cells_in_series : int\n            number of cells in series\n        alpha_sc : float\n            temperature coefficient of Isc [A/C]\n        beta_voc : float\n            temperature coefficient of Voc [V/C]\n\n    const : dict\n        E0 : float\n            effective irradiance at STC, default 1000 [W/m^2]\n        T0 : float\n            cell temperature at STC, default 25 [C]\n        k : float\n            1.38066E-23 J/K (Boltzmann's constant)\n        q : float\n            1.60218E-19 Coulomb (elementary charge)\n\n    maxiter : int, default 5\n        input that sets the maximum number of iterations for the parameter\n        updating part of the algorithm.\n\n    eps1: float, default 1e-3\n        Tolerance for the IV curve fitting. The parameter updating stops when\n        absolute values of the percent change in mean, max and standard\n        deviation of Imp, Vmp and Pmp between iterations are all less than\n        eps1, or when the number of iterations exceeds maxiter.\n\n    Returns\n    -------\n    dict\n        I_L_ref : float\n            light current at STC [A]\n        I_o_ref : float\n            dark current at STC [A]\n        EgRef : float\n            effective band gap at STC [eV]\n        R_s : float\n            series resistance at STC [ohm]\n        R_sh_ref : float\n            shunt resistance at STC [ohm]\n        cells_in_series : int\n            number of cells in series\n        iph : array\n            light current for each IV curve [A]\n        io : array\n            dark current for each IV curve [A]\n        rs : array\n            series resistance for each IV curve [ohm]\n        rsh : array\n            shunt resistance for each IV curve [ohm]\n        u : array\n            boolean for each IV curve indicating that the parameter values\n            are deemed reasonable by the private function ``_filter_params``\n\n    Notes\n    -----\n    The De Soto module performance model is described in [1]_. The fitting\n    method is documented in [2]_, [3]_. Ported from PVLib Matlab [4]_.\n\n    References\n    ----------\n    .. [1] W. De Soto et al., \"Improvement and validation of a model for\n       photovoltaic array performance\", Solar Energy, vol 80, pp. 78-88,\n       2006.\n    .. [2] C. Hansen, Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n    .. [3] C. Hansen, Estimation of Parameters for Single Diode Models using\n        Measured IV Curves, Proc. of the 39th IEEE PVSC, June 2013.\n    .. [4] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    \"\"\"\n\n    if const is None:\n        const = {'E0': 1000.0, 'T0': 25.0, 'k': 1.38066e-23, 'q': 1.60218e-19}\n\n    ee = ivcurves['ee']\n    tc = ivcurves['tc']\n    tck = tc + 273.15\n    isc = ivcurves['i_sc']\n    voc = ivcurves['v_oc']\n    imp = ivcurves['i_mp']\n    vmp = ivcurves['v_mp']\n\n    # Cell Thermal Voltage\n    vth = const['k'] / const['q'] * tck\n\n    n = len(voc)\n\n    # Initial estimate of Rsh used to obtain the diode factor gamma0 and diode\n    # temperature coefficient mu_gamma. Rsh is estimated using the co-content\n    # integral method.\n\n    rsh = np.ones(n)\n    for j in range(n):\n        voltage, current = rectify_iv_curve(ivcurves['v'][j], ivcurves['i'][j])\n        # initial estimate of Rsh, from integral over voltage regression\n        # [5] Step 3a; [6] Step 3a\n        _, _, _, rsh[j], _ = _fit_sandia_cocontent(\n            voltage, current, vth[j] * specs['cells_in_series'])\n\n    n0 = _fit_desoto_sandia_diode(ee, voc, vth, tc, specs, const)\n\n    bad_n = np.isnan(n0) or not np.isreal(n0)\n\n    if bad_n:\n        raise RuntimeError(\n            \"Failed to estimate the diode (ideality) factor parameter;\"\n            \" aborting parameter estimation.\")\n\n    nnsvth = n0 * specs['cells_in_series'] * vth\n\n    # For each IV curve, sequentially determine initial values for Io, Rs,\n    # and Iph [5] Step 3a; [6] Step 3\n    iph, io, rs, u = _initial_iv_params(ivcurves, ee, voc, isc, rsh,\n                                        nnsvth)\n\n    # Update values for each IV curve to converge at vmp, imp, voc and isc\n    iph, io, rs, rsh, u = _update_iv_params(voc, isc, vmp, imp, ee,\n                                            iph, io, rs, rsh, nnsvth, u,\n                                            maxiter, eps1)\n\n    # get single diode models from converged values for each IV curve\n    desoto = _extract_sdm_params(ee, tc, iph, io, rs, rsh, n0, u,\n                                 specs, const, model='desoto')\n    # Add parameters estimated in this function\n    desoto['a_ref'] = n0 * specs['cells_in_series'] * const['k'] / \\\n        const['q'] * (const['T0'] + 273.15)\n    desoto['cells_in_series'] = specs['cells_in_series']\n\n    return desoto\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "fit_desoto_sandia", "ivcurves", "specs", "const", "none", "maxiter", "5", "eps1", "1", "e", "3", "estimate", "parameters", "for", "the", "de", "soto", "module", "performance", "model", "parameters", "ivcurves", "dict", "i", "array", "one", "array", "element", "for", "each", "iv", "curve", "the", "jth", "element", "is", "itself", "an", "array", "of", "current", "for", "jth", "iv", "curve", "same", "length", "as", "v", "j", "a", "v", "array", "one", "array", "element", "for", "each", "iv", "curve", "the", "jth", "element", "is", "itself", "an", "array", "of", "voltage", "for", "jth", "iv", "curve", "same", "length", "as", "i", "j", "v", "ee", "array", "effective", "irradiance", "for", "each", "iv", "curve", "i", "e", "poa", "broadband", "irradiance", "adjusted", "by", "solar", "spectrum", "modifier", "w", "m", "2", "tc", "array", "cell", "temperature", "for", "each", "iv", "curve", "c", "i_sc", "array", "short", "circuit", "current", "for", "each", "iv", "curve", "a", "v_oc", "array", "open", "circuit", "voltage", "for", "each", "iv", "curve", "v", "i_mp", "array", "current", "at", "max", "power", "point", "for", "each", "iv", "curve", "a", "v_mp", "array", "voltage", "at", "max", "power", "point", "for", "each", "iv", "curve", "v", "specs", "dict", "cells_in_series", "int", "number", "of", "cells", "in", "series", "alpha_sc", "float", "temperature", "coefficient", "of", "isc", "a", "c", "beta_voc", "float", "temperature", "coefficient", "of", "voc", "v", "c", "const", "dict", "e0", "float", "effective", "irradiance", "at", "stc", "default", "1000", "w", "m", "2", "t0", "float", "cell", "temperature", "at", "stc", "default", "25", "c", "k", "float", "1", "38066e", "23", "j", "k", "boltzmann", "s", "constant", "q", "float", "1", "60218e", "19", "coulomb", "elementary", "charge", "maxiter", "int", "default", "5", "input", "that", "sets", "the", "maximum", "number", "of", "iterations", "for", "the", "parameter", "updating", "part", "of", "the", "algorithm", "eps1", "float", "default", "1e", "3", "tolerance", "for", "the", "iv", "curve", "fitting", "the", "parameter", "updating", "stops", "when", "absolute", "values", "of", "the", "percent", "change", "in", "mean", "max", "and", "standard", "deviation", "of", "imp", "vmp", "and", "pmp", "between", "iterations", "are", "all", "less", "than", "eps1", "or", "when", "the", "number", "of", "iterations", "exceeds", "maxiter", "returns", "dict", "i_l_ref", "float", "light", "current", "at", "stc", "a", "i_o_ref", "float", "dark", "current", "at", "stc", "a", "egref", "float", "effective", "band", "gap", "at", "stc", "ev", "r_s", "float", "series", "resistance", "at", "stc", "ohm", "r_sh_ref", "float", "shunt", "resistance", "at", "stc", "ohm", "cells_in_series", "int", "number", "of", "cells", "in", "series", "iph", "array", "light", "current", "for", "each", "iv", "curve", "a", "io", "array", "dark", "current", "for", "each", "iv", "curve", "a", "rs", "array", "series", "resistance", "for", "each", "iv", "curve", "ohm", "rsh", "array", "shunt", "resistance", "for", "each", "iv", "curve", "ohm", "u", "array", "boolean", "for", "each", "iv", "curve", "indicating", "that", "the", "parameter", "values", "are", "deemed", "reasonable", "by", "the", "private", "function", "_filter_params", "notes", "the", "de", "soto", "module", "performance", "model", "is", "described", "in", "1", "_", "the", "fitting", "method", "is", "documented", "in", "2", "_", "3", "_", "ported", "from", "pvlib", "matlab", "4", "_", "references", "1", "w", "de", "soto", "et", "al", "improvement", "and", "validation", "of", "a", "model", "for", "photovoltaic", "array", "performance", "solar", "energy", "vol", "80", "pp", "78", "88", "2006", "2", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "3", "c", "hansen", "estimation", "of", "parameters", "for", "single", "diode", "models", "using", "measured", "iv", "curves", "proc", "of", "the", "39th", "ieee", "pvsc", "june", "2013", "4", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "if", "const", "is", "none", "const", "e0", "1000", "0", "t0", "25", "0", "k", "1", "38066e", "23", "q", "1", "60218e", "19", "ee", "ivcurves", "ee", "tc", "ivcurves", "tc", "tck", "tc", "273", "15", "isc", "ivcurves", "i_sc", "voc", "ivcurves", "v_oc", "imp", "ivcurves", "i_mp", "vmp", "ivcurves", "v_mp", "cell", "thermal", "voltage", "vth", "const", "k", "const", "q", "tck", "n", "len", "voc", "initial", "estimate", "of", "rsh", "used", "to", "obtain", "the", "diode", "factor", "gamma0", "and", "diode", "temperature", "coefficient", "mu_gamma", "rsh", "is", "estimated", "using", "the", "co", "content", "integral", "method", "rsh", "np", "ones", "n", "for", "j", "in", "range", "n", "voltage", "current", "rectify_iv_curve", "ivcurves", "v", "j", "ivcurves", "i", "j", "initial", "estimate", "of", "rsh", "from", "integral", "over", "voltage", "regression", "5", "step", "3a", "6", "step", "3a", "_", "_", "_", "rsh", "j", "_", "_fit_sandia_cocontent", "voltage", "current", "vth", "j", "specs", "cells_in_series", "n0", "_fit_desoto_sandia_diode", "ee", "voc", "vth", "tc", "specs", "const", "bad_n", "np", "isnan", "n0", "or", "not", "np", "isreal", "n0", "if", "bad_n", "raise", "runtimeerror", "failed", "to", "estimate", "the", "diode", "ideality", "factor", "parameter", "aborting", "parameter", "estimation", "nnsvth", "n0", "specs", "cells_in_series", "vth", "for", "each", "iv", "curve", "sequentially", "determine", "initial", "values", "for", "io", "rs", "and", "iph", "5", "step", "3a", "6", "step", "3", "iph", "io", "rs", "u", "_initial_iv_params", "ivcurves", "ee", "voc", "isc", "rsh", "nnsvth", "update", "values", "for", "each", "iv", "curve", "to", "converge", "at", "vmp", "imp", "voc", "and", "isc", "iph", "io", "rs", "rsh", "u", "_update_iv_params", "voc", "isc", "vmp", "imp", "ee", "iph", "io", "rs", "rsh", "nnsvth", "u", "maxiter", "eps1", "get", "single", "diode", "models", "from", "converged", "values", "for", "each", "iv", "curve", "desoto", "_extract_sdm_params", "ee", "tc", "iph", "io", "rs", "rsh", "n0", "u", "specs", "const", "model", "desoto", "add", "parameters", "estimated", "in", "this", "function", "desoto", "a_ref", "n0", "specs", "cells_in_series", "const", "k", "const", "q", "const", "t0", "273", "15", "desoto", "cells_in_series", "specs", "cells_in_series", "return", "desoto"], "doc_len": 767}
{"doc_id": "pvlib/ivtools/sdm.py::_fit_pvsyst_sandia_gamma", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_fit_pvsyst_sandia_gamma", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _fit_pvsyst_sandia_gamma(voc, isc, rsh, vth, tck, specs, const):\n    # Estimate the diode factor gamma from Isc-Voc data. Method incorporates\n    # temperature dependence by means of the equation for Io\n\n    y = np.log(isc - voc / rsh) - 3. * np.log(tck / (const['T0'] + 273.15))\n    x1 = const['q'] / const['k'] * (1. / (const['T0'] + 273.15) - 1. / tck)\n    x2 = voc / (vth * specs['cells_in_series'])\n    uu = np.logical_or(np.isnan(y), np.isnan(x1), np.isnan(x2))\n\n    x = np.vstack((np.ones(len(x1[~uu])), x1[~uu], -x1[~uu] *\n                   (tck[~uu] - (const['T0'] + 273.15)), x2[~uu],\n                   -x2[~uu] * (tck[~uu] - (const['T0'] + 273.15)))).T\n    alpha = np.linalg.lstsq(x, y[~uu], rcond=None)[0]\n\n    gamma_ref = 1. / alpha[3]\n    mu_gamma = alpha[4] / alpha[3] ** 2\n    return gamma_ref, mu_gamma\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_fit_pvsyst_sandia_gamma", "voc", "isc", "rsh", "vth", "tck", "specs", "const", "estimate", "the", "diode", "factor", "gamma", "from", "isc", "voc", "data", "method", "incorporates", "temperature", "dependence", "by", "means", "of", "the", "equation", "for", "io", "y", "np", "log", "isc", "voc", "rsh", "3", "np", "log", "tck", "const", "t0", "273", "15", "x1", "const", "q", "const", "k", "1", "const", "t0", "273", "15", "1", "tck", "x2", "voc", "vth", "specs", "cells_in_series", "uu", "np", "logical_or", "np", "isnan", "y", "np", "isnan", "x1", "np", "isnan", "x2", "x", "np", "vstack", "np", "ones", "len", "x1", "uu", "x1", "uu", "x1", "uu", "tck", "uu", "const", "t0", "273", "15", "x2", "uu", "x2", "uu", "tck", "uu", "const", "t0", "273", "15", "t", "alpha", "np", "linalg", "lstsq", "x", "y", "uu", "rcond", "none", "0", "gamma_ref", "1", "alpha", "3", "mu_gamma", "alpha", "4", "alpha", "3", "2", "return", "gamma_ref", "mu_gamma"], "doc_len": 128}
{"doc_id": "pvlib/ivtools/sdm.py::_fit_desoto_sandia_diode", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_fit_desoto_sandia_diode", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _fit_desoto_sandia_diode(ee, voc, vth, tc, specs, const):\n    # estimates the diode factor for the De Soto model.\n    # Helper function for fit_desoto_sandia\n    try:\n        import statsmodels.api as sm\n    except ImportError:\n        raise ImportError(\n            'Parameter extraction using Sandia method requires statsmodels')\n\n    x = specs['cells_in_series'] * vth * np.log(ee / const['E0'])\n    y = voc - specs['beta_voc'] * (tc - const['T0'])\n    new_x = sm.add_constant(x)\n    res = sm.RLM(y, new_x).fit()\n    return res.params[1]\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_fit_desoto_sandia_diode", "ee", "voc", "vth", "tc", "specs", "const", "estimates", "the", "diode", "factor", "for", "the", "de", "soto", "model", "helper", "function", "for", "fit_desoto_sandia", "try", "import", "statsmodels", "api", "as", "sm", "except", "importerror", "raise", "importerror", "parameter", "extraction", "using", "sandia", "method", "requires", "statsmodels", "x", "specs", "cells_in_series", "vth", "np", "log", "ee", "const", "e0", "y", "voc", "specs", "beta_voc", "tc", "const", "t0", "new_x", "sm", "add_constant", "x", "res", "sm", "rlm", "y", "new_x", "fit", "return", "res", "params", "1"], "doc_len": 72}
{"doc_id": "pvlib/ivtools/sdm.py::_initial_iv_params", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_initial_iv_params", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _initial_iv_params(ivcurves, ee, voc, isc, rsh, nnsvth):\n    # sets initial values for iph, io, rs and quality filter u.\n    # Helper function for fit_<model>_sandia.\n    n = len(ivcurves['v_oc'])\n    io = np.ones(n)\n    iph = np.ones(n)\n    rs = np.ones(n)\n\n    for j in range(n):\n\n        if rsh[j] > 0:\n            volt, curr = rectify_iv_curve(ivcurves['v'][j],\n                                          ivcurves['i'][j])\n            # Initial estimate of Io, evaluate the single diode model at\n            # voc and approximate Iph + Io = Isc [5] Step 3a; [6] Step 3b\n            io[j] = (isc[j] - voc[j] / rsh[j]) * np.exp(-voc[j] /\n                                                        nnsvth[j])\n\n            # initial estimate of rs from dI/dV near Voc\n            # [5] Step 3a; [6] Step 3c\n            [didv, d2id2v] = _numdiff(volt, curr)\n            t3 = volt > .5 * voc[j]\n            t4 = volt < .9 * voc[j]\n            tmp = -rsh[j] * didv - 1.\n            with np.errstate(invalid=\"ignore\"):  # expect nan in didv\n                v = np.logical_and.reduce(np.array([t3, t4, ~np.isnan(tmp),\n                                                    np.greater(tmp, 0)]))\n            if np.any(v):\n                vtrs = (nnsvth[j] / isc[j] * (\n                    np.log(tmp[v] * nnsvth[j] / (rsh[j] * io[j]))\n                    - volt[v] / nnsvth[j]))\n                rs[j] = np.mean(vtrs[vtrs > 0], axis=0)\n            else:\n                rs[j] = 0.\n\n            # Initial estimate of Iph, evaluate the single diode model at\n            # Isc [5] Step 3a; [6] Step 3d\n            iph[j] = isc[j] + io[j] * np.expm1(isc[j] / nnsvth[j]) \\\n                + isc[j] * rs[j] / rsh[j]\n\n        else:\n            io[j] = np.nan\n            rs[j] = np.nan\n            iph[j] = np.nan\n\n        # Filter IV curves for good initial values\n        # [5] Step 3b\n        u = _filter_params(ee, isc, io, rs, rsh)\n\n        # [5] Step 3c\n        # Refine Io to match Voc\n        io[u] = _update_io(voc[u], iph[u], io[u], rs[u], rsh[u], nnsvth[u])\n\n        # parameters [6], Step 3c\n        # Calculate Iph to be consistent with Isc and current values of other\n        iph = isc + io * np.expm1(rs * isc / nnsvth) + isc * rs / rsh\n\n    return iph, io, rs, u\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_initial_iv_params", "ivcurves", "ee", "voc", "isc", "rsh", "nnsvth", "sets", "initial", "values", "for", "iph", "io", "rs", "and", "quality", "filter", "u", "helper", "function", "for", "fit_", "model", "_sandia", "n", "len", "ivcurves", "v_oc", "io", "np", "ones", "n", "iph", "np", "ones", "n", "rs", "np", "ones", "n", "for", "j", "in", "range", "n", "if", "rsh", "j", "0", "volt", "curr", "rectify_iv_curve", "ivcurves", "v", "j", "ivcurves", "i", "j", "initial", "estimate", "of", "io", "evaluate", "the", "single", "diode", "model", "at", "voc", "and", "approximate", "iph", "io", "isc", "5", "step", "3a", "6", "step", "3b", "io", "j", "isc", "j", "voc", "j", "rsh", "j", "np", "exp", "voc", "j", "nnsvth", "j", "initial", "estimate", "of", "rs", "from", "di", "dv", "near", "voc", "5", "step", "3a", "6", "step", "3c", "didv", "d2id2v", "_numdiff", "volt", "curr", "t3", "volt", "5", "voc", "j", "t4", "volt", "9", "voc", "j", "tmp", "rsh", "j", "didv", "1", "with", "np", "errstate", "invalid", "ignore", "expect", "nan", "in", "didv", "v", "np", "logical_and", "reduce", "np", "array", "t3", "t4", "np", "isnan", "tmp", "np", "greater", "tmp", "0", "if", "np", "any", "v", "vtrs", "nnsvth", "j", "isc", "j", "np", "log", "tmp", "v", "nnsvth", "j", "rsh", "j", "io", "j", "volt", "v", "nnsvth", "j", "rs", "j", "np", "mean", "vtrs", "vtrs", "0", "axis", "0", "else", "rs", "j", "0", "initial", "estimate", "of", "iph", "evaluate", "the", "single", "diode", "model", "at", "isc", "5", "step", "3a", "6", "step", "3d", "iph", "j", "isc", "j", "io", "j", "np", "expm1", "isc", "j", "nnsvth", "j", "isc", "j", "rs", "j", "rsh", "j", "else", "io", "j", "np", "nan", "rs", "j", "np", "nan", "iph", "j", "np", "nan", "filter", "iv", "curves", "for", "good", "initial", "values", "5", "step", "3b", "u", "_filter_params", "ee", "isc", "io", "rs", "rsh", "5", "step", "3c", "refine", "io", "to", "match", "voc", "io", "u", "_update_io", "voc", "u", "iph", "u", "io", "u", "rs", "u", "rsh", "u", "nnsvth", "u", "parameters", "6", "step", "3c", "calculate", "iph", "to", "be", "consistent", "with", "isc", "and", "current", "values", "of", "other", "iph", "isc", "io", "np", "expm1", "rs", "isc", "nnsvth", "isc", "rs", "rsh", "return", "iph", "io", "rs", "u"], "doc_len": 314}
{"doc_id": "pvlib/ivtools/sdm.py::_update_iv_params", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_update_iv_params", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _update_iv_params(voc, isc, vmp, imp, ee, iph, io, rs, rsh, nnsvth, u,\n                      maxiter, eps1):\n    # Refine Rsh, Rs, Io and Iph in that order.\n    # Helper function for fit_<model>_sandia.\n    counter = 1.  # counter variable for parameter updating while loop,\n    # counts iterations\n    prevconvergeparams = {}\n    prevconvergeparams['state'] = 0.0\n\n    not_converged = np.array([True])\n\n    while not_converged.any() and counter <= maxiter:\n        # update rsh to match max power point using a fixed point method.\n        rsh[u] = _update_rsh_fixed_pt(vmp[u], imp[u], iph[u], io[u], rs[u],\n                                      rsh[u], nnsvth[u])\n\n        # Calculate Rs to be consistent with Rsh and maximum power point\n        _, phi = _calc_theta_phi_exact(vmp[u], imp[u], iph[u], io[u],\n                                       rs[u], rsh[u], nnsvth[u])\n        rs[u] = (iph[u] + io[u] - imp[u]) * rsh[u] / imp[u] - \\\n            nnsvth[u] * phi / imp[u] - vmp[u] / imp[u]\n\n        # Update filter for good parameters\n        u = _filter_params(ee, isc, io, rs, rsh)\n\n        # Update value for io to match voc\n        io[u] = _update_io(voc[u], iph[u], io[u], rs[u], rsh[u], nnsvth[u])\n\n        # Calculate Iph to be consistent with Isc and other parameters\n        iph = isc + io * np.expm1(rs * isc / nnsvth) + isc * rs / rsh\n\n        # update filter for good parameters\n        u = _filter_params(ee, isc, io, rs, rsh)\n\n        # compute the IV curve from the current parameter values\n        result = singlediode(iph[u], io[u], rs[u], rsh[u], nnsvth[u])\n\n        # check convergence criteria\n        # [5] Step 3d\n        convergeparams = _check_converge(\n            prevconvergeparams, result, vmp[u], imp[u], counter)\n\n        prevconvergeparams = convergeparams\n        counter += 1.\n        t5 = prevconvergeparams['vmperrmeanchange'] >= eps1\n        t6 = prevconvergeparams['imperrmeanchange'] >= eps1\n        t7 = prevconvergeparams['pmperrmeanchange'] >= eps1\n        t8 = prevconvergeparams['vmperrstdchange'] >= eps1\n        t9 = prevconvergeparams['imperrstdchange'] >= eps1\n        t10 = prevconvergeparams['pmperrstdchange'] >= eps1\n        t11 = prevconvergeparams['vmperrabsmaxchange'] >= eps1\n        t12 = prevconvergeparams['imperrabsmaxchange'] >= eps1\n        t13 = prevconvergeparams['pmperrabsmaxchange'] >= eps1\n        not_converged = np.logical_or.reduce(np.array([t5, t6, t7, t8, t9,\n                                                       t10, t11, t12, t13]))\n\n    return iph, io, rs, rsh, u\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_update_iv_params", "voc", "isc", "vmp", "imp", "ee", "iph", "io", "rs", "rsh", "nnsvth", "u", "maxiter", "eps1", "refine", "rsh", "rs", "io", "and", "iph", "in", "that", "order", "helper", "function", "for", "fit_", "model", "_sandia", "counter", "1", "counter", "variable", "for", "parameter", "updating", "while", "loop", "counts", "iterations", "prevconvergeparams", "prevconvergeparams", "state", "0", "0", "not_converged", "np", "array", "true", "while", "not_converged", "any", "and", "counter", "maxiter", "update", "rsh", "to", "match", "max", "power", "point", "using", "a", "fixed", "point", "method", "rsh", "u", "_update_rsh_fixed_pt", "vmp", "u", "imp", "u", "iph", "u", "io", "u", "rs", "u", "rsh", "u", "nnsvth", "u", "calculate", "rs", "to", "be", "consistent", "with", "rsh", "and", "maximum", "power", "point", "_", "phi", "_calc_theta_phi_exact", "vmp", "u", "imp", "u", "iph", "u", "io", "u", "rs", "u", "rsh", "u", "nnsvth", "u", "rs", "u", "iph", "u", "io", "u", "imp", "u", "rsh", "u", "imp", "u", "nnsvth", "u", "phi", "imp", "u", "vmp", "u", "imp", "u", "update", "filter", "for", "good", "parameters", "u", "_filter_params", "ee", "isc", "io", "rs", "rsh", "update", "value", "for", "io", "to", "match", "voc", "io", "u", "_update_io", "voc", "u", "iph", "u", "io", "u", "rs", "u", "rsh", "u", "nnsvth", "u", "calculate", "iph", "to", "be", "consistent", "with", "isc", "and", "other", "parameters", "iph", "isc", "io", "np", "expm1", "rs", "isc", "nnsvth", "isc", "rs", "rsh", "update", "filter", "for", "good", "parameters", "u", "_filter_params", "ee", "isc", "io", "rs", "rsh", "compute", "the", "iv", "curve", "from", "the", "current", "parameter", "values", "result", "singlediode", "iph", "u", "io", "u", "rs", "u", "rsh", "u", "nnsvth", "u", "check", "convergence", "criteria", "5", "step", "3d", "convergeparams", "_check_converge", "prevconvergeparams", "result", "vmp", "u", "imp", "u", "counter", "prevconvergeparams", "convergeparams", "counter", "1", "t5", "prevconvergeparams", "vmperrmeanchange", "eps1", "t6", "prevconvergeparams", "imperrmeanchange", "eps1", "t7", "prevconvergeparams", "pmperrmeanchange", "eps1", "t8", "prevconvergeparams", "vmperrstdchange", "eps1", "t9", "prevconvergeparams", "imperrstdchange", "eps1", "t10", "prevconvergeparams", "pmperrstdchange", "eps1", "t11", "prevconvergeparams", "vmperrabsmaxchange", "eps1", "t12", "prevconvergeparams", "imperrabsmaxchange", "eps1", "t13", "prevconvergeparams", "pmperrabsmaxchange", "eps1", "not_converged", "np", "logical_or", "reduce", "np", "array", "t5", "t6", "t7", "t8", "t9", "t10", "t11", "t12", "t13", "return", "iph", "io", "rs", "rsh", "u"], "doc_len": 302}
{"doc_id": "pvlib/ivtools/sdm.py::_extract_sdm_params", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_extract_sdm_params", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _extract_sdm_params(ee, tc, iph, io, rs, rsh, n, u, specs, const,\n                        model):\n    # Get single diode model parameters from five parameters iph, io, rs, rsh\n    # and n vs. effective irradiance and temperature\n    try:\n        import statsmodels.api as sm\n    except ImportError:\n        raise ImportError(\n            'Parameter extraction using Sandia method requires statsmodels')\n\n    tck = tc + 273.15\n    tok = const['T0'] + 273.15  # convert to to K\n\n    params = {}\n\n    if model == 'pvsyst':\n        # Estimate I_o_ref and EgRef\n        x_for_io = const['q'] / const['k'] * (1. / tok - 1. / tck[u]) / n[u]\n\n        # Estimate R_sh_0, R_sh_ref and R_sh_exp\n        # Initial guesses. R_sh_0 is value at ee=0.\n        nans = np.isnan(rsh)\n        if any(ee < 400):\n            grsh0 = np.mean(rsh[np.logical_and(~nans, ee < 400)])\n        else:\n            grsh0 = np.max(rsh)\n        # Rsh_ref is value at Ee = 1000\n        if any(ee > 400):\n            grshref = np.mean(rsh[np.logical_and(~nans, ee > 400)])\n        else:\n            grshref = np.min(rsh)\n        # PVsyst default for Rshexp is 5.5\n        R_sh_exp = 5.5\n\n        # Find parameters for Rsh equation\n\n        def fun_rsh(x, rshexp, ee, e0, rsh):\n            tf = np.log10(_rsh_pvsyst(x, R_sh_exp, ee, e0)) - np.log10(rsh)\n            return tf\n\n        x0 = np.array([grsh0, grshref])\n        beta = optimize.least_squares(\n            fun_rsh, x0, args=(R_sh_exp, ee[u], const['E0'], rsh[u]),\n            bounds=np.array([[1., 1.], [1.e7, 1.e6]]), verbose=2)\n        # Extract PVsyst parameter values\n        R_sh_0 = beta.x[0]\n        R_sh_ref = beta.x[1]\n\n        # parameters unique to PVsyst\n        params['R_sh_0'] = R_sh_0\n        params['R_sh_exp'] = R_sh_exp\n\n    elif model == 'desoto':\n        dEgdT = 0.0002677\n        x_for_io = const['q'] / const['k'] * (\n            1. / tok - 1. / tck[u] + dEgdT * (tc[u] - const['T0']) / tck[u])\n\n        # Estimate R_sh_ref\n        nans = np.isnan(rsh)\n        x = const['E0'] / ee[np.logical_and(u, ee > 400, ~nans)]\n        y = rsh[np.logical_and(u, ee > 400, ~nans)]\n        new_x = sm.add_constant(x)\n        beta = sm.RLM(y, new_x).fit()\n        R_sh_ref = beta.params[1]\n\n        params['dEgdT'] = dEgdT\n\n    # Estimate I_o_ref and EgRef\n    y = np.log(io[u]) - 3. * np.log(tck[u] / tok)\n    new_x = sm.add_constant(x_for_io)\n    res = sm.RLM(y, new_x).fit()\n    beta = res.params\n    I_o_ref = np.exp(beta[0])\n    EgRef = beta[1]\n\n    # Estimate I_L_ref\n    x = tc[u] - const['T0']\n    y = iph[u] * (const['E0'] / ee[u])\n    # average over non-NaN values of Y and X\n    nans = np.isnan(y - specs['alpha_sc'] * x)\n    I_L_ref = np.mean(y[~nans] - specs['alpha_sc'] * x[~nans])\n\n    # Estimate R_s\n    nans = np.isnan(rs)\n    R_s = np.mean(rs[np.logical_and(u, ee > 400, ~nans)])\n\n    params['I_L_ref'] = I_L_ref\n    params['I_o_ref'] = I_o_ref\n    params['EgRef'] = EgRef\n    params['R_sh_ref'] = R_sh_ref\n    params['R_s'] = R_s\n    # save values for each IV curve\n    params['iph'] = iph\n    params['io'] = io\n    params['rsh'] = rsh\n    params['rs'] = rs\n    params['u'] = u\n\n    return params\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_extract_sdm_params", "ee", "tc", "iph", "io", "rs", "rsh", "n", "u", "specs", "const", "model", "get", "single", "diode", "model", "parameters", "from", "five", "parameters", "iph", "io", "rs", "rsh", "and", "n", "vs", "effective", "irradiance", "and", "temperature", "try", "import", "statsmodels", "api", "as", "sm", "except", "importerror", "raise", "importerror", "parameter", "extraction", "using", "sandia", "method", "requires", "statsmodels", "tck", "tc", "273", "15", "tok", "const", "t0", "273", "15", "convert", "to", "to", "k", "params", "if", "model", "pvsyst", "estimate", "i_o_ref", "and", "egref", "x_for_io", "const", "q", "const", "k", "1", "tok", "1", "tck", "u", "n", "u", "estimate", "r_sh_0", "r_sh_ref", "and", "r_sh_exp", "initial", "guesses", "r_sh_0", "is", "value", "at", "ee", "0", "nans", "np", "isnan", "rsh", "if", "any", "ee", "400", "grsh0", "np", "mean", "rsh", "np", "logical_and", "nans", "ee", "400", "else", "grsh0", "np", "max", "rsh", "rsh_ref", "is", "value", "at", "ee", "1000", "if", "any", "ee", "400", "grshref", "np", "mean", "rsh", "np", "logical_and", "nans", "ee", "400", "else", "grshref", "np", "min", "rsh", "pvsyst", "default", "for", "rshexp", "is", "5", "5", "r_sh_exp", "5", "5", "find", "parameters", "for", "rsh", "equation", "def", "fun_rsh", "x", "rshexp", "ee", "e0", "rsh", "tf", "np", "log10", "_rsh_pvsyst", "x", "r_sh_exp", "ee", "e0", "np", "log10", "rsh", "return", "tf", "x0", "np", "array", "grsh0", "grshref", "beta", "optimize", "least_squares", "fun_rsh", "x0", "args", "r_sh_exp", "ee", "u", "const", "e0", "rsh", "u", "bounds", "np", "array", "1", "1", "1", "e7", "1", "e6", "verbose", "2", "extract", "pvsyst", "parameter", "values", "r_sh_0", "beta", "x", "0", "r_sh_ref", "beta", "x", "1", "parameters", "unique", "to", "pvsyst", "params", "r_sh_0", "r_sh_0", "params", "r_sh_exp", "r_sh_exp", "elif", "model", "desoto", "degdt", "0", "0002677", "x_for_io", "const", "q", "const", "k", "1", "tok", "1", "tck", "u", "degdt", "tc", "u", "const", "t0", "tck", "u", "estimate", "r_sh_ref", "nans", "np", "isnan", "rsh", "x", "const", "e0", "ee", "np", "logical_and", "u", "ee", "400", "nans", "y", "rsh", "np", "logical_and", "u", "ee", "400", "nans", "new_x", "sm", "add_constant", "x", "beta", "sm", "rlm", "y", "new_x", "fit", "r_sh_ref", "beta", "params", "1", "params", "degdt", "degdt", "estimate", "i_o_ref", "and", "egref", "y", "np", "log", "io", "u", "3", "np", "log", "tck", "u", "tok", "new_x", "sm", "add_constant", "x_for_io", "res", "sm", "rlm", "y", "new_x", "fit", "beta", "res", "params", "i_o_ref", "np", "exp", "beta", "0", "egref", "beta", "1", "estimate", "i_l_ref", "x", "tc", "u", "const", "t0", "y", "iph", "u", "const", "e0", "ee", "u", "average", "over", "non", "nan", "values", "of", "y", "and", "x", "nans", "np", "isnan", "y", "specs", "alpha_sc", "x", "i_l_ref", "np", "mean", "y", "nans", "specs", "alpha_sc", "x", "nans", "estimate", "r_s", "nans", "np", "isnan", "rs", "r_s", "np", "mean", "rs", "np", "logical_and", "u", "ee", "400", "nans", "params", "i_l_ref", "i_l_ref", "params", "i_o_ref", "i_o_ref", "params", "egref", "egref", "params", "r_sh_ref", "r_sh_ref", "params", "r_s", "r_s", "save", "values", "for", "each", "iv", "curve", "params", "iph", "iph", "params", "io", "io", "params", "rsh", "rsh", "params", "rs", "rs", "params", "u", "u", "return", "params"], "doc_len": 424}
{"doc_id": "pvlib/ivtools/sdm.py::_update_io", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_update_io", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _update_io(voc, iph, io, rs, rsh, nnsvth):\n    \"\"\"\n    Adjusts Io to match Voc using other parameter values.\n\n    Helper function for fit_pvsyst_sandia, fit_desoto_sandia\n\n    Description\n    -----------\n    Io is updated iteratively 10 times or until successive\n    values are less than 0.000001 % different. The updating is similar to\n    Newton's method.\n\n    Parameters\n    ----------\n    voc: a numpy array of length N of values for Voc (V)\n    iph: a numpy array of length N of values for lighbt current IL (A)\n    io: a numpy array of length N of initial values for Io (A)\n    rs: a numpy array of length N of values for the series resistance (ohm)\n    rsh: a numpy array of length N of values for the shunt resistance (ohm)\n    nnsvth: a numpy array of length N of values for the diode factor x thermal\n            voltage for the module, equal to Ns (number of cells in series) x\n            Vth (thermal voltage per cell).\n\n    Returns\n    -------\n    new_io - a numpy array of length N of updated values for io\n\n    References\n    ----------\n    .. [1] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    .. [2] C. Hansen, Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n    .. [3] C. Hansen, Estimation of Parameteres for Single Diode Models using\n       Measured IV Curves, Proc. of the 39th IEEE PVSC, June 2013.\n    \"\"\"\n\n    eps = 1e-6\n    niter = 10\n    k = 1\n    maxerr = 1\n\n    tio = io  # Current Estimate of Io\n\n    while maxerr > eps and k < niter:\n        # Predict Voc\n        pvoc = v_from_i(rsh, rs, nnsvth, 0., tio, iph)\n\n        # Difference in Voc\n        dvoc = pvoc - voc\n\n        # Update Io\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            new_io = tio * (1. + (2. * dvoc) / (2. * nnsvth - dvoc))\n            # Calculate Maximum Percent Difference\n            maxerr = np.max(np.abs(new_io - tio) / tio) * 100.\n\n        tio = new_io\n        k += 1.\n\n    return new_io\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_update_io", "voc", "iph", "io", "rs", "rsh", "nnsvth", "adjusts", "io", "to", "match", "voc", "using", "other", "parameter", "values", "helper", "function", "for", "fit_pvsyst_sandia", "fit_desoto_sandia", "description", "io", "is", "updated", "iteratively", "10", "times", "or", "until", "successive", "values", "are", "less", "than", "0", "000001", "different", "the", "updating", "is", "similar", "to", "newton", "s", "method", "parameters", "voc", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "voc", "v", "iph", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "lighbt", "current", "il", "a", "io", "a", "numpy", "array", "of", "length", "n", "of", "initial", "values", "for", "io", "a", "rs", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "series", "resistance", "ohm", "rsh", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "shunt", "resistance", "ohm", "nnsvth", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "diode", "factor", "x", "thermal", "voltage", "for", "the", "module", "equal", "to", "ns", "number", "of", "cells", "in", "series", "x", "vth", "thermal", "voltage", "per", "cell", "returns", "new_io", "a", "numpy", "array", "of", "length", "n", "of", "updated", "values", "for", "io", "references", "1", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "2", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "3", "c", "hansen", "estimation", "of", "parameteres", "for", "single", "diode", "models", "using", "measured", "iv", "curves", "proc", "of", "the", "39th", "ieee", "pvsc", "june", "2013", "eps", "1e", "6", "niter", "10", "k", "1", "maxerr", "1", "tio", "io", "current", "estimate", "of", "io", "while", "maxerr", "eps", "and", "k", "niter", "predict", "voc", "pvoc", "v_from_i", "rsh", "rs", "nnsvth", "0", "tio", "iph", "difference", "in", "voc", "dvoc", "pvoc", "voc", "update", "io", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "new_io", "tio", "1", "2", "dvoc", "2", "nnsvth", "dvoc", "calculate", "maximum", "percent", "difference", "maxerr", "np", "max", "np", "abs", "new_io", "tio", "tio", "100", "tio", "new_io", "k", "1", "return", "new_io"], "doc_len": 287}
{"doc_id": "pvlib/ivtools/sdm.py::_rsh_pvsyst", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_rsh_pvsyst", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _rsh_pvsyst(x, rshexp, g, go):\n    # computes rsh for PVsyst model where the parameters are in vector xL\n    # x[0] = Rsh0\n    # x[1] = Rshref\n\n    rsho = x[0]\n    rshref = x[1]\n\n    rshb = np.maximum(\n        (rshref - rsho * np.exp(-rshexp)) / (1. - np.exp(-rshexp)), 0.)\n    rsh = rshb + (rsho - rshb) * np.exp(-rshexp * g / go)\n    return rsh\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_rsh_pvsyst", "x", "rshexp", "g", "go", "computes", "rsh", "for", "pvsyst", "model", "where", "the", "parameters", "are", "in", "vector", "xl", "x", "0", "rsh0", "x", "1", "rshref", "rsho", "x", "0", "rshref", "x", "1", "rshb", "np", "maximum", "rshref", "rsho", "np", "exp", "rshexp", "1", "np", "exp", "rshexp", "0", "rsh", "rshb", "rsho", "rshb", "np", "exp", "rshexp", "g", "go", "return", "rsh"], "doc_len": 58}
{"doc_id": "pvlib/ivtools/sdm.py::_filter_params", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_filter_params", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _filter_params(ee, isc, io, rs, rsh):\n    # Function _filter_params identifies bad parameter sets. A bad set contains\n    # Nan, non-positive or imaginary values for parameters; Rs > Rsh; or data\n    # where effective irradiance Ee differs by more than 5% from a linear fit\n    # to Isc vs. Ee\n\n    badrsh = np.logical_or(rsh < 0., np.isnan(rsh))\n    negrs = rs < 0.\n    badrs = np.logical_or(rs > rsh, np.isnan(rs))\n    imagrs = ~(np.isreal(rs))\n    badio = np.logical_or(np.logical_or(~(np.isreal(rs)), io <= 0),\n                          np.isnan(io))\n    goodr = np.logical_and(~badrsh, ~imagrs)\n    goodr = np.logical_and(goodr, ~negrs)\n    goodr = np.logical_and(goodr, ~badrs)\n    goodr = np.logical_and(goodr, ~badio)\n\n    matrix = np.vstack((ee / 1000., np.zeros(len(ee)))).T\n    eff = np.linalg.lstsq(matrix, isc, rcond=None)[0][0]\n    pisc = eff * ee / 1000\n    pisc_error = np.abs(pisc - isc) / isc\n    # check for departure from linear relation between Isc and Ee\n    badiph = pisc_error > .05\n\n    u = np.logical_and(goodr, ~badiph)\n    return u\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_filter_params", "ee", "isc", "io", "rs", "rsh", "function", "_filter_params", "identifies", "bad", "parameter", "sets", "a", "bad", "set", "contains", "nan", "non", "positive", "or", "imaginary", "values", "for", "parameters", "rs", "rsh", "or", "data", "where", "effective", "irradiance", "ee", "differs", "by", "more", "than", "5", "from", "a", "linear", "fit", "to", "isc", "vs", "ee", "badrsh", "np", "logical_or", "rsh", "0", "np", "isnan", "rsh", "negrs", "rs", "0", "badrs", "np", "logical_or", "rs", "rsh", "np", "isnan", "rs", "imagrs", "np", "isreal", "rs", "badio", "np", "logical_or", "np", "logical_or", "np", "isreal", "rs", "io", "0", "np", "isnan", "io", "goodr", "np", "logical_and", "badrsh", "imagrs", "goodr", "np", "logical_and", "goodr", "negrs", "goodr", "np", "logical_and", "goodr", "badrs", "goodr", "np", "logical_and", "goodr", "badio", "matrix", "np", "vstack", "ee", "1000", "np", "zeros", "len", "ee", "t", "eff", "np", "linalg", "lstsq", "matrix", "isc", "rcond", "none", "0", "0", "pisc", "eff", "ee", "1000", "pisc_error", "np", "abs", "pisc", "isc", "isc", "check", "for", "departure", "from", "linear", "relation", "between", "isc", "and", "ee", "badiph", "pisc_error", "05", "u", "np", "logical_and", "goodr", "badiph", "return", "u"], "doc_len": 156}
{"doc_id": "pvlib/ivtools/sdm.py::_check_converge", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_check_converge", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _check_converge(prevparams, result, vmp, imp, i):\n    \"\"\"\n    Function _check_converge computes convergence metrics for all IV curves.\n\n    Helper function for fit_pvsyst_sandia, fit_desoto_sandia\n\n    Parameters\n    ----------\n    prevparams: Convergence Parameters from the previous Iteration (used to\n                determine Percent Change in values between iterations)\n    result: performacne paramters of the (predicted) single diode fitting,\n            which includes Voc, Vmp, Imp, Pmp and Isc\n    vmp: measured values for each IV curve\n    imp: measured values for each IV curve\n    i: Index of current iteration in cec_parameter_estimation\n\n    Returns\n    -------\n    convergeparam: dict containing the following for Imp, Vmp and Pmp:\n        - maximum percent difference between measured and modeled values\n        - minimum percent difference between measured and modeled values\n        - maximum absolute percent difference between measured and modeled\n          values\n        - mean percent difference between measured and modeled values\n        - standard deviation of percent difference between measured and modeled\n          values\n        - absolute difference for previous and current values of maximum\n          absolute percent difference (measured vs. modeled)\n        - absolute difference for previous and current values of mean percent\n          difference (measured vs. modeled)\n        - absolute difference for previous and current values of standard\n          deviation of percent difference (measured vs. modeled)\n    \"\"\"\n\n    convergeparam = {}\n\n    imperror = (result['i_mp'] - imp) / imp * 100.\n    vmperror = (result['v_mp'] - vmp) / vmp * 100.\n    pmperror = (result['p_mp'] - (imp * vmp)) / (imp * vmp) * 100.\n\n    convergeparam['imperrmax'] = max(imperror)  # max of the error in Imp\n    convergeparam['imperrmin'] = min(imperror)  # min of the error in Imp\n    # max of the absolute error in Imp\n    convergeparam['imperrabsmax'] = max(abs(imperror))\n    # mean of the error in Imp\n    convergeparam['imperrmean'] = np.mean(imperror, axis=0)\n    # std of the error in Imp\n    convergeparam['imperrstd'] = np.std(imperror, axis=0, ddof=1)\n\n    convergeparam['vmperrmax'] = max(vmperror)  # max of the error in Vmp\n    convergeparam['vmperrmin'] = min(vmperror)  # min of the error in Vmp\n    # max of the absolute error in Vmp\n    convergeparam['vmperrabsmax'] = max(abs(vmperror))\n    # mean of the error in Vmp\n    convergeparam['vmperrmean'] = np.mean(vmperror, axis=0)\n    # std of the error in Vmp\n    convergeparam['vmperrstd'] = np.std(vmperror, axis=0, ddof=1)\n\n    convergeparam['pmperrmax'] = max(pmperror)  # max of the error in Pmp\n    convergeparam['pmperrmin'] = min(pmperror)  # min of the error in Pmp\n    # max of the abs err. in Pmp\n    convergeparam['pmperrabsmax'] = max(abs(pmperror))\n    # mean error in Pmp\n    convergeparam['pmperrmean'] = np.mean(pmperror, axis=0)\n    # std error Pmp\n    convergeparam['pmperrstd'] = np.std(pmperror, axis=0, ddof=1)\n\n    if prevparams['state'] != 0.0:\n        convergeparam['imperrstdchange'] = np.abs(\n            convergeparam['imperrstd'] / prevparams['imperrstd'] - 1.)\n        convergeparam['vmperrstdchange'] = np.abs(\n            convergeparam['vmperrstd'] / prevparams['vmperrstd'] - 1.)\n        convergeparam['pmperrstdchange'] = np.abs(\n            convergeparam['pmperrstd'] / prevparams['pmperrstd'] - 1.)\n        convergeparam['imperrmeanchange'] = np.abs(\n            convergeparam['imperrmean'] / prevparams['imperrmean'] - 1.)\n        convergeparam['vmperrmeanchange'] = np.abs(\n            convergeparam['vmperrmean'] / prevparams['vmperrmean'] - 1.)\n        convergeparam['pmperrmeanchange'] = np.abs(\n            convergeparam['pmperrmean'] / prevparams['pmperrmean'] - 1.)\n        convergeparam['imperrabsmaxchange'] = np.abs(\n            convergeparam['imperrabsmax'] / prevparams['imperrabsmax'] - 1.)\n        convergeparam['vmperrabsmaxchange'] = np.abs(\n            convergeparam['vmperrabsmax'] / prevparams['vmperrabsmax'] - 1.)\n        convergeparam['pmperrabsmaxchange'] = np.abs(\n            convergeparam['pmperrabsmax'] / prevparams['pmperrabsmax'] - 1.)\n        convergeparam['state'] = 1.0\n    else:\n        convergeparam['imperrstdchange'] = float(\"Inf\")\n        convergeparam['vmperrstdchange'] = float(\"Inf\")\n        convergeparam['pmperrstdchange'] = float(\"Inf\")\n        convergeparam['imperrmeanchange'] = float(\"Inf\")\n        convergeparam['vmperrmeanchange'] = float(\"Inf\")\n        convergeparam['pmperrmeanchange'] = float(\"Inf\")\n        convergeparam['imperrabsmaxchange'] = float(\"Inf\")\n        convergeparam['vmperrabsmaxchange'] = float(\"Inf\")\n        convergeparam['pmperrabsmaxchange'] = float(\"Inf\")\n        convergeparam['state'] = 1.\n    return convergeparam\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_check_converge", "prevparams", "result", "vmp", "imp", "i", "function", "_check_converge", "computes", "convergence", "metrics", "for", "all", "iv", "curves", "helper", "function", "for", "fit_pvsyst_sandia", "fit_desoto_sandia", "parameters", "prevparams", "convergence", "parameters", "from", "the", "previous", "iteration", "used", "to", "determine", "percent", "change", "in", "values", "between", "iterations", "result", "performacne", "paramters", "of", "the", "predicted", "single", "diode", "fitting", "which", "includes", "voc", "vmp", "imp", "pmp", "and", "isc", "vmp", "measured", "values", "for", "each", "iv", "curve", "imp", "measured", "values", "for", "each", "iv", "curve", "i", "index", "of", "current", "iteration", "in", "cec_parameter_estimation", "returns", "convergeparam", "dict", "containing", "the", "following", "for", "imp", "vmp", "and", "pmp", "maximum", "percent", "difference", "between", "measured", "and", "modeled", "values", "minimum", "percent", "difference", "between", "measured", "and", "modeled", "values", "maximum", "absolute", "percent", "difference", "between", "measured", "and", "modeled", "values", "mean", "percent", "difference", "between", "measured", "and", "modeled", "values", "standard", "deviation", "of", "percent", "difference", "between", "measured", "and", "modeled", "values", "absolute", "difference", "for", "previous", "and", "current", "values", "of", "maximum", "absolute", "percent", "difference", "measured", "vs", "modeled", "absolute", "difference", "for", "previous", "and", "current", "values", "of", "mean", "percent", "difference", "measured", "vs", "modeled", "absolute", "difference", "for", "previous", "and", "current", "values", "of", "standard", "deviation", "of", "percent", "difference", "measured", "vs", "modeled", "convergeparam", "imperror", "result", "i_mp", "imp", "imp", "100", "vmperror", "result", "v_mp", "vmp", "vmp", "100", "pmperror", "result", "p_mp", "imp", "vmp", "imp", "vmp", "100", "convergeparam", "imperrmax", "max", "imperror", "max", "of", "the", "error", "in", "imp", "convergeparam", "imperrmin", "min", "imperror", "min", "of", "the", "error", "in", "imp", "max", "of", "the", "absolute", "error", "in", "imp", "convergeparam", "imperrabsmax", "max", "abs", "imperror", "mean", "of", "the", "error", "in", "imp", "convergeparam", "imperrmean", "np", "mean", "imperror", "axis", "0", "std", "of", "the", "error", "in", "imp", "convergeparam", "imperrstd", "np", "std", "imperror", "axis", "0", "ddof", "1", "convergeparam", "vmperrmax", "max", "vmperror", "max", "of", "the", "error", "in", "vmp", "convergeparam", "vmperrmin", "min", "vmperror", "min", "of", "the", "error", "in", "vmp", "max", "of", "the", "absolute", "error", "in", "vmp", "convergeparam", "vmperrabsmax", "max", "abs", "vmperror", "mean", "of", "the", "error", "in", "vmp", "convergeparam", "vmperrmean", "np", "mean", "vmperror", "axis", "0", "std", "of", "the", "error", "in", "vmp", "convergeparam", "vmperrstd", "np", "std", "vmperror", "axis", "0", "ddof", "1", "convergeparam", "pmperrmax", "max", "pmperror", "max", "of", "the", "error", "in", "pmp", "convergeparam", "pmperrmin", "min", "pmperror", "min", "of", "the", "error", "in", "pmp", "max", "of", "the", "abs", "err", "in", "pmp", "convergeparam", "pmperrabsmax", "max", "abs", "pmperror", "mean", "error", "in", "pmp", "convergeparam", "pmperrmean", "np", "mean", "pmperror", "axis", "0", "std", "error", "pmp", "convergeparam", "pmperrstd", "np", "std", "pmperror", "axis", "0", "ddof", "1", "if", "prevparams", "state", "0", "0", "convergeparam", "imperrstdchange", "np", "abs", "convergeparam", "imperrstd", "prevparams", "imperrstd", "1", "convergeparam", "vmperrstdchange", "np", "abs", "convergeparam", "vmperrstd", "prevparams", "vmperrstd", "1", "convergeparam", "pmperrstdchange", "np", "abs", "convergeparam", "pmperrstd", "prevparams", "pmperrstd", "1", "convergeparam", "imperrmeanchange", "np", "abs", "convergeparam", "imperrmean", "prevparams", "imperrmean", "1", "convergeparam", "vmperrmeanchange", "np", "abs", "convergeparam", "vmperrmean", "prevparams", "vmperrmean", "1", "convergeparam", "pmperrmeanchange", "np", "abs", "convergeparam", "pmperrmean", "prevparams", "pmperrmean", "1", "convergeparam", "imperrabsmaxchange", "np", "abs", "convergeparam", "imperrabsmax", "prevparams", "imperrabsmax", "1", "convergeparam", "vmperrabsmaxchange", "np", "abs", "convergeparam", "vmperrabsmax", "prevparams", "vmperrabsmax", "1", "convergeparam", "pmperrabsmaxchange", "np", "abs", "convergeparam", "pmperrabsmax", "prevparams", "pmperrabsmax", "1", "convergeparam", "state", "1", "0", "else", "convergeparam", "imperrstdchange", "float", "inf", "convergeparam", "vmperrstdchange", "float", "inf", "convergeparam", "pmperrstdchange", "float", "inf", "convergeparam", "imperrmeanchange", "float", "inf", "convergeparam", "vmperrmeanchange", "float", "inf", "convergeparam", "pmperrmeanchange", "float", "inf", "convergeparam", "imperrabsmaxchange", "float", "inf", "convergeparam", "vmperrabsmaxchange", "float", "inf", "convergeparam", "pmperrabsmaxchange", "float", "inf", "convergeparam", "state", "1", "return", "convergeparam"], "doc_len": 507}
{"doc_id": "pvlib/ivtools/sdm.py::_update_rsh_fixed_pt", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_update_rsh_fixed_pt", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _update_rsh_fixed_pt(vmp, imp, iph, io, rs, rsh, nnsvth):\n    \"\"\"\n    Adjust Rsh to match Vmp using other parameter values\n\n    Helper function for fit_pvsyst_sandia, fit_desoto_sandia\n\n    Description\n    -----------\n    Rsh is updated iteratively using a fixed point expression\n    obtained from combining Vmp = Vmp(Imp) (using the analytic solution to the\n    single diode equation) and dP / dI = 0 at Imp. 500 iterations are performed\n    because convergence can be very slow.\n\n    Parameters\n    ----------\n    vmp: a numpy array of length N of values for Vmp (V)\n    imp: a numpy array of length N of values for Imp (A)\n    iph: a numpy array of length N of values for light current IL (A)\n    io: a numpy array of length N of values for Io (A)\n    rs: a numpy array of length N of values for series resistance (ohm)\n    rsh: a numpy array of length N of initial values for shunt resistance (ohm)\n    nnsvth: a numpy array length N of values for the diode factor x thermal\n            voltage for the module, equal to Ns (number of cells in series) x\n            Vth (thermal voltage per cell).\n\n    Returns\n    -------\n    numpy array of length N of updated values for Rsh\n\n    References\n    ----------\n    .. [1] PVLib for MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    .. [2] C. Hansen, Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n    \"\"\"\n    niter = 500\n    x1 = rsh\n\n    for i in range(niter):\n        _, z = _calc_theta_phi_exact(vmp, imp, iph, io, rs, x1, nnsvth)\n        with np.errstate(divide=\"ignore\"):\n            next_x1 = (1 + z) / z * ((iph + io) * x1 / imp - nnsvth * z / imp\n                                     - 2 * vmp / imp)\n        x1 = next_x1\n\n    return x1\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_update_rsh_fixed_pt", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "adjust", "rsh", "to", "match", "vmp", "using", "other", "parameter", "values", "helper", "function", "for", "fit_pvsyst_sandia", "fit_desoto_sandia", "description", "rsh", "is", "updated", "iteratively", "using", "a", "fixed", "point", "expression", "obtained", "from", "combining", "vmp", "vmp", "imp", "using", "the", "analytic", "solution", "to", "the", "single", "diode", "equation", "and", "dp", "di", "0", "at", "imp", "500", "iterations", "are", "performed", "because", "convergence", "can", "be", "very", "slow", "parameters", "vmp", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "vmp", "v", "imp", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "imp", "a", "iph", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "light", "current", "il", "a", "io", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "io", "a", "rs", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "series", "resistance", "ohm", "rsh", "a", "numpy", "array", "of", "length", "n", "of", "initial", "values", "for", "shunt", "resistance", "ohm", "nnsvth", "a", "numpy", "array", "length", "n", "of", "values", "for", "the", "diode", "factor", "x", "thermal", "voltage", "for", "the", "module", "equal", "to", "ns", "number", "of", "cells", "in", "series", "x", "vth", "thermal", "voltage", "per", "cell", "returns", "numpy", "array", "of", "length", "n", "of", "updated", "values", "for", "rsh", "references", "1", "pvlib", "for", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "2", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "niter", "500", "x1", "rsh", "for", "i", "in", "range", "niter", "_", "z", "_calc_theta_phi_exact", "vmp", "imp", "iph", "io", "rs", "x1", "nnsvth", "with", "np", "errstate", "divide", "ignore", "next_x1", "1", "z", "z", "iph", "io", "x1", "imp", "nnsvth", "z", "imp", "2", "vmp", "imp", "x1", "next_x1", "return", "x1"], "doc_len": 259}
{"doc_id": "pvlib/ivtools/sdm.py::_calc_theta_phi_exact", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "_calc_theta_phi_exact", "text": "文件路径: pvlib/ivtools/sdm.py\ndef _calc_theta_phi_exact(vmp, imp, iph, io, rs, rsh, nnsvth):\n    \"\"\"\n    _calc_theta_phi_exact computes Lambert W values appearing in the analytic\n    solutions to the single diode equation for the max power point.\n\n    Helper function for fit_pvsyst_sandia\n\n    Parameters\n    ----------\n    vmp: a numpy array of length N of values for Vmp (V)\n    imp: a numpy array of length N of values for Imp (A)\n    iph: a numpy array of length N of values for the light current IL (A)\n    io: a numpy array of length N of values for Io (A)\n    rs: a numpy array of length N of values for the series resistance (ohm)\n    rsh: a numpy array of length N of values for the shunt resistance (ohm)\n    nnsvth: a numpy array of length N of values for the diode factor x\n            thermal voltage for the module, equal to Ns\n            (number of cells in series) x Vth\n            (thermal voltage per cell).\n\n    Returns\n    -------\n    theta: a numpy array of values for the Lamber W function for solving\n           I = I(V)\n    phi: a numpy array of values for the Lambert W function for solving\n         V = V(I)\n\n    Notes\n    -----\n    _calc_theta_phi_exact calculates values for the Lambert W function which\n    are used in the analytic solutions for the single diode equation at the\n    maximum power point. For V=V(I),\n    phi = W(Io*Rsh/n*Vth * exp((IL + Io - Imp)*Rsh/n*Vth)). For I=I(V),\n    theta = W(Rs*Io/n*Vth *\n    Rsh/ (Rsh+Rs) * exp(Rsh/ (Rsh+Rs)*((Rs(IL+Io) + V)/n*Vth))\n\n    References\n    ----------\n    .. [1] PVL MATLAB 2065 https://github.com/sandialabs/MATLAB_PV_LIB\n    .. [2] C. Hansen, Parameter Estimation for Single Diode Models of\n       Photovoltaic Modules, Sandia National Laboratories Report SAND2015-2065\n    .. [3] A. Jain, A. Kapoor, \"Exact analytical solutions of the parameters of\n       real solar cells using Lambert W-function\", Solar Energy Materials and\n       Solar Cells, 81 (2004) 269-277.\n    \"\"\"\n    # handle singleton inputs\n    vmp = np.asarray(vmp)\n    imp = np.asarray(imp)\n    iph = np.asarray(iph)\n    io = np.asarray(io)\n    rs = np.asarray(rs)\n    rsh = np.asarray(rsh)\n    nnsvth = np.asarray(nnsvth)\n\n    # Argument for Lambert W function involved in V = V(I) [2] Eq. 12; [3]\n    # Eq. 3\n    with np.errstate(over=\"ignore\", divide=\"ignore\", invalid=\"ignore\"):\n        argw = np.where(\n            nnsvth == 0,\n            np.nan,\n            rsh * io / nnsvth * np.exp(rsh * (iph + io - imp) / nnsvth))\n        phi = np.where(argw > 0, lambertw(argw).real, np.nan)\n\n    # NaN where argw overflows. Switch to log space to evaluate\n    u = np.isinf(argw)\n    if np.any(u):\n        logargw = (\n            np.log(rsh[u]) + np.log(io[u]) - np.log(nnsvth[u])\n            + rsh[u] * (iph[u] + io[u] - imp[u]) / nnsvth[u])\n        # Three iterations of Newton-Raphson method to solve w+log(w)=logargW.\n        # The initial guess is w=logargW. Where direct evaluation (above)\n        # results in NaN from overflow, 3 iterations of Newton's method gives\n        # approximately 8 digits of precision.\n        x = logargw\n        for i in range(3):\n            x *= ((1. - np.log(x) + logargw) / (1. + x))\n        phi[u] = x\n    phi = np.transpose(phi)\n\n    # Argument for Lambert W function involved in I = I(V) [2] Eq. 11; [3]\n    # E1. 2\n    with np.errstate(over=\"ignore\", divide=\"ignore\", invalid=\"ignore\"):\n        argw = np.where(\n            nnsvth == 0,\n            np.nan,\n            rsh / (rsh + rs) * rs * io / nnsvth * np.exp(\n                rsh / (rsh + rs) * (rs * (iph + io) + vmp) / nnsvth))\n        theta = np.where(argw > 0, lambertw(argw).real, np.nan)\n\n    # NaN where argw overflows. Switch to log space to evaluate\n    u = np.isinf(argw)\n    if np.any(u):\n        with np.errstate(divide=\"ignore\"):\n            logargw = (\n                np.log(rsh[u]) - np.log(rsh[u] + rs[u]) + np.log(rs[u])\n                + np.log(io[u]) - np.log(nnsvth[u])\n                + (rsh[u] / (rsh[u] + rs[u]))\n                * (rs[u] * (iph[u] + io[u]) + vmp[u]) / nnsvth[u])\n        # Three iterations of Newton-Raphson method to solve w+log(w)=logargW.\n        # The initial guess is w=logargW. Where direct evaluation (above)\n        # results in NaN from overflow, 3 iterations of Newton's method gives\n        # approximately 8 digits of precision.\n        x = logargw\n        for i in range(3):\n            x *= ((1. - np.log(x) + logargw) / (1. + x))\n        theta[u] = x\n    theta = np.transpose(theta)\n\n    return theta, phi\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "_calc_theta_phi_exact", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "_calc_theta_phi_exact", "computes", "lambert", "w", "values", "appearing", "in", "the", "analytic", "solutions", "to", "the", "single", "diode", "equation", "for", "the", "max", "power", "point", "helper", "function", "for", "fit_pvsyst_sandia", "parameters", "vmp", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "vmp", "v", "imp", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "imp", "a", "iph", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "light", "current", "il", "a", "io", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "io", "a", "rs", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "series", "resistance", "ohm", "rsh", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "shunt", "resistance", "ohm", "nnsvth", "a", "numpy", "array", "of", "length", "n", "of", "values", "for", "the", "diode", "factor", "x", "thermal", "voltage", "for", "the", "module", "equal", "to", "ns", "number", "of", "cells", "in", "series", "x", "vth", "thermal", "voltage", "per", "cell", "returns", "theta", "a", "numpy", "array", "of", "values", "for", "the", "lamber", "w", "function", "for", "solving", "i", "i", "v", "phi", "a", "numpy", "array", "of", "values", "for", "the", "lambert", "w", "function", "for", "solving", "v", "v", "i", "notes", "_calc_theta_phi_exact", "calculates", "values", "for", "the", "lambert", "w", "function", "which", "are", "used", "in", "the", "analytic", "solutions", "for", "the", "single", "diode", "equation", "at", "the", "maximum", "power", "point", "for", "v", "v", "i", "phi", "w", "io", "rsh", "n", "vth", "exp", "il", "io", "imp", "rsh", "n", "vth", "for", "i", "i", "v", "theta", "w", "rs", "io", "n", "vth", "rsh", "rsh", "rs", "exp", "rsh", "rsh", "rs", "rs", "il", "io", "v", "n", "vth", "references", "1", "pvl", "matlab", "2065", "https", "github", "com", "sandialabs", "matlab_pv_lib", "2", "c", "hansen", "parameter", "estimation", "for", "single", "diode", "models", "of", "photovoltaic", "modules", "sandia", "national", "laboratories", "report", "sand2015", "2065", "3", "a", "jain", "a", "kapoor", "exact", "analytical", "solutions", "of", "the", "parameters", "of", "real", "solar", "cells", "using", "lambert", "w", "function", "solar", "energy", "materials", "and", "solar", "cells", "81", "2004", "269", "277", "handle", "singleton", "inputs", "vmp", "np", "asarray", "vmp", "imp", "np", "asarray", "imp", "iph", "np", "asarray", "iph", "io", "np", "asarray", "io", "rs", "np", "asarray", "rs", "rsh", "np", "asarray", "rsh", "nnsvth", "np", "asarray", "nnsvth", "argument", "for", "lambert", "w", "function", "involved", "in", "v", "v", "i", "2", "eq", "12", "3", "eq", "3", "with", "np", "errstate", "over", "ignore", "divide", "ignore", "invalid", "ignore", "argw", "np", "where", "nnsvth", "0", "np", "nan", "rsh", "io", "nnsvth", "np", "exp", "rsh", "iph", "io", "imp", "nnsvth", "phi", "np", "where", "argw", "0", "lambertw", "argw", "real", "np", "nan", "nan", "where", "argw", "overflows", "switch", "to", "log", "space", "to", "evaluate", "u", "np", "isinf", "argw", "if", "np", "any", "u", "logargw", "np", "log", "rsh", "u", "np", "log", "io", "u", "np", "log", "nnsvth", "u", "rsh", "u", "iph", "u", "io", "u", "imp", "u", "nnsvth", "u", "three", "iterations", "of", "newton", "raphson", "method", "to", "solve", "w", "log", "w", "logargw", "the", "initial", "guess", "is", "w", "logargw", "where", "direct", "evaluation", "above", "results", "in", "nan", "from", "overflow", "3", "iterations", "of", "newton", "s", "method", "gives", "approximately", "8", "digits", "of", "precision", "x", "logargw", "for", "i", "in", "range", "3", "x", "1", "np", "log", "x", "logargw", "1", "x", "phi", "u", "x", "phi", "np", "transpose", "phi", "argument", "for", "lambert", "w", "function", "involved", "in", "i", "i", "v", "2", "eq", "11", "3", "e1", "2", "with", "np", "errstate", "over", "ignore", "divide", "ignore", "invalid", "ignore", "argw", "np", "where", "nnsvth", "0", "np", "nan", "rsh", "rsh", "rs", "rs", "io", "nnsvth", "np", "exp", "rsh", "rsh", "rs", "rs", "iph", "io", "vmp", "nnsvth", "theta", "np", "where", "argw", "0", "lambertw", "argw", "real", "np", "nan", "nan", "where", "argw", "overflows", "switch", "to", "log", "space", "to", "evaluate", "u", "np", "isinf", "argw", "if", "np", "any", "u", "with", "np", "errstate", "divide", "ignore", "logargw", "np", "log", "rsh", "u", "np", "log", "rsh", "u", "rs", "u", "np", "log", "rs", "u", "np", "log", "io", "u", "np", "log", "nnsvth", "u", "rsh", "u", "rsh", "u", "rs", "u", "rs", "u", "iph", "u", "io", "u", "vmp", "u", "nnsvth", "u", "three", "iterations", "of", "newton", "raphson", "method", "to", "solve", "w", "log", "w", "logargw", "the", "initial", "guess", "is", "w", "logargw", "where", "direct", "evaluation", "above", "results", "in", "nan", "from", "overflow", "3", "iterations", "of", "newton", "s", "method", "gives", "approximately", "8", "digits", "of", "precision", "x", "logargw", "for", "i", "in", "range", "3", "x", "1", "np", "log", "x", "logargw", "1", "x", "theta", "u", "x", "theta", "np", "transpose", "theta", "return", "theta", "phi"], "doc_len": 675}
{"doc_id": "pvlib/ivtools/sdm.py::pvsyst_temperature_coeff", "file_path": "pvlib/ivtools/sdm.py", "class_name": null, "func_name": "pvsyst_temperature_coeff", "text": "文件路径: pvlib/ivtools/sdm.py\ndef pvsyst_temperature_coeff(alpha_sc, gamma_ref, mu_gamma, I_L_ref, I_o_ref,\n                             R_sh_ref, R_sh_0, R_s, cells_in_series,\n                             R_sh_exp=5.5, EgRef=1.121, irrad_ref=1000,\n                             temp_ref=25):\n    r\"\"\"\n    Calculates the temperature coefficient of power for a pvsyst single\n    diode model.\n\n    The temperature coefficient is determined as the numerical derivative\n    :math:`\\frac{dP}{dT}` at the maximum power point at reference conditions\n    [1]_.\n\n    Parameters\n    ----------\n    alpha_sc : float\n        The short-circuit current temperature coefficient of the module. [A/C]\n\n    gamma_ref : float\n        The diode ideality factor. [unitless]\n\n    mu_gamma : float\n        The temperature coefficient for the diode ideality factor. [1/K]\n\n    I_L_ref : float\n        The light-generated current (or photocurrent) at reference conditions.\n        [A]\n\n    I_o_ref : float\n        The dark or diode reverse saturation current at reference conditions.\n        [A]\n\n    R_sh_ref : float\n        The shunt resistance at reference conditions. [ohm]\n\n    R_sh_0 : float\n        The shunt resistance at zero irradiance conditions. [ohm]\n\n    R_s : float\n        The series resistance at reference conditions. [ohm]\n\n    cells_in_series : int\n        The number of cells connected in series.\n\n    R_sh_exp : float, default 5.5\n        The exponent in the equation for shunt resistance. [unitless]\n\n    EgRef : float, default 1.121\n        The energy bandgap of the module's cells at reference temperature.\n        Default of 1.121 eV is for crystalline silicon. Must be positive. [eV]\n\n    irrad_ref : float, default 1000\n        Reference irradiance. [W/m^2].\n\n    temp_ref : float, default 25\n        Reference cell temperature. [C]\n\n\n    Returns\n    -------\n    gamma_pdc : float\n        Temperature coefficient of power at maximum power point at reference\n        conditions. [1/C]\n\n    References\n    ----------\n    .. [1] K. Sauer, T. Roessler, C. W. Hansen, Modeling the Irradiance and\n       Temperature Dependence of Photovoltaic Modules in PVsyst, IEEE Journal\n       of Photovoltaics v5(1), January 2015.\n    \"\"\"\n\n    def maxp(temp_cell, irrad_ref, alpha_sc, gamma_ref, mu_gamma, I_L_ref,\n             I_o_ref, R_sh_ref, R_sh_0, R_s, cells_in_series, R_sh_exp, EgRef,\n             temp_ref):\n        params = calcparams_pvsyst(\n            irrad_ref, temp_cell, alpha_sc, gamma_ref, mu_gamma, I_L_ref,\n            I_o_ref, R_sh_ref, R_sh_0, R_s, cells_in_series, R_sh_exp, EgRef,\n            irrad_ref, temp_ref)\n        res = bishop88_mpp(*params)\n        return res[2]\n\n    args = (irrad_ref, alpha_sc, gamma_ref, mu_gamma, I_L_ref,\n            I_o_ref, R_sh_ref, R_sh_0, R_s, cells_in_series, R_sh_exp, EgRef,\n            temp_ref)\n    pmp = maxp(temp_ref, *args)\n    gamma_pdc = derivative(maxp, temp_ref, args=args)\n    return gamma_pdc / pmp\n", "tokens": ["pvlib", "ivtools", "sdm", "py", "def", "pvsyst_temperature_coeff", "alpha_sc", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_s", "cells_in_series", "r_sh_exp", "5", "5", "egref", "1", "121", "irrad_ref", "1000", "temp_ref", "25", "r", "calculates", "the", "temperature", "coefficient", "of", "power", "for", "a", "pvsyst", "single", "diode", "model", "the", "temperature", "coefficient", "is", "determined", "as", "the", "numerical", "derivative", "math", "frac", "dp", "dt", "at", "the", "maximum", "power", "point", "at", "reference", "conditions", "1", "_", "parameters", "alpha_sc", "float", "the", "short", "circuit", "current", "temperature", "coefficient", "of", "the", "module", "a", "c", "gamma_ref", "float", "the", "diode", "ideality", "factor", "unitless", "mu_gamma", "float", "the", "temperature", "coefficient", "for", "the", "diode", "ideality", "factor", "1", "k", "i_l_ref", "float", "the", "light", "generated", "current", "or", "photocurrent", "at", "reference", "conditions", "a", "i_o_ref", "float", "the", "dark", "or", "diode", "reverse", "saturation", "current", "at", "reference", "conditions", "a", "r_sh_ref", "float", "the", "shunt", "resistance", "at", "reference", "conditions", "ohm", "r_sh_0", "float", "the", "shunt", "resistance", "at", "zero", "irradiance", "conditions", "ohm", "r_s", "float", "the", "series", "resistance", "at", "reference", "conditions", "ohm", "cells_in_series", "int", "the", "number", "of", "cells", "connected", "in", "series", "r_sh_exp", "float", "default", "5", "5", "the", "exponent", "in", "the", "equation", "for", "shunt", "resistance", "unitless", "egref", "float", "default", "1", "121", "the", "energy", "bandgap", "of", "the", "module", "s", "cells", "at", "reference", "temperature", "default", "of", "1", "121", "ev", "is", "for", "crystalline", "silicon", "must", "be", "positive", "ev", "irrad_ref", "float", "default", "1000", "reference", "irradiance", "w", "m", "2", "temp_ref", "float", "default", "25", "reference", "cell", "temperature", "c", "returns", "gamma_pdc", "float", "temperature", "coefficient", "of", "power", "at", "maximum", "power", "point", "at", "reference", "conditions", "1", "c", "references", "1", "k", "sauer", "t", "roessler", "c", "w", "hansen", "modeling", "the", "irradiance", "and", "temperature", "dependence", "of", "photovoltaic", "modules", "in", "pvsyst", "ieee", "journal", "of", "photovoltaics", "v5", "1", "january", "2015", "def", "maxp", "temp_cell", "irrad_ref", "alpha_sc", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_s", "cells_in_series", "r_sh_exp", "egref", "temp_ref", "params", "calcparams_pvsyst", "irrad_ref", "temp_cell", "alpha_sc", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_s", "cells_in_series", "r_sh_exp", "egref", "irrad_ref", "temp_ref", "res", "bishop88_mpp", "params", "return", "res", "2", "args", "irrad_ref", "alpha_sc", "gamma_ref", "mu_gamma", "i_l_ref", "i_o_ref", "r_sh_ref", "r_sh_0", "r_s", "cells_in_series", "r_sh_exp", "egref", "temp_ref", "pmp", "maxp", "temp_ref", "args", "gamma_pdc", "derivative", "maxp", "temp_ref", "args", "args", "return", "gamma_pdc", "pmp"], "doc_len": 326}
{"doc_id": "pvlib/ivtools/utils.py::_numdiff", "file_path": "pvlib/ivtools/utils.py", "class_name": null, "func_name": "_numdiff", "text": "文件路径: pvlib/ivtools/utils.py\ndef _numdiff(x, f):\n    \"\"\"\n    Compute first and second order derivative using possibly unequally\n    spaced data.\n\n    Parameters\n    ----------\n    x : numeric\n        a numpy array of values of x\n    f : numeric\n        a numpy array of values of the function f for which derivatives are to\n        be computed. Must be the same length as x.\n\n    Returns\n    -------\n    df : numeric\n        a numpy array of len(x) containing the first derivative of f at each\n        point x except at the first 2 and last 2 points\n    df2 : numeric\n        a numpy array of len(x) containing the second derivative of f at each\n        point x except at the first 2 and last 2 points.\n\n    Notes\n    -----\n    ``numdiff`` computes first and second order derivatives using a 5th order\n    formula that accounts for possibly unequally spaced data [1]_. Because a\n    5th order centered difference formula is used, ``numdiff`` returns NaNs\n    for the first 2 and last 2 points in the input vector for x. Ported from\n    PVLib Matlab [2]_.\n\n    References\n    ----------\n    .. [1] M. K. Bowen, R. Smith, \"Derivative formulae and errors for\n       non-uniformly spaced points\", Proceedings of the Royal Society A, vol.\n       461 pp 1975 - 1997, July 2005. DOI: 10.1098/rpsa.2004.1430\n    .. [2] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    \"\"\"\n\n    n = len(f)\n\n    df = np.zeros(n)\n    df2 = np.zeros(n)\n\n    # first two points are special\n    df[:2] = float(\"Nan\")\n    df2[:2] = float(\"Nan\")\n\n    # Last two points are special\n    df[-2:] = float(\"Nan\")\n    df2[-2:] = float(\"Nan\")\n\n    # Rest of points. Take reference point to be the middle of each group of 5\n    # points. Calculate displacements\n    ff = np.vstack((f[:-4], f[1:-3], f[2:-2], f[3:-1], f[4:])).T\n\n    a0 = (np.vstack((x[:-4], x[1:-3], x[2:-2], x[3:-1], x[4:])).T\n          - np.tile(x[2:-2], [5, 1]).T)\n\n    u1 = np.zeros(a0.shape)\n    left = np.zeros(a0.shape)\n    u2 = np.zeros(a0.shape)\n\n    u1[:, 0] = (\n        a0[:, 1] * a0[:, 2] * a0[:, 3] + a0[:, 1] * a0[:, 2] * a0[:, 4]\n        + a0[:, 1] * a0[:, 3] * a0[:, 4] + a0[:, 2] * a0[:, 3] * a0[:, 4])\n    u1[:, 1] = (\n        a0[:, 0] * a0[:, 2] * a0[:, 3] + a0[:, 0] * a0[:, 2] * a0[:, 4]\n        + a0[:, 0] * a0[:, 3] * a0[:, 4] + a0[:, 2] * a0[:, 3] * a0[:, 4])\n    u1[:, 2] = (\n        a0[:, 0] * a0[:, 1] * a0[:, 3] + a0[:, 0] * a0[:, 1] * a0[:, 4]\n        + a0[:, 0] * a0[:, 3] * a0[:, 4] + a0[:, 1] * a0[:, 3] * a0[:, 4])\n    u1[:, 3] = (\n        a0[:, 0] * a0[:, 1] * a0[:, 2] + a0[:, 0] * a0[:, 1] * a0[:, 4]\n        + a0[:, 0] * a0[:, 2] * a0[:, 4] + a0[:, 1] * a0[:, 2] * a0[:, 4])\n    u1[:, 4] = (\n        a0[:, 0] * a0[:, 1] * a0[:, 2] + a0[:, 0] * a0[:, 1] * a0[:, 3]\n        + a0[:, 0] * a0[:, 2] * a0[:, 3] + a0[:, 1] * a0[:, 2] * a0[:, 3])\n\n    left[:, 0] = (a0[:, 0] - a0[:, 1]) * (a0[:, 0] - a0[:, 2]) * \\\n        (a0[:, 0] - a0[:, 3]) * (a0[:, 0] - a0[:, 4])\n    left[:, 1] = (a0[:, 1] - a0[:, 0]) * (a0[:, 1] - a0[:, 2]) * \\\n        (a0[:, 1] - a0[:, 3]) * (a0[:, 1] - a0[:, 4])\n    left[:, 2] = (a0[:, 2] - a0[:, 0]) * (a0[:, 2] - a0[:, 1]) * \\\n        (a0[:, 2] - a0[:, 3]) * (a0[:, 2] - a0[:, 4])\n    left[:, 3] = (a0[:, 3] - a0[:, 0]) * (a0[:, 3] - a0[:, 1]) * \\\n        (a0[:, 3] - a0[:, 2]) * (a0[:, 3] - a0[:, 4])\n    left[:, 4] = (a0[:, 4] - a0[:, 0]) * (a0[:, 4] - a0[:, 1]) * \\\n        (a0[:, 4] - a0[:, 2]) * (a0[:, 4] - a0[:, 3])\n\n    df[2:-2] = np.sum(-(u1 / left) * ff, axis=1)\n\n    # second derivative\n    u2[:, 0] = (\n        a0[:, 1] * a0[:, 2] + a0[:, 1] * a0[:, 3] + a0[:, 1] * a0[:, 4]\n        + a0[:, 2] * a0[:, 3] + a0[:, 2] * a0[:, 4] + a0[:, 3] * a0[:, 4])\n    u2[:, 1] = (\n        a0[:, 0] * a0[:, 2] + a0[:, 0] * a0[:, 3] + a0[:, 0] * a0[:, 4]\n        + a0[:, 2] * a0[:, 3] + a0[:, 2] * a0[:, 4] + a0[:, 3] * a0[:, 4])\n    u2[:, 2] = (\n        a0[:, 0] * a0[:, 1] + a0[:, 0] * a0[:, 3] + a0[:, 0] * a0[:, 4]\n        + a0[:, 1] * a0[:, 3] + a0[:, 1] * a0[:, 3] + a0[:, 3] * a0[:, 4])\n    u2[:, 3] = (\n        a0[:, 0] * a0[:, 1] + a0[:, 0] * a0[:, 2] + a0[:, 0] * a0[:, 4]\n        + a0[:, 1] * a0[:, 2] + a0[:, 1] * a0[:, 4] + a0[:, 2] * a0[:, 4])\n    u2[:, 4] = (\n        a0[:, 0] * a0[:, 1] + a0[:, 0] * a0[:, 2] + a0[:, 0] * a0[:, 3]\n        + a0[:, 1] * a0[:, 2] + a0[:, 1] * a0[:, 4] + a0[:, 2] * a0[:, 3])\n\n    df2[2:-2] = 2. * np.sum(u2 * ff, axis=1)\n    return df, df2\n", "tokens": ["pvlib", "ivtools", "utils", "py", "def", "_numdiff", "x", "f", "compute", "first", "and", "second", "order", "derivative", "using", "possibly", "unequally", "spaced", "data", "parameters", "x", "numeric", "a", "numpy", "array", "of", "values", "of", "x", "f", "numeric", "a", "numpy", "array", "of", "values", "of", "the", "function", "f", "for", "which", "derivatives", "are", "to", "be", "computed", "must", "be", "the", "same", "length", "as", "x", "returns", "df", "numeric", "a", "numpy", "array", "of", "len", "x", "containing", "the", "first", "derivative", "of", "f", "at", "each", "point", "x", "except", "at", "the", "first", "2", "and", "last", "2", "points", "df2", "numeric", "a", "numpy", "array", "of", "len", "x", "containing", "the", "second", "derivative", "of", "f", "at", "each", "point", "x", "except", "at", "the", "first", "2", "and", "last", "2", "points", "notes", "numdiff", "computes", "first", "and", "second", "order", "derivatives", "using", "a", "5th", "order", "formula", "that", "accounts", "for", "possibly", "unequally", "spaced", "data", "1", "_", "because", "a", "5th", "order", "centered", "difference", "formula", "is", "used", "numdiff", "returns", "nans", "for", "the", "first", "2", "and", "last", "2", "points", "in", "the", "input", "vector", "for", "x", "ported", "from", "pvlib", "matlab", "2", "_", "references", "1", "m", "k", "bowen", "r", "smith", "derivative", "formulae", "and", "errors", "for", "non", "uniformly", "spaced", "points", "proceedings", "of", "the", "royal", "society", "a", "vol", "461", "pp", "1975", "1997", "july", "2005", "doi", "10", "1098", "rpsa", "2004", "1430", "2", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "n", "len", "f", "df", "np", "zeros", "n", "df2", "np", "zeros", "n", "first", "two", "points", "are", "special", "df", "2", "float", "nan", "df2", "2", "float", "nan", "last", "two", "points", "are", "special", "df", "2", "float", "nan", "df2", "2", "float", "nan", "rest", "of", "points", "take", "reference", "point", "to", "be", "the", "middle", "of", "each", "group", "of", "5", "points", "calculate", "displacements", "ff", "np", "vstack", "f", "4", "f", "1", "3", "f", "2", "2", "f", "3", "1", "f", "4", "t", "a0", "np", "vstack", "x", "4", "x", "1", "3", "x", "2", "2", "x", "3", "1", "x", "4", "t", "np", "tile", "x", "2", "2", "5", "1", "t", "u1", "np", "zeros", "a0", "shape", "left", "np", "zeros", "a0", "shape", "u2", "np", "zeros", "a0", "shape", "u1", "0", "a0", "1", "a0", "2", "a0", "3", "a0", "1", "a0", "2", "a0", "4", "a0", "1", "a0", "3", "a0", "4", "a0", "2", "a0", "3", "a0", "4", "u1", "1", "a0", "0", "a0", "2", "a0", "3", "a0", "0", "a0", "2", "a0", "4", "a0", "0", "a0", "3", "a0", "4", "a0", "2", "a0", "3", "a0", "4", "u1", "2", "a0", "0", "a0", "1", "a0", "3", "a0", "0", "a0", "1", "a0", "4", "a0", "0", "a0", "3", "a0", "4", "a0", "1", "a0", "3", "a0", "4", "u1", "3", "a0", "0", "a0", "1", "a0", "2", "a0", "0", "a0", "1", "a0", "4", "a0", "0", "a0", "2", "a0", "4", "a0", "1", "a0", "2", "a0", "4", "u1", "4", "a0", "0", "a0", "1", "a0", "2", "a0", "0", "a0", "1", "a0", "3", "a0", "0", "a0", "2", "a0", "3", "a0", "1", "a0", "2", "a0", "3", "left", "0", "a0", "0", "a0", "1", "a0", "0", "a0", "2", "a0", "0", "a0", "3", "a0", "0", "a0", "4", "left", "1", "a0", "1", "a0", "0", "a0", "1", "a0", "2", "a0", "1", "a0", "3", "a0", "1", "a0", "4", "left", "2", "a0", "2", "a0", "0", "a0", "2", "a0", "1", "a0", "2", "a0", "3", "a0", "2", "a0", "4", "left", "3", "a0", "3", "a0", "0", "a0", "3", "a0", "1", "a0", "3", "a0", "2", "a0", "3", "a0", "4", "left", "4", "a0", "4", "a0", "0", "a0", "4", "a0", "1", "a0", "4", "a0", "2", "a0", "4", "a0", "3", "df", "2", "2", "np", "sum", "u1", "left", "ff", "axis", "1", "second", "derivative", "u2", "0", "a0", "1", "a0", "2", "a0", "1", "a0", "3", "a0", "1", "a0", "4", "a0", "2", "a0", "3", "a0", "2", "a0", "4", "a0", "3", "a0", "4", "u2", "1", "a0", "0", "a0", "2", "a0", "0", "a0", "3", "a0", "0", "a0", "4", "a0", "2", "a0", "3", "a0", "2", "a0", "4", "a0", "3", "a0", "4", "u2", "2", "a0", "0", "a0", "1", "a0", "0", "a0", "3", "a0", "0", "a0", "4", "a0", "1", "a0", "3", "a0", "1", "a0", "3", "a0", "3", "a0", "4", "u2", "3", "a0", "0", "a0", "1", "a0", "0", "a0", "2", "a0", "0", "a0", "4", "a0", "1", "a0", "2", "a0", "1", "a0", "4", "a0", "2", "a0", "4", "u2", "4", "a0", "0", "a0", "1", "a0", "0", "a0", "2", "a0", "0", "a0", "3", "a0", "1", "a0", "2", "a0", "1", "a0", "4", "a0", "2", "a0", "3", "df2", "2", "2", "2", "np", "sum", "u2", "ff", "axis", "1", "return", "df", "df2"], "doc_len": 693}
{"doc_id": "pvlib/ivtools/utils.py::rectify_iv_curve", "file_path": "pvlib/ivtools/utils.py", "class_name": null, "func_name": "rectify_iv_curve", "text": "文件路径: pvlib/ivtools/utils.py\ndef rectify_iv_curve(voltage, current, decimals=None):\n    \"\"\"\n    Sort the IV curve data, remove NaNs and negative\n    values, and combine points with duplicate voltage.\n\n    Parameters\n    ----------\n    voltage : numeric [V]\n    current : numeric [A]\n    decimals : int or None, default None\n        number of decimal places to which voltage is rounded to remove\n        duplicated points. If None, no rounding is done.\n\n    Returns\n    -------\n    voltage : numeric [V]\n    current : numeric [A]\n\n    Notes\n    -----\n    ``rectify_iv_curve`` ensures that the IV curve lies in the first quadrant\n    of the (voltage, current) plane. The returned IV curve:\n\n      * increases in voltage\n      * contains no negative current or voltage values\n      * contains no NaNs\n      * contains no points with duplicate voltage values. Where voltage\n        values are repeated, a single data point is substituted with current\n        equal to the average of current at duplicated voltages.\n    \"\"\"\n\n    df = pd.DataFrame(data=np.vstack((voltage, current)).T, columns=['v', 'i'])\n    # restrict to first quadrant\n    df.dropna(inplace=True)\n    df = df[(df['v'] >= 0) & (df['i'] >= 0)]\n    # sort pairs on voltage, then current\n    df = df.sort_values(by=['v', 'i'], ascending=[True, False])\n\n    # eliminate duplicate voltage points\n    if decimals is not None:\n        df['v'] = np.round(df['v'], decimals=decimals)\n\n    _, inv = np.unique(df['v'], return_inverse=True)\n    df.index = inv\n    # average current at each common voltage\n    df = df.groupby(by=inv).mean()\n\n    tmp = np.array(df).T\n    return tmp[0, ], tmp[1, ]\n", "tokens": ["pvlib", "ivtools", "utils", "py", "def", "rectify_iv_curve", "voltage", "current", "decimals", "none", "sort", "the", "iv", "curve", "data", "remove", "nans", "and", "negative", "values", "and", "combine", "points", "with", "duplicate", "voltage", "parameters", "voltage", "numeric", "v", "current", "numeric", "a", "decimals", "int", "or", "none", "default", "none", "number", "of", "decimal", "places", "to", "which", "voltage", "is", "rounded", "to", "remove", "duplicated", "points", "if", "none", "no", "rounding", "is", "done", "returns", "voltage", "numeric", "v", "current", "numeric", "a", "notes", "rectify_iv_curve", "ensures", "that", "the", "iv", "curve", "lies", "in", "the", "first", "quadrant", "of", "the", "voltage", "current", "plane", "the", "returned", "iv", "curve", "increases", "in", "voltage", "contains", "no", "negative", "current", "or", "voltage", "values", "contains", "no", "nans", "contains", "no", "points", "with", "duplicate", "voltage", "values", "where", "voltage", "values", "are", "repeated", "a", "single", "data", "point", "is", "substituted", "with", "current", "equal", "to", "the", "average", "of", "current", "at", "duplicated", "voltages", "df", "pd", "dataframe", "data", "np", "vstack", "voltage", "current", "t", "columns", "v", "i", "restrict", "to", "first", "quadrant", "df", "dropna", "inplace", "true", "df", "df", "df", "v", "0", "df", "i", "0", "sort", "pairs", "on", "voltage", "then", "current", "df", "df", "sort_values", "by", "v", "i", "ascending", "true", "false", "eliminate", "duplicate", "voltage", "points", "if", "decimals", "is", "not", "none", "df", "v", "np", "round", "df", "v", "decimals", "decimals", "_", "inv", "np", "unique", "df", "v", "return_inverse", "true", "df", "index", "inv", "average", "current", "at", "each", "common", "voltage", "df", "df", "groupby", "by", "inv", "mean", "tmp", "np", "array", "df", "t", "return", "tmp", "0", "tmp", "1"], "doc_len": 221}
{"doc_id": "pvlib/ivtools/utils.py::_schumaker_qspline", "file_path": "pvlib/ivtools/utils.py", "class_name": null, "func_name": "_schumaker_qspline", "text": "文件路径: pvlib/ivtools/utils.py\ndef _schumaker_qspline(x, y):\n    \"\"\"\n    Fit a quadratic spline which preserves monotonicity and\n    convexity in the data.\n\n    Parameters\n    ----------\n    x : numeric\n        independent points between which the spline will interpolate.\n    y : numeric\n        dependent points between which the spline will interpolate.\n\n    Returns\n    -------\n    t : array\n        an ordered vector of knots, i.e., X values where the spline\n        changes coefficients. All values in x are used as knots.\n        The algorithm may insert additional knots between data points in x\n        where changes in convexity are indicated by the (numerical)\n        derivative. Consequently len(t) >= len(x).\n    c : array\n        a Nx3 matrix of coefficients where the kth row defines the quadratic\n        interpolant between t_k and t_(k+1), i.e., y = c[i, 0] *\n        (x - t_k)^2 + c[i, 1] * (x - t_k) + c[i, 2]\n    yhat : array\n        y values corresponding to the knots in t. Contains the original\n        data points, y, and also y values estimated from the spline at the\n        inserted knots.\n    kflag : array\n        a vector of len(t) of logicals, which are set to true for\n        elements of t that are knots inserted by the algorithm.\n\n    Notes\n    -----\n    Algorithm is taken from [1]_, which relies on prior work described in [2]_.\n    Ported from PVLib Matlab [3]_.\n\n    References\n    ----------\n    .. [1] L. L. Schumaker, \"On Shape Preserving Quadratic Spline\n       Interpolation\", SIAM Journal on Numerical Analysis 20(4), August 1983,\n       pp 854 - 864\n    .. [2] M. H. Lam, \"Monotone and Convex Quadratic Spline Interpolation\",\n       Virginia Journal of Science 41(1), Spring 1990\n    .. [3] PVLib MATLAB https://github.com/sandialabs/MATLAB_PV_LIB\n    \"\"\"\n    # Make sure vectors are 1D arrays\n    x = x.flatten()\n    y = y.flatten()\n\n    n = x.size\n\n    # compute various values used by the algorithm: differences, length of line\n    # segments between data points, and ratios of differences.\n    delx = np.diff(x)  # delx[i] = x[i + 1] - x[i]\n    dely = np.diff(y)\n\n    delta = dely / delx\n\n    # Calculate first derivative at each x value per [3]\n\n    s = np.zeros_like(x)\n\n    left = np.append(0.0, delta)\n    right = np.append(delta, 0.0)\n\n    pdelta = left * right\n\n    u = pdelta > 0\n\n    # [3], Eq. 9 for interior points\n    # fix tuning parameters in [2], Eq 9 at chi = .5 and eta = .5\n    s[u] = pdelta[u] / (0.5*left[u] + 0.5*right[u])\n\n    # [3], Eq. 7 for left endpoint\n    left_end = 2.0 * delta[0] - s[1]\n    if delta[0] * left_end > 0:\n        s[0] = left_end\n\n    # [3], Eq. 8 for right endpoint\n    right_end = 2.0 * delta[-1] - s[-2]\n    if delta[-1] * right_end > 0:\n        s[-1] = right_end\n\n    # determine knots. Start with initial points x\n    # [2], Algorithm 4.1 first 'if' condition of step 5 defines intervals\n    # which won't get internal knots\n    tests = s[:-1] + s[1:]\n    u = np.isclose(tests, 2.0 * delta, atol=EPS_slope)\n    # u = true for an interval which will not get an internal knot\n\n    k = n + sum(~u)  # total number of knots = original data + inserted knots\n\n    # set up output arrays\n    # knot locations, first n - 1 and very last (n + k) are original data\n    xk = np.zeros(k)\n    yk = np.zeros(k)  # function values at knot locations\n    # logicals that will indicate where additional knots are inserted\n    flag = np.zeros(k, dtype=bool)\n    a = np.zeros((k, 3))\n\n    # structures needed to compute coefficients, have to be maintained in\n    # association with each knot\n\n    tmpx = x[:-1]\n    tmpy = y[:-1]\n    tmpx2 = x[1:]\n    tmps = s[:-1]\n    tmps2 = s[1:]\n    diffs = np.diff(s)\n\n    # structure to contain information associated with each knot, used to\n    # calculate coefficients\n    uu = np.zeros((k, 6))\n\n    uu[:(n - 1), :] = np.array([tmpx, tmpx2, tmpy, tmps, tmps2, delta]).T\n\n    # [2], Algorithm 4.1 subpart 1 of Step 5\n    # original x values that are left points of intervals without internal\n    # knots\n\n    # MATLAB differs from NumPy, boolean indices must be same size as\n    # array\n    xk[:(n - 1)][u] = tmpx[u]\n    yk[:(n - 1)][u] = tmpy[u]\n    # constant term for each polynomial for intervals without knots\n    a[:(n - 1), 2][u] = tmpy[u]\n    a[:(n - 1), 1][u] = s[:-1][u]\n    a[:(n - 1), 0][u] = 0.5 * diffs[u] / delx[u]  # leading coefficients\n\n    # [2], Algorithm 4.1 subpart 2 of Step 5\n    # original x values that are left points of intervals with internal knots\n    xk[:(n-1)][~u] = tmpx[~u]\n    yk[:(n-1)][~u] = tmpy[~u]\n\n    aa = s[:-1] - delta\n    b = s[1:] - delta\n\n    # Since the above two lines can lead to numerical errors, aa and b\n    # are rounded to 0.0 is their absolute value is small enough.\n    aa[np.isclose(aa, 0., atol=EPS_val)] = 0.\n    b[np.isclose(b, 0., atol=EPS_val)] = 0.\n\n    sbar = np.zeros(k)\n    eta = np.zeros(k)\n    # will contain mapping from the left points of intervals containing an\n    # added knot to each inverval's internal knot value\n    xi = np.zeros(k)\n\n    t0 = aa * b >= 0\n    # first 'else' in Algorithm 4.1 Step 5\n    v = np.logical_and(~u, t0)  # len(u) == (n - 1) always\n    q = np.sum(v)  # number of this type of knot to add\n\n    if q > 0.:\n        xk[(n - 1):(n + q - 1)] = .5 * (tmpx[v] + tmpx2[v])  # knot location\n        uu[(n - 1):(n + q - 1), :] = np.array([tmpx[v], tmpx2[v], tmpy[v],\n                                               tmps[v], tmps2[v], delta[v]]).T\n        xi[:(n-1)][v] = xk[(n - 1):(n + q - 1)]\n\n    t1 = np.abs(aa) > np.abs(b)\n    w = np.logical_and(~u, ~v)  # second 'else' in Algorithm 4.1 Step 5\n    w = np.logical_and(w, t1)\n    r = np.sum(w)\n\n    if r > 0.:\n        xk[(n + q - 1):(n + q + r - 1)] = tmpx2[w] + aa[w] * delx[w] / diffs[w]\n        uu[(n + q - 1):(n + q + r - 1), :] = np.array([tmpx[w], tmpx2[w],\n                                                       tmpy[w], tmps[w],\n                                                       tmps2[w], delta[w]]).T\n        xi[:(n - 1)][w] = xk[(n + q - 1):(n + q + r - 1)]\n\n    z = np.logical_and(~u, ~v)  # last 'else' in Algorithm 4.1 Step 5\n    z = np.logical_and(z, ~w)\n    ss = np.sum(z)\n\n    if ss > 0.:\n        xk[(n + q + r - 1):(n + q + r + ss - 1)] = \\\n            tmpx[z] + b[z] * delx[z] / diffs[z]\n        uu[(n + q + r - 1):(n + q + r + ss - 1), :] = \\\n            np.array([tmpx[z], tmpx2[z], tmpy[z], tmps[z], tmps2[z],\n                      delta[z]]).T\n        xi[:(n-1)][z] = xk[(n + q + r - 1):(n + q + r + ss - 1)]\n\n    # define polynomial coefficients for intervals with added knots\n    ff = ~u\n    sbar[:(n-1)][ff] = (\n        (2 * uu[:(n - 1), 5][ff] - uu[:(n-1), 4][ff])\n        + (uu[:(n - 1), 4][ff] - uu[:(n-1), 3][ff])\n        * (xi[:(n - 1)][ff] - uu[:(n-1), 0][ff])\n        / (uu[:(n - 1), 1][ff] - uu[:(n-1), 0][ff]))\n    eta[:(n-1)][ff] = (\n        (sbar[:(n - 1)][ff] - uu[:(n-1), 3][ff])\n        / (xi[:(n - 1)][ff] - uu[:(n-1), 0][ff]))\n\n    sbar[(n - 1):(n + q + r + ss - 1)] = \\\n        (2 * uu[(n - 1):(n + q + r + ss - 1), 5] -\n         uu[(n - 1):(n + q + r + ss - 1), 4]) + \\\n        (uu[(n - 1):(n + q + r + ss - 1), 4] -\n         uu[(n - 1):(n + q + r + ss - 1), 3]) * \\\n        (xk[(n - 1):(n + q + r + ss - 1)] -\n         uu[(n - 1):(n + q + r + ss - 1), 0]) / \\\n        (uu[(n - 1):(n + q + r + ss - 1), 1] -\n         uu[(n - 1):(n + q + r + ss - 1), 0])\n    eta[(n - 1):(n + q + r + ss - 1)] = \\\n        (sbar[(n - 1):(n + q + r + ss - 1)] -\n         uu[(n - 1):(n + q + r + ss - 1), 3]) / \\\n        (xk[(n - 1):(n + q + r + ss - 1)] -\n         uu[(n - 1):(n + q + r + ss - 1), 0])\n\n    # constant term for polynomial for intervals with internal knots\n    a[:(n - 1), 2][~u] = uu[:(n - 1), 2][~u]\n    a[:(n - 1), 1][~u] = uu[:(n - 1), 3][~u]\n    a[:(n - 1), 0][~u] = 0.5 * eta[:(n - 1)][~u]  # leading coefficient\n\n    a[(n - 1):(n + q + r + ss - 1), 2] = \\\n        uu[(n - 1):(n + q + r + ss - 1), 2] + \\\n        uu[(n - 1):(n + q + r + ss - 1), 3] * \\\n        (xk[(n - 1):(n + q + r + ss - 1)] -\n         uu[(n - 1):(n + q + r + ss - 1), 0]) + \\\n        .5 * eta[(n - 1):(n + q + r + ss - 1)] * \\\n        (xk[(n - 1):(n + q + r + ss - 1)] -\n         uu[(n - 1):(n + q + r + ss - 1), 0]) ** 2.\n    a[(n - 1):(n + q + r + ss - 1), 1] = sbar[(n - 1):(n + q + r + ss - 1)]\n    a[(n - 1):(n + q + r + ss - 1), 0] = \\\n        .5 * (uu[(n - 1):(n + q + r + ss - 1), 4] -\n              sbar[(n - 1):(n + q + r + ss - 1)]) / \\\n        (uu[(n - 1):(n + q + r + ss - 1), 1] -\n         uu[(n - 1):(n + q + r + ss - 1), 0])\n\n    yk[(n - 1):(n + q + r + ss - 1)] = a[(n - 1):(n + q + r + ss - 1), 2]\n\n    xk[n + q + r + ss - 1] = x[n - 1]\n    yk[n + q + r + ss - 1] = y[n - 1]\n    flag[(n - 1):(n + q + r + ss - 1)] = True  # these are all inserted knots\n\n    tmp = np.vstack((xk, a.T, yk, flag)).T\n    # sort output in terms of increasing x (original plus added knots)\n    tmp2 = tmp[tmp[:, 0].argsort(kind='mergesort')]\n\n    t = tmp2[:, 0]\n    outn = len(t)\n    c = tmp2[0:(outn - 1), 1:4]\n    yhat = tmp2[:, 4]\n    kflag = tmp2[:, 5]\n    return t, c, yhat, kflag\n", "tokens": ["pvlib", "ivtools", "utils", "py", "def", "_schumaker_qspline", "x", "y", "fit", "a", "quadratic", "spline", "which", "preserves", "monotonicity", "and", "convexity", "in", "the", "data", "parameters", "x", "numeric", "independent", "points", "between", "which", "the", "spline", "will", "interpolate", "y", "numeric", "dependent", "points", "between", "which", "the", "spline", "will", "interpolate", "returns", "t", "array", "an", "ordered", "vector", "of", "knots", "i", "e", "x", "values", "where", "the", "spline", "changes", "coefficients", "all", "values", "in", "x", "are", "used", "as", "knots", "the", "algorithm", "may", "insert", "additional", "knots", "between", "data", "points", "in", "x", "where", "changes", "in", "convexity", "are", "indicated", "by", "the", "numerical", "derivative", "consequently", "len", "t", "len", "x", "c", "array", "a", "nx3", "matrix", "of", "coefficients", "where", "the", "kth", "row", "defines", "the", "quadratic", "interpolant", "between", "t_k", "and", "t_", "k", "1", "i", "e", "y", "c", "i", "0", "x", "t_k", "2", "c", "i", "1", "x", "t_k", "c", "i", "2", "yhat", "array", "y", "values", "corresponding", "to", "the", "knots", "in", "t", "contains", "the", "original", "data", "points", "y", "and", "also", "y", "values", "estimated", "from", "the", "spline", "at", "the", "inserted", "knots", "kflag", "array", "a", "vector", "of", "len", "t", "of", "logicals", "which", "are", "set", "to", "true", "for", "elements", "of", "t", "that", "are", "knots", "inserted", "by", "the", "algorithm", "notes", "algorithm", "is", "taken", "from", "1", "_", "which", "relies", "on", "prior", "work", "described", "in", "2", "_", "ported", "from", "pvlib", "matlab", "3", "_", "references", "1", "l", "l", "schumaker", "on", "shape", "preserving", "quadratic", "spline", "interpolation", "siam", "journal", "on", "numerical", "analysis", "20", "4", "august", "1983", "pp", "854", "864", "2", "m", "h", "lam", "monotone", "and", "convex", "quadratic", "spline", "interpolation", "virginia", "journal", "of", "science", "41", "1", "spring", "1990", "3", "pvlib", "matlab", "https", "github", "com", "sandialabs", "matlab_pv_lib", "make", "sure", "vectors", "are", "1d", "arrays", "x", "x", "flatten", "y", "y", "flatten", "n", "x", "size", "compute", "various", "values", "used", "by", "the", "algorithm", "differences", "length", "of", "line", "segments", "between", "data", "points", "and", "ratios", "of", "differences", "delx", "np", "diff", "x", "delx", "i", "x", "i", "1", "x", "i", "dely", "np", "diff", "y", "delta", "dely", "delx", "calculate", "first", "derivative", "at", "each", "x", "value", "per", "3", "s", "np", "zeros_like", "x", "left", "np", "append", "0", "0", "delta", "right", "np", "append", "delta", "0", "0", "pdelta", "left", "right", "u", "pdelta", "0", "3", "eq", "9", "for", "interior", "points", "fix", "tuning", "parameters", "in", "2", "eq", "9", "at", "chi", "5", "and", "eta", "5", "s", "u", "pdelta", "u", "0", "5", "left", "u", "0", "5", "right", "u", "3", "eq", "7", "for", "left", "endpoint", "left_end", "2", "0", "delta", "0", "s", "1", "if", "delta", "0", "left_end", "0", "s", "0", "left_end", "3", "eq", "8", "for", "right", "endpoint", "right_end", "2", "0", "delta", "1", "s", "2", "if", "delta", "1", "right_end", "0", "s", "1", "right_end", "determine", "knots", "start", "with", "initial", "points", "x", "2", "algorithm", "4", "1", "first", "if", "condition", "of", "step", "5", "defines", "intervals", "which", "won", "t", "get", "internal", "knots", "tests", "s", "1", "s", "1", "u", "np", "isclose", "tests", "2", "0", "delta", "atol", "eps_slope", "u", "true", "for", "an", "interval", "which", "will", "not", "get", "an", "internal", "knot", "k", "n", "sum", "u", "total", "number", "of", "knots", "original", "data", "inserted", "knots", "set", "up", "output", "arrays", "knot", "locations", "first", "n", "1", "and", "very", "last", "n", "k", "are", "original", "data", "xk", "np", "zeros", "k", "yk", "np", "zeros", "k", "function", "values", "at", "knot", "locations", "logicals", "that", "will", "indicate", "where", "additional", "knots", "are", "inserted", "flag", "np", "zeros", "k", "dtype", "bool", "a", "np", "zeros", "k", "3", "structures", "needed", "to", "compute", "coefficients", "have", "to", "be", "maintained", "in", "association", "with", "each", "knot", "tmpx", "x", "1", "tmpy", "y", "1", "tmpx2", "x", "1", "tmps", "s", "1", "tmps2", "s", "1", "diffs", "np", "diff", "s", "structure", "to", "contain", "information", "associated", "with", "each", "knot", "used", "to", "calculate", "coefficients", "uu", "np", "zeros", "k", "6", "uu", "n", "1", "np", "array", "tmpx", "tmpx2", "tmpy", "tmps", "tmps2", "delta", "t", "2", "algorithm", "4", "1", "subpart", "1", "of", "step", "5", "original", "x", "values", "that", "are", "left", "points", "of", "intervals", "without", "internal", "knots", "matlab", "differs", "from", "numpy", "boolean", "indices", "must", "be", "same", "size", "as", "array", "xk", "n", "1", "u", "tmpx", "u", "yk", "n", "1", "u", "tmpy", "u", "constant", "term", "for", "each", "polynomial", "for", "intervals", "without", "knots", "a", "n", "1", "2", "u", "tmpy", "u", "a", "n", "1", "1", "u", "s", "1", "u", "a", "n", "1", "0", "u", "0", "5", "diffs", "u", "delx", "u", "leading", "coefficients", "2", "algorithm", "4", "1", "subpart", "2", "of", "step", "5", "original", "x", "values", "that", "are", "left", "points", "of", "intervals", "with", "internal", "knots", "xk", "n", "1", "u", "tmpx", "u", "yk", "n", "1", "u", "tmpy", "u", "aa", "s", "1", "delta", "b", "s", "1", "delta", "since", "the", "above", "two", "lines", "can", "lead", "to", "numerical", "errors", "aa", "and", "b", "are", "rounded", "to", "0", "0", "is", "their", "absolute", "value", "is", "small", "enough", "aa", "np", "isclose", "aa", "0", "atol", "eps_val", "0", "b", "np", "isclose", "b", "0", "atol", "eps_val", "0", "sbar", "np", "zeros", "k", "eta", "np", "zeros", "k", "will", "contain", "mapping", "from", "the", "left", "points", "of", "intervals", "containing", "an", "added", "knot", "to", "each", "inverval", "s", "internal", "knot", "value", "xi", "np", "zeros", "k", "t0", "aa", "b", "0", "first", "else", "in", "algorithm", "4", "1", "step", "5", "v", "np", "logical_and", "u", "t0", "len", "u", "n", "1", "always", "q", "np", "sum", "v", "number", "of", "this", "type", "of", "knot", "to", "add", "if", "q", "0", "xk", "n", "1", "n", "q", "1", "5", "tmpx", "v", "tmpx2", "v", "knot", "location", "uu", "n", "1", "n", "q", "1", "np", "array", "tmpx", "v", "tmpx2", "v", "tmpy", "v", "tmps", "v", "tmps2", "v", "delta", "v", "t", "xi", "n", "1", "v", "xk", "n", "1", "n", "q", "1", "t1", "np", "abs", "aa", "np", "abs", "b", "w", "np", "logical_and", "u", "v", "second", "else", "in", "algorithm", "4", "1", "step", "5", "w", "np", "logical_and", "w", "t1", "r", "np", "sum", "w", "if", "r", "0", "xk", "n", "q", "1", "n", "q", "r", "1", "tmpx2", "w", "aa", "w", "delx", "w", "diffs", "w", "uu", "n", "q", "1", "n", "q", "r", "1", "np", "array", "tmpx", "w", "tmpx2", "w", "tmpy", "w", "tmps", "w", "tmps2", "w", "delta", "w", "t", "xi", "n", "1", "w", "xk", "n", "q", "1", "n", "q", "r", "1", "z", "np", "logical_and", "u", "v", "last", "else", "in", "algorithm", "4", "1", "step", "5", "z", "np", "logical_and", "z", "w", "ss", "np", "sum", "z", "if", "ss", "0", "xk", "n", "q", "r", "1", "n", "q", "r", "ss", "1", "tmpx", "z", "b", "z", "delx", "z", "diffs", "z", "uu", "n", "q", "r", "1", "n", "q", "r", "ss", "1", "np", "array", "tmpx", "z", "tmpx2", "z", "tmpy", "z", "tmps", "z", "tmps2", "z", "delta", "z", "t", "xi", "n", "1", "z", "xk", "n", "q", "r", "1", "n", "q", "r", "ss", "1", "define", "polynomial", "coefficients", "for", "intervals", "with", "added", "knots", "ff", "u", "sbar", "n", "1", "ff", "2", "uu", "n", "1", "5", "ff", "uu", "n", "1", "4", "ff", "uu", "n", "1", "4", "ff", "uu", "n", "1", "3", "ff", "xi", "n", "1", "ff", "uu", "n", "1", "0", "ff", "uu", "n", "1", "1", "ff", "uu", "n", "1", "0", "ff", "eta", "n", "1", "ff", "sbar", "n", "1", "ff", "uu", "n", "1", "3", "ff", "xi", "n", "1", "ff", "uu", "n", "1", "0", "ff", "sbar", "n", "1", "n", "q", "r", "ss", "1", "2", "uu", "n", "1", "n", "q", "r", "ss", "1", "5", "uu", "n", "1", "n", "q", "r", "ss", "1", "4", "uu", "n", "1", "n", "q", "r", "ss", "1", "4", "uu", "n", "1", "n", "q", "r", "ss", "1", "3", "xk", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "uu", "n", "1", "n", "q", "r", "ss", "1", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "eta", "n", "1", "n", "q", "r", "ss", "1", "sbar", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "3", "xk", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "constant", "term", "for", "polynomial", "for", "intervals", "with", "internal", "knots", "a", "n", "1", "2", "u", "uu", "n", "1", "2", "u", "a", "n", "1", "1", "u", "uu", "n", "1", "3", "u", "a", "n", "1", "0", "u", "0", "5", "eta", "n", "1", "u", "leading", "coefficient", "a", "n", "1", "n", "q", "r", "ss", "1", "2", "uu", "n", "1", "n", "q", "r", "ss", "1", "2", "uu", "n", "1", "n", "q", "r", "ss", "1", "3", "xk", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "5", "eta", "n", "1", "n", "q", "r", "ss", "1", "xk", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "2", "a", "n", "1", "n", "q", "r", "ss", "1", "1", "sbar", "n", "1", "n", "q", "r", "ss", "1", "a", "n", "1", "n", "q", "r", "ss", "1", "0", "5", "uu", "n", "1", "n", "q", "r", "ss", "1", "4", "sbar", "n", "1", "n", "q", "r", "ss", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "1", "uu", "n", "1", "n", "q", "r", "ss", "1", "0", "yk", "n", "1", "n", "q", "r", "ss", "1", "a", "n", "1", "n", "q", "r", "ss", "1", "2", "xk", "n", "q", "r", "ss", "1", "x", "n", "1", "yk", "n", "q", "r", "ss", "1", "y", "n", "1", "flag", "n", "1", "n", "q", "r", "ss", "1", "true", "these", "are", "all", "inserted", "knots", "tmp", "np", "vstack", "xk", "a", "t", "yk", "flag", "t", "sort", "output", "in", "terms", "of", "increasing", "x", "original", "plus", "added", "knots", "tmp2", "tmp", "tmp", "0", "argsort", "kind", "mergesort", "t", "tmp2", "0", "outn", "len", "t", "c", "tmp2", "0", "outn", "1", "1", "4", "yhat", "tmp2", "4", "kflag", "tmp2", "5", "return", "t", "c", "yhat", "kflag"], "doc_len": 1500}
{"doc_id": "pvlib/spa_c_files/spa_py_example.py::spa_calc_example", "file_path": "pvlib/spa_c_files/spa_py_example.py", "class_name": null, "func_name": "spa_calc_example", "text": "文件路径: pvlib/spa_c_files/spa_py_example.py\ndef spa_calc_example(test=True):\n    result = spa_calc(\n        year=2004, month=10, day=17, hour=12, minute=30, second=30,\n        time_zone=-7, longitude=-105.1786, latitude=39.742476,\n        elevation=1830.14, pressure=820, temperature=11, delta_t=67\n    )\n    if test:\n        for fieldname, expected_value in EXPECTED.items():\n            assert np.isclose(result[fieldname], expected_value)\n    return result\n", "tokens": ["pvlib", "spa_c_files", "spa_py_example", "py", "def", "spa_calc_example", "test", "true", "result", "spa_calc", "year", "2004", "month", "10", "day", "17", "hour", "12", "minute", "30", "second", "30", "time_zone", "7", "longitude", "105", "1786", "latitude", "39", "742476", "elevation", "1830", "14", "pressure", "820", "temperature", "11", "delta_t", "67", "if", "test", "for", "fieldname", "expected_value", "in", "expected", "items", "assert", "np", "isclose", "result", "fieldname", "expected_value", "return", "result"], "doc_len": 55}
{"doc_id": "pvlib/spectrum/mismatch.py::get_example_spectral_response", "file_path": "pvlib/spectrum/mismatch.py", "class_name": null, "func_name": "get_example_spectral_response", "text": "文件路径: pvlib/spectrum/mismatch.py\ndef get_example_spectral_response(wavelength=None):\n    '''\n    Generate a generic smooth spectral response (SR) for tests and experiments.\n\n    Parameters\n    ----------\n    wavelength: 1-D sequence of numeric, optional\n        Wavelengths at which spectral response values are generated.\n        By default ``wavelength`` is from 280 to 1200 in 5 nm intervals. [nm]\n\n    Returns\n    -------\n    spectral_response : pandas.Series\n        The relative spectral response indexed by ``wavelength`` in nm. [-]\n\n    Notes\n    -----\n    This spectral response is based on measurements taken on a c-Si cell.\n    A small number of points near the measured curve are used to define\n    a cubic spline having no undue oscillations, as shown in [1]_.  The spline\n    can be interpolated at arbitrary wavelengths to produce a continuous,\n    smooth curve , which makes it suitable for experimenting with spectral\n    data of different resolutions.\n\n    References\n    ----------\n    .. [1] Driesse, Anton, and Stein, Joshua. \"Global Normal Spectral\n       Irradiance in Albuquerque: a One-Year Open Dataset for PV Research\".\n       United States 2020. :doi:`10.2172/1814068`.\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Aug. 2022\n\n    SR_DATA = np.array([[ 290, 0.00],\n                        [ 350, 0.27],\n                        [ 400, 0.37],\n                        [ 500, 0.52],\n                        [ 650, 0.71],\n                        [ 800, 0.88],\n                        [ 900, 0.97],\n                        [ 950, 1.00],\n                        [1000, 0.93],\n                        [1050, 0.58],\n                        [1100, 0.21],\n                        [1150, 0.05],\n                        [1190, 0.00]]).transpose()\n\n    if wavelength is None:\n        resolution = 5.0\n        wavelength = np.arange(280, 1200 + resolution, resolution)\n\n    interpolator = interp1d(SR_DATA[0], SR_DATA[1],\n                            kind='cubic',\n                            bounds_error=False,\n                            fill_value=0.0,\n                            copy=False,\n                            assume_sorted=True)\n\n    sr = pd.Series(data=interpolator(wavelength), index=wavelength)\n\n    sr.index.name = 'wavelength'\n    sr.name = 'spectral_response'\n\n    return sr\n", "tokens": ["pvlib", "spectrum", "mismatch", "py", "def", "get_example_spectral_response", "wavelength", "none", "generate", "a", "generic", "smooth", "spectral", "response", "sr", "for", "tests", "and", "experiments", "parameters", "wavelength", "1", "d", "sequence", "of", "numeric", "optional", "wavelengths", "at", "which", "spectral", "response", "values", "are", "generated", "by", "default", "wavelength", "is", "from", "280", "to", "1200", "in", "5", "nm", "intervals", "nm", "returns", "spectral_response", "pandas", "series", "the", "relative", "spectral", "response", "indexed", "by", "wavelength", "in", "nm", "notes", "this", "spectral", "response", "is", "based", "on", "measurements", "taken", "on", "a", "c", "si", "cell", "a", "small", "number", "of", "points", "near", "the", "measured", "curve", "are", "used", "to", "define", "a", "cubic", "spline", "having", "no", "undue", "oscillations", "as", "shown", "in", "1", "_", "the", "spline", "can", "be", "interpolated", "at", "arbitrary", "wavelengths", "to", "produce", "a", "continuous", "smooth", "curve", "which", "makes", "it", "suitable", "for", "experimenting", "with", "spectral", "data", "of", "different", "resolutions", "references", "1", "driesse", "anton", "and", "stein", "joshua", "global", "normal", "spectral", "irradiance", "in", "albuquerque", "a", "one", "year", "open", "dataset", "for", "pv", "research", "united", "states", "2020", "doi", "10", "2172", "1814068", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "aug", "2022", "sr_data", "np", "array", "290", "0", "00", "350", "0", "27", "400", "0", "37", "500", "0", "52", "650", "0", "71", "800", "0", "88", "900", "0", "97", "950", "1", "00", "1000", "0", "93", "1050", "0", "58", "1100", "0", "21", "1150", "0", "05", "1190", "0", "00", "transpose", "if", "wavelength", "is", "none", "resolution", "5", "0", "wavelength", "np", "arange", "280", "1200", "resolution", "resolution", "interpolator", "interp1d", "sr_data", "0", "sr_data", "1", "kind", "cubic", "bounds_error", "false", "fill_value", "0", "0", "copy", "false", "assume_sorted", "true", "sr", "pd", "series", "data", "interpolator", "wavelength", "index", "wavelength", "sr", "index", "name", "wavelength", "sr", "name", "spectral_response", "return", "sr"], "doc_len": 255}
{"doc_id": "pvlib/spectrum/mismatch.py::get_am15g", "file_path": "pvlib/spectrum/mismatch.py", "class_name": null, "func_name": "get_am15g", "text": "文件路径: pvlib/spectrum/mismatch.py\ndef get_am15g(wavelength=None):\n    '''\n    Read the ASTM G173-03 AM1.5 global spectrum on a 37-degree tilted surface,\n    optionally interpolated to the specified wavelength(s).\n\n    Global (tilted) irradiance includes direct and diffuse irradiance from sky\n    and ground reflections, and is more formally called hemispherical\n    irradiance (on a tilted surface).  In the context of photovoltaic systems\n    the irradiance on a flat receiver is frequently called plane-of-array (POA)\n    irradiance.\n\n    Parameters\n    ----------\n    wavelength: 1-D sequence of numeric, optional\n        Wavelengths at which the spectrum is interpolated.\n        By default the 2002 wavelengths of the standard are returned. [nm]\n\n    Returns\n    -------\n    am15g: pandas.Series\n        The AM1.5g standard spectrum indexed by ``wavelength``. [(W/m^2)/nm]\n\n    Notes\n    -----\n    If ``wavelength`` is specified this function uses linear interpolation.\n\n    If the values in ``wavelength`` are too widely spaced, the integral of the\n    spectrum may deviate from the standard value of 1000.37 W/m^2.\n\n    The values in the data file provided with pvlib-python are copied from an\n    Excel file distributed by NREL, which is found here:\n    https://www.nrel.gov/grid/solar-resource/assets/data/astmg173.xls\n\n    More information about reference spectra is found here:\n    https://www.nrel.gov/grid/solar-resource/spectra-am1.5.html\n\n    References\n    ----------\n    .. [1] ASTM \"G173-03 Standard Tables for Reference Solar Spectral\n        Irradiances: Direct Normal and Hemispherical on 37° Tilted Surface.\"\n    '''\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Aug. 2022\n\n    pvlib_path = pvlib.__path__[0]\n    filepath = os.path.join(pvlib_path, 'data', 'astm_g173_am15g.csv')\n\n    am15g = pd.read_csv(filepath, index_col=0).squeeze()\n\n    if wavelength is not None:\n        interpolator = interp1d(am15g.index, am15g,\n                                kind='linear',\n                                bounds_error=False,\n                                fill_value=0.0,\n                                copy=False,\n                                assume_sorted=True)\n\n        am15g = pd.Series(data=interpolator(wavelength), index=wavelength)\n\n    am15g.index.name = 'wavelength'\n    am15g.name = 'am15g'\n\n    return am15g\n", "tokens": ["pvlib", "spectrum", "mismatch", "py", "def", "get_am15g", "wavelength", "none", "read", "the", "astm", "g173", "03", "am1", "5", "global", "spectrum", "on", "a", "37", "degree", "tilted", "surface", "optionally", "interpolated", "to", "the", "specified", "wavelength", "s", "global", "tilted", "irradiance", "includes", "direct", "and", "diffuse", "irradiance", "from", "sky", "and", "ground", "reflections", "and", "is", "more", "formally", "called", "hemispherical", "irradiance", "on", "a", "tilted", "surface", "in", "the", "context", "of", "photovoltaic", "systems", "the", "irradiance", "on", "a", "flat", "receiver", "is", "frequently", "called", "plane", "of", "array", "poa", "irradiance", "parameters", "wavelength", "1", "d", "sequence", "of", "numeric", "optional", "wavelengths", "at", "which", "the", "spectrum", "is", "interpolated", "by", "default", "the", "2002", "wavelengths", "of", "the", "standard", "are", "returned", "nm", "returns", "am15g", "pandas", "series", "the", "am1", "5g", "standard", "spectrum", "indexed", "by", "wavelength", "w", "m", "2", "nm", "notes", "if", "wavelength", "is", "specified", "this", "function", "uses", "linear", "interpolation", "if", "the", "values", "in", "wavelength", "are", "too", "widely", "spaced", "the", "integral", "of", "the", "spectrum", "may", "deviate", "from", "the", "standard", "value", "of", "1000", "37", "w", "m", "2", "the", "values", "in", "the", "data", "file", "provided", "with", "pvlib", "python", "are", "copied", "from", "an", "excel", "file", "distributed", "by", "nrel", "which", "is", "found", "here", "https", "www", "nrel", "gov", "grid", "solar", "resource", "assets", "data", "astmg173", "xls", "more", "information", "about", "reference", "spectra", "is", "found", "here", "https", "www", "nrel", "gov", "grid", "solar", "resource", "spectra", "am1", "5", "html", "references", "1", "astm", "g173", "03", "standard", "tables", "for", "reference", "solar", "spectral", "irradiances", "direct", "normal", "and", "hemispherical", "on", "37", "tilted", "surface", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "aug", "2022", "pvlib_path", "pvlib", "__path__", "0", "filepath", "os", "path", "join", "pvlib_path", "data", "astm_g173_am15g", "csv", "am15g", "pd", "read_csv", "filepath", "index_col", "0", "squeeze", "if", "wavelength", "is", "not", "none", "interpolator", "interp1d", "am15g", "index", "am15g", "kind", "linear", "bounds_error", "false", "fill_value", "0", "0", "copy", "false", "assume_sorted", "true", "am15g", "pd", "series", "data", "interpolator", "wavelength", "index", "wavelength", "am15g", "index", "name", "wavelength", "am15g", "name", "am15g", "return", "am15g"], "doc_len": 292}
{"doc_id": "pvlib/spectrum/mismatch.py::calc_spectral_mismatch_field", "file_path": "pvlib/spectrum/mismatch.py", "class_name": null, "func_name": "calc_spectral_mismatch_field", "text": "文件路径: pvlib/spectrum/mismatch.py\ndef calc_spectral_mismatch_field(sr, e_sun, e_ref=None):\n    \"\"\"\n    Calculate spectral mismatch between a test device and broadband reference\n    device under specified solar spectral irradiance conditions.\n\n    Parameters\n    ----------\n    sr: pandas.Series\n        The relative spectral response of one (photovoltaic) test device.\n        The index of the Series must contain wavelength values in nm. [-]\n\n    e_sun: pandas.DataFrame or pandas.Series\n        One or more measured solar irradiance spectra in a pandas.DataFrame\n        having wavelength in nm as column index.  A single spectrum may be\n        be given as a pandas.Series having wavelength in nm as index.\n        [(W/m^2)/nm]\n\n    e_ref: pandas.Series, optional\n        The reference spectrum to use for the mismatch calculation.\n        The index of the Series must contain wavelength values in nm.\n        The default is the ASTM G173-03 global tilted spectrum. [(W/m^2)/nm]\n\n    Returns\n    -------\n    smm: pandas.Series or float if a single measured spectrum is provided. [-]\n\n    Notes\n    -----\n    Measured solar spectral irradiance usually covers a wavelength range\n    that is smaller than the range considered as broadband irradiance.\n    The infrared limit for the former typically lies around 1100 or 1600 nm,\n    whereas the latter extends to around 2800 or 4000 nm.  To avoid imbalance\n    between the magnitudes of the integrated spectra (the broadband values)\n    this function truncates the reference spectrum to the same range as the\n    measured (or simulated) field spectra. The assumption implicit in this\n    truncation is that the energy in the unmeasured wavelength range\n    is the same fraction of the broadband energy for both the measured\n    spectra and the reference spectrum.\n\n    If the default reference spectrum is used it is linearly interpolated\n    to the wavelengths of the measured spectrum, but if a reference spectrum\n    is provided via the parameter ``e_ref`` it is used without change. This\n    makes it possible to avoid interpolation, or to use a different method of\n    interpolation, or to avoid truncation.\n\n    The spectral response is linearly interpolated to the wavelengths of each\n    spectrum with which is it multiplied internally (``e_sun`` and ``e_ref``).\n    If the wavelengths of the spectral response already match one or both\n    of these spectra interpolation has no effect; therefore, another type of\n    interpolation could be used to process ``sr`` before calling this function.\n\n    The standards describing mismatch calculations focus on indoor laboratory\n    applications, but are applicable to outdoor performance as well.\n    The 2016 version of ASTM E973 [1]_ is somewhat more difficult to\n    read than the 2010 version [2]_ because it includes adjustments for\n    the temperature dependency of spectral response, which led to a\n    formulation using quantum efficiency (QE).\n    IEC 60904-7 is clearer and also discusses the use of a broadband\n    reference device. [3]_\n\n    References\n    ----------\n    .. [1] ASTM \"E973-16 Standard Test Method for Determination of the\n       Spectral Mismatch Parameter Between a Photovoltaic Device and a\n       Photovoltaic Reference Cell\" :doi:`10.1520/E0973-16R20`\n    .. [2] ASTM \"E973-10 Standard Test Method for Determination of the\n       Spectral Mismatch Parameter Between a Photovoltaic Device and a\n       Photovoltaic Reference Cell\" :doi:`10.1520/E0973-10`\n    .. [3] IEC 60904-7 \"Computation of the spectral mismatch correction\n       for measurements of photovoltaic devices\"\n    \"\"\"\n    # Contributed by Anton Driesse (@adriesse), PV Performance Labs. Aug. 2022\n\n    # get the reference spectrum at wavelengths matching the measured spectra\n    if e_ref is None:\n        e_ref = get_am15g(wavelength=e_sun.T.index)\n\n    # interpolate the sr at the wavelengths of the spectra\n    # reference spectrum wavelengths may differ if e_ref is from caller\n    sr_sun = np.interp(e_sun.T.index, sr.index, sr, left=0.0, right=0.0)\n    sr_ref = np.interp(e_ref.T.index, sr.index, sr, left=0.0, right=0.0)\n\n    # a helper function to make usable fraction calculations more readable\n    def integrate(e):\n        return np.trapz(e, x=e.T.index, axis=-1)\n\n    # calculate usable fractions\n    uf_sun = integrate(e_sun * sr_sun) / integrate(e_sun)\n    uf_ref = integrate(e_ref * sr_ref) / integrate(e_ref)\n\n    # mismatch is the ratio or quotient of the usable fractions\n    smm = uf_sun / uf_ref\n\n    if isinstance(e_sun, pd.DataFrame):\n        smm = pd.Series(smm, index=e_sun.index)\n\n    return smm\n", "tokens": ["pvlib", "spectrum", "mismatch", "py", "def", "calc_spectral_mismatch_field", "sr", "e_sun", "e_ref", "none", "calculate", "spectral", "mismatch", "between", "a", "test", "device", "and", "broadband", "reference", "device", "under", "specified", "solar", "spectral", "irradiance", "conditions", "parameters", "sr", "pandas", "series", "the", "relative", "spectral", "response", "of", "one", "photovoltaic", "test", "device", "the", "index", "of", "the", "series", "must", "contain", "wavelength", "values", "in", "nm", "e_sun", "pandas", "dataframe", "or", "pandas", "series", "one", "or", "more", "measured", "solar", "irradiance", "spectra", "in", "a", "pandas", "dataframe", "having", "wavelength", "in", "nm", "as", "column", "index", "a", "single", "spectrum", "may", "be", "be", "given", "as", "a", "pandas", "series", "having", "wavelength", "in", "nm", "as", "index", "w", "m", "2", "nm", "e_ref", "pandas", "series", "optional", "the", "reference", "spectrum", "to", "use", "for", "the", "mismatch", "calculation", "the", "index", "of", "the", "series", "must", "contain", "wavelength", "values", "in", "nm", "the", "default", "is", "the", "astm", "g173", "03", "global", "tilted", "spectrum", "w", "m", "2", "nm", "returns", "smm", "pandas", "series", "or", "float", "if", "a", "single", "measured", "spectrum", "is", "provided", "notes", "measured", "solar", "spectral", "irradiance", "usually", "covers", "a", "wavelength", "range", "that", "is", "smaller", "than", "the", "range", "considered", "as", "broadband", "irradiance", "the", "infrared", "limit", "for", "the", "former", "typically", "lies", "around", "1100", "or", "1600", "nm", "whereas", "the", "latter", "extends", "to", "around", "2800", "or", "4000", "nm", "to", "avoid", "imbalance", "between", "the", "magnitudes", "of", "the", "integrated", "spectra", "the", "broadband", "values", "this", "function", "truncates", "the", "reference", "spectrum", "to", "the", "same", "range", "as", "the", "measured", "or", "simulated", "field", "spectra", "the", "assumption", "implicit", "in", "this", "truncation", "is", "that", "the", "energy", "in", "the", "unmeasured", "wavelength", "range", "is", "the", "same", "fraction", "of", "the", "broadband", "energy", "for", "both", "the", "measured", "spectra", "and", "the", "reference", "spectrum", "if", "the", "default", "reference", "spectrum", "is", "used", "it", "is", "linearly", "interpolated", "to", "the", "wavelengths", "of", "the", "measured", "spectrum", "but", "if", "a", "reference", "spectrum", "is", "provided", "via", "the", "parameter", "e_ref", "it", "is", "used", "without", "change", "this", "makes", "it", "possible", "to", "avoid", "interpolation", "or", "to", "use", "a", "different", "method", "of", "interpolation", "or", "to", "avoid", "truncation", "the", "spectral", "response", "is", "linearly", "interpolated", "to", "the", "wavelengths", "of", "each", "spectrum", "with", "which", "is", "it", "multiplied", "internally", "e_sun", "and", "e_ref", "if", "the", "wavelengths", "of", "the", "spectral", "response", "already", "match", "one", "or", "both", "of", "these", "spectra", "interpolation", "has", "no", "effect", "therefore", "another", "type", "of", "interpolation", "could", "be", "used", "to", "process", "sr", "before", "calling", "this", "function", "the", "standards", "describing", "mismatch", "calculations", "focus", "on", "indoor", "laboratory", "applications", "but", "are", "applicable", "to", "outdoor", "performance", "as", "well", "the", "2016", "version", "of", "astm", "e973", "1", "_", "is", "somewhat", "more", "difficult", "to", "read", "than", "the", "2010", "version", "2", "_", "because", "it", "includes", "adjustments", "for", "the", "temperature", "dependency", "of", "spectral", "response", "which", "led", "to", "a", "formulation", "using", "quantum", "efficiency", "qe", "iec", "60904", "7", "is", "clearer", "and", "also", "discusses", "the", "use", "of", "a", "broadband", "reference", "device", "3", "_", "references", "1", "astm", "e973", "16", "standard", "test", "method", "for", "determination", "of", "the", "spectral", "mismatch", "parameter", "between", "a", "photovoltaic", "device", "and", "a", "photovoltaic", "reference", "cell", "doi", "10", "1520", "e0973", "16r20", "2", "astm", "e973", "10", "standard", "test", "method", "for", "determination", "of", "the", "spectral", "mismatch", "parameter", "between", "a", "photovoltaic", "device", "and", "a", "photovoltaic", "reference", "cell", "doi", "10", "1520", "e0973", "10", "3", "iec", "60904", "7", "computation", "of", "the", "spectral", "mismatch", "correction", "for", "measurements", "of", "photovoltaic", "devices", "contributed", "by", "anton", "driesse", "adriesse", "pv", "performance", "labs", "aug", "2022", "get", "the", "reference", "spectrum", "at", "wavelengths", "matching", "the", "measured", "spectra", "if", "e_ref", "is", "none", "e_ref", "get_am15g", "wavelength", "e_sun", "t", "index", "interpolate", "the", "sr", "at", "the", "wavelengths", "of", "the", "spectra", "reference", "spectrum", "wavelengths", "may", "differ", "if", "e_ref", "is", "from", "caller", "sr_sun", "np", "interp", "e_sun", "t", "index", "sr", "index", "sr", "left", "0", "0", "right", "0", "0", "sr_ref", "np", "interp", "e_ref", "t", "index", "sr", "index", "sr", "left", "0", "0", "right", "0", "0", "a", "helper", "function", "to", "make", "usable", "fraction", "calculations", "more", "readable", "def", "integrate", "e", "return", "np", "trapz", "e", "x", "e", "t", "index", "axis", "1", "calculate", "usable", "fractions", "uf_sun", "integrate", "e_sun", "sr_sun", "integrate", "e_sun", "uf_ref", "integrate", "e_ref", "sr_ref", "integrate", "e_ref", "mismatch", "is", "the", "ratio", "or", "quotient", "of", "the", "usable", "fractions", "smm", "uf_sun", "uf_ref", "if", "isinstance", "e_sun", "pd", "dataframe", "smm", "pd", "series", "smm", "index", "e_sun", "index", "return", "smm"], "doc_len": 651}
{"doc_id": "pvlib/spectrum/spectrl2.py::_spectrl2_transmittances", "file_path": "pvlib/spectrum/spectrl2.py", "class_name": null, "func_name": "_spectrl2_transmittances", "text": "文件路径: pvlib/spectrum/spectrl2.py\ndef _spectrl2_transmittances(apparent_zenith, relative_airmass,\n                             surface_pressure, precipitable_water, ozone,\n                             optical_thickness, scattering_albedo, dayofyear):\n    \"\"\"\n    Calculate transmittance factors from Section 2 of Bird and Riordan 1984.\n\n    Parameters\n    ----------\n    apparent_zenith, relative_airmass, surface_pressure, precipitable_water,\n    ozone, dayofyear: float or 1d np.array\n        One value per timestamp\n    optical_thickness, scattering_albedo: np.ndarray\n        Array with shape (122, N) where N is either 1 or len(apparent_zenith)\n\n    Returns\n    -------\n    earth_sun_distance_correction: float or 1d np.array\n        Same shape/type as apparent_zenith\n    rayleigh_transmittance, aerosol_transmittance, vapor_transmittance,\n    ozone_transmittance, mixed_transmittance, aerosol_scattering,\n    aerosol_absorption: np.ndarray\n        Array with shape (122, N) where N is len(apparent_zenith)\n    \"\"\"\n    # add a dimension so that each ndarray is 2d with shape (122, 1)\n    wavelength = _SPECTRL2_COEFFS['wavelength'][:, np.newaxis]\n    vapor_coeff = _SPECTRL2_COEFFS['water_vapor_absorption'][:, np.newaxis]\n    ozone_coeff = _SPECTRL2_COEFFS['ozone_absorption'][:, np.newaxis]\n    mixed_coeff = _SPECTRL2_COEFFS['mixed_absorption'][:, np.newaxis]\n\n    # ET spectral irradiance correction for earth-sun distance seasonality.\n    # Note that we only want the distance correction coefficient, so set\n    # solar_constant=1:\n    earth_sun_distance_correction = \\\n        pvlib.irradiance.get_extra_radiation(dayofyear, method='spencer',\n                                             solar_constant=1)  # Eq 2-2, 2-3\n    # Rayleigh scattering\n    # note: 101300 is used for consistentcy with reference; can't use\n    # atmosphere.get_absolute_airmass because it uses 101325\n    airmass = relative_airmass * surface_pressure / 101300\n    wavelength_um = wavelength / 1000\n    rayleigh_transmittance = np.exp(\n        # Note: the report uses 1.335 but spectrl2_2.c uses 1.3366\n        # -airmass / (wavelength_um**4 * (115.6406 - 1.335 / wavelength_um**2))\n        -airmass / (wavelength_um**4 * (115.6406 - 1.3366 / wavelength_um**2))\n    )  # Eq 2-4\n\n    # Aerosol scattering and absorption, Eq 2-6\n    aerosol_transmittance = np.exp(-optical_thickness * relative_airmass)\n\n    # Water vapor absorption, Eq 2-8\n    aWM = vapor_coeff * precipitable_water * relative_airmass\n    vapor_transmittance = np.exp(-0.2385 * aWM / (1 + 20.07 * aWM)**0.45)\n\n    # Ozone absorption\n    ozone_max_height = 22\n    h0_norm = ozone_max_height / 6370\n    ozone_mass_numerator = (1 + h0_norm)\n    ozone_mass_denominator = np.sqrt(cosd(apparent_zenith)**2 + 2 * h0_norm)\n    ozone_mass = ozone_mass_numerator / ozone_mass_denominator  # Eq 2-10\n    ozone_transmittance = np.exp(-ozone_coeff * ozone * ozone_mass)  # Eq 2-9\n\n    # Mixed gas absorption, Eq 2-11\n    aM = mixed_coeff * airmass\n    # Note: the report uses 118.93, but spectrl2_2.c uses 118.3\n    # mixed_transmittance = np.exp(-1.41 * aM / (1 + 118.93 * aM)**0.45)\n    mixed_transmittance = np.exp(-1.41 * aM / (1 + 118.3 * aM)**0.45)\n\n    # split out aerosol components for diffuse irradiance calcs\n    aerosol_scattering = np.exp(\n        -scattering_albedo * optical_thickness * relative_airmass\n    )  # Eq 3-9\n\n    aerosol_absorption = np.exp(\n        -(1 - scattering_albedo) * optical_thickness * relative_airmass\n    )  # Eq 3-10\n\n    return (\n        earth_sun_distance_correction,\n        rayleigh_transmittance,\n        aerosol_transmittance,\n        vapor_transmittance,\n        ozone_transmittance,\n        mixed_transmittance,\n        aerosol_scattering,\n        aerosol_absorption,\n    )\n", "tokens": ["pvlib", "spectrum", "spectrl2", "py", "def", "_spectrl2_transmittances", "apparent_zenith", "relative_airmass", "surface_pressure", "precipitable_water", "ozone", "optical_thickness", "scattering_albedo", "dayofyear", "calculate", "transmittance", "factors", "from", "section", "2", "of", "bird", "and", "riordan", "1984", "parameters", "apparent_zenith", "relative_airmass", "surface_pressure", "precipitable_water", "ozone", "dayofyear", "float", "or", "1d", "np", "array", "one", "value", "per", "timestamp", "optical_thickness", "scattering_albedo", "np", "ndarray", "array", "with", "shape", "122", "n", "where", "n", "is", "either", "1", "or", "len", "apparent_zenith", "returns", "earth_sun_distance_correction", "float", "or", "1d", "np", "array", "same", "shape", "type", "as", "apparent_zenith", "rayleigh_transmittance", "aerosol_transmittance", "vapor_transmittance", "ozone_transmittance", "mixed_transmittance", "aerosol_scattering", "aerosol_absorption", "np", "ndarray", "array", "with", "shape", "122", "n", "where", "n", "is", "len", "apparent_zenith", "add", "a", "dimension", "so", "that", "each", "ndarray", "is", "2d", "with", "shape", "122", "1", "wavelength", "_spectrl2_coeffs", "wavelength", "np", "newaxis", "vapor_coeff", "_spectrl2_coeffs", "water_vapor_absorption", "np", "newaxis", "ozone_coeff", "_spectrl2_coeffs", "ozone_absorption", "np", "newaxis", "mixed_coeff", "_spectrl2_coeffs", "mixed_absorption", "np", "newaxis", "et", "spectral", "irradiance", "correction", "for", "earth", "sun", "distance", "seasonality", "note", "that", "we", "only", "want", "the", "distance", "correction", "coefficient", "so", "set", "solar_constant", "1", "earth_sun_distance_correction", "pvlib", "irradiance", "get_extra_radiation", "dayofyear", "method", "spencer", "solar_constant", "1", "eq", "2", "2", "2", "3", "rayleigh", "scattering", "note", "101300", "is", "used", "for", "consistentcy", "with", "reference", "can", "t", "use", "atmosphere", "get_absolute_airmass", "because", "it", "uses", "101325", "airmass", "relative_airmass", "surface_pressure", "101300", "wavelength_um", "wavelength", "1000", "rayleigh_transmittance", "np", "exp", "note", "the", "report", "uses", "1", "335", "but", "spectrl2_2", "c", "uses", "1", "3366", "airmass", "wavelength_um", "4", "115", "6406", "1", "335", "wavelength_um", "2", "airmass", "wavelength_um", "4", "115", "6406", "1", "3366", "wavelength_um", "2", "eq", "2", "4", "aerosol", "scattering", "and", "absorption", "eq", "2", "6", "aerosol_transmittance", "np", "exp", "optical_thickness", "relative_airmass", "water", "vapor", "absorption", "eq", "2", "8", "awm", "vapor_coeff", "precipitable_water", "relative_airmass", "vapor_transmittance", "np", "exp", "0", "2385", "awm", "1", "20", "07", "awm", "0", "45", "ozone", "absorption", "ozone_max_height", "22", "h0_norm", "ozone_max_height", "6370", "ozone_mass_numerator", "1", "h0_norm", "ozone_mass_denominator", "np", "sqrt", "cosd", "apparent_zenith", "2", "2", "h0_norm", "ozone_mass", "ozone_mass_numerator", "ozone_mass_denominator", "eq", "2", "10", "ozone_transmittance", "np", "exp", "ozone_coeff", "ozone", "ozone_mass", "eq", "2", "9", "mixed", "gas", "absorption", "eq", "2", "11", "am", "mixed_coeff", "airmass", "note", "the", "report", "uses", "118", "93", "but", "spectrl2_2", "c", "uses", "118", "3", "mixed_transmittance", "np", "exp", "1", "41", "am", "1", "118", "93", "am", "0", "45", "mixed_transmittance", "np", "exp", "1", "41", "am", "1", "118", "3", "am", "0", "45", "split", "out", "aerosol", "components", "for", "diffuse", "irradiance", "calcs", "aerosol_scattering", "np", "exp", "scattering_albedo", "optical_thickness", "relative_airmass", "eq", "3", "9", "aerosol_absorption", "np", "exp", "1", "scattering_albedo", "optical_thickness", "relative_airmass", "eq", "3", "10", "return", "earth_sun_distance_correction", "rayleigh_transmittance", "aerosol_transmittance", "vapor_transmittance", "ozone_transmittance", "mixed_transmittance", "aerosol_scattering", "aerosol_absorption"], "doc_len": 368}
{"doc_id": "pvlib/spectrum/spectrl2.py::spectrl2", "file_path": "pvlib/spectrum/spectrl2.py", "class_name": null, "func_name": "spectrl2", "text": "文件路径: pvlib/spectrum/spectrl2.py\ndef spectrl2(apparent_zenith, aoi, surface_tilt, ground_albedo,\n             surface_pressure, relative_airmass, precipitable_water, ozone,\n             aerosol_turbidity_500nm, dayofyear=None,\n             scattering_albedo_400nm=0.945, alpha=1.14,\n             wavelength_variation_factor=0.095, aerosol_asymmetry_factor=0.65):\n    \"\"\"\n    Estimate spectral irradiance using the Bird Simple Spectral Model\n    (SPECTRL2).\n\n    The Bird Simple Spectral Model [1]_ produces terrestrial spectra between\n    300 and 4000 nm with a resolution of approximately 10 nm. Direct and\n    diffuse spectral irradiance are modeled for horizontal and tilted surfaces\n    under cloudless skies. SPECTRL2 models radiative transmission, absorption,\n    and scattering due to atmospheric aerosol, water vapor, and ozone content.\n\n    Parameters\n    ----------\n    apparent_zenith : numeric\n        Solar zenith angle [degrees]\n    aoi : numeric\n        Angle of incidence of the solar vector on the panel [degrees]\n    surface_tilt : numeric\n        Panel tilt from horizontal [degrees]\n    ground_albedo : numeric\n        Albedo [0-1] of the ground surface. Can be provided as a scalar value\n        if albedo is not spectrally-dependent, or as a 122xN matrix where\n        the first dimension spans the wavelength range and the second spans\n        the number of simulations. [unitless]\n    surface_pressure : numeric\n        Surface pressure [Pa]\n    relative_airmass : numeric\n        Relative airmass. The airmass model used in [1]_ is the `'kasten1966'`\n        model, while a later implementation by NREL uses the\n        `'kastenyoung1989'` model. [unitless]\n    precipitable_water : numeric\n        Atmospheric water vapor content [cm]\n    ozone : numeric\n        Atmospheric ozone content [atm-cm]\n    aerosol_turbidity_500nm : numeric\n        Aerosol turbidity at 500 nm [unitless]\n    dayofyear : numeric, optional\n        The day of year [1-365].  Must be provided if ``apparent_zenith`` is\n        not a pandas Series.\n    scattering_albedo_400nm : numeric, default 0.945\n        Aerosol single scattering albedo at 400nm. The default value of 0.945\n        is suggested in [1]_ for a rural aerosol model. [unitless]\n    alpha : numeric, default 1.14\n        Angstrom turbidity exponent. The default value of 1.14 is suggested\n        in [1]_ for a rural aerosol model. [unitless]\n    wavelength_variation_factor : numeric, default 0.095\n        Wavelength variation factor [unitless]\n    aerosol_asymmetry_factor : numeric, default 0.65\n        Aerosol asymmetry factor (mean cosine of scattering angle) [unitless]\n\n    Returns\n    -------\n    spectra : dict\n        A dict of arrays.  With the exception of `wavelength`, which has length\n        122, each array has shape (122, N) where N is the length of the\n        input ``apparent_zenith``.  All values are spectral irradiance\n        with units W/m^2/nm except for `wavelength`, which is in nanometers.\n\n            * wavelength\n            * dni_extra\n            * dhi\n            * dni\n            * poa_sky_diffuse\n            * poa_ground_diffuse\n            * poa_direct\n            * poa_global\n\n    Notes\n    -----\n    NREL's C implementation ``spectrl2_2.c`` [2]_ of the model differs in\n    several ways from the original report [1]_.  The report itself also has\n    a few differences between the in-text equations and the code appendix.\n    The list of known differences is shown below.  Note that this\n    implementation follows ``spectrl2_2.c``.\n\n    =================== ========== ========== ===============\n    Equation            Report     Appendix   spectrl2_2.c\n    =================== ========== ========== ===============\n    2-4                 1.335      1.335      1.3366\n    2-11                118.93     118.93     118.3\n    3-8                 To'        Tu'        Tu'\n    3-5, 3-6, 3-7, 3-1  double Cs  single Cs  single Cs\n    2-5                 kasten1966 kasten1966 kastenyoung1989\n    =================== ========== ========== ===============\n\n    This implementation also deviates from the reference by including a\n    check for angles of incidence greater than 90 degrees; without this,\n    the model might return negative spectral irradiance values when the\n    sun is behind the plane of array.\n\n    References\n    ----------\n    .. [1] Bird, R, and Riordan, C., 1984, \"Simple solar spectral model for\n       direct and diffuse irradiance on horizontal and tilted planes at the\n       earth's surface for cloudless atmospheres\", NREL Technical Report\n       TR-215-2436 doi:10.2172/5986936.\n    .. [2] Bird Simple Spectral Model: spectrl2_2.c.\n       https://www.nrel.gov/grid/solar-resource/spectral.html\n    \"\"\"\n    # values need to be np arrays for broadcasting, so unwrap Series if needed:\n    is_pandas = isinstance(apparent_zenith, pd.Series)\n    if is_pandas:\n        original_index = apparent_zenith.index\n        (apparent_zenith, aoi, surface_tilt, ground_albedo, surface_pressure,\n         relative_airmass, precipitable_water, ozone, aerosol_turbidity_500nm,\n         scattering_albedo_400nm, alpha, wavelength_variation_factor,\n         aerosol_asymmetry_factor) = \\\n            tuple(map(np.asanyarray, [\n                apparent_zenith, aoi, surface_tilt, ground_albedo,\n                surface_pressure, relative_airmass, precipitable_water, ozone,\n                aerosol_turbidity_500nm, scattering_albedo_400nm, alpha,\n                wavelength_variation_factor, aerosol_asymmetry_factor]))\n\n        dayofyear = original_index.dayofyear.values\n\n    if not is_pandas and dayofyear is None:\n        raise ValueError('dayofyear must be specified if not using pandas '\n                         'Series inputs')\n\n    # add a dimension so that each ndarray is 2d with shape (122, 1)\n    wavelength = _SPECTRL2_COEFFS['wavelength'][:, np.newaxis]\n    spectrum_et = _SPECTRL2_COEFFS['spectral_irradiance_et'][:, np.newaxis]\n\n    optical_thickness = \\\n        pvlib.atmosphere.angstrom_aod_at_lambda(aod0=aerosol_turbidity_500nm,\n                                                lambda0=500, alpha=alpha,\n                                                lambda1=wavelength)  # Eq 2-7\n\n    # Eq 3-16\n    scattering_albedo = scattering_albedo_400nm * \\\n        np.exp(-wavelength_variation_factor * np.log(wavelength / 400)**2)\n\n    spectrl2 = _spectrl2_transmittances(apparent_zenith, relative_airmass,\n                                        surface_pressure, precipitable_water,\n                                        ozone, optical_thickness,\n                                        scattering_albedo, dayofyear)\n    D, Tr, Ta, Tw, To, Tu, Tas, Taa = spectrl2\n\n    spectrum_et_adj = spectrum_et * D\n    # spectrum of direct irradiance, Eq 2-1\n    Id = spectrum_et_adj * Tr * Ta * Tw * To * Tu\n\n    cosZ = cosd(apparent_zenith)\n    # Eq 3-17\n    Cs = np.where(wavelength <= 450, ((wavelength + 550)/1000)**1.8, 1.0)\n    ALG = np.log(1 - aerosol_asymmetry_factor)  # Eq 3-14\n    BFS = ALG * (0.0783 + ALG * (-0.3824 - ALG * 0.5874))  # Eq 3-13\n    AFS = ALG * (1.459 + ALG * (0.1595 + ALG * 0.4129))  # Eq 3-12\n    Fs = 1 - 0.5 * np.exp((AFS + BFS * cosZ) * cosZ)  # Eq 3-11\n    Fsp = 1 - 0.5 * np.exp((AFS + BFS / 1.8) / 1.8)  # Eq 3.15\n\n    # evaluate the \"primed terms\" -- transmittances evaluated at airmass=1.8\n    primes = _spectrl2_transmittances(apparent_zenith, 1.8,\n                                      surface_pressure, precipitable_water,\n                                      ozone, optical_thickness,\n                                      scattering_albedo, dayofyear)\n    _, Trp, Tap, Twp, Top, Tup, Tasp, Taap = primes\n\n    # Note: not sure what the correct form of this equation is.\n    # The first coefficient is To' in Eq 3-8 but Tu' in the code appendix.\n    # spectrl2_2.c uses Tu'.\n    sky_reflectivity = (\n        # Top * Twp * Taap * (0.5 * (1-Trp) + (1-Fsp) * Trp * (1-Tasp))\n        Tup * Twp * Taap * (0.5 * (1-Trp) + (1-Fsp) * Trp * (1-Tasp))\n    )  # Eq 3-8\n\n    # a common factor for 3-5 and 3-6\n    common_factor = spectrum_et_adj * cosZ * To * Tu * Tw * Taa\n    # Note: spectrl2_2.c differs from the report in how the Cs value is used.\n    # The two commented out lines match the report, while the following match\n    # spectrl2_2.c. With regard to Cs, the equations in the report and\n    # spectrl12_2.c are algebraically equivalent.\n    # Ir = common_factor * (1 - Tr**0.95) * 0.5 * Cs  # Eq 3-5\n    # Ia = common_factor * Tr**1.5 * (1 - Tas) * Fs * Cs  # Eq 3-6\n    Ir = common_factor * (1 - Tr**0.95) * 0.5  # Eq 3-5\n    Ia = common_factor * Tr**1.5 * (1 - Tas) * Fs  # Eq 3-6\n\n    rs = sky_reflectivity\n    rg = ground_albedo\n    Ig = (Id * cosZ + Ir + Ia) * rs * rg / (1 - rs * rg)  # Eq 3-7\n\n    # total scattered irradiance\n    # Note: see discussion about Cs above.\n    # Is = Ir + Ia + Ig  # Eq 3-1\n    Is = (Ir + Ia + Ig) * Cs  # Eq 3-1\n\n    # calculate spectral irradiance on a tilted surface, Eq 3-18\n    # Note: clipping cosd(aoi) to >=0 is not in the reference, but is necessary\n    # to prevent nonsense values when the sun is behind the plane of array.\n    # The same constraint is applied in irradiance.haydavies when not\n    # supplying `projection_ratio`.\n    aoi_projection_nn = np.maximum(cosd(aoi), 0)  # GH 1348\n    Ibeam = Id * aoi_projection_nn\n\n    # don't need surface_azimuth if we provide projection_ratio.\n    # Also constrain cos zenith to avoid blowup, as in irradiance.haydavies\n    projection_ratio = aoi_projection_nn / np.maximum(cosZ, 0.01745)\n    Isky = pvlib.irradiance.haydavies(surface_tilt=surface_tilt,\n                                      surface_azimuth=None,\n                                      dhi=Is,\n                                      dni=Id,\n                                      dni_extra=spectrum_et_adj,\n                                      projection_ratio=projection_ratio)\n\n    ghi = Id * cosZ + Is\n    Iground = pvlib.irradiance.get_ground_diffuse(surface_tilt, ghi, albedo=rg)\n\n    Itilt = Ibeam + Isky + Iground\n    wavelength_1d = wavelength.reshape(-1)  # only needs 1 dimension\n    return {\n        'wavelength': wavelength_1d,\n        'dni_extra': spectrum_et_adj,\n        'dhi': Is,\n        'dni': Id,\n        'poa_sky_diffuse': Isky,\n        'poa_ground_diffuse': Iground,\n        'poa_direct': Ibeam,\n        'poa_global': Itilt,\n    }\n", "tokens": ["pvlib", "spectrum", "spectrl2", "py", "def", "spectrl2", "apparent_zenith", "aoi", "surface_tilt", "ground_albedo", "surface_pressure", "relative_airmass", "precipitable_water", "ozone", "aerosol_turbidity_500nm", "dayofyear", "none", "scattering_albedo_400nm", "0", "945", "alpha", "1", "14", "wavelength_variation_factor", "0", "095", "aerosol_asymmetry_factor", "0", "65", "estimate", "spectral", "irradiance", "using", "the", "bird", "simple", "spectral", "model", "spectrl2", "the", "bird", "simple", "spectral", "model", "1", "_", "produces", "terrestrial", "spectra", "between", "300", "and", "4000", "nm", "with", "a", "resolution", "of", "approximately", "10", "nm", "direct", "and", "diffuse", "spectral", "irradiance", "are", "modeled", "for", "horizontal", "and", "tilted", "surfaces", "under", "cloudless", "skies", "spectrl2", "models", "radiative", "transmission", "absorption", "and", "scattering", "due", "to", "atmospheric", "aerosol", "water", "vapor", "and", "ozone", "content", "parameters", "apparent_zenith", "numeric", "solar", "zenith", "angle", "degrees", "aoi", "numeric", "angle", "of", "incidence", "of", "the", "solar", "vector", "on", "the", "panel", "degrees", "surface_tilt", "numeric", "panel", "tilt", "from", "horizontal", "degrees", "ground_albedo", "numeric", "albedo", "0", "1", "of", "the", "ground", "surface", "can", "be", "provided", "as", "a", "scalar", "value", "if", "albedo", "is", "not", "spectrally", "dependent", "or", "as", "a", "122xn", "matrix", "where", "the", "first", "dimension", "spans", "the", "wavelength", "range", "and", "the", "second", "spans", "the", "number", "of", "simulations", "unitless", "surface_pressure", "numeric", "surface", "pressure", "pa", "relative_airmass", "numeric", "relative", "airmass", "the", "airmass", "model", "used", "in", "1", "_", "is", "the", "kasten1966", "model", "while", "a", "later", "implementation", "by", "nrel", "uses", "the", "kastenyoung1989", "model", "unitless", "precipitable_water", "numeric", "atmospheric", "water", "vapor", "content", "cm", "ozone", "numeric", "atmospheric", "ozone", "content", "atm", "cm", "aerosol_turbidity_500nm", "numeric", "aerosol", "turbidity", "at", "500", "nm", "unitless", "dayofyear", "numeric", "optional", "the", "day", "of", "year", "1", "365", "must", "be", "provided", "if", "apparent_zenith", "is", "not", "a", "pandas", "series", "scattering_albedo_400nm", "numeric", "default", "0", "945", "aerosol", "single", "scattering", "albedo", "at", "400nm", "the", "default", "value", "of", "0", "945", "is", "suggested", "in", "1", "_", "for", "a", "rural", "aerosol", "model", "unitless", "alpha", "numeric", "default", "1", "14", "angstrom", "turbidity", "exponent", "the", "default", "value", "of", "1", "14", "is", "suggested", "in", "1", "_", "for", "a", "rural", "aerosol", "model", "unitless", "wavelength_variation_factor", "numeric", "default", "0", "095", "wavelength", "variation", "factor", "unitless", "aerosol_asymmetry_factor", "numeric", "default", "0", "65", "aerosol", "asymmetry", "factor", "mean", "cosine", "of", "scattering", "angle", "unitless", "returns", "spectra", "dict", "a", "dict", "of", "arrays", "with", "the", "exception", "of", "wavelength", "which", "has", "length", "122", "each", "array", "has", "shape", "122", "n", "where", "n", "is", "the", "length", "of", "the", "input", "apparent_zenith", "all", "values", "are", "spectral", "irradiance", "with", "units", "w", "m", "2", "nm", "except", "for", "wavelength", "which", "is", "in", "nanometers", "wavelength", "dni_extra", "dhi", "dni", "poa_sky_diffuse", "poa_ground_diffuse", "poa_direct", "poa_global", "notes", "nrel", "s", "c", "implementation", "spectrl2_2", "c", "2", "_", "of", "the", "model", "differs", "in", "several", "ways", "from", "the", "original", "report", "1", "_", "the", "report", "itself", "also", "has", "a", "few", "differences", "between", "the", "in", "text", "equations", "and", "the", "code", "appendix", "the", "list", "of", "known", "differences", "is", "shown", "below", "note", "that", "this", "implementation", "follows", "spectrl2_2", "c", "equation", "report", "appendix", "spectrl2_2", "c", "2", "4", "1", "335", "1", "335", "1", "3366", "2", "11", "118", "93", "118", "93", "118", "3", "3", "8", "to", "tu", "tu", "3", "5", "3", "6", "3", "7", "3", "1", "double", "cs", "single", "cs", "single", "cs", "2", "5", "kasten1966", "kasten1966", "kastenyoung1989", "this", "implementation", "also", "deviates", "from", "the", "reference", "by", "including", "a", "check", "for", "angles", "of", "incidence", "greater", "than", "90", "degrees", "without", "this", "the", "model", "might", "return", "negative", "spectral", "irradiance", "values", "when", "the", "sun", "is", "behind", "the", "plane", "of", "array", "references", "1", "bird", "r", "and", "riordan", "c", "1984", "simple", "solar", "spectral", "model", "for", "direct", "and", "diffuse", "irradiance", "on", "horizontal", "and", "tilted", "planes", "at", "the", "earth", "s", "surface", "for", "cloudless", "atmospheres", "nrel", "technical", "report", "tr", "215", "2436", "doi", "10", "2172", "5986936", "2", "bird", "simple", "spectral", "model", "spectrl2_2", "c", "https", "www", "nrel", "gov", "grid", "solar", "resource", "spectral", "html", "values", "need", "to", "be", "np", "arrays", "for", "broadcasting", "so", "unwrap", "series", "if", "needed", "is_pandas", "isinstance", "apparent_zenith", "pd", "series", "if", "is_pandas", "original_index", "apparent_zenith", "index", "apparent_zenith", "aoi", "surface_tilt", "ground_albedo", "surface_pressure", "relative_airmass", "precipitable_water", "ozone", "aerosol_turbidity_500nm", "scattering_albedo_400nm", "alpha", "wavelength_variation_factor", "aerosol_asymmetry_factor", "tuple", "map", "np", "asanyarray", "apparent_zenith", "aoi", "surface_tilt", "ground_albedo", "surface_pressure", "relative_airmass", "precipitable_water", "ozone", "aerosol_turbidity_500nm", "scattering_albedo_400nm", "alpha", "wavelength_variation_factor", "aerosol_asymmetry_factor", "dayofyear", "original_index", "dayofyear", "values", "if", "not", "is_pandas", "and", "dayofyear", "is", "none", "raise", "valueerror", "dayofyear", "must", "be", "specified", "if", "not", "using", "pandas", "series", "inputs", "add", "a", "dimension", "so", "that", "each", "ndarray", "is", "2d", "with", "shape", "122", "1", "wavelength", "_spectrl2_coeffs", "wavelength", "np", "newaxis", "spectrum_et", "_spectrl2_coeffs", "spectral_irradiance_et", "np", "newaxis", "optical_thickness", "pvlib", "atmosphere", "angstrom_aod_at_lambda", "aod0", "aerosol_turbidity_500nm", "lambda0", "500", "alpha", "alpha", "lambda1", "wavelength", "eq", "2", "7", "eq", "3", "16", "scattering_albedo", "scattering_albedo_400nm", "np", "exp", "wavelength_variation_factor", "np", "log", "wavelength", "400", "2", "spectrl2", "_spectrl2_transmittances", "apparent_zenith", "relative_airmass", "surface_pressure", "precipitable_water", "ozone", "optical_thickness", "scattering_albedo", "dayofyear", "d", "tr", "ta", "tw", "to", "tu", "tas", "taa", "spectrl2", "spectrum_et_adj", "spectrum_et", "d", "spectrum", "of", "direct", "irradiance", "eq", "2", "1", "id", "spectrum_et_adj", "tr", "ta", "tw", "to", "tu", "cosz", "cosd", "apparent_zenith", "eq", "3", "17", "cs", "np", "where", "wavelength", "450", "wavelength", "550", "1000", "1", "8", "1", "0", "alg", "np", "log", "1", "aerosol_asymmetry_factor", "eq", "3", "14", "bfs", "alg", "0", "0783", "alg", "0", "3824", "alg", "0", "5874", "eq", "3", "13", "afs", "alg", "1", "459", "alg", "0", "1595", "alg", "0", "4129", "eq", "3", "12", "fs", "1", "0", "5", "np", "exp", "afs", "bfs", "cosz", "cosz", "eq", "3", "11", "fsp", "1", "0", "5", "np", "exp", "afs", "bfs", "1", "8", "1", "8", "eq", "3", "15", "evaluate", "the", "primed", "terms", "transmittances", "evaluated", "at", "airmass", "1", "8", "primes", "_spectrl2_transmittances", "apparent_zenith", "1", "8", "surface_pressure", "precipitable_water", "ozone", "optical_thickness", "scattering_albedo", "dayofyear", "_", "trp", "tap", "twp", "top", "tup", "tasp", "taap", "primes", "note", "not", "sure", "what", "the", "correct", "form", "of", "this", "equation", "is", "the", "first", "coefficient", "is", "to", "in", "eq", "3", "8", "but", "tu", "in", "the", "code", "appendix", "spectrl2_2", "c", "uses", "tu", "sky_reflectivity", "top", "twp", "taap", "0", "5", "1", "trp", "1", "fsp", "trp", "1", "tasp", "tup", "twp", "taap", "0", "5", "1", "trp", "1", "fsp", "trp", "1", "tasp", "eq", "3", "8", "a", "common", "factor", "for", "3", "5", "and", "3", "6", "common_factor", "spectrum_et_adj", "cosz", "to", "tu", "tw", "taa", "note", "spectrl2_2", "c", "differs", "from", "the", "report", "in", "how", "the", "cs", "value", "is", "used", "the", "two", "commented", "out", "lines", "match", "the", "report", "while", "the", "following", "match", "spectrl2_2", "c", "with", "regard", "to", "cs", "the", "equations", "in", "the", "report", "and", "spectrl12_2", "c", "are", "algebraically", "equivalent", "ir", "common_factor", "1", "tr", "0", "95", "0", "5", "cs", "eq", "3", "5", "ia", "common_factor", "tr", "1", "5", "1", "tas", "fs", "cs", "eq", "3", "6", "ir", "common_factor", "1", "tr", "0", "95", "0", "5", "eq", "3", "5", "ia", "common_factor", "tr", "1", "5", "1", "tas", "fs", "eq", "3", "6", "rs", "sky_reflectivity", "rg", "ground_albedo", "ig", "id", "cosz", "ir", "ia", "rs", "rg", "1", "rs", "rg", "eq", "3", "7", "total", "scattered", "irradiance", "note", "see", "discussion", "about", "cs", "above", "is", "ir", "ia", "ig", "eq", "3", "1", "is", "ir", "ia", "ig", "cs", "eq", "3", "1", "calculate", "spectral", "irradiance", "on", "a", "tilted", "surface", "eq", "3", "18", "note", "clipping", "cosd", "aoi", "to", "0", "is", "not", "in", "the", "reference", "but", "is", "necessary", "to", "prevent", "nonsense", "values", "when", "the", "sun", "is", "behind", "the", "plane", "of", "array", "the", "same", "constraint", "is", "applied", "in", "irradiance", "haydavies", "when", "not", "supplying", "projection_ratio", "aoi_projection_nn", "np", "maximum", "cosd", "aoi", "0", "gh", "1348", "ibeam", "id", "aoi_projection_nn", "don", "t", "need", "surface_azimuth", "if", "we", "provide", "projection_ratio", "also", "constrain", "cos", "zenith", "to", "avoid", "blowup", "as", "in", "irradiance", "haydavies", "projection_ratio", "aoi_projection_nn", "np", "maximum", "cosz", "0", "01745", "isky", "pvlib", "irradiance", "haydavies", "surface_tilt", "surface_tilt", "surface_azimuth", "none", "dhi", "is", "dni", "id", "dni_extra", "spectrum_et_adj", "projection_ratio", "projection_ratio", "ghi", "id", "cosz", "is", "iground", "pvlib", "irradiance", "get_ground_diffuse", "surface_tilt", "ghi", "albedo", "rg", "itilt", "ibeam", "isky", "iground", "wavelength_1d", "wavelength", "reshape", "1", "only", "needs", "1", "dimension", "return", "wavelength", "wavelength_1d", "dni_extra", "spectrum_et_adj", "dhi", "is", "dni", "id", "poa_sky_diffuse", "isky", "poa_ground_diffuse", "iground", "poa_direct", "ibeam", "poa_global", "itilt"], "doc_len": 1181}
{"doc_id": "pvlib/tests/conftest.py::fail_on_pvlib_version", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "fail_on_pvlib_version", "text": "文件路径: pvlib/tests/conftest.py\ndef fail_on_pvlib_version(version):\n    # second level of decorator takes the function under consideration\n    def wrapper(func):\n        # third level defers computation until the test is called\n        # this allows the specific test to fail at test runtime,\n        # rather than at decoration time (when the module is imported)\n        @wraps(func)\n        def inner(*args, **kwargs):\n            # fail if the version is too high\n            if pvlib_base_version >= parse_version(version):\n                pytest.fail('the tested function is scheduled to be '\n                            'removed in %s' % version)\n            # otherwise return the function to be executed\n            else:\n                return func(*args, **kwargs)\n        return inner\n    return wrapper\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "fail_on_pvlib_version", "version", "second", "level", "of", "decorator", "takes", "the", "function", "under", "consideration", "def", "wrapper", "func", "third", "level", "defers", "computation", "until", "the", "test", "is", "called", "this", "allows", "the", "specific", "test", "to", "fail", "at", "test", "runtime", "rather", "than", "at", "decoration", "time", "when", "the", "module", "is", "imported", "wraps", "func", "def", "inner", "args", "kwargs", "fail", "if", "the", "version", "is", "too", "high", "if", "pvlib_base_version", "parse_version", "version", "pytest", "fail", "the", "tested", "function", "is", "scheduled", "to", "be", "removed", "in", "s", "version", "otherwise", "return", "the", "function", "to", "be", "executed", "else", "return", "func", "args", "kwargs", "return", "inner", "return", "wrapper"], "doc_len": 94}
{"doc_id": "pvlib/tests/conftest.py::_check_pandas_assert_kwargs", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "_check_pandas_assert_kwargs", "text": "文件路径: pvlib/tests/conftest.py\ndef _check_pandas_assert_kwargs(kwargs):\n    # handles the change in API related to default\n    # tolerances in pandas 1.1.0.  See pvlib GH #1018\n    if parse_version(pd.__version__) >= parse_version('1.1.0'):\n        if kwargs.pop('check_less_precise', False):\n            kwargs['atol'] = 1e-3\n            kwargs['rtol'] = 1e-3\n        else:\n            kwargs['atol'] = 1e-5\n            kwargs['rtol'] = 1e-5\n    else:\n        kwargs.pop('rtol', None)\n        kwargs.pop('atol', None)\n    return kwargs\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "_check_pandas_assert_kwargs", "kwargs", "handles", "the", "change", "in", "api", "related", "to", "default", "tolerances", "in", "pandas", "1", "1", "0", "see", "pvlib", "gh", "1018", "if", "parse_version", "pd", "__version__", "parse_version", "1", "1", "0", "if", "kwargs", "pop", "check_less_precise", "false", "kwargs", "atol", "1e", "3", "kwargs", "rtol", "1e", "3", "else", "kwargs", "atol", "1e", "5", "kwargs", "rtol", "1e", "5", "else", "kwargs", "pop", "rtol", "none", "kwargs", "pop", "atol", "none", "return", "kwargs"], "doc_len": 66}
{"doc_id": "pvlib/tests/conftest.py::assert_index_equal", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "assert_index_equal", "text": "文件路径: pvlib/tests/conftest.py\ndef assert_index_equal(left, right, **kwargs):\n    kwargs = _check_pandas_assert_kwargs(kwargs)\n    pd.testing.assert_index_equal(left, right, **kwargs)\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "assert_index_equal", "left", "right", "kwargs", "kwargs", "_check_pandas_assert_kwargs", "kwargs", "pd", "testing", "assert_index_equal", "left", "right", "kwargs"], "doc_len": 18}
{"doc_id": "pvlib/tests/conftest.py::assert_series_equal", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "assert_series_equal", "text": "文件路径: pvlib/tests/conftest.py\ndef assert_series_equal(left, right, **kwargs):\n    kwargs = _check_pandas_assert_kwargs(kwargs)\n    pd.testing.assert_series_equal(left, right, **kwargs)\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "assert_series_equal", "left", "right", "kwargs", "kwargs", "_check_pandas_assert_kwargs", "kwargs", "pd", "testing", "assert_series_equal", "left", "right", "kwargs"], "doc_len": 18}
{"doc_id": "pvlib/tests/conftest.py::assert_frame_equal", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "assert_frame_equal", "text": "文件路径: pvlib/tests/conftest.py\ndef assert_frame_equal(left, right, **kwargs):\n    kwargs = _check_pandas_assert_kwargs(kwargs)\n    pd.testing.assert_frame_equal(left, right, **kwargs)\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "assert_frame_equal", "left", "right", "kwargs", "kwargs", "_check_pandas_assert_kwargs", "kwargs", "pd", "testing", "assert_frame_equal", "left", "right", "kwargs"], "doc_len": 18}
{"doc_id": "pvlib/tests/conftest.py::has_spa_c", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "has_spa_c", "text": "文件路径: pvlib/tests/conftest.py\ndef has_spa_c():\n    try:\n        from pvlib.spa_c_files.spa_py import spa_calc\n    except ImportError:\n        return False\n    else:\n        return True\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "has_spa_c", "try", "from", "pvlib", "spa_c_files", "spa_py", "import", "spa_calc", "except", "importerror", "return", "false", "else", "return", "true"], "doc_len": 20}
{"doc_id": "pvlib/tests/conftest.py::has_numba", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "has_numba", "text": "文件路径: pvlib/tests/conftest.py\ndef has_numba():\n    try:\n        import numba\n    except ImportError:\n        return False\n    else:\n        vers = numba.__version__.split('.')\n        if int(vers[0] + vers[1]) < 17:\n            return False\n        else:\n            return True\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "has_numba", "try", "import", "numba", "except", "importerror", "return", "false", "else", "vers", "numba", "__version__", "split", "if", "int", "vers", "0", "vers", "1", "17", "return", "false", "else", "return", "true"], "doc_len": 30}
{"doc_id": "pvlib/tests/conftest.py::golden", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "golden", "text": "文件路径: pvlib/tests/conftest.py\ndef golden():\n    return Location(39.742476, -105.1786, 'America/Denver', 1830.14)\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "golden", "return", "location", "39", "742476", "105", "1786", "america", "denver", "1830", "14"], "doc_len": 16}
{"doc_id": "pvlib/tests/conftest.py::golden_mst", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "golden_mst", "text": "文件路径: pvlib/tests/conftest.py\ndef golden_mst():\n    return Location(39.742476, -105.1786, 'MST', 1830.14)\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "golden_mst", "return", "location", "39", "742476", "105", "1786", "mst", "1830", "14"], "doc_len": 15}
{"doc_id": "pvlib/tests/conftest.py::expected_solpos", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "expected_solpos", "text": "文件路径: pvlib/tests/conftest.py\ndef expected_solpos():\n    return pd.DataFrame({'elevation': 39.872046,\n                         'apparent_zenith': 50.111622,\n                         'azimuth': 194.340241,\n                         'apparent_elevation': 39.888378},\n                        index=['2003-10-17T12:30:30Z'])\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "expected_solpos", "return", "pd", "dataframe", "elevation", "39", "872046", "apparent_zenith", "50", "111622", "azimuth", "194", "340241", "apparent_elevation", "39", "888378", "index", "2003", "10", "17t12", "30", "30z"], "doc_len": 27}
{"doc_id": "pvlib/tests/conftest.py::sam_data", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "sam_data", "text": "文件路径: pvlib/tests/conftest.py\ndef sam_data():\n    data = {}\n    with warnings.catch_warnings():\n        # ignore messages about duplicate entries in the databases.\n        warnings.simplefilter(\"ignore\", UserWarning)\n        data['sandiamod'] = pvlib.pvsystem.retrieve_sam('sandiamod')\n        data['adrinverter'] = pvlib.pvsystem.retrieve_sam('adrinverter')\n    return data\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "sam_data", "data", "with", "warnings", "catch_warnings", "ignore", "messages", "about", "duplicate", "entries", "in", "the", "databases", "warnings", "simplefilter", "ignore", "userwarning", "data", "sandiamod", "pvlib", "pvsystem", "retrieve_sam", "sandiamod", "data", "adrinverter", "pvlib", "pvsystem", "retrieve_sam", "adrinverter", "return", "data"], "doc_len": 36}
{"doc_id": "pvlib/tests/conftest.py::pvsyst_module_params", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "pvsyst_module_params", "text": "文件路径: pvlib/tests/conftest.py\ndef pvsyst_module_params():\n    \"\"\"\n    Define some PVSyst module parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'gamma_ref': 1.05,\n        'mu_gamma': 0.001,\n        'I_L_ref': 6.0,\n        'I_o_ref': 5e-9,\n        'EgRef': 1.121,\n        'R_sh_ref': 300,\n        'R_sh_0': 1000,\n        'R_s': 0.5,\n        'R_sh_exp': 5.5,\n        'cells_in_series': 60,\n        'alpha_sc': 0.001,\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "pvsyst_module_params", "define", "some", "pvsyst", "module", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "gamma_ref", "1", "05", "mu_gamma", "0", "001", "i_l_ref", "6", "0", "i_o_ref", "5e", "9", "egref", "1", "121", "r_sh_ref", "300", "r_sh_0", "1000", "r_s", "0", "5", "r_sh_exp", "5", "5", "cells_in_series", "60", "alpha_sc", "0", "001", "return", "parameters"], "doc_len": 67}
{"doc_id": "pvlib/tests/conftest.py::adr_inverter_parameters", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "adr_inverter_parameters", "text": "文件路径: pvlib/tests/conftest.py\ndef adr_inverter_parameters():\n    \"\"\"\n    Define some ADR inverter parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'Ablerex Electronics Co., Ltd.: ES 2200-US-240 (240Vac)'\n                '[CEC 2011]',\n        'Vac': 240.,\n        'Pacmax': 2110.,\n        'Pnom': 2200.,\n        'Vnom': 396.,\n        'Vmin': 155.,\n        'Vmax': 413.,\n        'Vdcmax': 500.,\n        'MPPTHi': 450.,\n        'MPPTLow': 150.,\n        'Pnt': 0.25,\n        'ADRCoefficients': [0.01385, 0.0152, 0.00794, 0.00286, -0.01872,\n                            -0.01305, 0.0, 0.0, 0.0]\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "adr_inverter_parameters", "define", "some", "adr", "inverter", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "ablerex", "electronics", "co", "ltd", "es", "2200", "us", "240", "240vac", "cec", "2011", "vac", "240", "pacmax", "2110", "pnom", "2200", "vnom", "396", "vmin", "155", "vmax", "413", "vdcmax", "500", "mppthi", "450", "mpptlow", "150", "pnt", "0", "25", "adrcoefficients", "0", "01385", "0", "0152", "0", "00794", "0", "00286", "0", "01872", "0", "01305", "0", "0", "0", "0", "0", "0", "return", "parameters"], "doc_len": 89}
{"doc_id": "pvlib/tests/conftest.py::cec_inverter_parameters", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "cec_inverter_parameters", "text": "文件路径: pvlib/tests/conftest.py\ndef cec_inverter_parameters():\n    \"\"\"\n    Define some CEC inverter parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'ABB: MICRO-0.25-I-OUTD-US-208 208V [CEC 2014]',\n        'Vac': 208.0,\n        'Paco': 250.0,\n        'Pdco': 259.5220505,\n        'Vdco': 40.24260317,\n        'Pso': 1.771614224,\n        'C0': -2.48e-5,\n        'C1': -9.01e-5,\n        'C2': 6.69e-4,\n        'C3': -0.0189,\n        'Pnt': 0.02,\n        'Vdcmax': 65.0,\n        'Idcmax': 10.0,\n        'Mppt_low': 20.0,\n        'Mppt_high': 50.0,\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "cec_inverter_parameters", "define", "some", "cec", "inverter", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "abb", "micro", "0", "25", "i", "outd", "us", "208", "208v", "cec", "2014", "vac", "208", "0", "paco", "250", "0", "pdco", "259", "5220505", "vdco", "40", "24260317", "pso", "1", "771614224", "c0", "2", "48e", "5", "c1", "9", "01e", "5", "c2", "6", "69e", "4", "c3", "0", "0189", "pnt", "0", "02", "vdcmax", "65", "0", "idcmax", "10", "0", "mppt_low", "20", "0", "mppt_high", "50", "0", "return", "parameters"], "doc_len": 94}
{"doc_id": "pvlib/tests/conftest.py::cec_module_params", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "cec_module_params", "text": "文件路径: pvlib/tests/conftest.py\ndef cec_module_params():\n    \"\"\"\n    Define some CEC module parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'Example Module',\n        'BIPV': 'Y',\n        'Date': '4/28/2008',\n        'T_NOCT': 65,\n        'A_c': 0.67,\n        'N_s': 18,\n        'I_sc_ref': 7.5,\n        'V_oc_ref': 10.4,\n        'I_mp_ref': 6.6,\n        'V_mp_ref': 8.4,\n        'alpha_sc': 0.003,\n        'beta_oc': -0.04,\n        'a_ref': 0.473,\n        'I_L_ref': 7.545,\n        'I_o_ref': 1.94e-09,\n        'R_s': 0.094,\n        'R_sh_ref': 15.72,\n        'Adjust': 10.6,\n        'gamma_r': -0.5,\n        'Version': 'MM105',\n        'PTC': 48.9,\n        'Technology': 'Multi-c-Si',\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "cec_module_params", "define", "some", "cec", "module", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "example", "module", "bipv", "y", "date", "4", "28", "2008", "t_noct", "65", "a_c", "0", "67", "n_s", "18", "i_sc_ref", "7", "5", "v_oc_ref", "10", "4", "i_mp_ref", "6", "6", "v_mp_ref", "8", "4", "alpha_sc", "0", "003", "beta_oc", "0", "04", "a_ref", "0", "473", "i_l_ref", "7", "545", "i_o_ref", "1", "94e", "09", "r_s", "0", "094", "r_sh_ref", "15", "72", "adjust", "10", "6", "gamma_r", "0", "5", "version", "mm105", "ptc", "48", "9", "technology", "multi", "c", "si", "return", "parameters"], "doc_len": 102}
{"doc_id": "pvlib/tests/conftest.py::cec_module_cs5p_220m", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "cec_module_cs5p_220m", "text": "文件路径: pvlib/tests/conftest.py\ndef cec_module_cs5p_220m():\n    \"\"\"\n    Define Canadian Solar CS5P-220M module parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'Canadian Solar CS5P-220M',\n        'BIPV': 'N',\n        'Date': '10/5/2009',\n        'T_NOCT': 42.4,\n        'A_c': 1.7,\n        'N_s': 96,\n        'I_sc_ref': 5.1,\n        'V_oc_ref': 59.4,\n        'I_mp_ref': 4.69,\n        'V_mp_ref': 46.9,\n        'alpha_sc': 0.004539,\n        'beta_oc': -0.22216,\n        'a_ref': 2.6373,\n        'I_L_ref': 5.114,\n        'I_o_ref': 8.196e-10,\n        'R_s': 1.065,\n        'R_sh_ref': 381.68,\n        'Adjust': 8.7,\n        'gamma_r': -0.476,\n        'Version': 'MM106',\n        'PTC': 200.1,\n        'Technology': 'Mono-c-Si',\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "cec_module_cs5p_220m", "define", "canadian", "solar", "cs5p", "220m", "module", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "canadian", "solar", "cs5p", "220m", "bipv", "n", "date", "10", "5", "2009", "t_noct", "42", "4", "a_c", "1", "7", "n_s", "96", "i_sc_ref", "5", "1", "v_oc_ref", "59", "4", "i_mp_ref", "4", "69", "v_mp_ref", "46", "9", "alpha_sc", "0", "004539", "beta_oc", "0", "22216", "a_ref", "2", "6373", "i_l_ref", "5", "114", "i_o_ref", "8", "196e", "10", "r_s", "1", "065", "r_sh_ref", "381", "68", "adjust", "8", "7", "gamma_r", "0", "476", "version", "mm106", "ptc", "200", "1", "technology", "mono", "c", "si", "return", "parameters"], "doc_len": 107}
{"doc_id": "pvlib/tests/conftest.py::cec_module_spr_e20_327", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "cec_module_spr_e20_327", "text": "文件路径: pvlib/tests/conftest.py\ndef cec_module_spr_e20_327():\n    \"\"\"\n    Define SunPower SPR-E20-327 module parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'SunPower SPR-E20-327',\n        'BIPV': 'N',\n        'Date': '1/14/2013',\n        'T_NOCT': 46,\n        'A_c': 1.631,\n        'N_s': 96,\n        'I_sc_ref': 6.46,\n        'V_oc_ref': 65.1,\n        'I_mp_ref': 5.98,\n        'V_mp_ref': 54.7,\n        'alpha_sc': 0.004522,\n        'beta_oc': -0.23176,\n        'a_ref': 2.6868,\n        'I_L_ref': 6.468,\n        'I_o_ref': 1.88e-10,\n        'R_s': 0.37,\n        'R_sh_ref': 298.13,\n        'Adjust': -0.1862,\n        'gamma_r': -0.386,\n        'Version': 'NRELv1',\n        'PTC': 301.4,\n        'Technology': 'Mono-c-Si',\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "cec_module_spr_e20_327", "define", "sunpower", "spr", "e20", "327", "module", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "sunpower", "spr", "e20", "327", "bipv", "n", "date", "1", "14", "2013", "t_noct", "46", "a_c", "1", "631", "n_s", "96", "i_sc_ref", "6", "46", "v_oc_ref", "65", "1", "i_mp_ref", "5", "98", "v_mp_ref", "54", "7", "alpha_sc", "0", "004522", "beta_oc", "0", "23176", "a_ref", "2", "6868", "i_l_ref", "6", "468", "i_o_ref", "1", "88e", "10", "r_s", "0", "37", "r_sh_ref", "298", "13", "adjust", "0", "1862", "gamma_r", "0", "386", "version", "nrelv1", "ptc", "301", "4", "technology", "mono", "c", "si", "return", "parameters"], "doc_len": 106}
{"doc_id": "pvlib/tests/conftest.py::cec_module_fs_495", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "cec_module_fs_495", "text": "文件路径: pvlib/tests/conftest.py\ndef cec_module_fs_495():\n    \"\"\"\n    Define First Solar FS-495 module parameters for testing.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {\n        'Name': 'First Solar FS-495',\n        'BIPV': 'N',\n        'Date': '9/18/2014',\n        'T_NOCT': 44.6,\n        'A_c': 0.72,\n        'N_s': 216,\n        'I_sc_ref': 1.55,\n        'V_oc_ref': 86.5,\n        'I_mp_ref': 1.4,\n        'V_mp_ref': 67.9,\n        'alpha_sc': 0.000924,\n        'beta_oc': -0.22741,\n        'a_ref': 2.9482,\n        'I_L_ref': 1.563,\n        'I_o_ref': 2.64e-13,\n        'R_s': 6.804,\n        'R_sh_ref': 806.27,\n        'Adjust': -10.65,\n        'gamma_r': -0.264,\n        'Version': 'NRELv1',\n        'PTC': 89.7,\n        'Technology': 'CdTe',\n    }\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "cec_module_fs_495", "define", "first", "solar", "fs", "495", "module", "parameters", "for", "testing", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "name", "first", "solar", "fs", "495", "bipv", "n", "date", "9", "18", "2014", "t_noct", "44", "6", "a_c", "0", "72", "n_s", "216", "i_sc_ref", "1", "55", "v_oc_ref", "86", "5", "i_mp_ref", "1", "4", "v_mp_ref", "67", "9", "alpha_sc", "0", "000924", "beta_oc", "0", "22741", "a_ref", "2", "9482", "i_l_ref", "1", "563", "i_o_ref", "2", "64e", "13", "r_s", "6", "804", "r_sh_ref", "806", "27", "adjust", "10", "65", "gamma_r", "0", "264", "version", "nrelv1", "ptc", "89", "7", "technology", "cdte", "return", "parameters"], "doc_len": 105}
{"doc_id": "pvlib/tests/conftest.py::sapm_temperature_cs5p_220m", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "sapm_temperature_cs5p_220m", "text": "文件路径: pvlib/tests/conftest.py\ndef sapm_temperature_cs5p_220m():\n    # SAPM temperature model parameters for Canadian_Solar_CS5P_220M\n    # (glass/polymer) in open rack\n    return {'a': -3.40641, 'b': -0.0842075, 'deltaT': 3}\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "sapm_temperature_cs5p_220m", "sapm", "temperature", "model", "parameters", "for", "canadian_solar_cs5p_220m", "glass", "polymer", "in", "open", "rack", "return", "a", "3", "40641", "b", "0", "0842075", "deltat", "3"], "doc_len": 26}
{"doc_id": "pvlib/tests/conftest.py::sapm_module_params", "file_path": "pvlib/tests/conftest.py", "class_name": null, "func_name": "sapm_module_params", "text": "文件路径: pvlib/tests/conftest.py\ndef sapm_module_params():\n    \"\"\"\n    Define SAPM model parameters for Canadian Solar CS5P 220M module.\n\n    The scope of the fixture is set to ``'function'`` to allow tests to modify\n    parameters if required without affecting other tests.\n    \"\"\"\n    parameters = {'Material': 'c-Si',\n                  'Cells_in_Series': 96,\n                  'Parallel_Strings': 1,\n                  'A0': 0.928385,\n                  'A1': 0.068093,\n                  'A2': -0.0157738,\n                  'A3': 0.0016606,\n                  'A4': -6.93E-05,\n                  'B0': 1,\n                  'B1': -0.002438,\n                  'B2': 0.0003103,\n                  'B3': -0.00001246,\n                  'B4': 2.11E-07,\n                  'B5': -1.36E-09,\n                  'C0': 1.01284,\n                  'C1': -0.0128398,\n                  'C2': 0.279317,\n                  'C3': -7.24463,\n                  'C4': 0.996446,\n                  'C5': 0.003554,\n                  'C6': 1.15535,\n                  'C7': -0.155353,\n                  'Isco': 5.09115,\n                  'Impo': 4.54629,\n                  'Voco': 59.2608,\n                  'Vmpo': 48.3156,\n                  'Aisc': 0.000397,\n                  'Aimp': 0.000181,\n                  'Bvoco': -0.21696,\n                  'Mbvoc': 0.0,\n                  'Bvmpo': -0.235488,\n                  'Mbvmp': 0.0,\n                  'N': 1.4032,\n                  'IXO': 4.97599,\n                  'IXXO': 3.18803,\n                  'FD': 1}\n    return parameters\n", "tokens": ["pvlib", "tests", "conftest", "py", "def", "sapm_module_params", "define", "sapm", "model", "parameters", "for", "canadian", "solar", "cs5p", "220m", "module", "the", "scope", "of", "the", "fixture", "is", "set", "to", "function", "to", "allow", "tests", "to", "modify", "parameters", "if", "required", "without", "affecting", "other", "tests", "parameters", "material", "c", "si", "cells_in_series", "96", "parallel_strings", "1", "a0", "0", "928385", "a1", "0", "068093", "a2", "0", "0157738", "a3", "0", "0016606", "a4", "6", "93e", "05", "b0", "1", "b1", "0", "002438", "b2", "0", "0003103", "b3", "0", "00001246", "b4", "2", "11e", "07", "b5", "1", "36e", "09", "c0", "1", "01284", "c1", "0", "0128398", "c2", "0", "279317", "c3", "7", "24463", "c4", "0", "996446", "c5", "0", "003554", "c6", "1", "15535", "c7", "0", "155353", "isco", "5", "09115", "impo", "4", "54629", "voco", "59", "2608", "vmpo", "48", "3156", "aisc", "0", "000397", "aimp", "0", "000181", "bvoco", "0", "21696", "mbvoc", "0", "0", "bvmpo", "0", "235488", "mbvmp", "0", "0", "n", "1", "4032", "ixo", "4", "97599", "ixxo", "3", "18803", "fd", "1", "return", "parameters"], "doc_len": 147}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_pres2alt", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_pres2alt", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_pres2alt():\n    out = atmosphere.pres2alt(np.array([10000, 90000, 101325]))\n    expected = np.array([15797.638, 988.637, 0.124])\n    assert_allclose(out, expected, atol=0.001)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_pres2alt", "out", "atmosphere", "pres2alt", "np", "array", "10000", "90000", "101325", "expected", "np", "array", "15797", "638", "988", "637", "0", "124", "assert_allclose", "out", "expected", "atol", "0", "001"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_alt2pres", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_alt2pres", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_alt2pres():\n    out = atmosphere.alt2pres(np.array([-100, 0, 1000, 8000]))\n    expected = np.array([102532.073, 101324.999,  89874.750,  35600.496])\n    assert_allclose(out, expected, atol=0.001)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_alt2pres", "out", "atmosphere", "alt2pres", "np", "array", "100", "0", "1000", "8000", "expected", "np", "array", "102532", "073", "101324", "999", "89874", "750", "35600", "496", "assert_allclose", "out", "expected", "atol", "0", "001"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_atmosphere.py::zeniths", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "zeniths", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef zeniths():\n    return np.array([100, 89.9, 80, 0])\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "zeniths", "return", "np", "array", "100", "89", "9", "80", "0"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_airmass", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_airmass", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_airmass(model, expected, zeniths):\n    out = atmosphere.get_relative_airmass(zeniths, model)\n    expected = np.array(expected)\n    assert_allclose(out, expected, equal_nan=True, atol=0.001)\n    # test series in/out. index does not matter\n    # hits the isinstance() block in get_relative_airmass\n    times = pd.date_range(start='20180101', periods=len(zeniths), freq='1s')\n    zeniths = pd.Series(zeniths, index=times)\n    expected = pd.Series(expected, index=times)\n    out = atmosphere.get_relative_airmass(zeniths, model)\n    assert_series_equal(out, expected, check_less_precise=True)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_airmass", "model", "expected", "zeniths", "out", "atmosphere", "get_relative_airmass", "zeniths", "model", "expected", "np", "array", "expected", "assert_allclose", "out", "expected", "equal_nan", "true", "atol", "0", "001", "test", "series", "in", "out", "index", "does", "not", "matter", "hits", "the", "isinstance", "block", "in", "get_relative_airmass", "times", "pd", "date_range", "start", "20180101", "periods", "len", "zeniths", "freq", "1s", "zeniths", "pd", "series", "zeniths", "index", "times", "expected", "pd", "series", "expected", "index", "times", "out", "atmosphere", "get_relative_airmass", "zeniths", "model", "assert_series_equal", "out", "expected", "check_less_precise", "true"], "doc_len": 72}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_airmass_scalar", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_airmass_scalar", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_airmass_scalar():\n    assert not np.isnan(atmosphere.get_relative_airmass(10))\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_airmass_scalar", "assert", "not", "np", "isnan", "atmosphere", "get_relative_airmass", "10"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_airmass_invalid", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_airmass_invalid", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_airmass_invalid():\n    with pytest.raises(ValueError):\n        atmosphere.get_relative_airmass(0, 'invalid')\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_airmass_invalid", "with", "pytest", "raises", "valueerror", "atmosphere", "get_relative_airmass", "0", "invalid"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_get_absolute_airmass", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_get_absolute_airmass", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_get_absolute_airmass():\n    # input am\n    relative_am = np.array([nan, 40, 2, .999])\n    # call without pressure kwarg\n    out = atmosphere.get_absolute_airmass(relative_am)\n    expected = np.array([nan, 40., 2., 0.999])\n    assert_allclose(out, expected, equal_nan=True, atol=0.001)\n    # call with pressure kwarg\n    out = atmosphere.get_absolute_airmass(relative_am, pressure=90000)\n    expected = np.array([nan, 35.529, 1.776, 0.887])\n    assert_allclose(out, expected, equal_nan=True, atol=0.001)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_get_absolute_airmass", "input", "am", "relative_am", "np", "array", "nan", "40", "2", "999", "call", "without", "pressure", "kwarg", "out", "atmosphere", "get_absolute_airmass", "relative_am", "expected", "np", "array", "nan", "40", "2", "0", "999", "assert_allclose", "out", "expected", "equal_nan", "true", "atol", "0", "001", "call", "with", "pressure", "kwarg", "out", "atmosphere", "get_absolute_airmass", "relative_am", "pressure", "90000", "expected", "np", "array", "nan", "35", "529", "1", "776", "0", "887", "assert_allclose", "out", "expected", "equal_nan", "true", "atol", "0", "001"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_gueymard94_pw", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_gueymard94_pw", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_gueymard94_pw():\n    temp_air = np.array([0, 20, 40])\n    relative_humidity = np.array([0, 30, 100])\n    temps_humids = np.array(\n        list(itertools.product(temp_air, relative_humidity)))\n    pws = atmosphere.gueymard94_pw(temps_humids[:, 0], temps_humids[:, 1])\n\n    expected = np.array(\n        [  0.1       ,   0.33702061,   1.12340202,   0.1       ,\n         1.12040963,   3.73469877,   0.1       ,   3.44859767,  11.49532557])\n\n    assert_allclose(pws, expected, atol=0.01)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_gueymard94_pw", "temp_air", "np", "array", "0", "20", "40", "relative_humidity", "np", "array", "0", "30", "100", "temps_humids", "np", "array", "list", "itertools", "product", "temp_air", "relative_humidity", "pws", "atmosphere", "gueymard94_pw", "temps_humids", "0", "temps_humids", "1", "expected", "np", "array", "0", "1", "0", "33702061", "1", "12340202", "0", "1", "1", "12040963", "3", "73469877", "0", "1", "3", "44859767", "11", "49532557", "assert_allclose", "pws", "expected", "atol", "0", "01"], "doc_len": 60}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_first_solar_spectral_correction", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_first_solar_spectral_correction", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_first_solar_spectral_correction(module_type, expect):\n    ams = np.array([1, 3, 5])\n    pws = np.array([1, 3, 5])\n    ams, pws = np.meshgrid(ams, pws)\n    out = atmosphere.first_solar_spectral_correction(pws, ams, module_type)\n    assert_allclose(out, expect, atol=0.001)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_first_solar_spectral_correction", "module_type", "expect", "ams", "np", "array", "1", "3", "5", "pws", "np", "array", "1", "3", "5", "ams", "pws", "np", "meshgrid", "ams", "pws", "out", "atmosphere", "first_solar_spectral_correction", "pws", "ams", "module_type", "assert_allclose", "out", "expect", "atol", "0", "001"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_first_solar_spectral_correction_supplied", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_first_solar_spectral_correction_supplied", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_first_solar_spectral_correction_supplied():\n    # use the cdte coeffs\n    coeffs = (0.87102, -0.040543, -0.00929202, 0.10052, 0.073062, -0.0034187)\n    out = atmosphere.first_solar_spectral_correction(1, 1, coefficients=coeffs)\n    expected = 0.99134828\n    assert_allclose(out, expected, atol=1e-3)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_first_solar_spectral_correction_supplied", "use", "the", "cdte", "coeffs", "coeffs", "0", "87102", "0", "040543", "0", "00929202", "0", "10052", "0", "073062", "0", "0034187", "out", "atmosphere", "first_solar_spectral_correction", "1", "1", "coefficients", "coeffs", "expected", "0", "99134828", "assert_allclose", "out", "expected", "atol", "1e", "3"], "doc_len": 39}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_first_solar_spectral_correction_ambiguous", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_first_solar_spectral_correction_ambiguous", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_first_solar_spectral_correction_ambiguous():\n    with pytest.raises(TypeError):\n        atmosphere.first_solar_spectral_correction(1, 1)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_first_solar_spectral_correction_ambiguous", "with", "pytest", "raises", "typeerror", "atmosphere", "first_solar_spectral_correction", "1", "1"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_first_solar_spectral_correction_range", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_first_solar_spectral_correction_range", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_first_solar_spectral_correction_range():\n    with pytest.warns(UserWarning, match='Exceptionally high pw values'):\n        out = atmosphere.first_solar_spectral_correction(np.array([.1, 3, 10]),\n                                                         np.array([1, 3, 5]),\n                                                         module_type='monosi')\n    expected = np.array([0.96080878, 1.03055092,        nan])\n    assert_allclose(out, expected, atol=1e-3)\n    with pytest.warns(UserWarning, match='Exceptionally high pw values'):\n        out = atmosphere.first_solar_spectral_correction(6, 1.5, max_pw=5,\n                                                         module_type='monosi')\n    with pytest.warns(UserWarning, match='Exceptionally low pw values'):\n        out = atmosphere.first_solar_spectral_correction(np.array([0, 3, 8]),\n                                                         np.array([1, 3, 5]),\n                                                         module_type='monosi')\n    expected = np.array([0.96080878, 1.03055092, 1.04932727])\n    assert_allclose(out, expected, atol=1e-3)\n    with pytest.warns(UserWarning, match='Exceptionally low pw values'):\n        out = atmosphere.first_solar_spectral_correction(0.2, 1.5, min_pw=1,\n                                                         module_type='monosi')\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_first_solar_spectral_correction_range", "with", "pytest", "warns", "userwarning", "match", "exceptionally", "high", "pw", "values", "out", "atmosphere", "first_solar_spectral_correction", "np", "array", "1", "3", "10", "np", "array", "1", "3", "5", "module_type", "monosi", "expected", "np", "array", "0", "96080878", "1", "03055092", "nan", "assert_allclose", "out", "expected", "atol", "1e", "3", "with", "pytest", "warns", "userwarning", "match", "exceptionally", "high", "pw", "values", "out", "atmosphere", "first_solar_spectral_correction", "6", "1", "5", "max_pw", "5", "module_type", "monosi", "with", "pytest", "warns", "userwarning", "match", "exceptionally", "low", "pw", "values", "out", "atmosphere", "first_solar_spectral_correction", "np", "array", "0", "3", "8", "np", "array", "1", "3", "5", "module_type", "monosi", "expected", "np", "array", "0", "96080878", "1", "03055092", "1", "04932727", "assert_allclose", "out", "expected", "atol", "1e", "3", "with", "pytest", "warns", "userwarning", "match", "exceptionally", "low", "pw", "values", "out", "atmosphere", "first_solar_spectral_correction", "0", "2", "1", "5", "min_pw", "1", "module_type", "monosi"], "doc_len": 122}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_kasten96_lt", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_kasten96_lt", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_kasten96_lt():\n    \"\"\"Test Linke turbidity factor calculated from AOD, Pwat and AM\"\"\"\n    amp = np.array([1, 3, 5])\n    pwat = np.array([0, 2.5, 5])\n    aod_bb = np.array([0, 0.1, 1])\n    lt_expected = np.array(\n        [[[1.3802, 2.4102, 11.6802],\n          [1.16303976, 2.37303976, 13.26303976],\n          [1.12101907, 2.51101907, 15.02101907]],\n\n         [[2.95546945, 3.98546945, 13.25546945],\n          [2.17435443, 3.38435443, 14.27435443],\n          [1.99821967, 3.38821967, 15.89821967]],\n\n         [[3.37410769, 4.40410769, 13.67410769],\n          [2.44311797, 3.65311797, 14.54311797],\n          [2.23134152, 3.62134152, 16.13134152]]]\n    )\n    lt = atmosphere.kasten96_lt(*np.meshgrid(amp, pwat, aod_bb))\n    assert np.allclose(lt, lt_expected, 1e-3)\n    return lt\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_kasten96_lt", "test", "linke", "turbidity", "factor", "calculated", "from", "aod", "pwat", "and", "am", "amp", "np", "array", "1", "3", "5", "pwat", "np", "array", "0", "2", "5", "5", "aod_bb", "np", "array", "0", "0", "1", "1", "lt_expected", "np", "array", "1", "3802", "2", "4102", "11", "6802", "1", "16303976", "2", "37303976", "13", "26303976", "1", "12101907", "2", "51101907", "15", "02101907", "2", "95546945", "3", "98546945", "13", "25546945", "2", "17435443", "3", "38435443", "14", "27435443", "1", "99821967", "3", "38821967", "15", "89821967", "3", "37410769", "4", "40410769", "13", "67410769", "2", "44311797", "3", "65311797", "14", "54311797", "2", "23134152", "3", "62134152", "16", "13134152", "lt", "atmosphere", "kasten96_lt", "np", "meshgrid", "amp", "pwat", "aod_bb", "assert", "np", "allclose", "lt", "lt_expected", "1e", "3", "return", "lt"], "doc_len": 110}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_angstrom_aod", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_angstrom_aod", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_angstrom_aod():\n    \"\"\"Test Angstrom turbidity model functions.\"\"\"\n    aod550 = 0.15\n    aod1240 = 0.05\n    alpha = atmosphere.angstrom_alpha(aod550, 550, aod1240, 1240)\n    assert np.isclose(alpha, 1.3513924317859232)\n    aod700 = atmosphere.angstrom_aod_at_lambda(aod550, 550, alpha)\n    assert np.isclose(aod700, 0.10828110997681031)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_angstrom_aod", "test", "angstrom", "turbidity", "model", "functions", "aod550", "0", "15", "aod1240", "0", "05", "alpha", "atmosphere", "angstrom_alpha", "aod550", "550", "aod1240", "1240", "assert", "np", "isclose", "alpha", "1", "3513924317859232", "aod700", "atmosphere", "angstrom_aod_at_lambda", "aod550", "550", "alpha", "assert", "np", "isclose", "aod700", "0", "10828110997681031"], "doc_len": 42}
{"doc_id": "pvlib/tests/test_atmosphere.py::test_bird_hulstrom80_aod_bb", "file_path": "pvlib/tests/test_atmosphere.py", "class_name": null, "func_name": "test_bird_hulstrom80_aod_bb", "text": "文件路径: pvlib/tests/test_atmosphere.py\ndef test_bird_hulstrom80_aod_bb():\n    \"\"\"Test Bird_Hulstrom broadband AOD.\"\"\"\n    aod380, aod500 = 0.22072480948195175, 0.1614279181106312\n    bird_hulstrom = atmosphere.bird_hulstrom80_aod_bb(aod380, aod500)\n    assert np.isclose(0.11738229553812768, bird_hulstrom)\n", "tokens": ["pvlib", "tests", "test_atmosphere", "py", "def", "test_bird_hulstrom80_aod_bb", "test", "bird_hulstrom", "broadband", "aod", "aod380", "aod500", "0", "22072480948195175", "0", "1614279181106312", "bird_hulstrom", "atmosphere", "bird_hulstrom80_aod_bb", "aod380", "aod500", "assert", "np", "isclose", "0", "11738229553812768", "bird_hulstrom"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_series", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_series", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_series():\n    times = pd.date_range(start='2014-06-24', end='2014-06-25', freq='3h',\n                          tz='America/Phoenix')\n    apparent_zenith = pd.Series(np.array(\n        [124.0390863, 113.38779941, 82.85457044, 46.0467599, 10.56413562,\n         34.86074109, 72.41687122, 105.69538659, 124.05614124]),\n        index=times)\n    am = pd.Series(np.array(\n        [nan, nan, 6.97935524, 1.32355476, 0.93527685,\n         1.12008114, 3.01614096, nan, nan]),\n        index=times)\n    expected = pd.DataFrame(np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [   0.        ,    0.        ,    0.        ],\n               [  65.49426624,  321.16092181,   25.54562017],\n               [ 704.6968125 ,  888.90147035,   87.73601277],\n               [1044.1230677 ,  953.24925854,  107.03109696],\n               [ 853.02065704,  922.06124712,   96.42909484],\n               [ 251.99427693,  655.44925241,   53.9901349 ],\n               [   0.        ,    0.        ,    0.        ],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['ghi', 'dni', 'dhi'],\n                            index=times)\n\n    out = clearsky.ineichen(apparent_zenith, am, 3)\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_series", "times", "pd", "date_range", "start", "2014", "06", "24", "end", "2014", "06", "25", "freq", "3h", "tz", "america", "phoenix", "apparent_zenith", "pd", "series", "np", "array", "124", "0390863", "113", "38779941", "82", "85457044", "46", "0467599", "10", "56413562", "34", "86074109", "72", "41687122", "105", "69538659", "124", "05614124", "index", "times", "am", "pd", "series", "np", "array", "nan", "nan", "6", "97935524", "1", "32355476", "0", "93527685", "1", "12008114", "3", "01614096", "nan", "nan", "index", "times", "expected", "pd", "dataframe", "np", "array", "0", "0", "0", "0", "0", "0", "65", "49426624", "321", "16092181", "25", "54562017", "704", "6968125", "888", "90147035", "87", "73601277", "1044", "1230677", "953", "24925854", "107", "03109696", "853", "02065704", "922", "06124712", "96", "42909484", "251", "99427693", "655", "44925241", "53", "9901349", "0", "0", "0", "0", "0", "0", "columns", "ghi", "dni", "dhi", "index", "times", "out", "clearsky", "ineichen", "apparent_zenith", "am", "3", "assert_frame_equal", "expected", "out"], "doc_len": 130}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_series_perez_enhancement", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_series_perez_enhancement", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_series_perez_enhancement():\n    times = pd.date_range(start='2014-06-24', end='2014-06-25', freq='3h',\n                          tz='America/Phoenix')\n    apparent_zenith = pd.Series(np.array(\n        [124.0390863, 113.38779941, 82.85457044, 46.0467599, 10.56413562,\n         34.86074109, 72.41687122, 105.69538659, 124.05614124]),\n        index=times)\n    am = pd.Series(np.array(\n        [nan, nan, 6.97935524, 1.32355476, 0.93527685,\n         1.12008114, 3.01614096, nan, nan]),\n        index=times)\n    expected = pd.DataFrame(np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [   0.        ,    0.        ,    0.        ],\n               [  91.1249279 ,  321.16092171,   51.17628184],\n               [ 716.46580547,  888.9014706 ,   99.50500553],\n               [1053.42066073,  953.24925905,  116.3286895 ],\n               [ 863.54692748,  922.06124652,  106.9553658 ],\n               [ 271.06382275,  655.44925213,   73.05968076],\n               [   0.        ,    0.        ,    0.        ],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['ghi', 'dni', 'dhi'],\n                            index=times)\n\n    out = clearsky.ineichen(apparent_zenith, am, 3, perez_enhancement=True)\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_series_perez_enhancement", "times", "pd", "date_range", "start", "2014", "06", "24", "end", "2014", "06", "25", "freq", "3h", "tz", "america", "phoenix", "apparent_zenith", "pd", "series", "np", "array", "124", "0390863", "113", "38779941", "82", "85457044", "46", "0467599", "10", "56413562", "34", "86074109", "72", "41687122", "105", "69538659", "124", "05614124", "index", "times", "am", "pd", "series", "np", "array", "nan", "nan", "6", "97935524", "1", "32355476", "0", "93527685", "1", "12008114", "3", "01614096", "nan", "nan", "index", "times", "expected", "pd", "dataframe", "np", "array", "0", "0", "0", "0", "0", "0", "91", "1249279", "321", "16092171", "51", "17628184", "716", "46580547", "888", "9014706", "99", "50500553", "1053", "42066073", "953", "24925905", "116", "3286895", "863", "54692748", "922", "06124652", "106", "9553658", "271", "06382275", "655", "44925213", "73", "05968076", "0", "0", "0", "0", "0", "0", "columns", "ghi", "dni", "dhi", "index", "times", "out", "clearsky", "ineichen", "apparent_zenith", "am", "3", "perez_enhancement", "true", "assert_frame_equal", "expected", "out"], "doc_len": 132}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_scalar_input", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_scalar_input", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_scalar_input():\n    expected = OrderedDict()\n    expected['ghi'] = 1038.159219\n    expected['dni'] = 942.2081860378344\n    expected['dhi'] = 110.26529293612793\n\n    out = clearsky.ineichen(10., 1., 3.)\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_scalar_input", "expected", "ordereddict", "expected", "ghi", "1038", "159219", "expected", "dni", "942", "2081860378344", "expected", "dhi", "110", "26529293612793", "out", "clearsky", "ineichen", "10", "1", "3", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_nans", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_nans", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_nans():\n    length = 4\n\n    apparent_zenith = np.full(length, 10.)\n    apparent_zenith[0] = np.nan\n\n    linke_turbidity = np.full(length, 3.)\n    linke_turbidity[1] = np.nan\n\n    dni_extra = np.full(length, 1370.)\n    dni_extra[2] = np.nan\n\n    airmass_absolute = np.full(length, 1.)\n\n    expected = OrderedDict()\n    expected['ghi'] = np.full(length, np.nan)\n    expected['dni'] = np.full(length, np.nan)\n    expected['dhi'] = np.full(length, np.nan)\n\n    expected['ghi'][length-1] = 1042.72590228\n    expected['dni'][length-1] = 946.35279683\n    expected['dhi'][length-1] = 110.75033088\n\n    out = clearsky.ineichen(apparent_zenith, airmass_absolute,\n                            linke_turbidity, dni_extra=dni_extra)\n\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_nans", "length", "4", "apparent_zenith", "np", "full", "length", "10", "apparent_zenith", "0", "np", "nan", "linke_turbidity", "np", "full", "length", "3", "linke_turbidity", "1", "np", "nan", "dni_extra", "np", "full", "length", "1370", "dni_extra", "2", "np", "nan", "airmass_absolute", "np", "full", "length", "1", "expected", "ordereddict", "expected", "ghi", "np", "full", "length", "np", "nan", "expected", "dni", "np", "full", "length", "np", "nan", "expected", "dhi", "np", "full", "length", "np", "nan", "expected", "ghi", "length", "1", "1042", "72590228", "expected", "dni", "length", "1", "946", "35279683", "expected", "dhi", "length", "1", "110", "75033088", "out", "clearsky", "ineichen", "apparent_zenith", "airmass_absolute", "linke_turbidity", "dni_extra", "dni_extra", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 100}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_arrays", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_arrays", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_arrays():\n    expected = OrderedDict()\n\n    expected['ghi'] = (np.\n        array([[[1095.77074798, 1054.17449885, 1014.15727338],\n                [ 839.40909243,  807.54451692,  776.88954373],\n                [ 190.27859353,  183.05548067,  176.10656239]],\n\n               [[ 773.49041181,  625.19479557,  505.33080493],\n                [ 592.52803177,  478.92699901,  387.10585505],\n                [ 134.31520045,  108.56393694,   87.74977339]],\n\n               [[ 545.9968869 ,  370.78162375,  251.79449885],\n                [ 418.25788117,  284.03520249,  192.88577665],\n                [  94.81136442,   64.38555328,   43.72365587]]]))\n\n    expected['dni'] = (np.\n        array([[[1014.38807396,  942.20818604,  861.11344424],\n                [1014.38807396,  942.20818604,  861.11344424],\n                [1014.38807396,  942.20818604,  861.11344424]],\n\n               [[ 687.61305142,  419.14891162,  255.50098235],\n                [ 687.61305142,  419.14891162,  255.50098235],\n                [ 687.61305142,  419.14891162,  255.50098235]],\n\n               [[ 458.62196014,  186.46177428,   75.80970012],\n                [ 458.62196014,  186.46177428,   75.80970012],\n                [ 458.62196014,  186.46177428,   75.80970012]]]))\n\n    expected['dhi'] = (np.\n        array([[[ 81.38267402, 111.96631281, 153.04382915],\n                [ 62.3427452 ,  85.77117175, 117.23837487],\n                [ 14.13195304,  19.44274618,  26.57578203]],\n\n               [[ 85.87736039, 206.04588395, 249.82982258],\n                [ 65.78587472, 157.84030442, 191.38074731],\n                [ 14.91244713,  35.77949226,  43.38249342]],\n\n               [[ 87.37492676, 184.31984947, 175.98479873],\n                [ 66.93307711, 141.19719644, 134.81217714],\n                [ 15.17249681,  32.00680597,  30.5594396 ]]]))\n\n    apparent_zenith = np.linspace(0, 80, 3)\n    airmass_absolute = np.linspace(1, 10, 3)\n    linke_turbidity = np.linspace(2, 4, 3)\n\n    apparent_zenith, airmass_absolute, linke_turbidity = \\\n        np.meshgrid(apparent_zenith, airmass_absolute, linke_turbidity)\n\n    out = clearsky.ineichen(apparent_zenith, airmass_absolute, linke_turbidity)\n\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_arrays", "expected", "ordereddict", "expected", "ghi", "np", "array", "1095", "77074798", "1054", "17449885", "1014", "15727338", "839", "40909243", "807", "54451692", "776", "88954373", "190", "27859353", "183", "05548067", "176", "10656239", "773", "49041181", "625", "19479557", "505", "33080493", "592", "52803177", "478", "92699901", "387", "10585505", "134", "31520045", "108", "56393694", "87", "74977339", "545", "9968869", "370", "78162375", "251", "79449885", "418", "25788117", "284", "03520249", "192", "88577665", "94", "81136442", "64", "38555328", "43", "72365587", "expected", "dni", "np", "array", "1014", "38807396", "942", "20818604", "861", "11344424", "1014", "38807396", "942", "20818604", "861", "11344424", "1014", "38807396", "942", "20818604", "861", "11344424", "687", "61305142", "419", "14891162", "255", "50098235", "687", "61305142", "419", "14891162", "255", "50098235", "687", "61305142", "419", "14891162", "255", "50098235", "458", "62196014", "186", "46177428", "75", "80970012", "458", "62196014", "186", "46177428", "75", "80970012", "458", "62196014", "186", "46177428", "75", "80970012", "expected", "dhi", "np", "array", "81", "38267402", "111", "96631281", "153", "04382915", "62", "3427452", "85", "77117175", "117", "23837487", "14", "13195304", "19", "44274618", "26", "57578203", "85", "87736039", "206", "04588395", "249", "82982258", "65", "78587472", "157", "84030442", "191", "38074731", "14", "91244713", "35", "77949226", "43", "38249342", "87", "37492676", "184", "31984947", "175", "98479873", "66", "93307711", "141", "19719644", "134", "81217714", "15", "17249681", "32", "00680597", "30", "5594396", "apparent_zenith", "np", "linspace", "0", "80", "3", "airmass_absolute", "np", "linspace", "1", "10", "3", "linke_turbidity", "np", "linspace", "2", "4", "3", "apparent_zenith", "airmass_absolute", "linke_turbidity", "np", "meshgrid", "apparent_zenith", "airmass_absolute", "linke_turbidity", "out", "clearsky", "ineichen", "apparent_zenith", "airmass_absolute", "linke_turbidity", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 225}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_dni_extra", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_dni_extra", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_dni_extra():\n    expected = pd.DataFrame(\n        np.array([[1042.72590228,  946.35279683,  110.75033088]]),\n        columns=['ghi', 'dni', 'dhi'])\n\n    out = clearsky.ineichen(10, 1, 3, dni_extra=pd.Series(1370))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_dni_extra", "expected", "pd", "dataframe", "np", "array", "1042", "72590228", "946", "35279683", "110", "75033088", "columns", "ghi", "dni", "dhi", "out", "clearsky", "ineichen", "10", "1", "3", "dni_extra", "pd", "series", "1370", "assert_frame_equal", "expected", "out"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_clearsky.py::test_ineichen_altitude", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_ineichen_altitude", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_ineichen_altitude():\n    expected = pd.DataFrame(\n        np.array([[1134.24312405,  994.95377835,  154.40492924]]),\n        columns=['ghi', 'dni', 'dhi'])\n\n    out = clearsky.ineichen(10, 1, 3, altitude=pd.Series(2000))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_ineichen_altitude", "expected", "pd", "dataframe", "np", "array", "1134", "24312405", "994", "95377835", "154", "40492924", "columns", "ghi", "dni", "dhi", "out", "clearsky", "ineichen", "10", "1", "3", "altitude", "pd", "series", "2000", "assert_frame_equal", "expected", "out"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity():\n    times = pd.date_range(start='2014-06-24', end='2014-06-25',\n                          freq='12h', tz='America/Phoenix')\n    # expect same value on 2014-06-24 0000 and 1200, and\n    # diff value on 2014-06-25\n    expected = pd.Series(\n        np.array([3.11803278689, 3.11803278689, 3.13114754098]), index=times\n    )\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity", "times", "pd", "date_range", "start", "2014", "06", "24", "end", "2014", "06", "25", "freq", "12h", "tz", "america", "phoenix", "expect", "same", "value", "on", "2014", "06", "24", "0000", "and", "1200", "and", "diff", "value", "on", "2014", "06", "25", "expected", "pd", "series", "np", "array", "3", "11803278689", "3", "11803278689", "3", "13114754098", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "assert_series_equal", "expected", "out"], "doc_len": 63}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity_leapyear", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity_leapyear", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity_leapyear():\n    times = pd.date_range(start='2016-06-24', end='2016-06-25',\n                          freq='12h', tz='America/Phoenix')\n    # expect same value on 2016-06-24 0000 and 1200, and\n    # diff value on 2016-06-25\n    expected = pd.Series(\n        np.array([3.11803278689, 3.11803278689, 3.13114754098]), index=times\n    )\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity_leapyear", "times", "pd", "date_range", "start", "2016", "06", "24", "end", "2016", "06", "25", "freq", "12h", "tz", "america", "phoenix", "expect", "same", "value", "on", "2016", "06", "24", "0000", "and", "1200", "and", "diff", "value", "on", "2016", "06", "25", "expected", "pd", "series", "np", "array", "3", "11803278689", "3", "11803278689", "3", "13114754098", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "assert_series_equal", "expected", "out"], "doc_len": 63}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity_nointerp", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity_nointerp", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity_nointerp():\n    times = pd.date_range(start='2014-06-24', end='2014-06-25',\n                          freq='12h', tz='America/Phoenix')\n    # expect same value for all days\n    expected = pd.Series(np.array([3., 3., 3.]), index=times)\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875,\n                                          interp_turbidity=False)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity_nointerp", "times", "pd", "date_range", "start", "2014", "06", "24", "end", "2014", "06", "25", "freq", "12h", "tz", "america", "phoenix", "expect", "same", "value", "for", "all", "days", "expected", "pd", "series", "np", "array", "3", "3", "3", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "interp_turbidity", "false", "assert_series_equal", "expected", "out"], "doc_len": 51}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity_months", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity_months", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity_months():\n    times = pd.date_range(start='2014-04-01', end='2014-07-01',\n                          freq='1M', tz='America/Phoenix')\n    expected = pd.Series(\n        np.array([2.89918032787, 2.97540983607, 3.19672131148]), index=times\n    )\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity_months", "times", "pd", "date_range", "start", "2014", "04", "01", "end", "2014", "07", "01", "freq", "1m", "tz", "america", "phoenix", "expected", "pd", "series", "np", "array", "2", "89918032787", "2", "97540983607", "3", "19672131148", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "assert_series_equal", "expected", "out"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity_months_leapyear", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity_months_leapyear", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity_months_leapyear():\n    times = pd.date_range(start='2016-04-01', end='2016-07-01',\n                          freq='1M', tz='America/Phoenix')\n    expected = pd.Series(\n        np.array([2.89918032787, 2.97540983607, 3.19672131148]), index=times\n    )\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity_months_leapyear", "times", "pd", "date_range", "start", "2016", "04", "01", "end", "2016", "07", "01", "freq", "1m", "tz", "america", "phoenix", "expected", "pd", "series", "np", "array", "2", "89918032787", "2", "97540983607", "3", "19672131148", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "assert_series_equal", "expected", "out"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_clearsky.py::test_lookup_linke_turbidity_nointerp_months", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_lookup_linke_turbidity_nointerp_months", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_lookup_linke_turbidity_nointerp_months():\n    times = pd.date_range(start='2014-04-10', end='2014-07-10',\n                          freq='1M', tz='America/Phoenix')\n    expected = pd.Series(np.array([2.85, 2.95, 3.]), index=times)\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875,\n                                          interp_turbidity=False)\n    assert_series_equal(expected, out)\n    # changing the dates shouldn't matter if interp=False\n    times = pd.date_range(start='2014-04-05', end='2014-07-05',\n                          freq='1M', tz='America/Phoenix')\n    out = clearsky.lookup_linke_turbidity(times, 32.125, -110.875,\n                                          interp_turbidity=False)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_lookup_linke_turbidity_nointerp_months", "times", "pd", "date_range", "start", "2014", "04", "10", "end", "2014", "07", "10", "freq", "1m", "tz", "america", "phoenix", "expected", "pd", "series", "np", "array", "2", "85", "2", "95", "3", "index", "times", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "interp_turbidity", "false", "assert_series_equal", "expected", "out", "changing", "the", "dates", "shouldn", "t", "matter", "if", "interp", "false", "times", "pd", "date_range", "start", "2014", "04", "05", "end", "2014", "07", "05", "freq", "1m", "tz", "america", "phoenix", "out", "clearsky", "lookup_linke_turbidity", "times", "32", "125", "110", "875", "interp_turbidity", "false", "assert_series_equal", "expected", "out"], "doc_len": 85}
{"doc_id": "pvlib/tests/test_clearsky.py::test_haurwitz", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_haurwitz", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_haurwitz():\n    apparent_solar_elevation = np.array([-20, -0.05, -0.001, 5, 10, 30, 50, 90])\n    apparent_solar_zenith = 90 - apparent_solar_elevation\n    data_in = pd.DataFrame(data=apparent_solar_zenith,\n                           index=apparent_solar_zenith,\n                           columns=['apparent_zenith'])\n    expected = pd.DataFrame(np.array([0.,\n                                      0.,\n                                      0.,\n                                      48.6298687941956,\n                                      135.741748091813,\n                                      487.894132885425,\n                                      778.766689344363,\n                                      1035.09203253450]),\n                            columns=['ghi'],\n                            index=apparent_solar_zenith)\n    out = clearsky.haurwitz(data_in['apparent_zenith'])\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_haurwitz", "apparent_solar_elevation", "np", "array", "20", "0", "05", "0", "001", "5", "10", "30", "50", "90", "apparent_solar_zenith", "90", "apparent_solar_elevation", "data_in", "pd", "dataframe", "data", "apparent_solar_zenith", "index", "apparent_solar_zenith", "columns", "apparent_zenith", "expected", "pd", "dataframe", "np", "array", "0", "0", "0", "48", "6298687941956", "135", "741748091813", "487", "894132885425", "778", "766689344363", "1035", "09203253450", "columns", "ghi", "index", "apparent_solar_zenith", "out", "clearsky", "haurwitz", "data_in", "apparent_zenith", "assert_frame_equal", "expected", "out"], "doc_len": 61}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_scalar_elevation", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_scalar_elevation", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_scalar_elevation():\n    expected = OrderedDict()\n    expected['ghi'] = 1064.653145\n    expected['dni'] = 959.335463\n    expected['dhi'] = 129.125602\n\n    out = clearsky.simplified_solis(80)\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_scalar_elevation", "expected", "ordereddict", "expected", "ghi", "1064", "653145", "expected", "dni", "959", "335463", "expected", "dhi", "129", "125602", "out", "clearsky", "simplified_solis", "80", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_scalar_neg_elevation", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_scalar_neg_elevation", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_scalar_neg_elevation():\n    expected = OrderedDict()\n    expected['ghi'] = 0\n    expected['dni'] = 0\n    expected['dhi'] = 0\n\n    out = clearsky.simplified_solis(-10)\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_scalar_neg_elevation", "expected", "ordereddict", "expected", "ghi", "0", "expected", "dni", "0", "expected", "dhi", "0", "out", "clearsky", "simplified_solis", "10", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_series_elevation", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_series_elevation", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_series_elevation():\n    expected = pd.DataFrame(\n        np.array([[959.335463,  1064.653145,  129.125602]]),\n        columns=['dni', 'ghi', 'dhi'])\n    expected = expected[['ghi', 'dni', 'dhi']]\n\n    out = clearsky.simplified_solis(pd.Series(80))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_series_elevation", "expected", "pd", "dataframe", "np", "array", "959", "335463", "1064", "653145", "129", "125602", "columns", "dni", "ghi", "dhi", "expected", "expected", "ghi", "dni", "dhi", "out", "clearsky", "simplified_solis", "pd", "series", "80", "assert_frame_equal", "expected", "out"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_dni_extra", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_dni_extra", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_dni_extra():\n    expected = pd.DataFrame(np.array([[963.555414,  1069.33637,  129.693603]]),\n                            columns=['dni', 'ghi', 'dhi'])\n    expected = expected[['ghi', 'dni', 'dhi']]\n\n    out = clearsky.simplified_solis(80, dni_extra=pd.Series(1370))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_dni_extra", "expected", "pd", "dataframe", "np", "array", "963", "555414", "1069", "33637", "129", "693603", "columns", "dni", "ghi", "dhi", "expected", "expected", "ghi", "dni", "dhi", "out", "clearsky", "simplified_solis", "80", "dni_extra", "pd", "series", "1370", "assert_frame_equal", "expected", "out"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_pressure", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_pressure", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_pressure():\n    expected = pd.DataFrame(np.\n        array([[  964.26930718,  1067.96543669,   127.22841797],\n               [  961.88811874,  1066.36847963,   128.1402539 ],\n               [  959.58112234,  1064.81837558,   129.0304193 ]]),\n                            columns=['dni', 'ghi', 'dhi'])\n    expected = expected[['ghi', 'dni', 'dhi']]\n\n    out = clearsky.simplified_solis(\n        80, pressure=pd.Series([95000, 98000, 101000]))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_pressure", "expected", "pd", "dataframe", "np", "array", "964", "26930718", "1067", "96543669", "127", "22841797", "961", "88811874", "1066", "36847963", "128", "1402539", "959", "58112234", "1064", "81837558", "129", "0304193", "columns", "dni", "ghi", "dhi", "expected", "expected", "ghi", "dni", "dhi", "out", "clearsky", "simplified_solis", "80", "pressure", "pd", "series", "95000", "98000", "101000", "assert_frame_equal", "expected", "out"], "doc_len": 51}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_aod700", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_aod700", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_aod700():\n    expected = pd.DataFrame(np.\n        array([[ 1056.61710493,  1105.7229086 ,    64.41747323],\n               [ 1007.50558875,  1085.74139063,   102.96233698],\n               [  959.3354628 ,  1064.65314509,   129.12560167],\n               [  342.45810926,   638.63409683,    77.71786575],\n               [   55.24140911,     7.5413313 ,     0.        ]]),\n                            columns=['dni', 'ghi', 'dhi'])\n    expected = expected[['ghi', 'dni', 'dhi']]\n\n    aod700 = pd.Series([0.0, 0.05, 0.1, 1, 10])\n    out = clearsky.simplified_solis(80, aod700=aod700)\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_aod700", "expected", "pd", "dataframe", "np", "array", "1056", "61710493", "1105", "7229086", "64", "41747323", "1007", "50558875", "1085", "74139063", "102", "96233698", "959", "3354628", "1064", "65314509", "129", "12560167", "342", "45810926", "638", "63409683", "77", "71786575", "55", "24140911", "7", "5413313", "0", "columns", "dni", "ghi", "dhi", "expected", "expected", "ghi", "dni", "dhi", "aod700", "pd", "series", "0", "0", "0", "05", "0", "1", "1", "10", "out", "clearsky", "simplified_solis", "80", "aod700", "aod700", "assert_frame_equal", "expected", "out"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_precipitable_water", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_precipitable_water", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_precipitable_water():\n    expected = pd.DataFrame(np.\n        array([[ 1001.15353307,  1107.84678941,   128.58887606],\n               [ 1001.15353307,  1107.84678941,   128.58887606],\n               [  983.51027357,  1089.62306672,   129.08755996],\n               [  959.3354628 ,  1064.65314509,   129.12560167],\n               [  872.02335029,   974.18046717,   125.63581346]]),\n                            columns=['dni', 'ghi', 'dhi'])\n    expected = expected[['ghi', 'dni', 'dhi']]\n\n    out = clearsky.simplified_solis(\n        80, precipitable_water=pd.Series([0.0, 0.2, 0.5, 1.0, 5.0]))\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_precipitable_water", "expected", "pd", "dataframe", "np", "array", "1001", "15353307", "1107", "84678941", "128", "58887606", "1001", "15353307", "1107", "84678941", "128", "58887606", "983", "51027357", "1089", "62306672", "129", "08755996", "959", "3354628", "1064", "65314509", "129", "12560167", "872", "02335029", "974", "18046717", "125", "63581346", "columns", "dni", "ghi", "dhi", "expected", "expected", "ghi", "dni", "dhi", "out", "clearsky", "simplified_solis", "80", "precipitable_water", "pd", "series", "0", "0", "0", "2", "0", "5", "1", "0", "5", "0", "assert_frame_equal", "expected", "out"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_small_scalar_pw", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_small_scalar_pw", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_small_scalar_pw():\n\n    expected = OrderedDict()\n    expected['ghi'] = 1107.84678941\n    expected['dni'] = 1001.15353307\n    expected['dhi'] = 128.58887606\n\n    out = clearsky.simplified_solis(80, precipitable_water=0.1)\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_small_scalar_pw", "expected", "ordereddict", "expected", "ghi", "1107", "84678941", "expected", "dni", "1001", "15353307", "expected", "dhi", "128", "58887606", "out", "clearsky", "simplified_solis", "80", "precipitable_water", "0", "1", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_return_arrays", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_return_arrays", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_return_arrays():\n    expected = OrderedDict()\n\n    expected['ghi'] = np.array([[ 1148.40081325,   913.42330823],\n                                [  965.48550828,   760.04527609]])\n\n    expected['dni'] = np.array([[ 1099.25706525,   656.24601381],\n                                [  915.31689149,   530.31697378]])\n\n    expected['dhi'] = np.array([[   64.1063074 ,   254.6186615 ],\n                                [   62.75642216,   232.21931597]])\n\n    aod700 = np.linspace(0, 0.5, 2)\n    precipitable_water = np.linspace(0, 10, 2)\n\n    aod700, precipitable_water = np.meshgrid(aod700, precipitable_water)\n\n    out = clearsky.simplified_solis(80, aod700, precipitable_water)\n\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_return_arrays", "expected", "ordereddict", "expected", "ghi", "np", "array", "1148", "40081325", "913", "42330823", "965", "48550828", "760", "04527609", "expected", "dni", "np", "array", "1099", "25706525", "656", "24601381", "915", "31689149", "530", "31697378", "expected", "dhi", "np", "array", "64", "1063074", "254", "6186615", "62", "75642216", "232", "21931597", "aod700", "np", "linspace", "0", "0", "5", "2", "precipitable_water", "np", "linspace", "0", "10", "2", "aod700", "precipitable_water", "np", "meshgrid", "aod700", "precipitable_water", "out", "clearsky", "simplified_solis", "80", "aod700", "precipitable_water", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_nans_arrays", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_nans_arrays", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_nans_arrays():\n\n    # construct input arrays that each have 1 nan offset from each other,\n    # the last point is valid for all arrays\n\n    length = 6\n\n    apparent_elevation = np.full(length, 80.)\n    apparent_elevation[0] = np.nan\n\n    aod700 = np.full(length, 0.1)\n    aod700[1] = np.nan\n\n    precipitable_water = np.full(length, 0.5)\n    precipitable_water[2] = np.nan\n\n    pressure = np.full(length, 98000.)\n    pressure[3] = np.nan\n\n    dni_extra = np.full(length, 1370.)\n    dni_extra[4] = np.nan\n\n    expected = OrderedDict()\n    expected['ghi'] = np.full(length, np.nan)\n    expected['dni'] = np.full(length, np.nan)\n    expected['dhi'] = np.full(length, np.nan)\n\n    expected['ghi'][length-1] = 1096.022736\n    expected['dni'][length-1] = 990.306854\n    expected['dhi'][length-1] = 128.664594\n\n    out = clearsky.simplified_solis(apparent_elevation, aod700,\n                                    precipitable_water, pressure, dni_extra)\n\n    for k, v in expected.items():\n        assert_allclose(expected[k], out[k])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_nans_arrays", "construct", "input", "arrays", "that", "each", "have", "1", "nan", "offset", "from", "each", "other", "the", "last", "point", "is", "valid", "for", "all", "arrays", "length", "6", "apparent_elevation", "np", "full", "length", "80", "apparent_elevation", "0", "np", "nan", "aod700", "np", "full", "length", "0", "1", "aod700", "1", "np", "nan", "precipitable_water", "np", "full", "length", "0", "5", "precipitable_water", "2", "np", "nan", "pressure", "np", "full", "length", "98000", "pressure", "3", "np", "nan", "dni_extra", "np", "full", "length", "1370", "dni_extra", "4", "np", "nan", "expected", "ordereddict", "expected", "ghi", "np", "full", "length", "np", "nan", "expected", "dni", "np", "full", "length", "np", "nan", "expected", "dhi", "np", "full", "length", "np", "nan", "expected", "ghi", "length", "1", "1096", "022736", "expected", "dni", "length", "1", "990", "306854", "expected", "dhi", "length", "1", "128", "664594", "out", "clearsky", "simplified_solis", "apparent_elevation", "aod700", "precipitable_water", "pressure", "dni_extra", "for", "k", "v", "in", "expected", "items", "assert_allclose", "expected", "k", "out", "k"], "doc_len": 135}
{"doc_id": "pvlib/tests/test_clearsky.py::test_simplified_solis_nans_series", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_simplified_solis_nans_series", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_simplified_solis_nans_series():\n\n    # construct input arrays that each have 1 nan offset from each other,\n    # the last point is valid for all arrays\n\n    length = 6\n\n    apparent_elevation = pd.Series(np.full(length, 80.))\n    apparent_elevation[0] = np.nan\n\n    aod700 = np.full(length, 0.1)\n    aod700[1] = np.nan\n\n    precipitable_water = np.full(length, 0.5)\n    precipitable_water[2] = np.nan\n\n    pressure = np.full(length, 98000.)\n    pressure[3] = np.nan\n\n    dni_extra = np.full(length, 1370.)\n    dni_extra[4] = np.nan\n\n    expected = OrderedDict()\n    expected['ghi'] = np.full(length, np.nan)\n    expected['dni'] = np.full(length, np.nan)\n    expected['dhi'] = np.full(length, np.nan)\n\n    expected['ghi'][length-1] = 1096.022736\n    expected['dni'][length-1] = 990.306854\n    expected['dhi'][length-1] = 128.664594\n\n    expected = pd.DataFrame.from_dict(expected)\n\n    out = clearsky.simplified_solis(apparent_elevation, aod700,\n                                    precipitable_water, pressure, dni_extra)\n\n    assert_frame_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_simplified_solis_nans_series", "construct", "input", "arrays", "that", "each", "have", "1", "nan", "offset", "from", "each", "other", "the", "last", "point", "is", "valid", "for", "all", "arrays", "length", "6", "apparent_elevation", "pd", "series", "np", "full", "length", "80", "apparent_elevation", "0", "np", "nan", "aod700", "np", "full", "length", "0", "1", "aod700", "1", "np", "nan", "precipitable_water", "np", "full", "length", "0", "5", "precipitable_water", "2", "np", "nan", "pressure", "np", "full", "length", "98000", "pressure", "3", "np", "nan", "dni_extra", "np", "full", "length", "1370", "dni_extra", "4", "np", "nan", "expected", "ordereddict", "expected", "ghi", "np", "full", "length", "np", "nan", "expected", "dni", "np", "full", "length", "np", "nan", "expected", "dhi", "np", "full", "length", "np", "nan", "expected", "ghi", "length", "1", "1096", "022736", "expected", "dni", "length", "1", "990", "306854", "expected", "dhi", "length", "1", "128", "664594", "expected", "pd", "dataframe", "from_dict", "expected", "out", "clearsky", "simplified_solis", "apparent_elevation", "aod700", "precipitable_water", "pressure", "dni_extra", "assert_frame_equal", "expected", "out"], "doc_len": 134}
{"doc_id": "pvlib/tests/test_clearsky.py::test_linke_turbidity_corners", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_linke_turbidity_corners", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_linke_turbidity_corners():\n    \"\"\"Test Linke turbidity corners out of bounds.\"\"\"\n    months = pd.DatetimeIndex('%d/1/2016' % (m + 1) for m in range(12))\n\n    def monthly_lt_nointerp(lat, lon, time=months):\n        \"\"\"monthly Linke turbidity factor without time interpolation\"\"\"\n        return clearsky.lookup_linke_turbidity(\n            time, lat, lon, interp_turbidity=False\n        )\n\n    # Northwest\n    assert np.allclose(\n        monthly_lt_nointerp(90, -180),\n        [1.9, 1.9, 1.9, 2.0, 2.05, 2.05, 2.1, 2.1, 2.0, 1.95, 1.9, 1.9])\n    # Southwest\n    assert np.allclose(\n        monthly_lt_nointerp(-90, -180),\n        [1.35, 1.3, 1.45, 1.35, 1.35, 1.35, 1.35, 1.35, 1.35, 1.4, 1.4, 1.3])\n    # Northeast\n    assert np.allclose(\n        monthly_lt_nointerp(90, 180),\n        [1.9, 1.9, 1.9, 2.0, 2.05, 2.05, 2.1, 2.1, 2.0, 1.95, 1.9, 1.9])\n    # Southeast\n    assert np.allclose(\n        monthly_lt_nointerp(-90, 180),\n        [1.35, 1.7, 1.35, 1.35, 1.35, 1.35, 1.35, 1.35, 1.35, 1.35, 1.35, 1.7])\n    # test out of range exceptions at corners\n    with pytest.raises(IndexError):\n        monthly_lt_nointerp(91, -122)  # exceeds max latitude\n    with pytest.raises(IndexError):\n        monthly_lt_nointerp(38.2, 181)  # exceeds max longitude\n    with pytest.raises(IndexError):\n        monthly_lt_nointerp(-91, -122)  # exceeds min latitude\n    with pytest.raises(IndexError):\n        monthly_lt_nointerp(38.2, -181)  # exceeds min longitude\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_linke_turbidity_corners", "test", "linke", "turbidity", "corners", "out", "of", "bounds", "months", "pd", "datetimeindex", "d", "1", "2016", "m", "1", "for", "m", "in", "range", "12", "def", "monthly_lt_nointerp", "lat", "lon", "time", "months", "monthly", "linke", "turbidity", "factor", "without", "time", "interpolation", "return", "clearsky", "lookup_linke_turbidity", "time", "lat", "lon", "interp_turbidity", "false", "northwest", "assert", "np", "allclose", "monthly_lt_nointerp", "90", "180", "1", "9", "1", "9", "1", "9", "2", "0", "2", "05", "2", "05", "2", "1", "2", "1", "2", "0", "1", "95", "1", "9", "1", "9", "southwest", "assert", "np", "allclose", "monthly_lt_nointerp", "90", "180", "1", "35", "1", "3", "1", "45", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "4", "1", "4", "1", "3", "northeast", "assert", "np", "allclose", "monthly_lt_nointerp", "90", "180", "1", "9", "1", "9", "1", "9", "2", "0", "2", "05", "2", "05", "2", "1", "2", "1", "2", "0", "1", "95", "1", "9", "1", "9", "southeast", "assert", "np", "allclose", "monthly_lt_nointerp", "90", "180", "1", "35", "1", "7", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "35", "1", "7", "test", "out", "of", "range", "exceptions", "at", "corners", "with", "pytest", "raises", "indexerror", "monthly_lt_nointerp", "91", "122", "exceeds", "max", "latitude", "with", "pytest", "raises", "indexerror", "monthly_lt_nointerp", "38", "2", "181", "exceeds", "max", "longitude", "with", "pytest", "raises", "indexerror", "monthly_lt_nointerp", "91", "122", "exceeds", "min", "latitude", "with", "pytest", "raises", "indexerror", "monthly_lt_nointerp", "38", "2", "181", "exceeds", "min", "longitude"], "doc_len": 220}
{"doc_id": "pvlib/tests/test_clearsky.py::detect_clearsky_data", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "detect_clearsky_data", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef detect_clearsky_data():\n    data_file = DATA_DIR / 'detect_clearsky_data.csv'\n    expected = pd.read_csv(\n        data_file, index_col=0, parse_dates=True, comment='#')\n    expected = expected.tz_localize('UTC').tz_convert('Etc/GMT+7')\n    metadata = {}\n    with data_file.open() as f:\n        for line in f:\n            if line.startswith('#'):\n                key, value = line.strip('# \\n').split(':')\n                metadata[key] = float(value)\n            else:\n                break\n    metadata['window_length'] = int(metadata['window_length'])\n    loc = Location(metadata['latitude'], metadata['longitude'],\n                   altitude=metadata['elevation'])\n    # specify turbidity to guard against future lookup changes\n    cs = loc.get_clearsky(expected.index, linke_turbidity=2.658197)\n    return expected, cs\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "detect_clearsky_data", "data_file", "data_dir", "detect_clearsky_data", "csv", "expected", "pd", "read_csv", "data_file", "index_col", "0", "parse_dates", "true", "comment", "expected", "expected", "tz_localize", "utc", "tz_convert", "etc", "gmt", "7", "metadata", "with", "data_file", "open", "as", "f", "for", "line", "in", "f", "if", "line", "startswith", "key", "value", "line", "strip", "n", "split", "metadata", "key", "float", "value", "else", "break", "metadata", "window_length", "int", "metadata", "window_length", "loc", "location", "metadata", "latitude", "metadata", "longitude", "altitude", "metadata", "elevation", "specify", "turbidity", "to", "guard", "against", "future", "lookup", "changes", "cs", "loc", "get_clearsky", "expected", "index", "linke_turbidity", "2", "658197", "return", "expected", "cs"], "doc_len": 85}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi'], times=cs.index, window_length=10)\n    assert_series_equal(expected['Clear or not'], clear_samples,\n                        check_dtype=False, check_names=False)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "times", "cs", "index", "window_length", "10", "assert_series_equal", "expected", "clear", "or", "not", "clear_samples", "check_dtype", "false", "check_names", "false"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_defaults", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_defaults", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_defaults(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi'])\n    assert_series_equal(expected['Clear or not'], clear_samples,\n                        check_dtype=False, check_names=False)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_defaults", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "assert_series_equal", "expected", "clear", "or", "not", "clear_samples", "check_dtype", "false", "check_names", "false"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_components", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_components", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_components(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples, components, alpha = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi'], times=cs.index, window_length=10,\n        return_components=True)\n    assert_series_equal(expected['Clear or not'], clear_samples,\n                        check_dtype=False, check_names=False)\n    assert isinstance(components, OrderedDict)\n    assert np.allclose(alpha, 0.9633903181941296)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_components", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "components", "alpha", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "times", "cs", "index", "window_length", "10", "return_components", "true", "assert_series_equal", "expected", "clear", "or", "not", "clear_samples", "check_dtype", "false", "check_names", "false", "assert", "isinstance", "components", "ordereddict", "assert", "np", "allclose", "alpha", "0", "9633903181941296"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_iterations", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_iterations", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_iterations(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    alpha = 1.0448\n    with pytest.warns(RuntimeWarning):\n        clear_samples = clearsky.detect_clearsky(\n            expected['GHI'], cs['ghi']*alpha, max_iterations=1)\n    assert clear_samples[:'2012-04-01 10:41:00'].all()\n    assert not clear_samples['2012-04-01 10:42:00':].any()  # expected False\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi']*alpha, max_iterations=20)\n    assert_series_equal(expected['Clear or not'], clear_samples,\n                        check_dtype=False, check_names=False)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_iterations", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "alpha", "1", "0448", "with", "pytest", "warns", "runtimewarning", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "alpha", "max_iterations", "1", "assert", "clear_samples", "2012", "04", "01", "10", "41", "00", "all", "assert", "not", "clear_samples", "2012", "04", "01", "10", "42", "00", "any", "expected", "false", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "alpha", "max_iterations", "20", "assert_series_equal", "expected", "clear", "or", "not", "clear_samples", "check_dtype", "false", "check_names", "false"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_kwargs", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_kwargs", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_kwargs(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi'], times=cs.index, window_length=10,\n        mean_diff=1000, max_diff=1000, lower_line_length=-1000,\n        upper_line_length=1000, var_diff=10, slope_dev=1000)\n    assert clear_samples.all()\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_kwargs", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "times", "cs", "index", "window_length", "10", "mean_diff", "1000", "max_diff", "1000", "lower_line_length", "1000", "upper_line_length", "1000", "var_diff", "10", "slope_dev", "1000", "assert", "clear_samples", "all"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_window", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_window", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_window(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'], cs['ghi'], window_length=3)\n    expected = expected['Clear or not'].copy()\n    expected.iloc[-3:] = True\n    assert_series_equal(expected, clear_samples,\n                        check_dtype=False, check_names=False)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_window", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "cs", "ghi", "window_length", "3", "expected", "expected", "clear", "or", "not", "copy", "expected", "iloc", "3", "true", "assert_series_equal", "expected", "clear_samples", "check_dtype", "false", "check_names", "false"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_time_interval", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_time_interval", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_time_interval(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    u = np.arange(0, len(cs), 2)\n    cs2 = cs.iloc[u]\n    expected2 = expected.iloc[u]\n    clear_samples = clearsky.detect_clearsky(\n        expected2['GHI'], cs2['ghi'], window_length=6)\n    assert_series_equal(expected2['Clear or not'], clear_samples,\n                        check_dtype=False, check_names=False)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_time_interval", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "u", "np", "arange", "0", "len", "cs", "2", "cs2", "cs", "iloc", "u", "expected2", "expected", "iloc", "u", "clear_samples", "clearsky", "detect_clearsky", "expected2", "ghi", "cs2", "ghi", "window_length", "6", "assert_series_equal", "expected2", "clear", "or", "not", "clear_samples", "check_dtype", "false", "check_names", "false"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_arrays", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_arrays", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_arrays(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    clear_samples = clearsky.detect_clearsky(\n        expected['GHI'].values, cs['ghi'].values, times=cs.index,\n        window_length=10)\n    assert isinstance(clear_samples, np.ndarray)\n    assert (clear_samples == expected['Clear or not'].values).all()\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_arrays", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "clear_samples", "clearsky", "detect_clearsky", "expected", "ghi", "values", "cs", "ghi", "values", "times", "cs", "index", "window_length", "10", "assert", "isinstance", "clear_samples", "np", "ndarray", "assert", "clear_samples", "expected", "clear", "or", "not", "values", "all"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_irregular_times", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_irregular_times", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_irregular_times(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    times = cs.index.values.copy()\n    times[0] += 10**9\n    times = pd.DatetimeIndex(times)\n    with pytest.raises(NotImplementedError):\n        clearsky.detect_clearsky(expected['GHI'].values, cs['ghi'].values,\n                                 times, 10)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_irregular_times", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "times", "cs", "index", "values", "copy", "times", "0", "10", "9", "times", "pd", "datetimeindex", "times", "with", "pytest", "raises", "notimplementederror", "clearsky", "detect_clearsky", "expected", "ghi", "values", "cs", "ghi", "values", "times", "10"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_clearsky.py::test_detect_clearsky_missing_index", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_detect_clearsky_missing_index", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_detect_clearsky_missing_index(detect_clearsky_data):\n    expected, cs = detect_clearsky_data\n    with pytest.raises(ValueError):\n        clearsky.detect_clearsky(expected['GHI'].values, cs['ghi'].values)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_detect_clearsky_missing_index", "detect_clearsky_data", "expected", "cs", "detect_clearsky_data", "with", "pytest", "raises", "valueerror", "clearsky", "detect_clearsky", "expected", "ghi", "values", "cs", "ghi", "values"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_clearsky.py::detect_clearsky_helper_data", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "detect_clearsky_helper_data", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef detect_clearsky_helper_data():\n    samples_per_window = 3\n    sample_interval = 1\n    x = pd.Series(np.arange(0, 7)**2.)\n    # line length between adjacent points\n    sqt = pd.Series(np.sqrt(np.array([np.nan, 2., 10., 26., 50., 82, 122.])))\n    H = hankel(np.arange(samples_per_window),\n               np.arange(samples_per_window-1, len(sqt)))\n    return x, samples_per_window, sample_interval, H\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "detect_clearsky_helper_data", "samples_per_window", "3", "sample_interval", "1", "x", "pd", "series", "np", "arange", "0", "7", "2", "line", "length", "between", "adjacent", "points", "sqt", "pd", "series", "np", "sqrt", "np", "array", "np", "nan", "2", "10", "26", "50", "82", "122", "h", "hankel", "np", "arange", "samples_per_window", "np", "arange", "samples_per_window", "1", "len", "sqt", "return", "x", "samples_per_window", "sample_interval", "h"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_clearsky.py::test__line_length_windowed", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test__line_length_windowed", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test__line_length_windowed(detect_clearsky_helper_data):\n    x, samples_per_window, sample_interval, H = detect_clearsky_helper_data\n    # sqt is hand-calculated assuming window=3\n    # line length between adjacent points\n    sqt = pd.Series(np.sqrt(np.array([np.nan, 2., 10., 26., 50., 82, 122.])))\n    expected = {}\n    expected['line_length'] = sqt + sqt.shift(-1)\n    result = clearsky._line_length_windowed(\n        x, H, samples_per_window, sample_interval)\n    assert_series_equal(result, expected['line_length'])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test__line_length_windowed", "detect_clearsky_helper_data", "x", "samples_per_window", "sample_interval", "h", "detect_clearsky_helper_data", "sqt", "is", "hand", "calculated", "assuming", "window", "3", "line", "length", "between", "adjacent", "points", "sqt", "pd", "series", "np", "sqrt", "np", "array", "np", "nan", "2", "10", "26", "50", "82", "122", "expected", "expected", "line_length", "sqt", "sqt", "shift", "1", "result", "clearsky", "_line_length_windowed", "x", "h", "samples_per_window", "sample_interval", "assert_series_equal", "result", "expected", "line_length"], "doc_len": 57}
{"doc_id": "pvlib/tests/test_clearsky.py::test__max_diff_windowed", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test__max_diff_windowed", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test__max_diff_windowed(detect_clearsky_helper_data):\n    x, samples_per_window, sample_interval, H = detect_clearsky_helper_data\n    expected = {}\n    expected['max_diff'] = pd.Series(\n        data=[np.nan, 3., 5., 7., 9., 11., np.nan], index=x.index)\n    result = clearsky._max_diff_windowed(x, H, samples_per_window)\n    assert_series_equal(result, expected['max_diff'])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test__max_diff_windowed", "detect_clearsky_helper_data", "x", "samples_per_window", "sample_interval", "h", "detect_clearsky_helper_data", "expected", "expected", "max_diff", "pd", "series", "data", "np", "nan", "3", "5", "7", "9", "11", "np", "nan", "index", "x", "index", "result", "clearsky", "_max_diff_windowed", "x", "h", "samples_per_window", "assert_series_equal", "result", "expected", "max_diff"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_clearsky.py::test__calc_stats", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test__calc_stats", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test__calc_stats(detect_clearsky_helper_data):\n    x, samples_per_window, sample_interval, H = detect_clearsky_helper_data\n    # stats are hand-computed assuming window = 3, sample_interval = 1,\n    # and right-aligned labels\n    mean_x = pd.Series(np.array([np.nan, np.nan, 5, 14, 29, 50, 77]) / 3.)\n    max_x = pd.Series(np.array([np.nan, np.nan, 4, 9, 16, 25, 36]))\n    diff_std = np.array([np.nan, np.nan, np.sqrt(2), np.sqrt(2), np.sqrt(2),\n                         np.sqrt(2), np.sqrt(2)])\n    slope_nstd = diff_std / mean_x\n    slope = x.diff().shift(-1)\n    expected = {}\n    expected['mean'] = mean_x.shift(-1)  # shift to align to center\n    expected['max'] = max_x.shift(-1)\n    # slope between adjacent points\n    expected['slope'] = slope\n    expected['slope_nstd'] = slope_nstd.shift(-1)\n    result = clearsky._calc_stats(\n        x, samples_per_window, sample_interval, H)\n    res_mean, res_max, res_slope_nstd, res_slope = result\n    assert_series_equal(res_mean, expected['mean'])\n    assert_series_equal(res_max, expected['max'])\n    assert_series_equal(res_slope_nstd, expected['slope_nstd'])\n    assert_series_equal(res_slope, expected['slope'])\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test__calc_stats", "detect_clearsky_helper_data", "x", "samples_per_window", "sample_interval", "h", "detect_clearsky_helper_data", "stats", "are", "hand", "computed", "assuming", "window", "3", "sample_interval", "1", "and", "right", "aligned", "labels", "mean_x", "pd", "series", "np", "array", "np", "nan", "np", "nan", "5", "14", "29", "50", "77", "3", "max_x", "pd", "series", "np", "array", "np", "nan", "np", "nan", "4", "9", "16", "25", "36", "diff_std", "np", "array", "np", "nan", "np", "nan", "np", "sqrt", "2", "np", "sqrt", "2", "np", "sqrt", "2", "np", "sqrt", "2", "np", "sqrt", "2", "slope_nstd", "diff_std", "mean_x", "slope", "x", "diff", "shift", "1", "expected", "expected", "mean", "mean_x", "shift", "1", "shift", "to", "align", "to", "center", "expected", "max", "max_x", "shift", "1", "slope", "between", "adjacent", "points", "expected", "slope", "slope", "expected", "slope_nstd", "slope_nstd", "shift", "1", "result", "clearsky", "_calc_stats", "x", "samples_per_window", "sample_interval", "h", "res_mean", "res_max", "res_slope_nstd", "res_slope", "result", "assert_series_equal", "res_mean", "expected", "mean", "assert_series_equal", "res_max", "expected", "max", "assert_series_equal", "res_slope_nstd", "expected", "slope_nstd", "assert_series_equal", "res_slope", "expected", "slope"], "doc_len": 140}
{"doc_id": "pvlib/tests/test_clearsky.py::test_bird", "file_path": "pvlib/tests/test_clearsky.py", "class_name": null, "func_name": "test_bird", "text": "文件路径: pvlib/tests/test_clearsky.py\ndef test_bird():\n    \"\"\"Test Bird/Hulstrom Clearsky Model\"\"\"\n    times = pd.date_range(start='1/1/2015 0:00', end='12/31/2015 23:00',\n                          freq='H')\n    tz = -7  # test timezone\n    gmt_tz = pytz.timezone('Etc/GMT%+d' % -(tz))\n    times = times.tz_localize(gmt_tz)  # set timezone\n    # match test data from BIRD_08_16_2012.xls\n    latitude = 40.\n    longitude = -105.\n    press_mB = 840.\n    o3_cm = 0.3\n    h2o_cm = 1.5\n    aod_500nm = 0.1\n    aod_380nm = 0.15\n    b_a = 0.85\n    alb = 0.2\n    eot = solarposition.equation_of_time_spencer71(times.dayofyear)\n    hour_angle = solarposition.hour_angle(times, longitude, eot) - 0.5 * 15.\n    declination = solarposition.declination_spencer71(times.dayofyear)\n    zenith = solarposition.solar_zenith_analytical(\n        np.deg2rad(latitude), np.deg2rad(hour_angle), declination\n    )\n    zenith = np.rad2deg(zenith)\n    airmass = atmosphere.get_relative_airmass(zenith, model='kasten1966')\n    etr = irradiance.get_extra_radiation(times)\n    # test Bird with time series data\n    field_names = ('dni', 'direct_horizontal', 'ghi', 'dhi')\n    irrads = clearsky.bird(\n        zenith, airmass, aod_380nm, aod_500nm, h2o_cm, o3_cm, press_mB * 100.,\n        etr, b_a, alb\n    )\n    Eb, Ebh, Gh, Dh = (irrads[_] for _ in field_names)\n    data_path = DATA_DIR / 'BIRD_08_16_2012.csv'\n    testdata = pd.read_csv(data_path, usecols=range(1, 26), header=1).dropna()\n    testdata.index = times[1:48]\n    assert np.allclose(testdata['DEC'], np.rad2deg(declination[1:48]))\n    assert np.allclose(testdata['EQT'], eot[1:48], rtol=1e-4)\n    assert np.allclose(testdata['Hour Angle'], hour_angle[1:48])\n    assert np.allclose(testdata['Zenith Ang'], zenith[1:48])\n    dawn = zenith < 88.\n    dusk = testdata['Zenith Ang'] < 88.\n    am = pd.Series(np.where(dawn, airmass, 0.), index=times).fillna(0.0)\n    assert np.allclose(\n        testdata['Air Mass'].where(dusk, 0.), am[1:48], rtol=1e-3\n    )\n    direct_beam = pd.Series(np.where(dawn, Eb, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Direct Beam'].where(dusk, 0.), direct_beam[1:48], rtol=1e-3\n    )\n    direct_horz = pd.Series(np.where(dawn, Ebh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Direct Hz'].where(dusk, 0.), direct_horz[1:48], rtol=1e-3\n    )\n    global_horz = pd.Series(np.where(dawn, Gh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Global Hz'].where(dusk, 0.), global_horz[1:48], rtol=1e-3\n    )\n    diffuse_horz = pd.Series(np.where(dawn, Dh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Dif Hz'].where(dusk, 0.), diffuse_horz[1:48], rtol=1e-3\n    )\n    # repeat test with albedo as a Series\n    alb_series = pd.Series(0.2, index=times)\n    irrads = clearsky.bird(\n        zenith, airmass, aod_380nm, aod_500nm, h2o_cm, o3_cm, press_mB * 100.,\n        etr, b_a, alb_series\n    )\n    Eb, Ebh, Gh, Dh = (irrads[_] for _ in field_names)\n    direct_beam = pd.Series(np.where(dawn, Eb, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Direct Beam'].where(dusk, 0.), direct_beam[1:48], rtol=1e-3\n    )\n    direct_horz = pd.Series(np.where(dawn, Ebh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Direct Hz'].where(dusk, 0.), direct_horz[1:48], rtol=1e-3\n    )\n    global_horz = pd.Series(np.where(dawn, Gh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Global Hz'].where(dusk, 0.), global_horz[1:48], rtol=1e-3\n    )\n    diffuse_horz = pd.Series(np.where(dawn, Dh, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata['Dif Hz'].where(dusk, 0.), diffuse_horz[1:48], rtol=1e-3\n    )\n\n    # test keyword parameters\n    irrads2 = clearsky.bird(\n        zenith, airmass, aod_380nm, aod_500nm, h2o_cm, dni_extra=etr\n    )\n    Eb2, Ebh2, Gh2, Dh2 = (irrads2[_] for _ in field_names)\n    data_path = DATA_DIR / 'BIRD_08_16_2012_patm.csv'\n    testdata2 = pd.read_csv(data_path, usecols=range(1, 26), header=1).dropna()\n    testdata2.index = times[1:48]\n    direct_beam2 = pd.Series(np.where(dawn, Eb2, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata2['Direct Beam'].where(dusk, 0.), direct_beam2[1:48], rtol=1e-3\n    )\n    direct_horz2 = pd.Series(np.where(dawn, Ebh2, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata2['Direct Hz'].where(dusk, 0.), direct_horz2[1:48], rtol=1e-3\n    )\n    global_horz2 = pd.Series(np.where(dawn, Gh2, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata2['Global Hz'].where(dusk, 0.), global_horz2[1:48], rtol=1e-3\n    )\n    diffuse_horz2 = pd.Series(np.where(dawn, Dh2, 0.), index=times).fillna(0.)\n    assert np.allclose(\n        testdata2['Dif Hz'].where(dusk, 0.), diffuse_horz2[1:48], rtol=1e-3\n    )\n    # test scalars just at noon\n    # XXX: calculations start at 12am so noon is at index = 12\n    irrads3 = clearsky.bird(\n        zenith[12], airmass[12], aod_380nm, aod_500nm, h2o_cm, dni_extra=etr[12]\n    )\n    Eb3, Ebh3, Gh3, Dh3 = (irrads3[_] for _ in field_names)\n    # XXX: testdata starts at 1am so noon is at index = 11\n    np.allclose(\n        [Eb3, Ebh3, Gh3, Dh3],\n        testdata2[['Direct Beam', 'Direct Hz', 'Global Hz', 'Dif Hz']].iloc[11],\n        rtol=1e-3)\n    return pd.DataFrame({'Eb': Eb, 'Ebh': Ebh, 'Gh': Gh, 'Dh': Dh}, index=times)\n", "tokens": ["pvlib", "tests", "test_clearsky", "py", "def", "test_bird", "test", "bird", "hulstrom", "clearsky", "model", "times", "pd", "date_range", "start", "1", "1", "2015", "0", "00", "end", "12", "31", "2015", "23", "00", "freq", "h", "tz", "7", "test", "timezone", "gmt_tz", "pytz", "timezone", "etc", "gmt", "d", "tz", "times", "times", "tz_localize", "gmt_tz", "set", "timezone", "match", "test", "data", "from", "bird_08_16_2012", "xls", "latitude", "40", "longitude", "105", "press_mb", "840", "o3_cm", "0", "3", "h2o_cm", "1", "5", "aod_500nm", "0", "1", "aod_380nm", "0", "15", "b_a", "0", "85", "alb", "0", "2", "eot", "solarposition", "equation_of_time_spencer71", "times", "dayofyear", "hour_angle", "solarposition", "hour_angle", "times", "longitude", "eot", "0", "5", "15", "declination", "solarposition", "declination_spencer71", "times", "dayofyear", "zenith", "solarposition", "solar_zenith_analytical", "np", "deg2rad", "latitude", "np", "deg2rad", "hour_angle", "declination", "zenith", "np", "rad2deg", "zenith", "airmass", "atmosphere", "get_relative_airmass", "zenith", "model", "kasten1966", "etr", "irradiance", "get_extra_radiation", "times", "test", "bird", "with", "time", "series", "data", "field_names", "dni", "direct_horizontal", "ghi", "dhi", "irrads", "clearsky", "bird", "zenith", "airmass", "aod_380nm", "aod_500nm", "h2o_cm", "o3_cm", "press_mb", "100", "etr", "b_a", "alb", "eb", "ebh", "gh", "dh", "irrads", "_", "for", "_", "in", "field_names", "data_path", "data_dir", "bird_08_16_2012", "csv", "testdata", "pd", "read_csv", "data_path", "usecols", "range", "1", "26", "header", "1", "dropna", "testdata", "index", "times", "1", "48", "assert", "np", "allclose", "testdata", "dec", "np", "rad2deg", "declination", "1", "48", "assert", "np", "allclose", "testdata", "eqt", "eot", "1", "48", "rtol", "1e", "4", "assert", "np", "allclose", "testdata", "hour", "angle", "hour_angle", "1", "48", "assert", "np", "allclose", "testdata", "zenith", "ang", "zenith", "1", "48", "dawn", "zenith", "88", "dusk", "testdata", "zenith", "ang", "88", "am", "pd", "series", "np", "where", "dawn", "airmass", "0", "index", "times", "fillna", "0", "0", "assert", "np", "allclose", "testdata", "air", "mass", "where", "dusk", "0", "am", "1", "48", "rtol", "1e", "3", "direct_beam", "pd", "series", "np", "where", "dawn", "eb", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "direct", "beam", "where", "dusk", "0", "direct_beam", "1", "48", "rtol", "1e", "3", "direct_horz", "pd", "series", "np", "where", "dawn", "ebh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "direct", "hz", "where", "dusk", "0", "direct_horz", "1", "48", "rtol", "1e", "3", "global_horz", "pd", "series", "np", "where", "dawn", "gh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "global", "hz", "where", "dusk", "0", "global_horz", "1", "48", "rtol", "1e", "3", "diffuse_horz", "pd", "series", "np", "where", "dawn", "dh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "dif", "hz", "where", "dusk", "0", "diffuse_horz", "1", "48", "rtol", "1e", "3", "repeat", "test", "with", "albedo", "as", "a", "series", "alb_series", "pd", "series", "0", "2", "index", "times", "irrads", "clearsky", "bird", "zenith", "airmass", "aod_380nm", "aod_500nm", "h2o_cm", "o3_cm", "press_mb", "100", "etr", "b_a", "alb_series", "eb", "ebh", "gh", "dh", "irrads", "_", "for", "_", "in", "field_names", "direct_beam", "pd", "series", "np", "where", "dawn", "eb", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "direct", "beam", "where", "dusk", "0", "direct_beam", "1", "48", "rtol", "1e", "3", "direct_horz", "pd", "series", "np", "where", "dawn", "ebh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "direct", "hz", "where", "dusk", "0", "direct_horz", "1", "48", "rtol", "1e", "3", "global_horz", "pd", "series", "np", "where", "dawn", "gh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "global", "hz", "where", "dusk", "0", "global_horz", "1", "48", "rtol", "1e", "3", "diffuse_horz", "pd", "series", "np", "where", "dawn", "dh", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata", "dif", "hz", "where", "dusk", "0", "diffuse_horz", "1", "48", "rtol", "1e", "3", "test", "keyword", "parameters", "irrads2", "clearsky", "bird", "zenith", "airmass", "aod_380nm", "aod_500nm", "h2o_cm", "dni_extra", "etr", "eb2", "ebh2", "gh2", "dh2", "irrads2", "_", "for", "_", "in", "field_names", "data_path", "data_dir", "bird_08_16_2012_patm", "csv", "testdata2", "pd", "read_csv", "data_path", "usecols", "range", "1", "26", "header", "1", "dropna", "testdata2", "index", "times", "1", "48", "direct_beam2", "pd", "series", "np", "where", "dawn", "eb2", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata2", "direct", "beam", "where", "dusk", "0", "direct_beam2", "1", "48", "rtol", "1e", "3", "direct_horz2", "pd", "series", "np", "where", "dawn", "ebh2", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata2", "direct", "hz", "where", "dusk", "0", "direct_horz2", "1", "48", "rtol", "1e", "3", "global_horz2", "pd", "series", "np", "where", "dawn", "gh2", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata2", "global", "hz", "where", "dusk", "0", "global_horz2", "1", "48", "rtol", "1e", "3", "diffuse_horz2", "pd", "series", "np", "where", "dawn", "dh2", "0", "index", "times", "fillna", "0", "assert", "np", "allclose", "testdata2", "dif", "hz", "where", "dusk", "0", "diffuse_horz2", "1", "48", "rtol", "1e", "3", "test", "scalars", "just", "at", "noon", "xxx", "calculations", "start", "at", "12am", "so", "noon", "is", "at", "index", "12", "irrads3", "clearsky", "bird", "zenith", "12", "airmass", "12", "aod_380nm", "aod_500nm", "h2o_cm", "dni_extra", "etr", "12", "eb3", "ebh3", "gh3", "dh3", "irrads3", "_", "for", "_", "in", "field_names", "xxx", "testdata", "starts", "at", "1am", "so", "noon", "is", "at", "index", "11", "np", "allclose", "eb3", "ebh3", "gh3", "dh3", "testdata2", "direct", "beam", "direct", "hz", "global", "hz", "dif", "hz", "iloc", "11", "rtol", "1e", "3", "return", "pd", "dataframe", "eb", "eb", "ebh", "ebh", "gh", "gh", "dh", "dh", "index", "times"], "doc_len": 736}
{"doc_id": "pvlib/tests/test_conftest.py::test_fail_on_pvlib_version", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "test_fail_on_pvlib_version", "text": "文件路径: pvlib/tests/test_conftest.py\ndef test_fail_on_pvlib_version():\n    pass\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "test_fail_on_pvlib_version", "pass"], "doc_len": 7}
{"doc_id": "pvlib/tests/test_conftest.py::test_fail_on_pvlib_version_pass", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "test_fail_on_pvlib_version_pass", "text": "文件路径: pvlib/tests/test_conftest.py\ndef test_fail_on_pvlib_version_pass():\n    pass\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "test_fail_on_pvlib_version_pass", "pass"], "doc_len": 7}
{"doc_id": "pvlib/tests/test_conftest.py::test_fail_on_pvlib_version_fail_in_test", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "test_fail_on_pvlib_version_fail_in_test", "text": "文件路径: pvlib/tests/test_conftest.py\ndef test_fail_on_pvlib_version_fail_in_test():\n    raise Exception\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "test_fail_on_pvlib_version_fail_in_test", "raise", "exception"], "doc_len": 8}
{"doc_id": "pvlib/tests/test_conftest.py::some_data", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "some_data", "text": "文件路径: pvlib/tests/test_conftest.py\ndef some_data():\n    return \"some data\"\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "some_data", "return", "some", "data"], "doc_len": 9}
{"doc_id": "pvlib/tests/test_conftest.py::alt_func", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "alt_func", "text": "文件路径: pvlib/tests/test_conftest.py\ndef alt_func(*args):\n    return args\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "alt_func", "args", "return", "args"], "doc_len": 9}
{"doc_id": "pvlib/tests/test_conftest.py::test_use_fixture_with_decorator", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "test_use_fixture_with_decorator", "text": "文件路径: pvlib/tests/test_conftest.py\ndef test_use_fixture_with_decorator(some_data):\n    # test that the correct data is returned by the some_data fixture\n    assert some_data == \"some data\"\n    with pytest.warns(pvlibDeprecationWarning):  # test for deprecation warning\n        deprec_func(some_data)\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "test_use_fixture_with_decorator", "some_data", "test", "that", "the", "correct", "data", "is", "returned", "by", "the", "some_data", "fixture", "assert", "some_data", "some", "data", "with", "pytest", "warns", "pvlibdeprecationwarning", "test", "for", "deprecation", "warning", "deprec_func", "some_data"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_conftest.py::test__check_pandas_assert_kwargs", "file_path": "pvlib/tests/test_conftest.py", "class_name": null, "func_name": "test__check_pandas_assert_kwargs", "text": "文件路径: pvlib/tests/test_conftest.py\ndef test__check_pandas_assert_kwargs(mocker, function_name, pd_version,\n                                     check_less_precise):\n    # test that conftest._check_pandas_assert_kwargs returns appropriate\n    # kwargs for the assert_x_equal functions\n\n    # NOTE: be careful about mixing mocker.patch and pytest.MonkeyPatch!\n    # they do not coordinate their cleanups, so it is safest to only\n    # use one or the other.  GH #1447\n\n    # patch the pandas assert; not interested in actually calling them,\n    # plus we want to spy on how they get called.\n    spy = mocker.patch('pandas.testing.' + function_name)\n    # patch pd.__version__ to exercise the two branches in\n    # conftest._check_pandas_assert_kwargs\n    mocker.patch('pandas.__version__', new=pd_version)\n\n    # finally, run the function and check what args got passed to pandas:\n    assert_function = getattr(conftest, function_name)\n    args = [None, None]\n    assert_function(*args, check_less_precise=check_less_precise)\n    if pd_version == '1.1.0':\n        tol = 1e-3 if check_less_precise else 1e-5\n        expected_kwargs = {'atol': tol, 'rtol': tol}\n    else:\n        expected_kwargs = {'check_less_precise': check_less_precise}\n\n    spy.assert_called_once_with(*args, **expected_kwargs)\n", "tokens": ["pvlib", "tests", "test_conftest", "py", "def", "test__check_pandas_assert_kwargs", "mocker", "function_name", "pd_version", "check_less_precise", "test", "that", "conftest", "_check_pandas_assert_kwargs", "returns", "appropriate", "kwargs", "for", "the", "assert_x_equal", "functions", "note", "be", "careful", "about", "mixing", "mocker", "patch", "and", "pytest", "monkeypatch", "they", "do", "not", "coordinate", "their", "cleanups", "so", "it", "is", "safest", "to", "only", "use", "one", "or", "the", "other", "gh", "1447", "patch", "the", "pandas", "assert", "not", "interested", "in", "actually", "calling", "them", "plus", "we", "want", "to", "spy", "on", "how", "they", "get", "called", "spy", "mocker", "patch", "pandas", "testing", "function_name", "patch", "pd", "__version__", "to", "exercise", "the", "two", "branches", "in", "conftest", "_check_pandas_assert_kwargs", "mocker", "patch", "pandas", "__version__", "new", "pd_version", "finally", "run", "the", "function", "and", "check", "what", "args", "got", "passed", "to", "pandas", "assert_function", "getattr", "conftest", "function_name", "args", "none", "none", "assert_function", "args", "check_less_precise", "check_less_precise", "if", "pd_version", "1", "1", "0", "tol", "1e", "3", "if", "check_less_precise", "else", "1e", "5", "expected_kwargs", "atol", "tol", "rtol", "tol", "else", "expected_kwargs", "check_less_precise", "check_less_precise", "spy", "assert_called_once_with", "args", "expected_kwargs"], "doc_len": 142}
{"doc_id": "pvlib/tests/test_forecast.py::model", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "model", "text": "文件路径: pvlib/tests/test_forecast.py\ndef model(request):\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = request.param()\n    try:\n        raw_data = amodel.get_data(_latitude, _longitude, _start, _end)\n    except Exception as e:\n        warnings.warn('Exception getting data for {}.\\n'\n                      'latitude, longitude, start, end = {} {} {} {}\\n{}'\n                      .format(amodel, _latitude, _longitude, _start, _end, e))\n        raw_data = pd.DataFrame()  # raw_data.empty will be used later\n    amodel.raw_data = raw_data\n    return amodel\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "model", "request", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "request", "param", "try", "raw_data", "amodel", "get_data", "_latitude", "_longitude", "_start", "_end", "except", "exception", "as", "e", "warnings", "warn", "exception", "getting", "data", "for", "n", "latitude", "longitude", "start", "end", "n", "format", "amodel", "_latitude", "_longitude", "_start", "_end", "e", "raw_data", "pd", "dataframe", "raw_data", "empty", "will", "be", "used", "later", "amodel", "raw_data", "raw_data", "return", "amodel"], "doc_len": 59}
{"doc_id": "pvlib/tests/test_forecast.py::test_process_data", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_process_data", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_process_data(model):\n    for how in ['campbell_norman', 'clearsky_scaling']:\n        if model.raw_data.empty:\n            warnings.warn('Could not test {} process_data with how={} '\n                          'because raw_data was empty'.format(model, how))\n            continue\n        data = model.process_data(model.raw_data, how=how)\n        for variable in _nonnan_variables:\n            try:\n                assert not data[variable].isnull().values.any()\n            except AssertionError:\n                warnings.warn('{}, {}, data contained null values'\n                              .format(model, variable))\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_process_data", "model", "for", "how", "in", "campbell_norman", "clearsky_scaling", "if", "model", "raw_data", "empty", "warnings", "warn", "could", "not", "test", "process_data", "with", "how", "because", "raw_data", "was", "empty", "format", "model", "how", "continue", "data", "model", "process_data", "model", "raw_data", "how", "how", "for", "variable", "in", "_nonnan_variables", "try", "assert", "not", "data", "variable", "isnull", "values", "any", "except", "assertionerror", "warnings", "warn", "data", "contained", "null", "values", "format", "model", "variable"], "doc_len": 62}
{"doc_id": "pvlib/tests/test_forecast.py::test_bad_kwarg_get_data", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_bad_kwarg_get_data", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_bad_kwarg_get_data():\n    # For more information on why you would want to pass an unknown keyword\n    # argument, see Github issue #745.\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = NAM()\n    data = amodel.get_data(_latitude, _longitude, _start, _end,\n                           bad_kwarg=False)\n    assert not data.empty\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_bad_kwarg_get_data", "for", "more", "information", "on", "why", "you", "would", "want", "to", "pass", "an", "unknown", "keyword", "argument", "see", "github", "issue", "745", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "nam", "data", "amodel", "get_data", "_latitude", "_longitude", "_start", "_end", "bad_kwarg", "false", "assert", "not", "data", "empty"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_forecast.py::test_bad_kwarg_get_processed_data", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_bad_kwarg_get_processed_data", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_bad_kwarg_get_processed_data():\n    # For more information on why you would want to pass an unknown keyword\n    # argument, see Github issue #745.\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = NAM()\n    data = amodel.get_processed_data(_latitude, _longitude, _start, _end,\n                                     bad_kwarg=False)\n    assert not data.empty\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_bad_kwarg_get_processed_data", "for", "more", "information", "on", "why", "you", "would", "want", "to", "pass", "an", "unknown", "keyword", "argument", "see", "github", "issue", "745", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "nam", "data", "amodel", "get_processed_data", "_latitude", "_longitude", "_start", "_end", "bad_kwarg", "false", "assert", "not", "data", "empty"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_forecast.py::test_how_kwarg_get_processed_data", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_how_kwarg_get_processed_data", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_how_kwarg_get_processed_data():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = NAM()\n    data = amodel.get_processed_data(_latitude, _longitude, _start, _end,\n                                     how='clearsky_scaling')\n    assert not data.empty\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_how_kwarg_get_processed_data", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "nam", "data", "amodel", "get_processed_data", "_latitude", "_longitude", "_start", "_end", "how", "clearsky_scaling", "assert", "not", "data", "empty"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_forecast.py::test_vert_level", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_vert_level", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_vert_level():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = NAM()\n    vert_level = 5000\n    amodel.get_processed_data(_latitude, _longitude, _start, _end,\n                              vert_level=vert_level)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_vert_level", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "nam", "vert_level", "5000", "amodel", "get_processed_data", "_latitude", "_longitude", "_start", "_end", "vert_level", "vert_level"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_forecast.py::test_datetime", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_datetime", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_datetime():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = NAM()\n    start = datetime.now(tz=timezone.utc)\n    end = start + timedelta(days=1)\n    amodel.get_processed_data(_latitude, _longitude, start, end)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_datetime", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "nam", "start", "datetime", "now", "tz", "timezone", "utc", "end", "start", "timedelta", "days", "1", "amodel", "get_processed_data", "_latitude", "_longitude", "start", "end"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_forecast.py::test_queryvariables", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_queryvariables", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_queryvariables():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    new_variables = ['u-component_of_wind_height_above_ground']\n    data = amodel.get_data(_latitude, _longitude, _start, _end,\n                           query_variables=new_variables)\n    data['u-component_of_wind_height_above_ground']\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_queryvariables", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "new_variables", "u", "component_of_wind_height_above_ground", "data", "amodel", "get_data", "_latitude", "_longitude", "_start", "_end", "query_variables", "new_variables", "data", "u", "component_of_wind_height_above_ground"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_forecast.py::test_latest", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_latest", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_latest():\n    with pytest.warns(pvlibDeprecationWarning):\n        GFS(set_type='latest')\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_latest", "with", "pytest", "warns", "pvlibdeprecationwarning", "gfs", "set_type", "latest"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_forecast.py::test_full", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_full", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_full():\n    with pytest.warns(pvlibDeprecationWarning):\n        GFS(set_type='full')\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_full", "with", "pytest", "warns", "pvlibdeprecationwarning", "gfs", "set_type", "full"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_forecast.py::test_temp_convert", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_temp_convert", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_temp_convert():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    data = pd.DataFrame({'temp_air': [273.15]})\n    data['temp_air'] = amodel.kelvin_to_celsius(data['temp_air'])\n\n    assert_allclose(data['temp_air'].values, 0.0)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_temp_convert", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "data", "pd", "dataframe", "temp_air", "273", "15", "data", "temp_air", "amodel", "kelvin_to_celsius", "data", "temp_air", "assert_allclose", "data", "temp_air", "values", "0", "0"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_forecast.py::test_set_location", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_set_location", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_set_location():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    latitude, longitude = 32.2, -110.9\n    time = 'UTC'\n    amodel.set_location(time, latitude, longitude)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_set_location", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "latitude", "longitude", "32", "2", "110", "9", "time", "utc", "amodel", "set_location", "time", "latitude", "longitude"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_forecast.py::test_set_query_time_range_tzfail", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_set_query_time_range_tzfail", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_set_query_time_range_tzfail():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    with pytest.raises(TypeError):\n        amodel.set_query_time_range(datetime.now(), datetime.now())\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_set_query_time_range_tzfail", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "with", "pytest", "raises", "typeerror", "amodel", "set_query_time_range", "datetime", "now", "datetime", "now"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_forecast.py::test_cloud_cover_to_transmittance_linear", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_cloud_cover_to_transmittance_linear", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_cloud_cover_to_transmittance_linear():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    assert_allclose(amodel.cloud_cover_to_transmittance_linear(0), 0.75)\n    assert_allclose(amodel.cloud_cover_to_transmittance_linear(100), 0.0)\n    assert_allclose(amodel.cloud_cover_to_transmittance_linear(0, 0.5), 0.5)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_cloud_cover_to_transmittance_linear", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "assert_allclose", "amodel", "cloud_cover_to_transmittance_linear", "0", "0", "75", "assert_allclose", "amodel", "cloud_cover_to_transmittance_linear", "100", "0", "0", "assert_allclose", "amodel", "cloud_cover_to_transmittance_linear", "0", "0", "5", "0", "5"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_forecast.py::test_cloud_cover_to_ghi_linear", "file_path": "pvlib/tests/test_forecast.py", "class_name": null, "func_name": "test_cloud_cover_to_ghi_linear", "text": "文件路径: pvlib/tests/test_forecast.py\ndef test_cloud_cover_to_ghi_linear():\n    with pytest.warns(pvlibDeprecationWarning):\n        amodel = GFS()\n    ghi_clear = 1000\n    offset = 25\n    out = amodel.cloud_cover_to_ghi_linear(0, ghi_clear, offset=offset)\n    assert_allclose(out, 1000)\n    out = amodel.cloud_cover_to_ghi_linear(100, ghi_clear, offset=offset)\n    assert_allclose(out, 250)\n", "tokens": ["pvlib", "tests", "test_forecast", "py", "def", "test_cloud_cover_to_ghi_linear", "with", "pytest", "warns", "pvlibdeprecationwarning", "amodel", "gfs", "ghi_clear", "1000", "offset", "25", "out", "amodel", "cloud_cover_to_ghi_linear", "0", "ghi_clear", "offset", "offset", "assert_allclose", "out", "1000", "out", "amodel", "cloud_cover_to_ghi_linear", "100", "ghi_clear", "offset", "offset", "assert_allclose", "out", "250"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_iam.py::test_ashrae", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_ashrae", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_ashrae():\n    thetas = np.array([-90., -67.5, -45., -22.5, 0., 22.5, 45., 67.5, 89., 90.,\n                       np.nan])\n    expected = np.array([0, 0.9193437, 0.97928932, 0.99588039, 1., 0.99588039,\n                         0.97928932, 0.9193437, 0, 0, np.nan])\n    iam = _iam.ashrae(thetas, .05)\n    assert_allclose(iam, expected, equal_nan=True)\n    iam_series = _iam.ashrae(pd.Series(thetas))\n    assert_series_equal(iam_series, pd.Series(expected))\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_ashrae", "thetas", "np", "array", "90", "67", "5", "45", "22", "5", "0", "22", "5", "45", "67", "5", "89", "90", "np", "nan", "expected", "np", "array", "0", "0", "9193437", "0", "97928932", "0", "99588039", "1", "0", "99588039", "0", "97928932", "0", "9193437", "0", "0", "np", "nan", "iam", "_iam", "ashrae", "thetas", "05", "assert_allclose", "iam", "expected", "equal_nan", "true", "iam_series", "_iam", "ashrae", "pd", "series", "thetas", "assert_series_equal", "iam_series", "pd", "series", "expected"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_iam.py::test_ashrae_scalar", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_ashrae_scalar", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_ashrae_scalar():\n    thetas = -45.\n    iam = _iam.ashrae(thetas, .05)\n    expected = 0.97928932\n    assert_allclose(iam, expected, equal_nan=True)\n    thetas = np.nan\n    iam = _iam.ashrae(thetas, .05)\n    expected = np.nan\n    assert_allclose(iam, expected, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_ashrae_scalar", "thetas", "45", "iam", "_iam", "ashrae", "thetas", "05", "expected", "0", "97928932", "assert_allclose", "iam", "expected", "equal_nan", "true", "thetas", "np", "nan", "iam", "_iam", "ashrae", "thetas", "05", "expected", "np", "nan", "assert_allclose", "iam", "expected", "equal_nan", "true"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_iam.py::test_physical", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_physical", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_physical():\n    aoi = np.array([-90., -67.5, -45., -22.5, 0., 22.5, 45., 67.5, 90.,\n                    np.nan])\n    expected = np.array([0, 0.8893998, 0.98797788, 0.99926198, 1, 0.99926198,\n                         0.98797788, 0.8893998, 0, np.nan])\n    iam = _iam.physical(aoi, 1.526, 0.002, 4)\n    assert_allclose(iam, expected, equal_nan=True)\n\n    # GitHub issue 397\n    aoi = pd.Series(aoi)\n    iam = _iam.physical(aoi, 1.526, 0.002, 4)\n    expected = pd.Series(expected)\n    assert_series_equal(iam, expected)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_physical", "aoi", "np", "array", "90", "67", "5", "45", "22", "5", "0", "22", "5", "45", "67", "5", "90", "np", "nan", "expected", "np", "array", "0", "0", "8893998", "0", "98797788", "0", "99926198", "1", "0", "99926198", "0", "98797788", "0", "8893998", "0", "np", "nan", "iam", "_iam", "physical", "aoi", "1", "526", "0", "002", "4", "assert_allclose", "iam", "expected", "equal_nan", "true", "github", "issue", "397", "aoi", "pd", "series", "aoi", "iam", "_iam", "physical", "aoi", "1", "526", "0", "002", "4", "expected", "pd", "series", "expected", "assert_series_equal", "iam", "expected"], "doc_len": 81}
{"doc_id": "pvlib/tests/test_iam.py::test_physical_scalar", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_physical_scalar", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_physical_scalar():\n    aoi = -45.\n    iam = _iam.physical(aoi, 1.526, 0.002, 4)\n    expected = 0.98797788\n    assert_allclose(iam, expected, equal_nan=True)\n    aoi = np.nan\n    iam = _iam.physical(aoi, 1.526, 0.002, 4)\n    expected = np.nan\n    assert_allclose(iam, expected, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_physical_scalar", "aoi", "45", "iam", "_iam", "physical", "aoi", "1", "526", "0", "002", "4", "expected", "0", "98797788", "assert_allclose", "iam", "expected", "equal_nan", "true", "aoi", "np", "nan", "iam", "_iam", "physical", "aoi", "1", "526", "0", "002", "4", "expected", "np", "nan", "assert_allclose", "iam", "expected", "equal_nan", "true"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_iam.py::test_martin_ruiz", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_martin_ruiz", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_martin_ruiz():\n\n    aoi = 45.\n    a_r = 0.16\n    expected = 0.98986965\n\n    # will fail if default values change\n    iam = _iam.martin_ruiz(aoi)\n    assert_allclose(iam, expected)\n\n    # will fail if parameter names change\n    iam = _iam.martin_ruiz(aoi=aoi, a_r=a_r)\n    assert_allclose(iam, expected)\n\n    a_r = 0.18\n    aoi = [-100, -60, 0, 60, 100, np.nan, np.inf]\n    expected = [0.0, 0.9414631, 1.0, 0.9414631, 0.0, np.nan, 0.0]\n\n    # check out of range of inputs as list\n    iam = _iam.martin_ruiz(aoi, a_r)\n    assert_allclose(iam, expected, equal_nan=True)\n\n    # check out of range of inputs as array\n    iam = _iam.martin_ruiz(np.array(aoi), a_r)\n    assert_allclose(iam, expected, equal_nan=True)\n\n    # check out of range of inputs as Series\n    aoi = pd.Series(aoi)\n    expected = pd.Series(expected)\n    iam = _iam.martin_ruiz(aoi, a_r)\n    assert_series_equal(iam, expected)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_martin_ruiz", "aoi", "45", "a_r", "0", "16", "expected", "0", "98986965", "will", "fail", "if", "default", "values", "change", "iam", "_iam", "martin_ruiz", "aoi", "assert_allclose", "iam", "expected", "will", "fail", "if", "parameter", "names", "change", "iam", "_iam", "martin_ruiz", "aoi", "aoi", "a_r", "a_r", "assert_allclose", "iam", "expected", "a_r", "0", "18", "aoi", "100", "60", "0", "60", "100", "np", "nan", "np", "inf", "expected", "0", "0", "0", "9414631", "1", "0", "0", "9414631", "0", "0", "np", "nan", "0", "0", "check", "out", "of", "range", "of", "inputs", "as", "list", "iam", "_iam", "martin_ruiz", "aoi", "a_r", "assert_allclose", "iam", "expected", "equal_nan", "true", "check", "out", "of", "range", "of", "inputs", "as", "array", "iam", "_iam", "martin_ruiz", "np", "array", "aoi", "a_r", "assert_allclose", "iam", "expected", "equal_nan", "true", "check", "out", "of", "range", "of", "inputs", "as", "series", "aoi", "pd", "series", "aoi", "expected", "pd", "series", "expected", "iam", "_iam", "martin_ruiz", "aoi", "a_r", "assert_series_equal", "iam", "expected"], "doc_len": 133}
{"doc_id": "pvlib/tests/test_iam.py::test_martin_ruiz_exception", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_martin_ruiz_exception", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_martin_ruiz_exception():\n\n    with pytest.raises(ValueError):\n        _iam.martin_ruiz(0.0, a_r=0.0)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_martin_ruiz_exception", "with", "pytest", "raises", "valueerror", "_iam", "martin_ruiz", "0", "0", "a_r", "0", "0"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_iam.py::test_martin_ruiz_diffuse", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_martin_ruiz_diffuse", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_martin_ruiz_diffuse():\n\n    surface_tilt = 30.\n    a_r = 0.16\n    expected = (0.9549735, 0.7944426)\n\n    # will fail if default values change\n    iam = _iam.martin_ruiz_diffuse(surface_tilt)\n    assert_allclose(iam, expected)\n\n    # will fail if parameter names change\n    iam = _iam.martin_ruiz_diffuse(surface_tilt=surface_tilt, a_r=a_r)\n    assert_allclose(iam, expected)\n\n    a_r = 0.18\n    surface_tilt = [0, 30, 90, 120, 180, np.nan, np.inf]\n    expected_sky = [0.9407678, 0.9452250, 0.9407678, 0.9055541, 0.0000000,\n                    np.nan, np.nan]\n    expected_gnd = [0.0000000, 0.7610849, 0.9407678, 0.9483508, 0.9407678,\n                    np.nan, np.nan]\n\n    # check various inputs as list\n    iam = _iam.martin_ruiz_diffuse(surface_tilt, a_r)\n    assert_allclose(iam[0], expected_sky, atol=1e-7, equal_nan=True)\n    assert_allclose(iam[1], expected_gnd, atol=1e-7, equal_nan=True)\n\n    # check various inputs as array\n    iam = _iam.martin_ruiz_diffuse(np.array(surface_tilt), a_r)\n    assert_allclose(iam[0], expected_sky, atol=1e-7, equal_nan=True)\n    assert_allclose(iam[1], expected_gnd, atol=1e-7, equal_nan=True)\n\n    # check various inputs as Series\n    surface_tilt = pd.Series(surface_tilt)\n    expected_sky = pd.Series(expected_sky, name='iam_sky')\n    expected_gnd = pd.Series(expected_gnd, name='iam_ground')\n    iam = _iam.martin_ruiz_diffuse(surface_tilt, a_r)\n    assert_series_equal(iam[0], expected_sky)\n    assert_series_equal(iam[1], expected_gnd)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_martin_ruiz_diffuse", "surface_tilt", "30", "a_r", "0", "16", "expected", "0", "9549735", "0", "7944426", "will", "fail", "if", "default", "values", "change", "iam", "_iam", "martin_ruiz_diffuse", "surface_tilt", "assert_allclose", "iam", "expected", "will", "fail", "if", "parameter", "names", "change", "iam", "_iam", "martin_ruiz_diffuse", "surface_tilt", "surface_tilt", "a_r", "a_r", "assert_allclose", "iam", "expected", "a_r", "0", "18", "surface_tilt", "0", "30", "90", "120", "180", "np", "nan", "np", "inf", "expected_sky", "0", "9407678", "0", "9452250", "0", "9407678", "0", "9055541", "0", "0000000", "np", "nan", "np", "nan", "expected_gnd", "0", "0000000", "0", "7610849", "0", "9407678", "0", "9483508", "0", "9407678", "np", "nan", "np", "nan", "check", "various", "inputs", "as", "list", "iam", "_iam", "martin_ruiz_diffuse", "surface_tilt", "a_r", "assert_allclose", "iam", "0", "expected_sky", "atol", "1e", "7", "equal_nan", "true", "assert_allclose", "iam", "1", "expected_gnd", "atol", "1e", "7", "equal_nan", "true", "check", "various", "inputs", "as", "array", "iam", "_iam", "martin_ruiz_diffuse", "np", "array", "surface_tilt", "a_r", "assert_allclose", "iam", "0", "expected_sky", "atol", "1e", "7", "equal_nan", "true", "assert_allclose", "iam", "1", "expected_gnd", "atol", "1e", "7", "equal_nan", "true", "check", "various", "inputs", "as", "series", "surface_tilt", "pd", "series", "surface_tilt", "expected_sky", "pd", "series", "expected_sky", "name", "iam_sky", "expected_gnd", "pd", "series", "expected_gnd", "name", "iam_ground", "iam", "_iam", "martin_ruiz_diffuse", "surface_tilt", "a_r", "assert_series_equal", "iam", "0", "expected_sky", "assert_series_equal", "iam", "1", "expected_gnd"], "doc_len": 180}
{"doc_id": "pvlib/tests/test_iam.py::test_iam_interp", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_iam_interp", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_iam_interp():\n\n    aoi_meas = [0.0, 45.0, 65.0, 75.0]\n    iam_meas = [1.0,  0.9,  0.8,  0.6]\n\n    # simple default linear method\n    aoi = 55.0\n    expected = 0.85\n    iam = _iam.interp(aoi, aoi_meas, iam_meas)\n    assert_allclose(iam, expected)\n\n    # simple non-default method\n    aoi = 55.0\n    expected = 0.8878062\n    iam = _iam.interp(aoi, aoi_meas, iam_meas, method='cubic')\n    assert_allclose(iam, expected)\n\n    # check with all reference values\n    aoi = aoi_meas\n    expected = iam_meas\n    iam = _iam.interp(aoi, aoi_meas, iam_meas)\n    assert_allclose(iam, expected)\n\n    # check normalization and Series\n    aoi = pd.Series(aoi)\n    expected = pd.Series(expected)\n    iam_mult = np.multiply(0.9, iam_meas)\n    iam = _iam.interp(aoi, aoi_meas, iam_mult, normalize=True)\n    assert_series_equal(iam, expected)\n\n    # check beyond reference values\n    aoi = [-45, 0, 45, 85, 90, 95, 100, 105, 110]\n    expected = [0.9, 1.0, 0.9, 0.4, 0.3, 0.2, 0.1, 0.0, 0.0]\n    iam = _iam.interp(aoi, aoi_meas, iam_meas)\n    assert_allclose(iam, expected)\n\n    # check exception clause\n    with pytest.raises(ValueError):\n        _iam.interp(0.0, [0], [1])\n\n    # check exception clause\n    with pytest.raises(ValueError):\n        _iam.interp(0.0, [0, 90], [1, -1])\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_iam_interp", "aoi_meas", "0", "0", "45", "0", "65", "0", "75", "0", "iam_meas", "1", "0", "0", "9", "0", "8", "0", "6", "simple", "default", "linear", "method", "aoi", "55", "0", "expected", "0", "85", "iam", "_iam", "interp", "aoi", "aoi_meas", "iam_meas", "assert_allclose", "iam", "expected", "simple", "non", "default", "method", "aoi", "55", "0", "expected", "0", "8878062", "iam", "_iam", "interp", "aoi", "aoi_meas", "iam_meas", "method", "cubic", "assert_allclose", "iam", "expected", "check", "with", "all", "reference", "values", "aoi", "aoi_meas", "expected", "iam_meas", "iam", "_iam", "interp", "aoi", "aoi_meas", "iam_meas", "assert_allclose", "iam", "expected", "check", "normalization", "and", "series", "aoi", "pd", "series", "aoi", "expected", "pd", "series", "expected", "iam_mult", "np", "multiply", "0", "9", "iam_meas", "iam", "_iam", "interp", "aoi", "aoi_meas", "iam_mult", "normalize", "true", "assert_series_equal", "iam", "expected", "check", "beyond", "reference", "values", "aoi", "45", "0", "45", "85", "90", "95", "100", "105", "110", "expected", "0", "9", "1", "0", "0", "9", "0", "4", "0", "3", "0", "2", "0", "1", "0", "0", "0", "0", "iam", "_iam", "interp", "aoi", "aoi_meas", "iam_meas", "assert_allclose", "iam", "expected", "check", "exception", "clause", "with", "pytest", "raises", "valueerror", "_iam", "interp", "0", "0", "0", "1", "check", "exception", "clause", "with", "pytest", "raises", "valueerror", "_iam", "interp", "0", "0", "0", "90", "1", "1"], "doc_len": 181}
{"doc_id": "pvlib/tests/test_iam.py::test_sapm", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_sapm", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_sapm(sapm_module_params, aoi, expected):\n\n    out = _iam.sapm(aoi, sapm_module_params)\n\n    if isinstance(aoi, pd.Series):\n        assert_series_equal(out, expected, check_less_precise=4)\n    else:\n        assert_allclose(out, expected, atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_sapm", "sapm_module_params", "aoi", "expected", "out", "_iam", "sapm", "aoi", "sapm_module_params", "if", "isinstance", "aoi", "pd", "series", "assert_series_equal", "out", "expected", "check_less_precise", "4", "else", "assert_allclose", "out", "expected", "atol", "1e", "4"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_iam.py::test_sapm_limits", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_sapm_limits", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_sapm_limits():\n    module_parameters = {'B0': 5, 'B1': 0, 'B2': 0, 'B3': 0, 'B4': 0, 'B5': 0}\n    assert _iam.sapm(1, module_parameters) == 5\n\n    module_parameters = {'B0': 5, 'B1': 0, 'B2': 0, 'B3': 0, 'B4': 0, 'B5': 0}\n    assert _iam.sapm(1, module_parameters, upper=1) == 1\n\n    module_parameters = {'B0': -5, 'B1': 0, 'B2': 0, 'B3': 0, 'B4': 0, 'B5': 0}\n    assert _iam.sapm(1, module_parameters) == 0\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_sapm_limits", "module_parameters", "b0", "5", "b1", "0", "b2", "0", "b3", "0", "b4", "0", "b5", "0", "assert", "_iam", "sapm", "1", "module_parameters", "5", "module_parameters", "b0", "5", "b1", "0", "b2", "0", "b3", "0", "b4", "0", "b5", "0", "assert", "_iam", "sapm", "1", "module_parameters", "upper", "1", "1", "module_parameters", "b0", "5", "b1", "0", "b2", "0", "b3", "0", "b4", "0", "b5", "0", "assert", "_iam", "sapm", "1", "module_parameters", "0"], "doc_len": 65}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_diffuse_model", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_diffuse_model", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_diffuse_model(mocker):\n    # 1: return values are correct\n    # 2: the underlying models are called appropriately\n    ashrae_expected = {\n        'sky': 0.9596085829811408,\n        'horizon': 0.8329070417832541,\n        'ground': 0.719823559106309\n    }\n    physical_expected = {\n        'sky': 0.9539178294437575,\n        'horizon': 0.7652650139134007,\n        'ground': 0.6387140117795903\n    }\n    ashrae_spy = mocker.spy(_iam, 'ashrae')\n    physical_spy = mocker.spy(_iam, 'physical')\n\n    ashrae_actual = _iam.marion_diffuse('ashrae', 20)\n    assert ashrae_spy.call_count == 3  # one call for each of the 3 regions\n    assert physical_spy.call_count == 0\n    physical_actual = _iam.marion_diffuse('physical', 20)\n    assert ashrae_spy.call_count == 3\n    assert physical_spy.call_count == 3\n\n    for k, v in ashrae_expected.items():\n        np.testing.assert_allclose(ashrae_actual[k], v)\n\n    for k, v in physical_expected.items():\n        np.testing.assert_allclose(physical_actual[k], v)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_diffuse_model", "mocker", "1", "return", "values", "are", "correct", "2", "the", "underlying", "models", "are", "called", "appropriately", "ashrae_expected", "sky", "0", "9596085829811408", "horizon", "0", "8329070417832541", "ground", "0", "719823559106309", "physical_expected", "sky", "0", "9539178294437575", "horizon", "0", "7652650139134007", "ground", "0", "6387140117795903", "ashrae_spy", "mocker", "spy", "_iam", "ashrae", "physical_spy", "mocker", "spy", "_iam", "physical", "ashrae_actual", "_iam", "marion_diffuse", "ashrae", "20", "assert", "ashrae_spy", "call_count", "3", "one", "call", "for", "each", "of", "the", "3", "regions", "assert", "physical_spy", "call_count", "0", "physical_actual", "_iam", "marion_diffuse", "physical", "20", "assert", "ashrae_spy", "call_count", "3", "assert", "physical_spy", "call_count", "3", "for", "k", "v", "in", "ashrae_expected", "items", "np", "testing", "assert_allclose", "ashrae_actual", "k", "v", "for", "k", "v", "in", "physical_expected", "items", "np", "testing", "assert_allclose", "physical_actual", "k", "v"], "doc_len": 107}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_diffuse_kwargs", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_diffuse_kwargs", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_diffuse_kwargs():\n    # kwargs get passed to underlying model\n    expected = {\n        'sky': 0.967489994422575,\n        'horizon': 0.8647842827418412,\n        'ground': 0.7700443455928433\n    }\n    actual = _iam.marion_diffuse('ashrae', 20, b=0.04)\n\n    for k, v in expected.items():\n        np.testing.assert_allclose(actual[k], v)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_diffuse_kwargs", "kwargs", "get", "passed", "to", "underlying", "model", "expected", "sky", "0", "967489994422575", "horizon", "0", "8647842827418412", "ground", "0", "7700443455928433", "actual", "_iam", "marion_diffuse", "ashrae", "20", "b", "0", "04", "for", "k", "v", "in", "expected", "items", "np", "testing", "assert_allclose", "actual", "k", "v"], "doc_len": 42}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_diffuse_invalid", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_diffuse_invalid", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_diffuse_invalid():\n    with pytest.raises(ValueError):\n        _iam.marion_diffuse('not_a_model', 20)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_diffuse_invalid", "with", "pytest", "raises", "valueerror", "_iam", "marion_diffuse", "not_a_model", "20"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_integrate_scalar", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_integrate_scalar", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_integrate_scalar(region, N, expected):\n    actual = _iam.marion_integrate(_iam.ashrae, 20, region, N)\n    assert_allclose(actual, expected)\n\n    with np.errstate(invalid='ignore'):\n        actual = _iam.marion_integrate(_iam.ashrae, np.nan, region, N)\n    expected = np.nan\n    assert_allclose(actual, expected)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_integrate_scalar", "region", "n", "expected", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "20", "region", "n", "assert_allclose", "actual", "expected", "with", "np", "errstate", "invalid", "ignore", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "np", "nan", "region", "n", "expected", "np", "nan", "assert_allclose", "actual", "expected"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_integrate_list", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_integrate_list", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_integrate_list(region, N, expected):\n    actual = _iam.marion_integrate(_iam.ashrae, [0, 20, 30], region, N)\n    assert_allclose(actual, expected)\n\n    with np.errstate(invalid='ignore'):\n        actual = _iam.marion_integrate(_iam.ashrae, [0, 20, np.nan], region, N)\n    assert_allclose(actual, [expected[0], expected[1], np.nan])\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_integrate_list", "region", "n", "expected", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "0", "20", "30", "region", "n", "assert_allclose", "actual", "expected", "with", "np", "errstate", "invalid", "ignore", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "0", "20", "np", "nan", "region", "n", "assert_allclose", "actual", "expected", "0", "expected", "1", "np", "nan"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_integrate_series", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_integrate_series", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_integrate_series(region, N, expected):\n    idx = pd.date_range('2019-01-01', periods=3, freq='h')\n    tilt = pd.Series([0, 20, 30], index=idx)\n    expected = pd.Series(expected, index=idx)\n    actual = _iam.marion_integrate(_iam.ashrae, tilt, region, N)\n    assert_series_equal(actual, expected)\n\n    tilt.iloc[1] = np.nan\n    expected.iloc[1] = np.nan\n    with np.errstate(invalid='ignore'):\n        actual = _iam.marion_integrate(_iam.ashrae, tilt, region, N)\n    assert_allclose(actual, expected)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_integrate_series", "region", "n", "expected", "idx", "pd", "date_range", "2019", "01", "01", "periods", "3", "freq", "h", "tilt", "pd", "series", "0", "20", "30", "index", "idx", "expected", "pd", "series", "expected", "index", "idx", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "tilt", "region", "n", "assert_series_equal", "actual", "expected", "tilt", "iloc", "1", "np", "nan", "expected", "iloc", "1", "np", "nan", "with", "np", "errstate", "invalid", "ignore", "actual", "_iam", "marion_integrate", "_iam", "ashrae", "tilt", "region", "n", "assert_allclose", "actual", "expected"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_integrate_ground_flat", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_integrate_ground_flat", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_integrate_ground_flat():\n    iam = _iam.marion_integrate(_iam.ashrae, 0, 'horizon', 1800)\n    assert_allclose(iam, 0)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_integrate_ground_flat", "iam", "_iam", "marion_integrate", "_iam", "ashrae", "0", "horizon", "1800", "assert_allclose", "iam", "0"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_iam.py::test_marion_integrate_invalid", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_marion_integrate_invalid", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_marion_integrate_invalid():\n    # check for invalid region string.  this actually gets checked twice,\n    # with the difference being whether `num` is specified or not.\n    with pytest.raises(ValueError):\n        _iam.marion_integrate(_iam.ashrae, 0, 'bad')\n\n    with pytest.raises(ValueError):\n        _iam.marion_integrate(_iam.ashrae, 0, 'bad', 180)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_marion_integrate_invalid", "check", "for", "invalid", "region", "string", "this", "actually", "gets", "checked", "twice", "with", "the", "difference", "being", "whether", "num", "is", "specified", "or", "not", "with", "pytest", "raises", "valueerror", "_iam", "marion_integrate", "_iam", "ashrae", "0", "bad", "with", "pytest", "raises", "valueerror", "_iam", "marion_integrate", "_iam", "ashrae", "0", "bad", "180"], "doc_len": 47}
{"doc_id": "pvlib/tests/test_iam.py::test_schlick", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_schlick", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_schlick():\n    idx = pd.date_range('2019-01-01', freq='h', periods=9)\n    aoi = pd.Series([-180, -135, -90, -45, 0, 45, 90, 135, 180], idx)\n    expected = pd.Series([0, 0, 0, 0.99784451, 1.0, 0.99784451, 0, 0, 0], idx)\n\n    # scalars\n    for aoi_scalar, expected_scalar in zip(aoi, expected):\n        actual = _iam.schlick(aoi_scalar)\n        assert_allclose(expected_scalar, actual)\n\n    # numpy arrays\n    actual = _iam.schlick(aoi.values)\n    assert_allclose(expected.values, actual)\n\n    # pandas Series\n    actual = _iam.schlick(aoi)\n    assert_series_equal(expected, actual)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_schlick", "idx", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "9", "aoi", "pd", "series", "180", "135", "90", "45", "0", "45", "90", "135", "180", "idx", "expected", "pd", "series", "0", "0", "0", "0", "99784451", "1", "0", "0", "99784451", "0", "0", "0", "idx", "scalars", "for", "aoi_scalar", "expected_scalar", "in", "zip", "aoi", "expected", "actual", "_iam", "schlick", "aoi_scalar", "assert_allclose", "expected_scalar", "actual", "numpy", "arrays", "actual", "_iam", "schlick", "aoi", "values", "assert_allclose", "expected", "values", "actual", "pandas", "series", "actual", "_iam", "schlick", "aoi", "assert_series_equal", "expected", "actual"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_iam.py::test_schlick_diffuse", "file_path": "pvlib/tests/test_iam.py", "class_name": null, "func_name": "test_schlick_diffuse", "text": "文件路径: pvlib/tests/test_iam.py\ndef test_schlick_diffuse():\n    surface_tilt = np.array([0, 20, 70, 90])\n    # expected values calculated with marion_integrate and schlick\n    expected_sky = np.array([0.95238092, 0.96249934, 0.96228167, 0.95238094])\n    expected_ground = np.array([0, 0.62693858, 0.93218737, 0.95238094])\n\n    # numpy arrays\n    actual_sky, actual_ground = _iam.schlick_diffuse(surface_tilt)\n    assert_allclose(expected_sky, actual_sky)\n    assert_allclose(expected_ground, actual_ground, rtol=1e-6)\n\n    # scalars\n    for i in range(len(surface_tilt)):\n        actual_sky, actual_ground = _iam.schlick_diffuse(surface_tilt[i])\n        assert_allclose(expected_sky[i], actual_sky)\n        assert_allclose(expected_ground[i], actual_ground, rtol=1e-6)\n\n    # pandas Series\n    idx = pd.date_range('2019-01-01', freq='h', periods=len(surface_tilt))\n    actual_sky, actual_ground = _iam.schlick_diffuse(pd.Series(surface_tilt,\n                                                               idx))\n    assert_series_equal(pd.Series(expected_sky, idx), actual_sky)\n    assert_series_equal(pd.Series(expected_ground, idx), actual_ground,\n                        rtol=1e-6)\n", "tokens": ["pvlib", "tests", "test_iam", "py", "def", "test_schlick_diffuse", "surface_tilt", "np", "array", "0", "20", "70", "90", "expected", "values", "calculated", "with", "marion_integrate", "and", "schlick", "expected_sky", "np", "array", "0", "95238092", "0", "96249934", "0", "96228167", "0", "95238094", "expected_ground", "np", "array", "0", "0", "62693858", "0", "93218737", "0", "95238094", "numpy", "arrays", "actual_sky", "actual_ground", "_iam", "schlick_diffuse", "surface_tilt", "assert_allclose", "expected_sky", "actual_sky", "assert_allclose", "expected_ground", "actual_ground", "rtol", "1e", "6", "scalars", "for", "i", "in", "range", "len", "surface_tilt", "actual_sky", "actual_ground", "_iam", "schlick_diffuse", "surface_tilt", "i", "assert_allclose", "expected_sky", "i", "actual_sky", "assert_allclose", "expected_ground", "i", "actual_ground", "rtol", "1e", "6", "pandas", "series", "idx", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "len", "surface_tilt", "actual_sky", "actual_ground", "_iam", "schlick_diffuse", "pd", "series", "surface_tilt", "idx", "assert_series_equal", "pd", "series", "expected_sky", "idx", "actual_sky", "assert_series_equal", "pd", "series", "expected_ground", "idx", "actual_ground", "rtol", "1e", "6"], "doc_len": 117}
{"doc_id": "pvlib/tests/test_inverter.py::test_adr", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_adr", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_adr(adr_inverter_parameters):\n    vdcs = pd.Series([135, 154, 390, 420, 551])\n    pdcs = pd.Series([135, 1232, 1170, 420, 551])\n\n    pacs = inverter.adr(vdcs, pdcs, adr_inverter_parameters)\n    assert_series_equal(pacs, pd.Series([np.nan, 1161.5745, 1116.4459,\n                                         382.6679, np.nan]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_adr", "adr_inverter_parameters", "vdcs", "pd", "series", "135", "154", "390", "420", "551", "pdcs", "pd", "series", "135", "1232", "1170", "420", "551", "pacs", "inverter", "adr", "vdcs", "pdcs", "adr_inverter_parameters", "assert_series_equal", "pacs", "pd", "series", "np", "nan", "1161", "5745", "1116", "4459", "382", "6679", "np", "nan"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_inverter.py::test_adr_vtol", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_adr_vtol", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_adr_vtol(adr_inverter_parameters):\n    vdcs = pd.Series([135, 154, 390, 420, 551])\n    pdcs = pd.Series([135, 1232, 1170, 420, 551])\n\n    pacs = inverter.adr(vdcs, pdcs, adr_inverter_parameters, vtol=0.20)\n    assert_series_equal(pacs, pd.Series([104.8223, 1161.5745, 1116.4459,\n                                         382.6679, 513.3385]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_adr_vtol", "adr_inverter_parameters", "vdcs", "pd", "series", "135", "154", "390", "420", "551", "pdcs", "pd", "series", "135", "1232", "1170", "420", "551", "pacs", "inverter", "adr", "vdcs", "pdcs", "adr_inverter_parameters", "vtol", "0", "20", "assert_series_equal", "pacs", "pd", "series", "104", "8223", "1161", "5745", "1116", "4459", "382", "6679", "513", "3385"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_inverter.py::test_adr_float", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_adr_float", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_adr_float(adr_inverter_parameters):\n    vdcs = 154.\n    pdcs = 1232.\n\n    pacs = inverter.adr(vdcs, pdcs, adr_inverter_parameters)\n    assert_allclose(pacs, 1161.5745)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_adr_float", "adr_inverter_parameters", "vdcs", "154", "pdcs", "1232", "pacs", "inverter", "adr", "vdcs", "pdcs", "adr_inverter_parameters", "assert_allclose", "pacs", "1161", "5745"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_inverter.py::test_adr_invalid_and_night", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_adr_invalid_and_night", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_adr_invalid_and_night(sam_data):\n    # also tests if inverter.adr can read the output from pvsystem.retrieve_sam\n    inverters = sam_data['adrinverter']\n    testinv = 'Zigor__Sunzet_3_TL_US_240V__CEC_2011_'\n    vdcs = np.array([39.873036, 0., np.nan, 420])\n    pdcs = np.array([188.09182, 0., 420, np.nan])\n\n    pacs = inverter.adr(vdcs, pdcs, inverters[testinv])\n    assert_allclose(pacs, np.array([np.nan, -0.25, np.nan, np.nan]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_adr_invalid_and_night", "sam_data", "also", "tests", "if", "inverter", "adr", "can", "read", "the", "output", "from", "pvsystem", "retrieve_sam", "inverters", "sam_data", "adrinverter", "testinv", "zigor__sunzet_3_tl_us_240v__cec_2011_", "vdcs", "np", "array", "39", "873036", "0", "np", "nan", "420", "pdcs", "np", "array", "188", "09182", "0", "420", "np", "nan", "pacs", "inverter", "adr", "vdcs", "pdcs", "inverters", "testinv", "assert_allclose", "pacs", "np", "array", "np", "nan", "0", "25", "np", "nan", "np", "nan"], "doc_len": 61}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia(cec_inverter_parameters):\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3))\n    pdcs = idcs * vdcs\n\n    pacs = inverter.sandia(vdcs, pdcs, cec_inverter_parameters)\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004308, 250.000000]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia", "vdcs", "pdcs", "cec_inverter_parameters", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004308", "250", "000000"], "doc_len": 42}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia_float", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia_float", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia_float(cec_inverter_parameters):\n    vdcs = 25.\n    idcs = 5.5\n    pdcs = idcs * vdcs\n    pacs = inverter.sandia(vdcs, pdcs, cec_inverter_parameters)\n    assert_allclose(pacs, 132.004278, 5)\n    # test at low power condition\n    vdcs = 25.\n    idcs = 0\n    pdcs = idcs * vdcs\n    pacs = inverter.sandia(vdcs, pdcs, cec_inverter_parameters)\n    assert_allclose(pacs, -1. * cec_inverter_parameters['Pnt'], 5)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia_float", "cec_inverter_parameters", "vdcs", "25", "idcs", "5", "5", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia", "vdcs", "pdcs", "cec_inverter_parameters", "assert_allclose", "pacs", "132", "004278", "5", "test", "at", "low", "power", "condition", "vdcs", "25", "idcs", "0", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia", "vdcs", "pdcs", "cec_inverter_parameters", "assert_allclose", "pacs", "1", "cec_inverter_parameters", "pnt", "5"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia_Pnt_micro", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia_Pnt_micro", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia_Pnt_micro():\n    \"\"\"\n    Test for issue #140, where some microinverters were giving a positive AC\n    power output when the DC power was 0.\n    \"\"\"\n    inverter_parameters = {\n        'Name': 'Enphase Energy: M250-60-2LL-S2x (-ZC) (-NA) 208V [CEC 2013]',\n        'Vac': 208.0,\n        'Paco': 240.0,\n        'Pdco': 250.5311318,\n        'Vdco': 32.06160667,\n        'Pso': 1.12048857,\n        'C0': -5.76E-05,\n        'C1': -6.24E-04,\n        'C2': 8.09E-02,\n        'C3': -0.111781106,\n        'Pnt': 0.043,\n        'Vdcmax': 48.0,\n        'Idcmax': 9.8,\n        'Mppt_low': 27.0,\n        'Mppt_high': 39.0,\n    }\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3))\n    pdcs = idcs * vdcs\n\n    pacs = inverter.sandia(vdcs, pdcs, inverter_parameters)\n    assert_series_equal(pacs, pd.Series([-0.043, 132.545914746, 240.0]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia_pnt_micro", "test", "for", "issue", "140", "where", "some", "microinverters", "were", "giving", "a", "positive", "ac", "power", "output", "when", "the", "dc", "power", "was", "0", "inverter_parameters", "name", "enphase", "energy", "m250", "60", "2ll", "s2x", "zc", "na", "208v", "cec", "2013", "vac", "208", "0", "paco", "240", "0", "pdco", "250", "5311318", "vdco", "32", "06160667", "pso", "1", "12048857", "c0", "5", "76e", "05", "c1", "6", "24e", "04", "c2", "8", "09e", "02", "c3", "0", "111781106", "pnt", "0", "043", "vdcmax", "48", "0", "idcmax", "9", "8", "mppt_low", "27", "0", "mppt_high", "39", "0", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia", "vdcs", "pdcs", "inverter_parameters", "assert_series_equal", "pacs", "pd", "series", "0", "043", "132", "545914746", "240", "0"], "doc_len": 119}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia_multi", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia_multi", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia_multi(cec_inverter_parameters):\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3)) / 2\n    pdcs = idcs * vdcs\n    pacs = inverter.sandia_multi((vdcs, vdcs), (pdcs, pdcs),\n                                 cec_inverter_parameters)\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004278, 250.000000]))\n    # with lists instead of tuples\n    pacs = inverter.sandia_multi([vdcs, vdcs], [pdcs, pdcs],\n                                 cec_inverter_parameters)\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004278, 250.000000]))\n    # with arrays instead of tuples\n    pacs = inverter.sandia_multi(np.array([vdcs, vdcs]),\n                                 np.array([pdcs, pdcs]),\n                                 cec_inverter_parameters)\n    assert_allclose(pacs, np.array([-0.020000, 132.004278, 250.000000]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia_multi", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "2", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia_multi", "vdcs", "vdcs", "pdcs", "pdcs", "cec_inverter_parameters", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004278", "250", "000000", "with", "lists", "instead", "of", "tuples", "pacs", "inverter", "sandia_multi", "vdcs", "vdcs", "pdcs", "pdcs", "cec_inverter_parameters", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004278", "250", "000000", "with", "arrays", "instead", "of", "tuples", "pacs", "inverter", "sandia_multi", "np", "array", "vdcs", "vdcs", "np", "array", "pdcs", "pdcs", "cec_inverter_parameters", "assert_allclose", "pacs", "np", "array", "0", "020000", "132", "004278", "250", "000000"], "doc_len": 95}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia_multi_length_error", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia_multi_length_error", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia_multi_length_error(cec_inverter_parameters):\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3))\n    pdcs = idcs * vdcs\n    with pytest.raises(ValueError, match='p_dc and v_dc have different'):\n        inverter.sandia_multi((vdcs,), (pdcs, pdcs), cec_inverter_parameters)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia_multi_length_error", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "with", "pytest", "raises", "valueerror", "match", "p_dc", "and", "v_dc", "have", "different", "inverter", "sandia_multi", "vdcs", "pdcs", "pdcs", "cec_inverter_parameters"], "doc_len": 42}
{"doc_id": "pvlib/tests/test_inverter.py::test_sandia_multi_array", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_sandia_multi_array", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_sandia_multi_array(cec_inverter_parameters):\n    vdcs = np.linspace(0, 50, 3)\n    idcs = np.linspace(0, 11, 3)\n    pdcs = idcs * vdcs\n    pacs = inverter.sandia_multi((vdcs,), (pdcs,), cec_inverter_parameters)\n    assert_allclose(pacs, np.array([-0.020000, 132.004278, 250.000000]))\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_sandia_multi_array", "cec_inverter_parameters", "vdcs", "np", "linspace", "0", "50", "3", "idcs", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "pacs", "inverter", "sandia_multi", "vdcs", "pdcs", "cec_inverter_parameters", "assert_allclose", "pacs", "np", "array", "0", "020000", "132", "004278", "250", "000000"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_inverter.py::test_pvwatts_scalars", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_pvwatts_scalars", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_pvwatts_scalars():\n    expected = 85.58556604752516\n    out = inverter.pvwatts(90, 100, 0.95)\n    assert_allclose(out, expected)\n    # GH 675\n    expected = 0.\n    out = inverter.pvwatts(0., 100)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_pvwatts_scalars", "expected", "85", "58556604752516", "out", "inverter", "pvwatts", "90", "100", "0", "95", "assert_allclose", "out", "expected", "gh", "675", "expected", "0", "out", "inverter", "pvwatts", "0", "100", "assert_allclose", "out", "expected"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_inverter.py::test_pvwatts_possible_negative", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_pvwatts_possible_negative", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_pvwatts_possible_negative():\n    # pvwatts could return a negative value for (pdc / pdc0) < 0.006\n    # unless it is clipped. see GH 541 for more\n    expected = 0\n    out = inverter.pvwatts(0.001, 1)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_pvwatts_possible_negative", "pvwatts", "could", "return", "a", "negative", "value", "for", "pdc", "pdc0", "0", "006", "unless", "it", "is", "clipped", "see", "gh", "541", "for", "more", "expected", "0", "out", "inverter", "pvwatts", "0", "001", "1", "assert_allclose", "out", "expected"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_inverter.py::test_pvwatts_arrays", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_pvwatts_arrays", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_pvwatts_arrays():\n    pdc = np.array([[np.nan], [0], [50], [100]])\n    pdc0 = 100\n    expected = np.array([[np.nan],\n                         [0.],\n                         [47.60843624],\n                         [95.]])\n    out = inverter.pvwatts(pdc, pdc0, 0.95)\n    assert_allclose(out, expected, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_pvwatts_arrays", "pdc", "np", "array", "np", "nan", "0", "50", "100", "pdc0", "100", "expected", "np", "array", "np", "nan", "0", "47", "60843624", "95", "out", "inverter", "pvwatts", "pdc", "pdc0", "0", "95", "assert_allclose", "out", "expected", "equal_nan", "true"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_inverter.py::test_pvwatts_series", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_pvwatts_series", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_pvwatts_series():\n    pdc = pd.Series([np.nan, 0, 50, 100])\n    pdc0 = 100\n    expected = pd.Series(np.array([np.nan, 0., 47.608436, 95.]))\n    out = inverter.pvwatts(pdc, pdc0, 0.95)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_pvwatts_series", "pdc", "pd", "series", "np", "nan", "0", "50", "100", "pdc0", "100", "expected", "pd", "series", "np", "array", "np", "nan", "0", "47", "608436", "95", "out", "inverter", "pvwatts", "pdc", "pdc0", "0", "95", "assert_series_equal", "expected", "out"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_inverter.py::test_pvwatts_multi", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_pvwatts_multi", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_pvwatts_multi():\n    pdc = np.array([np.nan, 0, 50, 100]) / 2\n    pdc0 = 100\n    expected = np.array([np.nan, 0., 47.608436, 95.])\n    out = inverter.pvwatts_multi((pdc, pdc), pdc0, 0.95)\n    assert_allclose(expected, out)\n    # with 2D array\n    pdc_2d = np.array([pdc, pdc])\n    out = inverter.pvwatts_multi(pdc_2d, pdc0, 0.95)\n    assert_allclose(expected, out)\n    # with Series\n    pdc = pd.Series(pdc)\n    out = inverter.pvwatts_multi((pdc, pdc), pdc0, 0.95)\n    assert_series_equal(pd.Series(expected), out)\n    # with list instead of tuple\n    out = inverter.pvwatts_multi([pdc, pdc], pdc0, 0.95)\n    assert_series_equal(pd.Series(expected), out)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_pvwatts_multi", "pdc", "np", "array", "np", "nan", "0", "50", "100", "2", "pdc0", "100", "expected", "np", "array", "np", "nan", "0", "47", "608436", "95", "out", "inverter", "pvwatts_multi", "pdc", "pdc", "pdc0", "0", "95", "assert_allclose", "expected", "out", "with", "2d", "array", "pdc_2d", "np", "array", "pdc", "pdc", "out", "inverter", "pvwatts_multi", "pdc_2d", "pdc0", "0", "95", "assert_allclose", "expected", "out", "with", "series", "pdc", "pd", "series", "pdc", "out", "inverter", "pvwatts_multi", "pdc", "pdc", "pdc0", "0", "95", "assert_series_equal", "pd", "series", "expected", "out", "with", "list", "instead", "of", "tuple", "out", "inverter", "pvwatts_multi", "pdc", "pdc", "pdc0", "0", "95", "assert_series_equal", "pd", "series", "expected", "out"], "doc_len": 92}
{"doc_id": "pvlib/tests/test_inverter.py::test_fit_sandia", "file_path": "pvlib/tests/test_inverter.py", "class_name": null, "func_name": "test_fit_sandia", "text": "文件路径: pvlib/tests/test_inverter.py\ndef test_fit_sandia(infilen, expected):\n    curves = pd.read_csv(infilen)\n    dc_power = curves['ac_power'] / curves['efficiency']\n    result = inverter.fit_sandia(ac_power=curves['ac_power'],\n                                 dc_power=dc_power,\n                                 dc_voltage=curves['dc_voltage'],\n                                 dc_voltage_level=curves['dc_voltage_level'],\n                                 p_ac_0=expected['Paco'], p_nt=expected['Pnt'])\n    assert expected == pytest.approx(result, rel=1e-3)\n", "tokens": ["pvlib", "tests", "test_inverter", "py", "def", "test_fit_sandia", "infilen", "expected", "curves", "pd", "read_csv", "infilen", "dc_power", "curves", "ac_power", "curves", "efficiency", "result", "inverter", "fit_sandia", "ac_power", "curves", "ac_power", "dc_power", "dc_power", "dc_voltage", "curves", "dc_voltage", "dc_voltage_level", "curves", "dc_voltage_level", "p_ac_0", "expected", "paco", "p_nt", "expected", "pnt", "assert", "expected", "pytest", "approx", "result", "rel", "1e", "3"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_irradiance.py::times", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "times", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef times():\n    # must include night values\n    return pd.date_range(start='20140624', freq='6H', periods=4,\n                         tz='US/Arizona')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "times", "must", "include", "night", "values", "return", "pd", "date_range", "start", "20140624", "freq", "6h", "periods", "4", "tz", "us", "arizona"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_irradiance.py::irrad_data", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "irrad_data", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef irrad_data(times):\n    return pd.DataFrame(np.array(\n        [[0.,    0.,    0.],\n         [79.73860422,  316.1949056,   40.46149818],\n         [1042.48031487,  939.95469881,  118.45831879],\n         [257.20751138,  646.22886049,   62.03376265]]),\n        columns=['ghi', 'dni', 'dhi'], index=times)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "irrad_data", "times", "return", "pd", "dataframe", "np", "array", "0", "0", "0", "79", "73860422", "316", "1949056", "40", "46149818", "1042", "48031487", "939", "95469881", "118", "45831879", "257", "20751138", "646", "22886049", "62", "03376265", "columns", "ghi", "dni", "dhi", "index", "times"], "doc_len": 39}
{"doc_id": "pvlib/tests/test_irradiance.py::ephem_data", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "ephem_data", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef ephem_data(times):\n    return pd.DataFrame(np.array(\n        [[124.0390863, 124.0390863, -34.0390863, -34.0390863,\n          352.69550699,  -2.36677158],\n         [82.85457044,  82.97705621,   7.14542956,   7.02294379,\n          66.71410338,  -2.42072165],\n         [10.56413562,  10.56725766,  79.43586438,  79.43274234,\n          144.76567754,  -2.47457321],\n         [72.41687122,  72.46903556,  17.58312878,  17.53096444,\n          287.04104128,  -2.52831909]]),\n        columns=['apparent_zenith', 'zenith', 'apparent_elevation',\n                 'elevation', 'azimuth', 'equation_of_time'],\n        index=times)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "ephem_data", "times", "return", "pd", "dataframe", "np", "array", "124", "0390863", "124", "0390863", "34", "0390863", "34", "0390863", "352", "69550699", "2", "36677158", "82", "85457044", "82", "97705621", "7", "14542956", "7", "02294379", "66", "71410338", "2", "42072165", "10", "56413562", "10", "56725766", "79", "43586438", "79", "43274234", "144", "76567754", "2", "47457321", "72", "41687122", "72", "46903556", "17", "58312878", "17", "53096444", "287", "04104128", "2", "52831909", "columns", "apparent_zenith", "zenith", "apparent_elevation", "elevation", "azimuth", "equation_of_time", "index", "times"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_irradiance.py::dni_et", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "dni_et", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef dni_et(times):\n    return np.array(\n        [1321.1655834833093, 1321.1655834833093, 1321.1655834833093,\n         1321.1655834833093])\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "dni_et", "times", "return", "np", "array", "1321", "1655834833093", "1321", "1655834833093", "1321", "1655834833093", "1321", "1655834833093"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_irradiance.py::relative_airmass", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "relative_airmass", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef relative_airmass(times):\n    return pd.Series([np.nan, 7.58831596, 1.01688136, 3.27930443], times)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "relative_airmass", "times", "return", "pd", "series", "np", "nan", "7", "58831596", "1", "01688136", "3", "27930443", "times"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_extra_radiation", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_extra_radiation", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_extra_radiation(testval, expected, method):\n    out = irradiance.get_extra_radiation(testval, method=method)\n    assert_allclose(out, expected, atol=10)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_extra_radiation", "testval", "expected", "method", "out", "irradiance", "get_extra_radiation", "testval", "method", "method", "assert_allclose", "out", "expected", "atol", "10"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_extra_radiation_epoch_year", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_extra_radiation_epoch_year", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_extra_radiation_epoch_year():\n    out = irradiance.get_extra_radiation(doy, method='nrel', epoch_year=2012)\n    assert_allclose(out, 1382.4926804890767, atol=0.1)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_extra_radiation_epoch_year", "out", "irradiance", "get_extra_radiation", "doy", "method", "nrel", "epoch_year", "2012", "assert_allclose", "out", "1382", "4926804890767", "atol", "0", "1"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_extra_radiation_nrel_numba", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_extra_radiation_nrel_numba", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_extra_radiation_nrel_numba(times):\n    with warnings.catch_warnings():\n        # don't warn on method reload or num threads\n        warnings.simplefilter(\"ignore\")\n        result = irradiance.get_extra_radiation(\n            times, method='nrel', how='numba', numthreads=4)\n        # and reset to no-numba state\n        irradiance.get_extra_radiation(times, method='nrel')\n    assert_allclose(result,\n                    [1322.332316, 1322.296282, 1322.261205, 1322.227091])\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_extra_radiation_nrel_numba", "times", "with", "warnings", "catch_warnings", "don", "t", "warn", "on", "method", "reload", "or", "num", "threads", "warnings", "simplefilter", "ignore", "result", "irradiance", "get_extra_radiation", "times", "method", "nrel", "how", "numba", "numthreads", "4", "and", "reset", "to", "no", "numba", "state", "irradiance", "get_extra_radiation", "times", "method", "nrel", "assert_allclose", "result", "1322", "332316", "1322", "296282", "1322", "261205", "1322", "227091"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_extra_radiation_invalid", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_extra_radiation_invalid", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_extra_radiation_invalid():\n    with pytest.raises(ValueError):\n        irradiance.get_extra_radiation(300, method='invalid')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_extra_radiation_invalid", "with", "pytest", "raises", "valueerror", "irradiance", "get_extra_radiation", "300", "method", "invalid"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_ground_diffuse_simple_float", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_ground_diffuse_simple_float", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_ground_diffuse_simple_float():\n    result = irradiance.get_ground_diffuse(40, 900)\n    assert_allclose(result, 26.32000014911496)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_ground_diffuse_simple_float", "result", "irradiance", "get_ground_diffuse", "40", "900", "assert_allclose", "result", "26", "32000014911496"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_ground_diffuse_simple_series", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_ground_diffuse_simple_series", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_ground_diffuse_simple_series(irrad_data):\n    ground_irrad = irradiance.get_ground_diffuse(40, irrad_data['ghi'])\n    assert ground_irrad.name == 'diffuse_ground'\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_ground_diffuse_simple_series", "irrad_data", "ground_irrad", "irradiance", "get_ground_diffuse", "40", "irrad_data", "ghi", "assert", "ground_irrad", "name", "diffuse_ground"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_ground_diffuse_albedo_0", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_ground_diffuse_albedo_0", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_ground_diffuse_albedo_0(irrad_data):\n    ground_irrad = irradiance.get_ground_diffuse(\n        40, irrad_data['ghi'], albedo=0)\n    assert (0 == ground_irrad).all()\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_ground_diffuse_albedo_0", "irrad_data", "ground_irrad", "irradiance", "get_ground_diffuse", "40", "irrad_data", "ghi", "albedo", "0", "assert", "0", "ground_irrad", "all"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_ground_diffuse_albedo_series", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_ground_diffuse_albedo_series", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_ground_diffuse_albedo_series(times):\n    albedo = pd.Series(0.2, index=times)\n    ground_irrad = irradiance.get_ground_diffuse(\n        45, pd.Series(1000, index=times), albedo)\n    expected = albedo * 0.5 * (1 - np.sqrt(2) / 2.) * 1000\n    expected.name = 'diffuse_ground'\n    assert_series_equal(ground_irrad, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_ground_diffuse_albedo_series", "times", "albedo", "pd", "series", "0", "2", "index", "times", "ground_irrad", "irradiance", "get_ground_diffuse", "45", "pd", "series", "1000", "index", "times", "albedo", "expected", "albedo", "0", "5", "1", "np", "sqrt", "2", "2", "1000", "expected", "name", "diffuse_ground", "assert_series_equal", "ground_irrad", "expected"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_irradiance.py::test_grounddiffuse_albedo_invalid_surface", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_grounddiffuse_albedo_invalid_surface", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_grounddiffuse_albedo_invalid_surface(irrad_data):\n    with pytest.raises(KeyError):\n        irradiance.get_ground_diffuse(\n            40, irrad_data['ghi'], surface_type='invalid')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_grounddiffuse_albedo_invalid_surface", "irrad_data", "with", "pytest", "raises", "keyerror", "irradiance", "get_ground_diffuse", "40", "irrad_data", "ghi", "surface_type", "invalid"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_ground_diffuse_albedo_surface", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_ground_diffuse_albedo_surface", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_ground_diffuse_albedo_surface(irrad_data):\n    result = irradiance.get_ground_diffuse(40, irrad_data['ghi'],\n                                           surface_type='sand')\n    assert_allclose(result, [0, 3.731058, 48.778813, 12.035025], atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_ground_diffuse_albedo_surface", "irrad_data", "result", "irradiance", "get_ground_diffuse", "40", "irrad_data", "ghi", "surface_type", "sand", "assert_allclose", "result", "0", "3", "731058", "48", "778813", "12", "035025", "atol", "1e", "4"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_irradiance.py::test_isotropic_float", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_isotropic_float", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_isotropic_float():\n    result = irradiance.isotropic(40, 100)\n    assert_allclose(result, 88.30222215594891)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_isotropic_float", "result", "irradiance", "isotropic", "40", "100", "assert_allclose", "result", "88", "30222215594891"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_irradiance.py::test_isotropic_series", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_isotropic_series", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_isotropic_series(irrad_data):\n    result = irradiance.isotropic(40, irrad_data['dhi'])\n    assert_allclose(result, [0, 35.728402, 104.601328, 54.777191], atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_isotropic_series", "irrad_data", "result", "irradiance", "isotropic", "40", "irrad_data", "dhi", "assert_allclose", "result", "0", "35", "728402", "104", "601328", "54", "777191", "atol", "1e", "4"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_irradiance.py::test_klucher_series_float", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_klucher_series_float", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_klucher_series_float():\n    # klucher inputs\n    surface_tilt, surface_azimuth = 40.0, 180.0\n    dhi, ghi = 100.0, 900.0\n    solar_zenith, solar_azimuth = 20.0, 180.0\n    # expect same result for floats and pd.Series\n    expected = irradiance.klucher(\n        surface_tilt, surface_azimuth,\n        pd.Series(dhi), pd.Series(ghi),\n        pd.Series(solar_zenith), pd.Series(solar_azimuth)\n    )  # 94.99429931664851\n    result = irradiance.klucher(\n        surface_tilt, surface_azimuth, dhi, ghi, solar_zenith, solar_azimuth\n    )\n    assert_allclose(result, expected[0])\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_klucher_series_float", "klucher", "inputs", "surface_tilt", "surface_azimuth", "40", "0", "180", "0", "dhi", "ghi", "100", "0", "900", "0", "solar_zenith", "solar_azimuth", "20", "0", "180", "0", "expect", "same", "result", "for", "floats", "and", "pd", "series", "expected", "irradiance", "klucher", "surface_tilt", "surface_azimuth", "pd", "series", "dhi", "pd", "series", "ghi", "pd", "series", "solar_zenith", "pd", "series", "solar_azimuth", "94", "99429931664851", "result", "irradiance", "klucher", "surface_tilt", "surface_azimuth", "dhi", "ghi", "solar_zenith", "solar_azimuth", "assert_allclose", "result", "expected", "0"], "doc_len": 66}
{"doc_id": "pvlib/tests/test_irradiance.py::test_klucher_series", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_klucher_series", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_klucher_series(irrad_data, ephem_data):\n    result = irradiance.klucher(40, 180, irrad_data['dhi'], irrad_data['ghi'],\n                                ephem_data['apparent_zenith'],\n                                ephem_data['azimuth'])\n    # pvlib matlab 1.4 does not contain the max(cos_tt, 0) correction\n    # so, these values are different\n    assert_allclose(result, [0., 36.789794, 109.209347, 56.965916], atol=1e-4)\n    # expect same result for np.array and pd.Series\n    expected = irradiance.klucher(\n        40, 180, irrad_data['dhi'].values, irrad_data['ghi'].values,\n        ephem_data['apparent_zenith'].values, ephem_data['azimuth'].values\n    )\n    assert_allclose(result, expected, atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_klucher_series", "irrad_data", "ephem_data", "result", "irradiance", "klucher", "40", "180", "irrad_data", "dhi", "irrad_data", "ghi", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "pvlib", "matlab", "1", "4", "does", "not", "contain", "the", "max", "cos_tt", "0", "correction", "so", "these", "values", "are", "different", "assert_allclose", "result", "0", "36", "789794", "109", "209347", "56", "965916", "atol", "1e", "4", "expect", "same", "result", "for", "np", "array", "and", "pd", "series", "expected", "irradiance", "klucher", "40", "180", "irrad_data", "dhi", "values", "irrad_data", "ghi", "values", "ephem_data", "apparent_zenith", "values", "ephem_data", "azimuth", "values", "assert_allclose", "result", "expected", "atol", "1e", "4"], "doc_len": 82}
{"doc_id": "pvlib/tests/test_irradiance.py::test_haydavies", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_haydavies", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_haydavies(irrad_data, ephem_data, dni_et):\n    result = irradiance.haydavies(\n        40, 180, irrad_data['dhi'], irrad_data['dni'], dni_et,\n        ephem_data['apparent_zenith'], ephem_data['azimuth'])\n    # values from matlab 1.4 code\n    assert_allclose(result, [0, 27.1775, 102.9949, 33.1909], atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_haydavies", "irrad_data", "ephem_data", "dni_et", "result", "irradiance", "haydavies", "40", "180", "irrad_data", "dhi", "irrad_data", "dni", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "values", "from", "matlab", "1", "4", "code", "assert_allclose", "result", "0", "27", "1775", "102", "9949", "33", "1909", "atol", "1e", "4"], "doc_len": 41}
{"doc_id": "pvlib/tests/test_irradiance.py::test_haydavies_components", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_haydavies_components", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_haydavies_components(irrad_data, ephem_data, dni_et):\n    expected = pd.DataFrame(np.array(\n        [[0, 27.1775, 102.9949, 33.1909],\n         [0, 27.1775, 30.1818, 27.9837],\n         [0, 0, 72.8130, 5.2071],\n         [0, 0, 0, 0]]).T,\n        columns=['sky_diffuse', 'isotropic', 'circumsolar', 'horizon'],\n        index=irrad_data.index\n    )\n    # pandas\n    result = irradiance.haydavies(\n        40, 180, irrad_data['dhi'], irrad_data['dni'], dni_et,\n        ephem_data['apparent_zenith'], ephem_data['azimuth'],\n        return_components=True)\n    assert_frame_equal(result, expected, check_less_precise=4)\n    # numpy\n    result = irradiance.haydavies(\n        40, 180, irrad_data['dhi'].values, irrad_data['dni'].values, dni_et,\n        ephem_data['apparent_zenith'].values, ephem_data['azimuth'].values,\n        return_components=True)\n    assert_allclose(result['sky_diffuse'], expected['sky_diffuse'], atol=1e-4)\n    assert_allclose(result['isotropic'], expected['isotropic'], atol=1e-4)\n    assert_allclose(result['circumsolar'], expected['circumsolar'], atol=1e-4)\n    assert_allclose(result['horizon'], expected['horizon'], atol=1e-4)\n    assert isinstance(result, dict)\n    # scalar\n    result = irradiance.haydavies(\n        40, 180, irrad_data['dhi'].values[-1], irrad_data['dni'].values[-1],\n        dni_et[-1], ephem_data['apparent_zenith'].values[-1],\n        ephem_data['azimuth'].values[-1], return_components=True)\n    assert_allclose(result['sky_diffuse'], expected['sky_diffuse'][-1],\n                    atol=1e-4)\n    assert_allclose(result['isotropic'], expected['isotropic'][-1],\n                    atol=1e-4)\n    assert_allclose(result['circumsolar'], expected['circumsolar'][-1],\n                    atol=1e-4)\n    assert_allclose(result['horizon'], expected['horizon'][-1], atol=1e-4)\n    assert isinstance(result, dict)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_haydavies_components", "irrad_data", "ephem_data", "dni_et", "expected", "pd", "dataframe", "np", "array", "0", "27", "1775", "102", "9949", "33", "1909", "0", "27", "1775", "30", "1818", "27", "9837", "0", "0", "72", "8130", "5", "2071", "0", "0", "0", "0", "t", "columns", "sky_diffuse", "isotropic", "circumsolar", "horizon", "index", "irrad_data", "index", "pandas", "result", "irradiance", "haydavies", "40", "180", "irrad_data", "dhi", "irrad_data", "dni", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "return_components", "true", "assert_frame_equal", "result", "expected", "check_less_precise", "4", "numpy", "result", "irradiance", "haydavies", "40", "180", "irrad_data", "dhi", "values", "irrad_data", "dni", "values", "dni_et", "ephem_data", "apparent_zenith", "values", "ephem_data", "azimuth", "values", "return_components", "true", "assert_allclose", "result", "sky_diffuse", "expected", "sky_diffuse", "atol", "1e", "4", "assert_allclose", "result", "isotropic", "expected", "isotropic", "atol", "1e", "4", "assert_allclose", "result", "circumsolar", "expected", "circumsolar", "atol", "1e", "4", "assert_allclose", "result", "horizon", "expected", "horizon", "atol", "1e", "4", "assert", "isinstance", "result", "dict", "scalar", "result", "irradiance", "haydavies", "40", "180", "irrad_data", "dhi", "values", "1", "irrad_data", "dni", "values", "1", "dni_et", "1", "ephem_data", "apparent_zenith", "values", "1", "ephem_data", "azimuth", "values", "1", "return_components", "true", "assert_allclose", "result", "sky_diffuse", "expected", "sky_diffuse", "1", "atol", "1e", "4", "assert_allclose", "result", "isotropic", "expected", "isotropic", "1", "atol", "1e", "4", "assert_allclose", "result", "circumsolar", "expected", "circumsolar", "1", "atol", "1e", "4", "assert_allclose", "result", "horizon", "expected", "horizon", "1", "atol", "1e", "4", "assert", "isinstance", "result", "dict"], "doc_len": 192}
{"doc_id": "pvlib/tests/test_irradiance.py::test_reindl", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_reindl", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_reindl(irrad_data, ephem_data, dni_et):\n    result = irradiance.reindl(\n        40, 180, irrad_data['dhi'], irrad_data['dni'], irrad_data['ghi'],\n        dni_et, ephem_data['apparent_zenith'], ephem_data['azimuth'])\n    # values from matlab 1.4 code\n    assert_allclose(result, [0., 27.9412, 104.1317, 34.1663], atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_reindl", "irrad_data", "ephem_data", "dni_et", "result", "irradiance", "reindl", "40", "180", "irrad_data", "dhi", "irrad_data", "dni", "irrad_data", "ghi", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "values", "from", "matlab", "1", "4", "code", "assert_allclose", "result", "0", "27", "9412", "104", "1317", "34", "1663", "atol", "1e", "4"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_irradiance.py::test_king", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_king", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_king(irrad_data, ephem_data):\n    result = irradiance.king(40, irrad_data['dhi'], irrad_data['ghi'],\n                             ephem_data['apparent_zenith'])\n    assert_allclose(result, [0, 44.629352, 115.182626, 79.719855], atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_king", "irrad_data", "ephem_data", "result", "irradiance", "king", "40", "irrad_data", "dhi", "irrad_data", "ghi", "ephem_data", "apparent_zenith", "assert_allclose", "result", "0", "44", "629352", "115", "182626", "79", "719855", "atol", "1e", "4"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_irradiance.py::test_perez", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_perez", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_perez(irrad_data, ephem_data, dni_et, relative_airmass):\n    dni = irrad_data['dni'].copy()\n    dni.iloc[2] = np.nan\n    out = irradiance.perez(40, 180, irrad_data['dhi'], dni,\n                           dni_et, ephem_data['apparent_zenith'],\n                           ephem_data['azimuth'], relative_airmass)\n    expected = pd.Series(np.array(\n        [0.,   31.46046871,  np.nan,   45.45539877]),\n        index=irrad_data.index)\n    assert_series_equal(out, expected, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_perez", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "dni", "irrad_data", "dni", "copy", "dni", "iloc", "2", "np", "nan", "out", "irradiance", "perez", "40", "180", "irrad_data", "dhi", "dni", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "relative_airmass", "expected", "pd", "series", "np", "array", "0", "31", "46046871", "np", "nan", "45", "45539877", "index", "irrad_data", "index", "assert_series_equal", "out", "expected", "check_less_precise", "2"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_irradiance.py::test_perez_components", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_perez_components", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_perez_components(irrad_data, ephem_data, dni_et, relative_airmass):\n    dni = irrad_data['dni'].copy()\n    dni.iloc[2] = np.nan\n    out = irradiance.perez(40, 180, irrad_data['dhi'], dni,\n                           dni_et, ephem_data['apparent_zenith'],\n                           ephem_data['azimuth'], relative_airmass,\n                           return_components=True)\n    expected = pd.DataFrame(np.array(\n        [[0.,   31.46046871,  np.nan,   45.45539877],\n         [0.,  26.84138589,          np.nan,  31.72696071],\n         [0.,  0.,         np.nan,  4.47966439],\n         [0.,  4.62212181,         np.nan,  9.25316454]]).T,\n        columns=['sky_diffuse', 'isotropic', 'circumsolar', 'horizon'],\n        index=irrad_data.index\n    )\n    expected_for_sum = expected['sky_diffuse'].copy()\n    expected_for_sum.iloc[2] = 0\n    sum_components = out.iloc[:, 1:].sum(axis=1)\n    sum_components.name = 'sky_diffuse'\n\n    assert_frame_equal(out, expected, check_less_precise=2)\n    assert_series_equal(sum_components, expected_for_sum, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_perez_components", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "dni", "irrad_data", "dni", "copy", "dni", "iloc", "2", "np", "nan", "out", "irradiance", "perez", "40", "180", "irrad_data", "dhi", "dni", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "relative_airmass", "return_components", "true", "expected", "pd", "dataframe", "np", "array", "0", "31", "46046871", "np", "nan", "45", "45539877", "0", "26", "84138589", "np", "nan", "31", "72696071", "0", "0", "np", "nan", "4", "47966439", "0", "4", "62212181", "np", "nan", "9", "25316454", "t", "columns", "sky_diffuse", "isotropic", "circumsolar", "horizon", "index", "irrad_data", "index", "expected_for_sum", "expected", "sky_diffuse", "copy", "expected_for_sum", "iloc", "2", "0", "sum_components", "out", "iloc", "1", "sum", "axis", "1", "sum_components", "name", "sky_diffuse", "assert_frame_equal", "out", "expected", "check_less_precise", "2", "assert_series_equal", "sum_components", "expected_for_sum", "check_less_precise", "2"], "doc_len": 104}
{"doc_id": "pvlib/tests/test_irradiance.py::test_perez_negative_horizon", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_perez_negative_horizon", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_perez_negative_horizon():\n    times = pd.date_range(start='20190101 11:30:00', freq='1H',\n                          periods=5, tz='US/Central')\n\n    # Avoid test dependencies on functionality not being tested by hard-coding\n    # the inputs. This data corresponds to Goodwin Creek in the afternoon on\n    # 1/1/2019.\n    # dni_e is slightly rounded from irradiance.get_extra_radiation\n    # airmass from atmosphere.get_relative_airmas\n    inputs = pd.DataFrame(np.array(\n        [[158,         19,          1,          0,          0],\n         [249,        165,        136,         93,         50],\n         [57.746951,  57.564205,  60.813841,  66.989435,  75.353368],\n         [171.003315, 187.346924, 202.974357, 216.725599, 228.317233],\n         [1414,       1414,       1414,       1414,       1414],\n         [1.869315,   1.859981,   2.044429,   2.544943,   3.900136]]).T,\n        columns=['dni', 'dhi', 'solar_zenith',\n                 'solar_azimuth', 'dni_extra', 'airmass'],\n        index=times\n    )\n\n    out = irradiance.perez(34, 180, inputs['dhi'], inputs['dni'],\n                           inputs['dni_extra'], inputs['solar_zenith'],\n                           inputs['solar_azimuth'], inputs['airmass'],\n                           model='allsitescomposite1990',\n                           return_components=True)\n\n    # sky_diffuse can be less than isotropic under certain conditions as\n    # horizon goes negative\n    expected = pd.DataFrame(np.array(\n        [[281.410185, 152.20879, 123.867898, 82.836412, 43.517015],\n         [166.785419, 142.24475, 119.173875, 83.525150, 45.725931],\n         [113.548755,  16.09757,   9.956174,  3.142467,  0],\n         [1.076010,  -6.13353,  -5.262151, -3.831230, -2.208923]]).T,\n        columns=['sky_diffuse', 'isotropic', 'circumsolar', 'horizon'],\n        index=times\n    )\n\n    expected_for_sum = expected['sky_diffuse'].copy()\n    sum_components = out.iloc[:, 1:].sum(axis=1)\n    sum_components.name = 'sky_diffuse'\n\n    assert_frame_equal(out, expected, check_less_precise=2)\n    assert_series_equal(sum_components, expected_for_sum, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_perez_negative_horizon", "times", "pd", "date_range", "start", "20190101", "11", "30", "00", "freq", "1h", "periods", "5", "tz", "us", "central", "avoid", "test", "dependencies", "on", "functionality", "not", "being", "tested", "by", "hard", "coding", "the", "inputs", "this", "data", "corresponds", "to", "goodwin", "creek", "in", "the", "afternoon", "on", "1", "1", "2019", "dni_e", "is", "slightly", "rounded", "from", "irradiance", "get_extra_radiation", "airmass", "from", "atmosphere", "get_relative_airmas", "inputs", "pd", "dataframe", "np", "array", "158", "19", "1", "0", "0", "249", "165", "136", "93", "50", "57", "746951", "57", "564205", "60", "813841", "66", "989435", "75", "353368", "171", "003315", "187", "346924", "202", "974357", "216", "725599", "228", "317233", "1414", "1414", "1414", "1414", "1414", "1", "869315", "1", "859981", "2", "044429", "2", "544943", "3", "900136", "t", "columns", "dni", "dhi", "solar_zenith", "solar_azimuth", "dni_extra", "airmass", "index", "times", "out", "irradiance", "perez", "34", "180", "inputs", "dhi", "inputs", "dni", "inputs", "dni_extra", "inputs", "solar_zenith", "inputs", "solar_azimuth", "inputs", "airmass", "model", "allsitescomposite1990", "return_components", "true", "sky_diffuse", "can", "be", "less", "than", "isotropic", "under", "certain", "conditions", "as", "horizon", "goes", "negative", "expected", "pd", "dataframe", "np", "array", "281", "410185", "152", "20879", "123", "867898", "82", "836412", "43", "517015", "166", "785419", "142", "24475", "119", "173875", "83", "525150", "45", "725931", "113", "548755", "16", "09757", "9", "956174", "3", "142467", "0", "1", "076010", "6", "13353", "5", "262151", "3", "831230", "2", "208923", "t", "columns", "sky_diffuse", "isotropic", "circumsolar", "horizon", "index", "times", "expected_for_sum", "expected", "sky_diffuse", "copy", "sum_components", "out", "iloc", "1", "sum", "axis", "1", "sum_components", "name", "sky_diffuse", "assert_frame_equal", "out", "expected", "check_less_precise", "2", "assert_series_equal", "sum_components", "expected_for_sum", "check_less_precise", "2"], "doc_len": 228}
{"doc_id": "pvlib/tests/test_irradiance.py::test_perez_arrays", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_perez_arrays", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_perez_arrays(irrad_data, ephem_data, dni_et, relative_airmass):\n    dni = irrad_data['dni'].copy()\n    dni.iloc[2] = np.nan\n    out = irradiance.perez(40, 180, irrad_data['dhi'].values, dni.values,\n                           dni_et, ephem_data['apparent_zenith'].values,\n                           ephem_data['azimuth'].values,\n                           relative_airmass.values)\n    expected = np.array(\n        [0.,   31.46046871,  np.nan,   45.45539877])\n    assert_allclose(out, expected, atol=1e-2)\n    assert isinstance(out, np.ndarray)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_perez_arrays", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "dni", "irrad_data", "dni", "copy", "dni", "iloc", "2", "np", "nan", "out", "irradiance", "perez", "40", "180", "irrad_data", "dhi", "values", "dni", "values", "dni_et", "ephem_data", "apparent_zenith", "values", "ephem_data", "azimuth", "values", "relative_airmass", "values", "expected", "np", "array", "0", "31", "46046871", "np", "nan", "45", "45539877", "assert_allclose", "out", "expected", "atol", "1e", "2", "assert", "isinstance", "out", "np", "ndarray"], "doc_len": 59}
{"doc_id": "pvlib/tests/test_irradiance.py::test_perez_scalar", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_perez_scalar", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_perez_scalar():\n    # copied values from fixtures\n    out = irradiance.perez(40, 180, 118.45831879, 939.95469881,\n                           1321.1655834833093, 10.56413562, 144.76567754,\n                           1.01688136)\n    # this will fail. out is ndarry with ndim == 0. fix in future version.\n    # assert np.isscalar(out)\n    assert_allclose(out, 109.084332)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_perez_scalar", "copied", "values", "from", "fixtures", "out", "irradiance", "perez", "40", "180", "118", "45831879", "939", "95469881", "1321", "1655834833093", "10", "56413562", "144", "76567754", "1", "01688136", "this", "will", "fail", "out", "is", "ndarry", "with", "ndim", "0", "fix", "in", "future", "version", "assert", "np", "isscalar", "out", "assert_allclose", "out", "109", "084332"], "doc_len": 48}
{"doc_id": "pvlib/tests/test_irradiance.py::test_sky_diffuse_zenith_close_to_90", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_sky_diffuse_zenith_close_to_90", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_sky_diffuse_zenith_close_to_90(model):\n    # GH 432\n    sky_diffuse = irradiance.get_sky_diffuse(\n        30, 180, 89.999, 230,\n        dni=10, ghi=51, dhi=50, dni_extra=1360, airmass=12, model=model)\n    assert sky_diffuse < 100\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_sky_diffuse_zenith_close_to_90", "model", "gh", "432", "sky_diffuse", "irradiance", "get_sky_diffuse", "30", "180", "89", "999", "230", "dni", "10", "ghi", "51", "dhi", "50", "dni_extra", "1360", "airmass", "12", "model", "model", "assert", "sky_diffuse", "100"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_sky_diffuse_model_invalid", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_sky_diffuse_model_invalid", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_sky_diffuse_model_invalid():\n    with pytest.raises(ValueError):\n        irradiance.get_sky_diffuse(\n            30, 180, 0, 180, 1000, 1100, 100, dni_extra=1360, airmass=1,\n            model='invalid')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_sky_diffuse_model_invalid", "with", "pytest", "raises", "valueerror", "irradiance", "get_sky_diffuse", "30", "180", "0", "180", "1000", "1100", "100", "dni_extra", "1360", "airmass", "1", "model", "invalid"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_sky_diffuse_missing_dni_extra", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_sky_diffuse_missing_dni_extra", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_sky_diffuse_missing_dni_extra():\n    msg = 'dni_extra is required'\n    with pytest.raises(ValueError, match=msg):\n        irradiance.get_sky_diffuse(\n            30, 180, 0, 180, 1000, 1100, 100, airmass=1,\n            model='haydavies')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_sky_diffuse_missing_dni_extra", "msg", "dni_extra", "is", "required", "with", "pytest", "raises", "valueerror", "match", "msg", "irradiance", "get_sky_diffuse", "30", "180", "0", "180", "1000", "1100", "100", "airmass", "1", "model", "haydavies"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_sky_diffuse_missing_airmass", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_sky_diffuse_missing_airmass", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_sky_diffuse_missing_airmass(irrad_data, ephem_data, dni_et):\n    # test assumes location is Tucson, AZ\n    # calculated airmass should be the equivalent to fixture airmass\n    dni = irrad_data['dni'].copy()\n    dni.iloc[2] = np.nan\n    out = irradiance.get_sky_diffuse(\n        40, 180, ephem_data['apparent_zenith'], ephem_data['azimuth'], dni,\n        irrad_data['ghi'], irrad_data['dhi'], dni_et,  model='perez')\n    expected = pd.Series(np.array(\n        [0., 31.46046871, np.nan, 45.45539877]),\n        index=irrad_data.index)\n    assert_series_equal(out, expected, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_sky_diffuse_missing_airmass", "irrad_data", "ephem_data", "dni_et", "test", "assumes", "location", "is", "tucson", "az", "calculated", "airmass", "should", "be", "the", "equivalent", "to", "fixture", "airmass", "dni", "irrad_data", "dni", "copy", "dni", "iloc", "2", "np", "nan", "out", "irradiance", "get_sky_diffuse", "40", "180", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "dni", "irrad_data", "ghi", "irrad_data", "dhi", "dni_et", "model", "perez", "expected", "pd", "series", "np", "array", "0", "31", "46046871", "np", "nan", "45", "45539877", "index", "irrad_data", "index", "assert_series_equal", "out", "expected", "check_less_precise", "2"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_irradiance.py::test_campbell_norman", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_campbell_norman", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_campbell_norman():\n    expected = pd.DataFrame(np.array(\n        [[863.859736967, 653.123094076, 220.65905025]]),\n        columns=['ghi', 'dni', 'dhi'],\n        index=[0])\n    out = irradiance.campbell_norman(\n        pd.Series([10]), pd.Series([0.5]), pd.Series([109764.21013135818]),\n        dni_extra=1400)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_campbell_norman", "expected", "pd", "dataframe", "np", "array", "863", "859736967", "653", "123094076", "220", "65905025", "columns", "ghi", "dni", "dhi", "index", "0", "out", "irradiance", "campbell_norman", "pd", "series", "10", "pd", "series", "0", "5", "pd", "series", "109764", "21013135818", "dni_extra", "1400", "assert_frame_equal", "out", "expected"], "doc_len": 42}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_total_irradiance", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_total_irradiance", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_total_irradiance(irrad_data, ephem_data, dni_et,\n                              relative_airmass):\n    models = ['isotropic', 'klucher',\n              'haydavies', 'reindl', 'king', 'perez']\n\n    for model in models:\n        total = irradiance.get_total_irradiance(\n            32, 180,\n            ephem_data['apparent_zenith'], ephem_data['azimuth'],\n            dni=irrad_data['dni'], ghi=irrad_data['ghi'],\n            dhi=irrad_data['dhi'],\n            dni_extra=dni_et, airmass=relative_airmass,\n            model=model,\n            surface_type='urban')\n\n        assert total.columns.tolist() == ['poa_global', 'poa_direct',\n                                          'poa_diffuse', 'poa_sky_diffuse',\n                                          'poa_ground_diffuse']\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_total_irradiance", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "models", "isotropic", "klucher", "haydavies", "reindl", "king", "perez", "for", "model", "in", "models", "total", "irradiance", "get_total_irradiance", "32", "180", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "dni", "irrad_data", "dni", "ghi", "irrad_data", "ghi", "dhi", "irrad_data", "dhi", "dni_extra", "dni_et", "airmass", "relative_airmass", "model", "model", "surface_type", "urban", "assert", "total", "columns", "tolist", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_total_irradiance_albedo", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_total_irradiance_albedo", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_total_irradiance_albedo(\n        irrad_data, ephem_data, dni_et, relative_airmass, model):\n    albedo = pd.Series(0.2, index=ephem_data.index)\n    total = irradiance.get_total_irradiance(\n        32, 180,\n        ephem_data['apparent_zenith'], ephem_data['azimuth'],\n        dni=irrad_data['dni'], ghi=irrad_data['ghi'],\n        dhi=irrad_data['dhi'],\n        dni_extra=dni_et, airmass=relative_airmass,\n        model=model,\n        albedo=albedo)\n\n    assert total.columns.tolist() == ['poa_global', 'poa_direct',\n                                      'poa_diffuse', 'poa_sky_diffuse',\n                                      'poa_ground_diffuse']\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_total_irradiance_albedo", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "model", "albedo", "pd", "series", "0", "2", "index", "ephem_data", "index", "total", "irradiance", "get_total_irradiance", "32", "180", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "dni", "irrad_data", "dni", "ghi", "irrad_data", "ghi", "dhi", "irrad_data", "dhi", "dni_extra", "dni_et", "airmass", "relative_airmass", "model", "model", "albedo", "albedo", "assert", "total", "columns", "tolist", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_total_irradiance_scalars", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_total_irradiance_scalars", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_total_irradiance_scalars(model):\n    total = irradiance.get_total_irradiance(\n        32, 180,\n        10, 180,\n        dni=1000, ghi=1100,\n        dhi=100,\n        dni_extra=1400, airmass=1,\n        model=model,\n        surface_type='urban')\n\n    assert list(total.keys()) == ['poa_global', 'poa_direct',\n                                  'poa_diffuse', 'poa_sky_diffuse',\n                                  'poa_ground_diffuse']\n    # test that none of the values are nan\n    assert np.isnan(np.array(list(total.values()))).sum() == 0\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_total_irradiance_scalars", "model", "total", "irradiance", "get_total_irradiance", "32", "180", "10", "180", "dni", "1000", "ghi", "1100", "dhi", "100", "dni_extra", "1400", "airmass", "1", "model", "model", "surface_type", "urban", "assert", "list", "total", "keys", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "test", "that", "none", "of", "the", "values", "are", "nan", "assert", "np", "isnan", "np", "array", "list", "total", "values", "sum", "0"], "doc_len": 55}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_total_irradiance_missing_dni_extra", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_total_irradiance_missing_dni_extra", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_total_irradiance_missing_dni_extra():\n    msg = 'dni_extra is required'\n    with pytest.raises(ValueError, match=msg):\n        irradiance.get_total_irradiance(\n            32, 180,\n            10, 180,\n            dni=1000, ghi=1100,\n            dhi=100,\n            model='haydavies')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_total_irradiance_missing_dni_extra", "msg", "dni_extra", "is", "required", "with", "pytest", "raises", "valueerror", "match", "msg", "irradiance", "get_total_irradiance", "32", "180", "10", "180", "dni", "1000", "ghi", "1100", "dhi", "100", "model", "haydavies"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_irradiance.py::test_get_total_irradiance_missing_airmass", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_get_total_irradiance_missing_airmass", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_get_total_irradiance_missing_airmass():\n    total = irradiance.get_total_irradiance(\n        32, 180,\n        10, 180,\n        dni=1000, ghi=1100,\n        dhi=100,\n        dni_extra=1400,\n        model='perez')\n    assert list(total.keys()) == ['poa_global', 'poa_direct',\n                                  'poa_diffuse', 'poa_sky_diffuse',\n                                  'poa_ground_diffuse']\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_get_total_irradiance_missing_airmass", "total", "irradiance", "get_total_irradiance", "32", "180", "10", "180", "dni", "1000", "ghi", "1100", "dhi", "100", "dni_extra", "1400", "model", "perez", "assert", "list", "total", "keys", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_irradiance.py::test_poa_components", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_poa_components", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_poa_components(irrad_data, ephem_data, dni_et, relative_airmass):\n    aoi = irradiance.aoi(40, 180, ephem_data['apparent_zenith'],\n                         ephem_data['azimuth'])\n    gr_sand = irradiance.get_ground_diffuse(40, irrad_data['ghi'],\n                                            surface_type='sand')\n    diff_perez = irradiance.perez(\n        40, 180, irrad_data['dhi'], irrad_data['dni'], dni_et,\n        ephem_data['apparent_zenith'], ephem_data['azimuth'], relative_airmass)\n    out = irradiance.poa_components(\n        aoi, irrad_data['dni'], diff_perez, gr_sand)\n    expected = pd.DataFrame(np.array(\n        [[0.,  -0.,   0.,   0.,\n            0.],\n         [35.19456561,   0.,  35.19456561,  31.4635077,\n            3.73105791],\n         [956.18253696, 798.31939281, 157.86314414, 109.08433162,\n          48.77881252],\n         [90.99624896,  33.50143401,  57.49481495,  45.45978964,\n          12.03502531]]),\n        columns=['poa_global', 'poa_direct', 'poa_diffuse', 'poa_sky_diffuse',\n                 'poa_ground_diffuse'],\n        index=irrad_data.index)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_poa_components", "irrad_data", "ephem_data", "dni_et", "relative_airmass", "aoi", "irradiance", "aoi", "40", "180", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "gr_sand", "irradiance", "get_ground_diffuse", "40", "irrad_data", "ghi", "surface_type", "sand", "diff_perez", "irradiance", "perez", "40", "180", "irrad_data", "dhi", "irrad_data", "dni", "dni_et", "ephem_data", "apparent_zenith", "ephem_data", "azimuth", "relative_airmass", "out", "irradiance", "poa_components", "aoi", "irrad_data", "dni", "diff_perez", "gr_sand", "expected", "pd", "dataframe", "np", "array", "0", "0", "0", "0", "0", "35", "19456561", "0", "35", "19456561", "31", "4635077", "3", "73105791", "956", "18253696", "798", "31939281", "157", "86314414", "109", "08433162", "48", "77881252", "90", "99624896", "33", "50143401", "57", "49481495", "45", "45978964", "12", "03502531", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "index", "irrad_data", "index", "assert_frame_equal", "out", "expected"], "doc_len": 101}
{"doc_id": "pvlib/tests/test_irradiance.py::test_disc_value", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_disc_value", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_disc_value(pressure, expected):\n    # see GH 449 for pressure=None vs. 101325.\n    columns = ['dni', 'kt', 'airmass']\n    times = pd.DatetimeIndex(['2014-06-24T1200', '2014-06-24T1800'],\n                             tz='America/Phoenix')\n    ghi = pd.Series([1038.62, 254.53], index=times)\n    zenith = pd.Series([10.567, 72.469], index=times)\n    out = irradiance.disc(ghi, zenith, times, pressure=pressure)\n    expected_values = np.array(expected)\n    expected = pd.DataFrame(expected_values, columns=columns, index=times)\n    # check the pandas dataframe. check_less_precise is weird\n    assert_frame_equal(out, expected, check_less_precise=True)\n    # use np.assert_allclose to check values more clearly\n    assert_allclose(out.values, expected_values, atol=1e-5)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_disc_value", "pressure", "expected", "see", "gh", "449", "for", "pressure", "none", "vs", "101325", "columns", "dni", "kt", "airmass", "times", "pd", "datetimeindex", "2014", "06", "24t1200", "2014", "06", "24t1800", "tz", "america", "phoenix", "ghi", "pd", "series", "1038", "62", "254", "53", "index", "times", "zenith", "pd", "series", "10", "567", "72", "469", "index", "times", "out", "irradiance", "disc", "ghi", "zenith", "times", "pressure", "pressure", "expected_values", "np", "array", "expected", "expected", "pd", "dataframe", "expected_values", "columns", "columns", "index", "times", "check", "the", "pandas", "dataframe", "check_less_precise", "is", "weird", "assert_frame_equal", "out", "expected", "check_less_precise", "true", "use", "np", "assert_allclose", "to", "check", "values", "more", "clearly", "assert_allclose", "out", "values", "expected_values", "atol", "1e", "5"], "doc_len": 97}
{"doc_id": "pvlib/tests/test_irradiance.py::test_disc_overirradiance", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_disc_overirradiance", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_disc_overirradiance():\n    columns = ['dni', 'kt', 'airmass']\n    ghi = np.array([3000])\n    solar_zenith = np.full_like(ghi, 0)\n    times = pd.date_range(start='2016-07-19 12:00:00', freq='1s',\n                          periods=len(ghi), tz='America/Phoenix')\n    out = irradiance.disc(ghi=ghi, solar_zenith=solar_zenith,\n                          datetime_or_doy=times)\n    expected = pd.DataFrame(np.array(\n        [[8.72544336e+02, 1.00000000e+00, 9.99493933e-01]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_disc_overirradiance", "columns", "dni", "kt", "airmass", "ghi", "np", "array", "3000", "solar_zenith", "np", "full_like", "ghi", "0", "times", "pd", "date_range", "start", "2016", "07", "19", "12", "00", "00", "freq", "1s", "periods", "len", "ghi", "tz", "america", "phoenix", "out", "irradiance", "disc", "ghi", "ghi", "solar_zenith", "solar_zenith", "datetime_or_doy", "times", "expected", "pd", "dataframe", "np", "array", "8", "72544336e", "02", "1", "00000000e", "00", "9", "99493933e", "01", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_irradiance.py::test_disc_min_cos_zenith_max_zenith", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_disc_min_cos_zenith_max_zenith", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_disc_min_cos_zenith_max_zenith():\n    # map out behavior under difficult conditions with various\n    # limiting kwargs settings\n    columns = ['dni', 'kt', 'airmass']\n    times = pd.DatetimeIndex(['2016-07-19 06:11:00'], tz='America/Phoenix')\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times)\n    expected = pd.DataFrame(np.array(\n        [[0.00000000e+00, 1.16046346e-02, 12.0]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # max_zenith and/or max_airmass keep these results reasonable\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          min_cos_zenith=0)\n    expected = pd.DataFrame(np.array(\n        [[0.00000000e+00, 1.0, 12.0]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # still get reasonable values because of max_airmass=12 limit\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          max_zenith=100)\n    expected = pd.DataFrame(np.array(\n        [[0., 1.16046346e-02, 12.0]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # still get reasonable values because of max_airmass=12 limit\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          min_cos_zenith=0, max_zenith=100)\n    expected = pd.DataFrame(np.array(\n        [[277.50185968, 1.0, 12.0]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # max_zenith keeps this result reasonable\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          min_cos_zenith=0, max_airmass=100)\n    expected = pd.DataFrame(np.array(\n        [[0.00000000e+00, 1.0, 36.39544757]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # allow zenith to be close to 90 and airmass to be infinite\n    # and we get crazy values\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          max_zenith=100, max_airmass=100)\n    expected = pd.DataFrame(np.array(\n        [[6.68577449e+03, 1.16046346e-02, 3.63954476e+01]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # allow min cos zenith to be 0, zenith to be close to 90,\n    # and airmass to be very big and we get even higher DNI values\n    out = irradiance.disc(ghi=1.0, solar_zenith=89.99, datetime_or_doy=times,\n                          min_cos_zenith=0, max_zenith=100, max_airmass=100)\n    expected = pd.DataFrame(np.array(\n        [[7.21238390e+03, 1., 3.63954476e+01]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_disc_min_cos_zenith_max_zenith", "map", "out", "behavior", "under", "difficult", "conditions", "with", "various", "limiting", "kwargs", "settings", "columns", "dni", "kt", "airmass", "times", "pd", "datetimeindex", "2016", "07", "19", "06", "11", "00", "tz", "america", "phoenix", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "expected", "pd", "dataframe", "np", "array", "0", "00000000e", "00", "1", "16046346e", "02", "12", "0", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "max_zenith", "and", "or", "max_airmass", "keep", "these", "results", "reasonable", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "min_cos_zenith", "0", "expected", "pd", "dataframe", "np", "array", "0", "00000000e", "00", "1", "0", "12", "0", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "still", "get", "reasonable", "values", "because", "of", "max_airmass", "12", "limit", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "max_zenith", "100", "expected", "pd", "dataframe", "np", "array", "0", "1", "16046346e", "02", "12", "0", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "still", "get", "reasonable", "values", "because", "of", "max_airmass", "12", "limit", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "min_cos_zenith", "0", "max_zenith", "100", "expected", "pd", "dataframe", "np", "array", "277", "50185968", "1", "0", "12", "0", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "max_zenith", "keeps", "this", "result", "reasonable", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "min_cos_zenith", "0", "max_airmass", "100", "expected", "pd", "dataframe", "np", "array", "0", "00000000e", "00", "1", "0", "36", "39544757", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "allow", "zenith", "to", "be", "close", "to", "90", "and", "airmass", "to", "be", "infinite", "and", "we", "get", "crazy", "values", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "max_zenith", "100", "max_airmass", "100", "expected", "pd", "dataframe", "np", "array", "6", "68577449e", "03", "1", "16046346e", "02", "3", "63954476e", "01", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "allow", "min", "cos", "zenith", "to", "be", "0", "zenith", "to", "be", "close", "to", "90", "and", "airmass", "to", "be", "very", "big", "and", "we", "get", "even", "higher", "dni", "values", "out", "irradiance", "disc", "ghi", "1", "0", "solar_zenith", "89", "99", "datetime_or_doy", "times", "min_cos_zenith", "0", "max_zenith", "100", "max_airmass", "100", "expected", "pd", "dataframe", "np", "array", "7", "21238390e", "03", "1", "3", "63954476e", "01", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected"], "doc_len": 340}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_value", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_value", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_value():\n    times = pd.DatetimeIndex(['2014-06-24T12-0700', '2014-06-24T18-0700'])\n    ghi = pd.Series([1038.62, 254.53], index=times)\n    zenith = pd.Series([10.567, 72.469], index=times)\n    pressure = 93193.\n    dirint_data = irradiance.dirint(ghi, zenith, times, pressure=pressure)\n    assert_almost_equal(dirint_data.values,\n                        np.array([868.8,  699.7]), 1)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_value", "times", "pd", "datetimeindex", "2014", "06", "24t12", "0700", "2014", "06", "24t18", "0700", "ghi", "pd", "series", "1038", "62", "254", "53", "index", "times", "zenith", "pd", "series", "10", "567", "72", "469", "index", "times", "pressure", "93193", "dirint_data", "irradiance", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "assert_almost_equal", "dirint_data", "values", "np", "array", "868", "8", "699", "7", "1"], "doc_len": 55}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_nans", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_nans", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_nans():\n    times = pd.date_range(start='2014-06-24T12-0700', periods=5, freq='6H')\n    ghi = pd.Series([np.nan, 1038.62, 1038.62, 1038.62, 1038.62], index=times)\n    zenith = pd.Series([10.567, np.nan, 10.567, 10.567, 10.567], index=times)\n    pressure = pd.Series([93193., 93193., np.nan, 93193., 93193.], index=times)\n    temp_dew = pd.Series([10, 10, 10, np.nan, 10], index=times)\n    dirint_data = irradiance.dirint(ghi, zenith, times, pressure=pressure,\n                                    temp_dew=temp_dew)\n    assert_almost_equal(dirint_data.values,\n                        np.array([np.nan, np.nan, np.nan, np.nan, 893.1]), 1)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_nans", "times", "pd", "date_range", "start", "2014", "06", "24t12", "0700", "periods", "5", "freq", "6h", "ghi", "pd", "series", "np", "nan", "1038", "62", "1038", "62", "1038", "62", "1038", "62", "index", "times", "zenith", "pd", "series", "10", "567", "np", "nan", "10", "567", "10", "567", "10", "567", "index", "times", "pressure", "pd", "series", "93193", "93193", "np", "nan", "93193", "93193", "index", "times", "temp_dew", "pd", "series", "10", "10", "10", "np", "nan", "10", "index", "times", "dirint_data", "irradiance", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "temp_dew", "temp_dew", "assert_almost_equal", "dirint_data", "values", "np", "array", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "893", "1", "1"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_tdew", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_tdew", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_tdew():\n    times = pd.DatetimeIndex(['2014-06-24T12-0700', '2014-06-24T18-0700'])\n    ghi = pd.Series([1038.62, 254.53], index=times)\n    zenith = pd.Series([10.567, 72.469], index=times)\n    pressure = 93193.\n    dirint_data = irradiance.dirint(ghi, zenith, times, pressure=pressure,\n                                    temp_dew=10)\n    assert_almost_equal(dirint_data.values,\n                        np.array([882.1,  672.6]), 1)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_tdew", "times", "pd", "datetimeindex", "2014", "06", "24t12", "0700", "2014", "06", "24t18", "0700", "ghi", "pd", "series", "1038", "62", "254", "53", "index", "times", "zenith", "pd", "series", "10", "567", "72", "469", "index", "times", "pressure", "93193", "dirint_data", "irradiance", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "temp_dew", "10", "assert_almost_equal", "dirint_data", "values", "np", "array", "882", "1", "672", "6", "1"], "doc_len": 57}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_no_delta_kt", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_no_delta_kt", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_no_delta_kt():\n    times = pd.DatetimeIndex(['2014-06-24T12-0700', '2014-06-24T18-0700'])\n    ghi = pd.Series([1038.62, 254.53], index=times)\n    zenith = pd.Series([10.567, 72.469], index=times)\n    pressure = 93193.\n    dirint_data = irradiance.dirint(ghi, zenith, times, pressure=pressure,\n                                    use_delta_kt_prime=False)\n    assert_almost_equal(dirint_data.values,\n                        np.array([861.9,  670.4]), 1)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_no_delta_kt", "times", "pd", "datetimeindex", "2014", "06", "24t12", "0700", "2014", "06", "24t18", "0700", "ghi", "pd", "series", "1038", "62", "254", "53", "index", "times", "zenith", "pd", "series", "10", "567", "72", "469", "index", "times", "pressure", "93193", "dirint_data", "irradiance", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "use_delta_kt_prime", "false", "assert_almost_equal", "dirint_data", "values", "np", "array", "861", "9", "670", "4", "1"], "doc_len": 57}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_coeffs", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_coeffs", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_coeffs():\n    coeffs = irradiance._get_dirint_coeffs()\n    assert coeffs[0, 0, 0, 0] == 0.385230\n    assert coeffs[0, 1, 2, 1] == 0.229970\n    assert coeffs[3, 2, 6, 3] == 1.032260\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_coeffs", "coeffs", "irradiance", "_get_dirint_coeffs", "assert", "coeffs", "0", "0", "0", "0", "0", "385230", "assert", "coeffs", "0", "1", "2", "1", "0", "229970", "assert", "coeffs", "3", "2", "6", "3", "1", "032260"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirint_min_cos_zenith_max_zenith", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirint_min_cos_zenith_max_zenith", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirint_min_cos_zenith_max_zenith():\n    # map out behavior under difficult conditions with various\n    # limiting kwargs settings\n    # times don't have any physical relevance\n    times = pd.DatetimeIndex(['2014-06-24T12-0700', '2014-06-24T18-0700'])\n    ghi = pd.Series([0, 1], index=times)\n    solar_zenith = pd.Series([90, 89.99], index=times)\n\n    out = irradiance.dirint(ghi, solar_zenith, times)\n    expected = pd.Series([0.0, 0.0], index=times, name='dni')\n    assert_series_equal(out, expected)\n\n    out = irradiance.dirint(ghi, solar_zenith, times, min_cos_zenith=0)\n    expected = pd.Series([0.0, 0.0], index=times, name='dni')\n    assert_series_equal(out, expected)\n\n    out = irradiance.dirint(ghi, solar_zenith, times, max_zenith=90)\n    expected = pd.Series([0.0, 0.0], index=times, name='dni')\n    assert_series_equal(out, expected, check_less_precise=True)\n\n    out = irradiance.dirint(ghi, solar_zenith, times, min_cos_zenith=0,\n                            max_zenith=90)\n    expected = pd.Series([0.0, 144.264507], index=times, name='dni')\n    assert_series_equal(out, expected, check_less_precise=True)\n\n    out = irradiance.dirint(ghi, solar_zenith, times, min_cos_zenith=0,\n                            max_zenith=100)\n    expected = pd.Series([0.0, 144.264507], index=times, name='dni')\n    assert_series_equal(out, expected, check_less_precise=True)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirint_min_cos_zenith_max_zenith", "map", "out", "behavior", "under", "difficult", "conditions", "with", "various", "limiting", "kwargs", "settings", "times", "don", "t", "have", "any", "physical", "relevance", "times", "pd", "datetimeindex", "2014", "06", "24t12", "0700", "2014", "06", "24t18", "0700", "ghi", "pd", "series", "0", "1", "index", "times", "solar_zenith", "pd", "series", "90", "89", "99", "index", "times", "out", "irradiance", "dirint", "ghi", "solar_zenith", "times", "expected", "pd", "series", "0", "0", "0", "0", "index", "times", "name", "dni", "assert_series_equal", "out", "expected", "out", "irradiance", "dirint", "ghi", "solar_zenith", "times", "min_cos_zenith", "0", "expected", "pd", "series", "0", "0", "0", "0", "index", "times", "name", "dni", "assert_series_equal", "out", "expected", "out", "irradiance", "dirint", "ghi", "solar_zenith", "times", "max_zenith", "90", "expected", "pd", "series", "0", "0", "0", "0", "index", "times", "name", "dni", "assert_series_equal", "out", "expected", "check_less_precise", "true", "out", "irradiance", "dirint", "ghi", "solar_zenith", "times", "min_cos_zenith", "0", "max_zenith", "90", "expected", "pd", "series", "0", "0", "144", "264507", "index", "times", "name", "dni", "assert_series_equal", "out", "expected", "check_less_precise", "true", "out", "irradiance", "dirint", "ghi", "solar_zenith", "times", "min_cos_zenith", "0", "max_zenith", "100", "expected", "pd", "series", "0", "0", "144", "264507", "index", "times", "name", "dni", "assert_series_equal", "out", "expected", "check_less_precise", "true"], "doc_len": 168}
{"doc_id": "pvlib/tests/test_irradiance.py::test_gti_dirint", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_gti_dirint", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_gti_dirint():\n    times = pd.DatetimeIndex(\n        ['2014-06-24T06-0700', '2014-06-24T09-0700', '2014-06-24T12-0700'])\n    poa_global = np.array([20, 300, 1000])\n    aoi = np.array([100, 70, 10])\n    zenith = np.array([80, 45, 20])\n    azimuth = np.array([90, 135, 180])\n    surface_tilt = 30\n    surface_azimuth = 180\n\n    # test defaults\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth)\n\n    expected_col_order = ['ghi', 'dni', 'dhi']\n    expected = pd.DataFrame(array(\n        [[21.05796198,    0.,   21.05796198],\n         [291.40037163,   63.41290679,  246.56067523],\n         [931.04078010,  695.94965324,  277.06172442]]),\n        columns=expected_col_order, index=times)\n\n    assert_frame_equal(output, expected)\n\n    # test ignore calculate_gt_90\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth,\n        calculate_gt_90=False)\n\n    expected_no_90 = expected.copy()\n    expected_no_90.iloc[0, :] = np.nan\n\n    assert_frame_equal(output, expected_no_90)\n\n    # test pressure input\n    pressure = 93193.\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth,\n        pressure=pressure)\n\n    expected = pd.DataFrame(array(\n        [[21.05796198,    0.,   21.05796198],\n         [293.21310935,   63.27500913,  248.47092131],\n         [932.46756378,  648.05001357,  323.49974813]]),\n        columns=expected_col_order, index=times)\n\n    assert_frame_equal(output, expected)\n\n    # test albedo input\n    albedo = 0.05\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth,\n        albedo=albedo)\n\n    expected = pd.DataFrame(array(\n        [[21.3592591,    0.,   21.3592591],\n         [294.4985420,   66.25848451,  247.64671830],\n         [941.7943404,  727.50552952,  258.16276278]]),\n        columns=expected_col_order, index=times)\n\n    assert_frame_equal(output, expected)\n\n    # test with albedo as a Series\n    albedo = pd.Series(0.05, index=times)\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth,\n        albedo=albedo)\n\n    assert_frame_equal(output, expected)\n\n    # test temp_dew input\n    temp_dew = np.array([70, 80, 20])\n    output = irradiance.gti_dirint(\n        poa_global, aoi, zenith, azimuth, times, surface_tilt, surface_azimuth,\n        temp_dew=temp_dew)\n\n    expected = pd.DataFrame(array(\n        [[21.05796198,    0.,           21.05796198],\n         [295.06070190,   38.20346345,  268.0467738],\n         [931.79627208,  689.81549269,  283.5817439]]),\n        columns=expected_col_order, index=times)\n\n    assert_frame_equal(output, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_gti_dirint", "times", "pd", "datetimeindex", "2014", "06", "24t06", "0700", "2014", "06", "24t09", "0700", "2014", "06", "24t12", "0700", "poa_global", "np", "array", "20", "300", "1000", "aoi", "np", "array", "100", "70", "10", "zenith", "np", "array", "80", "45", "20", "azimuth", "np", "array", "90", "135", "180", "surface_tilt", "30", "surface_azimuth", "180", "test", "defaults", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "expected_col_order", "ghi", "dni", "dhi", "expected", "pd", "dataframe", "array", "21", "05796198", "0", "21", "05796198", "291", "40037163", "63", "41290679", "246", "56067523", "931", "04078010", "695", "94965324", "277", "06172442", "columns", "expected_col_order", "index", "times", "assert_frame_equal", "output", "expected", "test", "ignore", "calculate_gt_90", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "calculate_gt_90", "false", "expected_no_90", "expected", "copy", "expected_no_90", "iloc", "0", "np", "nan", "assert_frame_equal", "output", "expected_no_90", "test", "pressure", "input", "pressure", "93193", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "pressure", "pressure", "expected", "pd", "dataframe", "array", "21", "05796198", "0", "21", "05796198", "293", "21310935", "63", "27500913", "248", "47092131", "932", "46756378", "648", "05001357", "323", "49974813", "columns", "expected_col_order", "index", "times", "assert_frame_equal", "output", "expected", "test", "albedo", "input", "albedo", "0", "05", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "albedo", "albedo", "expected", "pd", "dataframe", "array", "21", "3592591", "0", "21", "3592591", "294", "4985420", "66", "25848451", "247", "64671830", "941", "7943404", "727", "50552952", "258", "16276278", "columns", "expected_col_order", "index", "times", "assert_frame_equal", "output", "expected", "test", "with", "albedo", "as", "a", "series", "albedo", "pd", "series", "0", "05", "index", "times", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "albedo", "albedo", "assert_frame_equal", "output", "expected", "test", "temp_dew", "input", "temp_dew", "np", "array", "70", "80", "20", "output", "irradiance", "gti_dirint", "poa_global", "aoi", "zenith", "azimuth", "times", "surface_tilt", "surface_azimuth", "temp_dew", "temp_dew", "expected", "pd", "dataframe", "array", "21", "05796198", "0", "21", "05796198", "295", "06070190", "38", "20346345", "268", "0467738", "931", "79627208", "689", "81549269", "283", "5817439", "columns", "expected_col_order", "index", "times", "assert_frame_equal", "output", "expected"], "doc_len": 287}
{"doc_id": "pvlib/tests/test_irradiance.py::test_erbs", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_erbs", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_erbs():\n    index = pd.DatetimeIndex(['20190101']*3 + ['20190620'])\n    ghi = pd.Series([0, 50, 1000, 1000], index=index)\n    zenith = pd.Series([120, 85, 10, 10], index=index)\n    expected = pd.DataFrame(np.array(\n        [[0.00000000e+00, 0.00000000e+00, 0.00000000e+00],\n         [9.67192672e+01, 4.15703604e+01, 4.05723511e-01],\n         [7.94205651e+02, 2.17860117e+02, 7.18132729e-01],\n         [8.42001578e+02, 1.70790318e+02, 7.68214312e-01]]),\n        columns=['dni', 'dhi', 'kt'], index=index)\n\n    out = irradiance.erbs(ghi, zenith, index)\n\n    assert_frame_equal(np.round(out, 0), np.round(expected, 0))\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_erbs", "index", "pd", "datetimeindex", "20190101", "3", "20190620", "ghi", "pd", "series", "0", "50", "1000", "1000", "index", "index", "zenith", "pd", "series", "120", "85", "10", "10", "index", "index", "expected", "pd", "dataframe", "np", "array", "0", "00000000e", "00", "0", "00000000e", "00", "0", "00000000e", "00", "9", "67192672e", "01", "4", "15703604e", "01", "4", "05723511e", "01", "7", "94205651e", "02", "2", "17860117e", "02", "7", "18132729e", "01", "8", "42001578e", "02", "1", "70790318e", "02", "7", "68214312e", "01", "columns", "dni", "dhi", "kt", "index", "index", "out", "irradiance", "erbs", "ghi", "zenith", "index", "assert_frame_equal", "np", "round", "out", "0", "np", "round", "expected", "0"], "doc_len": 92}
{"doc_id": "pvlib/tests/test_irradiance.py::test_erbs_min_cos_zenith_max_zenith", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_erbs_min_cos_zenith_max_zenith", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_erbs_min_cos_zenith_max_zenith():\n    # map out behavior under difficult conditions with various\n    # limiting kwargs settings\n    columns = ['dni', 'dhi', 'kt']\n    times = pd.DatetimeIndex(['2016-07-19 06:11:00'], tz='America/Phoenix')\n\n    # max_zenith keeps these results reasonable\n    out = irradiance.erbs(ghi=1.0, zenith=89.99999,\n                          datetime_or_doy=times, min_cos_zenith=0)\n    expected = pd.DataFrame(np.array(\n        [[0., 1., 1.]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # 4-5 9s will produce bad behavior without max_zenith limit\n    out = irradiance.erbs(ghi=1.0, zenith=89.99999,\n                          datetime_or_doy=times, max_zenith=100)\n    expected = pd.DataFrame(np.array(\n        [[6.00115286e+03, 9.98952601e-01, 1.16377640e-02]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # 1-2 9s will produce bad behavior without either limit\n    out = irradiance.erbs(ghi=1.0, zenith=89.99, datetime_or_doy=times,\n                          min_cos_zenith=0, max_zenith=100)\n    expected = pd.DataFrame(np.array(\n        [[4.78419761e+03, 1.65000000e-01, 1.00000000e+00]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n\n    # check default behavior under hardest condition\n    out = irradiance.erbs(ghi=1.0, zenith=90, datetime_or_doy=times)\n    expected = pd.DataFrame(np.array(\n        [[0., 1., 0.01163776]]),\n        columns=columns, index=times)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_erbs_min_cos_zenith_max_zenith", "map", "out", "behavior", "under", "difficult", "conditions", "with", "various", "limiting", "kwargs", "settings", "columns", "dni", "dhi", "kt", "times", "pd", "datetimeindex", "2016", "07", "19", "06", "11", "00", "tz", "america", "phoenix", "max_zenith", "keeps", "these", "results", "reasonable", "out", "irradiance", "erbs", "ghi", "1", "0", "zenith", "89", "99999", "datetime_or_doy", "times", "min_cos_zenith", "0", "expected", "pd", "dataframe", "np", "array", "0", "1", "1", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "4", "5", "9s", "will", "produce", "bad", "behavior", "without", "max_zenith", "limit", "out", "irradiance", "erbs", "ghi", "1", "0", "zenith", "89", "99999", "datetime_or_doy", "times", "max_zenith", "100", "expected", "pd", "dataframe", "np", "array", "6", "00115286e", "03", "9", "98952601e", "01", "1", "16377640e", "02", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "1", "2", "9s", "will", "produce", "bad", "behavior", "without", "either", "limit", "out", "irradiance", "erbs", "ghi", "1", "0", "zenith", "89", "99", "datetime_or_doy", "times", "min_cos_zenith", "0", "max_zenith", "100", "expected", "pd", "dataframe", "np", "array", "4", "78419761e", "03", "1", "65000000e", "01", "1", "00000000e", "00", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected", "check", "default", "behavior", "under", "hardest", "condition", "out", "irradiance", "erbs", "ghi", "1", "0", "zenith", "90", "datetime_or_doy", "times", "expected", "pd", "dataframe", "np", "array", "0", "1", "0", "01163776", "columns", "columns", "index", "times", "assert_frame_equal", "out", "expected"], "doc_len": 188}
{"doc_id": "pvlib/tests/test_irradiance.py::test_erbs_all_scalar", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_erbs_all_scalar", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_erbs_all_scalar():\n    ghi = 1000\n    zenith = 10\n    doy = 180\n\n    expected = OrderedDict()\n    expected['dni'] = 8.42358014e+02\n    expected['dhi'] = 1.70439297e+02\n    expected['kt'] = 7.68919470e-01\n\n    out = irradiance.erbs(ghi, zenith, doy)\n\n    for k, v in out.items():\n        assert_allclose(v, expected[k], 5)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_erbs_all_scalar", "ghi", "1000", "zenith", "10", "doy", "180", "expected", "ordereddict", "expected", "dni", "8", "42358014e", "02", "expected", "dhi", "1", "70439297e", "02", "expected", "kt", "7", "68919470e", "01", "out", "irradiance", "erbs", "ghi", "zenith", "doy", "for", "k", "v", "in", "out", "items", "assert_allclose", "v", "expected", "k", "5"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirindex", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirindex", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirindex(times):\n    ghi = pd.Series([0, 0, 1038.62, 254.53], index=times)\n    ghi_clearsky = pd.Series(\n        np.array([0., 79.73860422, 1042.48031487, 257.20751138]),\n        index=times\n    )\n    dni_clearsky = pd.Series(\n        np.array([0., 316.1949056, 939.95469881, 646.22886049]),\n        index=times\n    )\n    zenith = pd.Series(\n        np.array([124.0390863, 82.85457044, 10.56413562, 72.41687122]),\n        index=times\n    )\n    pressure = 93193.\n    tdew = 10.\n    out = irradiance.dirindex(ghi, ghi_clearsky, dni_clearsky,\n                              zenith, times, pressure=pressure,\n                              temp_dew=tdew)\n    dirint_close_values = irradiance.dirint(ghi, zenith, times,\n                                            pressure=pressure,\n                                            use_delta_kt_prime=True,\n                                            temp_dew=tdew).values\n    expected_out = np.array([np.nan, 0., 748.31562753, 630.72592644])\n\n    tolerance = 1e-8\n    assert np.allclose(out, expected_out, rtol=tolerance, atol=0,\n                       equal_nan=True)\n    tol_dirint = 0.2\n    assert np.allclose(out.values, dirint_close_values, rtol=tol_dirint, atol=0,\n                       equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirindex", "times", "ghi", "pd", "series", "0", "0", "1038", "62", "254", "53", "index", "times", "ghi_clearsky", "pd", "series", "np", "array", "0", "79", "73860422", "1042", "48031487", "257", "20751138", "index", "times", "dni_clearsky", "pd", "series", "np", "array", "0", "316", "1949056", "939", "95469881", "646", "22886049", "index", "times", "zenith", "pd", "series", "np", "array", "124", "0390863", "82", "85457044", "10", "56413562", "72", "41687122", "index", "times", "pressure", "93193", "tdew", "10", "out", "irradiance", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "zenith", "times", "pressure", "pressure", "temp_dew", "tdew", "dirint_close_values", "irradiance", "dirint", "ghi", "zenith", "times", "pressure", "pressure", "use_delta_kt_prime", "true", "temp_dew", "tdew", "values", "expected_out", "np", "array", "np", "nan", "0", "748", "31562753", "630", "72592644", "tolerance", "1e", "8", "assert", "np", "allclose", "out", "expected_out", "rtol", "tolerance", "atol", "0", "equal_nan", "true", "tol_dirint", "0", "2", "assert", "np", "allclose", "out", "values", "dirint_close_values", "rtol", "tol_dirint", "atol", "0", "equal_nan", "true"], "doc_len": 129}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dirindex_min_cos_zenith_max_zenith", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dirindex_min_cos_zenith_max_zenith", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dirindex_min_cos_zenith_max_zenith():\n    # map out behavior under difficult conditions with various\n    # limiting kwargs settings\n    # times don't have any physical relevance\n    times = pd.DatetimeIndex(['2014-06-24T12-0700', '2014-06-24T18-0700'])\n    ghi = pd.Series([0, 1], index=times)\n    ghi_clearsky = pd.Series([0, 1], index=times)\n    dni_clearsky = pd.Series([0, 5], index=times)\n    solar_zenith = pd.Series([90, 89.99], index=times)\n\n    out = irradiance.dirindex(ghi, ghi_clearsky, dni_clearsky, solar_zenith,\n                              times)\n    expected = pd.Series([nan, nan], index=times)\n    assert_series_equal(out, expected)\n\n    out = irradiance.dirindex(ghi, ghi_clearsky, dni_clearsky, solar_zenith,\n                              times, min_cos_zenith=0)\n    expected = pd.Series([nan, nan], index=times)\n    assert_series_equal(out, expected)\n\n    out = irradiance.dirindex(ghi, ghi_clearsky, dni_clearsky, solar_zenith,\n                              times, max_zenith=90)\n    expected = pd.Series([nan, nan], index=times)\n    assert_series_equal(out, expected)\n\n    out = irradiance.dirindex(ghi, ghi_clearsky, dni_clearsky, solar_zenith,\n                              times, min_cos_zenith=0, max_zenith=100)\n    expected = pd.Series([nan, 5.], index=times)\n    assert_series_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dirindex_min_cos_zenith_max_zenith", "map", "out", "behavior", "under", "difficult", "conditions", "with", "various", "limiting", "kwargs", "settings", "times", "don", "t", "have", "any", "physical", "relevance", "times", "pd", "datetimeindex", "2014", "06", "24t12", "0700", "2014", "06", "24t18", "0700", "ghi", "pd", "series", "0", "1", "index", "times", "ghi_clearsky", "pd", "series", "0", "1", "index", "times", "dni_clearsky", "pd", "series", "0", "5", "index", "times", "solar_zenith", "pd", "series", "90", "89", "99", "index", "times", "out", "irradiance", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "solar_zenith", "times", "expected", "pd", "series", "nan", "nan", "index", "times", "assert_series_equal", "out", "expected", "out", "irradiance", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "solar_zenith", "times", "min_cos_zenith", "0", "expected", "pd", "series", "nan", "nan", "index", "times", "assert_series_equal", "out", "expected", "out", "irradiance", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "solar_zenith", "times", "max_zenith", "90", "expected", "pd", "series", "nan", "nan", "index", "times", "assert_series_equal", "out", "expected", "out", "irradiance", "dirindex", "ghi", "ghi_clearsky", "dni_clearsky", "solar_zenith", "times", "min_cos_zenith", "0", "max_zenith", "100", "expected", "pd", "series", "nan", "5", "index", "times", "assert_series_equal", "out", "expected"], "doc_len": 144}
{"doc_id": "pvlib/tests/test_irradiance.py::test_dni", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_dni", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_dni():\n    ghi = pd.Series([90, 100, 100, 100, 100])\n    dhi = pd.Series([100, 90, 50, 50, 50])\n    zenith = pd.Series([80, 100, 85, 70, 85])\n    clearsky_dni = pd.Series([50, 50, 200, 50, 300])\n\n    dni = irradiance.dni(ghi, dhi, zenith,\n                         clearsky_dni=clearsky_dni, clearsky_tolerance=2)\n    assert_series_equal(dni,\n                        pd.Series([float('nan'), float('nan'), 400,\n                                   146.190220008, 573.685662283]))\n\n    dni = irradiance.dni(ghi, dhi, zenith)\n    assert_series_equal(dni,\n                        pd.Series([float('nan'), float('nan'), 573.685662283,\n                                   146.190220008, 573.685662283]))\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_dni", "ghi", "pd", "series", "90", "100", "100", "100", "100", "dhi", "pd", "series", "100", "90", "50", "50", "50", "zenith", "pd", "series", "80", "100", "85", "70", "85", "clearsky_dni", "pd", "series", "50", "50", "200", "50", "300", "dni", "irradiance", "dni", "ghi", "dhi", "zenith", "clearsky_dni", "clearsky_dni", "clearsky_tolerance", "2", "assert_series_equal", "dni", "pd", "series", "float", "nan", "float", "nan", "400", "146", "190220008", "573", "685662283", "dni", "irradiance", "dni", "ghi", "dhi", "zenith", "assert_series_equal", "dni", "pd", "series", "float", "nan", "float", "nan", "573", "685662283", "146", "190220008", "573", "685662283"], "doc_len": 81}
{"doc_id": "pvlib/tests/test_irradiance.py::test_aoi_and_aoi_projection", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_aoi_and_aoi_projection", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_aoi_and_aoi_projection(surface_tilt, surface_azimuth, solar_zenith,\n                                solar_azimuth, aoi_expected,\n                                aoi_proj_expected):\n    aoi = irradiance.aoi(surface_tilt, surface_azimuth, solar_zenith,\n                         solar_azimuth)\n    assert_allclose(aoi, aoi_expected, atol=1e-5)\n\n    aoi_projection = irradiance.aoi_projection(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth)\n    assert_allclose(aoi_projection, aoi_proj_expected, atol=1e-6)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_aoi_and_aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "aoi_expected", "aoi_proj_expected", "aoi", "irradiance", "aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "assert_allclose", "aoi", "aoi_expected", "atol", "1e", "5", "aoi_projection", "irradiance", "aoi_projection", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "assert_allclose", "aoi_projection", "aoi_proj_expected", "atol", "1e", "6"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_irradiance.py::test_aoi_projection_precision", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_aoi_projection_precision", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_aoi_projection_precision():\n    # GH 1185 -- test that aoi_projection does not exceed 1.0, and when\n    # given identical inputs, the returned projection is very close to 1.0\n\n    # scalars\n    zenith = 89.26778228223463\n    azimuth = 60.932028605997004\n    projection = irradiance.aoi_projection(zenith, azimuth, zenith, azimuth)\n    assert projection <= 1\n    assert np.isclose(projection, 1)\n\n    # arrays\n    zeniths = np.array([zenith])\n    azimuths = np.array([azimuth])\n    projections = irradiance.aoi_projection(zeniths, azimuths,\n                                            zeniths, azimuths)\n    assert all(projections <= 1)\n    assert all(np.isclose(projections, 1))\n    assert projections.dtype == np.dtype('float64')\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_aoi_projection_precision", "gh", "1185", "test", "that", "aoi_projection", "does", "not", "exceed", "1", "0", "and", "when", "given", "identical", "inputs", "the", "returned", "projection", "is", "very", "close", "to", "1", "0", "scalars", "zenith", "89", "26778228223463", "azimuth", "60", "932028605997004", "projection", "irradiance", "aoi_projection", "zenith", "azimuth", "zenith", "azimuth", "assert", "projection", "1", "assert", "np", "isclose", "projection", "1", "arrays", "zeniths", "np", "array", "zenith", "azimuths", "np", "array", "azimuth", "projections", "irradiance", "aoi_projection", "zeniths", "azimuths", "zeniths", "azimuths", "assert", "all", "projections", "1", "assert", "all", "np", "isclose", "projections", "1", "assert", "projections", "dtype", "np", "dtype", "float64"], "doc_len": 84}
{"doc_id": "pvlib/tests/test_irradiance.py::airmass_kt", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "airmass_kt", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef airmass_kt():\n    # disc algorithm stopped at am=12. test am > 12 for out of range behavior\n    return np.array([1, 5, 12, 20])\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "airmass_kt", "disc", "algorithm", "stopped", "at", "am", "12", "test", "am", "12", "for", "out", "of", "range", "behavior", "return", "np", "array", "1", "5", "12", "20"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_irradiance.py::test_kt_kt_prime_factor", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_kt_kt_prime_factor", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_kt_kt_prime_factor(airmass_kt):\n    out = irradiance._kt_kt_prime_factor(airmass_kt)\n    expected = np.array([0.999971,  0.723088,  0.548811,  0.471068])\n    assert_allclose(out, expected, atol=1e-5)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_kt_kt_prime_factor", "airmass_kt", "out", "irradiance", "_kt_kt_prime_factor", "airmass_kt", "expected", "np", "array", "0", "999971", "0", "723088", "0", "548811", "0", "471068", "assert_allclose", "out", "expected", "atol", "1e", "5"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_irradiance.py::test_clearsky_index", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_clearsky_index", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_clearsky_index():\n    ghi = np.array([-1., 0., 1., 500., 1000., np.nan])\n    ghi_measured, ghi_modeled = np.meshgrid(ghi, ghi)\n    # default max_clearsky_index\n    with np.errstate(invalid='ignore', divide='ignore'):\n        out = irradiance.clearsky_index(ghi_measured, ghi_modeled)\n    expected = np.array(\n        [[1., 0., 0., 0., 0., np.nan],\n         [0., 0., 0., 0., 0., np.nan],\n         [0., 0., 1., 2., 2., np.nan],\n         [0., 0., 0.002, 1., 2., np.nan],\n         [0., 0., 0.001, 0.5, 1., np.nan],\n         [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan]])\n    assert_allclose(out, expected, atol=0.001)\n    # specify max_clearsky_index\n    with np.errstate(invalid='ignore', divide='ignore'):\n        out = irradiance.clearsky_index(ghi_measured, ghi_modeled,\n                                        max_clearsky_index=1.5)\n    expected = np.array(\n        [[1., 0., 0., 0., 0., np.nan],\n         [0., 0., 0., 0., 0., np.nan],\n         [0., 0., 1., 1.5, 1.5, np.nan],\n         [0., 0., 0.002, 1., 1.5, np.nan],\n         [0., 0., 0.001, 0.5, 1., np.nan],\n         [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan]])\n    assert_allclose(out, expected, atol=0.001)\n    # scalars\n    out = irradiance.clearsky_index(10, 1000)\n    expected = 0.01\n    assert_allclose(out, expected, atol=0.001)\n    # series\n    times = pd.date_range(start='20180601', periods=2, freq='12H')\n    ghi_measured = pd.Series([100,  500], index=times)\n    ghi_modeled = pd.Series([500, 1000], index=times)\n    out = irradiance.clearsky_index(ghi_measured, ghi_modeled)\n    expected = pd.Series([0.2, 0.5], index=times)\n    assert_series_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_clearsky_index", "ghi", "np", "array", "1", "0", "1", "500", "1000", "np", "nan", "ghi_measured", "ghi_modeled", "np", "meshgrid", "ghi", "ghi", "default", "max_clearsky_index", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "out", "irradiance", "clearsky_index", "ghi_measured", "ghi_modeled", "expected", "np", "array", "1", "0", "0", "0", "0", "np", "nan", "0", "0", "0", "0", "0", "np", "nan", "0", "0", "1", "2", "2", "np", "nan", "0", "0", "0", "002", "1", "2", "np", "nan", "0", "0", "0", "001", "0", "5", "1", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "assert_allclose", "out", "expected", "atol", "0", "001", "specify", "max_clearsky_index", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "out", "irradiance", "clearsky_index", "ghi_measured", "ghi_modeled", "max_clearsky_index", "1", "5", "expected", "np", "array", "1", "0", "0", "0", "0", "np", "nan", "0", "0", "0", "0", "0", "np", "nan", "0", "0", "1", "1", "5", "1", "5", "np", "nan", "0", "0", "0", "002", "1", "1", "5", "np", "nan", "0", "0", "0", "001", "0", "5", "1", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "np", "nan", "assert_allclose", "out", "expected", "atol", "0", "001", "scalars", "out", "irradiance", "clearsky_index", "10", "1000", "expected", "0", "01", "assert_allclose", "out", "expected", "atol", "0", "001", "series", "times", "pd", "date_range", "start", "20180601", "periods", "2", "freq", "12h", "ghi_measured", "pd", "series", "100", "500", "index", "times", "ghi_modeled", "pd", "series", "500", "1000", "index", "times", "out", "irradiance", "clearsky_index", "ghi_measured", "ghi_modeled", "expected", "pd", "series", "0", "2", "0", "5", "index", "times", "assert_series_equal", "out", "expected"], "doc_len": 230}
{"doc_id": "pvlib/tests/test_irradiance.py::test_clearness_index", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_clearness_index", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_clearness_index():\n    ghi = np.array([-1, 0, 1, 1000])\n    solar_zenith = np.array([180, 90, 89.999, 0])\n    ghi, solar_zenith = np.meshgrid(ghi, solar_zenith)\n    # default min_cos_zenith\n    out = irradiance.clearness_index(ghi, solar_zenith, 1370)\n    # np.set_printoptions(precision=3, floatmode='maxprec', suppress=True)\n    expected = np.array(\n        [[0., 0., 0.011, 2.],\n         [0., 0., 0.011, 2.],\n         [0., 0., 0.011, 2.],\n         [0., 0., 0.001, 0.73]])\n    assert_allclose(out, expected, atol=0.001)\n    # specify min_cos_zenith\n    with np.errstate(invalid='ignore', divide='ignore'):\n        out = irradiance.clearness_index(ghi, solar_zenith, 1400,\n                                         min_cos_zenith=0)\n    expected = np.array(\n        [[0.,   nan, 2., 2.],\n         [0., 0., 2., 2.],\n         [0., 0., 2., 2.],\n         [0., 0., 0.001, 0.714]])\n    assert_allclose(out, expected, atol=0.001)\n    # specify max_clearness_index\n    out = irradiance.clearness_index(ghi, solar_zenith, 1370,\n                                     max_clearness_index=0.82)\n    expected = np.array(\n        [[0.,  0.,  0.011,  0.82],\n         [0.,  0.,  0.011,  0.82],\n         [0.,  0.,  0.011,  0.82],\n         [0.,  0.,  0.001,  0.73]])\n    assert_allclose(out, expected, atol=0.001)\n    # specify min_cos_zenith and max_clearness_index\n    with np.errstate(invalid='ignore', divide='ignore'):\n        out = irradiance.clearness_index(ghi, solar_zenith, 1400,\n                                         min_cos_zenith=0,\n                                         max_clearness_index=0.82)\n    expected = np.array(\n        [[0.,    nan,  0.82,  0.82],\n         [0.,  0.,  0.82,  0.82],\n         [0.,  0.,  0.82,  0.82],\n         [0.,  0.,  0.001,  0.714]])\n    assert_allclose(out, expected, atol=0.001)\n    # scalars\n    out = irradiance.clearness_index(1000, 10, 1400)\n    expected = 0.725\n    assert_allclose(out, expected, atol=0.001)\n    # series\n    times = pd.date_range(start='20180601', periods=2, freq='12H')\n    ghi = pd.Series([0, 1000], index=times)\n    solar_zenith = pd.Series([90, 0], index=times)\n    extra_radiation = pd.Series([1360, 1400], index=times)\n    out = irradiance.clearness_index(ghi, solar_zenith, extra_radiation)\n    expected = pd.Series([0, 0.714285714286], index=times)\n    assert_series_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_clearness_index", "ghi", "np", "array", "1", "0", "1", "1000", "solar_zenith", "np", "array", "180", "90", "89", "999", "0", "ghi", "solar_zenith", "np", "meshgrid", "ghi", "solar_zenith", "default", "min_cos_zenith", "out", "irradiance", "clearness_index", "ghi", "solar_zenith", "1370", "np", "set_printoptions", "precision", "3", "floatmode", "maxprec", "suppress", "true", "expected", "np", "array", "0", "0", "0", "011", "2", "0", "0", "0", "011", "2", "0", "0", "0", "011", "2", "0", "0", "0", "001", "0", "73", "assert_allclose", "out", "expected", "atol", "0", "001", "specify", "min_cos_zenith", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "out", "irradiance", "clearness_index", "ghi", "solar_zenith", "1400", "min_cos_zenith", "0", "expected", "np", "array", "0", "nan", "2", "2", "0", "0", "2", "2", "0", "0", "2", "2", "0", "0", "0", "001", "0", "714", "assert_allclose", "out", "expected", "atol", "0", "001", "specify", "max_clearness_index", "out", "irradiance", "clearness_index", "ghi", "solar_zenith", "1370", "max_clearness_index", "0", "82", "expected", "np", "array", "0", "0", "0", "011", "0", "82", "0", "0", "0", "011", "0", "82", "0", "0", "0", "011", "0", "82", "0", "0", "0", "001", "0", "73", "assert_allclose", "out", "expected", "atol", "0", "001", "specify", "min_cos_zenith", "and", "max_clearness_index", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "out", "irradiance", "clearness_index", "ghi", "solar_zenith", "1400", "min_cos_zenith", "0", "max_clearness_index", "0", "82", "expected", "np", "array", "0", "nan", "0", "82", "0", "82", "0", "0", "0", "82", "0", "82", "0", "0", "0", "82", "0", "82", "0", "0", "0", "001", "0", "714", "assert_allclose", "out", "expected", "atol", "0", "001", "scalars", "out", "irradiance", "clearness_index", "1000", "10", "1400", "expected", "0", "725", "assert_allclose", "out", "expected", "atol", "0", "001", "series", "times", "pd", "date_range", "start", "20180601", "periods", "2", "freq", "12h", "ghi", "pd", "series", "0", "1000", "index", "times", "solar_zenith", "pd", "series", "90", "0", "index", "times", "extra_radiation", "pd", "series", "1360", "1400", "index", "times", "out", "irradiance", "clearness_index", "ghi", "solar_zenith", "extra_radiation", "expected", "pd", "series", "0", "0", "714285714286", "index", "times", "assert_series_equal", "out", "expected"], "doc_len": 280}
{"doc_id": "pvlib/tests/test_irradiance.py::test_clearness_index_zenith_independent", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_clearness_index_zenith_independent", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_clearness_index_zenith_independent(airmass_kt):\n    clearness_index = np.array([-1, 0, .1, 1])\n    clearness_index, airmass_kt = np.meshgrid(clearness_index, airmass_kt)\n    out = irradiance.clearness_index_zenith_independent(clearness_index,\n                                                        airmass_kt)\n    expected = np.array(\n        [[0., 0., 0.1, 1.],\n         [0., 0., 0.138, 1.383],\n         [0., 0., 0.182, 1.822],\n         [0., 0., 0.212, 2.]])\n    assert_allclose(out, expected, atol=0.001)\n    # test max_clearness_index\n    out = irradiance.clearness_index_zenith_independent(\n        clearness_index, airmass_kt, max_clearness_index=0.82)\n    expected = np.array(\n        [[0.,  0.,  0.1,  0.82],\n         [0.,  0.,  0.138,  0.82],\n         [0.,  0.,  0.182,  0.82],\n         [0.,  0.,  0.212,  0.82]])\n    assert_allclose(out, expected, atol=0.001)\n    # scalars\n    out = irradiance.clearness_index_zenith_independent(.4, 2)\n    expected = 0.443\n    assert_allclose(out, expected, atol=0.001)\n    # series\n    times = pd.date_range(start='20180601', periods=2, freq='12H')\n    clearness_index = pd.Series([0, .5], index=times)\n    airmass = pd.Series([np.nan, 2], index=times)\n    out = irradiance.clearness_index_zenith_independent(clearness_index,\n                                                        airmass)\n    expected = pd.Series([np.nan, 0.553744437562], index=times)\n    assert_series_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_clearness_index_zenith_independent", "airmass_kt", "clearness_index", "np", "array", "1", "0", "1", "1", "clearness_index", "airmass_kt", "np", "meshgrid", "clearness_index", "airmass_kt", "out", "irradiance", "clearness_index_zenith_independent", "clearness_index", "airmass_kt", "expected", "np", "array", "0", "0", "0", "1", "1", "0", "0", "0", "138", "1", "383", "0", "0", "0", "182", "1", "822", "0", "0", "0", "212", "2", "assert_allclose", "out", "expected", "atol", "0", "001", "test", "max_clearness_index", "out", "irradiance", "clearness_index_zenith_independent", "clearness_index", "airmass_kt", "max_clearness_index", "0", "82", "expected", "np", "array", "0", "0", "0", "1", "0", "82", "0", "0", "0", "138", "0", "82", "0", "0", "0", "182", "0", "82", "0", "0", "0", "212", "0", "82", "assert_allclose", "out", "expected", "atol", "0", "001", "scalars", "out", "irradiance", "clearness_index_zenith_independent", "4", "2", "expected", "0", "443", "assert_allclose", "out", "expected", "atol", "0", "001", "series", "times", "pd", "date_range", "start", "20180601", "periods", "2", "freq", "12h", "clearness_index", "pd", "series", "0", "5", "index", "times", "airmass", "pd", "series", "np", "nan", "2", "index", "times", "out", "irradiance", "clearness_index_zenith_independent", "clearness_index", "airmass", "expected", "pd", "series", "np", "nan", "0", "553744437562", "index", "times", "assert_series_equal", "out", "expected"], "doc_len": 156}
{"doc_id": "pvlib/tests/test_irradiance.py::test_complete_irradiance", "file_path": "pvlib/tests/test_irradiance.py", "class_name": null, "func_name": "test_complete_irradiance", "text": "文件路径: pvlib/tests/test_irradiance.py\ndef test_complete_irradiance():\n    # Generate dataframe to test on\n    times = pd.date_range('2010-07-05 7:00:00-0700', periods=2, freq='H')\n    i = pd.DataFrame({'ghi': [372.103976116, 497.087579068],\n                      'dhi': [356.543700, 465.44400],\n                      'dni': [49.63565561689957, 62.10624908037814]},\n                     index=times)\n    # Define the solar position and clearsky dataframe\n    solar_position = pd.DataFrame({'apparent_zenith': [71.7303262449161,\n                                                       59.369],\n                                   'zenith': [71.7764, 59.395]},\n                                  index=pd.DatetimeIndex([\n                                      '2010-07-05 07:00:00-0700',\n                                      '2010-07-05 08:00:00-0700']))\n    clearsky = pd.DataFrame({'dni': [625.5254880160008, 778.7766443075865],\n                             'ghi': [246.3508023804681, 469.461381740857],\n                             'dhi': [50.25488725346631, 72.66909939636372]},\n                            index=pd.DatetimeIndex([\n                                '2010-07-05 07:00:00-0700',\n                                '2010-07-05 08:00:00-0700']))\n    # Test scenario where DNI is generated via component sum equation\n    complete_df = irradiance.complete_irradiance(\n        solar_position.apparent_zenith,\n        ghi=i.ghi,\n        dhi=i.dhi,\n        dni=None,\n        dni_clear=clearsky.dni)\n    # Assert that the ghi, dhi, and dni series match the original dataframe\n    # values\n    assert_frame_equal(complete_df, i)\n    # Test scenario where GHI is generated via component sum equation\n    complete_df = irradiance.complete_irradiance(\n        solar_position.apparent_zenith,\n        ghi=None,\n        dhi=i.dhi,\n        dni=i.dni,\n        dni_clear=clearsky.dni)\n    # Assert that the ghi, dhi, and dni series match the original dataframe\n    # values\n    assert_frame_equal(complete_df, i)\n    # Test scenario where DHI is generated via component sum equation\n    complete_df = irradiance.complete_irradiance(\n        solar_position.apparent_zenith,\n        ghi=i.ghi,\n        dhi=None,\n        dni=i.dni,\n        dni_clear=clearsky.dni)\n    # Assert that the ghi, dhi, and dni series match the original dataframe\n    # values\n    assert_frame_equal(complete_df, i)\n    # Test scenario where all parameters are passed (throw error)\n    with pytest.raises(ValueError):\n        irradiance.complete_irradiance(solar_position.apparent_zenith,\n                                       ghi=i.ghi,\n                                       dhi=i.dhi,\n                                       dni=i.dni,\n                                       dni_clear=clearsky.dni)\n    # Test scenario where only one parameter is passed (throw error)\n    with pytest.raises(ValueError):\n        irradiance.complete_irradiance(solar_position.apparent_zenith,\n                                       ghi=None,\n                                       dhi=None,\n                                       dni=i.dni,\n                                       dni_clear=clearsky.dni)\n", "tokens": ["pvlib", "tests", "test_irradiance", "py", "def", "test_complete_irradiance", "generate", "dataframe", "to", "test", "on", "times", "pd", "date_range", "2010", "07", "05", "7", "00", "00", "0700", "periods", "2", "freq", "h", "i", "pd", "dataframe", "ghi", "372", "103976116", "497", "087579068", "dhi", "356", "543700", "465", "44400", "dni", "49", "63565561689957", "62", "10624908037814", "index", "times", "define", "the", "solar", "position", "and", "clearsky", "dataframe", "solar_position", "pd", "dataframe", "apparent_zenith", "71", "7303262449161", "59", "369", "zenith", "71", "7764", "59", "395", "index", "pd", "datetimeindex", "2010", "07", "05", "07", "00", "00", "0700", "2010", "07", "05", "08", "00", "00", "0700", "clearsky", "pd", "dataframe", "dni", "625", "5254880160008", "778", "7766443075865", "ghi", "246", "3508023804681", "469", "461381740857", "dhi", "50", "25488725346631", "72", "66909939636372", "index", "pd", "datetimeindex", "2010", "07", "05", "07", "00", "00", "0700", "2010", "07", "05", "08", "00", "00", "0700", "test", "scenario", "where", "dni", "is", "generated", "via", "component", "sum", "equation", "complete_df", "irradiance", "complete_irradiance", "solar_position", "apparent_zenith", "ghi", "i", "ghi", "dhi", "i", "dhi", "dni", "none", "dni_clear", "clearsky", "dni", "assert", "that", "the", "ghi", "dhi", "and", "dni", "series", "match", "the", "original", "dataframe", "values", "assert_frame_equal", "complete_df", "i", "test", "scenario", "where", "ghi", "is", "generated", "via", "component", "sum", "equation", "complete_df", "irradiance", "complete_irradiance", "solar_position", "apparent_zenith", "ghi", "none", "dhi", "i", "dhi", "dni", "i", "dni", "dni_clear", "clearsky", "dni", "assert", "that", "the", "ghi", "dhi", "and", "dni", "series", "match", "the", "original", "dataframe", "values", "assert_frame_equal", "complete_df", "i", "test", "scenario", "where", "dhi", "is", "generated", "via", "component", "sum", "equation", "complete_df", "irradiance", "complete_irradiance", "solar_position", "apparent_zenith", "ghi", "i", "ghi", "dhi", "none", "dni", "i", "dni", "dni_clear", "clearsky", "dni", "assert", "that", "the", "ghi", "dhi", "and", "dni", "series", "match", "the", "original", "dataframe", "values", "assert_frame_equal", "complete_df", "i", "test", "scenario", "where", "all", "parameters", "are", "passed", "throw", "error", "with", "pytest", "raises", "valueerror", "irradiance", "complete_irradiance", "solar_position", "apparent_zenith", "ghi", "i", "ghi", "dhi", "i", "dhi", "dni", "i", "dni", "dni_clear", "clearsky", "dni", "test", "scenario", "where", "only", "one", "parameter", "is", "passed", "throw", "error", "with", "pytest", "raises", "valueerror", "irradiance", "complete_irradiance", "solar_position", "apparent_zenith", "ghi", "none", "dhi", "none", "dni", "i", "dni", "dni_clear", "clearsky", "dni"], "doc_len": 300}
{"doc_id": "pvlib/tests/test_location.py::test_location_required", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_required", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_required():\n    Location(32.2, -111)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_required", "location", "32", "2", "111"], "doc_len": 10}
{"doc_id": "pvlib/tests/test_location.py::test_location_all", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_all", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_all():\n    Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_all", "location", "32", "2", "111", "us", "arizona", "700", "tucson"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_location.py::test_location_tz", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_tz", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_tz(tz):\n    Location(32.2, -111, tz)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_tz", "tz", "location", "32", "2", "111", "tz"], "doc_len": 12}
{"doc_id": "pvlib/tests/test_location.py::test_location_invalid_tz", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_invalid_tz", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_invalid_tz():\n    with pytest.raises(UnknownTimeZoneError):\n        Location(32.2, -111, 'invalid')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_invalid_tz", "with", "pytest", "raises", "unknowntimezoneerror", "location", "32", "2", "111", "invalid"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_location.py::test_location_invalid_tz_type", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_invalid_tz_type", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_invalid_tz_type():\n    with pytest.raises(TypeError):\n        Location(32.2, -111, [5])\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_invalid_tz_type", "with", "pytest", "raises", "typeerror", "location", "32", "2", "111", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_location.py::test_location_print_all", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_print_all", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_print_all():\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    expected_str = '\\n'.join([\n        'Location: ',\n        '  name: Tucson',\n        '  latitude: 32.2',\n        '  longitude: -111',\n        '  altitude: 700',\n        '  tz: US/Arizona'\n    ])\n    assert tus.__str__() == expected_str\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_print_all", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "expected_str", "n", "join", "location", "name", "tucson", "latitude", "32", "2", "longitude", "111", "altitude", "700", "tz", "us", "arizona", "assert", "tus", "__str__", "expected_str"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_location.py::test_location_print_pytz", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_location_print_pytz", "text": "文件路径: pvlib/tests/test_location.py\ndef test_location_print_pytz():\n    tus = Location(32.2, -111, pytz.timezone('US/Arizona'), 700, 'Tucson')\n    expected_str = '\\n'.join([\n        'Location: ',\n        '  name: Tucson',\n        '  latitude: 32.2',\n        '  longitude: -111',\n        '  altitude: 700',\n        '  tz: US/Arizona'\n    ])\n    assert tus.__str__() == expected_str\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location_print_pytz", "tus", "location", "32", "2", "111", "pytz", "timezone", "us", "arizona", "700", "tucson", "expected_str", "n", "join", "location", "name", "tucson", "latitude", "32", "2", "longitude", "111", "altitude", "700", "tz", "us", "arizona", "assert", "tus", "__str__", "expected_str"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_location.py::times", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "times", "text": "文件路径: pvlib/tests/test_location.py\ndef times():\n    return pd.date_range(start='20160101T0600-0700',\n                         end='20160101T1800-0700',\n                         freq='3H')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "times", "return", "pd", "date_range", "start", "20160101t0600", "0700", "end", "20160101t1800", "0700", "freq", "3h"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky(mocker, times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    m = mocker.spy(pvlib.clearsky, 'ineichen')\n    out = tus.get_clearsky(times)\n    assert m.call_count == 1\n    assert_index_equal(out.index, times)\n    # check that values are 0 before sunrise and after sunset\n    assert out.iloc[0, :].sum().sum() == 0\n    assert out.iloc[-1:, :].sum().sum() == 0\n    # check that values are > 0 during the day\n    assert (out.iloc[1:-1, :] > 0).all().all()\n    assert (out.columns.values == ['ghi', 'dni', 'dhi']).all()\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky", "mocker", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "m", "mocker", "spy", "pvlib", "clearsky", "ineichen", "out", "tus", "get_clearsky", "times", "assert", "m", "call_count", "1", "assert_index_equal", "out", "index", "times", "check", "that", "values", "are", "0", "before", "sunrise", "and", "after", "sunset", "assert", "out", "iloc", "0", "sum", "sum", "0", "assert", "out", "iloc", "1", "sum", "sum", "0", "check", "that", "values", "are", "0", "during", "the", "day", "assert", "out", "iloc", "1", "1", "0", "all", "all", "assert", "out", "columns", "values", "ghi", "dni", "dhi", "all"], "doc_len": 83}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_ineichen_supply_linke", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_ineichen_supply_linke", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_ineichen_supply_linke(mocker):\n    tus = Location(32.2, -111, 'US/Arizona', 700)\n    times = pd.date_range(start='2014-06-24-0700', end='2014-06-25-0700',\n                          freq='3h')\n    mocker.spy(pvlib.clearsky, 'ineichen')\n    out = tus.get_clearsky(times, linke_turbidity=3)\n    # we only care that the LT is passed in this test\n    pvlib.clearsky.ineichen.assert_called_once_with(ANY, ANY, 3, ANY, ANY)\n    assert_index_equal(out.index, times)\n    # check that values are 0 before sunrise and after sunset\n    assert out.iloc[0:2, :].sum().sum() == 0\n    assert out.iloc[-2:, :].sum().sum() == 0\n    # check that values are > 0 during the day\n    assert (out.iloc[2:-2, :] > 0).all().all()\n    assert (out.columns.values == ['ghi', 'dni', 'dhi']).all()\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_ineichen_supply_linke", "mocker", "tus", "location", "32", "2", "111", "us", "arizona", "700", "times", "pd", "date_range", "start", "2014", "06", "24", "0700", "end", "2014", "06", "25", "0700", "freq", "3h", "mocker", "spy", "pvlib", "clearsky", "ineichen", "out", "tus", "get_clearsky", "times", "linke_turbidity", "3", "we", "only", "care", "that", "the", "lt", "is", "passed", "in", "this", "test", "pvlib", "clearsky", "ineichen", "assert_called_once_with", "any", "any", "3", "any", "any", "assert_index_equal", "out", "index", "times", "check", "that", "values", "are", "0", "before", "sunrise", "and", "after", "sunset", "assert", "out", "iloc", "0", "2", "sum", "sum", "0", "assert", "out", "iloc", "2", "sum", "sum", "0", "check", "that", "values", "are", "0", "during", "the", "day", "assert", "out", "iloc", "2", "2", "0", "all", "all", "assert", "out", "columns", "values", "ghi", "dni", "dhi", "all"], "doc_len": 114}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_haurwitz", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_haurwitz", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_haurwitz(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    clearsky = tus.get_clearsky(times, model='haurwitz')\n    expected = pd.DataFrame(data=np.array(\n                            [[   0.        ],\n                             [ 242.30085588],\n                             [ 559.38247117],\n                             [ 384.6873791 ],\n                             [   0.        ]]),\n                            columns=['ghi'],\n                            index=times)\n    assert_frame_equal(expected, clearsky)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_haurwitz", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "clearsky", "tus", "get_clearsky", "times", "model", "haurwitz", "expected", "pd", "dataframe", "data", "np", "array", "0", "242", "30085588", "559", "38247117", "384", "6873791", "0", "columns", "ghi", "index", "times", "assert_frame_equal", "expected", "clearsky"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_simplified_solis", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_simplified_solis", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_simplified_solis(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    clearsky = tus.get_clearsky(times, model='simplified_solis')\n    expected = pd.DataFrame(data=np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [  70.00146271,  638.01145669,  236.71136245],\n               [ 101.69729217,  852.51950946,  577.1117803 ],\n               [  86.1679965 ,  755.98048017,  385.59586091],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['dhi', 'dni', 'ghi'],\n                            index=times)\n    expected = expected[['ghi', 'dni', 'dhi']]\n    assert_frame_equal(expected, clearsky, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_simplified_solis", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "clearsky", "tus", "get_clearsky", "times", "model", "simplified_solis", "expected", "pd", "dataframe", "data", "np", "array", "0", "0", "0", "70", "00146271", "638", "01145669", "236", "71136245", "101", "69729217", "852", "51950946", "577", "1117803", "86", "1679965", "755", "98048017", "385", "59586091", "0", "0", "0", "columns", "dhi", "dni", "ghi", "index", "times", "expected", "expected", "ghi", "dni", "dhi", "assert_frame_equal", "expected", "clearsky", "check_less_precise", "2"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_simplified_solis_apparent_elevation", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_simplified_solis_apparent_elevation", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_simplified_solis_apparent_elevation(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    solar_position = {'apparent_elevation': pd.Series(80, index=times),\n                      'apparent_zenith': pd.Series(10, index=times)}\n    clearsky = tus.get_clearsky(times, model='simplified_solis',\n                                solar_position=solar_position)\n    expected = pd.DataFrame(data=np.\n        array([[  131.3124497 ,  1001.14754036,  1108.14147919],\n               [  131.3124497 ,  1001.14754036,  1108.14147919],\n               [  131.3124497 ,  1001.14754036,  1108.14147919],\n               [  131.3124497 ,  1001.14754036,  1108.14147919],\n               [  131.3124497 ,  1001.14754036,  1108.14147919]]),\n                            columns=['dhi', 'dni', 'ghi'],\n                            index=times)\n    expected = expected[['ghi', 'dni', 'dhi']]\n    assert_frame_equal(expected, clearsky, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_simplified_solis_apparent_elevation", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "solar_position", "apparent_elevation", "pd", "series", "80", "index", "times", "apparent_zenith", "pd", "series", "10", "index", "times", "clearsky", "tus", "get_clearsky", "times", "model", "simplified_solis", "solar_position", "solar_position", "expected", "pd", "dataframe", "data", "np", "array", "131", "3124497", "1001", "14754036", "1108", "14147919", "131", "3124497", "1001", "14754036", "1108", "14147919", "131", "3124497", "1001", "14754036", "1108", "14147919", "131", "3124497", "1001", "14754036", "1108", "14147919", "131", "3124497", "1001", "14754036", "1108", "14147919", "columns", "dhi", "dni", "ghi", "index", "times", "expected", "expected", "ghi", "dni", "dhi", "assert_frame_equal", "expected", "clearsky", "check_less_precise", "2"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_simplified_solis_dni_extra", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_simplified_solis_dni_extra", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_simplified_solis_dni_extra(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    clearsky = tus.get_clearsky(times, model='simplified_solis',\n                                dni_extra=1370)\n    expected = pd.DataFrame(data=np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [  67.82281485,  618.15469596,  229.34422063],\n               [  98.53217848,  825.98663808,  559.15039353],\n               [  83.48619937,  732.45218243,  373.59500313],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['dhi', 'dni', 'ghi'],\n                            index=times)\n    expected = expected[['ghi', 'dni', 'dhi']]\n    assert_frame_equal(expected, clearsky)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_simplified_solis_dni_extra", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "clearsky", "tus", "get_clearsky", "times", "model", "simplified_solis", "dni_extra", "1370", "expected", "pd", "dataframe", "data", "np", "array", "0", "0", "0", "67", "82281485", "618", "15469596", "229", "34422063", "98", "53217848", "825", "98663808", "559", "15039353", "83", "48619937", "732", "45218243", "373", "59500313", "0", "0", "0", "columns", "dhi", "dni", "ghi", "index", "times", "expected", "expected", "ghi", "dni", "dhi", "assert_frame_equal", "expected", "clearsky"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_simplified_solis_pressure", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_simplified_solis_pressure", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_simplified_solis_pressure(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    clearsky = tus.get_clearsky(times, model='simplified_solis',\n                                pressure=95000)\n    expected = pd.DataFrame(data=np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [  70.20556637,  635.53091983,  236.17716435],\n               [ 102.08954904,  850.49502085,  576.28465815],\n               [  86.46561686,  753.70744638,  384.90537859],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['dhi', 'dni', 'ghi'],\n                            index=times)\n    expected = expected[['ghi', 'dni', 'dhi']]\n    assert_frame_equal(expected, clearsky, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_simplified_solis_pressure", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "clearsky", "tus", "get_clearsky", "times", "model", "simplified_solis", "pressure", "95000", "expected", "pd", "dataframe", "data", "np", "array", "0", "0", "0", "70", "20556637", "635", "53091983", "236", "17716435", "102", "08954904", "850", "49502085", "576", "28465815", "86", "46561686", "753", "70744638", "384", "90537859", "0", "0", "0", "columns", "dhi", "dni", "ghi", "index", "times", "expected", "expected", "ghi", "dni", "dhi", "assert_frame_equal", "expected", "clearsky", "check_less_precise", "2"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_simplified_solis_aod_pw", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_simplified_solis_aod_pw", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_simplified_solis_aod_pw(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    clearsky = tus.get_clearsky(times, model='simplified_solis',\n                                aod700=0.25, precipitable_water=2.)\n    expected = pd.DataFrame(data=np.\n        array([[   0.        ,    0.        ,    0.        ],\n               [  85.77821205,  374.58084365,  179.48483117],\n               [ 143.52743364,  625.91745295,  490.06254157],\n               [ 114.63275842,  506.52275195,  312.24711495],\n               [   0.        ,    0.        ,    0.        ]]),\n                            columns=['dhi', 'dni', 'ghi'],\n                            index=times)\n    expected = expected[['ghi', 'dni', 'dhi']]\n    assert_frame_equal(expected, clearsky, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_simplified_solis_aod_pw", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "clearsky", "tus", "get_clearsky", "times", "model", "simplified_solis", "aod700", "0", "25", "precipitable_water", "2", "expected", "pd", "dataframe", "data", "np", "array", "0", "0", "0", "85", "77821205", "374", "58084365", "179", "48483117", "143", "52743364", "625", "91745295", "490", "06254157", "114", "63275842", "506", "52275195", "312", "24711495", "0", "0", "0", "columns", "dhi", "dni", "ghi", "index", "times", "expected", "expected", "ghi", "dni", "dhi", "assert_frame_equal", "expected", "clearsky", "check_less_precise", "2"], "doc_len": 73}
{"doc_id": "pvlib/tests/test_location.py::test_get_clearsky_valueerror", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_clearsky_valueerror", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_clearsky_valueerror(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    with pytest.raises(ValueError):\n        tus.get_clearsky(times, model='invalid_model')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_clearsky_valueerror", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "with", "pytest", "raises", "valueerror", "tus", "get_clearsky", "times", "model", "invalid_model"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_location.py::test_from_tmy_3", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_from_tmy_3", "text": "文件路径: pvlib/tests/test_location.py\ndef test_from_tmy_3():\n    from pvlib.tests.iotools.test_tmy import TMY3_TESTFILE\n    from pvlib.iotools import read_tmy3\n    data, meta = read_tmy3(TMY3_TESTFILE)\n    loc = Location.from_tmy(meta, data)\n    assert loc.name is not None\n    assert loc.altitude != 0\n    assert loc.tz != 'UTC'\n    assert_frame_equal(loc.weather, data)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_from_tmy_3", "from", "pvlib", "tests", "iotools", "test_tmy", "import", "tmy3_testfile", "from", "pvlib", "iotools", "import", "read_tmy3", "data", "meta", "read_tmy3", "tmy3_testfile", "loc", "location", "from_tmy", "meta", "data", "assert", "loc", "name", "is", "not", "none", "assert", "loc", "altitude", "0", "assert", "loc", "tz", "utc", "assert_frame_equal", "loc", "weather", "data"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_location.py::test_from_tmy_2", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_from_tmy_2", "text": "文件路径: pvlib/tests/test_location.py\ndef test_from_tmy_2():\n    from pvlib.tests.iotools.test_tmy import TMY2_TESTFILE\n    from pvlib.iotools import read_tmy2\n    data, meta = read_tmy2(TMY2_TESTFILE)\n    loc = Location.from_tmy(meta, data)\n    assert loc.name is not None\n    assert loc.altitude != 0\n    assert loc.tz != 'UTC'\n    assert_frame_equal(loc.weather, data)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_from_tmy_2", "from", "pvlib", "tests", "iotools", "test_tmy", "import", "tmy2_testfile", "from", "pvlib", "iotools", "import", "read_tmy2", "data", "meta", "read_tmy2", "tmy2_testfile", "loc", "location", "from_tmy", "meta", "data", "assert", "loc", "name", "is", "not", "none", "assert", "loc", "altitude", "0", "assert", "loc", "tz", "utc", "assert_frame_equal", "loc", "weather", "data"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_location.py::test_from_epw", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_from_epw", "text": "文件路径: pvlib/tests/test_location.py\ndef test_from_epw():\n    from pvlib.tests.iotools.test_epw import epw_testfile\n    from pvlib.iotools import read_epw\n    data, meta = read_epw(epw_testfile)\n    loc = Location.from_epw(meta, data)\n    assert loc.name is not None\n    assert loc.altitude != 0\n    assert loc.tz != 'UTC'\n    assert_frame_equal(loc.weather, data)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_from_epw", "from", "pvlib", "tests", "iotools", "test_epw", "import", "epw_testfile", "from", "pvlib", "iotools", "import", "read_epw", "data", "meta", "read_epw", "epw_testfile", "loc", "location", "from_epw", "meta", "data", "assert", "loc", "name", "is", "not", "none", "assert", "loc", "altitude", "0", "assert", "loc", "tz", "utc", "assert_frame_equal", "loc", "weather", "data"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_location.py::test_get_solarposition", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_solarposition", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_solarposition(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    ephem_data = golden_mst.get_solarposition(times, temperature=11)\n    ephem_data = np.round(ephem_data, 3)\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 3)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_solarposition", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "ephem_data", "golden_mst", "get_solarposition", "times", "temperature", "11", "ephem_data", "np", "round", "ephem_data", "3", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "3", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_location.py::test_get_airmass", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_airmass", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_airmass(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    airmass = tus.get_airmass(times)\n    expected = pd.DataFrame(data=np.array(\n                            [[        nan,         nan],\n                             [ 3.61046506,  3.32072602],\n                             [ 1.76470864,  1.62309115],\n                             [ 2.45582153,  2.25874238],\n                             [        nan,         nan]]),\n                            columns=['airmass_relative', 'airmass_absolute'],\n                            index=times)\n    assert_frame_equal(expected, airmass)\n\n    airmass = tus.get_airmass(times, model='young1994')\n    expected = pd.DataFrame(data=np.array(\n                            [[        nan,         nan],\n                             [ 3.6075018 ,  3.31800056],\n                             [ 1.7641033 ,  1.62253439],\n                             [ 2.45413091,  2.25718744],\n                             [        nan,         nan]]),\n                            columns=['airmass_relative', 'airmass_absolute'],\n                            index=times)\n    assert_frame_equal(expected, airmass)\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_airmass", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "airmass", "tus", "get_airmass", "times", "expected", "pd", "dataframe", "data", "np", "array", "nan", "nan", "3", "61046506", "3", "32072602", "1", "76470864", "1", "62309115", "2", "45582153", "2", "25874238", "nan", "nan", "columns", "airmass_relative", "airmass_absolute", "index", "times", "assert_frame_equal", "expected", "airmass", "airmass", "tus", "get_airmass", "times", "model", "young1994", "expected", "pd", "dataframe", "data", "np", "array", "nan", "nan", "3", "6075018", "3", "31800056", "1", "7641033", "1", "62253439", "2", "45413091", "2", "25718744", "nan", "nan", "columns", "airmass_relative", "airmass_absolute", "index", "times", "assert_frame_equal", "expected", "airmass"], "doc_len": 86}
{"doc_id": "pvlib/tests/test_location.py::test_get_airmass_valueerror", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_airmass_valueerror", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_airmass_valueerror(times):\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n    with pytest.raises(ValueError):\n        tus.get_airmass(times, model='invalid_model')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_airmass_valueerror", "times", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "with", "pytest", "raises", "valueerror", "tus", "get_airmass", "times", "model", "invalid_model"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_location.py::test_Location___repr__", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_Location___repr__", "text": "文件路径: pvlib/tests/test_location.py\ndef test_Location___repr__():\n    tus = Location(32.2, -111, 'US/Arizona', 700, 'Tucson')\n\n    expected = '\\n'.join([\n        'Location: ',\n        '  name: Tucson',\n        '  latitude: 32.2',\n        '  longitude: -111',\n        '  altitude: 700',\n        '  tz: US/Arizona'\n    ])\n    assert tus.__repr__() == expected\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_location___repr__", "tus", "location", "32", "2", "111", "us", "arizona", "700", "tucson", "expected", "n", "join", "location", "name", "tucson", "latitude", "32", "2", "longitude", "111", "altitude", "700", "tz", "us", "arizona", "assert", "tus", "__repr__", "expected"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_location.py::test_get_sun_rise_set_transit", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_sun_rise_set_transit", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_sun_rise_set_transit(golden):\n    times = pd.DatetimeIndex(['2015-01-01 07:00:00', '2015-01-01 23:00:00'],\n                             tz='MST')\n    result = golden.get_sun_rise_set_transit(times, method='pyephem')\n    assert all(result.columns == ['sunrise', 'sunset', 'transit'])\n\n    result = golden.get_sun_rise_set_transit(times, method='spa')\n    assert all(result.columns == ['sunrise', 'sunset', 'transit'])\n\n    dayofyear = 1\n    declination = declination_spencer71(dayofyear)\n    eot = equation_of_time_spencer71(dayofyear)\n    result = golden.get_sun_rise_set_transit(times, method='geometric',\n                                             declination=declination,\n                                             equation_of_time=eot)\n    assert all(result.columns == ['sunrise', 'sunset', 'transit'])\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_sun_rise_set_transit", "golden", "times", "pd", "datetimeindex", "2015", "01", "01", "07", "00", "00", "2015", "01", "01", "23", "00", "00", "tz", "mst", "result", "golden", "get_sun_rise_set_transit", "times", "method", "pyephem", "assert", "all", "result", "columns", "sunrise", "sunset", "transit", "result", "golden", "get_sun_rise_set_transit", "times", "method", "spa", "assert", "all", "result", "columns", "sunrise", "sunset", "transit", "dayofyear", "1", "declination", "declination_spencer71", "dayofyear", "eot", "equation_of_time_spencer71", "dayofyear", "result", "golden", "get_sun_rise_set_transit", "times", "method", "geometric", "declination", "declination", "equation_of_time", "eot", "assert", "all", "result", "columns", "sunrise", "sunset", "transit"], "doc_len": 75}
{"doc_id": "pvlib/tests/test_location.py::test_get_sun_rise_set_transit_valueerror", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_get_sun_rise_set_transit_valueerror", "text": "文件路径: pvlib/tests/test_location.py\ndef test_get_sun_rise_set_transit_valueerror(golden):\n    times = pd.DatetimeIndex(['2015-01-01 07:00:00', '2015-01-01 23:00:00'],\n                             tz='MST')\n    with pytest.raises(ValueError):\n        golden.get_sun_rise_set_transit(times, method='eyeball')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_get_sun_rise_set_transit_valueerror", "golden", "times", "pd", "datetimeindex", "2015", "01", "01", "07", "00", "00", "2015", "01", "01", "23", "00", "00", "tz", "mst", "with", "pytest", "raises", "valueerror", "golden", "get_sun_rise_set_transit", "times", "method", "eyeball"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_location.py::test_extra_kwargs", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_extra_kwargs", "text": "文件路径: pvlib/tests/test_location.py\ndef test_extra_kwargs():\n    with pytest.raises(TypeError, match='arbitrary_kwarg'):\n        Location(32.2, -111, arbitrary_kwarg='value')\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_extra_kwargs", "with", "pytest", "raises", "typeerror", "match", "arbitrary_kwarg", "location", "32", "2", "111", "arbitrary_kwarg", "value"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_location.py::test_lookup_altitude", "file_path": "pvlib/tests/test_location.py", "class_name": null, "func_name": "test_lookup_altitude", "text": "文件路径: pvlib/tests/test_location.py\ndef test_lookup_altitude():\n    max_alt_error = 125\n    # location name, latitude, longitude, altitude\n    test_locations = [\n        ('Tucson, USA', 32.2540, -110.9742, 724),\n        ('Lusaka, Zambia', -15.3875, 28.3228, 1253),\n        ('Tokio, Japan', 35.6762, 139.6503, 40),\n        ('Canberra, Australia', -35.2802, 149.1310, 566),\n        ('Bogota, Colombia', 4.7110, -74.0721, 2555),\n        ('Dead Sea, West Bank', 31.525849, 35.449214, -415),\n        ('New Delhi, India', 28.6139, 77.2090, 214),\n        ('Null Island,  Atlantic Ocean', 0, 0, 0),\n    ]\n\n    for name, lat, lon, expected_alt in test_locations:\n        alt_found = lookup_altitude(lat, lon)\n        assert abs(alt_found - expected_alt) < max_alt_error, \\\n            f'Max error exceded for {name} - e: {expected_alt} f: {alt_found}'\n", "tokens": ["pvlib", "tests", "test_location", "py", "def", "test_lookup_altitude", "max_alt_error", "125", "location", "name", "latitude", "longitude", "altitude", "test_locations", "tucson", "usa", "32", "2540", "110", "9742", "724", "lusaka", "zambia", "15", "3875", "28", "3228", "1253", "tokio", "japan", "35", "6762", "139", "6503", "40", "canberra", "australia", "35", "2802", "149", "1310", "566", "bogota", "colombia", "4", "7110", "74", "0721", "2555", "dead", "sea", "west", "bank", "31", "525849", "35", "449214", "415", "new", "delhi", "india", "28", "6139", "77", "2090", "214", "null", "island", "atlantic", "ocean", "0", "0", "0", "for", "name", "lat", "lon", "expected_alt", "in", "test_locations", "alt_found", "lookup_altitude", "lat", "lon", "assert", "abs", "alt_found", "expected_alt", "max_alt_error", "f", "max", "error", "exceded", "for", "name", "e", "expected_alt", "f", "alt_found"], "doc_len": 99}
{"doc_id": "pvlib/tests/test_modelchain.py::sapm_dc_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "sapm_dc_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef sapm_dc_snl_ac_system(sapm_module_params, cec_inverter_parameters,\n                          sapm_temperature_cs5p_220m):\n    module = 'Canadian_Solar_CS5P_220M___2009_'\n    module_parameters = sapm_module_params.copy()\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module=module,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=cec_inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "sapm_dc_snl_ac_system", "sapm_module_params", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module", "canadian_solar_cs5p_220m___2009_", "module_parameters", "sapm_module_params", "copy", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_modelchain.py::cec_dc_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "cec_dc_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef cec_dc_snl_ac_system(cec_module_cs5p_220m, cec_inverter_parameters,\n                         sapm_temperature_cs5p_220m):\n    module_parameters = cec_module_cs5p_220m.copy()\n    module_parameters['b'] = 0.05\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module=module_parameters['Name'],\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=cec_inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "cec_dc_snl_ac_system", "cec_module_cs5p_220m", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module_parameters", "cec_module_cs5p_220m", "copy", "module_parameters", "b", "0", "05", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module_parameters", "name", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_modelchain.py::cec_dc_snl_ac_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "cec_dc_snl_ac_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef cec_dc_snl_ac_arrays(cec_module_cs5p_220m, cec_inverter_parameters,\n                         sapm_temperature_cs5p_220m):\n    module_parameters = cec_module_cs5p_220m.copy()\n    module_parameters['b'] = 0.05\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    array_one = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=32.2, surface_azimuth=180),\n        module=module_parameters['Name'],\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    array_two = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=42.2, surface_azimuth=220),\n        module=module_parameters['Name'],\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    system = PVSystem(\n        arrays=[array_one, array_two],\n        inverter_parameters=cec_inverter_parameters\n    )\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "cec_dc_snl_ac_arrays", "cec_module_cs5p_220m", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module_parameters", "cec_module_cs5p_220m", "copy", "module_parameters", "b", "0", "05", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module_parameters", "name", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "42", "2", "surface_azimuth", "220", "module", "module_parameters", "name", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "system", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 76}
{"doc_id": "pvlib/tests/test_modelchain.py::cec_dc_native_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "cec_dc_native_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef cec_dc_native_snl_ac_system(cec_module_cs5p_220m, cec_inverter_parameters,\n                                sapm_temperature_cs5p_220m):\n    module_parameters = cec_module_cs5p_220m.copy()\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module=module_parameters['Name'],\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=cec_inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "cec_dc_native_snl_ac_system", "cec_module_cs5p_220m", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module_parameters", "cec_module_cs5p_220m", "copy", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module_parameters", "name", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_modelchain.py::pvsyst_dc_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvsyst_dc_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvsyst_dc_snl_ac_system(pvsyst_module_params, cec_inverter_parameters,\n                            sapm_temperature_cs5p_220m):\n    module = 'PVsyst test module'\n    module_parameters = pvsyst_module_params\n    module_parameters['b'] = 0.05\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module=module,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=cec_inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvsyst_dc_snl_ac_system", "pvsyst_module_params", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module", "pvsyst", "test", "module", "module_parameters", "pvsyst_module_params", "module_parameters", "b", "0", "05", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 39}
{"doc_id": "pvlib/tests/test_modelchain.py::pvsyst_dc_snl_ac_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvsyst_dc_snl_ac_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvsyst_dc_snl_ac_arrays(pvsyst_module_params, cec_inverter_parameters,\n                            sapm_temperature_cs5p_220m):\n    module = 'PVsyst test module'\n    module_parameters = pvsyst_module_params\n    module_parameters['b'] = 0.05\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    array_one = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=32.2, surface_azimuth=180),\n        module=module,\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    array_two = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=42.2, surface_azimuth=220),\n        module=module,\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    system = PVSystem(\n        arrays=[array_one, array_two],\n        inverter_parameters=cec_inverter_parameters\n    )\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvsyst_dc_snl_ac_arrays", "pvsyst_module_params", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module", "pvsyst", "test", "module", "module_parameters", "pvsyst_module_params", "module_parameters", "b", "0", "05", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "42", "2", "surface_azimuth", "220", "module", "module", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "system", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_modelchain.py::cec_dc_adr_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "cec_dc_adr_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef cec_dc_adr_ac_system(sam_data, cec_module_cs5p_220m,\n                         sapm_temperature_cs5p_220m):\n    module_parameters = cec_module_cs5p_220m.copy()\n    module_parameters['b'] = 0.05\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    inverters = sam_data['adrinverter']\n    inverter = inverters['Zigor__Sunzet_3_TL_US_240V__CEC_2011_'].copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module=module_parameters['Name'],\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "cec_dc_adr_ac_system", "sam_data", "cec_module_cs5p_220m", "sapm_temperature_cs5p_220m", "module_parameters", "cec_module_cs5p_220m", "copy", "module_parameters", "b", "0", "05", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "inverters", "sam_data", "adrinverter", "inverter", "inverters", "zigor__sunzet_3_tl_us_240v__cec_2011_", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module_parameters", "name", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter", "return", "system"], "doc_len": 52}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_snl_ac_system(cec_inverter_parameters):\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      inverter_parameters=cec_inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_snl_ac_system", "cec_inverter_parameters", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "inverter_parameters", "cec_inverter_parameters", "return", "system"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_system(sapm_temperature_cs5p_220m):\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_system", "sapm_temperature_cs5p_220m", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_system_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_system_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_system_arrays(sapm_temperature_cs5p_220m):\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    array_one = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=32.2, surface_azimuth=180),\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    array_two = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=42.2, surface_azimuth=220),\n        module_parameters=module_parameters.copy(),\n        temperature_model_parameters=temp_model_params.copy()\n    )\n    system = PVSystem(\n        arrays=[array_one, array_two], inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_system_arrays", "sapm_temperature_cs5p_220m", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "42", "2", "surface_azimuth", "220", "module_parameters", "module_parameters", "copy", "temperature_model_parameters", "temp_model_params", "copy", "system", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 65}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_faiman_temp_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_faiman_temp_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_faiman_temp_system():\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = {'u0': 25.0, 'u1': 6.84}\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_faiman_temp_system", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "u0", "25", "0", "u1", "6", "84", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_pvsyst_temp_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_pvsyst_temp_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_pvsyst_temp_system():\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = {'u_c': 29.0, 'u_v': 0.0, 'module_efficiency': 0.1,\n                         'alpha_absorption': 0.9}\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_pvsyst_temp_system", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "u_c", "29", "0", "u_v", "0", "0", "module_efficiency", "0", "1", "alpha_absorption", "0", "9", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_fuentes_temp_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_fuentes_temp_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_fuentes_temp_system():\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = {'noct_installed': 45}\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_fuentes_temp_system", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "noct_installed", "45", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_modelchain.py::pvwatts_dc_pvwatts_ac_noct_sam_temp_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "pvwatts_dc_pvwatts_ac_noct_sam_temp_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef pvwatts_dc_pvwatts_ac_noct_sam_temp_system():\n    module_parameters = {'pdc0': 220, 'gamma_pdc': -0.003}\n    temp_model_params = {'noct': 45, 'module_efficiency': 0.2}\n    inverter_parameters = {'pdc0': 220, 'eta_inv_nom': 0.95}\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "pvwatts_dc_pvwatts_ac_noct_sam_temp_system", "module_parameters", "pdc0", "220", "gamma_pdc", "0", "003", "temp_model_params", "noct", "45", "module_efficiency", "0", "2", "inverter_parameters", "pdc0", "220", "eta_inv_nom", "0", "95", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 39}
{"doc_id": "pvlib/tests/test_modelchain.py::system_no_aoi", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "system_no_aoi", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef system_no_aoi(cec_module_cs5p_220m, sapm_temperature_cs5p_220m,\n                  cec_inverter_parameters):\n    module_parameters = cec_module_cs5p_220m.copy()\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    inverter_parameters = cec_inverter_parameters.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      temperature_model_parameters=temp_model_params,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "system_no_aoi", "cec_module_cs5p_220m", "sapm_temperature_cs5p_220m", "cec_inverter_parameters", "module_parameters", "cec_module_cs5p_220m", "copy", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "inverter_parameters", "cec_inverter_parameters", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 41}
{"doc_id": "pvlib/tests/test_modelchain.py::system_no_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "system_no_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef system_no_temp(cec_module_cs5p_220m, cec_inverter_parameters):\n    module_parameters = cec_module_cs5p_220m.copy()\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    inverter_parameters = cec_inverter_parameters.copy()\n    system = PVSystem(surface_tilt=32.2, surface_azimuth=180,\n                      module_parameters=module_parameters,\n                      inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "system_no_temp", "cec_module_cs5p_220m", "cec_inverter_parameters", "module_parameters", "cec_module_cs5p_220m", "copy", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "inverter_parameters", "cec_inverter_parameters", "copy", "system", "pvsystem", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_modelchain.py::location", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "location", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef location():\n    return Location(32.2, -111, altitude=700)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "location", "return", "location", "32", "2", "111", "altitude", "700"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_modelchain.py::weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef weather():\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    weather = pd.DataFrame({'ghi': [500, 0], 'dni': [800, 0], 'dhi': [100, 0]},\n                           index=times)\n    return weather\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "weather", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "weather", "pd", "dataframe", "ghi", "500", "0", "dni", "800", "0", "dhi", "100", "0", "index", "times", "return", "weather"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_modelchain.py::total_irrad", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "total_irrad", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef total_irrad(weather):\n    return pd.DataFrame({'poa_global': [800., 500.],\n                         'poa_direct': [500., 300.],\n                         'poa_diffuse': [300., 200.]}, index=weather.index)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "total_irrad", "weather", "return", "pd", "dataframe", "poa_global", "800", "500", "poa_direct", "500", "300", "poa_diffuse", "300", "200", "index", "weather", "index"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_modelchain.py::sapm_dc_snl_ac_system_Array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "sapm_dc_snl_ac_system_Array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef sapm_dc_snl_ac_system_Array(sapm_module_params, cec_inverter_parameters,\n                                sapm_temperature_cs5p_220m):\n    module = 'Canadian_Solar_CS5P_220M___2009_'\n    module_parameters = sapm_module_params.copy()\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    array_one = pvsystem.Array(mount=pvsystem.FixedMount(surface_tilt=32,\n                                                         surface_azimuth=180),\n                               albedo=0.2, module=module,\n                               module_parameters=module_parameters,\n                               temperature_model_parameters=temp_model_params,\n                               modules_per_string=1,\n                               strings=1)\n    array_two = pvsystem.Array(mount=pvsystem.FixedMount(surface_tilt=15,\n                                                         surface_azimuth=180),\n                               albedo=0.2, module=module,\n                               module_parameters=module_parameters,\n                               temperature_model_parameters=temp_model_params,\n                               modules_per_string=1,\n                               strings=1)\n    return PVSystem(arrays=[array_one, array_two],\n                    inverter_parameters=cec_inverter_parameters)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "sapm_dc_snl_ac_system_array", "sapm_module_params", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "module", "canadian_solar_cs5p_220m___2009_", "module_parameters", "sapm_module_params", "copy", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "surface_azimuth", "180", "albedo", "0", "2", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "modules_per_string", "1", "strings", "1", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "15", "surface_azimuth", "180", "albedo", "0", "2", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "modules_per_string", "1", "strings", "1", "return", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "cec_inverter_parameters"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_modelchain.py::sapm_dc_snl_ac_system_same_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "sapm_dc_snl_ac_system_same_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef sapm_dc_snl_ac_system_same_arrays(sapm_module_params,\n                                      cec_inverter_parameters,\n                                      sapm_temperature_cs5p_220m):\n    \"\"\"A system with two identical arrays.\"\"\"\n    module = 'Canadian_Solar_CS5P_220M___2009_'\n    module_parameters = sapm_module_params.copy()\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    array_one = pvsystem.Array(mount=pvsystem.FixedMount(surface_tilt=32.2,\n                                                         surface_azimuth=180),\n                               module=module,\n                               module_parameters=module_parameters,\n                               temperature_model_parameters=temp_model_params,\n                               modules_per_string=1,\n                               strings=1)\n    array_two = pvsystem.Array(mount=pvsystem.FixedMount(surface_tilt=32.2,\n                                                         surface_azimuth=180),\n                               module=module,\n                               module_parameters=module_parameters,\n                               temperature_model_parameters=temp_model_params,\n                               modules_per_string=1,\n                               strings=1)\n    return PVSystem(arrays=[array_one, array_two],\n                    inverter_parameters=cec_inverter_parameters)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "sapm_dc_snl_ac_system_same_arrays", "sapm_module_params", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "a", "system", "with", "two", "identical", "arrays", "module", "canadian_solar_cs5p_220m___2009_", "module_parameters", "sapm_module_params", "copy", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "modules_per_string", "1", "strings", "1", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module", "module", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "modules_per_string", "1", "strings", "1", "return", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "cec_inverter_parameters"], "doc_len": 72}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_creation", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_creation", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_creation(sapm_dc_snl_ac_system, location):\n    ModelChain(sapm_dc_snl_ac_system, location)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_creation", "sapm_dc_snl_ac_system", "location", "modelchain", "sapm_dc_snl_ac_system", "location"], "doc_len": 11}
{"doc_id": "pvlib/tests/test_modelchain.py::test_with_sapm", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_with_sapm", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_with_sapm(sapm_dc_snl_ac_system, location, weather):\n    mc = ModelChain.with_sapm(sapm_dc_snl_ac_system, location)\n    assert mc.dc_model == mc.sapm\n    mc.run_model(weather)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_with_sapm", "sapm_dc_snl_ac_system", "location", "weather", "mc", "modelchain", "with_sapm", "sapm_dc_snl_ac_system", "location", "assert", "mc", "dc_model", "mc", "sapm", "mc", "run_model", "weather"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_modelchain.py::test_with_pvwatts", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_with_pvwatts", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_with_pvwatts(pvwatts_dc_pvwatts_ac_system, location, weather):\n    mc = ModelChain.with_pvwatts(pvwatts_dc_pvwatts_ac_system, location)\n    assert mc.dc_model == mc.pvwatts_dc\n    assert mc.temperature_model == mc.sapm_temp\n    mc.run_model(weather)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_with_pvwatts", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mc", "modelchain", "with_pvwatts", "pvwatts_dc_pvwatts_ac_system", "location", "assert", "mc", "dc_model", "mc", "pvwatts_dc", "assert", "mc", "temperature_model", "mc", "sapm_temp", "mc", "run_model", "weather"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_irradiance", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_irradiance", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_irradiance(sapm_dc_snl_ac_system, location):\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    irradiance = pd.DataFrame({'dni': 900, 'ghi': 600, 'dhi': 150},\n                              index=times)\n    ac = mc.run_model(irradiance).results.ac\n\n    expected = pd.Series(np.array([187.80746494643176, -0.02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_irradiance", "sapm_dc_snl_ac_system", "location", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "irradiance", "pd", "dataframe", "dni", "900", "ghi", "600", "dhi", "150", "index", "times", "ac", "mc", "run_model", "irradiance", "results", "ac", "expected", "pd", "series", "np", "array", "187", "80746494643176", "0", "02", "index", "times", "assert_series_equal", "ac", "expected"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_modelchain.py::multi_array_sapm_dc_snl_ac_system", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "multi_array_sapm_dc_snl_ac_system", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef multi_array_sapm_dc_snl_ac_system(\n        sapm_temperature_cs5p_220m, sapm_module_params,\n        cec_inverter_parameters):\n    module_parameters = sapm_module_params\n    temp_model_parameters = sapm_temperature_cs5p_220m.copy()\n    inverter_parameters = cec_inverter_parameters\n    array_one = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=32.2, surface_azimuth=180),\n        module_parameters=module_parameters,\n        temperature_model_parameters=temp_model_parameters\n    )\n    array_two = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=32.2, surface_azimuth=220),\n        module_parameters=module_parameters,\n        temperature_model_parameters=temp_model_parameters\n    )\n    two_array_system = PVSystem(\n        arrays=[array_one, array_two],\n        inverter_parameters=inverter_parameters\n    )\n    array_one_system = PVSystem(\n        arrays=[array_one],\n        inverter_parameters=inverter_parameters\n    )\n    array_two_system = PVSystem(\n        arrays=[array_two],\n        inverter_parameters=inverter_parameters\n    )\n    return {'two_array_system': two_array_system,\n            'array_one_system': array_one_system,\n            'array_two_system': array_two_system}\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "multi_array_sapm_dc_snl_ac_system", "sapm_temperature_cs5p_220m", "sapm_module_params", "cec_inverter_parameters", "module_parameters", "sapm_module_params", "temp_model_parameters", "sapm_temperature_cs5p_220m", "copy", "inverter_parameters", "cec_inverter_parameters", "array_one", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "180", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_parameters", "array_two", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "32", "2", "surface_azimuth", "220", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_parameters", "two_array_system", "pvsystem", "arrays", "array_one", "array_two", "inverter_parameters", "inverter_parameters", "array_one_system", "pvsystem", "arrays", "array_one", "inverter_parameters", "inverter_parameters", "array_two_system", "pvsystem", "arrays", "array_two", "inverter_parameters", "inverter_parameters", "return", "two_array_system", "two_array_system", "array_one_system", "array_one_system", "array_two_system", "array_two_system"], "doc_len": 72}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_irradiance_arrays_no_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_irradiance_arrays_no_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_irradiance_arrays_no_loss(\n        multi_array_sapm_dc_snl_ac_system, location):\n    mc_both = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['two_array_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    mc_one = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['array_one_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    mc_two = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['array_two_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    irradiance = pd.DataFrame({'dni': 900, 'ghi': 600, 'dhi': 150},\n                              index=times)\n    mc_one.run_model(irradiance)\n    mc_two.run_model(irradiance)\n    mc_both.run_model(irradiance)\n    assert_frame_equal(\n        mc_both.results.dc[0],\n        mc_one.results.dc\n    )\n    assert_frame_equal(\n        mc_both.results.dc[1],\n        mc_two.results.dc\n    )\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_irradiance_arrays_no_loss", "multi_array_sapm_dc_snl_ac_system", "location", "mc_both", "modelchain", "multi_array_sapm_dc_snl_ac_system", "two_array_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc_one", "modelchain", "multi_array_sapm_dc_snl_ac_system", "array_one_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc_two", "modelchain", "multi_array_sapm_dc_snl_ac_system", "array_two_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "irradiance", "pd", "dataframe", "dni", "900", "ghi", "600", "dhi", "150", "index", "times", "mc_one", "run_model", "irradiance", "mc_two", "run_model", "irradiance", "mc_both", "run_model", "irradiance", "assert_frame_equal", "mc_both", "results", "dc", "0", "mc_one", "results", "dc", "assert_frame_equal", "mc_both", "results", "dc", "1", "mc_two", "results", "dc"], "doc_len": 87}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_irradiance_arrays_no_loss_input_type", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_irradiance_arrays_no_loss_input_type", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_irradiance_arrays_no_loss_input_type(\n        multi_array_sapm_dc_snl_ac_system, location, input_type):\n    mc_both = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['two_array_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    mc_one = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['array_one_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    mc_two = ModelChain(\n        multi_array_sapm_dc_snl_ac_system['array_two_system'],\n        location,\n        aoi_model='no_loss',\n        spectral_model='no_loss',\n        losses_model='no_loss'\n    )\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    irradiance = pd.DataFrame({'dni': 900, 'ghi': 600, 'dhi': 150},\n                              index=times)\n    mc_one.run_model(irradiance)\n    mc_two.run_model(irradiance)\n    mc_both.run_model(input_type((irradiance, irradiance)))\n    assert_frame_equal(\n        mc_both.results.dc[0], mc_one.results.dc\n    )\n    assert_frame_equal(\n        mc_both.results.dc[1], mc_two.results.dc\n    )\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_irradiance_arrays_no_loss_input_type", "multi_array_sapm_dc_snl_ac_system", "location", "input_type", "mc_both", "modelchain", "multi_array_sapm_dc_snl_ac_system", "two_array_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc_one", "modelchain", "multi_array_sapm_dc_snl_ac_system", "array_one_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc_two", "modelchain", "multi_array_sapm_dc_snl_ac_system", "array_two_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "irradiance", "pd", "dataframe", "dni", "900", "ghi", "600", "dhi", "150", "index", "times", "mc_one", "run_model", "irradiance", "mc_two", "run_model", "irradiance", "mc_both", "run_model", "input_type", "irradiance", "irradiance", "assert_frame_equal", "mc_both", "results", "dc", "0", "mc_one", "results", "dc", "assert_frame_equal", "mc_both", "results", "dc", "1", "mc_two", "results", "dc"], "doc_len": 90}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_invalid_inverter_params_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_invalid_inverter_params_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_invalid_inverter_params_arrays(\n        inverter, sapm_dc_snl_ac_system_same_arrays,\n        location, adr_inverter_parameters):\n    inverter_params = {'adr': adr_inverter_parameters}\n    sapm_dc_snl_ac_system_same_arrays.inverter_parameters = \\\n        inverter_params[inverter]\n    with pytest.raises(ValueError,\n                       match=r'adr inverter function cannot'):\n        ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_invalid_inverter_params_arrays", "inverter", "sapm_dc_snl_ac_system_same_arrays", "location", "adr_inverter_parameters", "inverter_params", "adr", "adr_inverter_parameters", "sapm_dc_snl_ac_system_same_arrays", "inverter_parameters", "inverter_params", "inverter", "with", "pytest", "raises", "valueerror", "match", "r", "adr", "inverter", "function", "cannot", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_multi_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_multi_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_multi_weather(\n        sapm_dc_snl_ac_system_Array, location, input_type):\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    weather = pd.DataFrame({'ghi': 1, 'dhi': 1, 'dni': 1},\n                           index=times)\n    mc.prepare_inputs(input_type((weather, weather)))\n    num_arrays = sapm_dc_snl_ac_system_Array.num_arrays\n    assert len(mc.results.total_irrad) == num_arrays\n    # check that albedo is transfered to mc.results from mc.system.arrays\n    assert mc.results.albedo == (0.2, 0.2)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_multi_weather", "sapm_dc_snl_ac_system_array", "location", "input_type", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "weather", "pd", "dataframe", "ghi", "1", "dhi", "1", "dni", "1", "index", "times", "mc", "prepare_inputs", "input_type", "weather", "weather", "num_arrays", "sapm_dc_snl_ac_system_array", "num_arrays", "assert", "len", "mc", "results", "total_irrad", "num_arrays", "check", "that", "albedo", "is", "transfered", "to", "mc", "results", "from", "mc", "system", "arrays", "assert", "mc", "results", "albedo", "0", "2", "0", "2"], "doc_len": 71}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_albedo_in_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_albedo_in_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_albedo_in_weather(\n        sapm_dc_snl_ac_system_Array, location, input_type):\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    weather = pd.DataFrame({'ghi': 1, 'dhi': 1, 'dni': 1, 'albedo': 0.5},\n                           index=times)\n    # weather as a single DataFrame\n    mc.prepare_inputs(weather)\n    num_arrays = sapm_dc_snl_ac_system_Array.num_arrays\n    assert len(mc.results.albedo) == num_arrays\n    # repeat with tuple of weather\n    mc.prepare_inputs(input_type((weather, weather)))\n    num_arrays = sapm_dc_snl_ac_system_Array.num_arrays\n    assert len(mc.results.albedo) == num_arrays\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_albedo_in_weather", "sapm_dc_snl_ac_system_array", "location", "input_type", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "weather", "pd", "dataframe", "ghi", "1", "dhi", "1", "dni", "1", "albedo", "0", "5", "index", "times", "weather", "as", "a", "single", "dataframe", "mc", "prepare_inputs", "weather", "num_arrays", "sapm_dc_snl_ac_system_array", "num_arrays", "assert", "len", "mc", "results", "albedo", "num_arrays", "repeat", "with", "tuple", "of", "weather", "mc", "prepare_inputs", "input_type", "weather", "weather", "num_arrays", "sapm_dc_snl_ac_system_array", "num_arrays", "assert", "len", "mc", "results", "albedo", "num_arrays"], "doc_len": 76}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_no_irradiance", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_no_irradiance", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_no_irradiance(sapm_dc_snl_ac_system, location):\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    weather = pd.DataFrame()\n    with pytest.raises(ValueError):\n        mc.prepare_inputs(weather)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_no_irradiance", "sapm_dc_snl_ac_system", "location", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "weather", "pd", "dataframe", "with", "pytest", "raises", "valueerror", "mc", "prepare_inputs", "weather"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_arrays_one_missing_irradiance", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_arrays_one_missing_irradiance", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_arrays_one_missing_irradiance(\n        sapm_dc_snl_ac_system_Array, location):\n    \"\"\"If any of the input DataFrames is missing a column then a\n    ValueError is raised.\"\"\"\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    weather = pd.DataFrame(\n        {'ghi': [1], 'dhi': [1], 'dni': [1]}\n    )\n    weather_incomplete = pd.DataFrame(\n        {'ghi': [1], 'dhi': [1]}\n    )\n    with pytest.raises(ValueError,\n                       match=r\"Incomplete input data\\. .*\"):\n        mc.prepare_inputs((weather, weather_incomplete))\n    with pytest.raises(ValueError,\n                       match=r\"Incomplete input data\\. .*\"):\n        mc.prepare_inputs((weather_incomplete, weather))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_arrays_one_missing_irradiance", "sapm_dc_snl_ac_system_array", "location", "if", "any", "of", "the", "input", "dataframes", "is", "missing", "a", "column", "then", "a", "valueerror", "is", "raised", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "weather", "pd", "dataframe", "ghi", "1", "dhi", "1", "dni", "1", "weather_incomplete", "pd", "dataframe", "ghi", "1", "dhi", "1", "with", "pytest", "raises", "valueerror", "match", "r", "incomplete", "input", "data", "mc", "prepare_inputs", "weather", "weather_incomplete", "with", "pytest", "raises", "valueerror", "match", "r", "incomplete", "input", "data", "mc", "prepare_inputs", "weather_incomplete", "weather"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_weather_wrong_length", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_weather_wrong_length", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_weather_wrong_length(\n        sapm_dc_snl_ac_system_Array, location, input_type):\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    weather = pd.DataFrame({'ghi': [1], 'dhi': [1], 'dni': [1]})\n    with pytest.raises(ValueError,\n                       match=\"Input must be same length as number of Arrays \"\n                             r\"in system\\. Expected 2, got 1\\.\"):\n        mc.prepare_inputs(input_type((weather,)))\n    with pytest.raises(ValueError,\n                       match=\"Input must be same length as number of Arrays \"\n                             r\"in system\\. Expected 2, got 3\\.\"):\n        mc.prepare_inputs(input_type((weather, weather, weather)))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_weather_wrong_length", "sapm_dc_snl_ac_system_array", "location", "input_type", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "weather", "pd", "dataframe", "ghi", "1", "dhi", "1", "dni", "1", "with", "pytest", "raises", "valueerror", "match", "input", "must", "be", "same", "length", "as", "number", "of", "arrays", "r", "in", "system", "expected", "2", "got", "1", "mc", "prepare_inputs", "input_type", "weather", "with", "pytest", "raises", "valueerror", "match", "input", "must", "be", "same", "length", "as", "number", "of", "arrays", "r", "in", "system", "expected", "2", "got", "3", "mc", "prepare_inputs", "input_type", "weather", "weather", "weather"], "doc_len": 74}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_times_error_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_times_error_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_times_error_arrays(sapm_dc_snl_ac_system_Array, location):\n    \"\"\"ModelChain.times is assigned a single index given multiple weather\n    DataFrames.\n    \"\"\"\n    error_str = r\"Input DataFrames must have same index\\.\"\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    irradiance = {'ghi': [1, 2], 'dhi': [1, 2], 'dni': [1, 2]}\n    times_one = pd.date_range(start='1/1/2020', freq='6H', periods=2)\n    times_two = pd.date_range(start='1/1/2020 00:15', freq='6H', periods=2)\n    weather_one = pd.DataFrame(irradiance, index=times_one)\n    weather_two = pd.DataFrame(irradiance, index=times_two)\n    with pytest.raises(ValueError, match=error_str):\n        mc.prepare_inputs((weather_one, weather_two))\n    # test with overlapping, but differently sized indices.\n    times_three = pd.date_range(start='1/1/2020', freq='6H', periods=3)\n    irradiance_three = irradiance\n    irradiance_three['ghi'].append(3)\n    irradiance_three['dhi'].append(3)\n    irradiance_three['dni'].append(3)\n    weather_three = pd.DataFrame(irradiance_three, index=times_three)\n    with pytest.raises(ValueError, match=error_str):\n        mc.prepare_inputs((weather_one, weather_three))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_times_error_arrays", "sapm_dc_snl_ac_system_array", "location", "modelchain", "times", "is", "assigned", "a", "single", "index", "given", "multiple", "weather", "dataframes", "error_str", "r", "input", "dataframes", "must", "have", "same", "index", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "irradiance", "ghi", "1", "2", "dhi", "1", "2", "dni", "1", "2", "times_one", "pd", "date_range", "start", "1", "1", "2020", "freq", "6h", "periods", "2", "times_two", "pd", "date_range", "start", "1", "1", "2020", "00", "15", "freq", "6h", "periods", "2", "weather_one", "pd", "dataframe", "irradiance", "index", "times_one", "weather_two", "pd", "dataframe", "irradiance", "index", "times_two", "with", "pytest", "raises", "valueerror", "match", "error_str", "mc", "prepare_inputs", "weather_one", "weather_two", "test", "with", "overlapping", "but", "differently", "sized", "indices", "times_three", "pd", "date_range", "start", "1", "1", "2020", "freq", "6h", "periods", "3", "irradiance_three", "irradiance", "irradiance_three", "ghi", "append", "3", "irradiance_three", "dhi", "append", "3", "irradiance_three", "dni", "append", "3", "weather_three", "pd", "dataframe", "irradiance_three", "index", "times_three", "with", "pytest", "raises", "valueerror", "match", "error_str", "mc", "prepare_inputs", "weather_one", "weather_three"], "doc_len": 135}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_times_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_times_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_times_arrays(sapm_dc_snl_ac_system_Array, location):\n    \"\"\"ModelChain.times is assigned a single index given multiple weather\n    DataFrames.\n    \"\"\"\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    irradiance_one = {'ghi': [1, 2], 'dhi': [1, 2], 'dni': [1, 2]}\n    irradiance_two = {'ghi': [2, 1], 'dhi': [2, 1], 'dni': [2, 1]}\n    times = pd.date_range(start='1/1/2020', freq='6H', periods=2)\n    weather_one = pd.DataFrame(irradiance_one, index=times)\n    weather_two = pd.DataFrame(irradiance_two, index=times)\n    mc.prepare_inputs((weather_one, weather_two))\n    assert mc.results.times.equals(times)\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    mc.prepare_inputs(weather_one)\n    assert mc.results.times.equals(times)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_times_arrays", "sapm_dc_snl_ac_system_array", "location", "modelchain", "times", "is", "assigned", "a", "single", "index", "given", "multiple", "weather", "dataframes", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "irradiance_one", "ghi", "1", "2", "dhi", "1", "2", "dni", "1", "2", "irradiance_two", "ghi", "2", "1", "dhi", "2", "1", "dni", "2", "1", "times", "pd", "date_range", "start", "1", "1", "2020", "freq", "6h", "periods", "2", "weather_one", "pd", "dataframe", "irradiance_one", "index", "times", "weather_two", "pd", "dataframe", "irradiance_two", "index", "times", "mc", "prepare_inputs", "weather_one", "weather_two", "assert", "mc", "results", "times", "equals", "times", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "mc", "prepare_inputs", "weather_one", "assert", "mc", "results", "times", "equals", "times"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_missing_irrad_component", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_missing_irrad_component", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_missing_irrad_component(\n        sapm_dc_snl_ac_system, location, missing):\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    weather = pd.DataFrame({'dhi': [1, 2], 'dni': [1, 2], 'ghi': [1, 2]})\n    weather.drop(columns=missing, inplace=True)\n    with pytest.raises(ValueError):\n        mc.prepare_inputs(weather)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_missing_irrad_component", "sapm_dc_snl_ac_system", "location", "missing", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "weather", "pd", "dataframe", "dhi", "1", "2", "dni", "1", "2", "ghi", "1", "2", "weather", "drop", "columns", "missing", "inplace", "true", "with", "pytest", "raises", "valueerror", "mc", "prepare_inputs", "weather"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_arrays_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_arrays_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_arrays_weather(sapm_dc_snl_ac_system_same_arrays,\n                                  pvwatts_dc_pvwatts_ac_system_arrays,\n                                  location, ac_model, input_type):\n    system = {'sandia': sapm_dc_snl_ac_system_same_arrays,\n              'pvwatts': pvwatts_dc_pvwatts_ac_system_arrays}\n    mc = ModelChain(system[ac_model], location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    times = pd.date_range('20200101 1200-0700', periods=2, freq='2H')\n    weather_one = pd.DataFrame({'dni': [900, 800],\n                                'ghi': [600, 500],\n                                'dhi': [150, 100]},\n                               index=times)\n    weather_two = pd.DataFrame({'dni': [500, 400],\n                                'ghi': [300, 200],\n                                'dhi': [75, 65]},\n                               index=times)\n    mc.run_model(input_type((weather_one, weather_two)))\n    assert (mc.results.dc[0] != mc.results.dc[1]).all().all()\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_arrays_weather", "sapm_dc_snl_ac_system_same_arrays", "pvwatts_dc_pvwatts_ac_system_arrays", "location", "ac_model", "input_type", "system", "sandia", "sapm_dc_snl_ac_system_same_arrays", "pvwatts", "pvwatts_dc_pvwatts_ac_system_arrays", "mc", "modelchain", "system", "ac_model", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "times", "pd", "date_range", "20200101", "1200", "0700", "periods", "2", "freq", "2h", "weather_one", "pd", "dataframe", "dni", "900", "800", "ghi", "600", "500", "dhi", "150", "100", "index", "times", "weather_two", "pd", "dataframe", "dni", "500", "400", "ghi", "300", "200", "dhi", "75", "65", "index", "times", "mc", "run_model", "input_type", "weather_one", "weather_two", "assert", "mc", "results", "dc", "0", "mc", "results", "dc", "1", "all", "all", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 85}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_perez", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_perez", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_perez(sapm_dc_snl_ac_system, location):\n    mc = ModelChain(sapm_dc_snl_ac_system, location,\n                    transposition_model='perez')\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    irradiance = pd.DataFrame({'dni': 900, 'ghi': 600, 'dhi': 150},\n                              index=times)\n    ac = mc.run_model(irradiance).results.ac\n\n    expected = pd.Series(np.array([187.94295642, -2.00000000e-02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_perez", "sapm_dc_snl_ac_system", "location", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "transposition_model", "perez", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "irradiance", "pd", "dataframe", "dni", "900", "ghi", "600", "dhi", "150", "index", "times", "ac", "mc", "run_model", "irradiance", "results", "ac", "expected", "pd", "series", "np", "array", "187", "94295642", "2", "00000000e", "02", "index", "times", "assert_series_equal", "ac", "expected"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_gueymard_perez", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_gueymard_perez", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_gueymard_perez(sapm_dc_snl_ac_system, location):\n    mc = ModelChain(sapm_dc_snl_ac_system, location,\n                    airmass_model='gueymard1993',\n                    transposition_model='perez')\n    times = pd.date_range('20160101 1200-0700', periods=2, freq='6H')\n    irradiance = pd.DataFrame({'dni': 900, 'ghi': 600, 'dhi': 150},\n                              index=times)\n    ac = mc.run_model(irradiance).results.ac\n\n    expected = pd.Series(np.array([187.94317405, -2.00000000e-02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_gueymard_perez", "sapm_dc_snl_ac_system", "location", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "airmass_model", "gueymard1993", "transposition_model", "perez", "times", "pd", "date_range", "20160101", "1200", "0700", "periods", "2", "freq", "6h", "irradiance", "pd", "dataframe", "dni", "900", "ghi", "600", "dhi", "150", "index", "times", "ac", "mc", "run_model", "irradiance", "results", "ac", "expected", "pd", "series", "np", "array", "187", "94317405", "2", "00000000e", "02", "index", "times", "assert_series_equal", "ac", "expected"], "doc_len": 58}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_weather_sapm_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_weather_sapm_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_weather_sapm_temp(sapm_dc_snl_ac_system, location,\n                                          weather, mocker):\n    # test with sapm cell temperature model\n    weather['wind_speed'] = 5\n    weather['temp_air'] = 10\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.temperature_model = 'sapm'\n    m_sapm = mocker.spy(sapm_dc_snl_ac_system, 'get_cell_temperature')\n    mc.run_model(weather)\n    assert m_sapm.call_count == 1\n    # assert_called_once_with cannot be used with series, so need to use\n    # assert_series_equal on call_args\n    assert_series_equal(m_sapm.call_args[0][1], weather['temp_air'])  # temp\n    assert_series_equal(m_sapm.call_args[0][2], weather['wind_speed'])  # wind\n    assert m_sapm.call_args[1]['model'] == 'sapm'\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_weather_sapm_temp", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "test", "with", "sapm", "cell", "temperature", "model", "weather", "wind_speed", "5", "weather", "temp_air", "10", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "temperature_model", "sapm", "m_sapm", "mocker", "spy", "sapm_dc_snl_ac_system", "get_cell_temperature", "mc", "run_model", "weather", "assert", "m_sapm", "call_count", "1", "assert_called_once_with", "cannot", "be", "used", "with", "series", "so", "need", "to", "use", "assert_series_equal", "on", "call_args", "assert_series_equal", "m_sapm", "call_args", "0", "1", "weather", "temp_air", "temp", "assert_series_equal", "m_sapm", "call_args", "0", "2", "weather", "wind_speed", "wind", "assert", "m_sapm", "call_args", "1", "model", "sapm", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 82}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_weather_pvsyst_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_weather_pvsyst_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_weather_pvsyst_temp(sapm_dc_snl_ac_system, location,\n                                            weather, mocker):\n    # test with pvsyst cell temperature model\n    weather['wind_speed'] = 5\n    weather['temp_air'] = 10\n    sapm_dc_snl_ac_system.arrays[0].racking_model = 'freestanding'\n    sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters = \\\n        temperature._temperature_model_params('pvsyst', 'freestanding')\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.temperature_model = 'pvsyst'\n    m_pvsyst = mocker.spy(sapm_dc_snl_ac_system, 'get_cell_temperature')\n    mc.run_model(weather)\n    assert m_pvsyst.call_count == 1\n    assert_series_equal(m_pvsyst.call_args[0][1], weather['temp_air'])\n    assert_series_equal(m_pvsyst.call_args[0][2], weather['wind_speed'])\n    assert m_pvsyst.call_args[1]['model'] == 'pvsyst'\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_weather_pvsyst_temp", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "test", "with", "pvsyst", "cell", "temperature", "model", "weather", "wind_speed", "5", "weather", "temp_air", "10", "sapm_dc_snl_ac_system", "arrays", "0", "racking_model", "freestanding", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "temperature", "_temperature_model_params", "pvsyst", "freestanding", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "temperature_model", "pvsyst", "m_pvsyst", "mocker", "spy", "sapm_dc_snl_ac_system", "get_cell_temperature", "mc", "run_model", "weather", "assert", "m_pvsyst", "call_count", "1", "assert_series_equal", "m_pvsyst", "call_args", "0", "1", "weather", "temp_air", "assert_series_equal", "m_pvsyst", "call_args", "0", "2", "weather", "wind_speed", "assert", "m_pvsyst", "call_args", "1", "model", "pvsyst", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_weather_faiman_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_weather_faiman_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_weather_faiman_temp(sapm_dc_snl_ac_system, location,\n                                            weather, mocker):\n    # test with faiman cell temperature model\n    weather['wind_speed'] = 5\n    weather['temp_air'] = 10\n    sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters = {\n        'u0': 25.0, 'u1': 6.84\n    }\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.temperature_model = 'faiman'\n    m_faiman = mocker.spy(sapm_dc_snl_ac_system, 'get_cell_temperature')\n    mc.run_model(weather)\n    assert m_faiman.call_count == 1\n    assert_series_equal(m_faiman.call_args[0][1], weather['temp_air'])\n    assert_series_equal(m_faiman.call_args[0][2], weather['wind_speed'])\n    assert m_faiman.call_args[1]['model'] == 'faiman'\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_weather_faiman_temp", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "test", "with", "faiman", "cell", "temperature", "model", "weather", "wind_speed", "5", "weather", "temp_air", "10", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "u0", "25", "0", "u1", "6", "84", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "temperature_model", "faiman", "m_faiman", "mocker", "spy", "sapm_dc_snl_ac_system", "get_cell_temperature", "mc", "run_model", "weather", "assert", "m_faiman", "call_count", "1", "assert_series_equal", "m_faiman", "call_args", "0", "1", "weather", "temp_air", "assert_series_equal", "m_faiman", "call_args", "0", "2", "weather", "wind_speed", "assert", "m_faiman", "call_args", "1", "model", "faiman", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_weather_fuentes_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_weather_fuentes_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_weather_fuentes_temp(sapm_dc_snl_ac_system, location,\n                                             weather, mocker):\n    weather['wind_speed'] = 5\n    weather['temp_air'] = 10\n    sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters = {\n        'noct_installed': 45, 'surface_tilt': 30,\n    }\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.temperature_model = 'fuentes'\n    m_fuentes = mocker.spy(sapm_dc_snl_ac_system, 'get_cell_temperature')\n    mc.run_model(weather)\n    assert m_fuentes.call_count == 1\n    assert_series_equal(m_fuentes.call_args[0][1], weather['temp_air'])\n    assert_series_equal(m_fuentes.call_args[0][2], weather['wind_speed'])\n    assert m_fuentes.call_args[1]['model'] == 'fuentes'\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_weather_fuentes_temp", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "weather", "wind_speed", "5", "weather", "temp_air", "10", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "noct_installed", "45", "surface_tilt", "30", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "temperature_model", "fuentes", "m_fuentes", "mocker", "spy", "sapm_dc_snl_ac_system", "get_cell_temperature", "mc", "run_model", "weather", "assert", "m_fuentes", "call_count", "1", "assert_series_equal", "m_fuentes", "call_args", "0", "1", "weather", "temp_air", "assert_series_equal", "m_fuentes", "call_args", "0", "2", "weather", "wind_speed", "assert", "m_fuentes", "call_args", "1", "model", "fuentes", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_with_weather_noct_sam_temp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_with_weather_noct_sam_temp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_with_weather_noct_sam_temp(sapm_dc_snl_ac_system, location,\n                                              weather, mocker):\n    weather['wind_speed'] = 5\n    weather['temp_air'] = 10\n    sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters = {\n        'noct': 45, 'module_efficiency': 0.2\n    }\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.temperature_model = 'noct_sam'\n    m_noct_sam = mocker.spy(sapm_dc_snl_ac_system, 'get_cell_temperature')\n    mc.run_model(weather)\n    assert m_noct_sam.call_count == 1\n    assert_series_equal(m_noct_sam.call_args[0][1], weather['temp_air'])\n    assert_series_equal(m_noct_sam.call_args[0][2], weather['wind_speed'])\n    # check that effective_irradiance was used\n    assert m_noct_sam.call_args[1] == {\n        'effective_irradiance': mc.results.effective_irradiance,\n        'model': 'noct_sam'}\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_with_weather_noct_sam_temp", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "weather", "wind_speed", "5", "weather", "temp_air", "10", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "noct", "45", "module_efficiency", "0", "2", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "temperature_model", "noct_sam", "m_noct_sam", "mocker", "spy", "sapm_dc_snl_ac_system", "get_cell_temperature", "mc", "run_model", "weather", "assert", "m_noct_sam", "call_count", "1", "assert_series_equal", "m_noct_sam", "call_args", "0", "1", "weather", "temp_air", "assert_series_equal", "m_noct_sam", "call_args", "0", "2", "weather", "wind_speed", "check", "that", "effective_irradiance", "was", "used", "assert", "m_noct_sam", "call_args", "1", "effective_irradiance", "mc", "results", "effective_irradiance", "model", "noct_sam"], "doc_len": 73}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_tracker", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_tracker", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_tracker(sapm_dc_snl_ac_system, location, weather, mocker):\n    with pytest.warns(pvlibDeprecationWarning):\n        system = SingleAxisTracker(\n            module_parameters=sapm_dc_snl_ac_system.arrays[0].module_parameters,  # noqa: E501\n            temperature_model_parameters=(\n                sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters\n            ),\n            inverter_parameters=sapm_dc_snl_ac_system.inverter_parameters)\n    mocker.spy(system, 'singleaxis')\n    mc = ModelChain(system, location)\n    mc.run_model(weather)\n    assert system.singleaxis.call_count == 1\n    assert (mc.results.tracking.columns == ['tracker_theta',\n                                            'aoi',\n                                            'surface_azimuth',\n                                            'surface_tilt']).all()\n    assert mc.results.ac[0] > 0\n    assert np.isnan(mc.results.ac[1])\n    assert isinstance(mc.results.dc, pd.DataFrame)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_tracker", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "singleaxistracker", "module_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "module_parameters", "noqa", "e501", "temperature_model_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "inverter_parameters", "sapm_dc_snl_ac_system", "inverter_parameters", "mocker", "spy", "system", "singleaxis", "mc", "modelchain", "system", "location", "mc", "run_model", "weather", "assert", "system", "singleaxis", "call_count", "1", "assert", "mc", "results", "tracking", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "all", "assert", "mc", "results", "ac", "0", "0", "assert", "np", "isnan", "mc", "results", "ac", "1", "assert", "isinstance", "mc", "results", "dc", "pd", "dataframe"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_tracker_list", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_tracker_list", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_tracker_list(\n        sapm_dc_snl_ac_system, location, weather, mocker):\n    with pytest.warns(pvlibDeprecationWarning):\n        system = SingleAxisTracker(\n            module_parameters=sapm_dc_snl_ac_system.arrays[0].module_parameters,  # noqa: E501\n            temperature_model_parameters=(\n                sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters\n            ),\n            inverter_parameters=sapm_dc_snl_ac_system.inverter_parameters)\n    mocker.spy(system, 'singleaxis')\n    mc = ModelChain(system, location)\n    mc.run_model([weather])\n    assert system.singleaxis.call_count == 1\n    assert (mc.results.tracking.columns == ['tracker_theta',\n                                            'aoi',\n                                            'surface_azimuth',\n                                            'surface_tilt']).all()\n    assert mc.results.ac[0] > 0\n    assert np.isnan(mc.results.ac[1])\n    assert isinstance(mc.results.dc, tuple)\n    assert len(mc.results.dc) == 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_tracker_list", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "singleaxistracker", "module_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "module_parameters", "noqa", "e501", "temperature_model_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "inverter_parameters", "sapm_dc_snl_ac_system", "inverter_parameters", "mocker", "spy", "system", "singleaxis", "mc", "modelchain", "system", "location", "mc", "run_model", "weather", "assert", "system", "singleaxis", "call_count", "1", "assert", "mc", "results", "tracking", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "all", "assert", "mc", "results", "ac", "0", "0", "assert", "np", "isnan", "mc", "results", "ac", "1", "assert", "isinstance", "mc", "results", "dc", "tuple", "assert", "len", "mc", "results", "dc", "1"], "doc_len": 82}
{"doc_id": "pvlib/tests/test_modelchain.py::test__assign_total_irrad", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test__assign_total_irrad", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test__assign_total_irrad(sapm_dc_snl_ac_system, location, weather,\n                             total_irrad):\n    data = pd.concat([weather, total_irrad], axis=1)\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc._assign_total_irrad(data)\n    assert_frame_equal(mc.results.total_irrad, total_irrad)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test__assign_total_irrad", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "data", "pd", "concat", "weather", "total_irrad", "axis", "1", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "_assign_total_irrad", "data", "assert_frame_equal", "mc", "results", "total_irrad", "total_irrad"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_from_poa", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_from_poa", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_from_poa(sapm_dc_snl_ac_system, location,\n                                 weather, total_irrad):\n    data = pd.concat([weather, total_irrad], axis=1)\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.prepare_inputs_from_poa(data)\n    weather_expected = weather.copy()\n    weather_expected['temp_air'] = 20\n    weather_expected['wind_speed'] = 0\n    # order as expected\n    weather_expected = weather_expected[\n        ['ghi', 'dhi', 'dni', 'wind_speed', 'temp_air']]\n    # weather attribute\n    assert_frame_equal(mc.results.weather, weather_expected)\n    # total_irrad attribute\n    assert_frame_equal(mc.results.total_irrad, total_irrad)\n    assert not pd.isnull(mc.results.solar_position.index[0])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_from_poa", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "data", "pd", "concat", "weather", "total_irrad", "axis", "1", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "prepare_inputs_from_poa", "data", "weather_expected", "weather", "copy", "weather_expected", "temp_air", "20", "weather_expected", "wind_speed", "0", "order", "as", "expected", "weather_expected", "weather_expected", "ghi", "dhi", "dni", "wind_speed", "temp_air", "weather", "attribute", "assert_frame_equal", "mc", "results", "weather", "weather_expected", "total_irrad", "attribute", "assert_frame_equal", "mc", "results", "total_irrad", "total_irrad", "assert", "not", "pd", "isnull", "mc", "results", "solar_position", "index", "0"], "doc_len": 66}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_from_poa_multi_data", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_from_poa_multi_data", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_from_poa_multi_data(\n        sapm_dc_snl_ac_system_Array, location, total_irrad, weather,\n        input_type):\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    poa = pd.concat([weather, total_irrad], axis=1)\n    mc.prepare_inputs_from_poa(input_type((poa, poa)))\n    num_arrays = sapm_dc_snl_ac_system_Array.num_arrays\n    assert len(mc.results.total_irrad) == num_arrays\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_from_poa_multi_data", "sapm_dc_snl_ac_system_array", "location", "total_irrad", "weather", "input_type", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "poa", "pd", "concat", "weather", "total_irrad", "axis", "1", "mc", "prepare_inputs_from_poa", "input_type", "poa", "poa", "num_arrays", "sapm_dc_snl_ac_system_array", "num_arrays", "assert", "len", "mc", "results", "total_irrad", "num_arrays"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_from_poa_wrong_number_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_from_poa_wrong_number_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_from_poa_wrong_number_arrays(\n        sapm_dc_snl_ac_system_Array, location, total_irrad, weather,\n        input_type):\n    len_error = r\"Input must be same length as number of Arrays in system\\. \" \\\n                r\"Expected 2, got [0-9]+\\.\"\n    type_error = r\"Input must be a tuple of length 2, got .*\\.\"\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    poa = pd.concat([weather, total_irrad], axis=1)\n    with pytest.raises(TypeError, match=type_error):\n        mc.prepare_inputs_from_poa(poa)\n    with pytest.raises(ValueError, match=len_error):\n        mc.prepare_inputs_from_poa(input_type((poa,)))\n    with pytest.raises(ValueError, match=len_error):\n        mc.prepare_inputs_from_poa(input_type((poa, poa, poa)))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_from_poa_wrong_number_arrays", "sapm_dc_snl_ac_system_array", "location", "total_irrad", "weather", "input_type", "len_error", "r", "input", "must", "be", "same", "length", "as", "number", "of", "arrays", "in", "system", "r", "expected", "2", "got", "0", "9", "type_error", "r", "input", "must", "be", "a", "tuple", "of", "length", "2", "got", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "poa", "pd", "concat", "weather", "total_irrad", "axis", "1", "with", "pytest", "raises", "typeerror", "match", "type_error", "mc", "prepare_inputs_from_poa", "poa", "with", "pytest", "raises", "valueerror", "match", "len_error", "mc", "prepare_inputs_from_poa", "input_type", "poa", "with", "pytest", "raises", "valueerror", "match", "len_error", "mc", "prepare_inputs_from_poa", "input_type", "poa", "poa", "poa"], "doc_len": 83}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_from_poa_arrays_different_indices", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_from_poa_arrays_different_indices", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_from_poa_arrays_different_indices(\n        sapm_dc_snl_ac_system_Array, location, total_irrad, weather):\n    error_str = r\"Input DataFrames must have same index\\.\"\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    poa = pd.concat([weather, total_irrad], axis=1)\n    with pytest.raises(ValueError, match=error_str):\n        mc.prepare_inputs_from_poa((poa, poa.shift(periods=1, freq='6H')))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_from_poa_arrays_different_indices", "sapm_dc_snl_ac_system_array", "location", "total_irrad", "weather", "error_str", "r", "input", "dataframes", "must", "have", "same", "index", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "poa", "pd", "concat", "weather", "total_irrad", "axis", "1", "with", "pytest", "raises", "valueerror", "match", "error_str", "mc", "prepare_inputs_from_poa", "poa", "poa", "shift", "periods", "1", "freq", "6h"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_modelchain.py::test_prepare_inputs_from_poa_arrays_missing_column", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_prepare_inputs_from_poa_arrays_missing_column", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_prepare_inputs_from_poa_arrays_missing_column(\n        sapm_dc_snl_ac_system_Array, location, weather, total_irrad):\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    poa = pd.concat([weather, total_irrad], axis=1)\n    with pytest.raises(ValueError, match=r\"Incomplete input data\\. \"\n                                         r\"Data needs to contain .*\\. \"\n                                         r\"Detected data in element 1 \"\n                                         r\"contains: .*\"):\n        mc.prepare_inputs_from_poa((poa, poa.drop(columns='poa_global')))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_prepare_inputs_from_poa_arrays_missing_column", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "poa", "pd", "concat", "weather", "total_irrad", "axis", "1", "with", "pytest", "raises", "valueerror", "match", "r", "incomplete", "input", "data", "r", "data", "needs", "to", "contain", "r", "detected", "data", "in", "element", "1", "r", "contains", "mc", "prepare_inputs_from_poa", "poa", "poa", "drop", "columns", "poa_global"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_modelchain.py::test__prepare_temperature", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test__prepare_temperature", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test__prepare_temperature(sapm_dc_snl_ac_system, location, weather,\n                              total_irrad):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    # prepare_temperature expects mc.total_irrad and mc.results.weather\n    # to be set\n    mc._assign_weather(data)\n    mc._assign_total_irrad(data)\n    mc._prepare_temperature(data)\n    expected = pd.Series([48.928025, 38.080016], index=data.index)\n    assert_series_equal(mc.results.cell_temperature, expected)\n    data['module_temperature'] = [40., 30.]\n    mc._prepare_temperature(data)\n    expected = pd.Series([42.4, 31.5], index=data.index)\n    assert_series_equal(mc.results.cell_temperature, expected)\n    data['cell_temperature'] = [50., 35.]\n    mc._prepare_temperature(data)\n    assert_series_equal(mc.results.cell_temperature, data['cell_temperature'])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test__prepare_temperature", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "prepare_temperature", "expects", "mc", "total_irrad", "and", "mc", "results", "weather", "to", "be", "set", "mc", "_assign_weather", "data", "mc", "_assign_total_irrad", "data", "mc", "_prepare_temperature", "data", "expected", "pd", "series", "48", "928025", "38", "080016", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "expected", "data", "module_temperature", "40", "30", "mc", "_prepare_temperature", "data", "expected", "pd", "series", "42", "4", "31", "5", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "expected", "data", "cell_temperature", "50", "35", "mc", "_prepare_temperature", "data", "assert_series_equal", "mc", "results", "cell_temperature", "data", "cell_temperature"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_modelchain.py::test__prepare_temperature_len1_weather_tuple", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test__prepare_temperature_len1_weather_tuple", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test__prepare_temperature_len1_weather_tuple(\n        sapm_dc_snl_ac_system, location, weather, total_irrad):\n    # GH 1192\n    weather['module_temperature'] = [40., 30.]\n    data = weather.copy()\n\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    mc.run_model([data])\n    expected = pd.Series([42.617244212941394, 30.0], index=data.index)\n    assert_series_equal(mc.results.cell_temperature[0], expected)\n\n    data = weather.copy().rename(\n        columns={\n            \"ghi\": \"poa_global\", \"dhi\": \"poa_diffuse\", \"dni\": \"poa_direct\"}\n    )\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    mc.run_model_from_poa([data])\n    expected = pd.Series([41.5, 30.0], index=data.index)\n    assert_series_equal(mc.results.cell_temperature[0], expected)\n\n    data = weather.copy()[[\"module_temperature\", \"ghi\"]].rename(\n        columns={\"ghi\": \"effective_irradiance\"}\n    )\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    mc.run_model_from_effective_irradiance([data])\n    expected = pd.Series([41.5, 30.0], index=data.index)\n    assert_series_equal(mc.results.cell_temperature[0], expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test__prepare_temperature_len1_weather_tuple", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "gh", "1192", "weather", "module_temperature", "40", "30", "data", "weather", "copy", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model", "data", "expected", "pd", "series", "42", "617244212941394", "30", "0", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "0", "expected", "data", "weather", "copy", "rename", "columns", "ghi", "poa_global", "dhi", "poa_diffuse", "dni", "poa_direct", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model_from_poa", "data", "expected", "pd", "series", "41", "5", "30", "0", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "0", "expected", "data", "weather", "copy", "module_temperature", "ghi", "rename", "columns", "ghi", "effective_irradiance", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model_from_effective_irradiance", "data", "expected", "pd", "series", "41", "5", "30", "0", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "0", "expected"], "doc_len": 120}
{"doc_id": "pvlib/tests/test_modelchain.py::test__prepare_temperature_arrays_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test__prepare_temperature_arrays_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test__prepare_temperature_arrays_weather(sapm_dc_snl_ac_system_same_arrays,\n                                             location, weather,\n                                             total_irrad):\n    data = weather.copy()\n    data[['poa_global', 'poa_direct', 'poa_diffuse']] = total_irrad\n    data_two = data.copy()\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    # prepare_temperature expects mc.results.total_irrad and mc.results.weather\n    # to be set\n    mc._assign_weather((data, data_two))\n    mc._assign_total_irrad((data, data_two))\n    mc._prepare_temperature((data, data_two))\n    expected = pd.Series([48.928025, 38.080016], index=data.index)\n    assert_series_equal(mc.results.cell_temperature[0], expected)\n    assert_series_equal(mc.results.cell_temperature[1], expected)\n    data['module_temperature'] = [40., 30.]\n    mc._prepare_temperature((data, data_two))\n    expected = pd.Series([42.4, 31.5], index=data.index)\n    assert (mc.results.cell_temperature[1] != expected).all()\n    assert_series_equal(mc.results.cell_temperature[0], expected)\n    data['cell_temperature'] = [50., 35.]\n    mc._prepare_temperature((data, data_two))\n    assert_series_equal(\n        mc.results.cell_temperature[0], data['cell_temperature'])\n    data_two['module_temperature'] = [40., 30.]\n    mc._prepare_temperature((data, data_two))\n    assert_series_equal(mc.results.cell_temperature[1], expected)\n    assert_series_equal(\n        mc.results.cell_temperature[0], data['cell_temperature'])\n    data_two['cell_temperature'] = [10.0, 20.0]\n    mc._prepare_temperature((data, data_two))\n    assert_series_equal(\n        mc.results.cell_temperature[1], data_two['cell_temperature'])\n    assert_series_equal(\n        mc.results.cell_temperature[0], data['cell_temperature'])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test__prepare_temperature_arrays_weather", "sapm_dc_snl_ac_system_same_arrays", "location", "weather", "total_irrad", "data", "weather", "copy", "data", "poa_global", "poa_direct", "poa_diffuse", "total_irrad", "data_two", "data", "copy", "mc", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "prepare_temperature", "expects", "mc", "results", "total_irrad", "and", "mc", "results", "weather", "to", "be", "set", "mc", "_assign_weather", "data", "data_two", "mc", "_assign_total_irrad", "data", "data_two", "mc", "_prepare_temperature", "data", "data_two", "expected", "pd", "series", "48", "928025", "38", "080016", "index", "data", "index", "assert_series_equal", "mc", "results", "cell_temperature", "0", "expected", "assert_series_equal", "mc", "results", "cell_temperature", "1", "expected", "data", "module_temperature", "40", "30", "mc", "_prepare_temperature", "data", "data_two", "expected", "pd", "series", "42", "4", "31", "5", "index", "data", "index", "assert", "mc", "results", "cell_temperature", "1", "expected", "all", "assert_series_equal", "mc", "results", "cell_temperature", "0", "expected", "data", "cell_temperature", "50", "35", "mc", "_prepare_temperature", "data", "data_two", "assert_series_equal", "mc", "results", "cell_temperature", "0", "data", "cell_temperature", "data_two", "module_temperature", "40", "30", "mc", "_prepare_temperature", "data", "data_two", "assert_series_equal", "mc", "results", "cell_temperature", "1", "expected", "assert_series_equal", "mc", "results", "cell_temperature", "0", "data", "cell_temperature", "data_two", "cell_temperature", "10", "0", "20", "0", "mc", "_prepare_temperature", "data", "data_two", "assert_series_equal", "mc", "results", "cell_temperature", "1", "data_two", "cell_temperature", "assert_series_equal", "mc", "results", "cell_temperature", "0", "data", "cell_temperature"], "doc_len": 166}
{"doc_id": "pvlib/tests/test_modelchain.py::test_temperature_models_arrays_multi_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_temperature_models_arrays_multi_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_temperature_models_arrays_multi_weather(\n        temp_params, temp_model,\n        sapm_dc_snl_ac_system_same_arrays,\n        location, weather, total_irrad):\n    for array in sapm_dc_snl_ac_system_same_arrays.arrays:\n        array.temperature_model_parameters = temp_params\n    # set air temp so it does not default to the same value for both arrays\n    weather['temp_air'] = 25\n    weather_one = weather\n    weather_two = weather.copy() * 0.5\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    mc.prepare_inputs((weather_one, weather_two))\n    temp_model(mc)\n    assert (mc.results.cell_temperature[0]\n            != mc.results.cell_temperature[1]).all()\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_temperature_models_arrays_multi_weather", "temp_params", "temp_model", "sapm_dc_snl_ac_system_same_arrays", "location", "weather", "total_irrad", "for", "array", "in", "sapm_dc_snl_ac_system_same_arrays", "arrays", "array", "temperature_model_parameters", "temp_params", "set", "air", "temp", "so", "it", "does", "not", "default", "to", "the", "same", "value", "for", "both", "arrays", "weather", "temp_air", "25", "weather_one", "weather", "weather_two", "weather", "copy", "0", "5", "mc", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "prepare_inputs", "weather_one", "weather_two", "temp_model", "mc", "assert", "mc", "results", "cell_temperature", "0", "mc", "results", "cell_temperature", "1", "all"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_solar_position_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_solar_position_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_solar_position_weather(\n        pvwatts_dc_pvwatts_ac_system, location, weather, mocker):\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    weather['pressure'] = 90000\n    weather['temp_air'] = 25\n    m = mocker.spy(location, 'get_solarposition')\n    mc.run_model(weather)\n    # assert_called_once_with cannot be used with series, so need to use\n    # assert_series_equal on call_args\n    assert_series_equal(m.call_args[1]['temperature'], weather['temp_air'])\n    assert_series_equal(m.call_args[1]['pressure'], weather['pressure'])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_solar_position_weather", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "weather", "pressure", "90000", "weather", "temp_air", "25", "m", "mocker", "spy", "location", "get_solarposition", "mc", "run_model", "weather", "assert_called_once_with", "cannot", "be", "used", "with", "series", "so", "need", "to", "use", "assert_series_equal", "on", "call_args", "assert_series_equal", "m", "call_args", "1", "temperature", "weather", "temp_air", "assert_series_equal", "m", "call_args", "1", "pressure", "weather", "pressure"], "doc_len": 59}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_poa", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_poa", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_poa(sapm_dc_snl_ac_system, location, total_irrad):\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_poa(total_irrad).results.ac\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=total_irrad.index)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_poa", "sapm_dc_snl_ac_system", "location", "total_irrad", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_poa", "total_irrad", "results", "ac", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "total_irrad", "index", "assert_series_equal", "ac", "expected"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_poa_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_poa_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_poa_arrays(sapm_dc_snl_ac_system_Array, location,\n                                   weather, total_irrad, input_type):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    mc.run_model_from_poa(input_type((data, data)))\n    # arrays have different orientation, but should give same dc power\n    # because we are the same passing POA irradiance and air\n    # temperature.\n    assert_frame_equal(mc.results.dc[0], mc.results.dc[1])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_poa_arrays", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model_from_poa", "input_type", "data", "data", "arrays", "have", "different", "orientation", "but", "should", "give", "same", "dc", "power", "because", "we", "are", "the", "same", "passing", "poa", "irradiance", "and", "air", "temperature", "assert_frame_equal", "mc", "results", "dc", "0", "mc", "results", "dc", "1"], "doc_len": 62}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_poa_arrays_solar_position_weather", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_poa_arrays_solar_position_weather", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_poa_arrays_solar_position_weather(\n        sapm_dc_snl_ac_system_Array, location, weather, total_irrad, mocker):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['pressure'] = 90000\n    data['temp_air'] = 25\n    data2 = data.copy()\n    data2['pressure'] = 95000\n    data2['temp_air'] = 30\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    m = mocker.spy(location, 'get_solarposition')\n    mc.run_model_from_poa((data, data2))\n    # mc uses only the first weather data for solar position corrections\n    assert_series_equal(m.call_args[1]['temperature'], data['temp_air'])\n    assert_series_equal(m.call_args[1]['pressure'], data['pressure'])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_poa_arrays_solar_position_weather", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "mocker", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "pressure", "90000", "data", "temp_air", "25", "data2", "data", "copy", "data2", "pressure", "95000", "data2", "temp_air", "30", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "m", "mocker", "spy", "location", "get_solarposition", "mc", "run_model_from_poa", "data", "data2", "mc", "uses", "only", "the", "first", "weather", "data", "for", "solar", "position", "corrections", "assert_series_equal", "m", "call_args", "1", "temperature", "data", "temp_air", "assert_series_equal", "m", "call_args", "1", "pressure", "data", "pressure"], "doc_len": 76}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_poa_tracking", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_poa_tracking", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_poa_tracking(sapm_dc_snl_ac_system, location,\n                                     total_irrad):\n    with pytest.warns(pvlibDeprecationWarning):\n        system = SingleAxisTracker(\n            module_parameters=sapm_dc_snl_ac_system.arrays[0].module_parameters,  # noqa: E501\n            temperature_model_parameters=(\n                sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters\n            ),\n            inverter_parameters=sapm_dc_snl_ac_system.inverter_parameters)\n    mc = ModelChain(system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_poa(total_irrad).results.ac\n    assert (mc.results.tracking.columns == ['tracker_theta',\n                                            'aoi',\n                                            'surface_azimuth',\n                                            'surface_tilt']).all()\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=total_irrad.index)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_poa_tracking", "sapm_dc_snl_ac_system", "location", "total_irrad", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "singleaxistracker", "module_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "module_parameters", "noqa", "e501", "temperature_model_parameters", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "inverter_parameters", "sapm_dc_snl_ac_system", "inverter_parameters", "mc", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_poa", "total_irrad", "results", "ac", "assert", "mc", "results", "tracking", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "all", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "total_irrad", "index", "assert_series_equal", "ac", "expected"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance(sapm_dc_snl_ac_system, location,\n                                             weather, total_irrad, input_type):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effective_irradiance'] = data['poa_global']\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_effective_irradiance(input_type((data,))).results.ac\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=data.index)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effective_irradiance", "data", "poa_global", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_effective_irradiance", "input_type", "data", "results", "ac", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "data", "index", "assert_series_equal", "ac", "expected"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_multi_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_multi_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_multi_array(\n        sapm_dc_snl_ac_system_Array, location, weather, total_irrad,\n        input_type):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effective_irradiance'] = data['poa_global']\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    mc.run_model_from_effective_irradiance(input_type((data, data)))\n    # arrays have different orientation, but should give same dc power\n    # because we are the same passing POA irradiance and air\n    # temperature.\n    assert_frame_equal(mc.results.dc[0], mc.results.dc[1])\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_multi_array", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effective_irradiance", "data", "poa_global", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model_from_effective_irradiance", "input_type", "data", "data", "arrays", "have", "different", "orientation", "but", "should", "give", "same", "dc", "power", "because", "we", "are", "the", "same", "passing", "poa", "irradiance", "and", "air", "temperature", "assert_frame_equal", "mc", "results", "dc", "0", "mc", "results", "dc", "1"], "doc_len": 66}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_no_poa_global", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_no_poa_global", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_no_poa_global(\n        sapm_dc_snl_ac_system, location, weather, total_irrad, input_type):\n    data = weather.copy()\n    data['effective_irradiance'] = total_irrad['poa_global']\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_effective_irradiance(input_type((data,))).results.ac\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=data.index)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_no_poa_global", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "effective_irradiance", "total_irrad", "poa_global", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_effective_irradiance", "input_type", "data", "results", "ac", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "data", "index", "assert_series_equal", "ac", "expected"], "doc_len": 48}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_poa_global_differs", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_poa_global_differs", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_poa_global_differs(\n        sapm_dc_snl_ac_system, location, weather, total_irrad):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effective_irradiance'] = data['poa_global'] * 0.8\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_effective_irradiance(data).results.ac\n    expected = pd.Series(np.array([118.302801, 76.099841]),\n                         index=data.index)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_poa_global_differs", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effective_irradiance", "data", "poa_global", "0", "8", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_effective_irradiance", "data", "results", "ac", "expected", "pd", "series", "np", "array", "118", "302801", "76", "099841", "index", "data", "index", "assert_series_equal", "ac", "expected"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_arrays_error", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_arrays_error", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_arrays_error(\n        sapm_dc_snl_ac_system_Array, location, weather, total_irrad,\n        input_type):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effetive_irradiance'] = data['poa_global']\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    len_error = r\"Input must be same length as number of Arrays in system\\. \" \\\n                r\"Expected 2, got [0-9]+\\.\"\n    type_error = r\"Input must be a tuple of length 2, got DataFrame\\.\"\n    with pytest.raises(TypeError, match=type_error):\n        mc.run_model_from_effective_irradiance(data)\n    with pytest.raises(ValueError, match=len_error):\n        mc.run_model_from_effective_irradiance(input_type((data,)))\n    with pytest.raises(ValueError, match=len_error):\n        mc.run_model_from_effective_irradiance(input_type((data, data, data)))\n    with pytest.raises(ValueError,\n                       match=r\"Input DataFrames must have same index\\.\"):\n        mc.run_model_from_effective_irradiance(\n            (data, data.shift(periods=1, freq='6H'))\n        )\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_arrays_error", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effetive_irradiance", "data", "poa_global", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "len_error", "r", "input", "must", "be", "same", "length", "as", "number", "of", "arrays", "in", "system", "r", "expected", "2", "got", "0", "9", "type_error", "r", "input", "must", "be", "a", "tuple", "of", "length", "2", "got", "dataframe", "with", "pytest", "raises", "typeerror", "match", "type_error", "mc", "run_model_from_effective_irradiance", "data", "with", "pytest", "raises", "valueerror", "match", "len_error", "mc", "run_model_from_effective_irradiance", "input_type", "data", "with", "pytest", "raises", "valueerror", "match", "len_error", "mc", "run_model_from_effective_irradiance", "input_type", "data", "data", "data", "with", "pytest", "raises", "valueerror", "match", "r", "input", "dataframes", "must", "have", "same", "index", "mc", "run_model_from_effective_irradiance", "data", "data", "shift", "periods", "1", "freq", "6h"], "doc_len": 110}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_arrays(\n        sapm_dc_snl_ac_system_Array, location, weather, total_irrad,\n        input_type):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effective_irradiance'] = data['poa_global']\n    data['cell_temperature'] = 40\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    mc.run_model_from_effective_irradiance(input_type((data, data)))\n    # arrays have different orientation, but should give same dc power\n    # because we are the same passing effective irradiance and cell\n    # temperature.\n    assert_frame_equal(mc.results.dc[0], mc.results.dc[1])\n    # test that unequal inputs create unequal results\n    data_two = data.copy()\n    data_two['effective_irradiance'] = data['poa_global'] * 0.5\n    mc.run_model_from_effective_irradiance(input_type((data, data_two)))\n    assert (mc.results.dc[0] != mc.results.dc[1]).all().all()\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_arrays", "sapm_dc_snl_ac_system_array", "location", "weather", "total_irrad", "input_type", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effective_irradiance", "data", "poa_global", "data", "cell_temperature", "40", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "mc", "run_model_from_effective_irradiance", "input_type", "data", "data", "arrays", "have", "different", "orientation", "but", "should", "give", "same", "dc", "power", "because", "we", "are", "the", "same", "passing", "effective", "irradiance", "and", "cell", "temperature", "assert_frame_equal", "mc", "results", "dc", "0", "mc", "results", "dc", "1", "test", "that", "unequal", "inputs", "create", "unequal", "results", "data_two", "data", "copy", "data_two", "effective_irradiance", "data", "poa_global", "0", "5", "mc", "run_model_from_effective_irradiance", "input_type", "data", "data_two", "assert", "mc", "results", "dc", "0", "mc", "results", "dc", "1", "all", "all"], "doc_len": 97}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_minimal_input", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_minimal_input", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_minimal_input(\n        sapm_dc_snl_ac_system, sapm_dc_snl_ac_system_Array,\n        location, total_irrad):\n    data = pd.DataFrame({'effective_irradiance': total_irrad['poa_global'],\n                         'cell_temperature': 40},\n                        index=total_irrad.index)\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    mc.run_model_from_effective_irradiance(data)\n    # make sure, for a single Array, the result is the correct type and value\n    assert_series_equal(mc.results.cell_temperature, data['cell_temperature'])\n    assert not mc.results.dc.empty\n    assert not mc.results.ac.empty\n    # test with multiple arrays\n    mc = ModelChain(sapm_dc_snl_ac_system_Array, location)\n    mc.run_model_from_effective_irradiance((data, data))\n    assert_frame_equal(mc.results.dc[0], mc.results.dc[1])\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_minimal_input", "sapm_dc_snl_ac_system", "sapm_dc_snl_ac_system_array", "location", "total_irrad", "data", "pd", "dataframe", "effective_irradiance", "total_irrad", "poa_global", "cell_temperature", "40", "index", "total_irrad", "index", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "mc", "run_model_from_effective_irradiance", "data", "make", "sure", "for", "a", "single", "array", "the", "result", "is", "the", "correct", "type", "and", "value", "assert_series_equal", "mc", "results", "cell_temperature", "data", "cell_temperature", "assert", "not", "mc", "results", "dc", "empty", "assert", "not", "mc", "results", "ac", "empty", "test", "with", "multiple", "arrays", "mc", "modelchain", "sapm_dc_snl_ac_system_array", "location", "mc", "run_model_from_effective_irradiance", "data", "data", "assert_frame_equal", "mc", "results", "dc", "0", "mc", "results", "dc", "1", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 87}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_singleton_weather_single_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_singleton_weather_single_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_singleton_weather_single_array(cec_dc_snl_ac_system,\n                                                  location, weather):\n    mc = ModelChain(cec_dc_snl_ac_system, location,\n                    aoi_model=\"no_loss\", spectral_model=\"no_loss\")\n    mc.run_model([weather])\n    assert isinstance(mc.results.weather, tuple)\n    assert isinstance(mc.results.total_irrad, tuple)\n    assert isinstance(mc.results.aoi, tuple)\n    assert isinstance(mc.results.aoi_modifier, tuple)\n    assert isinstance(mc.results.spectral_modifier, tuple)\n    assert isinstance(mc.results.effective_irradiance, tuple)\n    assert isinstance(mc.results.dc, tuple)\n    assert isinstance(mc.results.cell_temperature, tuple)\n    assert len(mc.results.cell_temperature) == 1\n    assert isinstance(mc.results.cell_temperature[0], pd.Series)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_singleton_weather_single_array", "cec_dc_snl_ac_system", "location", "weather", "mc", "modelchain", "cec_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model", "weather", "assert", "isinstance", "mc", "results", "weather", "tuple", "assert", "isinstance", "mc", "results", "total_irrad", "tuple", "assert", "isinstance", "mc", "results", "aoi", "tuple", "assert", "isinstance", "mc", "results", "aoi_modifier", "tuple", "assert", "isinstance", "mc", "results", "spectral_modifier", "tuple", "assert", "isinstance", "mc", "results", "effective_irradiance", "tuple", "assert", "isinstance", "mc", "results", "dc", "tuple", "assert", "isinstance", "mc", "results", "cell_temperature", "tuple", "assert", "len", "mc", "results", "cell_temperature", "1", "assert", "isinstance", "mc", "results", "cell_temperature", "0", "pd", "series"], "doc_len": 82}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_poa_singleton_weather_single_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_poa_singleton_weather_single_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_poa_singleton_weather_single_array(\n        sapm_dc_snl_ac_system, location, total_irrad):\n    mc = ModelChain(sapm_dc_snl_ac_system, location,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    ac = mc.run_model_from_poa([total_irrad]).results.ac\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=total_irrad.index)\n    assert isinstance(mc.results.weather, tuple)\n    assert isinstance(mc.results.cell_temperature, tuple)\n    assert len(mc.results.cell_temperature) == 1\n    assert isinstance(mc.results.cell_temperature[0], pd.Series)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_poa_singleton_weather_single_array", "sapm_dc_snl_ac_system", "location", "total_irrad", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_poa", "total_irrad", "results", "ac", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "total_irrad", "index", "assert", "isinstance", "mc", "results", "weather", "tuple", "assert", "isinstance", "mc", "results", "cell_temperature", "tuple", "assert", "len", "mc", "results", "cell_temperature", "1", "assert", "isinstance", "mc", "results", "cell_temperature", "0", "pd", "series", "assert_series_equal", "ac", "expected"], "doc_len": 64}
{"doc_id": "pvlib/tests/test_modelchain.py::test_run_model_from_effective_irradiance_weather_single_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_run_model_from_effective_irradiance_weather_single_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_run_model_from_effective_irradiance_weather_single_array(\n        sapm_dc_snl_ac_system, location, weather, total_irrad):\n    data = weather.copy()\n    data[['poa_global', 'poa_diffuse', 'poa_direct']] = total_irrad\n    data['effective_irradiance'] = data['poa_global']\n    mc = ModelChain(sapm_dc_snl_ac_system, location, aoi_model='no_loss',\n                    spectral_model='no_loss')\n    ac = mc.run_model_from_effective_irradiance([data]).results.ac\n    expected = pd.Series(np.array([149.280238, 96.678385]),\n                         index=data.index)\n    assert isinstance(mc.results.weather, tuple)\n    assert isinstance(mc.results.cell_temperature, tuple)\n    assert len(mc.results.cell_temperature) == 1\n    assert isinstance(mc.results.cell_temperature[0], pd.Series)\n    assert isinstance(mc.results.dc, tuple)\n    assert len(mc.results.dc) == 1\n    assert isinstance(mc.results.dc[0], pd.DataFrame)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_run_model_from_effective_irradiance_weather_single_array", "sapm_dc_snl_ac_system", "location", "weather", "total_irrad", "data", "weather", "copy", "data", "poa_global", "poa_diffuse", "poa_direct", "total_irrad", "data", "effective_irradiance", "data", "poa_global", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "ac", "mc", "run_model_from_effective_irradiance", "data", "results", "ac", "expected", "pd", "series", "np", "array", "149", "280238", "96", "678385", "index", "data", "index", "assert", "isinstance", "mc", "results", "weather", "tuple", "assert", "isinstance", "mc", "results", "cell_temperature", "tuple", "assert", "len", "mc", "results", "cell_temperature", "1", "assert", "isinstance", "mc", "results", "cell_temperature", "0", "pd", "series", "assert", "isinstance", "mc", "results", "dc", "tuple", "assert", "len", "mc", "results", "dc", "1", "assert", "isinstance", "mc", "results", "dc", "0", "pd", "dataframe", "assert_series_equal", "ac", "expected"], "doc_len": 97}
{"doc_id": "pvlib/tests/test_modelchain.py::poadc", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "poadc", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef poadc(mc):\n    mc.results.dc = mc.results.total_irrad['poa_global'] * 0.2\n    mc.results.dc.name = None  # assert_series_equal will fail without this\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "poadc", "mc", "mc", "results", "dc", "mc", "results", "total_irrad", "poa_global", "0", "2", "mc", "results", "dc", "name", "none", "assert_series_equal", "will", "fail", "without", "this"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_dc_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_dc_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_dc_model(sapm_dc_snl_ac_system, cec_dc_snl_ac_system,\n                        pvsyst_dc_snl_ac_system, pvwatts_dc_pvwatts_ac_system,\n                        location, dc_model, weather, mocker):\n    dc_systems = {'sapm': sapm_dc_snl_ac_system,\n                  'cec': cec_dc_snl_ac_system,\n                  'desoto': cec_dc_snl_ac_system,\n                  'pvsyst': pvsyst_dc_snl_ac_system,\n                  'singlediode': cec_dc_snl_ac_system,\n                  'pvwatts_dc': pvwatts_dc_pvwatts_ac_system}\n    dc_model_function = {'sapm': 'sapm',\n                         'cec': 'calcparams_cec',\n                         'desoto': 'calcparams_desoto',\n                         'pvsyst': 'calcparams_pvsyst',\n                         'singlediode': 'calcparams_desoto',\n                         'pvwatts_dc': 'pvwatts_dc'}\n    temp_model_function = {'sapm': 'sapm',\n                           'cec': 'sapm',\n                           'desoto': 'sapm',\n                           'pvsyst': 'pvsyst',\n                           'singlediode': 'sapm',\n                           'pvwatts_dc': 'sapm'}\n    temp_model_params = {'sapm': {'a': -3.40641, 'b': -0.0842075, 'deltaT': 3},\n                         'pvsyst': {'u_c': 29.0, 'u_v': 0}}\n    system = dc_systems[dc_model]\n    for array in system.arrays:\n        array.temperature_model_parameters = temp_model_params[\n            temp_model_function[dc_model]]\n    # remove Adjust from model parameters for desoto, singlediode\n    if dc_model in ['desoto', 'singlediode']:\n        for array in system.arrays:\n            array.module_parameters.pop('Adjust')\n    m = mocker.spy(pvsystem, dc_model_function[dc_model])\n    mc = ModelChain(system, location,\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    temperature_model=temp_model_function[dc_model])\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert isinstance(mc.results.dc, (pd.Series, pd.DataFrame))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_dc_model", "sapm_dc_snl_ac_system", "cec_dc_snl_ac_system", "pvsyst_dc_snl_ac_system", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "weather", "mocker", "dc_systems", "sapm", "sapm_dc_snl_ac_system", "cec", "cec_dc_snl_ac_system", "desoto", "cec_dc_snl_ac_system", "pvsyst", "pvsyst_dc_snl_ac_system", "singlediode", "cec_dc_snl_ac_system", "pvwatts_dc", "pvwatts_dc_pvwatts_ac_system", "dc_model_function", "sapm", "sapm", "cec", "calcparams_cec", "desoto", "calcparams_desoto", "pvsyst", "calcparams_pvsyst", "singlediode", "calcparams_desoto", "pvwatts_dc", "pvwatts_dc", "temp_model_function", "sapm", "sapm", "cec", "sapm", "desoto", "sapm", "pvsyst", "pvsyst", "singlediode", "sapm", "pvwatts_dc", "sapm", "temp_model_params", "sapm", "a", "3", "40641", "b", "0", "0842075", "deltat", "3", "pvsyst", "u_c", "29", "0", "u_v", "0", "system", "dc_systems", "dc_model", "for", "array", "in", "system", "arrays", "array", "temperature_model_parameters", "temp_model_params", "temp_model_function", "dc_model", "remove", "adjust", "from", "model", "parameters", "for", "desoto", "singlediode", "if", "dc_model", "in", "desoto", "singlediode", "for", "array", "in", "system", "arrays", "array", "module_parameters", "pop", "adjust", "m", "mocker", "spy", "pvsystem", "dc_model_function", "dc_model", "mc", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "temperature_model", "temp_model_function", "dc_model", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "dc", "pd", "series", "pd", "dataframe"], "doc_len": 137}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_dc_model_incomplete", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_dc_model_incomplete", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_dc_model_incomplete(multi_array_sapm_dc_snl_ac_system,\n                                   location):\n    match = 'Could not infer DC model from the module_parameters attributes '\n    system = multi_array_sapm_dc_snl_ac_system['two_array_system']\n    system.arrays[0].module_parameters.pop('A0')\n    with pytest.raises(ValueError, match=match):\n        ModelChain(system, location)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_dc_model_incomplete", "multi_array_sapm_dc_snl_ac_system", "location", "match", "could", "not", "infer", "dc", "model", "from", "the", "module_parameters", "attributes", "system", "multi_array_sapm_dc_snl_ac_system", "two_array_system", "system", "arrays", "0", "module_parameters", "pop", "a0", "with", "pytest", "raises", "valueerror", "match", "match", "modelchain", "system", "location"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_modelchain.py::test_singlediode_dc_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_singlediode_dc_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_singlediode_dc_arrays(location, dc_model,\n                               cec_dc_snl_ac_arrays,\n                               pvsyst_dc_snl_ac_arrays,\n                               weather):\n    systems = {'cec': cec_dc_snl_ac_arrays,\n               'pvsyst': pvsyst_dc_snl_ac_arrays,\n               'desoto': cec_dc_snl_ac_arrays}\n    temp_sapm = {'a': -3.40641, 'b': -0.0842075, 'deltaT': 3}\n    temp_pvsyst = {'u_c': 29.0, 'u_v': 0}\n    temp_model_params = {'cec': temp_sapm,\n                         'desoto': temp_sapm,\n                         'pvsyst': temp_pvsyst}\n    temp_model = {'cec': 'sapm', 'desoto': 'sapm', 'pvsyst': 'pvsyst'}\n    system = systems[dc_model]\n    for array in system.arrays:\n        array.temperature_model_parameters = temp_model_params[dc_model]\n    if dc_model == 'desoto':\n        for array in system.arrays:\n            array.module_parameters.pop('Adjust')\n    mc = ModelChain(system, location,\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    temperature_model=temp_model[dc_model])\n    mc.run_model(weather)\n    assert isinstance(mc.results.dc, tuple)\n    assert len(mc.results.dc) == system.num_arrays\n    for dc in mc.results.dc:\n        assert isinstance(dc, (pd.Series, pd.DataFrame))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_singlediode_dc_arrays", "location", "dc_model", "cec_dc_snl_ac_arrays", "pvsyst_dc_snl_ac_arrays", "weather", "systems", "cec", "cec_dc_snl_ac_arrays", "pvsyst", "pvsyst_dc_snl_ac_arrays", "desoto", "cec_dc_snl_ac_arrays", "temp_sapm", "a", "3", "40641", "b", "0", "0842075", "deltat", "3", "temp_pvsyst", "u_c", "29", "0", "u_v", "0", "temp_model_params", "cec", "temp_sapm", "desoto", "temp_sapm", "pvsyst", "temp_pvsyst", "temp_model", "cec", "sapm", "desoto", "sapm", "pvsyst", "pvsyst", "system", "systems", "dc_model", "for", "array", "in", "system", "arrays", "array", "temperature_model_parameters", "temp_model_params", "dc_model", "if", "dc_model", "desoto", "for", "array", "in", "system", "arrays", "array", "module_parameters", "pop", "adjust", "mc", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "temperature_model", "temp_model", "dc_model", "mc", "run_model", "weather", "assert", "isinstance", "mc", "results", "dc", "tuple", "assert", "len", "mc", "results", "dc", "system", "num_arrays", "for", "dc", "in", "mc", "results", "dc", "assert", "isinstance", "dc", "pd", "series", "pd", "dataframe"], "doc_len": 111}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_spectral_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_spectral_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_spectral_model(location, sapm_dc_snl_ac_system,\n                              cec_dc_snl_ac_system,\n                              cec_dc_native_snl_ac_system, dc_model):\n    dc_systems = {'sapm': sapm_dc_snl_ac_system,\n                  'cec': cec_dc_snl_ac_system,\n                  'cec_native': cec_dc_native_snl_ac_system}\n    system = dc_systems[dc_model]\n    mc = ModelChain(system, location, aoi_model='physical')\n    assert isinstance(mc, ModelChain)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_spectral_model", "location", "sapm_dc_snl_ac_system", "cec_dc_snl_ac_system", "cec_dc_native_snl_ac_system", "dc_model", "dc_systems", "sapm", "sapm_dc_snl_ac_system", "cec", "cec_dc_snl_ac_system", "cec_native", "cec_dc_native_snl_ac_system", "system", "dc_systems", "dc_model", "mc", "modelchain", "system", "location", "aoi_model", "physical", "assert", "isinstance", "mc", "modelchain"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_temp_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_temp_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_temp_model(location, sapm_dc_snl_ac_system,\n                          pvwatts_dc_pvwatts_ac_pvsyst_temp_system,\n                          pvwatts_dc_pvwatts_ac_faiman_temp_system,\n                          pvwatts_dc_pvwatts_ac_fuentes_temp_system,\n                          pvwatts_dc_pvwatts_ac_noct_sam_temp_system,\n                          temp_model):\n    dc_systems = {'sapm_temp': sapm_dc_snl_ac_system,\n                  'pvsyst_temp': pvwatts_dc_pvwatts_ac_pvsyst_temp_system,\n                  'faiman_temp': pvwatts_dc_pvwatts_ac_faiman_temp_system,\n                  'fuentes_temp': pvwatts_dc_pvwatts_ac_fuentes_temp_system,\n                  'noct_sam_temp': pvwatts_dc_pvwatts_ac_noct_sam_temp_system}\n    system = dc_systems[temp_model]\n    mc = ModelChain(system, location, aoi_model='physical',\n                    spectral_model='no_loss')\n    assert temp_model == mc.temperature_model.__name__\n    assert isinstance(mc, ModelChain)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_temp_model", "location", "sapm_dc_snl_ac_system", "pvwatts_dc_pvwatts_ac_pvsyst_temp_system", "pvwatts_dc_pvwatts_ac_faiman_temp_system", "pvwatts_dc_pvwatts_ac_fuentes_temp_system", "pvwatts_dc_pvwatts_ac_noct_sam_temp_system", "temp_model", "dc_systems", "sapm_temp", "sapm_dc_snl_ac_system", "pvsyst_temp", "pvwatts_dc_pvwatts_ac_pvsyst_temp_system", "faiman_temp", "pvwatts_dc_pvwatts_ac_faiman_temp_system", "fuentes_temp", "pvwatts_dc_pvwatts_ac_fuentes_temp_system", "noct_sam_temp", "pvwatts_dc_pvwatts_ac_noct_sam_temp_system", "system", "dc_systems", "temp_model", "mc", "modelchain", "system", "location", "aoi_model", "physical", "spectral_model", "no_loss", "assert", "temp_model", "mc", "temperature_model", "__name__", "assert", "isinstance", "mc", "modelchain"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_temp_model_invalid", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_temp_model_invalid", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_temp_model_invalid(location, sapm_dc_snl_ac_system):\n    sapm_dc_snl_ac_system.arrays[0].temperature_model_parameters.pop('a')\n    with pytest.raises(ValueError):\n        ModelChain(sapm_dc_snl_ac_system, location,\n                   aoi_model='physical', spectral_model='no_loss')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_temp_model_invalid", "location", "sapm_dc_snl_ac_system", "sapm_dc_snl_ac_system", "arrays", "0", "temperature_model_parameters", "pop", "a", "with", "pytest", "raises", "valueerror", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "physical", "spectral_model", "no_loss"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_modelchain.py::test_temperature_model_inconsistent", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_temperature_model_inconsistent", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_temperature_model_inconsistent(location, sapm_dc_snl_ac_system):\n    with pytest.raises(ValueError):\n        ModelChain(sapm_dc_snl_ac_system, location, aoi_model='physical',\n                   spectral_model='no_loss', temperature_model='pvsyst')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_temperature_model_inconsistent", "location", "sapm_dc_snl_ac_system", "with", "pytest", "raises", "valueerror", "modelchain", "sapm_dc_snl_ac_system", "location", "aoi_model", "physical", "spectral_model", "no_loss", "temperature_model", "pvsyst"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_modelchain.py::test_dc_model_user_func", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_dc_model_user_func", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_dc_model_user_func(pvwatts_dc_pvwatts_ac_system, location, weather,\n                            mocker):\n    m = mocker.spy(sys.modules[__name__], 'poadc')\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, dc_model=poadc,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert isinstance(mc.results.ac, (pd.Series, pd.DataFrame))\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_dc_model_user_func", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "sys", "modules", "__name__", "poadc", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "poadc", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "pd", "dataframe", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 49}
{"doc_id": "pvlib/tests/test_modelchain.py::test_pvwatts_dc_multiple_strings", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_pvwatts_dc_multiple_strings", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_pvwatts_dc_multiple_strings(pvwatts_dc_pvwatts_ac_system, location,\n                                     weather, mocker):\n    system = pvwatts_dc_pvwatts_ac_system\n    m = mocker.spy(system, 'scale_voltage_current_power')\n    mc1 = ModelChain(system, location,\n                     aoi_model='no_loss', spectral_model='no_loss')\n    mc1.run_model(weather)\n    assert m.call_count == 1\n    system.arrays[0].modules_per_string = 2\n    mc2 = ModelChain(system, location,\n                     aoi_model='no_loss', spectral_model='no_loss')\n    mc2.run_model(weather)\n    assert isinstance(mc2.results.ac, (pd.Series, pd.DataFrame))\n    assert not mc2.results.ac.empty\n    expected = pd.Series(data=[2., np.nan], index=mc2.results.dc.index,\n                         name='p_mp')\n    assert_series_equal(mc2.results.dc / mc1.results.dc, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_pvwatts_dc_multiple_strings", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "system", "pvwatts_dc_pvwatts_ac_system", "m", "mocker", "spy", "system", "scale_voltage_current_power", "mc1", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc1", "run_model", "weather", "assert", "m", "call_count", "1", "system", "arrays", "0", "modules_per_string", "2", "mc2", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc2", "run_model", "weather", "assert", "isinstance", "mc2", "results", "ac", "pd", "series", "pd", "dataframe", "assert", "not", "mc2", "results", "ac", "empty", "expected", "pd", "series", "data", "2", "np", "nan", "index", "mc2", "results", "dc", "index", "name", "p_mp", "assert_series_equal", "mc2", "results", "dc", "mc1", "results", "dc", "expected"], "doc_len": 85}
{"doc_id": "pvlib/tests/test_modelchain.py::acdc", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "acdc", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef acdc(mc):\n    mc.results.ac = mc.results.dc\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "acdc", "mc", "mc", "results", "ac", "mc", "results", "dc"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ac_models", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ac_models", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ac_models(sapm_dc_snl_ac_system, cec_dc_adr_ac_system,\n                   pvwatts_dc_pvwatts_ac_system, cec_dc_snl_ac_arrays,\n                   pvwatts_dc_pvwatts_ac_system_arrays,\n                   location, inverter_model, weather, mocker):\n    ac_systems = {'sandia': sapm_dc_snl_ac_system,\n                  'sandia_multi': cec_dc_snl_ac_arrays,\n                  'adr': cec_dc_adr_ac_system,\n                  'pvwatts': pvwatts_dc_pvwatts_ac_system,\n                  'pvwatts_multi': pvwatts_dc_pvwatts_ac_system_arrays}\n    inverter_to_ac_model = {\n        'sandia': 'sandia',\n        'sandia_multi': 'sandia',\n        'adr': 'adr',\n        'pvwatts': 'pvwatts',\n        'pvwatts_multi': 'pvwatts'}\n    ac_model = inverter_to_ac_model[inverter_model]\n    system = ac_systems[inverter_model]\n\n    mc_inferred = ModelChain(system, location,\n                             aoi_model='no_loss', spectral_model='no_loss')\n    mc = ModelChain(system, location, ac_model=ac_model,\n                    aoi_model='no_loss', spectral_model='no_loss')\n\n    # tests ModelChain.infer_ac_model\n    assert mc_inferred.ac_model.__name__ == mc.ac_model.__name__\n\n    m = mocker.spy(inverter, inverter_model)\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert isinstance(mc.results.ac, pd.Series)\n    assert not mc.results.ac.empty\n    assert mc.results.ac[1] < 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_ac_models", "sapm_dc_snl_ac_system", "cec_dc_adr_ac_system", "pvwatts_dc_pvwatts_ac_system", "cec_dc_snl_ac_arrays", "pvwatts_dc_pvwatts_ac_system_arrays", "location", "inverter_model", "weather", "mocker", "ac_systems", "sandia", "sapm_dc_snl_ac_system", "sandia_multi", "cec_dc_snl_ac_arrays", "adr", "cec_dc_adr_ac_system", "pvwatts", "pvwatts_dc_pvwatts_ac_system", "pvwatts_multi", "pvwatts_dc_pvwatts_ac_system_arrays", "inverter_to_ac_model", "sandia", "sandia", "sandia_multi", "sandia", "adr", "adr", "pvwatts", "pvwatts", "pvwatts_multi", "pvwatts", "ac_model", "inverter_to_ac_model", "inverter_model", "system", "ac_systems", "inverter_model", "mc_inferred", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "modelchain", "system", "location", "ac_model", "ac_model", "aoi_model", "no_loss", "spectral_model", "no_loss", "tests", "modelchain", "infer_ac_model", "assert", "mc_inferred", "ac_model", "__name__", "mc", "ac_model", "__name__", "m", "mocker", "spy", "inverter", "inverter_model", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "assert", "not", "mc", "results", "ac", "empty", "assert", "mc", "results", "ac", "1", "1"], "doc_len": 102}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ac_model_user_func", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ac_model_user_func", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ac_model_user_func(pvwatts_dc_pvwatts_ac_system, location, weather,\n                            mocker):\n    m = mocker.spy(sys.modules[__name__], 'acdc')\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, ac_model=acdc,\n                    aoi_model='no_loss', spectral_model='no_loss')\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert_series_equal(mc.results.ac, mc.results.dc)\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_ac_model_user_func", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "sys", "modules", "__name__", "acdc", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "ac_model", "acdc", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert_series_equal", "mc", "results", "ac", "mc", "results", "dc", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 47}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ac_model_not_a_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ac_model_not_a_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ac_model_not_a_model(pvwatts_dc_pvwatts_ac_system, location, weather):\n    exc_text = 'not a valid AC power model'\n    with pytest.raises(ValueError, match=exc_text):\n        ModelChain(pvwatts_dc_pvwatts_ac_system, location,\n                   ac_model='not_a_model', aoi_model='no_loss',\n                   spectral_model='no_loss')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_ac_model_not_a_model", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "exc_text", "not", "a", "valid", "ac", "power", "model", "with", "pytest", "raises", "valueerror", "match", "exc_text", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "ac_model", "not_a_model", "aoi_model", "no_loss", "spectral_model", "no_loss"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_ac_model_invalid_params", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_ac_model_invalid_params", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_ac_model_invalid_params(location):\n    # only the keys are relevant here, using arbitrary values\n    module_parameters = {'pdc0': 1, 'gamma_pdc': 1}\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(\n            mount=pvsystem.FixedMount(0, 180),\n            module_parameters=module_parameters\n        )],\n        inverter_parameters={'foo': 1, 'bar': 2}\n    )\n    with pytest.raises(ValueError, match='could not infer AC model'):\n        ModelChain(system, location)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_ac_model_invalid_params", "location", "only", "the", "keys", "are", "relevant", "here", "using", "arbitrary", "values", "module_parameters", "pdc0", "1", "gamma_pdc", "1", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "module_parameters", "inverter_parameters", "foo", "1", "bar", "2", "with", "pytest", "raises", "valueerror", "match", "could", "not", "infer", "ac", "model", "modelchain", "system", "location"], "doc_len": 52}
{"doc_id": "pvlib/tests/test_modelchain.py::constant_aoi_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "constant_aoi_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef constant_aoi_loss(mc):\n    mc.results.aoi_modifier = 0.9\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "constant_aoi_loss", "mc", "mc", "results", "aoi_modifier", "0", "9"], "doc_len": 12}
{"doc_id": "pvlib/tests/test_modelchain.py::test_aoi_models", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_aoi_models", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_aoi_models(sapm_dc_snl_ac_system, location, aoi_model,\n                    weather, mocker):\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model=aoi_model, spectral_model='no_loss')\n    m = mocker.spy(sapm_dc_snl_ac_system, 'get_iam')\n    mc.run_model(weather=weather)\n    assert m.call_count == 1\n    assert isinstance(mc.results.ac, pd.Series)\n    assert not mc.results.ac.empty\n    assert mc.results.ac[0] > 150 and mc.results.ac[0] < 200\n    assert mc.results.ac[1] < 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_aoi_models", "sapm_dc_snl_ac_system", "location", "aoi_model", "weather", "mocker", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "aoi_model", "spectral_model", "no_loss", "m", "mocker", "spy", "sapm_dc_snl_ac_system", "get_iam", "mc", "run_model", "weather", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "assert", "not", "mc", "results", "ac", "empty", "assert", "mc", "results", "ac", "0", "150", "and", "mc", "results", "ac", "0", "200", "assert", "mc", "results", "ac", "1", "1"], "doc_len": 65}
{"doc_id": "pvlib/tests/test_modelchain.py::test_aoi_models_singleon_weather_single_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_aoi_models_singleon_weather_single_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_aoi_models_singleon_weather_single_array(\n        sapm_dc_snl_ac_system, location, aoi_model, weather):\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model=aoi_model, spectral_model='no_loss')\n    mc.run_model(weather=[weather])\n    assert isinstance(mc.results.aoi_modifier, tuple)\n    assert len(mc.results.aoi_modifier) == 1\n    assert isinstance(mc.results.ac, pd.Series)\n    assert not mc.results.ac.empty\n    assert mc.results.ac[0] > 150 and mc.results.ac[0] < 200\n    assert mc.results.ac[1] < 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_aoi_models_singleon_weather_single_array", "sapm_dc_snl_ac_system", "location", "aoi_model", "weather", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "aoi_model", "spectral_model", "no_loss", "mc", "run_model", "weather", "weather", "assert", "isinstance", "mc", "results", "aoi_modifier", "tuple", "assert", "len", "mc", "results", "aoi_modifier", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "assert", "not", "mc", "results", "ac", "empty", "assert", "mc", "results", "ac", "0", "150", "and", "mc", "results", "ac", "0", "200", "assert", "mc", "results", "ac", "1", "1"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_modelchain.py::test_aoi_model_no_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_aoi_model_no_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_aoi_model_no_loss(sapm_dc_snl_ac_system, location, weather):\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model='no_loss', spectral_model='no_loss')\n    mc.run_model(weather)\n    assert mc.results.aoi_modifier == 1.0\n    assert not mc.results.ac.empty\n    assert mc.results.ac[0] > 150 and mc.results.ac[0] < 200\n    assert mc.results.ac[1] < 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_aoi_model_no_loss", "sapm_dc_snl_ac_system", "location", "weather", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "no_loss", "spectral_model", "no_loss", "mc", "run_model", "weather", "assert", "mc", "results", "aoi_modifier", "1", "0", "assert", "not", "mc", "results", "ac", "empty", "assert", "mc", "results", "ac", "0", "150", "and", "mc", "results", "ac", "0", "200", "assert", "mc", "results", "ac", "1", "1"], "doc_len": 52}
{"doc_id": "pvlib/tests/test_modelchain.py::test_aoi_model_user_func", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_aoi_model_user_func", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_aoi_model_user_func(sapm_dc_snl_ac_system, location, weather, mocker):\n    m = mocker.spy(sys.modules[__name__], 'constant_aoi_loss')\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model=constant_aoi_loss, spectral_model='no_loss')\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert mc.results.aoi_modifier == 0.9\n    assert not mc.results.ac.empty\n    assert mc.results.ac[0] > 140 and mc.results.ac[0] < 200\n    assert mc.results.ac[1] < 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_aoi_model_user_func", "sapm_dc_snl_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "sys", "modules", "__name__", "constant_aoi_loss", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "constant_aoi_loss", "spectral_model", "no_loss", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "mc", "results", "aoi_modifier", "0", "9", "assert", "not", "mc", "results", "ac", "empty", "assert", "mc", "results", "ac", "0", "140", "and", "mc", "results", "ac", "0", "200", "assert", "mc", "results", "ac", "1", "1"], "doc_len": 64}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_aoi_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_aoi_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_aoi_model(location, system_no_aoi, aoi_model):\n    for k in iam._IAM_MODEL_PARAMS[aoi_model]:\n        system_no_aoi.arrays[0].module_parameters.update({k: 1.0})\n    mc = ModelChain(system_no_aoi, location, spectral_model='no_loss')\n    assert isinstance(mc, ModelChain)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_aoi_model", "location", "system_no_aoi", "aoi_model", "for", "k", "in", "iam", "_iam_model_params", "aoi_model", "system_no_aoi", "arrays", "0", "module_parameters", "update", "k", "1", "0", "mc", "modelchain", "system_no_aoi", "location", "spectral_model", "no_loss", "assert", "isinstance", "mc", "modelchain"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_modelchain.py::test_infer_aoi_model_invalid", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_infer_aoi_model_invalid", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_infer_aoi_model_invalid(location, system_no_aoi):\n    exc_text = 'could not infer AOI model'\n    with pytest.raises(ValueError, match=exc_text):\n        ModelChain(system_no_aoi, location, spectral_model='no_loss')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_infer_aoi_model_invalid", "location", "system_no_aoi", "exc_text", "could", "not", "infer", "aoi", "model", "with", "pytest", "raises", "valueerror", "match", "exc_text", "modelchain", "system_no_aoi", "location", "spectral_model", "no_loss"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_modelchain.py::constant_spectral_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "constant_spectral_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef constant_spectral_loss(mc):\n    mc.results.spectral_modifier = 0.9\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "constant_spectral_loss", "mc", "mc", "results", "spectral_modifier", "0", "9"], "doc_len": 12}
{"doc_id": "pvlib/tests/test_modelchain.py::test_spectral_models", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_spectral_models", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_spectral_models(sapm_dc_snl_ac_system, location, spectral_model,\n                         weather):\n    # add pw to weather dataframe\n    weather['precipitable_water'] = [0.3, 0.5]\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model='no_loss', spectral_model=spectral_model)\n    spectral_modifier = mc.run_model(weather).results.spectral_modifier\n    assert isinstance(spectral_modifier, (pd.Series, float, int))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_spectral_models", "sapm_dc_snl_ac_system", "location", "spectral_model", "weather", "add", "pw", "to", "weather", "dataframe", "weather", "precipitable_water", "0", "3", "0", "5", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "no_loss", "spectral_model", "spectral_model", "spectral_modifier", "mc", "run_model", "weather", "results", "spectral_modifier", "assert", "isinstance", "spectral_modifier", "pd", "series", "float", "int"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_modelchain.py::test_spectral_models_singleton_weather_single_array", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_spectral_models_singleton_weather_single_array", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_spectral_models_singleton_weather_single_array(\n        sapm_dc_snl_ac_system, location, spectral_model, weather):\n    # add pw to weather dataframe\n    weather['precipitable_water'] = [0.3, 0.5]\n    mc = ModelChain(sapm_dc_snl_ac_system, location, dc_model='sapm',\n                    aoi_model='no_loss', spectral_model=spectral_model)\n    spectral_modifier = mc.run_model([weather]).results.spectral_modifier\n    assert isinstance(spectral_modifier, tuple)\n    assert len(spectral_modifier) == 1\n    assert isinstance(spectral_modifier[0], (pd.Series, float, int))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_spectral_models_singleton_weather_single_array", "sapm_dc_snl_ac_system", "location", "spectral_model", "weather", "add", "pw", "to", "weather", "dataframe", "weather", "precipitable_water", "0", "3", "0", "5", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "dc_model", "sapm", "aoi_model", "no_loss", "spectral_model", "spectral_model", "spectral_modifier", "mc", "run_model", "weather", "results", "spectral_modifier", "assert", "isinstance", "spectral_modifier", "tuple", "assert", "len", "spectral_modifier", "1", "assert", "isinstance", "spectral_modifier", "0", "pd", "series", "float", "int"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_modelchain.py::constant_losses", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "constant_losses", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef constant_losses(mc):\n    mc.results.losses = 0.9\n    mc.results.dc *= mc.results.losses\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "constant_losses", "mc", "mc", "results", "losses", "0", "9", "mc", "results", "dc", "mc", "results", "losses"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_modelchain.py::dc_constant_losses", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "dc_constant_losses", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef dc_constant_losses(mc):\n    mc.results.dc['p_mp'] *= 0.9\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "dc_constant_losses", "mc", "mc", "results", "dc", "p_mp", "0", "9"], "doc_len": 13}
{"doc_id": "pvlib/tests/test_modelchain.py::test_dc_ohmic_model_ohms_from_percent", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_dc_ohmic_model_ohms_from_percent", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_dc_ohmic_model_ohms_from_percent(cec_dc_snl_ac_system,\n                                          cec_dc_snl_ac_arrays,\n                                          location,\n                                          weather,\n                                          mocker):\n\n    m = mocker.spy(pvsystem, 'dc_ohms_from_percent')\n\n    system = cec_dc_snl_ac_system\n\n    for array in system.arrays:\n        array.array_losses_parameters = dict(dc_ohmic_percent=3)\n\n    mc = ModelChain(system, location,\n                    aoi_model='no_loss',\n                    spectral_model='no_loss',\n                    dc_ohmic_model='dc_ohms_from_percent')\n    mc.run_model(weather)\n\n    assert m.call_count == 1\n\n    assert isinstance(mc.results.dc_ohmic_losses, pd.Series)\n\n    system = cec_dc_snl_ac_arrays\n\n    for array in system.arrays:\n        array.array_losses_parameters = dict(dc_ohmic_percent=3)\n\n    mc = ModelChain(system, location,\n                    aoi_model='no_loss',\n                    spectral_model='no_loss',\n                    dc_ohmic_model='dc_ohms_from_percent')\n    mc.run_model(weather)\n\n    assert m.call_count == 3\n    assert len(mc.results.dc_ohmic_losses) == len(mc.system.arrays)\n\n    assert isinstance(mc.results.dc_ohmic_losses, tuple)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_dc_ohmic_model_ohms_from_percent", "cec_dc_snl_ac_system", "cec_dc_snl_ac_arrays", "location", "weather", "mocker", "m", "mocker", "spy", "pvsystem", "dc_ohms_from_percent", "system", "cec_dc_snl_ac_system", "for", "array", "in", "system", "arrays", "array", "array_losses_parameters", "dict", "dc_ohmic_percent", "3", "mc", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "dc_ohmic_model", "dc_ohms_from_percent", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "dc_ohmic_losses", "pd", "series", "system", "cec_dc_snl_ac_arrays", "for", "array", "in", "system", "arrays", "array", "array_losses_parameters", "dict", "dc_ohmic_percent", "3", "mc", "modelchain", "system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "dc_ohmic_model", "dc_ohms_from_percent", "mc", "run_model", "weather", "assert", "m", "call_count", "3", "assert", "len", "mc", "results", "dc_ohmic_losses", "len", "mc", "system", "arrays", "assert", "isinstance", "mc", "results", "dc_ohmic_losses", "tuple"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_modelchain.py::test_dc_ohmic_model_no_dc_ohmic_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_dc_ohmic_model_no_dc_ohmic_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_dc_ohmic_model_no_dc_ohmic_loss(cec_dc_snl_ac_system,\n                                         location,\n                                         weather,\n                                         mocker):\n\n    m = mocker.spy(modelchain.ModelChain, 'no_dc_ohmic_loss')\n    mc = ModelChain(cec_dc_snl_ac_system, location,\n                    aoi_model='no_loss',\n                    spectral_model='no_loss',\n                    dc_ohmic_model='no_loss')\n    mc.run_model(weather)\n\n    assert mc.dc_ohmic_model == mc.no_dc_ohmic_loss\n    assert m.call_count == 1\n    assert mc.results.dc_ohmic_losses is None\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_dc_ohmic_model_no_dc_ohmic_loss", "cec_dc_snl_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "modelchain", "modelchain", "no_dc_ohmic_loss", "mc", "modelchain", "cec_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "dc_ohmic_model", "no_loss", "mc", "run_model", "weather", "assert", "mc", "dc_ohmic_model", "mc", "no_dc_ohmic_loss", "assert", "m", "call_count", "1", "assert", "mc", "results", "dc_ohmic_losses", "is", "none"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_modelchain.py::test_dc_ohmic_ext_def", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_dc_ohmic_ext_def", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_dc_ohmic_ext_def(cec_dc_snl_ac_system, location,\n                          weather, mocker):\n    m = mocker.spy(sys.modules[__name__], 'dc_constant_losses')\n    mc = ModelChain(cec_dc_snl_ac_system, location,\n                    aoi_model='no_loss',\n                    spectral_model='no_loss',\n                    dc_ohmic_model=dc_constant_losses)\n    mc.run_model(weather)\n\n    assert m.call_count == 1\n    assert isinstance(mc.results.ac, (pd.Series, pd.DataFrame))\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_dc_ohmic_ext_def", "cec_dc_snl_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "sys", "modules", "__name__", "dc_constant_losses", "mc", "modelchain", "cec_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "dc_ohmic_model", "dc_constant_losses", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "pd", "dataframe", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 49}
{"doc_id": "pvlib/tests/test_modelchain.py::test_dc_ohmic_not_a_model", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_dc_ohmic_not_a_model", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_dc_ohmic_not_a_model(cec_dc_snl_ac_system, location,\n                              weather, mocker):\n    exc_text = 'not_a_dc_model is not a valid losses model'\n    with pytest.raises(ValueError, match=exc_text):\n        ModelChain(cec_dc_snl_ac_system, location,\n                   aoi_model='no_loss',\n                   spectral_model='no_loss',\n                   dc_ohmic_model='not_a_dc_model')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_dc_ohmic_not_a_model", "cec_dc_snl_ac_system", "location", "weather", "mocker", "exc_text", "not_a_dc_model", "is", "not", "a", "valid", "losses", "model", "with", "pytest", "raises", "valueerror", "match", "exc_text", "modelchain", "cec_dc_snl_ac_system", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "dc_ohmic_model", "not_a_dc_model"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_modelchain.py::test_losses_models_pvwatts", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_losses_models_pvwatts", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_losses_models_pvwatts(pvwatts_dc_pvwatts_ac_system, location, weather,\n                               mocker):\n    age = 1\n    pvwatts_dc_pvwatts_ac_system.losses_parameters = dict(age=age)\n    m = mocker.spy(pvsystem, 'pvwatts_losses')\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, dc_model='pvwatts',\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model='pvwatts')\n    mc.run_model(weather)\n    assert m.call_count == 1\n    m.assert_called_with(age=age)\n    assert isinstance(mc.results.ac, (pd.Series, pd.DataFrame))\n    assert not mc.results.ac.empty\n    # check that we're applying correction to dc\n    # GH 696\n    dc_with_loss = mc.results.dc\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, dc_model='pvwatts',\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model='no_loss')\n    mc.run_model(weather)\n    assert not np.allclose(mc.results.dc, dc_with_loss, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_losses_models_pvwatts", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "age", "1", "pvwatts_dc_pvwatts_ac_system", "losses_parameters", "dict", "age", "age", "m", "mocker", "spy", "pvsystem", "pvwatts_losses", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "pvwatts", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "pvwatts", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "m", "assert_called_with", "age", "age", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "pd", "dataframe", "assert", "not", "mc", "results", "ac", "empty", "check", "that", "we", "re", "applying", "correction", "to", "dc", "gh", "696", "dc_with_loss", "mc", "results", "dc", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "pvwatts", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc", "run_model", "weather", "assert", "not", "np", "allclose", "mc", "results", "dc", "dc_with_loss", "equal_nan", "true"], "doc_len": 99}
{"doc_id": "pvlib/tests/test_modelchain.py::test_losses_models_pvwatts_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_losses_models_pvwatts_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_losses_models_pvwatts_arrays(multi_array_sapm_dc_snl_ac_system,\n                                      location, weather):\n    age = 1\n    system_both = multi_array_sapm_dc_snl_ac_system['two_array_system']\n    system_both.losses_parameters = dict(age=age)\n    mc = ModelChain(system_both, location,\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model='pvwatts')\n    mc.run_model(weather)\n    dc_with_loss = mc.results.dc\n    mc = ModelChain(system_both, location,\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model='no_loss')\n    mc.run_model(weather)\n    assert not np.allclose(mc.results.dc[0], dc_with_loss[0], equal_nan=True)\n    assert not np.allclose(mc.results.dc[1], dc_with_loss[1], equal_nan=True)\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_losses_models_pvwatts_arrays", "multi_array_sapm_dc_snl_ac_system", "location", "weather", "age", "1", "system_both", "multi_array_sapm_dc_snl_ac_system", "two_array_system", "system_both", "losses_parameters", "dict", "age", "age", "mc", "modelchain", "system_both", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "pvwatts", "mc", "run_model", "weather", "dc_with_loss", "mc", "results", "dc", "mc", "modelchain", "system_both", "location", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "mc", "run_model", "weather", "assert", "not", "np", "allclose", "mc", "results", "dc", "0", "dc_with_loss", "0", "equal_nan", "true", "assert", "not", "np", "allclose", "mc", "results", "dc", "1", "dc_with_loss", "1", "equal_nan", "true", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 79}
{"doc_id": "pvlib/tests/test_modelchain.py::test_losses_models_ext_def", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_losses_models_ext_def", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_losses_models_ext_def(pvwatts_dc_pvwatts_ac_system, location, weather,\n                               mocker):\n    m = mocker.spy(sys.modules[__name__], 'constant_losses')\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, dc_model='pvwatts',\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model=constant_losses)\n    mc.run_model(weather)\n    assert m.call_count == 1\n    assert isinstance(mc.results.ac, (pd.Series, pd.DataFrame))\n    assert mc.results.losses == 0.9\n    assert not mc.results.ac.empty\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_losses_models_ext_def", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "sys", "modules", "__name__", "constant_losses", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "pvwatts", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "constant_losses", "mc", "run_model", "weather", "assert", "m", "call_count", "1", "assert", "isinstance", "mc", "results", "ac", "pd", "series", "pd", "dataframe", "assert", "mc", "results", "losses", "0", "9", "assert", "not", "mc", "results", "ac", "empty"], "doc_len": 57}
{"doc_id": "pvlib/tests/test_modelchain.py::test_losses_models_no_loss", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_losses_models_no_loss", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_losses_models_no_loss(pvwatts_dc_pvwatts_ac_system, location, weather,\n                               mocker):\n    m = mocker.spy(pvsystem, 'pvwatts_losses')\n    mc = ModelChain(pvwatts_dc_pvwatts_ac_system, location, dc_model='pvwatts',\n                    aoi_model='no_loss', spectral_model='no_loss',\n                    losses_model='no_loss')\n    assert mc.losses_model == mc.no_extra_losses\n    mc.run_model(weather)\n    assert m.call_count == 0\n    assert mc.results.losses == 1\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_losses_models_no_loss", "pvwatts_dc_pvwatts_ac_system", "location", "weather", "mocker", "m", "mocker", "spy", "pvsystem", "pvwatts_losses", "mc", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "dc_model", "pvwatts", "aoi_model", "no_loss", "spectral_model", "no_loss", "losses_model", "no_loss", "assert", "mc", "losses_model", "mc", "no_extra_losses", "mc", "run_model", "weather", "assert", "m", "call_count", "0", "assert", "mc", "results", "losses", "1"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_modelchain.py::test_invalid_dc_model_params", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_invalid_dc_model_params", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_invalid_dc_model_params(sapm_dc_snl_ac_system, cec_dc_snl_ac_system,\n                                 pvwatts_dc_pvwatts_ac_system, location):\n    kwargs = {'dc_model': 'sapm', 'ac_model': 'sandia',\n              'aoi_model': 'no_loss', 'spectral_model': 'no_loss',\n              'temperature_model': 'sapm', 'losses_model': 'no_loss'}\n    for array in sapm_dc_snl_ac_system.arrays:\n        array.module_parameters.pop('A0')  # remove a parameter\n    with pytest.raises(ValueError):\n        ModelChain(sapm_dc_snl_ac_system, location, **kwargs)\n\n    kwargs['dc_model'] = 'singlediode'\n    for array in cec_dc_snl_ac_system.arrays:\n        array.module_parameters.pop('a_ref')  # remove a parameter\n    with pytest.raises(ValueError):\n        ModelChain(cec_dc_snl_ac_system, location, **kwargs)\n\n    kwargs['dc_model'] = 'pvwatts'\n    kwargs['ac_model'] = 'pvwatts'\n    for array in pvwatts_dc_pvwatts_ac_system.arrays:\n        array.module_parameters.pop('pdc0')\n\n    match = 'one or more Arrays are missing one or more required parameters'\n    with pytest.raises(ValueError, match=match):\n        ModelChain(pvwatts_dc_pvwatts_ac_system, location, **kwargs)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_invalid_dc_model_params", "sapm_dc_snl_ac_system", "cec_dc_snl_ac_system", "pvwatts_dc_pvwatts_ac_system", "location", "kwargs", "dc_model", "sapm", "ac_model", "sandia", "aoi_model", "no_loss", "spectral_model", "no_loss", "temperature_model", "sapm", "losses_model", "no_loss", "for", "array", "in", "sapm_dc_snl_ac_system", "arrays", "array", "module_parameters", "pop", "a0", "remove", "a", "parameter", "with", "pytest", "raises", "valueerror", "modelchain", "sapm_dc_snl_ac_system", "location", "kwargs", "kwargs", "dc_model", "singlediode", "for", "array", "in", "cec_dc_snl_ac_system", "arrays", "array", "module_parameters", "pop", "a_ref", "remove", "a", "parameter", "with", "pytest", "raises", "valueerror", "modelchain", "cec_dc_snl_ac_system", "location", "kwargs", "kwargs", "dc_model", "pvwatts", "kwargs", "ac_model", "pvwatts", "for", "array", "in", "pvwatts_dc_pvwatts_ac_system", "arrays", "array", "module_parameters", "pop", "pdc0", "match", "one", "or", "more", "arrays", "are", "missing", "one", "or", "more", "required", "parameters", "with", "pytest", "raises", "valueerror", "match", "match", "modelchain", "pvwatts_dc_pvwatts_ac_system", "location", "kwargs"], "doc_len": 103}
{"doc_id": "pvlib/tests/test_modelchain.py::test_invalid_models", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_invalid_models", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_invalid_models(model, sapm_dc_snl_ac_system, location):\n    kwargs = {'dc_model': 'pvwatts', 'ac_model': 'pvwatts',\n              'aoi_model': 'no_loss', 'spectral_model': 'no_loss',\n              'temperature_model': 'sapm', 'losses_model': 'no_loss'}\n    kwargs[model] = 'invalid'\n    with pytest.raises(ValueError):\n        ModelChain(sapm_dc_snl_ac_system, location, **kwargs)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_invalid_models", "model", "sapm_dc_snl_ac_system", "location", "kwargs", "dc_model", "pvwatts", "ac_model", "pvwatts", "aoi_model", "no_loss", "spectral_model", "no_loss", "temperature_model", "sapm", "losses_model", "no_loss", "kwargs", "model", "invalid", "with", "pytest", "raises", "valueerror", "modelchain", "sapm_dc_snl_ac_system", "location", "kwargs"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_modelchain.py::test_bad_get_orientation", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_bad_get_orientation", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_bad_get_orientation():\n    with pytest.raises(ValueError):\n        modelchain.get_orientation('bad value')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_bad_get_orientation", "with", "pytest", "raises", "valueerror", "modelchain", "get_orientation", "bad", "value"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_modelchain.py::test_with_sapm_pvsystem_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_with_sapm_pvsystem_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_with_sapm_pvsystem_arrays(sapm_dc_snl_ac_system_Array, location,\n                                   weather):\n    mc = ModelChain.with_sapm(sapm_dc_snl_ac_system_Array, location,\n                              ac_model='sandia')\n    assert mc.dc_model == mc.sapm\n    assert mc.ac_model == mc.sandia_inverter\n    mc.run_model(weather)\n    assert mc.results\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_with_sapm_pvsystem_arrays", "sapm_dc_snl_ac_system_array", "location", "weather", "mc", "modelchain", "with_sapm", "sapm_dc_snl_ac_system_array", "location", "ac_model", "sandia", "assert", "mc", "dc_model", "mc", "sapm", "assert", "mc", "ac_model", "mc", "sandia_inverter", "mc", "run_model", "weather", "assert", "mc", "results"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_no_extra_kwargs", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_no_extra_kwargs", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_no_extra_kwargs(sapm_dc_snl_ac_system, location):\n    with pytest.raises(TypeError, match=\"arbitrary_kwarg\"):\n        ModelChain(sapm_dc_snl_ac_system, location, arbitrary_kwarg='value')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_no_extra_kwargs", "sapm_dc_snl_ac_system", "location", "with", "pytest", "raises", "typeerror", "match", "arbitrary_kwarg", "modelchain", "sapm_dc_snl_ac_system", "location", "arbitrary_kwarg", "value"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_modelchain.py::test_ModelChain_attributes_deprecated_10", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_ModelChain_attributes_deprecated_10", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_ModelChain_attributes_deprecated_10(sapm_dc_snl_ac_system, location):\n    match = 'Use ModelChain.results'\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    with pytest.warns(pvlibDeprecationWarning, match=match):\n        mc.aoi\n    with pytest.warns(pvlibDeprecationWarning, match=match):\n        mc.aoi = 5\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain_attributes_deprecated_10", "sapm_dc_snl_ac_system", "location", "match", "use", "modelchain", "results", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "match", "mc", "aoi", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "match", "mc", "aoi", "5"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_modelchain.py::test_basic_chain_alt_az", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_basic_chain_alt_az", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_basic_chain_alt_az(sam_data, cec_inverter_parameters,\n                            sapm_temperature_cs5p_220m):\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    latitude = 32.2\n    longitude = -111\n    surface_tilt = 0\n    surface_azimuth = 0\n    modules = sam_data['sandiamod']\n    module_parameters = modules['Canadian_Solar_CS5P_220M___2009_']\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    with pytest.warns(pvlibDeprecationWarning, match='with_pvwatts'):\n        dc, ac = modelchain.basic_chain(times, latitude, longitude,\n                                        surface_tilt, surface_azimuth,\n                                        module_parameters, temp_model_params,\n                                        cec_inverter_parameters)\n\n    expected = pd.Series(np.array([111.621405, -2.00000000e-02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_basic_chain_alt_az", "sam_data", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "latitude", "32", "2", "longitude", "111", "surface_tilt", "0", "surface_azimuth", "0", "modules", "sam_data", "sandiamod", "module_parameters", "modules", "canadian_solar_cs5p_220m___2009_", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "with_pvwatts", "dc", "ac", "modelchain", "basic_chain", "times", "latitude", "longitude", "surface_tilt", "surface_azimuth", "module_parameters", "temp_model_params", "cec_inverter_parameters", "expected", "pd", "series", "np", "array", "111", "621405", "2", "00000000e", "02", "index", "times", "assert_series_equal", "ac", "expected"], "doc_len": 73}
{"doc_id": "pvlib/tests/test_modelchain.py::test_basic_chain_altitude_pressure", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_basic_chain_altitude_pressure", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_basic_chain_altitude_pressure(sam_data, cec_inverter_parameters,\n                                       sapm_temperature_cs5p_220m):\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    latitude = 32.2\n    longitude = -111\n    altitude = 700\n    surface_tilt = 0\n    surface_azimuth = 0\n    modules = sam_data['sandiamod']\n    module_parameters = modules['Canadian_Solar_CS5P_220M___2009_']\n    temp_model_params = sapm_temperature_cs5p_220m.copy()\n    with pytest.warns(pvlibDeprecationWarning, match='with_pvwatts'):\n        dc, ac = modelchain.basic_chain(times, latitude, longitude,\n                                        surface_tilt, surface_azimuth,\n                                        module_parameters, temp_model_params,\n                                        cec_inverter_parameters,\n                                        pressure=93194)\n\n    expected = pd.Series(np.array([113.190045, -2.00000000e-02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n\n    with pytest.warns(pvlibDeprecationWarning, match='with_pvwatts'):\n        dc, ac = modelchain.basic_chain(times, latitude, longitude,\n                                        surface_tilt, surface_azimuth,\n                                        module_parameters, temp_model_params,\n                                        cec_inverter_parameters,\n                                        altitude=altitude)\n\n    expected = pd.Series(np.array([113.189814, -2.00000000e-02]),\n                         index=times)\n    assert_series_equal(ac, expected)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_basic_chain_altitude_pressure", "sam_data", "cec_inverter_parameters", "sapm_temperature_cs5p_220m", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "latitude", "32", "2", "longitude", "111", "altitude", "700", "surface_tilt", "0", "surface_azimuth", "0", "modules", "sam_data", "sandiamod", "module_parameters", "modules", "canadian_solar_cs5p_220m___2009_", "temp_model_params", "sapm_temperature_cs5p_220m", "copy", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "with_pvwatts", "dc", "ac", "modelchain", "basic_chain", "times", "latitude", "longitude", "surface_tilt", "surface_azimuth", "module_parameters", "temp_model_params", "cec_inverter_parameters", "pressure", "93194", "expected", "pd", "series", "np", "array", "113", "190045", "2", "00000000e", "02", "index", "times", "assert_series_equal", "ac", "expected", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "with_pvwatts", "dc", "ac", "modelchain", "basic_chain", "times", "latitude", "longitude", "surface_tilt", "surface_azimuth", "module_parameters", "temp_model_params", "cec_inverter_parameters", "altitude", "altitude", "expected", "pd", "series", "np", "array", "113", "189814", "2", "00000000e", "02", "index", "times", "assert_series_equal", "ac", "expected"], "doc_len": 112}
{"doc_id": "pvlib/tests/test_modelchain.py::test_complete_irradiance_clean_run", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_complete_irradiance_clean_run", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_complete_irradiance_clean_run(sapm_dc_snl_ac_system, location):\n    \"\"\"The DataFrame should not change if all columns are passed\"\"\"\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    times = pd.date_range('2010-07-05 9:00:00', periods=2, freq='H')\n    i = pd.DataFrame(\n        {'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n\n    mc.complete_irradiance(i)\n\n    assert_series_equal(mc.results.weather['dni'],\n                        pd.Series([2, 3], index=times, name='dni'))\n    assert_series_equal(mc.results.weather['dhi'],\n                        pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather['ghi'],\n                        pd.Series([9, 5], index=times, name='ghi'))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_complete_irradiance_clean_run", "sapm_dc_snl_ac_system", "location", "the", "dataframe", "should", "not", "change", "if", "all", "columns", "are", "passed", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "times", "pd", "date_range", "2010", "07", "05", "9", "00", "00", "periods", "2", "freq", "h", "i", "pd", "dataframe", "dni", "2", "3", "dhi", "4", "6", "ghi", "9", "5", "index", "times", "mc", "complete_irradiance", "i", "assert_series_equal", "mc", "results", "weather", "dni", "pd", "series", "2", "3", "index", "times", "name", "dni", "assert_series_equal", "mc", "results", "weather", "dhi", "pd", "series", "4", "6", "index", "times", "name", "dhi", "assert_series_equal", "mc", "results", "weather", "ghi", "pd", "series", "9", "5", "index", "times", "name", "ghi"], "doc_len": 91}
{"doc_id": "pvlib/tests/test_modelchain.py::test_complete_irradiance", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_complete_irradiance", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_complete_irradiance(sapm_dc_snl_ac_system, location):\n    \"\"\"Check calculations\"\"\"\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    times = pd.date_range('2010-07-05 7:00:00-0700', periods=2, freq='H')\n    i = pd.DataFrame({'dni': [49.756966, 62.153947],\n                      'ghi': [372.103976116, 497.087579068],\n                      'dhi': [356.543700, 465.44400]}, index=times)\n\n    with pytest.warns(UserWarning):\n        mc.complete_irradiance(i[['ghi', 'dni']])\n    assert_series_equal(mc.results.weather['dhi'],\n                        pd.Series([356.543700, 465.44400],\n                                  index=times, name='dhi'))\n\n    with pytest.warns(UserWarning):\n        mc.complete_irradiance(i[['dhi', 'dni']])\n    assert_series_equal(mc.results.weather['ghi'],\n                        pd.Series([372.103976116, 497.087579068],\n                                  index=times, name='ghi'))\n\n    mc.complete_irradiance(i[['dhi', 'ghi']])\n    assert_series_equal(mc.results.weather['dni'],\n                        pd.Series([49.756966, 62.153947],\n                                  index=times, name='dni'))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_complete_irradiance", "sapm_dc_snl_ac_system", "location", "check", "calculations", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "times", "pd", "date_range", "2010", "07", "05", "7", "00", "00", "0700", "periods", "2", "freq", "h", "i", "pd", "dataframe", "dni", "49", "756966", "62", "153947", "ghi", "372", "103976116", "497", "087579068", "dhi", "356", "543700", "465", "44400", "index", "times", "with", "pytest", "warns", "userwarning", "mc", "complete_irradiance", "i", "ghi", "dni", "assert_series_equal", "mc", "results", "weather", "dhi", "pd", "series", "356", "543700", "465", "44400", "index", "times", "name", "dhi", "with", "pytest", "warns", "userwarning", "mc", "complete_irradiance", "i", "dhi", "dni", "assert_series_equal", "mc", "results", "weather", "ghi", "pd", "series", "372", "103976116", "497", "087579068", "index", "times", "name", "ghi", "mc", "complete_irradiance", "i", "dhi", "ghi", "assert_series_equal", "mc", "results", "weather", "dni", "pd", "series", "49", "756966", "62", "153947", "index", "times", "name", "dni"], "doc_len": 116}
{"doc_id": "pvlib/tests/test_modelchain.py::test_complete_irradiance_arrays", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_complete_irradiance_arrays", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_complete_irradiance_arrays(\n        sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3],\n                            'dhi': [4, 6],\n                            'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError,\n                       match=r\"Input DataFrames must have same index\\.\"):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    for mc_weather in mc.results.weather:\n        assert_series_equal(mc_weather['dni'],\n                            pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'],\n                            pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'],\n                            pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']],\n                                       weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'],\n                        pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'],\n                        pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'],\n                        pd.Series([2, 3], index=times, name='dni'))\n    assert 'dhi' in mc.results.weather[1].columns\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_complete_irradiance_arrays", "sapm_dc_snl_ac_system_same_arrays", "location", "input_type", "modelchain", "complete_irradiance", "can", "accept", "a", "tuple", "of", "weather", "dataframes", "times", "pd", "date_range", "start", "2020", "01", "01", "0700", "0700", "periods", "2", "freq", "h", "weather", "pd", "dataframe", "dni", "2", "3", "dhi", "4", "6", "ghi", "9", "5", "index", "times", "mc", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location", "with", "pytest", "raises", "valueerror", "match", "r", "input", "dataframes", "must", "have", "same", "index", "mc", "complete_irradiance", "input_type", "weather", "weather", "1", "mc", "complete_irradiance", "input_type", "weather", "weather", "for", "mc_weather", "in", "mc", "results", "weather", "assert_series_equal", "mc_weather", "dni", "pd", "series", "2", "3", "index", "times", "name", "dni", "assert_series_equal", "mc_weather", "dhi", "pd", "series", "4", "6", "index", "times", "name", "dhi", "assert_series_equal", "mc_weather", "ghi", "pd", "series", "9", "5", "index", "times", "name", "ghi", "mc", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location", "mc", "complete_irradiance", "input_type", "weather", "ghi", "dhi", "weather", "dhi", "dni", "assert", "dni", "in", "mc", "results", "weather", "0", "columns", "assert", "ghi", "in", "mc", "results", "weather", "1", "columns", "mc", "complete_irradiance", "input_type", "weather", "weather", "ghi", "dni", "assert_series_equal", "mc", "results", "weather", "0", "dhi", "pd", "series", "4", "6", "index", "times", "name", "dhi", "assert_series_equal", "mc", "results", "weather", "0", "ghi", "pd", "series", "9", "5", "index", "times", "name", "ghi", "assert_series_equal", "mc", "results", "weather", "0", "dni", "pd", "series", "2", "3", "index", "times", "name", "dni", "assert", "dhi", "in", "mc", "results", "weather", "1", "columns"], "doc_len": 197}
{"doc_id": "pvlib/tests/test_modelchain.py::test_complete_irradiance_arrays_wrong_length", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_complete_irradiance_arrays_wrong_length", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_complete_irradiance_arrays_wrong_length(\n        sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3],\n                            'dhi': [4, 6],\n                            'ghi': [9, 5]}, index=times)\n    error_str = \"Input must be same length as number \" \\\n                r\"of Arrays in system\\. Expected 2, got [0-9]+\\.\"\n    with pytest.raises(ValueError, match=error_str):\n        mc.complete_irradiance(input_type((weather,)))\n    with pytest.raises(ValueError, match=error_str):\n        mc.complete_irradiance(input_type((weather, weather, weather)))\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_complete_irradiance_arrays_wrong_length", "sapm_dc_snl_ac_system_same_arrays", "location", "input_type", "mc", "modelchain", "sapm_dc_snl_ac_system_same_arrays", "location", "times", "pd", "date_range", "start", "2020", "01", "01", "0700", "0700", "periods", "2", "freq", "h", "weather", "pd", "dataframe", "dni", "2", "3", "dhi", "4", "6", "ghi", "9", "5", "index", "times", "error_str", "input", "must", "be", "same", "length", "as", "number", "r", "of", "arrays", "in", "system", "expected", "2", "got", "0", "9", "with", "pytest", "raises", "valueerror", "match", "error_str", "mc", "complete_irradiance", "input_type", "weather", "with", "pytest", "raises", "valueerror", "match", "error_str", "mc", "complete_irradiance", "input_type", "weather", "weather", "weather"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_modelchain.py::test_unknown_attribute", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_unknown_attribute", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_unknown_attribute(sapm_dc_snl_ac_system, location):\n    mc = ModelChain(sapm_dc_snl_ac_system, location)\n    with pytest.raises(AttributeError):\n        mc.unknown_attribute\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_unknown_attribute", "sapm_dc_snl_ac_system", "location", "mc", "modelchain", "sapm_dc_snl_ac_system", "location", "with", "pytest", "raises", "attributeerror", "mc", "unknown_attribute"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_modelchain.py::test_inconsistent_array_params", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_inconsistent_array_params", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_inconsistent_array_params(location,\n                                   sapm_module_params,\n                                   cec_module_params):\n    module_error = \".* selected for the DC model but one or more Arrays are \" \\\n                   \"missing one or more required parameters\"\n    temperature_error = \"could not infer temperature model from \" \\\n                        r\"system\\.temperature_model_parameters\\. Check \" \\\n                        r\"that all Arrays in system\\.arrays have \" \\\n                        r\"parameters for the same temperature model\\. \" \\\n                        r\"Common temperature model parameters: .*\"\n    different_module_system = pvsystem.PVSystem(\n        arrays=[\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=sapm_module_params),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=cec_module_params),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=cec_module_params)]\n    )\n    with pytest.raises(ValueError, match=module_error):\n        ModelChain(different_module_system, location, dc_model='cec')\n    different_temp_system = pvsystem.PVSystem(\n        arrays=[\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=cec_module_params,\n                temperature_model_parameters={'a': 1,\n                                              'b': 1,\n                                              'deltaT': 1}),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=cec_module_params,\n                temperature_model_parameters={'a': 2,\n                                              'b': 2,\n                                              'deltaT': 2}),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters=cec_module_params,\n                temperature_model_parameters={'b': 3, 'deltaT': 3})]\n    )\n    with pytest.raises(ValueError, match=temperature_error):\n        ModelChain(different_temp_system, location,\n                   ac_model='sandia',\n                   aoi_model='no_loss', spectral_model='no_loss',\n                   temperature_model='sapm')\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_inconsistent_array_params", "location", "sapm_module_params", "cec_module_params", "module_error", "selected", "for", "the", "dc", "model", "but", "one", "or", "more", "arrays", "are", "missing", "one", "or", "more", "required", "parameters", "temperature_error", "could", "not", "infer", "temperature", "model", "from", "r", "system", "temperature_model_parameters", "check", "r", "that", "all", "arrays", "in", "system", "arrays", "have", "r", "parameters", "for", "the", "same", "temperature", "model", "r", "common", "temperature", "model", "parameters", "different_module_system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "cec_module_params", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "cec_module_params", "with", "pytest", "raises", "valueerror", "match", "module_error", "modelchain", "different_module_system", "location", "dc_model", "cec", "different_temp_system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "cec_module_params", "temperature_model_parameters", "a", "1", "b", "1", "deltat", "1", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "cec_module_params", "temperature_model_parameters", "a", "2", "b", "2", "deltat", "2", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "cec_module_params", "temperature_model_parameters", "b", "3", "deltat", "3", "with", "pytest", "raises", "valueerror", "match", "temperature_error", "modelchain", "different_temp_system", "location", "ac_model", "sandia", "aoi_model", "no_loss", "spectral_model", "no_loss", "temperature_model", "sapm"], "doc_len": 167}
{"doc_id": "pvlib/tests/test_modelchain.py::test_modelchain__common_keys", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test_modelchain__common_keys", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test_modelchain__common_keys():\n    dictionary = {'a': 1, 'b': 1}\n    series = pd.Series(dictionary)\n    assert {'a', 'b'} == modelchain._common_keys(\n        {'a': 1, 'b': 1}\n    )\n    assert {'a', 'b'} == modelchain._common_keys(\n        pd.Series({'a': 1, 'b': 1})\n    )\n    assert {'a', 'b'} == modelchain._common_keys(\n        (dictionary, series)\n    )\n    no_a = dictionary.copy()\n    del no_a['a']\n    assert {'b'} == modelchain._common_keys(\n        (dictionary, no_a)\n    )\n    assert {'b'} == modelchain._common_keys(\n        (series, pd.Series(no_a))\n    )\n    assert {'b'} == modelchain._common_keys(\n        (series, no_a)\n    )\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test_modelchain__common_keys", "dictionary", "a", "1", "b", "1", "series", "pd", "series", "dictionary", "assert", "a", "b", "modelchain", "_common_keys", "a", "1", "b", "1", "assert", "a", "b", "modelchain", "_common_keys", "pd", "series", "a", "1", "b", "1", "assert", "a", "b", "modelchain", "_common_keys", "dictionary", "series", "no_a", "dictionary", "copy", "del", "no_a", "a", "assert", "b", "modelchain", "_common_keys", "dictionary", "no_a", "assert", "b", "modelchain", "_common_keys", "series", "pd", "series", "no_a", "assert", "b", "modelchain", "_common_keys", "series", "no_a"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_modelchain.py::test__irrad_for_celltemp", "file_path": "pvlib/tests/test_modelchain.py", "class_name": null, "func_name": "test__irrad_for_celltemp", "text": "文件路径: pvlib/tests/test_modelchain.py\ndef test__irrad_for_celltemp():\n    total_irrad = pd.DataFrame(index=[0, 1], columns=['poa_global'],\n                               data=[10., 20.])\n    empty = total_irrad.drop('poa_global', axis=1)\n    effect_irrad = pd.Series(index=total_irrad.index, data=[5., 8.])\n    # test with single array inputs\n    poa = modelchain._irrad_for_celltemp(total_irrad, effect_irrad)\n    assert_series_equal(poa, total_irrad['poa_global'])\n    poa = modelchain._irrad_for_celltemp(empty, effect_irrad)\n    assert_series_equal(poa, effect_irrad)\n    # test with tuples\n    poa = modelchain._irrad_for_celltemp(\n        (total_irrad, total_irrad), (effect_irrad, effect_irrad))\n    assert len(poa) == 2\n    assert_series_equal(poa[0], total_irrad['poa_global'])\n    assert_series_equal(poa[1], total_irrad['poa_global'])\n    poa = modelchain._irrad_for_celltemp(\n        (empty, empty), (effect_irrad, effect_irrad))\n    assert len(poa) == 2\n    assert_series_equal(poa[0], effect_irrad)\n    assert_series_equal(poa[1], effect_irrad)\n", "tokens": ["pvlib", "tests", "test_modelchain", "py", "def", "test__irrad_for_celltemp", "total_irrad", "pd", "dataframe", "index", "0", "1", "columns", "poa_global", "data", "10", "20", "empty", "total_irrad", "drop", "poa_global", "axis", "1", "effect_irrad", "pd", "series", "index", "total_irrad", "index", "data", "5", "8", "test", "with", "single", "array", "inputs", "poa", "modelchain", "_irrad_for_celltemp", "total_irrad", "effect_irrad", "assert_series_equal", "poa", "total_irrad", "poa_global", "poa", "modelchain", "_irrad_for_celltemp", "empty", "effect_irrad", "assert_series_equal", "poa", "effect_irrad", "test", "with", "tuples", "poa", "modelchain", "_irrad_for_celltemp", "total_irrad", "total_irrad", "effect_irrad", "effect_irrad", "assert", "len", "poa", "2", "assert_series_equal", "poa", "0", "total_irrad", "poa_global", "assert_series_equal", "poa", "1", "total_irrad", "poa_global", "poa", "modelchain", "_irrad_for_celltemp", "empty", "empty", "effect_irrad", "effect_irrad", "assert", "len", "poa", "2", "assert_series_equal", "poa", "0", "effect_irrad", "assert_series_equal", "poa", "1", "effect_irrad"], "doc_len": 97}
{"doc_id": "pvlib/tests/test_numerical_precision.py::generate_numerical_precision", "file_path": "pvlib/tests/test_numerical_precision.py", "class_name": null, "func_name": "generate_numerical_precision", "text": "文件路径: pvlib/tests/test_numerical_precision.py\ndef generate_numerical_precision():  # pragma: no cover\n    \"\"\"\n    Generate expected data with infinite numerical precision using SymPy.\n    :return: dataframe of expected values\n    \"\"\"\n    if symbols is NotImplemented:\n        LOGGER.critical(\"SymPy is required to generate expected data.\")\n        raise ImportError(\"could not import sympy\")\n    il, io, rs, rsh, nnsvt, vd = symbols('il, io, rs, rsh, nnsvt, vd')\n    a = sy_exp(vd / nnsvt)\n    b = 1.0 / rsh\n    i = il - io * (a - 1.0) - vd * b\n    v = vd - i * rs\n    c = io * a / nnsvt\n    grad_i = - c - b  # di/dvd\n    grad_v = 1.0 - grad_i * rs  # dv/dvd\n    # dp/dv = d(iv)/dv = v * di/dv + i\n    grad = grad_i / grad_v  # di/dv\n    p = i * v\n    grad_p = v * grad + i  # dp/dv\n    grad2i = -c / nnsvt\n    grad2v = -grad2i * rs\n    grad2p = (\n        grad_v * grad + v * (grad2i/grad_v - grad_i*grad2v/grad_v**2) + grad_i\n    )\n    # generate exact values\n    data = dict(zip((il, io, rs, rsh, nnsvt), ARGS))\n    vdtest = np.linspace(0, estimate_voc(IL, I0, NNSVTH), IVCURVE_NPTS)\n    expected = []\n    for test in vdtest:\n        data[vd] = test\n        test_data = {\n            'i': np.float64(i.evalf(subs=data)),\n            'v': np.float64(v.evalf(subs=data)),\n            'p': np.float64(p.evalf(subs=data)),\n            'grad_i': np.float64(grad_i.evalf(subs=data)),\n            'grad_v': np.float64(grad_v.evalf(subs=data)),\n            'grad': np.float64(grad.evalf(subs=data)),\n            'grad_p': np.float64(grad_p.evalf(subs=data)),\n            'grad2p': np.float64(grad2p.evalf(subs=data))\n        }\n        LOGGER.debug(test_data)\n        expected.append(test_data)\n    return pd.DataFrame(expected, index=vdtest)\n", "tokens": ["pvlib", "tests", "test_numerical_precision", "py", "def", "generate_numerical_precision", "pragma", "no", "cover", "generate", "expected", "data", "with", "infinite", "numerical", "precision", "using", "sympy", "return", "dataframe", "of", "expected", "values", "if", "symbols", "is", "notimplemented", "logger", "critical", "sympy", "is", "required", "to", "generate", "expected", "data", "raise", "importerror", "could", "not", "import", "sympy", "il", "io", "rs", "rsh", "nnsvt", "vd", "symbols", "il", "io", "rs", "rsh", "nnsvt", "vd", "a", "sy_exp", "vd", "nnsvt", "b", "1", "0", "rsh", "i", "il", "io", "a", "1", "0", "vd", "b", "v", "vd", "i", "rs", "c", "io", "a", "nnsvt", "grad_i", "c", "b", "di", "dvd", "grad_v", "1", "0", "grad_i", "rs", "dv", "dvd", "dp", "dv", "d", "iv", "dv", "v", "di", "dv", "i", "grad", "grad_i", "grad_v", "di", "dv", "p", "i", "v", "grad_p", "v", "grad", "i", "dp", "dv", "grad2i", "c", "nnsvt", "grad2v", "grad2i", "rs", "grad2p", "grad_v", "grad", "v", "grad2i", "grad_v", "grad_i", "grad2v", "grad_v", "2", "grad_i", "generate", "exact", "values", "data", "dict", "zip", "il", "io", "rs", "rsh", "nnsvt", "args", "vdtest", "np", "linspace", "0", "estimate_voc", "il", "i0", "nnsvth", "ivcurve_npts", "expected", "for", "test", "in", "vdtest", "data", "vd", "test", "test_data", "i", "np", "float64", "i", "evalf", "subs", "data", "v", "np", "float64", "v", "evalf", "subs", "data", "p", "np", "float64", "p", "evalf", "subs", "data", "grad_i", "np", "float64", "grad_i", "evalf", "subs", "data", "grad_v", "np", "float64", "grad_v", "evalf", "subs", "data", "grad", "np", "float64", "grad", "evalf", "subs", "data", "grad_p", "np", "float64", "grad_p", "evalf", "subs", "data", "grad2p", "np", "float64", "grad2p", "evalf", "subs", "data", "logger", "debug", "test_data", "expected", "append", "test_data", "return", "pd", "dataframe", "expected", "index", "vdtest"], "doc_len": 229}
{"doc_id": "pvlib/tests/test_numerical_precision.py::test_numerical_precision", "file_path": "pvlib/tests/test_numerical_precision.py", "class_name": null, "func_name": "test_numerical_precision", "text": "文件路径: pvlib/tests/test_numerical_precision.py\ndef test_numerical_precision():\n    \"\"\"\n    Test that there are no numerical errors due to floating point arithmetic.\n    \"\"\"\n    expected = pd.read_csv(DATA_PATH)\n    vdtest = np.linspace(0, estimate_voc(IL, I0, NNSVTH), IVCURVE_NPTS)\n    results = bishop88(vdtest, *ARGS, gradients=True)\n    assert np.allclose(expected['i'], results[0])\n    assert np.allclose(expected['v'], results[1])\n    assert np.allclose(expected['p'], results[2])\n    assert np.allclose(expected['grad_i'], results[3])\n    assert np.allclose(expected['grad_v'], results[4])\n    assert np.allclose(expected['grad'], results[5])\n    assert np.allclose(expected['grad_p'], results[6])\n    assert np.allclose(expected['grad2p'], results[7])\n", "tokens": ["pvlib", "tests", "test_numerical_precision", "py", "def", "test_numerical_precision", "test", "that", "there", "are", "no", "numerical", "errors", "due", "to", "floating", "point", "arithmetic", "expected", "pd", "read_csv", "data_path", "vdtest", "np", "linspace", "0", "estimate_voc", "il", "i0", "nnsvth", "ivcurve_npts", "results", "bishop88", "vdtest", "args", "gradients", "true", "assert", "np", "allclose", "expected", "i", "results", "0", "assert", "np", "allclose", "expected", "v", "results", "1", "assert", "np", "allclose", "expected", "p", "results", "2", "assert", "np", "allclose", "expected", "grad_i", "results", "3", "assert", "np", "allclose", "expected", "grad_v", "results", "4", "assert", "np", "allclose", "expected", "grad", "results", "5", "assert", "np", "allclose", "expected", "grad_p", "results", "6", "assert", "np", "allclose", "expected", "grad2p", "results", "7"], "doc_len": 93}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_iam", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_iam", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_iam(mocker, iam_model, model_params):\n    m = mocker.spy(_iam, iam_model)\n    system = pvsystem.PVSystem(module_parameters=model_params)\n    thetas = 1\n    iam = system.get_iam(thetas, iam_model=iam_model)\n    m.assert_called_with(thetas, **model_params)\n    assert iam < 1.\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_iam", "mocker", "iam_model", "model_params", "m", "mocker", "spy", "_iam", "iam_model", "system", "pvsystem", "pvsystem", "module_parameters", "model_params", "thetas", "1", "iam", "system", "get_iam", "thetas", "iam_model", "iam_model", "m", "assert_called_with", "thetas", "model_params", "assert", "iam", "1"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_get_iam", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_get_iam", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_get_iam():\n    model_params = {'b': 0.05}\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(mount=pvsystem.FixedMount(0, 180),\n                               module_parameters=model_params),\n                pvsystem.Array(mount=pvsystem.FixedMount(0, 180),\n                               module_parameters=model_params)]\n    )\n    iam = system.get_iam((1, 5), iam_model='ashrae')\n    assert len(iam) == 2\n    assert iam[0] != iam[1]\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_iam((1,), iam_model='ashrae')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_get_iam", "model_params", "b", "0", "05", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "model_params", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "model_params", "iam", "system", "get_iam", "1", "5", "iam_model", "ashrae", "assert", "len", "iam", "2", "assert", "iam", "0", "iam", "1", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_iam", "1", "iam_model", "ashrae"], "doc_len": 64}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_iam_sapm", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_iam_sapm", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_iam_sapm(sapm_module_params, mocker):\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    mocker.spy(_iam, 'sapm')\n    aoi = 0\n    out = system.get_iam(aoi, 'sapm')\n    _iam.sapm.assert_called_once_with(aoi, sapm_module_params)\n    assert_allclose(out, 1.0, atol=0.01)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_iam_sapm", "sapm_module_params", "mocker", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "mocker", "spy", "_iam", "sapm", "aoi", "0", "out", "system", "get_iam", "aoi", "sapm", "_iam", "sapm", "assert_called_once_with", "aoi", "sapm_module_params", "assert_allclose", "out", "1", "0", "atol", "0", "01"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_iam_interp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_iam_interp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_iam_interp(sapm_module_params, mocker):\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    with pytest.raises(ValueError):\n        system.get_iam(45, iam_model='interp')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_iam_interp", "sapm_module_params", "mocker", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "with", "pytest", "raises", "valueerror", "system", "get_iam", "45", "iam_model", "interp"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_pvsystem.py::test__normalize_sam_product_names", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test__normalize_sam_product_names", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test__normalize_sam_product_names():\n\n    BAD_NAMES  = [' -.()[]:+/\",', 'Module[1]']\n    NORM_NAMES = ['____________', 'Module_1_']\n\n    norm_names = pvsystem._normalize_sam_product_names(BAD_NAMES)\n    assert list(norm_names) == NORM_NAMES\n\n    BAD_NAMES  = ['Module[1]', 'Module(1)']\n    NORM_NAMES = ['Module_1_', 'Module_1_']\n\n    with pytest.warns(UserWarning):\n        norm_names = pvsystem._normalize_sam_product_names(BAD_NAMES)\n    assert list(norm_names) == NORM_NAMES\n\n    BAD_NAMES  = ['Module[1]', 'Module[1]']\n    NORM_NAMES = ['Module_1_', 'Module_1_']\n\n    with pytest.warns(UserWarning):\n        norm_names = pvsystem._normalize_sam_product_names(BAD_NAMES)\n    assert list(norm_names) == NORM_NAMES\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test__normalize_sam_product_names", "bad_names", "module", "1", "norm_names", "____________", "module_1_", "norm_names", "pvsystem", "_normalize_sam_product_names", "bad_names", "assert", "list", "norm_names", "norm_names", "bad_names", "module", "1", "module", "1", "norm_names", "module_1_", "module_1_", "with", "pytest", "warns", "userwarning", "norm_names", "pvsystem", "_normalize_sam_product_names", "bad_names", "assert", "list", "norm_names", "norm_names", "bad_names", "module", "1", "module", "1", "norm_names", "module_1_", "module_1_", "with", "pytest", "warns", "userwarning", "norm_names", "pvsystem", "_normalize_sam_product_names", "bad_names", "assert", "list", "norm_names", "norm_names"], "doc_len": 60}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_iam_invalid", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_iam_invalid", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_iam_invalid(sapm_module_params, mocker):\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    with pytest.raises(ValueError):\n        system.get_iam(45, iam_model='not_a_model')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_iam_invalid", "sapm_module_params", "mocker", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "with", "pytest", "raises", "valueerror", "system", "get_iam", "45", "iam_model", "not_a_model"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_retrieve_sam_raise_no_parameters", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_retrieve_sam_raise_no_parameters", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_retrieve_sam_raise_no_parameters():\n    \"\"\"\n    Raise an exception if no parameters are provided to `retrieve_sam()`.\n    \"\"\"\n    with pytest.raises(ValueError) as error:\n        pvsystem.retrieve_sam()\n    assert 'A name or path must be provided!' == str(error.value)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_retrieve_sam_raise_no_parameters", "raise", "an", "exception", "if", "no", "parameters", "are", "provided", "to", "retrieve_sam", "with", "pytest", "raises", "valueerror", "as", "error", "pvsystem", "retrieve_sam", "assert", "a", "name", "or", "path", "must", "be", "provided", "str", "error", "value"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_retrieve_sam_cecmod", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_retrieve_sam_cecmod", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_retrieve_sam_cecmod():\n    \"\"\"\n    Test the expected data is retrieved from the CEC module database. In\n    particular, check for a known module in the database and check for the\n    expected keys for that module.\n    \"\"\"\n    data = pvsystem.retrieve_sam('cecmod')\n    keys = [\n        'BIPV',\n        'Date',\n        'T_NOCT',\n        'A_c',\n        'N_s',\n        'I_sc_ref',\n        'V_oc_ref',\n        'I_mp_ref',\n        'V_mp_ref',\n        'alpha_sc',\n        'beta_oc',\n        'a_ref',\n        'I_L_ref',\n        'I_o_ref',\n        'R_s',\n        'R_sh_ref',\n        'Adjust',\n        'gamma_r',\n        'Version',\n        'STC',\n        'PTC',\n        'Technology',\n        'Bifacial',\n        'Length',\n        'Width',\n    ]\n    module = 'Itek_Energy_LLC_iT_300_HE'\n    assert module in data\n    assert set(data[module].keys()) == set(keys)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_retrieve_sam_cecmod", "test", "the", "expected", "data", "is", "retrieved", "from", "the", "cec", "module", "database", "in", "particular", "check", "for", "a", "known", "module", "in", "the", "database", "and", "check", "for", "the", "expected", "keys", "for", "that", "module", "data", "pvsystem", "retrieve_sam", "cecmod", "keys", "bipv", "date", "t_noct", "a_c", "n_s", "i_sc_ref", "v_oc_ref", "i_mp_ref", "v_mp_ref", "alpha_sc", "beta_oc", "a_ref", "i_l_ref", "i_o_ref", "r_s", "r_sh_ref", "adjust", "gamma_r", "version", "stc", "ptc", "technology", "bifacial", "length", "width", "module", "itek_energy_llc_it_300_he", "assert", "module", "in", "data", "assert", "set", "data", "module", "keys", "set", "keys"], "doc_len": 79}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_retrieve_sam_cecinverter", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_retrieve_sam_cecinverter", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_retrieve_sam_cecinverter():\n    \"\"\"\n    Test the expected data is retrieved from the CEC inverter database. In\n    particular, check for a known inverter in the database and check for the\n    expected keys for that inverter.\n    \"\"\"\n    data = pvsystem.retrieve_sam('cecinverter')\n    keys = [\n        'Vac',\n        'Paco',\n        'Pdco',\n        'Vdco',\n        'Pso',\n        'C0',\n        'C1',\n        'C2',\n        'C3',\n        'Pnt',\n        'Vdcmax',\n        'Idcmax',\n        'Mppt_low',\n        'Mppt_high',\n        'CEC_Date',\n        'CEC_Type',\n    ]\n    inverter = 'Yaskawa_Solectria_Solar__PVI_5300_208__208V_'\n    assert inverter in data\n    assert set(data[inverter].keys()) == set(keys)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_retrieve_sam_cecinverter", "test", "the", "expected", "data", "is", "retrieved", "from", "the", "cec", "inverter", "database", "in", "particular", "check", "for", "a", "known", "inverter", "in", "the", "database", "and", "check", "for", "the", "expected", "keys", "for", "that", "inverter", "data", "pvsystem", "retrieve_sam", "cecinverter", "keys", "vac", "paco", "pdco", "vdco", "pso", "c0", "c1", "c2", "c3", "pnt", "vdcmax", "idcmax", "mppt_low", "mppt_high", "cec_date", "cec_type", "inverter", "yaskawa_solectria_solar__pvi_5300_208__208v_", "assert", "inverter", "in", "data", "assert", "set", "data", "inverter", "keys", "set", "keys"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_sapm", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_sapm", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_sapm(sapm_module_params):\n\n    times = pd.date_range(start='2015-01-01', periods=5, freq='12H')\n    effective_irradiance = pd.Series([-1000, 500, 1100, np.nan, 1000],\n                                     index=times)\n    temp_cell = pd.Series([10, 25, 50, 25, np.nan], index=times)\n\n    out = pvsystem.sapm(effective_irradiance, temp_cell, sapm_module_params)\n\n    expected = pd.DataFrame(np.array(\n      [[  -5.0608322 ,   -4.65037767,           nan,           nan,\n                  nan,   -4.91119927,   -4.15367716],\n       [   2.545575  ,    2.28773882,   56.86182059,   47.21121608,\n         108.00693168,    2.48357383,    1.71782772],\n       [   5.65584763,    5.01709903,   54.1943277 ,   42.51861718,\n         213.32011294,    5.52987899,    3.48660728],\n       [          nan,           nan,           nan,           nan,\n                  nan,           nan,           nan],\n       [          nan,           nan,           nan,           nan,\n                  nan,           nan,           nan]]),\n        columns=['i_sc', 'i_mp', 'v_oc', 'v_mp', 'p_mp', 'i_x', 'i_xx'],\n        index=times)\n\n    assert_frame_equal(out, expected, check_less_precise=4)\n\n    out = pvsystem.sapm(1000, 25, sapm_module_params)\n\n    expected = OrderedDict()\n    expected['i_sc'] = 5.09115\n    expected['i_mp'] = 4.5462909092579995\n    expected['v_oc'] = 59.260800000000003\n    expected['v_mp'] = 48.315600000000003\n    expected['p_mp'] = 219.65677305534581\n    expected['i_x'] = 4.9759899999999995\n    expected['i_xx'] = 3.1880204359100004\n\n    for k, v in expected.items():\n        assert_allclose(out[k], v, atol=1e-4)\n\n    # just make sure it works with Series input\n    pvsystem.sapm(effective_irradiance, temp_cell,\n                  pd.Series(sapm_module_params))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_sapm", "sapm_module_params", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "5", "freq", "12h", "effective_irradiance", "pd", "series", "1000", "500", "1100", "np", "nan", "1000", "index", "times", "temp_cell", "pd", "series", "10", "25", "50", "25", "np", "nan", "index", "times", "out", "pvsystem", "sapm", "effective_irradiance", "temp_cell", "sapm_module_params", "expected", "pd", "dataframe", "np", "array", "5", "0608322", "4", "65037767", "nan", "nan", "nan", "4", "91119927", "4", "15367716", "2", "545575", "2", "28773882", "56", "86182059", "47", "21121608", "108", "00693168", "2", "48357383", "1", "71782772", "5", "65584763", "5", "01709903", "54", "1943277", "42", "51861718", "213", "32011294", "5", "52987899", "3", "48660728", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "columns", "i_sc", "i_mp", "v_oc", "v_mp", "p_mp", "i_x", "i_xx", "index", "times", "assert_frame_equal", "out", "expected", "check_less_precise", "4", "out", "pvsystem", "sapm", "1000", "25", "sapm_module_params", "expected", "ordereddict", "expected", "i_sc", "5", "09115", "expected", "i_mp", "4", "5462909092579995", "expected", "v_oc", "59", "260800000000003", "expected", "v_mp", "48", "315600000000003", "expected", "p_mp", "219", "65677305534581", "expected", "i_x", "4", "9759899999999995", "expected", "i_xx", "3", "1880204359100004", "for", "k", "v", "in", "expected", "items", "assert_allclose", "out", "k", "v", "atol", "1e", "4", "just", "make", "sure", "it", "works", "with", "series", "input", "pvsystem", "sapm", "effective_irradiance", "temp_cell", "pd", "series", "sapm_module_params"], "doc_len": 183}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm(sapm_module_params, mocker):\n    mocker.spy(pvsystem, 'sapm')\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    effective_irradiance = 500\n    temp_cell = 25\n    out = system.sapm(effective_irradiance, temp_cell)\n    pvsystem.sapm.assert_called_once_with(effective_irradiance, temp_cell,\n                                          sapm_module_params)\n    assert_allclose(out['p_mp'], 100, atol=100)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm", "sapm_module_params", "mocker", "mocker", "spy", "pvsystem", "sapm", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "effective_irradiance", "500", "temp_cell", "25", "out", "system", "sapm", "effective_irradiance", "temp_cell", "pvsystem", "sapm", "assert_called_once_with", "effective_irradiance", "temp_cell", "sapm_module_params", "assert_allclose", "out", "p_mp", "100", "atol", "100"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_sapm", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_sapm", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_sapm(sapm_module_params):\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params),\n                pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params)]\n    )\n    effective_irradiance = (100, 500)\n    temp_cell = (15, 25)\n    sapm_one, sapm_two = system.sapm(effective_irradiance, temp_cell)\n    assert sapm_one['p_mp'] != sapm_two['p_mp']\n    sapm_one_flip, sapm_two_flip = system.sapm(\n        (effective_irradiance[1], effective_irradiance[0]),\n        (temp_cell[1], temp_cell[0])\n    )\n    assert sapm_one_flip['p_mp'] == sapm_two['p_mp']\n    assert sapm_two_flip['p_mp'] == sapm_one['p_mp']\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.sapm(effective_irradiance, 10)\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.sapm(500, temp_cell)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_sapm", "sapm_module_params", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "effective_irradiance", "100", "500", "temp_cell", "15", "25", "sapm_one", "sapm_two", "system", "sapm", "effective_irradiance", "temp_cell", "assert", "sapm_one", "p_mp", "sapm_two", "p_mp", "sapm_one_flip", "sapm_two_flip", "system", "sapm", "effective_irradiance", "1", "effective_irradiance", "0", "temp_cell", "1", "temp_cell", "0", "assert", "sapm_one_flip", "p_mp", "sapm_two", "p_mp", "assert", "sapm_two_flip", "p_mp", "sapm_one", "p_mp", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "sapm", "effective_irradiance", "10", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "sapm", "500", "temp_cell"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_sapm_spectral_loss", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_sapm_spectral_loss", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_sapm_spectral_loss(sapm_module_params, airmass, expected):\n\n    out = pvsystem.sapm_spectral_loss(airmass, sapm_module_params)\n\n    if isinstance(airmass, pd.Series):\n        assert_series_equal(out, expected, check_less_precise=4)\n    else:\n        assert_allclose(out, expected, atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_sapm_spectral_loss", "sapm_module_params", "airmass", "expected", "out", "pvsystem", "sapm_spectral_loss", "airmass", "sapm_module_params", "if", "isinstance", "airmass", "pd", "series", "assert_series_equal", "out", "expected", "check_less_precise", "4", "else", "assert_allclose", "out", "expected", "atol", "1e", "4"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm_spectral_loss", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm_spectral_loss", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm_spectral_loss(sapm_module_params, mocker):\n    mocker.spy(pvsystem, 'sapm_spectral_loss')\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    airmass = 2\n    out = system.sapm_spectral_loss(airmass)\n    pvsystem.sapm_spectral_loss.assert_called_once_with(airmass,\n                                                        sapm_module_params)\n    assert_allclose(out, 1, atol=0.5)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm_spectral_loss", "sapm_module_params", "mocker", "mocker", "spy", "pvsystem", "sapm_spectral_loss", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "airmass", "2", "out", "system", "sapm_spectral_loss", "airmass", "pvsystem", "sapm_spectral_loss", "assert_called_once_with", "airmass", "sapm_module_params", "assert_allclose", "out", "1", "atol", "0", "5"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_sapm_spectral_loss", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_sapm_spectral_loss", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_sapm_spectral_loss(sapm_module_params):\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params),\n                pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params)]\n    )\n    loss_one, loss_two = system.sapm_spectral_loss(2)\n    assert loss_one == loss_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_sapm_spectral_loss", "sapm_module_params", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "loss_one", "loss_two", "system", "sapm_spectral_loss", "2", "assert", "loss_one", "loss_two"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_first_solar_spectral_loss", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_first_solar_spectral_loss", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_first_solar_spectral_loss(module_parameters, module_type,\n                                            coefficients, mocker):\n    mocker.spy(atmosphere, 'first_solar_spectral_correction')\n    system = pvsystem.PVSystem(module_parameters=module_parameters)\n    pw = 3\n    airmass_absolute = 3\n    out = system.first_solar_spectral_loss(pw, airmass_absolute)\n    atmosphere.first_solar_spectral_correction.assert_called_once_with(\n        pw, airmass_absolute, module_type, coefficients)\n    assert_allclose(out, 1, atol=0.5)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_first_solar_spectral_loss", "module_parameters", "module_type", "coefficients", "mocker", "mocker", "spy", "atmosphere", "first_solar_spectral_correction", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "pw", "3", "airmass_absolute", "3", "out", "system", "first_solar_spectral_loss", "pw", "airmass_absolute", "atmosphere", "first_solar_spectral_correction", "assert_called_once_with", "pw", "airmass_absolute", "module_type", "coefficients", "assert_allclose", "out", "1", "atol", "0", "5"], "doc_len": 41}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_first_solar_spectral_loss", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_first_solar_spectral_loss", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_first_solar_spectral_loss():\n    system = pvsystem.PVSystem(\n        arrays=[\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters={'Technology': 'mc-Si'},\n                module_type='multisi'\n            ),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                module_parameters={'Technology': 'mc-Si'},\n                module_type='multisi'\n            )\n        ]\n    )\n    loss_one, loss_two = system.first_solar_spectral_loss(1, 3)\n    assert loss_one == loss_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_first_solar_spectral_loss", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "technology", "mc", "si", "module_type", "multisi", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "technology", "mc", "si", "module_type", "multisi", "loss_one", "loss_two", "system", "first_solar_spectral_loss", "1", "3", "assert", "loss_one", "loss_two"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_sapm_effective_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_sapm_effective_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_sapm_effective_irradiance(sapm_module_params, test_input, expected):\n    test_input.append(sapm_module_params)\n    out = pvsystem.sapm_effective_irradiance(*test_input)\n    if isinstance(test_input, pd.Series):\n        assert_series_equal(out, expected, check_less_precise=4)\n    else:\n        assert_allclose(out, expected, atol=1e-1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_sapm_effective_irradiance", "sapm_module_params", "test_input", "expected", "test_input", "append", "sapm_module_params", "out", "pvsystem", "sapm_effective_irradiance", "test_input", "if", "isinstance", "test_input", "pd", "series", "assert_series_equal", "out", "expected", "check_less_precise", "4", "else", "assert_allclose", "out", "expected", "atol", "1e", "1"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm_effective_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm_effective_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm_effective_irradiance(sapm_module_params, mocker):\n    system = pvsystem.PVSystem(module_parameters=sapm_module_params)\n    mocker.spy(pvsystem, 'sapm_effective_irradiance')\n\n    poa_direct = 900\n    poa_diffuse = 100\n    airmass_absolute = 1.5\n    aoi = 0\n    p = (sapm_module_params['A4'], sapm_module_params['A3'],\n         sapm_module_params['A2'], sapm_module_params['A1'],\n         sapm_module_params['A0'])\n    f1 = np.polyval(p, airmass_absolute)\n    expected = f1 * (poa_direct + sapm_module_params['FD'] * poa_diffuse)\n    out = system.sapm_effective_irradiance(\n        poa_direct, poa_diffuse, airmass_absolute, aoi)\n    pvsystem.sapm_effective_irradiance.assert_called_once_with(\n        poa_direct, poa_diffuse, airmass_absolute, aoi, sapm_module_params)\n    assert_allclose(out, expected, atol=0.1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm_effective_irradiance", "sapm_module_params", "mocker", "system", "pvsystem", "pvsystem", "module_parameters", "sapm_module_params", "mocker", "spy", "pvsystem", "sapm_effective_irradiance", "poa_direct", "900", "poa_diffuse", "100", "airmass_absolute", "1", "5", "aoi", "0", "p", "sapm_module_params", "a4", "sapm_module_params", "a3", "sapm_module_params", "a2", "sapm_module_params", "a1", "sapm_module_params", "a0", "f1", "np", "polyval", "p", "airmass_absolute", "expected", "f1", "poa_direct", "sapm_module_params", "fd", "poa_diffuse", "out", "system", "sapm_effective_irradiance", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "pvsystem", "sapm_effective_irradiance", "assert_called_once_with", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "sapm_module_params", "assert_allclose", "out", "expected", "atol", "0", "1"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_sapm_effective_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_sapm_effective_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_sapm_effective_irradiance(sapm_module_params):\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params),\n                pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               module_parameters=sapm_module_params)]\n    )\n    poa_direct = (500, 900)\n    poa_diffuse = (50, 100)\n    aoi = (0, 10)\n    airmass_absolute = 1.5\n    irrad_one, irrad_two = system.sapm_effective_irradiance(\n        poa_direct, poa_diffuse, airmass_absolute, aoi\n    )\n    assert irrad_one != irrad_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_sapm_effective_irradiance", "sapm_module_params", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "sapm_module_params", "poa_direct", "500", "900", "poa_diffuse", "50", "100", "aoi", "0", "10", "airmass_absolute", "1", "5", "irrad_one", "irrad_two", "system", "sapm_effective_irradiance", "poa_direct", "poa_diffuse", "airmass_absolute", "aoi", "assert", "irrad_one", "irrad_two"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_pvsystem.py::two_array_system", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "two_array_system", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef two_array_system(pvsyst_module_params, cec_module_params):\n    \"\"\"Two-array PVSystem.\n\n    Both arrays are identical.\n    \"\"\"\n    temperature_model = temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'open_rack_glass_glass'\n    ]\n    # Need u_v to be non-zero so wind-speed changes cell temperature\n    # under the pvsyst model.\n    temperature_model['u_v'] = 1.0\n    # parameter for fuentes temperature model\n    temperature_model['noct_installed'] = 45\n    # parameters for noct_sam temperature model\n    temperature_model['noct'] = 45.\n    temperature_model['module_efficiency'] = 0.2\n    module_params = {**pvsyst_module_params, **cec_module_params}\n    return pvsystem.PVSystem(\n        arrays=[\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                temperature_model_parameters=temperature_model,\n                module_parameters=module_params\n            ),\n            pvsystem.Array(\n                mount=pvsystem.FixedMount(0, 180),\n                temperature_model_parameters=temperature_model,\n                module_parameters=module_params\n            )\n        ]\n    )\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "two_array_system", "pvsyst_module_params", "cec_module_params", "two", "array", "pvsystem", "both", "arrays", "are", "identical", "temperature_model", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "need", "u_v", "to", "be", "non", "zero", "so", "wind", "speed", "changes", "cell", "temperature", "under", "the", "pvsyst", "model", "temperature_model", "u_v", "1", "0", "parameter", "for", "fuentes", "temperature", "model", "temperature_model", "noct_installed", "45", "parameters", "for", "noct_sam", "temperature", "model", "temperature_model", "noct", "45", "temperature_model", "module_efficiency", "0", "2", "module_params", "pvsyst_module_params", "cec_module_params", "return", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "temperature_model_parameters", "temperature_model", "module_parameters", "module_params", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "temperature_model_parameters", "temperature_model", "module_parameters", "module_params"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm_effective_irradiance_value_error", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm_effective_irradiance_value_error", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm_effective_irradiance_value_error(\n        poa_direct, poa_diffuse, aoi, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.sapm_effective_irradiance(\n            poa_direct, poa_diffuse, 10, aoi\n        )\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm_effective_irradiance_value_error", "poa_direct", "poa_diffuse", "aoi", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "sapm_effective_irradiance", "poa_direct", "poa_diffuse", "10", "aoi"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm_celltemp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm_celltemp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm_celltemp(mocker):\n    a, b, deltaT = (-3.47, -0.0594, 3)  # open_rack_glass_glass\n    temp_model_params = {'a': a, 'b': b, 'deltaT': deltaT}\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    mocker.spy(temperature, 'sapm_cell')\n    temps = 25\n    irrads = 1000\n    winds = 1\n    out = system.get_cell_temperature(irrads, temps, winds, model='sapm')\n    temperature.sapm_cell.assert_called_once_with(irrads, temps, winds, a, b,\n                                                  deltaT)\n    assert_allclose(out, 57, atol=1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm_celltemp", "mocker", "a", "b", "deltat", "3", "47", "0", "0594", "3", "open_rack_glass_glass", "temp_model_params", "a", "a", "b", "b", "deltat", "deltat", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "mocker", "spy", "temperature", "sapm_cell", "temps", "25", "irrads", "1000", "winds", "1", "out", "system", "get_cell_temperature", "irrads", "temps", "winds", "model", "sapm", "temperature", "sapm_cell", "assert_called_once_with", "irrads", "temps", "winds", "a", "b", "deltat", "assert_allclose", "out", "57", "atol", "1"], "doc_len": 60}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_sapm_celltemp_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_sapm_celltemp_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_sapm_celltemp_kwargs(mocker):\n    temp_model_params = temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'open_rack_glass_glass']\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    mocker.spy(temperature, 'sapm_cell')\n    temps = 25\n    irrads = 1000\n    winds = 1\n    out = system.get_cell_temperature(irrads, temps, winds, model='sapm')\n    temperature.sapm_cell.assert_called_once_with(irrads, temps, winds,\n                                                  temp_model_params['a'],\n                                                  temp_model_params['b'],\n                                                  temp_model_params['deltaT'])\n    assert_allclose(out, 57, atol=1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_sapm_celltemp_kwargs", "mocker", "temp_model_params", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "mocker", "spy", "temperature", "sapm_cell", "temps", "25", "irrads", "1000", "winds", "1", "out", "system", "get_cell_temperature", "irrads", "temps", "winds", "model", "sapm", "temperature", "sapm_cell", "assert_called_once_with", "irrads", "temps", "winds", "temp_model_params", "a", "temp_model_params", "b", "temp_model_params", "deltat", "assert_allclose", "out", "57", "atol", "1"], "doc_len": 52}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_sapm_celltemp_different_arrays", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_sapm_celltemp_different_arrays", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_sapm_celltemp_different_arrays():\n    temp_model_one = temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'open_rack_glass_glass']\n    temp_model_two = temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'close_mount_glass_glass']\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               temperature_model_parameters=temp_model_one),\n                pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               temperature_model_parameters=temp_model_two)]\n    )\n    temp_one, temp_two = system.get_cell_temperature(\n        (1000, 1000), 25, 1, model='sapm'\n    )\n    assert temp_one != temp_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_sapm_celltemp_different_arrays", "temp_model_one", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "temp_model_two", "temperature", "temperature_model_parameters", "sapm", "close_mount_glass_glass", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "temperature_model_parameters", "temp_model_one", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "temperature_model_parameters", "temp_model_two", "temp_one", "temp_two", "system", "get_cell_temperature", "1000", "1000", "25", "1", "model", "sapm", "assert", "temp_one", "temp_two"], "doc_len": 49}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvsyst_celltemp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvsyst_celltemp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvsyst_celltemp(mocker):\n    parameter_set = 'insulated'\n    temp_model_params = temperature.TEMPERATURE_MODEL_PARAMETERS['pvsyst'][\n        parameter_set]\n    alpha_absorption = 0.85\n    module_efficiency = 0.17\n    module_parameters = {'alpha_absorption': alpha_absorption,\n                         'module_efficiency': module_efficiency}\n    system = pvsystem.PVSystem(module_parameters=module_parameters,\n                               temperature_model_parameters=temp_model_params)\n    mocker.spy(temperature, 'pvsyst_cell')\n    irrad = 800\n    temp = 45\n    wind = 0.5\n    out = system.get_cell_temperature(irrad, temp, wind_speed=wind,\n                                      model='pvsyst')\n    temperature.pvsyst_cell.assert_called_once_with(\n        irrad, temp, wind_speed=wind, u_c=temp_model_params['u_c'],\n        u_v=temp_model_params['u_v'], module_efficiency=module_efficiency,\n        alpha_absorption=alpha_absorption)\n    assert (out < 90) and (out > 70)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvsyst_celltemp", "mocker", "parameter_set", "insulated", "temp_model_params", "temperature", "temperature_model_parameters", "pvsyst", "parameter_set", "alpha_absorption", "0", "85", "module_efficiency", "0", "17", "module_parameters", "alpha_absorption", "alpha_absorption", "module_efficiency", "module_efficiency", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "temperature_model_parameters", "temp_model_params", "mocker", "spy", "temperature", "pvsyst_cell", "irrad", "800", "temp", "45", "wind", "0", "5", "out", "system", "get_cell_temperature", "irrad", "temp", "wind_speed", "wind", "model", "pvsyst", "temperature", "pvsyst_cell", "assert_called_once_with", "irrad", "temp", "wind_speed", "wind", "u_c", "temp_model_params", "u_c", "u_v", "temp_model_params", "u_v", "module_efficiency", "module_efficiency", "alpha_absorption", "alpha_absorption", "assert", "out", "90", "and", "out", "70"], "doc_len": 75}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_faiman_celltemp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_faiman_celltemp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_faiman_celltemp(mocker):\n    u0, u1 = 25.0, 6.84  # default values\n    temp_model_params = {'u0': u0, 'u1': u1}\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    mocker.spy(temperature, 'faiman')\n    temps = 25\n    irrads = 1000\n    winds = 1\n    out = system.get_cell_temperature(irrads, temps, winds, model='faiman')\n    temperature.faiman.assert_called_once_with(irrads, temps, winds, u0, u1)\n    assert_allclose(out, 56.4, atol=1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_faiman_celltemp", "mocker", "u0", "u1", "25", "0", "6", "84", "default", "values", "temp_model_params", "u0", "u0", "u1", "u1", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "mocker", "spy", "temperature", "faiman", "temps", "25", "irrads", "1000", "winds", "1", "out", "system", "get_cell_temperature", "irrads", "temps", "winds", "model", "faiman", "temperature", "faiman", "assert_called_once_with", "irrads", "temps", "winds", "u0", "u1", "assert_allclose", "out", "56", "4", "atol", "1"], "doc_len": 57}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_noct_celltemp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_noct_celltemp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_noct_celltemp(mocker):\n    poa_global, temp_air, wind_speed, noct, module_efficiency = (\n        1000., 25., 1., 45., 0.2)\n    expected = 55.230790492\n    temp_model_params = {'noct': noct, 'module_efficiency': module_efficiency}\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    mocker.spy(temperature, 'noct_sam')\n    out = system.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                      model='noct_sam')\n    temperature.noct_sam.assert_called_once_with(\n        poa_global, temp_air, wind_speed, noct, module_efficiency,\n        effective_irradiance=None)\n    assert_allclose(out, expected)\n    # different types\n    out = system.get_cell_temperature(np.array(poa_global), np.array(temp_air),\n                                      np.array(wind_speed), model='noct_sam')\n    assert_allclose(out, expected)\n    dr = pd.date_range(start='2020-01-01 12:00:00', end='2020-01-01 13:00:00',\n                       freq='1H')\n    out = system.get_cell_temperature(pd.Series(index=dr, data=poa_global),\n                                      pd.Series(index=dr, data=temp_air),\n                                      pd.Series(index=dr, data=wind_speed),\n                                      model='noct_sam')\n    assert_series_equal(out, pd.Series(index=dr, data=expected))\n    # now use optional arguments\n    temp_model_params.update({'transmittance_absorptance': 0.8,\n                              'array_height': 2,\n                              'mount_standoff': 2.0})\n    expected = 60.477703576\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    out = system.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                      effective_irradiance=1100.,\n                                      model='noct_sam')\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_noct_celltemp", "mocker", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "1000", "25", "1", "45", "0", "2", "expected", "55", "230790492", "temp_model_params", "noct", "noct", "module_efficiency", "module_efficiency", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "mocker", "spy", "temperature", "noct_sam", "out", "system", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "noct_sam", "temperature", "noct_sam", "assert_called_once_with", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "effective_irradiance", "none", "assert_allclose", "out", "expected", "different", "types", "out", "system", "get_cell_temperature", "np", "array", "poa_global", "np", "array", "temp_air", "np", "array", "wind_speed", "model", "noct_sam", "assert_allclose", "out", "expected", "dr", "pd", "date_range", "start", "2020", "01", "01", "12", "00", "00", "end", "2020", "01", "01", "13", "00", "00", "freq", "1h", "out", "system", "get_cell_temperature", "pd", "series", "index", "dr", "data", "poa_global", "pd", "series", "index", "dr", "data", "temp_air", "pd", "series", "index", "dr", "data", "wind_speed", "model", "noct_sam", "assert_series_equal", "out", "pd", "series", "index", "dr", "data", "expected", "now", "use", "optional", "arguments", "temp_model_params", "update", "transmittance_absorptance", "0", "8", "array_height", "2", "mount_standoff", "2", "0", "expected", "60", "477703576", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "out", "system", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "effective_irradiance", "1100", "model", "noct_sam", "assert_allclose", "out", "expected"], "doc_len": 160}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_noct_celltemp_error", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_noct_celltemp_error", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_noct_celltemp_error():\n    poa_global, temp_air, wind_speed, module_efficiency = (1000., 25., 1., 0.2)\n    temp_model_params = {'module_efficiency': module_efficiency}\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    with pytest.raises(KeyError):\n        system.get_cell_temperature(poa_global, temp_air, wind_speed,\n                                    model='noct_sam')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_noct_celltemp_error", "poa_global", "temp_air", "wind_speed", "module_efficiency", "1000", "25", "1", "0", "2", "temp_model_params", "module_efficiency", "module_efficiency", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "with", "pytest", "raises", "keyerror", "system", "get_cell_temperature", "poa_global", "temp_air", "wind_speed", "model", "noct_sam"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_functions", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_functions", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_functions(model, two_array_system):\n    times = pd.date_range(start='2020-08-25 11:00', freq='H', periods=3)\n    irrad_one = pd.Series(1000, index=times)\n    irrad_two = pd.Series(500, index=times)\n    temp_air = pd.Series(25, index=times)\n    wind_speed = pd.Series(1, index=times)\n\n    temp_one, temp_two = two_array_system.get_cell_temperature(\n        (irrad_one, irrad_two), temp_air, wind_speed, model=model)\n    assert (temp_one != temp_two).all()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_functions", "model", "two_array_system", "times", "pd", "date_range", "start", "2020", "08", "25", "11", "00", "freq", "h", "periods", "3", "irrad_one", "pd", "series", "1000", "index", "times", "irrad_two", "pd", "series", "500", "index", "times", "temp_air", "pd", "series", "25", "index", "times", "wind_speed", "pd", "series", "1", "index", "times", "temp_one", "temp_two", "two_array_system", "get_cell_temperature", "irrad_one", "irrad_two", "temp_air", "wind_speed", "model", "model", "assert", "temp_one", "temp_two", "all"], "doc_len": 59}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_multi_temp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_multi_temp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_multi_temp(model, two_array_system):\n    times = pd.date_range(start='2020-08-25 11:00', freq='H', periods=3)\n    irrad = pd.Series(1000, index=times)\n    temp_air_one = pd.Series(25, index=times)\n    temp_air_two = pd.Series(5, index=times)\n    wind_speed = pd.Series(1, index=times)\n    temp_one, temp_two = two_array_system.get_cell_temperature(\n        (irrad, irrad),\n        (temp_air_one, temp_air_two),\n        wind_speed,\n        model=model\n    )\n    assert (temp_one != temp_two).all()\n    temp_one_swtich, temp_two_switch = two_array_system.get_cell_temperature(\n        (irrad, irrad),\n        (temp_air_two, temp_air_one),\n        wind_speed,\n        model=model\n    )\n    assert_series_equal(temp_one, temp_two_switch)\n    assert_series_equal(temp_two, temp_one_swtich)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_multi_temp", "model", "two_array_system", "times", "pd", "date_range", "start", "2020", "08", "25", "11", "00", "freq", "h", "periods", "3", "irrad", "pd", "series", "1000", "index", "times", "temp_air_one", "pd", "series", "25", "index", "times", "temp_air_two", "pd", "series", "5", "index", "times", "wind_speed", "pd", "series", "1", "index", "times", "temp_one", "temp_two", "two_array_system", "get_cell_temperature", "irrad", "irrad", "temp_air_one", "temp_air_two", "wind_speed", "model", "model", "assert", "temp_one", "temp_two", "all", "temp_one_swtich", "temp_two_switch", "two_array_system", "get_cell_temperature", "irrad", "irrad", "temp_air_two", "temp_air_one", "wind_speed", "model", "model", "assert_series_equal", "temp_one", "temp_two_switch", "assert_series_equal", "temp_two", "temp_one_swtich"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_multi_wind", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_multi_wind", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_multi_wind(model, two_array_system):\n    times = pd.date_range(start='2020-08-25 11:00', freq='H', periods=3)\n    irrad = pd.Series(1000, index=times)\n    temp_air = pd.Series(25, index=times)\n    wind_speed_one = pd.Series(1, index=times)\n    wind_speed_two = pd.Series(5, index=times)\n    temp_one, temp_two = two_array_system.get_cell_temperature(\n        (irrad, irrad),\n        temp_air,\n        (wind_speed_one, wind_speed_two),\n        model=model\n    )\n    assert (temp_one != temp_two).all()\n    temp_one_swtich, temp_two_switch = two_array_system.get_cell_temperature(\n        (irrad, irrad),\n        temp_air,\n        (wind_speed_two, wind_speed_one),\n        model=model\n    )\n    assert_series_equal(temp_one, temp_two_switch)\n    assert_series_equal(temp_two, temp_one_swtich)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_multi_wind", "model", "two_array_system", "times", "pd", "date_range", "start", "2020", "08", "25", "11", "00", "freq", "h", "periods", "3", "irrad", "pd", "series", "1000", "index", "times", "temp_air", "pd", "series", "25", "index", "times", "wind_speed_one", "pd", "series", "1", "index", "times", "wind_speed_two", "pd", "series", "5", "index", "times", "temp_one", "temp_two", "two_array_system", "get_cell_temperature", "irrad", "irrad", "temp_air", "wind_speed_one", "wind_speed_two", "model", "model", "assert", "temp_one", "temp_two", "all", "temp_one_swtich", "temp_two_switch", "two_array_system", "get_cell_temperature", "irrad", "irrad", "temp_air", "wind_speed_two", "wind_speed_one", "model", "model", "assert_series_equal", "temp_one", "temp_two_switch", "assert_series_equal", "temp_two", "temp_one_swtich"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_cell_temperature_invalid", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_cell_temperature_invalid", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_cell_temperature_invalid():\n    system = pvsystem.PVSystem()\n    with pytest.raises(ValueError, match='not a valid'):\n        system.get_cell_temperature(1000, 25, 1, 'not_a_model')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_cell_temperature_invalid", "system", "pvsystem", "pvsystem", "with", "pytest", "raises", "valueerror", "match", "not", "a", "valid", "system", "get_cell_temperature", "1000", "25", "1", "not_a_model"], "doc_len": 23}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_temp_too_short", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_temp_too_short", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_temp_too_short(\n        model, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.get_cell_temperature((1000, 1000), (1,), 1,\n                                              model=model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_temp_too_short", "model", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "get_cell_temperature", "1000", "1000", "1", "1", "model", "model"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_temp_too_long", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_temp_too_long", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_temp_too_long(\n        model, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.get_cell_temperature((1000, 1000), (1, 1, 1), 1,\n                                              model=model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_temp_too_long", "model", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "get_cell_temperature", "1000", "1000", "1", "1", "1", "1", "model", "model"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_wind_too_short", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_wind_too_short", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_wind_too_short(\n        model, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.get_cell_temperature((1000, 1000), 25, (1,),\n                                              model=model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_wind_too_short", "model", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "get_cell_temperature", "1000", "1000", "25", "1", "model", "model"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_wind_too_long", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_wind_too_long", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_wind_too_long(\n        model, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.get_cell_temperature((1000, 1000), 25, (1, 1, 1),\n                                              model=model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_wind_too_long", "model", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "get_cell_temperature", "1000", "1000", "25", "1", "1", "1", "model", "model"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_celltemp_poa_length_mismatch", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_celltemp_poa_length_mismatch", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_celltemp_poa_length_mismatch(\n        model, two_array_system):\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        two_array_system.get_cell_temperature(1000, 25, 1, model=model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_celltemp_poa_length_mismatch", "model", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "two_array_system", "get_cell_temperature", "1000", "25", "1", "model", "model"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_fuentes_celltemp", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_fuentes_celltemp", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_fuentes_celltemp(mocker):\n    noct_installed = 45\n    temp_model_params = {'noct_installed': noct_installed, 'surface_tilt': 0}\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    spy = mocker.spy(temperature, 'fuentes')\n    index = pd.date_range('2019-01-01 11:00', freq='h', periods=3)\n    temps = pd.Series(25, index)\n    irrads = pd.Series(1000, index)\n    winds = pd.Series(1, index)\n    out = system.get_cell_temperature(irrads, temps, winds, model='fuentes')\n    assert_series_equal(spy.call_args[0][0], irrads)\n    assert_series_equal(spy.call_args[0][1], temps)\n    assert_series_equal(spy.call_args[0][2], winds)\n    assert spy.call_args[0][3] == noct_installed\n    assert_series_equal(out, pd.Series([52.85, 55.85, 55.85], index,\n                                       name='tmod'))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_fuentes_celltemp", "mocker", "noct_installed", "45", "temp_model_params", "noct_installed", "noct_installed", "surface_tilt", "0", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "spy", "mocker", "spy", "temperature", "fuentes", "index", "pd", "date_range", "2019", "01", "01", "11", "00", "freq", "h", "periods", "3", "temps", "pd", "series", "25", "index", "irrads", "pd", "series", "1000", "index", "winds", "pd", "series", "1", "index", "out", "system", "get_cell_temperature", "irrads", "temps", "winds", "model", "fuentes", "assert_series_equal", "spy", "call_args", "0", "0", "irrads", "assert_series_equal", "spy", "call_args", "0", "1", "temps", "assert_series_equal", "spy", "call_args", "0", "2", "winds", "assert", "spy", "call_args", "0", "3", "noct_installed", "assert_series_equal", "out", "pd", "series", "52", "85", "55", "85", "55", "85", "index", "name", "tmod"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_fuentes_module_height", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_fuentes_module_height", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_fuentes_module_height(mocker):\n    # check that fuentes picks up Array.mount.module_height correctly\n    # (temperature.fuentes defaults to 5 for module_height)\n    array = pvsystem.Array(mount=FixedMount(module_height=3),\n                           temperature_model_parameters={'noct_installed': 45})\n    spy = mocker.spy(temperature, 'fuentes')\n    index = pd.date_range('2019-01-01 11:00', freq='h', periods=3)\n    temps = pd.Series(25, index)\n    irrads = pd.Series(1000, index)\n    winds = pd.Series(1, index)\n    _ = array.get_cell_temperature(irrads, temps, winds, model='fuentes')\n    assert spy.call_args[1]['module_height'] == 3\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_fuentes_module_height", "mocker", "check", "that", "fuentes", "picks", "up", "array", "mount", "module_height", "correctly", "temperature", "fuentes", "defaults", "to", "5", "for", "module_height", "array", "pvsystem", "array", "mount", "fixedmount", "module_height", "3", "temperature_model_parameters", "noct_installed", "45", "spy", "mocker", "spy", "temperature", "fuentes", "index", "pd", "date_range", "2019", "01", "01", "11", "00", "freq", "h", "periods", "3", "temps", "pd", "series", "25", "index", "irrads", "pd", "series", "1000", "index", "winds", "pd", "series", "1", "index", "_", "array", "get_cell_temperature", "irrads", "temps", "winds", "model", "fuentes", "assert", "spy", "call_args", "1", "module_height", "3"], "doc_len": 79}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array__infer_temperature_model_params", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array__infer_temperature_model_params", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array__infer_temperature_model_params():\n    array = pvsystem.Array(mount=FixedMount(0, 180,\n                                            racking_model='open_rack'),\n                           module_parameters={},\n                           module_type='glass_polymer')\n    expected = temperature.TEMPERATURE_MODEL_PARAMETERS[\n        'sapm']['open_rack_glass_polymer']\n    assert expected == array._infer_temperature_model_params()\n    array = pvsystem.Array(mount=FixedMount(0, 180,\n                                            racking_model='freestanding'),\n                           module_parameters={},\n                           module_type='glass_polymer')\n    expected = temperature.TEMPERATURE_MODEL_PARAMETERS[\n        'pvsyst']['freestanding']\n    assert expected == array._infer_temperature_model_params()\n    array = pvsystem.Array(mount=FixedMount(0, 180,\n                                            racking_model='insulated'),\n                           module_parameters={},\n                           module_type=None)\n    expected = temperature.TEMPERATURE_MODEL_PARAMETERS[\n        'pvsyst']['insulated']\n    assert expected == array._infer_temperature_model_params()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array__infer_temperature_model_params", "array", "pvsystem", "array", "mount", "fixedmount", "0", "180", "racking_model", "open_rack", "module_parameters", "module_type", "glass_polymer", "expected", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_polymer", "assert", "expected", "array", "_infer_temperature_model_params", "array", "pvsystem", "array", "mount", "fixedmount", "0", "180", "racking_model", "freestanding", "module_parameters", "module_type", "glass_polymer", "expected", "temperature", "temperature_model_parameters", "pvsyst", "freestanding", "assert", "expected", "array", "_infer_temperature_model_params", "array", "pvsystem", "array", "mount", "fixedmount", "0", "180", "racking_model", "insulated", "module_parameters", "module_type", "none", "expected", "temperature", "temperature_model_parameters", "pvsyst", "insulated", "assert", "expected", "array", "_infer_temperature_model_params"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array__infer_cell_type", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array__infer_cell_type", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array__infer_cell_type():\n    array = pvsystem.Array(mount=pvsystem.FixedMount(0, 180),\n                           module_parameters={})\n    assert array._infer_cell_type() is None\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array__infer_cell_type", "array", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "0", "180", "module_parameters", "assert", "array", "_infer_cell_type", "is", "none"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_calcparams_desoto", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_calcparams_desoto", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_calcparams_desoto(cec_module_params):\n    times = pd.date_range(start='2015-01-01', periods=3, freq='12H')\n    effective_irradiance = pd.Series([0.0, 800.0, 800.0], index=times)\n    temp_cell = pd.Series([25, 25, 50], index=times)\n\n    IL, I0, Rs, Rsh, nNsVth = pvsystem.calcparams_desoto(\n                                  effective_irradiance,\n                                  temp_cell,\n                                  alpha_sc=cec_module_params['alpha_sc'],\n                                  a_ref=cec_module_params['a_ref'],\n                                  I_L_ref=cec_module_params['I_L_ref'],\n                                  I_o_ref=cec_module_params['I_o_ref'],\n                                  R_sh_ref=cec_module_params['R_sh_ref'],\n                                  R_s=cec_module_params['R_s'],\n                                  EgRef=1.121,\n                                  dEgdT=-0.0002677)\n\n    assert_series_equal(IL, pd.Series([0.0, 6.036, 6.096], index=times),\n                        check_less_precise=3)\n    assert_series_equal(I0, pd.Series([0.0, 1.94e-9, 7.419e-8], index=times),\n                        check_less_precise=3)\n    assert_allclose(Rs, 0.094)\n    assert_series_equal(Rsh, pd.Series([np.inf, 19.65, 19.65], index=times),\n                        check_less_precise=3)\n    assert_series_equal(nNsVth, pd.Series([0.473, 0.473, 0.5127], index=times),\n                        check_less_precise=3)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_calcparams_desoto", "cec_module_params", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "3", "freq", "12h", "effective_irradiance", "pd", "series", "0", "0", "800", "0", "800", "0", "index", "times", "temp_cell", "pd", "series", "25", "25", "50", "index", "times", "il", "i0", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_desoto", "effective_irradiance", "temp_cell", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "egref", "1", "121", "degdt", "0", "0002677", "assert_series_equal", "il", "pd", "series", "0", "0", "6", "036", "6", "096", "index", "times", "check_less_precise", "3", "assert_series_equal", "i0", "pd", "series", "0", "0", "1", "94e", "9", "7", "419e", "8", "index", "times", "check_less_precise", "3", "assert_allclose", "rs", "0", "094", "assert_series_equal", "rsh", "pd", "series", "np", "inf", "19", "65", "19", "65", "index", "times", "check_less_precise", "3", "assert_series_equal", "nnsvth", "pd", "series", "0", "473", "0", "473", "0", "5127", "index", "times", "check_less_precise", "3"], "doc_len": 132}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_calcparams_cec", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_calcparams_cec", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_calcparams_cec(cec_module_params):\n    times = pd.date_range(start='2015-01-01', periods=3, freq='12H')\n    effective_irradiance = pd.Series([0.0, 800.0, 800.0], index=times)\n    temp_cell = pd.Series([25, 25, 50], index=times)\n\n    IL, I0, Rs, Rsh, nNsVth = pvsystem.calcparams_cec(\n                                  effective_irradiance,\n                                  temp_cell,\n                                  alpha_sc=cec_module_params['alpha_sc'],\n                                  a_ref=cec_module_params['a_ref'],\n                                  I_L_ref=cec_module_params['I_L_ref'],\n                                  I_o_ref=cec_module_params['I_o_ref'],\n                                  R_sh_ref=cec_module_params['R_sh_ref'],\n                                  R_s=cec_module_params['R_s'],\n                                  Adjust=cec_module_params['Adjust'],\n                                  EgRef=1.121,\n                                  dEgdT=-0.0002677)\n\n    assert_series_equal(IL, pd.Series([0.0, 6.036, 6.0896], index=times),\n                        check_less_precise=3)\n    assert_series_equal(I0, pd.Series([0.0, 1.94e-9, 7.419e-8], index=times),\n                        check_less_precise=3)\n    assert_allclose(Rs, 0.094)\n    assert_series_equal(Rsh, pd.Series([np.inf, 19.65, 19.65], index=times),\n                        check_less_precise=3)\n    assert_series_equal(nNsVth, pd.Series([0.473, 0.473, 0.5127], index=times),\n                        check_less_precise=3)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_calcparams_cec", "cec_module_params", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "3", "freq", "12h", "effective_irradiance", "pd", "series", "0", "0", "800", "0", "800", "0", "index", "times", "temp_cell", "pd", "series", "25", "25", "50", "index", "times", "il", "i0", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_cec", "effective_irradiance", "temp_cell", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "adjust", "cec_module_params", "adjust", "egref", "1", "121", "degdt", "0", "0002677", "assert_series_equal", "il", "pd", "series", "0", "0", "6", "036", "6", "0896", "index", "times", "check_less_precise", "3", "assert_series_equal", "i0", "pd", "series", "0", "0", "1", "94e", "9", "7", "419e", "8", "index", "times", "check_less_precise", "3", "assert_allclose", "rs", "0", "094", "assert_series_equal", "rsh", "pd", "series", "np", "inf", "19", "65", "19", "65", "index", "times", "check_less_precise", "3", "assert_series_equal", "nnsvth", "pd", "series", "0", "473", "0", "473", "0", "5127", "index", "times", "check_less_precise", "3"], "doc_len": 135}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_calcparams_cec_extra_params_propagation", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_calcparams_cec_extra_params_propagation", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_calcparams_cec_extra_params_propagation(cec_module_params, mocker):\n    \"\"\"\n    See bug #1215.\n\n    When calling `calcparams_cec`, the parameters `EgRef`, `dEgdT`, `irrad_ref`\n    and `temp_ref` must not be ignored.\n\n    Since, internally, this function is calling `calcparams_desoto`, this test\n    checks that the latter is called with the expected parameters instead of\n    some default values.\n    \"\"\"\n    times = pd.date_range(start='2015-01-01', periods=3, freq='12H')\n    effective_irradiance = pd.Series([0.0, 800.0, 800.0], index=times)\n    temp_cell = pd.Series([25, 25, 50], index=times)\n    extra_parameters = dict(\n        EgRef=1.123,\n        dEgdT=-0.0002688,\n        irrad_ref=1100,\n        temp_ref=23,\n    )\n    m = mocker.spy(pvsystem, 'calcparams_desoto')\n    pvsystem.calcparams_cec(\n        effective_irradiance=effective_irradiance,\n        temp_cell=temp_cell,\n        alpha_sc=cec_module_params['alpha_sc'],\n        a_ref=cec_module_params['a_ref'],\n        I_L_ref=cec_module_params['I_L_ref'],\n        I_o_ref=cec_module_params['I_o_ref'],\n        R_sh_ref=cec_module_params['R_sh_ref'],\n        R_s=cec_module_params['R_s'],\n        Adjust=cec_module_params['Adjust'],\n        **extra_parameters,\n    )\n    assert m.call_count == 1\n    assert m.call_args[1] == extra_parameters\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_calcparams_cec_extra_params_propagation", "cec_module_params", "mocker", "see", "bug", "1215", "when", "calling", "calcparams_cec", "the", "parameters", "egref", "degdt", "irrad_ref", "and", "temp_ref", "must", "not", "be", "ignored", "since", "internally", "this", "function", "is", "calling", "calcparams_desoto", "this", "test", "checks", "that", "the", "latter", "is", "called", "with", "the", "expected", "parameters", "instead", "of", "some", "default", "values", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "3", "freq", "12h", "effective_irradiance", "pd", "series", "0", "0", "800", "0", "800", "0", "index", "times", "temp_cell", "pd", "series", "25", "25", "50", "index", "times", "extra_parameters", "dict", "egref", "1", "123", "degdt", "0", "0002688", "irrad_ref", "1100", "temp_ref", "23", "m", "mocker", "spy", "pvsystem", "calcparams_desoto", "pvsystem", "calcparams_cec", "effective_irradiance", "effective_irradiance", "temp_cell", "temp_cell", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "adjust", "cec_module_params", "adjust", "extra_parameters", "assert", "m", "call_count", "1", "assert", "m", "call_args", "1", "extra_parameters"], "doc_len": 133}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_calcparams_pvsyst", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_calcparams_pvsyst", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_calcparams_pvsyst(pvsyst_module_params):\n    times = pd.date_range(start='2015-01-01', periods=2, freq='12H')\n    effective_irradiance = pd.Series([0.0, 800.0], index=times)\n    temp_cell = pd.Series([25, 50], index=times)\n\n    IL, I0, Rs, Rsh, nNsVth = pvsystem.calcparams_pvsyst(\n        effective_irradiance,\n        temp_cell,\n        alpha_sc=pvsyst_module_params['alpha_sc'],\n        gamma_ref=pvsyst_module_params['gamma_ref'],\n        mu_gamma=pvsyst_module_params['mu_gamma'],\n        I_L_ref=pvsyst_module_params['I_L_ref'],\n        I_o_ref=pvsyst_module_params['I_o_ref'],\n        R_sh_ref=pvsyst_module_params['R_sh_ref'],\n        R_sh_0=pvsyst_module_params['R_sh_0'],\n        R_s=pvsyst_module_params['R_s'],\n        cells_in_series=pvsyst_module_params['cells_in_series'],\n        EgRef=pvsyst_module_params['EgRef'])\n\n    assert_series_equal(\n        IL.round(decimals=3), pd.Series([0.0, 4.8200], index=times))\n    assert_series_equal(\n        I0.round(decimals=3), pd.Series([0.0, 1.47e-7], index=times))\n    assert_allclose(Rs, 0.500)\n    assert_series_equal(\n        Rsh.round(decimals=3), pd.Series([1000.0, 305.757], index=times))\n    assert_series_equal(\n        nNsVth.round(decimals=4), pd.Series([1.6186, 1.7961], index=times))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_calcparams_pvsyst", "pvsyst_module_params", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "2", "freq", "12h", "effective_irradiance", "pd", "series", "0", "0", "800", "0", "index", "times", "temp_cell", "pd", "series", "25", "50", "index", "times", "il", "i0", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_pvsyst", "effective_irradiance", "temp_cell", "alpha_sc", "pvsyst_module_params", "alpha_sc", "gamma_ref", "pvsyst_module_params", "gamma_ref", "mu_gamma", "pvsyst_module_params", "mu_gamma", "i_l_ref", "pvsyst_module_params", "i_l_ref", "i_o_ref", "pvsyst_module_params", "i_o_ref", "r_sh_ref", "pvsyst_module_params", "r_sh_ref", "r_sh_0", "pvsyst_module_params", "r_sh_0", "r_s", "pvsyst_module_params", "r_s", "cells_in_series", "pvsyst_module_params", "cells_in_series", "egref", "pvsyst_module_params", "egref", "assert_series_equal", "il", "round", "decimals", "3", "pd", "series", "0", "0", "4", "8200", "index", "times", "assert_series_equal", "i0", "round", "decimals", "3", "pd", "series", "0", "0", "1", "47e", "7", "index", "times", "assert_allclose", "rs", "0", "500", "assert_series_equal", "rsh", "round", "decimals", "3", "pd", "series", "1000", "0", "305", "757", "index", "times", "assert_series_equal", "nnsvth", "round", "decimals", "4", "pd", "series", "1", "6186", "1", "7961", "index", "times"], "doc_len": 130}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_calcparams_desoto", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_calcparams_desoto", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_calcparams_desoto(cec_module_params, mocker):\n    mocker.spy(pvsystem, 'calcparams_desoto')\n    module_parameters = cec_module_params.copy()\n    module_parameters['EgRef'] = 1.121\n    module_parameters['dEgdT'] = -0.0002677\n    system = pvsystem.PVSystem(module_parameters=module_parameters)\n    effective_irradiance = np.array([0, 800])\n    temp_cell = 25\n    IL, I0, Rs, Rsh, nNsVth = system.calcparams_desoto(effective_irradiance,\n                                                       temp_cell)\n    pvsystem.calcparams_desoto.assert_called_once_with(\n                                  effective_irradiance,\n                                  temp_cell,\n                                  alpha_sc=cec_module_params['alpha_sc'],\n                                  a_ref=cec_module_params['a_ref'],\n                                  I_L_ref=cec_module_params['I_L_ref'],\n                                  I_o_ref=cec_module_params['I_o_ref'],\n                                  R_sh_ref=cec_module_params['R_sh_ref'],\n                                  R_s=cec_module_params['R_s'],\n                                  EgRef=module_parameters['EgRef'],\n                                  dEgdT=module_parameters['dEgdT'])\n    assert_allclose(IL, np.array([0.0, 6.036]), atol=1)\n    assert_allclose(I0, 2.0e-9, atol=1.0e-9)\n    assert_allclose(Rs, 0.1, atol=0.1)\n    assert_allclose(Rsh, np.array([np.inf, 20]), atol=1)\n    assert_allclose(nNsVth, 0.5, atol=0.1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_calcparams_desoto", "cec_module_params", "mocker", "mocker", "spy", "pvsystem", "calcparams_desoto", "module_parameters", "cec_module_params", "copy", "module_parameters", "egref", "1", "121", "module_parameters", "degdt", "0", "0002677", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "effective_irradiance", "np", "array", "0", "800", "temp_cell", "25", "il", "i0", "rs", "rsh", "nnsvth", "system", "calcparams_desoto", "effective_irradiance", "temp_cell", "pvsystem", "calcparams_desoto", "assert_called_once_with", "effective_irradiance", "temp_cell", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "egref", "module_parameters", "egref", "degdt", "module_parameters", "degdt", "assert_allclose", "il", "np", "array", "0", "0", "6", "036", "atol", "1", "assert_allclose", "i0", "2", "0e", "9", "atol", "1", "0e", "9", "assert_allclose", "rs", "0", "1", "atol", "0", "1", "assert_allclose", "rsh", "np", "array", "np", "inf", "20", "atol", "1", "assert_allclose", "nnsvth", "0", "5", "atol", "0", "1"], "doc_len": 115}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_calcparams_pvsyst", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_calcparams_pvsyst", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_calcparams_pvsyst(pvsyst_module_params, mocker):\n    mocker.spy(pvsystem, 'calcparams_pvsyst')\n    module_parameters = pvsyst_module_params.copy()\n    system = pvsystem.PVSystem(module_parameters=module_parameters)\n    effective_irradiance = np.array([0, 800])\n    temp_cell = np.array([25, 50])\n    IL, I0, Rs, Rsh, nNsVth = system.calcparams_pvsyst(effective_irradiance,\n                                                       temp_cell)\n    pvsystem.calcparams_pvsyst.assert_called_once_with(\n                                  effective_irradiance,\n                                  temp_cell,\n                                  alpha_sc=pvsyst_module_params['alpha_sc'],\n                                  gamma_ref=pvsyst_module_params['gamma_ref'],\n                                  mu_gamma=pvsyst_module_params['mu_gamma'],\n                                  I_L_ref=pvsyst_module_params['I_L_ref'],\n                                  I_o_ref=pvsyst_module_params['I_o_ref'],\n                                  R_sh_ref=pvsyst_module_params['R_sh_ref'],\n                                  R_sh_0=pvsyst_module_params['R_sh_0'],\n                                  R_s=pvsyst_module_params['R_s'],\n                    cells_in_series=pvsyst_module_params['cells_in_series'],\n                                  EgRef=pvsyst_module_params['EgRef'],\n                                  R_sh_exp=pvsyst_module_params['R_sh_exp'])\n\n    assert_allclose(IL, np.array([0.0, 4.8200]), atol=1)\n    assert_allclose(I0, np.array([0.0, 1.47e-7]), atol=1.0e-5)\n    assert_allclose(Rs, 0.5, atol=0.1)\n    assert_allclose(Rsh, np.array([1000, 305.757]), atol=50)\n    assert_allclose(nNsVth, np.array([1.6186, 1.7961]), atol=0.1)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_calcparams_pvsyst", "pvsyst_module_params", "mocker", "mocker", "spy", "pvsystem", "calcparams_pvsyst", "module_parameters", "pvsyst_module_params", "copy", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "effective_irradiance", "np", "array", "0", "800", "temp_cell", "np", "array", "25", "50", "il", "i0", "rs", "rsh", "nnsvth", "system", "calcparams_pvsyst", "effective_irradiance", "temp_cell", "pvsystem", "calcparams_pvsyst", "assert_called_once_with", "effective_irradiance", "temp_cell", "alpha_sc", "pvsyst_module_params", "alpha_sc", "gamma_ref", "pvsyst_module_params", "gamma_ref", "mu_gamma", "pvsyst_module_params", "mu_gamma", "i_l_ref", "pvsyst_module_params", "i_l_ref", "i_o_ref", "pvsyst_module_params", "i_o_ref", "r_sh_ref", "pvsyst_module_params", "r_sh_ref", "r_sh_0", "pvsyst_module_params", "r_sh_0", "r_s", "pvsyst_module_params", "r_s", "cells_in_series", "pvsyst_module_params", "cells_in_series", "egref", "pvsyst_module_params", "egref", "r_sh_exp", "pvsyst_module_params", "r_sh_exp", "assert_allclose", "il", "np", "array", "0", "0", "4", "8200", "atol", "1", "assert_allclose", "i0", "np", "array", "0", "0", "1", "47e", "7", "atol", "1", "0e", "5", "assert_allclose", "rs", "0", "5", "atol", "0", "1", "assert_allclose", "rsh", "np", "array", "1000", "305", "757", "atol", "50", "assert_allclose", "nnsvth", "np", "array", "1", "6186", "1", "7961", "atol", "0", "1"], "doc_len": 127}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_calcparams", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_calcparams", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_calcparams(calcparams, two_array_system):\n    params_one, params_two = calcparams(\n        two_array_system, (1000, 500), (30, 20)\n    )\n    assert params_one != params_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_calcparams", "calcparams", "two_array_system", "params_one", "params_two", "calcparams", "two_array_system", "1000", "500", "30", "20", "assert", "params_one", "params_two"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_calcparams_value_error", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_calcparams_value_error", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_calcparams_value_error(\n        calcparams, irrad, celltemp, two_array_system):\n    with pytest.raises(ValueError,\n                       match='Length mismatch for per-array parameter'):\n        calcparams(two_array_system, irrad, celltemp)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_calcparams_value_error", "calcparams", "irrad", "celltemp", "two_array_system", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "calcparams", "two_array_system", "irrad", "celltemp"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_pvsystem.py::fixture_v_from_i", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "fixture_v_from_i", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef fixture_v_from_i(request):\n    return request.param\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "fixture_v_from_i", "request", "return", "request", "param"], "doc_len": 10}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_v_from_i", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_v_from_i", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_v_from_i(fixture_v_from_i, method, atol):\n    # Solution set loaded from fixture\n    Rsh = fixture_v_from_i['Rsh']\n    Rs = fixture_v_from_i['Rs']\n    nNsVth = fixture_v_from_i['nNsVth']\n    I = fixture_v_from_i['I']\n    I0 = fixture_v_from_i['I0']\n    IL = fixture_v_from_i['IL']\n    V_expected = fixture_v_from_i['V_expected']\n\n    V = pvsystem.v_from_i(Rsh, Rs, nNsVth, I, I0, IL, method=method)\n    assert(isinstance(V, type(V_expected)))\n    if isinstance(V, type(np.ndarray)):\n        assert(isinstance(V.dtype, type(V_expected.dtype)))\n        assert(V.shape == V_expected.shape)\n    assert_allclose(V, V_expected, atol=atol)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_v_from_i", "fixture_v_from_i", "method", "atol", "solution", "set", "loaded", "from", "fixture", "rsh", "fixture_v_from_i", "rsh", "rs", "fixture_v_from_i", "rs", "nnsvth", "fixture_v_from_i", "nnsvth", "i", "fixture_v_from_i", "i", "i0", "fixture_v_from_i", "i0", "il", "fixture_v_from_i", "il", "v_expected", "fixture_v_from_i", "v_expected", "v", "pvsystem", "v_from_i", "rsh", "rs", "nnsvth", "i", "i0", "il", "method", "method", "assert", "isinstance", "v", "type", "v_expected", "if", "isinstance", "v", "type", "np", "ndarray", "assert", "isinstance", "v", "dtype", "type", "v_expected", "dtype", "assert", "v", "shape", "v_expected", "shape", "assert_allclose", "v", "v_expected", "atol", "atol"], "doc_len": 74}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_i_from_v_from_i", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_i_from_v_from_i", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_i_from_v_from_i(fixture_v_from_i):\n    # Solution set loaded from fixture\n    Rsh = fixture_v_from_i['Rsh']\n    Rs = fixture_v_from_i['Rs']\n    nNsVth = fixture_v_from_i['nNsVth']\n    I = fixture_v_from_i['I']\n    I0 = fixture_v_from_i['I0']\n    IL = fixture_v_from_i['IL']\n    V = fixture_v_from_i['V_expected']\n\n    # Convergence criteria\n    atol = 1.e-11\n\n    I_expected = pvsystem.i_from_v(Rsh, Rs, nNsVth, V, I0, IL,\n                                   method='lambertw')\n    assert_allclose(I, I_expected, atol=atol)\n    I = pvsystem.i_from_v(Rsh, Rs, nNsVth, V, I0, IL)\n    assert(isinstance(I, type(I_expected)))\n    if isinstance(I, type(np.ndarray)):\n        assert(isinstance(I.dtype, type(I_expected.dtype)))\n        assert(I.shape == I_expected.shape)\n    assert_allclose(I, I_expected, atol=atol)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_i_from_v_from_i", "fixture_v_from_i", "solution", "set", "loaded", "from", "fixture", "rsh", "fixture_v_from_i", "rsh", "rs", "fixture_v_from_i", "rs", "nnsvth", "fixture_v_from_i", "nnsvth", "i", "fixture_v_from_i", "i", "i0", "fixture_v_from_i", "i0", "il", "fixture_v_from_i", "il", "v", "fixture_v_from_i", "v_expected", "convergence", "criteria", "atol", "1", "e", "11", "i_expected", "pvsystem", "i_from_v", "rsh", "rs", "nnsvth", "v", "i0", "il", "method", "lambertw", "assert_allclose", "i", "i_expected", "atol", "atol", "i", "pvsystem", "i_from_v", "rsh", "rs", "nnsvth", "v", "i0", "il", "assert", "isinstance", "i", "type", "i_expected", "if", "isinstance", "i", "type", "np", "ndarray", "assert", "isinstance", "i", "dtype", "type", "i_expected", "dtype", "assert", "i", "shape", "i_expected", "shape", "assert_allclose", "i", "i_expected", "atol", "atol"], "doc_len": 92}
{"doc_id": "pvlib/tests/test_pvsystem.py::fixture_i_from_v", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "fixture_i_from_v", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef fixture_i_from_v(request):\n    return request.param\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "fixture_i_from_v", "request", "return", "request", "param"], "doc_len": 10}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_i_from_v", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_i_from_v", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_i_from_v(fixture_i_from_v, method, atol):\n    # Solution set loaded from fixture\n    Rsh = fixture_i_from_v['Rsh']\n    Rs = fixture_i_from_v['Rs']\n    nNsVth = fixture_i_from_v['nNsVth']\n    V = fixture_i_from_v['V']\n    I0 = fixture_i_from_v['I0']\n    IL = fixture_i_from_v['IL']\n    I_expected = fixture_i_from_v['I_expected']\n\n    I = pvsystem.i_from_v(Rsh, Rs, nNsVth, V, I0, IL, method=method)\n    assert(isinstance(I, type(I_expected)))\n    if isinstance(I, type(np.ndarray)):\n        assert(isinstance(I.dtype, type(I_expected.dtype)))\n        assert(I.shape == I_expected.shape)\n    assert_allclose(I, I_expected, atol=atol)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_i_from_v", "fixture_i_from_v", "method", "atol", "solution", "set", "loaded", "from", "fixture", "rsh", "fixture_i_from_v", "rsh", "rs", "fixture_i_from_v", "rs", "nnsvth", "fixture_i_from_v", "nnsvth", "v", "fixture_i_from_v", "v", "i0", "fixture_i_from_v", "i0", "il", "fixture_i_from_v", "il", "i_expected", "fixture_i_from_v", "i_expected", "i", "pvsystem", "i_from_v", "rsh", "rs", "nnsvth", "v", "i0", "il", "method", "method", "assert", "isinstance", "i", "type", "i_expected", "if", "isinstance", "i", "type", "np", "ndarray", "assert", "isinstance", "i", "dtype", "type", "i_expected", "dtype", "assert", "i", "shape", "i_expected", "shape", "assert_allclose", "i", "i_expected", "atol", "atol"], "doc_len": 74}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_i_from_v", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_i_from_v", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_i_from_v(mocker):\n    system = pvsystem.PVSystem()\n    m = mocker.patch('pvlib.pvsystem.i_from_v', autospec=True)\n    args = (20, 0.1, 0.5, 7.5049875193450521, 6e-7, 7)\n    system.i_from_v(*args)\n    m.assert_called_once_with(*args)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_i_from_v", "mocker", "system", "pvsystem", "pvsystem", "m", "mocker", "patch", "pvlib", "pvsystem", "i_from_v", "autospec", "true", "args", "20", "0", "1", "0", "5", "7", "5049875193450521", "6e", "7", "7", "system", "i_from_v", "args", "m", "assert_called_once_with", "args"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_i_from_v_size", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_i_from_v_size", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_i_from_v_size():\n    with pytest.raises(ValueError):\n        pvsystem.i_from_v(20, [0.1] * 2, 0.5, [7.5] * 3, 6.0e-7, 7.0)\n    with pytest.raises(ValueError):\n        pvsystem.i_from_v(20, [0.1] * 2, 0.5, [7.5] * 3, 6.0e-7, 7.0,\n                          method='brentq')\n    with pytest.raises(ValueError):\n        pvsystem.i_from_v(20, 0.1, 0.5, [7.5] * 3, 6.0e-7, np.array([7., 7.]),\n                          method='newton')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_i_from_v_size", "with", "pytest", "raises", "valueerror", "pvsystem", "i_from_v", "20", "0", "1", "2", "0", "5", "7", "5", "3", "6", "0e", "7", "7", "0", "with", "pytest", "raises", "valueerror", "pvsystem", "i_from_v", "20", "0", "1", "2", "0", "5", "7", "5", "3", "6", "0e", "7", "7", "0", "method", "brentq", "with", "pytest", "raises", "valueerror", "pvsystem", "i_from_v", "20", "0", "1", "0", "5", "7", "5", "3", "6", "0e", "7", "np", "array", "7", "7", "method", "newton"], "doc_len": 71}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_v_from_i_size", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_v_from_i_size", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_v_from_i_size():\n    with pytest.raises(ValueError):\n        pvsystem.v_from_i(20, [0.1] * 2, 0.5, [3.0] * 3, 6.0e-7, 7.0)\n    with pytest.raises(ValueError):\n        pvsystem.v_from_i(20, [0.1] * 2, 0.5, [3.0] * 3, 6.0e-7, 7.0,\n                          method='brentq')\n    with pytest.raises(ValueError):\n        pvsystem.v_from_i(20, [0.1], 0.5, [3.0] * 3, 6.0e-7, np.array([7., 7.]),\n                          method='newton')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_v_from_i_size", "with", "pytest", "raises", "valueerror", "pvsystem", "v_from_i", "20", "0", "1", "2", "0", "5", "3", "0", "3", "6", "0e", "7", "7", "0", "with", "pytest", "raises", "valueerror", "pvsystem", "v_from_i", "20", "0", "1", "2", "0", "5", "3", "0", "3", "6", "0e", "7", "7", "0", "method", "brentq", "with", "pytest", "raises", "valueerror", "pvsystem", "v_from_i", "20", "0", "1", "0", "5", "3", "0", "3", "6", "0e", "7", "np", "array", "7", "7", "method", "newton"], "doc_len": 71}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_mpp_floats", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_mpp_floats", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_mpp_floats():\n    \"\"\"test max_power_point\"\"\"\n    IL, I0, Rs, Rsh, nNsVth = (7, 6e-7, .1, 20, .5)\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='brentq')\n    expected = {'i_mp': 6.1362673597376753,  # 6.1390251797935704, lambertw\n                'v_mp': 6.2243393757884284,  # 6.221535886625464, lambertw\n                'p_mp': 38.194210547580511}  # 38.194165464983037} lambertw\n    assert isinstance(out, dict)\n    for k, v in out.items():\n        assert np.isclose(v, expected[k])\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='newton')\n    for k, v in out.items():\n        assert np.isclose(v, expected[k])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_mpp_floats", "test", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "7", "6e", "7", "1", "20", "5", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "brentq", "expected", "i_mp", "6", "1362673597376753", "6", "1390251797935704", "lambertw", "v_mp", "6", "2243393757884284", "6", "221535886625464", "lambertw", "p_mp", "38", "194210547580511", "38", "194165464983037", "lambertw", "assert", "isinstance", "out", "dict", "for", "k", "v", "in", "out", "items", "assert", "np", "isclose", "v", "expected", "k", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "newton", "for", "k", "v", "in", "out", "items", "assert", "np", "isclose", "v", "expected", "k"], "doc_len": 86}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_mpp_array", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_mpp_array", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_mpp_array():\n    \"\"\"test max_power_point\"\"\"\n    IL, I0, Rs, Rsh, nNsVth = (np.array([7, 7]), 6e-7, .1, 20, .5)\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='brentq')\n    expected = {'i_mp': [6.1362673597376753] * 2,\n                'v_mp': [6.2243393757884284] * 2,\n                'p_mp': [38.194210547580511] * 2}\n    assert isinstance(out, dict)\n    for k, v in out.items():\n        assert np.allclose(v, expected[k])\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='newton')\n    for k, v in out.items():\n        assert np.allclose(v, expected[k])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_mpp_array", "test", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "np", "array", "7", "7", "6e", "7", "1", "20", "5", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "brentq", "expected", "i_mp", "6", "1362673597376753", "2", "v_mp", "6", "2243393757884284", "2", "p_mp", "38", "194210547580511", "2", "assert", "isinstance", "out", "dict", "for", "k", "v", "in", "out", "items", "assert", "np", "allclose", "v", "expected", "k", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "newton", "for", "k", "v", "in", "out", "items", "assert", "np", "allclose", "v", "expected", "k"], "doc_len": 83}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_mpp_series", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_mpp_series", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_mpp_series():\n    \"\"\"test max_power_point\"\"\"\n    idx = ['2008-02-17T11:30:00-0800', '2008-02-17T12:30:00-0800']\n    IL, I0, Rs, Rsh, nNsVth = (np.array([7, 7]), 6e-7, .1, 20, .5)\n    IL = pd.Series(IL, index=idx)\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='brentq')\n    expected = pd.DataFrame({'i_mp': [6.1362673597376753] * 2,\n                             'v_mp': [6.2243393757884284] * 2,\n                             'p_mp': [38.194210547580511] * 2},\n                            index=idx)\n    assert isinstance(out, pd.DataFrame)\n    for k, v in out.items():\n        assert np.allclose(v, expected[k])\n    out = pvsystem.max_power_point(IL, I0, Rs, Rsh, nNsVth, method='newton')\n    for k, v in out.items():\n        assert np.allclose(v, expected[k])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_mpp_series", "test", "max_power_point", "idx", "2008", "02", "17t11", "30", "00", "0800", "2008", "02", "17t12", "30", "00", "0800", "il", "i0", "rs", "rsh", "nnsvth", "np", "array", "7", "7", "6e", "7", "1", "20", "5", "il", "pd", "series", "il", "index", "idx", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "brentq", "expected", "pd", "dataframe", "i_mp", "6", "1362673597376753", "2", "v_mp", "6", "2243393757884284", "2", "p_mp", "38", "194210547580511", "2", "index", "idx", "assert", "isinstance", "out", "pd", "dataframe", "for", "k", "v", "in", "out", "items", "assert", "np", "allclose", "v", "expected", "k", "out", "pvsystem", "max_power_point", "il", "i0", "rs", "rsh", "nnsvth", "method", "newton", "for", "k", "v", "in", "out", "items", "assert", "np", "allclose", "v", "expected", "k"], "doc_len": 107}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_singlediode_series", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_singlediode_series", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_singlediode_series(cec_module_params):\n    times = pd.date_range(start='2015-01-01', periods=2, freq='12H')\n    effective_irradiance = pd.Series([0.0, 800.0], index=times)\n    IL, I0, Rs, Rsh, nNsVth = pvsystem.calcparams_desoto(\n        effective_irradiance,\n        temp_cell=25,\n        alpha_sc=cec_module_params['alpha_sc'],\n        a_ref=cec_module_params['a_ref'],\n        I_L_ref=cec_module_params['I_L_ref'],\n        I_o_ref=cec_module_params['I_o_ref'],\n        R_sh_ref=cec_module_params['R_sh_ref'],\n        R_s=cec_module_params['R_s'],\n        EgRef=1.121,\n        dEgdT=-0.0002677\n    )\n    out = pvsystem.singlediode(IL, I0, Rs, Rsh, nNsVth)\n    assert isinstance(out, pd.DataFrame)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singlediode_series", "cec_module_params", "times", "pd", "date_range", "start", "2015", "01", "01", "periods", "2", "freq", "12h", "effective_irradiance", "pd", "series", "0", "0", "800", "0", "index", "times", "il", "i0", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_desoto", "effective_irradiance", "temp_cell", "25", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "egref", "1", "121", "degdt", "0", "0002677", "out", "pvsystem", "singlediode", "il", "i0", "rs", "rsh", "nnsvth", "assert", "isinstance", "out", "pd", "dataframe"], "doc_len": 74}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_singlediode_array", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_singlediode_array", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_singlediode_array():\n    # github issue 221\n    photocurrent = np.linspace(0, 10, 11)\n    resistance_shunt = 16\n    resistance_series = 0.094\n    nNsVth = 0.473\n    saturation_current = 1.943e-09\n\n    sd = pvsystem.singlediode(photocurrent, saturation_current,\n                              resistance_series, resistance_shunt, nNsVth,\n                              method='lambertw')\n\n    expected_i = np.array([\n        0., 0.54614798740338, 1.435026463529, 2.3621366610078, 3.2953968319952,\n        4.2303869378787, 5.1655276691892, 6.1000269648604, 7.0333996177802,\n        7.9653036915959, 8.8954716265647])\n    expected_v = np.array([\n        0., 7.0966259059555, 7.9961986643428, 8.2222496810656, 8.3255927555753,\n        8.3766915453915, 8.3988872440242, 8.4027948807891, 8.3941399580559,\n        8.3763655188855, 8.3517057522791])\n\n    assert_allclose(sd['i_mp'], expected_i, atol=1e-8)\n    assert_allclose(sd['v_mp'], expected_v, atol=1e-8)\n\n    sd = pvsystem.singlediode(photocurrent, saturation_current,\n                              resistance_series, resistance_shunt, nNsVth)\n    expected = pvsystem.i_from_v(resistance_shunt, resistance_series, nNsVth,\n                                 sd['v_mp'], saturation_current, photocurrent,\n                                 method='lambertw')\n    assert_allclose(sd['i_mp'], expected, atol=1e-8)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singlediode_array", "github", "issue", "221", "photocurrent", "np", "linspace", "0", "10", "11", "resistance_shunt", "16", "resistance_series", "0", "094", "nnsvth", "0", "473", "saturation_current", "1", "943e", "09", "sd", "pvsystem", "singlediode", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "method", "lambertw", "expected_i", "np", "array", "0", "0", "54614798740338", "1", "435026463529", "2", "3621366610078", "3", "2953968319952", "4", "2303869378787", "5", "1655276691892", "6", "1000269648604", "7", "0333996177802", "7", "9653036915959", "8", "8954716265647", "expected_v", "np", "array", "0", "7", "0966259059555", "7", "9961986643428", "8", "2222496810656", "8", "3255927555753", "8", "3766915453915", "8", "3988872440242", "8", "4027948807891", "8", "3941399580559", "8", "3763655188855", "8", "3517057522791", "assert_allclose", "sd", "i_mp", "expected_i", "atol", "1e", "8", "assert_allclose", "sd", "v_mp", "expected_v", "atol", "1e", "8", "sd", "pvsystem", "singlediode", "photocurrent", "saturation_current", "resistance_series", "resistance_shunt", "nnsvth", "expected", "pvsystem", "i_from_v", "resistance_shunt", "resistance_series", "nnsvth", "sd", "v_mp", "saturation_current", "photocurrent", "method", "lambertw", "assert_allclose", "sd", "i_mp", "expected", "atol", "1e", "8"], "doc_len": 126}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_singlediode_floats", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_singlediode_floats", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_singlediode_floats():\n    out = pvsystem.singlediode(7., 6.e-7, .1, 20., .5, method='lambertw')\n    expected = {'i_xx': 4.264060478,\n                'i_mp': 6.136267360,\n                'v_oc': 8.106300147,\n                'p_mp': 38.19421055,\n                'i_x': 6.7558815684,\n                'i_sc': 6.965172322,\n                'v_mp': 6.224339375,\n                'i': None,\n                'v': None}\n    assert isinstance(out, dict)\n    for k, v in out.items():\n        if k in ['i', 'v']:\n            assert v is None\n        else:\n            assert_allclose(v, expected[k], atol=1e-6)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singlediode_floats", "out", "pvsystem", "singlediode", "7", "6", "e", "7", "1", "20", "5", "method", "lambertw", "expected", "i_xx", "4", "264060478", "i_mp", "6", "136267360", "v_oc", "8", "106300147", "p_mp", "38", "19421055", "i_x", "6", "7558815684", "i_sc", "6", "965172322", "v_mp", "6", "224339375", "i", "none", "v", "none", "assert", "isinstance", "out", "dict", "for", "k", "v", "in", "out", "items", "if", "k", "in", "i", "v", "assert", "v", "is", "none", "else", "assert_allclose", "v", "expected", "k", "atol", "1e", "6"], "doc_len": 71}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_singlediode_floats_ivcurve", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_singlediode_floats_ivcurve", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_singlediode_floats_ivcurve():\n    out = pvsystem.singlediode(7., 6e-7, .1, 20., .5, ivcurve_pnts=3,\n                               method='lambertw')\n    expected = {'i_xx': 4.264060478,\n                'i_mp': 6.136267360,\n                'v_oc': 8.106300147,\n                'p_mp': 38.19421055,\n                'i_x': 6.7558815684,\n                'i_sc': 6.965172322,\n                'v_mp': 6.224339375,\n                'i': np.array([\n                    6.965172322, 6.755881568, 2.664535259e-14]),\n                'v': np.array([\n                    0., 4.053150073, 8.106300147])}\n    assert isinstance(out, dict)\n    for k, v in out.items():\n        assert_allclose(v, expected[k], atol=1e-6)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singlediode_floats_ivcurve", "out", "pvsystem", "singlediode", "7", "6e", "7", "1", "20", "5", "ivcurve_pnts", "3", "method", "lambertw", "expected", "i_xx", "4", "264060478", "i_mp", "6", "136267360", "v_oc", "8", "106300147", "p_mp", "38", "19421055", "i_x", "6", "7558815684", "i_sc", "6", "965172322", "v_mp", "6", "224339375", "i", "np", "array", "6", "965172322", "6", "755881568", "2", "664535259e", "14", "v", "np", "array", "0", "4", "053150073", "8", "106300147", "assert", "isinstance", "out", "dict", "for", "k", "v", "in", "out", "items", "assert_allclose", "v", "expected", "k", "atol", "1e", "6"], "doc_len": 76}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_singlediode_series_ivcurve", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_singlediode_series_ivcurve", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_singlediode_series_ivcurve(cec_module_params):\n    times = pd.date_range(start='2015-06-01', periods=3, freq='6H')\n    effective_irradiance = pd.Series([0.0, 400.0, 800.0], index=times)\n    IL, I0, Rs, Rsh, nNsVth = pvsystem.calcparams_desoto(\n                                  effective_irradiance,\n                                  temp_cell=25,\n                                  alpha_sc=cec_module_params['alpha_sc'],\n                                  a_ref=cec_module_params['a_ref'],\n                                  I_L_ref=cec_module_params['I_L_ref'],\n                                  I_o_ref=cec_module_params['I_o_ref'],\n                                  R_sh_ref=cec_module_params['R_sh_ref'],\n                                  R_s=cec_module_params['R_s'],\n                                  EgRef=1.121,\n                                  dEgdT=-0.0002677)\n\n    out = pvsystem.singlediode(IL, I0, Rs, Rsh, nNsVth, ivcurve_pnts=3,\n                               method='lambertw')\n\n    expected = OrderedDict([('i_sc', array([0., 3.01079860, 6.00726296])),\n                            ('v_oc', array([0., 9.96959733, 10.29603253])),\n                            ('i_mp', array([0., 2.656285960, 5.290525645])),\n                            ('v_mp', array([0., 8.321092255, 8.409413795])),\n                            ('p_mp', array([0., 22.10320053, 44.49021934])),\n                            ('i_x', array([0., 2.884132006, 5.746202281])),\n                            ('i_xx', array([0., 2.052691562, 3.909673879])),\n                            ('v', array([[0., 0., 0.],\n                                         [0., 4.984798663, 9.969597327],\n                                         [0., 5.148016266, 10.29603253]])),\n                            ('i', array([[0., 0., 0.],\n                                         [3.0107985972, 2.8841320056, 0.],\n                                         [6.0072629615, 5.7462022810, 0.]]))])\n\n\n    for k, v in out.items():\n        assert_allclose(v, expected[k], atol=1e-2)\n\n    out = pvsystem.singlediode(IL, I0, Rs, Rsh, nNsVth, ivcurve_pnts=3)\n\n    expected['i_mp'] = pvsystem.i_from_v(Rsh, Rs, nNsVth, out['v_mp'], I0, IL,\n                                         method='lambertw')\n    expected['v_mp'] = pvsystem.v_from_i(Rsh, Rs, nNsVth, out['i_mp'], I0, IL,\n                                         method='lambertw')\n    expected['i'] = pvsystem.i_from_v(Rsh, Rs, nNsVth, out['v'].T, I0, IL,\n                                         method='lambertw').T\n    expected['v'] = pvsystem.v_from_i(Rsh, Rs, nNsVth, out['i'].T, I0, IL,\n                                         method='lambertw').T\n\n    for k, v in out.items():\n        assert_allclose(v, expected[k], atol=1e-6)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singlediode_series_ivcurve", "cec_module_params", "times", "pd", "date_range", "start", "2015", "06", "01", "periods", "3", "freq", "6h", "effective_irradiance", "pd", "series", "0", "0", "400", "0", "800", "0", "index", "times", "il", "i0", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_desoto", "effective_irradiance", "temp_cell", "25", "alpha_sc", "cec_module_params", "alpha_sc", "a_ref", "cec_module_params", "a_ref", "i_l_ref", "cec_module_params", "i_l_ref", "i_o_ref", "cec_module_params", "i_o_ref", "r_sh_ref", "cec_module_params", "r_sh_ref", "r_s", "cec_module_params", "r_s", "egref", "1", "121", "degdt", "0", "0002677", "out", "pvsystem", "singlediode", "il", "i0", "rs", "rsh", "nnsvth", "ivcurve_pnts", "3", "method", "lambertw", "expected", "ordereddict", "i_sc", "array", "0", "3", "01079860", "6", "00726296", "v_oc", "array", "0", "9", "96959733", "10", "29603253", "i_mp", "array", "0", "2", "656285960", "5", "290525645", "v_mp", "array", "0", "8", "321092255", "8", "409413795", "p_mp", "array", "0", "22", "10320053", "44", "49021934", "i_x", "array", "0", "2", "884132006", "5", "746202281", "i_xx", "array", "0", "2", "052691562", "3", "909673879", "v", "array", "0", "0", "0", "0", "4", "984798663", "9", "969597327", "0", "5", "148016266", "10", "29603253", "i", "array", "0", "0", "0", "3", "0107985972", "2", "8841320056", "0", "6", "0072629615", "5", "7462022810", "0", "for", "k", "v", "in", "out", "items", "assert_allclose", "v", "expected", "k", "atol", "1e", "2", "out", "pvsystem", "singlediode", "il", "i0", "rs", "rsh", "nnsvth", "ivcurve_pnts", "3", "expected", "i_mp", "pvsystem", "i_from_v", "rsh", "rs", "nnsvth", "out", "v_mp", "i0", "il", "method", "lambertw", "expected", "v_mp", "pvsystem", "v_from_i", "rsh", "rs", "nnsvth", "out", "i_mp", "i0", "il", "method", "lambertw", "expected", "i", "pvsystem", "i_from_v", "rsh", "rs", "nnsvth", "out", "v", "t", "i0", "il", "method", "lambertw", "t", "expected", "v", "pvsystem", "v_from_i", "rsh", "rs", "nnsvth", "out", "i", "t", "i0", "il", "method", "lambertw", "t", "for", "k", "v", "in", "out", "items", "assert_allclose", "v", "expected", "k", "atol", "1e", "6"], "doc_len": 248}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_scale_voltage_current_power", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_scale_voltage_current_power", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_scale_voltage_current_power():\n    data = pd.DataFrame(\n        np.array([[2, 1.5, 10, 8, 12, 0.5, 1.5]]),\n        columns=['i_sc', 'i_mp', 'v_oc', 'v_mp', 'p_mp', 'i_x', 'i_xx'],\n        index=[0])\n    expected = pd.DataFrame(\n        np.array([[6, 4.5, 20, 16, 72, 1.5, 4.5]]),\n        columns=['i_sc', 'i_mp', 'v_oc', 'v_mp', 'p_mp', 'i_x', 'i_xx'],\n        index=[0])\n    out = pvsystem.scale_voltage_current_power(data, voltage=2, current=3)\n    assert_frame_equal(out, expected, check_less_precise=5)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_scale_voltage_current_power", "data", "pd", "dataframe", "np", "array", "2", "1", "5", "10", "8", "12", "0", "5", "1", "5", "columns", "i_sc", "i_mp", "v_oc", "v_mp", "p_mp", "i_x", "i_xx", "index", "0", "expected", "pd", "dataframe", "np", "array", "6", "4", "5", "20", "16", "72", "1", "5", "4", "5", "columns", "i_sc", "i_mp", "v_oc", "v_mp", "p_mp", "i_x", "i_xx", "index", "0", "out", "pvsystem", "scale_voltage_current_power", "data", "voltage", "2", "current", "3", "assert_frame_equal", "out", "expected", "check_less_precise", "5"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_scale_voltage_current_power", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_scale_voltage_current_power", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_scale_voltage_current_power(mocker):\n    data = None\n    system = pvsystem.PVSystem(modules_per_string=2, strings_per_inverter=3)\n    m = mocker.patch(\n        'pvlib.pvsystem.scale_voltage_current_power', autospec=True)\n    system.scale_voltage_current_power(data)\n    m.assert_called_once_with(data, voltage=2, current=3)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_scale_voltage_current_power", "mocker", "data", "none", "system", "pvsystem", "pvsystem", "modules_per_string", "2", "strings_per_inverter", "3", "m", "mocker", "patch", "pvlib", "pvsystem", "scale_voltage_current_power", "autospec", "true", "system", "scale_voltage_current_power", "data", "m", "assert_called_once_with", "data", "voltage", "2", "current", "3"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_scale_voltage_current_power", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_scale_voltage_current_power", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_scale_voltage_current_power(mocker):\n    data = (1, 2)\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               modules_per_string=2, strings=3),\n                pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               modules_per_string=3, strings=5)]\n    )\n    m = mocker.patch(\n        'pvlib.pvsystem.scale_voltage_current_power', autospec=True\n    )\n    system.scale_voltage_current_power(data)\n    m.assert_has_calls(\n        [mock.call(1, voltage=2, current=3),\n         mock.call(2, voltage=3, current=5)],\n        any_order=True\n    )\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.scale_voltage_current_power(None)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_scale_voltage_current_power", "mocker", "data", "1", "2", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "modules_per_string", "2", "strings", "3", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "modules_per_string", "3", "strings", "5", "m", "mocker", "patch", "pvlib", "pvsystem", "scale_voltage_current_power", "autospec", "true", "system", "scale_voltage_current_power", "data", "m", "assert_has_calls", "mock", "call", "1", "voltage", "2", "current", "3", "mock", "call", "2", "voltage", "3", "current", "5", "any_order", "true", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "scale_voltage_current_power", "none"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_sandia", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_sandia", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_sandia(cec_inverter_parameters, mocker):\n    inv_fun = mocker.spy(inverter, 'sandia')\n    system = pvsystem.PVSystem(\n        inverter=cec_inverter_parameters['Name'],\n        inverter_parameters=cec_inverter_parameters,\n    )\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3))\n    pdcs = idcs * vdcs\n    pacs = system.get_ac('sandia', pdcs, v_dc=vdcs)\n    inv_fun.assert_called_once()\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004308, 250.000000]))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_sandia", "cec_inverter_parameters", "mocker", "inv_fun", "mocker", "spy", "inverter", "sandia", "system", "pvsystem", "pvsystem", "inverter", "cec_inverter_parameters", "name", "inverter_parameters", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "pacs", "system", "get_ac", "sandia", "pdcs", "v_dc", "vdcs", "inv_fun", "assert_called_once", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004308", "250", "000000"], "doc_len": 59}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_snlinverter", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_snlinverter", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_snlinverter(cec_inverter_parameters):\n    system = pvsystem.PVSystem(\n        inverter=cec_inverter_parameters['Name'],\n        inverter_parameters=cec_inverter_parameters,\n    )\n    vdcs = pd.Series(np.linspace(0,50,3))\n    idcs = pd.Series(np.linspace(0,11,3))\n    pdcs = idcs * vdcs\n    with pytest.warns(pvlibDeprecationWarning):\n        pacs = system.snlinverter(vdcs, pdcs)\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004308, 250.000000]))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_snlinverter", "cec_inverter_parameters", "system", "pvsystem", "pvsystem", "inverter", "cec_inverter_parameters", "name", "inverter_parameters", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "pdcs", "idcs", "vdcs", "with", "pytest", "warns", "pvlibdeprecationwarning", "pacs", "system", "snlinverter", "vdcs", "pdcs", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004308", "250", "000000"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_sandia_multi", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_sandia_multi", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_sandia_multi(cec_inverter_parameters, mocker):\n    inv_fun = mocker.spy(inverter, 'sandia_multi')\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180)),\n                pvsystem.Array(pvsystem.FixedMount(0, 180))],\n        inverter=cec_inverter_parameters['Name'],\n        inverter_parameters=cec_inverter_parameters,\n    )\n    vdcs = pd.Series(np.linspace(0, 50, 3))\n    idcs = pd.Series(np.linspace(0, 11, 3)) / 2\n    pdcs = idcs * vdcs\n    pacs = system.get_ac('sandia', (pdcs, pdcs), v_dc=(vdcs, vdcs))\n    inv_fun.assert_called_once()\n    assert_series_equal(pacs, pd.Series([-0.020000, 132.004308, 250.000000]))\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('sandia', vdcs, (pdcs, pdcs))\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('sandia', vdcs, (pdcs,))\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('sandia', (vdcs, vdcs), (pdcs, pdcs, pdcs))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_sandia_multi", "cec_inverter_parameters", "mocker", "inv_fun", "mocker", "spy", "inverter", "sandia_multi", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "inverter", "cec_inverter_parameters", "name", "inverter_parameters", "cec_inverter_parameters", "vdcs", "pd", "series", "np", "linspace", "0", "50", "3", "idcs", "pd", "series", "np", "linspace", "0", "11", "3", "2", "pdcs", "idcs", "vdcs", "pacs", "system", "get_ac", "sandia", "pdcs", "pdcs", "v_dc", "vdcs", "vdcs", "inv_fun", "assert_called_once", "assert_series_equal", "pacs", "pd", "series", "0", "020000", "132", "004308", "250", "000000", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "sandia", "vdcs", "pdcs", "pdcs", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "sandia", "vdcs", "pdcs", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "sandia", "vdcs", "vdcs", "pdcs", "pdcs", "pdcs"], "doc_len": 127}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_pvwatts", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_pvwatts", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_pvwatts(pvwatts_system_defaults, mocker):\n    mocker.spy(inverter, 'pvwatts')\n    pdc = 50\n    out = pvwatts_system_defaults.get_ac('pvwatts', pdc)\n    inverter.pvwatts.assert_called_once_with(\n        pdc, **pvwatts_system_defaults.inverter_parameters)\n    assert out < pdc\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_pvwatts", "pvwatts_system_defaults", "mocker", "mocker", "spy", "inverter", "pvwatts", "pdc", "50", "out", "pvwatts_system_defaults", "get_ac", "pvwatts", "pdc", "inverter", "pvwatts", "assert_called_once_with", "pdc", "pvwatts_system_defaults", "inverter_parameters", "assert", "out", "pdc"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_pvwatts_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_pvwatts_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_pvwatts_kwargs(pvwatts_system_kwargs, mocker):\n    mocker.spy(inverter, 'pvwatts')\n    pdc = 50\n    out = pvwatts_system_kwargs.get_ac('pvwatts', pdc)\n    inverter.pvwatts.assert_called_once_with(\n        pdc, **pvwatts_system_kwargs.inverter_parameters)\n    assert out < pdc\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_pvwatts_kwargs", "pvwatts_system_kwargs", "mocker", "mocker", "spy", "inverter", "pvwatts", "pdc", "50", "out", "pvwatts_system_kwargs", "get_ac", "pvwatts", "pdc", "inverter", "pvwatts", "assert_called_once_with", "pdc", "pvwatts_system_kwargs", "inverter_parameters", "assert", "out", "pdc"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_pvwatts_multi", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_pvwatts_multi", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_pvwatts_multi(\n        pvwatts_system_defaults, pvwatts_system_kwargs, mocker):\n    mocker.spy(inverter, 'pvwatts_multi')\n    expected = [pd.Series([0.0, 48.123524, 86.400000]),\n                pd.Series([0.0, 45.893550, 85.500000])]\n    systems = [pvwatts_system_defaults, pvwatts_system_kwargs]\n    for base_sys, exp in zip(systems, expected):\n        system = pvsystem.PVSystem(\n            arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180)),\n                    pvsystem.Array(pvsystem.FixedMount(0, 180),)],\n            inverter_parameters=base_sys.inverter_parameters,\n        )\n        pdcs = pd.Series([0., 25., 50.])\n        pacs = system.get_ac('pvwatts', (pdcs, pdcs))\n        assert_series_equal(pacs, exp)\n    assert inverter.pvwatts_multi.call_count == 2\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('pvwatts', (pdcs,))\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('pvwatts', pdcs)\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_ac('pvwatts', (pdcs, pdcs, pdcs))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_pvwatts_multi", "pvwatts_system_defaults", "pvwatts_system_kwargs", "mocker", "mocker", "spy", "inverter", "pvwatts_multi", "expected", "pd", "series", "0", "0", "48", "123524", "86", "400000", "pd", "series", "0", "0", "45", "893550", "85", "500000", "systems", "pvwatts_system_defaults", "pvwatts_system_kwargs", "for", "base_sys", "exp", "in", "zip", "systems", "expected", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "inverter_parameters", "base_sys", "inverter_parameters", "pdcs", "pd", "series", "0", "25", "50", "pacs", "system", "get_ac", "pvwatts", "pdcs", "pdcs", "assert_series_equal", "pacs", "exp", "assert", "inverter", "pvwatts_multi", "call_count", "2", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "pvwatts", "pdcs", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "pvwatts", "pdcs", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_ac", "pvwatts", "pdcs", "pdcs", "pdcs"], "doc_len": 126}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_single_array_tuple_input", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_single_array_tuple_input", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_single_array_tuple_input(\n        model,\n        pvwatts_system_defaults,\n        cec_inverter_parameters,\n        adr_inverter_parameters):\n    vdcs = {\n        'sandia': pd.Series(np.linspace(0, 50, 3)),\n        'pvwatts': None,\n        'adr': pd.Series([135, 154, 390, 420, 551])\n    }\n    pdcs = {'adr': pd.Series([135, 1232, 1170, 420, 551]),\n            'sandia': pd.Series(np.linspace(0, 11, 3)) * vdcs['sandia'],\n            'pvwatts': 50}\n    inverter_parameters = {\n        'sandia': cec_inverter_parameters,\n        'adr': adr_inverter_parameters,\n        'pvwatts': pvwatts_system_defaults.inverter_parameters\n    }\n    expected = {\n        'adr': pd.Series([np.nan, 1161.5745, 1116.4459, 382.6679, np.nan]),\n        'sandia': pd.Series([-0.020000, 132.004308, 250.000000])\n    }\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180))],\n        inverter_parameters=inverter_parameters[model]\n    )\n    ac = system.get_ac(p_dc=(pdcs[model],), v_dc=(vdcs[model],), model=model)\n    if model == 'pvwatts':\n        assert ac < pdcs['pvwatts']\n    else:\n        assert_series_equal(ac, expected[model])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_single_array_tuple_input", "model", "pvwatts_system_defaults", "cec_inverter_parameters", "adr_inverter_parameters", "vdcs", "sandia", "pd", "series", "np", "linspace", "0", "50", "3", "pvwatts", "none", "adr", "pd", "series", "135", "154", "390", "420", "551", "pdcs", "adr", "pd", "series", "135", "1232", "1170", "420", "551", "sandia", "pd", "series", "np", "linspace", "0", "11", "3", "vdcs", "sandia", "pvwatts", "50", "inverter_parameters", "sandia", "cec_inverter_parameters", "adr", "adr_inverter_parameters", "pvwatts", "pvwatts_system_defaults", "inverter_parameters", "expected", "adr", "pd", "series", "np", "nan", "1161", "5745", "1116", "4459", "382", "6679", "np", "nan", "sandia", "pd", "series", "0", "020000", "132", "004308", "250", "000000", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "inverter_parameters", "inverter_parameters", "model", "ac", "system", "get_ac", "p_dc", "pdcs", "model", "v_dc", "vdcs", "model", "model", "model", "if", "model", "pvwatts", "assert", "ac", "pdcs", "pvwatts", "else", "assert_series_equal", "ac", "expected", "model"], "doc_len": 117}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_adr", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_adr", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_adr(adr_inverter_parameters, mocker):\n    mocker.spy(inverter, 'adr')\n    system = pvsystem.PVSystem(\n        inverter_parameters=adr_inverter_parameters,\n    )\n    vdcs = pd.Series([135, 154, 390, 420, 551])\n    pdcs = pd.Series([135, 1232, 1170, 420, 551])\n    pacs = system.get_ac('adr', pdcs, vdcs)\n    assert_series_equal(pacs, pd.Series([np.nan, 1161.5745, 1116.4459,\n                                         382.6679, np.nan]))\n    inverter.adr.assert_called_once_with(vdcs, pdcs,\n                                         system.inverter_parameters)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_adr", "adr_inverter_parameters", "mocker", "mocker", "spy", "inverter", "adr", "system", "pvsystem", "pvsystem", "inverter_parameters", "adr_inverter_parameters", "vdcs", "pd", "series", "135", "154", "390", "420", "551", "pdcs", "pd", "series", "135", "1232", "1170", "420", "551", "pacs", "system", "get_ac", "adr", "pdcs", "vdcs", "assert_series_equal", "pacs", "pd", "series", "np", "nan", "1161", "5745", "1116", "4459", "382", "6679", "np", "nan", "inverter", "adr", "assert_called_once_with", "vdcs", "pdcs", "system", "inverter_parameters"], "doc_len": 60}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_adr_multi", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_adr_multi", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_adr_multi(adr_inverter_parameters):\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180)),\n                pvsystem.Array(pvsystem.FixedMount(0, 180))],\n        inverter_parameters=adr_inverter_parameters,\n    )\n    pdcs = pd.Series([135, 1232, 1170, 420, 551])\n    with pytest.raises(ValueError,\n                       match=\"The adr inverter function cannot be used\"):\n        system.get_ac(model='adr', p_dc=pdcs)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_adr_multi", "adr_inverter_parameters", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "inverter_parameters", "adr_inverter_parameters", "pdcs", "pd", "series", "135", "1232", "1170", "420", "551", "with", "pytest", "raises", "valueerror", "match", "the", "adr", "inverter", "function", "cannot", "be", "used", "system", "get_ac", "model", "adr", "p_dc", "pdcs"], "doc_len": 51}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_ac_invalid", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_ac_invalid", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_ac_invalid(cec_inverter_parameters):\n    system = pvsystem.PVSystem(\n        inverter_parameters=cec_inverter_parameters,\n    )\n    pdcs = pd.Series(np.linspace(0, 50, 3))\n    with pytest.raises(ValueError, match=\"is not a valid AC power model\"):\n        system.get_ac(model='not_a_model', p_dc=pdcs)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_ac_invalid", "cec_inverter_parameters", "system", "pvsystem", "pvsystem", "inverter_parameters", "cec_inverter_parameters", "pdcs", "pd", "series", "np", "linspace", "0", "50", "3", "with", "pytest", "raises", "valueerror", "match", "is", "not", "a", "valid", "ac", "power", "model", "system", "get_ac", "model", "not_a_model", "p_dc", "pdcs"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_creation", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_creation", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_creation():\n    pv_system = pvsystem.PVSystem(module='blah', inverter='blarg')\n    # ensure that parameter attributes are dict-like. GH 294\n    with pytest.warns(pvlibDeprecationWarning):\n        pv_system.module_parameters['pdc0'] = 1\n\n    pv_system.inverter_parameters['Paco'] = 1\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_creation", "pv_system", "pvsystem", "pvsystem", "module", "blah", "inverter", "blarg", "ensure", "that", "parameter", "attributes", "are", "dict", "like", "gh", "294", "with", "pytest", "warns", "pvlibdeprecationwarning", "pv_system", "module_parameters", "pdc0", "1", "pv_system", "inverter_parameters", "paco", "1"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multiple_array_creation", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multiple_array_creation", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multiple_array_creation():\n    array_one = pvsystem.Array(pvsystem.FixedMount(surface_tilt=32))\n    array_two = pvsystem.Array(pvsystem.FixedMount(surface_tilt=15),\n                               module_parameters={'pdc0': 1})\n    pv_system = pvsystem.PVSystem(arrays=[array_one, array_two])\n    assert pv_system.arrays[0].module_parameters == {}\n    assert pv_system.arrays[1].module_parameters == {'pdc0': 1}\n    assert pv_system.arrays == (array_one, array_two)\n    with pytest.raises(TypeError):\n        pvsystem.PVSystem(arrays=array_one)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multiple_array_creation", "array_one", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "32", "array_two", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "15", "module_parameters", "pdc0", "1", "pv_system", "pvsystem", "pvsystem", "arrays", "array_one", "array_two", "assert", "pv_system", "arrays", "0", "module_parameters", "assert", "pv_system", "arrays", "1", "module_parameters", "pdc0", "1", "assert", "pv_system", "arrays", "array_one", "array_two", "with", "pytest", "raises", "typeerror", "pvsystem", "pvsystem", "arrays", "array_one"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_aoi", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_aoi", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_aoi():\n    system = pvsystem.PVSystem(surface_tilt=32, surface_azimuth=135)\n    aoi = system.get_aoi(30, 225)\n    assert np.round(aoi, 4) == 42.7408\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_aoi", "system", "pvsystem", "pvsystem", "surface_tilt", "32", "surface_azimuth", "135", "aoi", "system", "get_aoi", "30", "225", "assert", "np", "round", "aoi", "4", "42", "7408"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multiple_array_get_aoi", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multiple_array_get_aoi", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multiple_array_get_aoi():\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(surface_tilt=15,\n                                                   surface_azimuth=135)),\n                pvsystem.Array(pvsystem.FixedMount(surface_tilt=32,\n                                                   surface_azimuth=135))]\n    )\n    aoi_one, aoi_two = system.get_aoi(30, 225)\n    assert np.round(aoi_two, 4) == 42.7408\n    assert aoi_two != aoi_one\n    assert aoi_one > 0\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multiple_array_get_aoi", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "15", "surface_azimuth", "135", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "32", "surface_azimuth", "135", "aoi_one", "aoi_two", "system", "get_aoi", "30", "225", "assert", "np", "round", "aoi_two", "4", "42", "7408", "assert", "aoi_two", "aoi_one", "assert", "aoi_one", "0"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_pvsystem.py::solar_pos", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "solar_pos", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef solar_pos():\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    location = Location(latitude=32, longitude=-111)\n    return location.get_solarposition(times)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "solar_pos", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "location", "location", "latitude", "32", "longitude", "111", "return", "location", "get_solarposition", "times"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_irradiance(solar_pos):\n    system = pvsystem.PVSystem(surface_tilt=32, surface_azimuth=135)\n    irrads = pd.DataFrame({'dni':[900,0], 'ghi':[600,0], 'dhi':[100,0]},\n                          index=solar_pos.index)\n\n    irradiance = system.get_irradiance(solar_pos['apparent_zenith'],\n                                       solar_pos['azimuth'],\n                                       irrads['dni'],\n                                       irrads['ghi'],\n                                       irrads['dhi'])\n\n    expected = pd.DataFrame(data=np.array(\n        [[883.65494055, 745.86141676, 137.79352379, 126.397131, 11.39639279],\n         [0., -0., 0., 0., 0.]]),\n                            columns=['poa_global', 'poa_direct',\n                                     'poa_diffuse', 'poa_sky_diffuse',\n                                     'poa_ground_diffuse'],\n                            index=solar_pos.index)\n    assert_frame_equal(irradiance, expected, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_irradiance", "solar_pos", "system", "pvsystem", "pvsystem", "surface_tilt", "32", "surface_azimuth", "135", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "solar_pos", "index", "irradiance", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "expected", "pd", "dataframe", "data", "np", "array", "883", "65494055", "745", "86141676", "137", "79352379", "126", "397131", "11", "39639279", "0", "0", "0", "0", "0", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "index", "solar_pos", "index", "assert_frame_equal", "irradiance", "expected", "check_less_precise", "2"], "doc_len": 77}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_irradiance_albedo", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_irradiance_albedo", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_irradiance_albedo(solar_pos):\n    system = pvsystem.PVSystem(surface_tilt=32, surface_azimuth=135)\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0],\n                           'albedo': [0.5, 0.5]},\n                          index=solar_pos.index)\n    # albedo as a Series\n    irradiance = system.get_irradiance(solar_pos['apparent_zenith'],\n                                       solar_pos['azimuth'],\n                                       irrads['dni'],\n                                       irrads['ghi'],\n                                       irrads['dhi'],\n                                       albedo=irrads['albedo'])\n    expected = pd.DataFrame(data=np.array(\n        [[895.05134334, 745.86141676, 149.18992658, 126.397131, 22.79279558],\n         [0., -0., 0., 0., 0.]]),\n        columns=['poa_global', 'poa_direct', 'poa_diffuse', 'poa_sky_diffuse',\n                 'poa_ground_diffuse'],\n        index=solar_pos.index)\n    assert_frame_equal(irradiance, expected, check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_irradiance_albedo", "solar_pos", "system", "pvsystem", "pvsystem", "surface_tilt", "32", "surface_azimuth", "135", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "albedo", "0", "5", "0", "5", "index", "solar_pos", "index", "albedo", "as", "a", "series", "irradiance", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "albedo", "irrads", "albedo", "expected", "pd", "dataframe", "data", "np", "array", "895", "05134334", "745", "86141676", "149", "18992658", "126", "397131", "22", "79279558", "0", "0", "0", "0", "0", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "index", "solar_pos", "index", "assert_frame_equal", "irradiance", "expected", "check_less_precise", "2"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_get_irradiance_model", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_get_irradiance_model", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_get_irradiance_model(mocker, solar_pos):\n    spy_perez = mocker.spy(irradiance, 'perez')\n    spy_haydavies = mocker.spy(irradiance, 'haydavies')\n    system = pvsystem.PVSystem(surface_tilt=32, surface_azimuth=135)\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0]},\n                          index=solar_pos.index)\n    system.get_irradiance(solar_pos['apparent_zenith'],\n                          solar_pos['azimuth'],\n                          irrads['dni'],\n                          irrads['ghi'],\n                          irrads['dhi'])\n    spy_haydavies.assert_called_once()\n    system.get_irradiance(solar_pos['apparent_zenith'],\n                          solar_pos['azimuth'],\n                          irrads['dni'],\n                          irrads['ghi'],\n                          irrads['dhi'],\n                          model='perez')\n    spy_perez.assert_called_once()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_get_irradiance_model", "mocker", "solar_pos", "spy_perez", "mocker", "spy", "irradiance", "perez", "spy_haydavies", "mocker", "spy", "irradiance", "haydavies", "system", "pvsystem", "pvsystem", "surface_tilt", "32", "surface_azimuth", "135", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "solar_pos", "index", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "spy_haydavies", "assert_called_once", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "model", "perez", "spy_perez", "assert_called_once"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_get_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_get_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_get_irradiance(solar_pos):\n    array_one = pvsystem.Array(pvsystem.FixedMount(surface_tilt=32,\n                                                   surface_azimuth=135))\n    array_two = pvsystem.Array(pvsystem.FixedMount(surface_tilt=5,\n                                                   surface_azimuth=150))\n    system = pvsystem.PVSystem(arrays=[array_one, array_two])\n\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0]},\n                          index=solar_pos.index)\n    array_one_expected = array_one.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dni'], irrads['ghi'], irrads['dhi']\n    )\n    array_two_expected = array_two.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dni'], irrads['ghi'], irrads['dhi']\n    )\n    array_one_irrad, array_two_irrad = system.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dni'], irrads['ghi'], irrads['dhi']\n    )\n    assert_frame_equal(\n        array_one_irrad, array_one_expected, check_less_precise=2\n    )\n    assert_frame_equal(\n        array_two_irrad, array_two_expected, check_less_precise=2\n    )\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_get_irradiance", "solar_pos", "array_one", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "32", "surface_azimuth", "135", "array_two", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "5", "surface_azimuth", "150", "system", "pvsystem", "pvsystem", "arrays", "array_one", "array_two", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "solar_pos", "index", "array_one_expected", "array_one", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "array_two_expected", "array_two", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "array_one_irrad", "array_two_irrad", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "assert_frame_equal", "array_one_irrad", "array_one_expected", "check_less_precise", "2", "assert_frame_equal", "array_two_irrad", "array_two_expected", "check_less_precise", "2"], "doc_len": 96}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_get_irradiance_multi_irrad", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_get_irradiance_multi_irrad", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_get_irradiance_multi_irrad(solar_pos):\n    \"\"\"Test a system with two identical arrays but different irradiance.\n\n    Because only the irradiance is different we expect the same output\n    when only one GHI/DHI/DNI input is given, but different output\n    for each array when different GHI/DHI/DNI input is given. For the later\n    case we verify that the correct irradiance data is passed to each array.\n    \"\"\"\n    array_one = pvsystem.Array(pvsystem.FixedMount(0, 180))\n    array_two = pvsystem.Array(pvsystem.FixedMount(0, 180))\n    system = pvsystem.PVSystem(arrays=[array_one, array_two])\n\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0]},\n                          index=solar_pos.index)\n    irrads_two = pd.DataFrame(\n        {'dni': [0, 900], 'ghi': [0, 600], 'dhi': [0, 100]},\n        index=solar_pos.index\n    )\n    array_irrad = system.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        (irrads['dhi'], irrads['dhi']),\n        (irrads['ghi'], irrads['ghi']),\n        (irrads['dni'], irrads['dni'])\n    )\n    assert_frame_equal(array_irrad[0], array_irrad[1])\n    array_irrad = system.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        (irrads['dhi'], irrads_two['dhi']),\n        (irrads['ghi'], irrads_two['ghi']),\n        (irrads['dni'], irrads_two['dni'])\n    )\n    array_one_expected = array_one.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dhi'], irrads['ghi'], irrads['dni']\n    )\n    array_two_expected = array_two.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads_two['dhi'], irrads_two['ghi'], irrads_two['dni']\n    )\n    assert not array_irrad[0].equals(array_irrad[1])\n    assert_frame_equal(array_irrad[0], array_one_expected)\n    assert_frame_equal(array_irrad[1], array_two_expected)\n    with pytest.raises(ValueError,\n                       match=\"Length mismatch for per-array parameter\"):\n        system.get_irradiance(\n            solar_pos['apparent_zenith'],\n            solar_pos['azimuth'],\n            (irrads['dhi'], irrads_two['dhi'], irrads['dhi']),\n            (irrads['ghi'], irrads_two['ghi']),\n            irrads['dni']\n        )\n    array_irrad = system.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        (irrads['dhi'], irrads_two['dhi']),\n        irrads['ghi'],\n        irrads['dni']\n    )\n    assert_frame_equal(array_irrad[0], array_one_expected)\n    assert not array_irrad[0].equals(array_irrad[1])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_get_irradiance_multi_irrad", "solar_pos", "test", "a", "system", "with", "two", "identical", "arrays", "but", "different", "irradiance", "because", "only", "the", "irradiance", "is", "different", "we", "expect", "the", "same", "output", "when", "only", "one", "ghi", "dhi", "dni", "input", "is", "given", "but", "different", "output", "for", "each", "array", "when", "different", "ghi", "dhi", "dni", "input", "is", "given", "for", "the", "later", "case", "we", "verify", "that", "the", "correct", "irradiance", "data", "is", "passed", "to", "each", "array", "array_one", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "array_two", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "system", "pvsystem", "pvsystem", "arrays", "array_one", "array_two", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "solar_pos", "index", "irrads_two", "pd", "dataframe", "dni", "0", "900", "ghi", "0", "600", "dhi", "0", "100", "index", "solar_pos", "index", "array_irrad", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dhi", "irrads", "dhi", "irrads", "ghi", "irrads", "ghi", "irrads", "dni", "irrads", "dni", "assert_frame_equal", "array_irrad", "0", "array_irrad", "1", "array_irrad", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dhi", "irrads_two", "dhi", "irrads", "ghi", "irrads_two", "ghi", "irrads", "dni", "irrads_two", "dni", "array_one_expected", "array_one", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dhi", "irrads", "ghi", "irrads", "dni", "array_two_expected", "array_two", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads_two", "dhi", "irrads_two", "ghi", "irrads_two", "dni", "assert", "not", "array_irrad", "0", "equals", "array_irrad", "1", "assert_frame_equal", "array_irrad", "0", "array_one_expected", "assert_frame_equal", "array_irrad", "1", "array_two_expected", "with", "pytest", "raises", "valueerror", "match", "length", "mismatch", "for", "per", "array", "parameter", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dhi", "irrads_two", "dhi", "irrads", "dhi", "irrads", "ghi", "irrads_two", "ghi", "irrads", "dni", "array_irrad", "system", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dhi", "irrads_two", "dhi", "irrads", "ghi", "irrads", "dni", "assert_frame_equal", "array_irrad", "0", "array_one_expected", "assert", "not", "array_irrad", "0", "equals", "array_irrad", "1"], "doc_len": 256}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array_get_irradiance", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array_get_irradiance", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array_get_irradiance(solar_pos):\n    array = pvsystem.Array(pvsystem.FixedMount(surface_tilt=32,\n                                               surface_azimuth=135))\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0]},\n                          index=solar_pos.index)\n    # defaults for kwargs\n    modeled = array.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dni'], irrads['ghi'], irrads['dhi']\n    )\n    expected = pd.DataFrame(\n        data=np.array(\n            [[883.65494055, 745.86141676, 137.79352379, 126.397131,\n              11.39639279],\n             [0., -0., 0., 0., 0.]]),\n        columns=['poa_global', 'poa_direct', 'poa_diffuse', 'poa_sky_diffuse',\n                 'poa_ground_diffuse'],\n        index=solar_pos.index\n    )\n    assert_frame_equal(modeled, expected, check_less_precise=5)\n    # with specified kwargs, use isotropic sky diffuse because it's easier\n    modeled = array.get_irradiance(\n        solar_pos['apparent_zenith'],\n        solar_pos['azimuth'],\n        irrads['dni'], irrads['ghi'], irrads['dhi'],\n        albedo=0.5, model='isotropic'\n    )\n    sky_diffuse = irradiance.isotropic(array.mount.surface_tilt, irrads['dhi'])\n    ground_diff = irradiance.get_ground_diffuse(\n        array.mount.surface_tilt, irrads['ghi'], 0.5, surface_type=None)\n    aoi = irradiance.aoi(array.mount.surface_tilt, array.mount.surface_azimuth,\n                         solar_pos['apparent_zenith'], solar_pos['azimuth'])\n    direct = irrads['dni'] * cosd(aoi)\n    expected = sky_diffuse + ground_diff + direct\n    assert_series_equal(expected, expected, check_less_precise=5)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array_get_irradiance", "solar_pos", "array", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "32", "surface_azimuth", "135", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "solar_pos", "index", "defaults", "for", "kwargs", "modeled", "array", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "expected", "pd", "dataframe", "data", "np", "array", "883", "65494055", "745", "86141676", "137", "79352379", "126", "397131", "11", "39639279", "0", "0", "0", "0", "0", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "index", "solar_pos", "index", "assert_frame_equal", "modeled", "expected", "check_less_precise", "5", "with", "specified", "kwargs", "use", "isotropic", "sky", "diffuse", "because", "it", "s", "easier", "modeled", "array", "get_irradiance", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "albedo", "0", "5", "model", "isotropic", "sky_diffuse", "irradiance", "isotropic", "array", "mount", "surface_tilt", "irrads", "dhi", "ground_diff", "irradiance", "get_ground_diffuse", "array", "mount", "surface_tilt", "irrads", "ghi", "0", "5", "surface_type", "none", "aoi", "irradiance", "aoi", "array", "mount", "surface_tilt", "array", "mount", "surface_azimuth", "solar_pos", "apparent_zenith", "solar_pos", "azimuth", "direct", "irrads", "dni", "cosd", "aoi", "expected", "sky_diffuse", "ground_diff", "direct", "assert_series_equal", "expected", "expected", "check_less_precise", "5"], "doc_len": 158}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array_attributes", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array_attributes", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array_attributes(attr):\n    array_one = pvsystem.Array(pvsystem.FixedMount())\n    array_two = pvsystem.Array(pvsystem.FixedMount())\n    system = pvsystem.PVSystem(arrays=[array_one, array_two])\n    with pytest.raises(AttributeError):\n        getattr(system, attr)\n\n    with pytest.raises(AttributeError):\n        setattr(system, attr, 'dummy')\n\n    system = pvsystem.PVSystem()\n    with pytest.warns(pvlibDeprecationWarning):\n        getattr(system, attr)\n\n    with pytest.warns(pvlibDeprecationWarning):\n        setattr(system, attr, 'dummy')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array_attributes", "attr", "array_one", "pvsystem", "array", "pvsystem", "fixedmount", "array_two", "pvsystem", "array", "pvsystem", "fixedmount", "system", "pvsystem", "pvsystem", "arrays", "array_one", "array_two", "with", "pytest", "raises", "attributeerror", "getattr", "system", "attr", "with", "pytest", "raises", "attributeerror", "setattr", "system", "attr", "dummy", "system", "pvsystem", "pvsystem", "with", "pytest", "warns", "pvlibdeprecationwarning", "getattr", "system", "attr", "with", "pytest", "warns", "pvlibdeprecationwarning", "setattr", "system", "attr", "dummy"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem___repr__", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem___repr__", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem___repr__():\n    system = pvsystem.PVSystem(\n        module='blah', inverter='blarg', name='pv ftw',\n        temperature_model_parameters={'a': -3.56})\n\n    expected = \"\"\"PVSystem:\n  name: pv ftw\n  Array:\n    name: None\n    mount: FixedMount(surface_tilt=0, surface_azimuth=180, racking_model=None, module_height=None)\n    module: blah\n    albedo: 0.25\n    module_type: None\n    temperature_model_parameters: {'a': -3.56}\n    strings: 1\n    modules_per_string: 1\n  inverter: blarg\"\"\"  # noqa: E501\n    assert system.__repr__() == expected\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem___repr__", "system", "pvsystem", "pvsystem", "module", "blah", "inverter", "blarg", "name", "pv", "ftw", "temperature_model_parameters", "a", "3", "56", "expected", "pvsystem", "name", "pv", "ftw", "array", "name", "none", "mount", "fixedmount", "surface_tilt", "0", "surface_azimuth", "180", "racking_model", "none", "module_height", "none", "module", "blah", "albedo", "0", "25", "module_type", "none", "temperature_model_parameters", "a", "3", "56", "strings", "1", "modules_per_string", "1", "inverter", "blarg", "noqa", "e501", "assert", "system", "__repr__", "expected"], "doc_len": 61}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multi_array___repr__", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multi_array___repr__", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multi_array___repr__():\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(surface_tilt=30,\n                                                   surface_azimuth=100)),\n                pvsystem.Array(pvsystem.FixedMount(surface_tilt=20,\n                                                   surface_azimuth=220),\n                               name='foo')],\n        inverter='blarg',\n    )\n    expected = \"\"\"PVSystem:\n  name: None\n  Array:\n    name: None\n    mount: FixedMount(surface_tilt=30, surface_azimuth=100, racking_model=None, module_height=None)\n    module: None\n    albedo: 0.25\n    module_type: None\n    temperature_model_parameters: {}\n    strings: 1\n    modules_per_string: 1\n  Array:\n    name: foo\n    mount: FixedMount(surface_tilt=20, surface_azimuth=220, racking_model=None, module_height=None)\n    module: None\n    albedo: 0.25\n    module_type: None\n    temperature_model_parameters: {}\n    strings: 1\n    modules_per_string: 1\n  inverter: blarg\"\"\"  # noqa: E501\n    assert expected == system.__repr__()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multi_array___repr__", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "30", "surface_azimuth", "100", "pvsystem", "array", "pvsystem", "fixedmount", "surface_tilt", "20", "surface_azimuth", "220", "name", "foo", "inverter", "blarg", "expected", "pvsystem", "name", "none", "array", "name", "none", "mount", "fixedmount", "surface_tilt", "30", "surface_azimuth", "100", "racking_model", "none", "module_height", "none", "module", "none", "albedo", "0", "25", "module_type", "none", "temperature_model_parameters", "strings", "1", "modules_per_string", "1", "array", "name", "foo", "mount", "fixedmount", "surface_tilt", "20", "surface_azimuth", "220", "racking_model", "none", "module_height", "none", "module", "none", "albedo", "0", "25", "module_type", "none", "temperature_model_parameters", "strings", "1", "modules_per_string", "1", "inverter", "blarg", "noqa", "e501", "assert", "expected", "system", "__repr__"], "doc_len": 92}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array___repr__", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array___repr__", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array___repr__():\n    array = pvsystem.Array(\n        mount=pvsystem.FixedMount(surface_tilt=10, surface_azimuth=100,\n                                  racking_model='close_mount'),\n        albedo=0.15, module_type='glass_glass',\n        temperature_model_parameters={'a': -3.56},\n        module_parameters={'foo': 'bar'},\n        modules_per_string=100,\n        strings=10, module='baz',\n        name='biz'\n    )\n    expected = \"\"\"Array:\n  name: biz\n  mount: FixedMount(surface_tilt=10, surface_azimuth=100, racking_model='close_mount', module_height=None)\n  module: baz\n  albedo: 0.15\n  module_type: glass_glass\n  temperature_model_parameters: {'a': -3.56}\n  strings: 10\n  modules_per_string: 100\"\"\"  # noqa: E501\n    assert array.__repr__() == expected\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array___repr__", "array", "pvsystem", "array", "mount", "pvsystem", "fixedmount", "surface_tilt", "10", "surface_azimuth", "100", "racking_model", "close_mount", "albedo", "0", "15", "module_type", "glass_glass", "temperature_model_parameters", "a", "3", "56", "module_parameters", "foo", "bar", "modules_per_string", "100", "strings", "10", "module", "baz", "name", "biz", "expected", "array", "name", "biz", "mount", "fixedmount", "surface_tilt", "10", "surface_azimuth", "100", "racking_model", "close_mount", "module_height", "none", "module", "baz", "albedo", "0", "15", "module_type", "glass_glass", "temperature_model_parameters", "a", "3", "56", "strings", "10", "modules_per_string", "100", "noqa", "e501", "assert", "array", "__repr__", "expected"], "doc_len": 73}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_dc_scalars", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_dc_scalars", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_dc_scalars():\n    expected = 88.65\n    out = pvsystem.pvwatts_dc(900, 30, 100, -0.003)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_dc_scalars", "expected", "88", "65", "out", "pvsystem", "pvwatts_dc", "900", "30", "100", "0", "003", "assert_allclose", "out", "expected"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_dc_arrays", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_dc_arrays", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_dc_arrays():\n    irrad_trans = np.array([np.nan, 900, 900])\n    temp_cell = np.array([30, np.nan, 30])\n    irrad_trans, temp_cell = np.meshgrid(irrad_trans, temp_cell)\n    expected = np.array([[nan,  88.65,  88.65],\n                         [nan,    nan,    nan],\n                         [nan,  88.65,  88.65]])\n    out = pvsystem.pvwatts_dc(irrad_trans, temp_cell, 100, -0.003)\n    assert_allclose(out, expected, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_dc_arrays", "irrad_trans", "np", "array", "np", "nan", "900", "900", "temp_cell", "np", "array", "30", "np", "nan", "30", "irrad_trans", "temp_cell", "np", "meshgrid", "irrad_trans", "temp_cell", "expected", "np", "array", "nan", "88", "65", "88", "65", "nan", "nan", "nan", "nan", "88", "65", "88", "65", "out", "pvsystem", "pvwatts_dc", "irrad_trans", "temp_cell", "100", "0", "003", "assert_allclose", "out", "expected", "equal_nan", "true"], "doc_len": 55}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_dc_series", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_dc_series", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_dc_series():\n    irrad_trans = pd.Series([np.nan, 900, 900])\n    temp_cell = pd.Series([30, np.nan, 30])\n    expected = pd.Series(np.array([   nan,    nan,  88.65]))\n    out = pvsystem.pvwatts_dc(irrad_trans, temp_cell, 100, -0.003)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_dc_series", "irrad_trans", "pd", "series", "np", "nan", "900", "900", "temp_cell", "pd", "series", "30", "np", "nan", "30", "expected", "pd", "series", "np", "array", "nan", "nan", "88", "65", "out", "pvsystem", "pvwatts_dc", "irrad_trans", "temp_cell", "100", "0", "003", "assert_series_equal", "expected", "out"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_losses_default", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_losses_default", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_losses_default():\n    expected = 14.075660688264469\n    out = pvsystem.pvwatts_losses()\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_losses_default", "expected", "14", "075660688264469", "out", "pvsystem", "pvwatts_losses", "assert_allclose", "out", "expected"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_losses_arrays", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_losses_arrays", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_losses_arrays():\n    expected = np.array([nan, 14.934904])\n    age = np.array([nan, 1])\n    out = pvsystem.pvwatts_losses(age=age)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_losses_arrays", "expected", "np", "array", "nan", "14", "934904", "age", "np", "array", "nan", "1", "out", "pvsystem", "pvwatts_losses", "age", "age", "assert_allclose", "out", "expected"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_pvwatts_losses_series", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_pvwatts_losses_series", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_pvwatts_losses_series():\n    expected = pd.Series([nan, 14.934904])\n    age = pd.Series([nan, 1])\n    out = pvsystem.pvwatts_losses(age=age)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvwatts_losses_series", "expected", "pd", "series", "nan", "14", "934904", "age", "pd", "series", "nan", "1", "out", "pvsystem", "pvwatts_losses", "age", "age", "assert_series_equal", "expected", "out"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_pvsystem.py::pvwatts_system_defaults", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "pvwatts_system_defaults", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef pvwatts_system_defaults():\n    module_parameters = {'pdc0': 100, 'gamma_pdc': -0.003}\n    inverter_parameters = {'pdc0': 90}\n    system = pvsystem.PVSystem(module_parameters=module_parameters,\n                               inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "pvwatts_system_defaults", "module_parameters", "pdc0", "100", "gamma_pdc", "0", "003", "inverter_parameters", "pdc0", "90", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 24}
{"doc_id": "pvlib/tests/test_pvsystem.py::pvwatts_system_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "pvwatts_system_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef pvwatts_system_kwargs():\n    module_parameters = {'pdc0': 100, 'gamma_pdc': -0.003, 'temp_ref': 20}\n    inverter_parameters = {'pdc0': 90, 'eta_inv_nom': 0.95, 'eta_inv_ref': 1.0}\n    system = pvsystem.PVSystem(module_parameters=module_parameters,\n                               inverter_parameters=inverter_parameters)\n    return system\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "pvwatts_system_kwargs", "module_parameters", "pdc0", "100", "gamma_pdc", "0", "003", "temp_ref", "20", "inverter_parameters", "pdc0", "90", "eta_inv_nom", "0", "95", "eta_inv_ref", "1", "0", "system", "pvsystem", "pvsystem", "module_parameters", "module_parameters", "inverter_parameters", "inverter_parameters", "return", "system"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvwatts_dc", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvwatts_dc", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvwatts_dc(pvwatts_system_defaults, mocker):\n    mocker.spy(pvsystem, 'pvwatts_dc')\n    irrad = 900\n    temp_cell = 30\n    expected = 90\n    out = pvwatts_system_defaults.pvwatts_dc(irrad, temp_cell)\n    pvsystem.pvwatts_dc.assert_called_once_with(\n        irrad, temp_cell,\n        **pvwatts_system_defaults.arrays[0].module_parameters)\n    assert_allclose(expected, out, atol=10)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvwatts_dc", "pvwatts_system_defaults", "mocker", "mocker", "spy", "pvsystem", "pvwatts_dc", "irrad", "900", "temp_cell", "30", "expected", "90", "out", "pvwatts_system_defaults", "pvwatts_dc", "irrad", "temp_cell", "pvsystem", "pvwatts_dc", "assert_called_once_with", "irrad", "temp_cell", "pvwatts_system_defaults", "arrays", "0", "module_parameters", "assert_allclose", "expected", "out", "atol", "10"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvwatts_dc_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvwatts_dc_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvwatts_dc_kwargs(pvwatts_system_kwargs, mocker):\n    mocker.spy(pvsystem, 'pvwatts_dc')\n    irrad = 900\n    temp_cell = 30\n    expected = 90\n    out = pvwatts_system_kwargs.pvwatts_dc(irrad, temp_cell)\n    pvsystem.pvwatts_dc.assert_called_once_with(\n        irrad, temp_cell, **pvwatts_system_kwargs.arrays[0].module_parameters)\n    assert_allclose(expected, out, atol=10)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvwatts_dc_kwargs", "pvwatts_system_kwargs", "mocker", "mocker", "spy", "pvsystem", "pvwatts_dc", "irrad", "900", "temp_cell", "30", "expected", "90", "out", "pvwatts_system_kwargs", "pvwatts_dc", "irrad", "temp_cell", "pvsystem", "pvwatts_dc", "assert_called_once_with", "irrad", "temp_cell", "pvwatts_system_kwargs", "arrays", "0", "module_parameters", "assert_allclose", "expected", "out", "atol", "10"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multiple_array_pvwatts_dc", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multiple_array_pvwatts_dc", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multiple_array_pvwatts_dc():\n    array_one_module_parameters = {\n        'pdc0': 100, 'gamma_pdc': -0.003, 'temp_ref': 20\n    }\n    array_one = pvsystem.Array(\n        pvsystem.FixedMount(0, 180),\n        module_parameters=array_one_module_parameters\n    )\n    array_two_module_parameters = {\n        'pdc0': 150, 'gamma_pdc': -0.002, 'temp_ref': 25\n    }\n    array_two = pvsystem.Array(\n        pvsystem.FixedMount(0, 180),\n        module_parameters=array_two_module_parameters\n    )\n    system = pvsystem.PVSystem(arrays=[array_one, array_two])\n    irrad_one = 900\n    irrad_two = 500\n    temp_cell_one = 30\n    temp_cell_two = 20\n    expected_one = pvsystem.pvwatts_dc(irrad_one, temp_cell_one,\n                                       **array_one_module_parameters)\n    expected_two = pvsystem.pvwatts_dc(irrad_two, temp_cell_two,\n                                       **array_two_module_parameters)\n    dc_one, dc_two = system.pvwatts_dc((irrad_one, irrad_two),\n                                       (temp_cell_one, temp_cell_two))\n    assert dc_one == expected_one\n    assert dc_two == expected_two\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multiple_array_pvwatts_dc", "array_one_module_parameters", "pdc0", "100", "gamma_pdc", "0", "003", "temp_ref", "20", "array_one", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "array_one_module_parameters", "array_two_module_parameters", "pdc0", "150", "gamma_pdc", "0", "002", "temp_ref", "25", "array_two", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "module_parameters", "array_two_module_parameters", "system", "pvsystem", "pvsystem", "arrays", "array_one", "array_two", "irrad_one", "900", "irrad_two", "500", "temp_cell_one", "30", "temp_cell_two", "20", "expected_one", "pvsystem", "pvwatts_dc", "irrad_one", "temp_cell_one", "array_one_module_parameters", "expected_two", "pvsystem", "pvwatts_dc", "irrad_two", "temp_cell_two", "array_two_module_parameters", "dc_one", "dc_two", "system", "pvwatts_dc", "irrad_one", "irrad_two", "temp_cell_one", "temp_cell_two", "assert", "dc_one", "expected_one", "assert", "dc_two", "expected_two"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_multiple_array_pvwatts_dc_value_error", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_multiple_array_pvwatts_dc_value_error", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_multiple_array_pvwatts_dc_value_error():\n    system = pvsystem.PVSystem(\n        arrays=[pvsystem.Array(pvsystem.FixedMount(0, 180)),\n                pvsystem.Array(pvsystem.FixedMount(0, 180)),\n                pvsystem.Array(pvsystem.FixedMount(0, 180))]\n    )\n    error_message = 'Length mismatch for per-array parameter'\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc(10, (1, 1, 1))\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((10, 10), (1, 1, 1))\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((10, 10, 10, 10), (1, 1, 1))\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((1, 1, 1), 1)\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((1, 1, 1), (1,))\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((1,), 1)\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc((1, 1, 1, 1), (1, 1))\n    with pytest.raises(ValueError, match=error_message):\n        system.pvwatts_dc(2, 3)\n    with pytest.raises(ValueError, match=error_message):\n        # ValueError is raised for non-tuple iterable with correct length\n        system.pvwatts_dc((1, 1, 1), pd.Series([1, 2, 3]))\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_multiple_array_pvwatts_dc_value_error", "system", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "error_message", "length", "mismatch", "for", "per", "array", "parameter", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "10", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "10", "10", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "10", "10", "10", "10", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "1", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "1", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "1", "1", "1", "1", "1", "1", "with", "pytest", "raises", "valueerror", "match", "error_message", "system", "pvwatts_dc", "2", "3", "with", "pytest", "raises", "valueerror", "match", "error_message", "valueerror", "is", "raised", "for", "non", "tuple", "iterable", "with", "correct", "length", "system", "pvwatts_dc", "1", "1", "1", "pd", "series", "1", "2", "3"], "doc_len": 159}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvwatts_losses", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvwatts_losses", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvwatts_losses(pvwatts_system_defaults, mocker):\n    mocker.spy(pvsystem, 'pvwatts_losses')\n    age = 1\n    pvwatts_system_defaults.losses_parameters = dict(age=age)\n    expected = 15\n    out = pvwatts_system_defaults.pvwatts_losses()\n    pvsystem.pvwatts_losses.assert_called_once_with(age=age)\n    assert out < expected\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvwatts_losses", "pvwatts_system_defaults", "mocker", "mocker", "spy", "pvsystem", "pvwatts_losses", "age", "1", "pvwatts_system_defaults", "losses_parameters", "dict", "age", "age", "expected", "15", "out", "pvwatts_system_defaults", "pvwatts_losses", "pvsystem", "pvwatts_losses", "assert_called_once_with", "age", "age", "assert", "out", "expected"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvwatts_ac", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvwatts_ac", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvwatts_ac(pvwatts_system_defaults, mocker):\n    mocker.spy(inverter, 'pvwatts')\n    pdc = 50\n    with pytest.warns(pvlibDeprecationWarning):\n        out = pvwatts_system_defaults.pvwatts_ac(pdc)\n    inverter.pvwatts.assert_called_once_with(\n        pdc, **pvwatts_system_defaults.inverter_parameters)\n    assert out < pdc\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvwatts_ac", "pvwatts_system_defaults", "mocker", "mocker", "spy", "inverter", "pvwatts", "pdc", "50", "with", "pytest", "warns", "pvlibdeprecationwarning", "out", "pvwatts_system_defaults", "pvwatts_ac", "pdc", "inverter", "pvwatts", "assert_called_once_with", "pdc", "pvwatts_system_defaults", "inverter_parameters", "assert", "out", "pdc"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_pvwatts_ac_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_pvwatts_ac_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_pvwatts_ac_kwargs(pvwatts_system_kwargs, mocker):\n    mocker.spy(inverter, 'pvwatts')\n    pdc = 50\n    with pytest.warns(pvlibDeprecationWarning):\n        out = pvwatts_system_kwargs.pvwatts_ac(pdc)\n    inverter.pvwatts.assert_called_once_with(\n        pdc, **pvwatts_system_kwargs.inverter_parameters)\n    assert out < pdc\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_pvwatts_ac_kwargs", "pvwatts_system_kwargs", "mocker", "mocker", "spy", "inverter", "pvwatts", "pdc", "50", "with", "pytest", "warns", "pvlibdeprecationwarning", "out", "pvwatts_system_kwargs", "pvwatts_ac", "pdc", "inverter", "pvwatts", "assert_called_once_with", "pdc", "pvwatts_system_kwargs", "inverter_parameters", "assert", "out", "pdc"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_num_arrays", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_num_arrays", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_num_arrays():\n    system_one = pvsystem.PVSystem()\n    system_two = pvsystem.PVSystem(arrays=[\n        pvsystem.Array(pvsystem.FixedMount(0, 180)),\n        pvsystem.Array(pvsystem.FixedMount(0, 180))])\n    assert system_one.num_arrays == 1\n    assert system_two.num_arrays == 2\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_num_arrays", "system_one", "pvsystem", "pvsystem", "system_two", "pvsystem", "pvsystem", "arrays", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "assert", "system_one", "num_arrays", "1", "assert", "system_two", "num_arrays", "2"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_at_least_one_array", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_at_least_one_array", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_at_least_one_array():\n    with pytest.raises(ValueError,\n                       match=\"PVSystem must have at least one Array\"):\n        pvsystem.PVSystem(arrays=[])\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_at_least_one_array", "with", "pytest", "raises", "valueerror", "match", "pvsystem", "must", "have", "at", "least", "one", "array", "pvsystem", "pvsystem", "arrays"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_combine_loss_factors", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_combine_loss_factors", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_combine_loss_factors():\n    test_index = pd.date_range(start='1990/01/01T12:00', periods=365, freq='D')\n    loss_1 = pd.Series(.10, index=test_index)\n    loss_2 = pd.Series(.05, index=pd.date_range(start='1990/01/01T12:00',\n                                                periods=365*2, freq='D'))\n    loss_3 = pd.Series(.02, index=pd.date_range(start='1990/01/01',\n                                                periods=12, freq='MS'))\n    expected = pd.Series(.1621, index=test_index)\n    out = pvsystem.combine_loss_factors(test_index, loss_1, loss_2, loss_3)\n    assert_series_equal(expected, out)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_combine_loss_factors", "test_index", "pd", "date_range", "start", "1990", "01", "01t12", "00", "periods", "365", "freq", "d", "loss_1", "pd", "series", "10", "index", "test_index", "loss_2", "pd", "series", "05", "index", "pd", "date_range", "start", "1990", "01", "01t12", "00", "periods", "365", "2", "freq", "d", "loss_3", "pd", "series", "02", "index", "pd", "date_range", "start", "1990", "01", "01", "periods", "12", "freq", "ms", "expected", "pd", "series", "1621", "index", "test_index", "out", "pvsystem", "combine_loss_factors", "test_index", "loss_1", "loss_2", "loss_3", "assert_series_equal", "expected", "out"], "doc_len": 72}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_no_extra_kwargs", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_no_extra_kwargs", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_no_extra_kwargs():\n    with pytest.raises(TypeError, match=\"arbitrary_kwarg\"):\n        pvsystem.PVSystem(arbitrary_kwarg='value')\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_no_extra_kwargs", "with", "pytest", "raises", "typeerror", "match", "arbitrary_kwarg", "pvsystem", "pvsystem", "arbitrary_kwarg", "value"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_AbstractMount_constructor", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_AbstractMount_constructor", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_AbstractMount_constructor():\n    match = \"Can't instantiate abstract class AbstractMount\"\n    with pytest.raises(TypeError, match=match):\n        _ = pvsystem.AbstractMount()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_abstractmount_constructor", "match", "can", "t", "instantiate", "abstract", "class", "abstractmount", "with", "pytest", "raises", "typeerror", "match", "match", "_", "pvsystem", "abstractmount"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_pvsystem.py::fixed_mount", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "fixed_mount", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef fixed_mount():\n    return pvsystem.FixedMount(20, 180)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "fixed_mount", "return", "pvsystem", "fixedmount", "20", "180"], "doc_len": 11}
{"doc_id": "pvlib/tests/test_pvsystem.py::single_axis_tracker_mount", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "single_axis_tracker_mount", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef single_axis_tracker_mount():\n    return pvsystem.SingleAxisTrackerMount(axis_tilt=10, axis_azimuth=170,\n                                           max_angle=45, backtrack=False,\n                                           gcr=0.4, cross_axis_tilt=-5)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "single_axis_tracker_mount", "return", "pvsystem", "singleaxistrackermount", "axis_tilt", "10", "axis_azimuth", "170", "max_angle", "45", "backtrack", "false", "gcr", "0", "4", "cross_axis_tilt", "5"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_FixedMount_constructor", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_FixedMount_constructor", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_FixedMount_constructor(fixed_mount):\n    assert fixed_mount.surface_tilt == 20\n    assert fixed_mount.surface_azimuth == 180\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_fixedmount_constructor", "fixed_mount", "assert", "fixed_mount", "surface_tilt", "20", "assert", "fixed_mount", "surface_azimuth", "180"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_FixedMount_get_orientation", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_FixedMount_get_orientation", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_FixedMount_get_orientation(fixed_mount):\n    expected = {'surface_tilt': 20, 'surface_azimuth': 180}\n    assert fixed_mount.get_orientation(45, 130) == expected\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_fixedmount_get_orientation", "fixed_mount", "expected", "surface_tilt", "20", "surface_azimuth", "180", "assert", "fixed_mount", "get_orientation", "45", "130", "expected"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_SingleAxisTrackerMount_constructor", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_SingleAxisTrackerMount_constructor", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_SingleAxisTrackerMount_constructor(single_axis_tracker_mount):\n    expected = dict(axis_tilt=10, axis_azimuth=170, max_angle=45,\n                    backtrack=False, gcr=0.4, cross_axis_tilt=-5)\n    for attr_name, expected_value in expected.items():\n        assert getattr(single_axis_tracker_mount, attr_name) == expected_value\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singleaxistrackermount_constructor", "single_axis_tracker_mount", "expected", "dict", "axis_tilt", "10", "axis_azimuth", "170", "max_angle", "45", "backtrack", "false", "gcr", "0", "4", "cross_axis_tilt", "5", "for", "attr_name", "expected_value", "in", "expected", "items", "assert", "getattr", "single_axis_tracker_mount", "attr_name", "expected_value"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_SingleAxisTrackerMount_get_orientation", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_SingleAxisTrackerMount_get_orientation", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_SingleAxisTrackerMount_get_orientation(single_axis_tracker_mount):\n    expected = {'surface_tilt': 19.29835284, 'surface_azimuth': 229.7643755}\n    actual = single_axis_tracker_mount.get_orientation(45, 190)\n    for key, expected_value in expected.items():\n        err_msg = f\"{key} value incorrect\"\n        assert actual[key] == pytest.approx(expected_value), err_msg\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_singleaxistrackermount_get_orientation", "single_axis_tracker_mount", "expected", "surface_tilt", "19", "29835284", "surface_azimuth", "229", "7643755", "actual", "single_axis_tracker_mount", "get_orientation", "45", "190", "for", "key", "expected_value", "in", "expected", "items", "err_msg", "f", "key", "value", "incorrect", "assert", "actual", "key", "pytest", "approx", "expected_value", "err_msg"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_dc_ohms_from_percent", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_dc_ohms_from_percent", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_dc_ohms_from_percent():\n    expected = .1425\n    out = pvsystem.dc_ohms_from_percent(38, 8, 3, 1, 1)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_dc_ohms_from_percent", "expected", "1425", "out", "pvsystem", "dc_ohms_from_percent", "38", "8", "3", "1", "1", "assert_allclose", "out", "expected"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_dc_ohms_from_percent", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_dc_ohms_from_percent", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_dc_ohms_from_percent(mocker):\n    mocker.spy(pvsystem, 'dc_ohms_from_percent')\n\n    expected = .1425\n    system = pvsystem.PVSystem(losses_parameters={'dc_ohmic_percent': 3},\n                               module_parameters={'I_mp_ref': 8,\n                                                  'V_mp_ref': 38})\n    out = system.dc_ohms_from_percent()\n\n    pvsystem.dc_ohms_from_percent.assert_called_once_with(\n        dc_ohmic_percent=3,\n        vmp_ref=38,\n        imp_ref=8,\n        modules_per_string=1,\n        strings=1\n    )\n\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_dc_ohms_from_percent", "mocker", "mocker", "spy", "pvsystem", "dc_ohms_from_percent", "expected", "1425", "system", "pvsystem", "pvsystem", "losses_parameters", "dc_ohmic_percent", "3", "module_parameters", "i_mp_ref", "8", "v_mp_ref", "38", "out", "system", "dc_ohms_from_percent", "pvsystem", "dc_ohms_from_percent", "assert_called_once_with", "dc_ohmic_percent", "3", "vmp_ref", "38", "imp_ref", "8", "modules_per_string", "1", "strings", "1", "assert_allclose", "out", "expected"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_dc_ohmic_losses", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_dc_ohmic_losses", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_dc_ohmic_losses():\n    expected = 9.12\n    out = pvsystem.dc_ohmic_losses(.1425, 8)\n    assert_allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_dc_ohmic_losses", "expected", "9", "12", "out", "pvsystem", "dc_ohmic_losses", "1425", "8", "assert_allclose", "out", "expected"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array_dc_ohms_from_percent", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array_dc_ohms_from_percent", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array_dc_ohms_from_percent(mocker):\n    mocker.spy(pvsystem, 'dc_ohms_from_percent')\n\n    expected = .1425\n\n    array = pvsystem.Array(pvsystem.FixedMount(0, 180),\n                           array_losses_parameters={'dc_ohmic_percent': 3},\n                           module_parameters={'I_mp_ref': 8,\n                                              'V_mp_ref': 38})\n    out = array.dc_ohms_from_percent()\n    pvsystem.dc_ohms_from_percent.assert_called_with(\n        dc_ohmic_percent=3,\n        vmp_ref=38,\n        imp_ref=8,\n        modules_per_string=1,\n        strings=1\n    )\n    assert_allclose(out, expected)\n\n    array = pvsystem.Array(pvsystem.FixedMount(0, 180),\n                           array_losses_parameters={'dc_ohmic_percent': 3},\n                           module_parameters={'Impo': 8,\n                                              'Vmpo': 38})\n    out = array.dc_ohms_from_percent()\n    pvsystem.dc_ohms_from_percent.assert_called_with(\n        dc_ohmic_percent=3,\n        vmp_ref=38,\n        imp_ref=8,\n        modules_per_string=1,\n        strings=1\n    )\n    assert_allclose(out, expected)\n\n    array = pvsystem.Array(pvsystem.FixedMount(0, 180),\n                           array_losses_parameters={'dc_ohmic_percent': 3},\n                           module_parameters={'Impp': 8,\n                                              'Vmpp': 38})\n    out = array.dc_ohms_from_percent()\n\n    pvsystem.dc_ohms_from_percent.assert_called_with(\n        dc_ohmic_percent=3,\n        vmp_ref=38,\n        imp_ref=8,\n        modules_per_string=1,\n        strings=1\n    )\n    assert_allclose(out, expected)\n\n    with pytest.raises(ValueError,\n                       match=('Parameters for Vmp and Imp could not be found '\n                              'in the array module parameters. Module '\n                              'parameters must include one set of '\n                              '{\"V_mp_ref\", \"I_mp_Ref\"}, '\n                              '{\"Vmpo\", \"Impo\"}, or '\n                              '{\"Vmpp\", \"Impp\"}.')):\n        array = pvsystem.Array(pvsystem.FixedMount(0, 180),\n                               array_losses_parameters={'dc_ohmic_percent': 3})\n        out = array.dc_ohms_from_percent()\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array_dc_ohms_from_percent", "mocker", "mocker", "spy", "pvsystem", "dc_ohms_from_percent", "expected", "1425", "array", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "array_losses_parameters", "dc_ohmic_percent", "3", "module_parameters", "i_mp_ref", "8", "v_mp_ref", "38", "out", "array", "dc_ohms_from_percent", "pvsystem", "dc_ohms_from_percent", "assert_called_with", "dc_ohmic_percent", "3", "vmp_ref", "38", "imp_ref", "8", "modules_per_string", "1", "strings", "1", "assert_allclose", "out", "expected", "array", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "array_losses_parameters", "dc_ohmic_percent", "3", "module_parameters", "impo", "8", "vmpo", "38", "out", "array", "dc_ohms_from_percent", "pvsystem", "dc_ohms_from_percent", "assert_called_with", "dc_ohmic_percent", "3", "vmp_ref", "38", "imp_ref", "8", "modules_per_string", "1", "strings", "1", "assert_allclose", "out", "expected", "array", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "array_losses_parameters", "dc_ohmic_percent", "3", "module_parameters", "impp", "8", "vmpp", "38", "out", "array", "dc_ohms_from_percent", "pvsystem", "dc_ohms_from_percent", "assert_called_with", "dc_ohmic_percent", "3", "vmp_ref", "38", "imp_ref", "8", "modules_per_string", "1", "strings", "1", "assert_allclose", "out", "expected", "with", "pytest", "raises", "valueerror", "match", "parameters", "for", "vmp", "and", "imp", "could", "not", "be", "found", "in", "the", "array", "module", "parameters", "module", "parameters", "must", "include", "one", "set", "of", "v_mp_ref", "i_mp_ref", "vmpo", "impo", "or", "vmpp", "impp", "array", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "array_losses_parameters", "dc_ohmic_percent", "3", "out", "array", "dc_ohms_from_percent"], "doc_len": 161}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_PVSystem_temperature_deprecated", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_PVSystem_temperature_deprecated", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_PVSystem_temperature_deprecated(funcname):\n    temp_model_params = {\n        'a': -3.47, 'b': -0.0594, 'deltaT': 3,  # sapm\n        'noct_installed': 45,  # fuentes\n        'module_efficiency': 0.2, 'noct': 45,  # noct_sam\n    }\n    system = pvsystem.PVSystem(temperature_model_parameters=temp_model_params)\n    func = getattr(system, funcname)\n    index = pd.date_range('2019-01-01', freq='h', periods=5)\n    temps = pd.Series(25, index)\n    irrads = pd.Series(1000, index)\n    winds = pd.Series(1, index)\n\n    with pytest.warns(pvlibDeprecationWarning):\n        func(irrads, temps, winds)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_pvsystem_temperature_deprecated", "funcname", "temp_model_params", "a", "3", "47", "b", "0", "0594", "deltat", "3", "sapm", "noct_installed", "45", "fuentes", "module_efficiency", "0", "2", "noct", "45", "noct_sam", "system", "pvsystem", "pvsystem", "temperature_model_parameters", "temp_model_params", "func", "getattr", "system", "funcname", "index", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "5", "temps", "pd", "series", "25", "index", "irrads", "pd", "series", "1000", "index", "winds", "pd", "series", "1", "index", "with", "pytest", "warns", "pvlibdeprecationwarning", "func", "irrads", "temps", "winds"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_pvsystem.py::test_Array_temperature_missing_parameters", "file_path": "pvlib/tests/test_pvsystem.py", "class_name": null, "func_name": "test_Array_temperature_missing_parameters", "text": "文件路径: pvlib/tests/test_pvsystem.py\ndef test_Array_temperature_missing_parameters(model, keys):\n    # test that a nice error is raised when required temp params are missing\n    array = pvsystem.Array(pvsystem.FixedMount(0, 180))\n    index = pd.date_range('2019-01-01', freq='h', periods=5)\n    temps = pd.Series(25, index)\n    irrads = pd.Series(1000, index)\n    winds = pd.Series(1, index)\n\n    for key in keys:\n        match = f\"Missing required parameter '{key}'\"\n        params = {k: 1 for k in keys}  # dummy values\n        params.pop(key)  # remove each key in turn\n        array.temperature_model_parameters = params\n        with pytest.raises(KeyError, match=match):\n            array.get_cell_temperature(irrads, temps, winds, model)\n", "tokens": ["pvlib", "tests", "test_pvsystem", "py", "def", "test_array_temperature_missing_parameters", "model", "keys", "test", "that", "a", "nice", "error", "is", "raised", "when", "required", "temp", "params", "are", "missing", "array", "pvsystem", "array", "pvsystem", "fixedmount", "0", "180", "index", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "5", "temps", "pd", "series", "25", "index", "irrads", "pd", "series", "1000", "index", "winds", "pd", "series", "1", "index", "for", "key", "in", "keys", "match", "f", "missing", "required", "parameter", "key", "params", "k", "1", "for", "k", "in", "keys", "dummy", "values", "params", "pop", "key", "remove", "each", "key", "in", "turn", "array", "temperature_model_parameters", "params", "with", "pytest", "raises", "keyerror", "match", "match", "array", "get_cell_temperature", "irrads", "temps", "winds", "model"], "doc_len": 95}
{"doc_id": "pvlib/tests/test_scaling.py::coordinates", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "coordinates", "text": "文件路径: pvlib/tests/test_scaling.py\ndef coordinates():\n    # Sample positions in lat/lon\n    lat = np.array((9.99, 10, 10.01))\n    lon = np.array((4.99, 5, 5.01))\n    coordinates = np.array([(lati, loni) for (lati, loni) in zip(lat, lon)])\n    return coordinates\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "coordinates", "sample", "positions", "in", "lat", "lon", "lat", "np", "array", "9", "99", "10", "10", "01", "lon", "np", "array", "4", "99", "5", "5", "01", "coordinates", "np", "array", "lati", "loni", "for", "lati", "loni", "in", "zip", "lat", "lon", "return", "coordinates"], "doc_len": 41}
{"doc_id": "pvlib/tests/test_scaling.py::clear_sky_index", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "clear_sky_index", "text": "文件路径: pvlib/tests/test_scaling.py\ndef clear_sky_index():\n    # Generate a sample clear_sky_index\n    clear_sky_index = np.ones(10000)\n    clear_sky_index[5000:5005] = np.array([1, 1, 1.1, 0.9, 1])\n    return clear_sky_index\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "clear_sky_index", "generate", "a", "sample", "clear_sky_index", "clear_sky_index", "np", "ones", "10000", "clear_sky_index", "5000", "5005", "np", "array", "1", "1", "1", "1", "0", "9", "1", "return", "clear_sky_index"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_scaling.py::time", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "time", "text": "文件路径: pvlib/tests/test_scaling.py\ndef time(clear_sky_index):\n    # Sample time vector\n    return np.arange(0, len(clear_sky_index))\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "time", "clear_sky_index", "sample", "time", "vector", "return", "np", "arange", "0", "len", "clear_sky_index"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_scaling.py::time_60s", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "time_60s", "text": "文件路径: pvlib/tests/test_scaling.py\ndef time_60s(clear_sky_index):\n    # Sample time vector 60s resolution\n    return np.arange(0, len(clear_sky_index))*60\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "time_60s", "clear_sky_index", "sample", "time", "vector", "60s", "resolution", "return", "np", "arange", "0", "len", "clear_sky_index", "60"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_scaling.py::time_500ms", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "time_500ms", "text": "文件路径: pvlib/tests/test_scaling.py\ndef time_500ms(clear_sky_index):\n    # Sample time vector 0.5s resolution\n    return np.arange(0, len(clear_sky_index))*0.5\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "time_500ms", "clear_sky_index", "sample", "time", "vector", "0", "5s", "resolution", "return", "np", "arange", "0", "len", "clear_sky_index", "0", "5"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_scaling.py::positions", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "positions", "text": "文件路径: pvlib/tests/test_scaling.py\ndef positions():\n    # Sample positions based on the previous lat/lon (calculated manually)\n    expect_xpos = np.array([554863.4, 555975.4, 557087.3])\n    expect_ypos = np.array([1110838.8, 1111950.8, 1113062.7])\n    return np.array([pt for pt in zip(expect_xpos, expect_ypos)])\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "positions", "sample", "positions", "based", "on", "the", "previous", "lat", "lon", "calculated", "manually", "expect_xpos", "np", "array", "554863", "4", "555975", "4", "557087", "3", "expect_ypos", "np", "array", "1110838", "8", "1111950", "8", "1113062", "7", "return", "np", "array", "pt", "for", "pt", "in", "zip", "expect_xpos", "expect_ypos"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_scaling.py::expect_tmscale", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_tmscale", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_tmscale():\n    # Expected timescales for dt = 1\n    return [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_tmscale", "expected", "timescales", "for", "dt", "1", "return", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024", "2048", "4096"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_scaling.py::expect_tmscale_1min", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_tmscale_1min", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_tmscale_1min():\n    # Expected timescales for dt = 60\n    return [60, 120, 240, 480, 960, 1920, 3840]\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_tmscale_1min", "expected", "timescales", "for", "dt", "60", "return", "60", "120", "240", "480", "960", "1920", "3840"], "doc_len": 19}
{"doc_id": "pvlib/tests/test_scaling.py::expect_tmscale_500ms", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_tmscale_500ms", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_tmscale_500ms():\n    # Expected timescales for dt = 0.5\n    return [0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_tmscale_500ms", "expected", "timescales", "for", "dt", "0", "5", "return", "0", "5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024", "2048", "4096"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_scaling.py::expect_wavelet", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_wavelet", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_wavelet():\n    # Expected wavelet for indices 5000:5004 for clear_sky_index above (Matlab)\n    e = np.zeros([13, 5])\n    e[0, :] = np.array([0, -0.05, 0.1, -0.05, 0])\n    e[1, :] = np.array([-0.025, 0.05, 0., -0.05, 0.025])\n    e[2, :] = np.array([0.025, 0., 0., 0., -0.025])\n    e[-1, :] = np.array([1, 1, 1, 1, 1])\n    return e\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_wavelet", "expected", "wavelet", "for", "indices", "5000", "5004", "for", "clear_sky_index", "above", "matlab", "e", "np", "zeros", "13", "5", "e", "0", "np", "array", "0", "0", "05", "0", "1", "0", "05", "0", "e", "1", "np", "array", "0", "025", "0", "05", "0", "0", "05", "0", "025", "e", "2", "np", "array", "0", "025", "0", "0", "0", "0", "025", "e", "1", "np", "array", "1", "1", "1", "1", "1", "return", "e"], "doc_len": 68}
{"doc_id": "pvlib/tests/test_scaling.py::expect_cs_smooth", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_cs_smooth", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_cs_smooth():\n    # Expected smoothed clear sky index for indices 5000:5004 (Matlab)\n    return np.array([1., 1., 1.05774, 0.94226, 1.])\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_cs_smooth", "expected", "smoothed", "clear", "sky", "index", "for", "indices", "5000", "5004", "matlab", "return", "np", "array", "1", "1", "1", "05774", "0", "94226", "1"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_scaling.py::expect_vr", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "expect_vr", "text": "文件路径: pvlib/tests/test_scaling.py\ndef expect_vr():\n    # Expected VR for expecttmscale\n    return np.array([3., 3., 3., 3., 3., 3., 2.9997844, 2.9708118, 2.6806291,\n                     2.0726611, 1.5653324, 1.2812714, 1.1389995])\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "expect_vr", "expected", "vr", "for", "expecttmscale", "return", "np", "array", "3", "3", "3", "3", "3", "3", "2", "9997844", "2", "9708118", "2", "6806291", "2", "0726611", "1", "5653324", "1", "2812714", "1", "1389995"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_scaling.py::test_latlon_to_xy_zero", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_latlon_to_xy_zero", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_latlon_to_xy_zero():\n    coord = [0, 0]\n    pos_e = [0, 0]\n    pos = scaling.latlon_to_xy(coord)\n    assert_almost_equal(pos, pos_e, decimal=1)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_latlon_to_xy_zero", "coord", "0", "0", "pos_e", "0", "0", "pos", "scaling", "latlon_to_xy", "coord", "assert_almost_equal", "pos", "pos_e", "decimal", "1"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_scaling.py::test_latlon_to_xy_single", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_latlon_to_xy_single", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_latlon_to_xy_single(coordinates, positions):\n    # Must test against central value, because latlon_to_xy uses the mean\n    coord = coordinates[1]\n    pos = scaling.latlon_to_xy(coord)\n    assert_almost_equal(pos, positions[1], decimal=1)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_latlon_to_xy_single", "coordinates", "positions", "must", "test", "against", "central", "value", "because", "latlon_to_xy", "uses", "the", "mean", "coord", "coordinates", "1", "pos", "scaling", "latlon_to_xy", "coord", "assert_almost_equal", "pos", "positions", "1", "decimal", "1"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_scaling.py::test_latlon_to_xy_array", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_latlon_to_xy_array", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_latlon_to_xy_array(coordinates, positions):\n    pos = scaling.latlon_to_xy(coordinates)\n    assert_almost_equal(pos, positions, decimal=1)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_latlon_to_xy_array", "coordinates", "positions", "pos", "scaling", "latlon_to_xy", "coordinates", "assert_almost_equal", "pos", "positions", "decimal", "1"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_scaling.py::test_latlon_to_xy_list", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_latlon_to_xy_list", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_latlon_to_xy_list(coordinates, positions):\n    pos = scaling.latlon_to_xy(coordinates.tolist())\n    assert_almost_equal(pos, positions, decimal=1)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_latlon_to_xy_list", "coordinates", "positions", "pos", "scaling", "latlon_to_xy", "coordinates", "tolist", "assert_almost_equal", "pos", "positions", "decimal", "1"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_series", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_series", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_series(clear_sky_index, time,\n                                expect_tmscale, expect_wavelet):\n    csi_series = pd.Series(clear_sky_index, index=time)\n    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n    assert_almost_equal(tmscale, expect_tmscale)\n    assert_almost_equal(wavelet[:, 5000:5005], expect_wavelet)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_series", "clear_sky_index", "time", "expect_tmscale", "expect_wavelet", "csi_series", "pd", "series", "clear_sky_index", "index", "time", "wavelet", "tmscale", "scaling", "_compute_wavelet", "csi_series", "assert_almost_equal", "tmscale", "expect_tmscale", "assert_almost_equal", "wavelet", "5000", "5005", "expect_wavelet"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_series_numindex", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_series_numindex", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_series_numindex(clear_sky_index, time,\n                                         expect_tmscale, expect_wavelet):\n    dtindex = pd.to_datetime(time, unit='s')\n    csi_series = pd.Series(clear_sky_index, index=dtindex)\n    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n    assert_almost_equal(tmscale, expect_tmscale)\n    assert_almost_equal(wavelet[:, 5000:5005], expect_wavelet)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_series_numindex", "clear_sky_index", "time", "expect_tmscale", "expect_wavelet", "dtindex", "pd", "to_datetime", "time", "unit", "s", "csi_series", "pd", "series", "clear_sky_index", "index", "dtindex", "wavelet", "tmscale", "scaling", "_compute_wavelet", "csi_series", "assert_almost_equal", "tmscale", "expect_tmscale", "assert_almost_equal", "wavelet", "5000", "5005", "expect_wavelet"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_series_highres", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_series_highres", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_series_highres(clear_sky_index, time_500ms,\n                                        expect_tmscale_500ms, expect_wavelet):\n    dtindex = pd.to_datetime(time_500ms, unit='s')\n    csi_series = pd.Series(clear_sky_index, index=dtindex)\n    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n    assert_almost_equal(tmscale, expect_tmscale_500ms)\n    assert_almost_equal(wavelet[:, 5000:5005].shape, (14, 5))\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_series_highres", "clear_sky_index", "time_500ms", "expect_tmscale_500ms", "expect_wavelet", "dtindex", "pd", "to_datetime", "time_500ms", "unit", "s", "csi_series", "pd", "series", "clear_sky_index", "index", "dtindex", "wavelet", "tmscale", "scaling", "_compute_wavelet", "csi_series", "assert_almost_equal", "tmscale", "expect_tmscale_500ms", "assert_almost_equal", "wavelet", "5000", "5005", "shape", "14", "5"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_series_minuteres", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_series_minuteres", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_series_minuteres(clear_sky_index, time_60s,\n                                          expect_tmscale_1min, expect_wavelet):\n    dtindex = pd.to_datetime(time_60s, unit='s')\n    csi_series = pd.Series(clear_sky_index, index=dtindex)\n    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n    assert_almost_equal(tmscale, expect_tmscale_1min)\n    assert_almost_equal(wavelet[:, 5000:5005].shape,\n                        expect_wavelet[0:len(tmscale), :].shape)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_series_minuteres", "clear_sky_index", "time_60s", "expect_tmscale_1min", "expect_wavelet", "dtindex", "pd", "to_datetime", "time_60s", "unit", "s", "csi_series", "pd", "series", "clear_sky_index", "index", "dtindex", "wavelet", "tmscale", "scaling", "_compute_wavelet", "csi_series", "assert_almost_equal", "tmscale", "expect_tmscale_1min", "assert_almost_equal", "wavelet", "5000", "5005", "shape", "expect_wavelet", "0", "len", "tmscale", "shape"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_array", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_array", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_array(clear_sky_index,\n                               expect_tmscale, expect_wavelet):\n    wavelet, tmscale = scaling._compute_wavelet(clear_sky_index, dt)\n    assert_almost_equal(tmscale, expect_tmscale)\n    assert_almost_equal(wavelet[:, 5000:5005], expect_wavelet)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_array", "clear_sky_index", "expect_tmscale", "expect_wavelet", "wavelet", "tmscale", "scaling", "_compute_wavelet", "clear_sky_index", "dt", "assert_almost_equal", "tmscale", "expect_tmscale", "assert_almost_equal", "wavelet", "5000", "5005", "expect_wavelet"], "doc_len": 23}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_array_invalid", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_array_invalid", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_array_invalid(clear_sky_index):\n    with pytest.raises(ValueError):\n        scaling._compute_wavelet(clear_sky_index)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_array_invalid", "clear_sky_index", "with", "pytest", "raises", "valueerror", "scaling", "_compute_wavelet", "clear_sky_index"], "doc_len": 14}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_wavelet_dwttheory", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_wavelet_dwttheory", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_wavelet_dwttheory(clear_sky_index, time,\n                                   expect_tmscale, expect_wavelet):\n    # Confirm detail coeffs sum to original signal\n    csi_series = pd.Series(clear_sky_index, index=time)\n    wavelet, tmscale = scaling._compute_wavelet(csi_series)\n    assert_almost_equal(np.sum(wavelet, 0), csi_series)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_wavelet_dwttheory", "clear_sky_index", "time", "expect_tmscale", "expect_wavelet", "confirm", "detail", "coeffs", "sum", "to", "original", "signal", "csi_series", "pd", "series", "clear_sky_index", "index", "time", "wavelet", "tmscale", "scaling", "_compute_wavelet", "csi_series", "assert_almost_equal", "np", "sum", "wavelet", "0", "csi_series"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_scaling.py::test_compute_vr", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_compute_vr", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_compute_vr(positions, expect_tmscale, expect_vr):\n    vr = scaling._compute_vr(positions, cloud_speed, np.array(expect_tmscale))\n    assert_almost_equal(vr, expect_vr)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_compute_vr", "positions", "expect_tmscale", "expect_vr", "vr", "scaling", "_compute_vr", "positions", "cloud_speed", "np", "array", "expect_tmscale", "assert_almost_equal", "vr", "expect_vr"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_scaling.py::test_wvm_series", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_wvm_series", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_wvm_series(clear_sky_index, time, positions, expect_cs_smooth):\n    csi_series = pd.Series(clear_sky_index, index=time)\n    cs_sm, _, _ = scaling.wvm(csi_series, positions, cloud_speed)\n    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_wvm_series", "clear_sky_index", "time", "positions", "expect_cs_smooth", "csi_series", "pd", "series", "clear_sky_index", "index", "time", "cs_sm", "_", "_", "scaling", "wvm", "csi_series", "positions", "cloud_speed", "assert_almost_equal", "cs_sm", "5000", "5005", "expect_cs_smooth", "decimal", "4"], "doc_len": 31}
{"doc_id": "pvlib/tests/test_scaling.py::test_wvm_array", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_wvm_array", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_wvm_array(clear_sky_index, positions, expect_cs_smooth):\n    cs_sm, _, _ = scaling.wvm(clear_sky_index, positions, cloud_speed, dt=dt)\n    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_wvm_array", "clear_sky_index", "positions", "expect_cs_smooth", "cs_sm", "_", "_", "scaling", "wvm", "clear_sky_index", "positions", "cloud_speed", "dt", "dt", "assert_almost_equal", "cs_sm", "5000", "5005", "expect_cs_smooth", "decimal", "4"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_scaling.py::test_wvm_series_xyaslist", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_wvm_series_xyaslist", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_wvm_series_xyaslist(clear_sky_index, time, positions,\n                             expect_cs_smooth):\n    csi_series = pd.Series(clear_sky_index, index=time)\n    cs_sm, _, _ = scaling.wvm(csi_series, positions.tolist(), cloud_speed)\n    assert_almost_equal(cs_sm[5000:5005], expect_cs_smooth, decimal=4)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_wvm_series_xyaslist", "clear_sky_index", "time", "positions", "expect_cs_smooth", "csi_series", "pd", "series", "clear_sky_index", "index", "time", "cs_sm", "_", "_", "scaling", "wvm", "csi_series", "positions", "tolist", "cloud_speed", "assert_almost_equal", "cs_sm", "5000", "5005", "expect_cs_smooth", "decimal", "4"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_scaling.py::test_wvm_invalid", "file_path": "pvlib/tests/test_scaling.py", "class_name": null, "func_name": "test_wvm_invalid", "text": "文件路径: pvlib/tests/test_scaling.py\ndef test_wvm_invalid(clear_sky_index, positions):\n    with pytest.raises(ValueError):\n        scaling.wvm(clear_sky_index, positions, cloud_speed)\n", "tokens": ["pvlib", "tests", "test_scaling", "py", "def", "test_wvm_invalid", "clear_sky_index", "positions", "with", "pytest", "raises", "valueerror", "scaling", "wvm", "clear_sky_index", "positions", "cloud_speed"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_shading.py::surface_tilt", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "surface_tilt", "text": "文件路径: pvlib/tests/test_shading.py\ndef surface_tilt():\n    idx = pd.date_range('2019-01-01', freq='h', periods=3)\n    return pd.Series([0, 20, 90], index=idx)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "surface_tilt", "idx", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "3", "return", "pd", "series", "0", "20", "90", "index", "idx"], "doc_len": 24}
{"doc_id": "pvlib/tests/test_shading.py::masking_angle", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "masking_angle", "text": "文件路径: pvlib/tests/test_shading.py\ndef masking_angle(surface_tilt):\n    # masking angles for the surface_tilt fixture,\n    # assuming GCR=0.5 and height=0.25\n    return pd.Series([0.0, 11.20223712, 20.55604522], index=surface_tilt.index)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "masking_angle", "surface_tilt", "masking", "angles", "for", "the", "surface_tilt", "fixture", "assuming", "gcr", "0", "5", "and", "height", "0", "25", "return", "pd", "series", "0", "0", "11", "20223712", "20", "55604522", "index", "surface_tilt", "index"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_shading.py::average_masking_angle", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "average_masking_angle", "text": "文件路径: pvlib/tests/test_shading.py\ndef average_masking_angle(surface_tilt):\n    # average masking angles for the surface_tilt fixture, assuming GCR=0.5\n    return pd.Series([0.0, 7.20980655, 13.779867461], index=surface_tilt.index)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "average_masking_angle", "surface_tilt", "average", "masking", "angles", "for", "the", "surface_tilt", "fixture", "assuming", "gcr", "0", "5", "return", "pd", "series", "0", "0", "7", "20980655", "13", "779867461", "index", "surface_tilt", "index"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_shading.py::shading_loss", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "shading_loss", "text": "文件路径: pvlib/tests/test_shading.py\ndef shading_loss(surface_tilt):\n    # diffuse shading loss values for the average_masking_angle fixture\n    return pd.Series([0, 0.00395338, 0.01439098], index=surface_tilt.index)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "shading_loss", "surface_tilt", "diffuse", "shading", "loss", "values", "for", "the", "average_masking_angle", "fixture", "return", "pd", "series", "0", "0", "00395338", "0", "01439098", "index", "surface_tilt", "index"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_shading.py::test_masking_angle_series", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_masking_angle_series", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_masking_angle_series(surface_tilt, masking_angle):\n    # series inputs and outputs\n    masking_angle_actual = shading.masking_angle(surface_tilt, 0.5, 0.25)\n    assert_series_equal(masking_angle_actual, masking_angle)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_masking_angle_series", "surface_tilt", "masking_angle", "series", "inputs", "and", "outputs", "masking_angle_actual", "shading", "masking_angle", "surface_tilt", "0", "5", "0", "25", "assert_series_equal", "masking_angle_actual", "masking_angle"], "doc_len": 23}
{"doc_id": "pvlib/tests/test_shading.py::test_masking_angle_scalar", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_masking_angle_scalar", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_masking_angle_scalar(surface_tilt, masking_angle):\n    # scalar inputs and outputs, including zero\n    for tilt, angle in zip(surface_tilt, masking_angle):\n        masking_angle_actual = shading.masking_angle(tilt, 0.5, 0.25)\n        assert np.isclose(masking_angle_actual, angle)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_masking_angle_scalar", "surface_tilt", "masking_angle", "scalar", "inputs", "and", "outputs", "including", "zero", "for", "tilt", "angle", "in", "zip", "surface_tilt", "masking_angle", "masking_angle_actual", "shading", "masking_angle", "tilt", "0", "5", "0", "25", "assert", "np", "isclose", "masking_angle_actual", "angle"], "doc_len": 34}
{"doc_id": "pvlib/tests/test_shading.py::test_masking_angle_zero_gcr", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_masking_angle_zero_gcr", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_masking_angle_zero_gcr(surface_tilt):\n    # scalar inputs and outputs, including zero\n    for tilt in surface_tilt:\n        masking_angle_actual = shading.masking_angle(tilt, 0, 0.25)\n        assert np.isclose(masking_angle_actual, 0)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_masking_angle_zero_gcr", "surface_tilt", "scalar", "inputs", "and", "outputs", "including", "zero", "for", "tilt", "in", "surface_tilt", "masking_angle_actual", "shading", "masking_angle", "tilt", "0", "0", "25", "assert", "np", "isclose", "masking_angle_actual", "0"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_shading.py::test_masking_angle_passias_series", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_masking_angle_passias_series", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_masking_angle_passias_series(surface_tilt, average_masking_angle):\n    # pandas series inputs and outputs\n    masking_angle_actual = shading.masking_angle_passias(surface_tilt, 0.5)\n    assert_series_equal(masking_angle_actual, average_masking_angle)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_masking_angle_passias_series", "surface_tilt", "average_masking_angle", "pandas", "series", "inputs", "and", "outputs", "masking_angle_actual", "shading", "masking_angle_passias", "surface_tilt", "0", "5", "assert_series_equal", "masking_angle_actual", "average_masking_angle"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_shading.py::test_masking_angle_passias_scalar", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_masking_angle_passias_scalar", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_masking_angle_passias_scalar(surface_tilt, average_masking_angle):\n    # scalar inputs and outputs, including zero\n    for tilt, angle in zip(surface_tilt, average_masking_angle):\n        masking_angle_actual = shading.masking_angle_passias(tilt, 0.5)\n        assert np.isclose(masking_angle_actual, angle)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_masking_angle_passias_scalar", "surface_tilt", "average_masking_angle", "scalar", "inputs", "and", "outputs", "including", "zero", "for", "tilt", "angle", "in", "zip", "surface_tilt", "average_masking_angle", "masking_angle_actual", "shading", "masking_angle_passias", "tilt", "0", "5", "assert", "np", "isclose", "masking_angle_actual", "angle"], "doc_len": 32}
{"doc_id": "pvlib/tests/test_shading.py::test_sky_diffuse_passias_series", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_sky_diffuse_passias_series", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_sky_diffuse_passias_series(average_masking_angle, shading_loss):\n    # pandas series inputs and outputs\n    actual_loss = shading.sky_diffuse_passias(average_masking_angle)\n    assert_series_equal(shading_loss, actual_loss)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_sky_diffuse_passias_series", "average_masking_angle", "shading_loss", "pandas", "series", "inputs", "and", "outputs", "actual_loss", "shading", "sky_diffuse_passias", "average_masking_angle", "assert_series_equal", "shading_loss", "actual_loss"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_shading.py::test_sky_diffuse_passias_scalar", "file_path": "pvlib/tests/test_shading.py", "class_name": null, "func_name": "test_sky_diffuse_passias_scalar", "text": "文件路径: pvlib/tests/test_shading.py\ndef test_sky_diffuse_passias_scalar(average_masking_angle, shading_loss):\n    # scalar inputs and outputs\n    for angle, loss in zip(average_masking_angle, shading_loss):\n        actual_loss = shading.sky_diffuse_passias(angle)\n        assert np.isclose(loss, actual_loss)\n", "tokens": ["pvlib", "tests", "test_shading", "py", "def", "test_sky_diffuse_passias_scalar", "average_masking_angle", "shading_loss", "scalar", "inputs", "and", "outputs", "for", "angle", "loss", "in", "zip", "average_masking_angle", "shading_loss", "actual_loss", "shading", "sky_diffuse_passias", "angle", "assert", "np", "isclose", "loss", "actual_loss"], "doc_len": 28}
{"doc_id": "pvlib/tests/test_singlediode.py::test_method_spr_e20_327", "file_path": "pvlib/tests/test_singlediode.py", "class_name": null, "func_name": "test_method_spr_e20_327", "text": "文件路径: pvlib/tests/test_singlediode.py\ndef test_method_spr_e20_327(method, cec_module_spr_e20_327):\n    \"\"\"test pvsystem.singlediode with different methods on SPR-E20-327\"\"\"\n    spr_e20_327 = cec_module_spr_e20_327\n    x = pvsystem.calcparams_desoto(\n        effective_irradiance=POA, temp_cell=TCELL,\n        alpha_sc=spr_e20_327['alpha_sc'], a_ref=spr_e20_327['a_ref'],\n        I_L_ref=spr_e20_327['I_L_ref'], I_o_ref=spr_e20_327['I_o_ref'],\n        R_sh_ref=spr_e20_327['R_sh_ref'], R_s=spr_e20_327['R_s'],\n        EgRef=1.121, dEgdT=-0.0002677)\n    il, io, rs, rsh, nnsvt = x\n    pvs = pvsystem.singlediode(*x, method='lambertw')\n    out = pvsystem.singlediode(*x, method=method)\n    isc, voc, imp, vmp, pmp, ix, ixx = out.values()\n    assert np.isclose(pvs['i_sc'], isc)\n    assert np.isclose(pvs['v_oc'], voc)\n    # the singlediode method doesn't actually get the MPP correct\n    pvs_imp = pvsystem.i_from_v(rsh, rs, nnsvt, vmp, io, il, method='lambertw')\n    pvs_vmp = pvsystem.v_from_i(rsh, rs, nnsvt, imp, io, il, method='lambertw')\n    assert np.isclose(pvs_imp, imp)\n    assert np.isclose(pvs_vmp, vmp)\n    assert np.isclose(pvs['p_mp'], pmp)\n    assert np.isclose(pvs['i_x'], ix)\n    pvs_ixx = pvsystem.i_from_v(rsh, rs, nnsvt, (voc + vmp)/2, io, il,\n                                method='lambertw')\n    assert np.isclose(pvs_ixx, ixx)\n", "tokens": ["pvlib", "tests", "test_singlediode", "py", "def", "test_method_spr_e20_327", "method", "cec_module_spr_e20_327", "test", "pvsystem", "singlediode", "with", "different", "methods", "on", "spr", "e20", "327", "spr_e20_327", "cec_module_spr_e20_327", "x", "pvsystem", "calcparams_desoto", "effective_irradiance", "poa", "temp_cell", "tcell", "alpha_sc", "spr_e20_327", "alpha_sc", "a_ref", "spr_e20_327", "a_ref", "i_l_ref", "spr_e20_327", "i_l_ref", "i_o_ref", "spr_e20_327", "i_o_ref", "r_sh_ref", "spr_e20_327", "r_sh_ref", "r_s", "spr_e20_327", "r_s", "egref", "1", "121", "degdt", "0", "0002677", "il", "io", "rs", "rsh", "nnsvt", "x", "pvs", "pvsystem", "singlediode", "x", "method", "lambertw", "out", "pvsystem", "singlediode", "x", "method", "method", "isc", "voc", "imp", "vmp", "pmp", "ix", "ixx", "out", "values", "assert", "np", "isclose", "pvs", "i_sc", "isc", "assert", "np", "isclose", "pvs", "v_oc", "voc", "the", "singlediode", "method", "doesn", "t", "actually", "get", "the", "mpp", "correct", "pvs_imp", "pvsystem", "i_from_v", "rsh", "rs", "nnsvt", "vmp", "io", "il", "method", "lambertw", "pvs_vmp", "pvsystem", "v_from_i", "rsh", "rs", "nnsvt", "imp", "io", "il", "method", "lambertw", "assert", "np", "isclose", "pvs_imp", "imp", "assert", "np", "isclose", "pvs_vmp", "vmp", "assert", "np", "isclose", "pvs", "p_mp", "pmp", "assert", "np", "isclose", "pvs", "i_x", "ix", "pvs_ixx", "pvsystem", "i_from_v", "rsh", "rs", "nnsvt", "voc", "vmp", "2", "io", "il", "method", "lambertw", "assert", "np", "isclose", "pvs_ixx", "ixx"], "doc_len": 162}
{"doc_id": "pvlib/tests/test_singlediode.py::test_newton_fs_495", "file_path": "pvlib/tests/test_singlediode.py", "class_name": null, "func_name": "test_newton_fs_495", "text": "文件路径: pvlib/tests/test_singlediode.py\ndef test_newton_fs_495(method, cec_module_fs_495):\n    \"\"\"test pvsystem.singlediode with different methods on FS495\"\"\"\n    fs_495 = cec_module_fs_495\n    x = pvsystem.calcparams_desoto(\n        effective_irradiance=POA, temp_cell=TCELL,\n        alpha_sc=fs_495['alpha_sc'], a_ref=fs_495['a_ref'],\n        I_L_ref=fs_495['I_L_ref'], I_o_ref=fs_495['I_o_ref'],\n        R_sh_ref=fs_495['R_sh_ref'], R_s=fs_495['R_s'],\n        EgRef=1.475, dEgdT=-0.0003)\n    il, io, rs, rsh, nnsvt = x\n    x += (101, )\n    pvs = pvsystem.singlediode(*x, method='lambertw')\n    out = pvsystem.singlediode(*x, method=method)\n    isc, voc, imp, vmp, pmp, ix, ixx, i, v = out.values()\n    assert np.isclose(pvs['i_sc'], isc)\n    assert np.isclose(pvs['v_oc'], voc)\n    # the singlediode method doesn't actually get the MPP correct\n    pvs_imp = pvsystem.i_from_v(rsh, rs, nnsvt, vmp, io, il, method='lambertw')\n    pvs_vmp = pvsystem.v_from_i(rsh, rs, nnsvt, imp, io, il, method='lambertw')\n    assert np.isclose(pvs_imp, imp)\n    assert np.isclose(pvs_vmp, vmp)\n    assert np.isclose(pvs['p_mp'], pmp)\n    assert np.isclose(pvs['i_x'], ix)\n    pvs_ixx = pvsystem.i_from_v(rsh, rs, nnsvt, (voc + vmp)/2, io, il,\n                                method='lambertw')\n    assert np.isclose(pvs_ixx, ixx)\n", "tokens": ["pvlib", "tests", "test_singlediode", "py", "def", "test_newton_fs_495", "method", "cec_module_fs_495", "test", "pvsystem", "singlediode", "with", "different", "methods", "on", "fs495", "fs_495", "cec_module_fs_495", "x", "pvsystem", "calcparams_desoto", "effective_irradiance", "poa", "temp_cell", "tcell", "alpha_sc", "fs_495", "alpha_sc", "a_ref", "fs_495", "a_ref", "i_l_ref", "fs_495", "i_l_ref", "i_o_ref", "fs_495", "i_o_ref", "r_sh_ref", "fs_495", "r_sh_ref", "r_s", "fs_495", "r_s", "egref", "1", "475", "degdt", "0", "0003", "il", "io", "rs", "rsh", "nnsvt", "x", "x", "101", "pvs", "pvsystem", "singlediode", "x", "method", "lambertw", "out", "pvsystem", "singlediode", "x", "method", "method", "isc", "voc", "imp", "vmp", "pmp", "ix", "ixx", "i", "v", "out", "values", "assert", "np", "isclose", "pvs", "i_sc", "isc", "assert", "np", "isclose", "pvs", "v_oc", "voc", "the", "singlediode", "method", "doesn", "t", "actually", "get", "the", "mpp", "correct", "pvs_imp", "pvsystem", "i_from_v", "rsh", "rs", "nnsvt", "vmp", "io", "il", "method", "lambertw", "pvs_vmp", "pvsystem", "v_from_i", "rsh", "rs", "nnsvt", "imp", "io", "il", "method", "lambertw", "assert", "np", "isclose", "pvs_imp", "imp", "assert", "np", "isclose", "pvs_vmp", "vmp", "assert", "np", "isclose", "pvs", "p_mp", "pmp", "assert", "np", "isclose", "pvs", "i_x", "ix", "pvs_ixx", "pvsystem", "i_from_v", "rsh", "rs", "nnsvt", "voc", "vmp", "2", "io", "il", "method", "lambertw", "assert", "np", "isclose", "pvs_ixx", "ixx"], "doc_len": 164}
{"doc_id": "pvlib/tests/test_singlediode.py::get_pvsyst_fs_495", "file_path": "pvlib/tests/test_singlediode.py", "class_name": null, "func_name": "get_pvsyst_fs_495", "text": "文件路径: pvlib/tests/test_singlediode.py\ndef get_pvsyst_fs_495():\n    \"\"\"\n    PVsyst parameters for First Solar FS-495 module from PVSyst-6.7.2 database.\n\n    I_L_ref derived from Isc_ref conditions::\n\n        I_L_ref = (I_sc_ref + Id + Ish) / (1 - d2mutau/(Vbi*N_s - Vd))\n\n    where::\n\n        Vd = I_sc_ref * R_s\n        Id = I_o_ref * (exp(Vd / nNsVt) - 1)\n        Ish = Vd / R_sh_ref\n\n    \"\"\"\n    return {\n        'd2mutau': 1.31, 'alpha_sc': 0.00039, 'gamma_ref': 1.48,\n        'mu_gamma': 0.001, 'I_o_ref': 9.62e-10, 'R_sh_ref': 5000,\n        'R_sh_0': 12500, 'R_sh_exp': 3.1, 'R_s': 4.6, 'beta_oc': -0.2116,\n        'EgRef': 1.5, 'cells_in_series': 108, 'cells_in_parallel': 2,\n        'I_sc_ref': 1.55, 'V_oc_ref': 86.5, 'I_mp_ref': 1.4, 'V_mp_ref': 67.85,\n        'temp_ref': 25, 'irrad_ref': 1000, 'I_L_ref': 1.5743233463848496\n    }\n", "tokens": ["pvlib", "tests", "test_singlediode", "py", "def", "get_pvsyst_fs_495", "pvsyst", "parameters", "for", "first", "solar", "fs", "495", "module", "from", "pvsyst", "6", "7", "2", "database", "i_l_ref", "derived", "from", "isc_ref", "conditions", "i_l_ref", "i_sc_ref", "id", "ish", "1", "d2mutau", "vbi", "n_s", "vd", "where", "vd", "i_sc_ref", "r_s", "id", "i_o_ref", "exp", "vd", "nnsvt", "1", "ish", "vd", "r_sh_ref", "return", "d2mutau", "1", "31", "alpha_sc", "0", "00039", "gamma_ref", "1", "48", "mu_gamma", "0", "001", "i_o_ref", "9", "62e", "10", "r_sh_ref", "5000", "r_sh_0", "12500", "r_sh_exp", "3", "1", "r_s", "4", "6", "beta_oc", "0", "2116", "egref", "1", "5", "cells_in_series", "108", "cells_in_parallel", "2", "i_sc_ref", "1", "55", "v_oc_ref", "86", "5", "i_mp_ref", "1", "4", "v_mp_ref", "67", "85", "temp_ref", "25", "irrad_ref", "1000", "i_l_ref", "1", "5743233463848496"], "doc_len": 103}
{"doc_id": "pvlib/tests/test_singlediode.py::test_pvsyst_recombination_loss", "file_path": "pvlib/tests/test_singlediode.py", "class_name": null, "func_name": "test_pvsyst_recombination_loss", "text": "文件路径: pvlib/tests/test_singlediode.py\ndef test_pvsyst_recombination_loss(method, poa, temp_cell, expected, tol):\n    \"\"\"test PVSst recombination loss\"\"\"\n    pvsyst_fs_495 = get_pvsyst_fs_495()\n    # first evaluate PVSyst model with thin-film recombination loss current\n    # at reference conditions\n    x = pvsystem.calcparams_pvsyst(\n        effective_irradiance=poa, temp_cell=temp_cell,\n        alpha_sc=pvsyst_fs_495['alpha_sc'],\n        gamma_ref=pvsyst_fs_495['gamma_ref'],\n        mu_gamma=pvsyst_fs_495['mu_gamma'], I_L_ref=pvsyst_fs_495['I_L_ref'],\n        I_o_ref=pvsyst_fs_495['I_o_ref'], R_sh_ref=pvsyst_fs_495['R_sh_ref'],\n        R_sh_0=pvsyst_fs_495['R_sh_0'], R_sh_exp=pvsyst_fs_495['R_sh_exp'],\n        R_s=pvsyst_fs_495['R_s'],\n        cells_in_series=pvsyst_fs_495['cells_in_series'],\n        EgRef=pvsyst_fs_495['EgRef']\n    )\n    il_pvsyst, io_pvsyst, rs_pvsyst, rsh_pvsyst, nnsvt_pvsyst = x\n    voc_est_pvsyst = estimate_voc(photocurrent=il_pvsyst,\n                                  saturation_current=io_pvsyst,\n                                  nNsVth=nnsvt_pvsyst)\n    vd_pvsyst = np.linspace(0, voc_est_pvsyst, 1000)\n    pvsyst = bishop88(\n        diode_voltage=vd_pvsyst, photocurrent=il_pvsyst,\n        saturation_current=io_pvsyst, resistance_series=rs_pvsyst,\n        resistance_shunt=rsh_pvsyst, nNsVth=nnsvt_pvsyst,\n        d2mutau=pvsyst_fs_495['d2mutau'],\n        NsVbi=VOLTAGE_BUILTIN*pvsyst_fs_495['cells_in_series']\n    )\n    # test max power\n    assert np.isclose(max(pvsyst[2]), expected['pmp'], *tol)\n\n    # test short circuit current\n    isc_pvsyst = np.interp(0, pvsyst[1], pvsyst[0])\n    assert np.isclose(isc_pvsyst, expected['isc'], *tol)\n\n    # test open circuit voltage\n    voc_pvsyst = np.interp(0, pvsyst[0][::-1], pvsyst[1][::-1])\n    assert np.isclose(voc_pvsyst, expected['voc'], *tol)\n\n    # repeat tests as above with specialized bishop88 functions\n    y = dict(d2mutau=pvsyst_fs_495['d2mutau'],\n             NsVbi=VOLTAGE_BUILTIN*pvsyst_fs_495['cells_in_series'])\n\n    mpp_88 = bishop88_mpp(*x, **y, method=method)\n    assert np.isclose(mpp_88[2], expected['pmp'], *tol)\n\n    isc_88 = bishop88_i_from_v(0, *x, **y, method=method)\n    assert np.isclose(isc_88, expected['isc'], *tol)\n\n    voc_88 = bishop88_v_from_i(0, *x, **y, method=method)\n    assert np.isclose(voc_88, expected['voc'], *tol)\n\n    ioc_88 = bishop88_i_from_v(voc_88, *x, **y, method=method)\n    assert np.isclose(ioc_88, 0.0, *tol)\n\n    vsc_88 = bishop88_v_from_i(isc_88, *x, **y, method=method)\n    assert np.isclose(vsc_88, 0.0, *tol)\n", "tokens": ["pvlib", "tests", "test_singlediode", "py", "def", "test_pvsyst_recombination_loss", "method", "poa", "temp_cell", "expected", "tol", "test", "pvsst", "recombination", "loss", "pvsyst_fs_495", "get_pvsyst_fs_495", "first", "evaluate", "pvsyst", "model", "with", "thin", "film", "recombination", "loss", "current", "at", "reference", "conditions", "x", "pvsystem", "calcparams_pvsyst", "effective_irradiance", "poa", "temp_cell", "temp_cell", "alpha_sc", "pvsyst_fs_495", "alpha_sc", "gamma_ref", "pvsyst_fs_495", "gamma_ref", "mu_gamma", "pvsyst_fs_495", "mu_gamma", "i_l_ref", "pvsyst_fs_495", "i_l_ref", "i_o_ref", "pvsyst_fs_495", "i_o_ref", "r_sh_ref", "pvsyst_fs_495", "r_sh_ref", "r_sh_0", "pvsyst_fs_495", "r_sh_0", "r_sh_exp", "pvsyst_fs_495", "r_sh_exp", "r_s", "pvsyst_fs_495", "r_s", "cells_in_series", "pvsyst_fs_495", "cells_in_series", "egref", "pvsyst_fs_495", "egref", "il_pvsyst", "io_pvsyst", "rs_pvsyst", "rsh_pvsyst", "nnsvt_pvsyst", "x", "voc_est_pvsyst", "estimate_voc", "photocurrent", "il_pvsyst", "saturation_current", "io_pvsyst", "nnsvth", "nnsvt_pvsyst", "vd_pvsyst", "np", "linspace", "0", "voc_est_pvsyst", "1000", "pvsyst", "bishop88", "diode_voltage", "vd_pvsyst", "photocurrent", "il_pvsyst", "saturation_current", "io_pvsyst", "resistance_series", "rs_pvsyst", "resistance_shunt", "rsh_pvsyst", "nnsvth", "nnsvt_pvsyst", "d2mutau", "pvsyst_fs_495", "d2mutau", "nsvbi", "voltage_builtin", "pvsyst_fs_495", "cells_in_series", "test", "max", "power", "assert", "np", "isclose", "max", "pvsyst", "2", "expected", "pmp", "tol", "test", "short", "circuit", "current", "isc_pvsyst", "np", "interp", "0", "pvsyst", "1", "pvsyst", "0", "assert", "np", "isclose", "isc_pvsyst", "expected", "isc", "tol", "test", "open", "circuit", "voltage", "voc_pvsyst", "np", "interp", "0", "pvsyst", "0", "1", "pvsyst", "1", "1", "assert", "np", "isclose", "voc_pvsyst", "expected", "voc", "tol", "repeat", "tests", "as", "above", "with", "specialized", "bishop88", "functions", "y", "dict", "d2mutau", "pvsyst_fs_495", "d2mutau", "nsvbi", "voltage_builtin", "pvsyst_fs_495", "cells_in_series", "mpp_88", "bishop88_mpp", "x", "y", "method", "method", "assert", "np", "isclose", "mpp_88", "2", "expected", "pmp", "tol", "isc_88", "bishop88_i_from_v", "0", "x", "y", "method", "method", "assert", "np", "isclose", "isc_88", "expected", "isc", "tol", "voc_88", "bishop88_v_from_i", "0", "x", "y", "method", "method", "assert", "np", "isclose", "voc_88", "expected", "voc", "tol", "ioc_88", "bishop88_i_from_v", "voc_88", "x", "y", "method", "method", "assert", "np", "isclose", "ioc_88", "0", "0", "tol", "vsc_88", "bishop88_v_from_i", "isc_88", "x", "y", "method", "method", "assert", "np", "isclose", "vsc_88", "0", "0", "tol"], "doc_len": 250}
{"doc_id": "pvlib/tests/test_singlediode.py::test_pvsyst_breakdown", "file_path": "pvlib/tests/test_singlediode.py", "class_name": null, "func_name": "test_pvsyst_breakdown", "text": "文件路径: pvlib/tests/test_singlediode.py\ndef test_pvsyst_breakdown(method, brk_params, recomb_params, poa, temp_cell,\n                          expected, tol):\n    \"\"\"test PVSyst recombination loss\"\"\"\n    pvsyst_fs_495 = get_pvsyst_fs_495()\n    # first evaluate PVSyst model with thin-film recombination loss current\n    # at reference conditions\n    x = pvsystem.calcparams_pvsyst(\n        effective_irradiance=poa, temp_cell=temp_cell,\n        alpha_sc=pvsyst_fs_495['alpha_sc'],\n        gamma_ref=pvsyst_fs_495['gamma_ref'],\n        mu_gamma=pvsyst_fs_495['mu_gamma'], I_L_ref=pvsyst_fs_495['I_L_ref'],\n        I_o_ref=pvsyst_fs_495['I_o_ref'], R_sh_ref=pvsyst_fs_495['R_sh_ref'],\n        R_sh_0=pvsyst_fs_495['R_sh_0'], R_sh_exp=pvsyst_fs_495['R_sh_exp'],\n        R_s=pvsyst_fs_495['R_s'],\n        cells_in_series=pvsyst_fs_495['cells_in_series'],\n        EgRef=pvsyst_fs_495['EgRef']\n    )\n    il_pvsyst, io_pvsyst, rs_pvsyst, rsh_pvsyst, nnsvt_pvsyst = x\n\n    d2mutau, NsVbi = recomb_params\n    breakdown_factor, breakdown_voltage, breakdown_exp = brk_params\n\n    voc_est_pvsyst = estimate_voc(photocurrent=il_pvsyst,\n                                  saturation_current=io_pvsyst,\n                                  nNsVth=nnsvt_pvsyst)\n    vd_pvsyst = np.linspace(0, voc_est_pvsyst, 1000)\n    pvsyst = bishop88(\n        diode_voltage=vd_pvsyst, photocurrent=il_pvsyst,\n        saturation_current=io_pvsyst, resistance_series=rs_pvsyst,\n        resistance_shunt=rsh_pvsyst, nNsVth=nnsvt_pvsyst,\n        d2mutau=d2mutau, NsVbi=NsVbi,\n        breakdown_factor=breakdown_factor, breakdown_voltage=breakdown_voltage,\n        breakdown_exp=breakdown_exp\n    )\n    # test max power\n    assert np.isclose(max(pvsyst[2]), expected['pmp'], *tol)\n\n    # test short circuit current\n    isc_pvsyst = np.interp(0, pvsyst[1], pvsyst[0])\n    assert np.isclose(isc_pvsyst, expected['isc'], *tol)\n\n    # test open circuit voltage\n    voc_pvsyst = np.interp(0, pvsyst[0][::-1], pvsyst[1][::-1])\n    assert np.isclose(voc_pvsyst, expected['voc'], *tol)\n\n    # repeat tests as above with specialized bishop88 functions\n    y = {'d2mutau': recomb_params[0], 'NsVbi': recomb_params[1],\n         'breakdown_factor': brk_params[0], 'breakdown_voltage': brk_params[1],\n         'breakdown_exp': brk_params[2]}\n\n    mpp_88 = bishop88_mpp(*x, **y, method=method)\n    assert np.isclose(mpp_88[2], expected['pmp'], *tol)\n\n    isc_88 = bishop88_i_from_v(0, *x, **y, method=method)\n    assert np.isclose(isc_88, expected['isc'], *tol)\n\n    voc_88 = bishop88_v_from_i(0, *x, **y, method=method)\n    assert np.isclose(voc_88, expected['voc'], *tol)\n\n    ioc_88 = bishop88_i_from_v(voc_88, *x, **y, method=method)\n    assert np.isclose(ioc_88, 0.0, *tol)\n\n    vsc_88 = bishop88_v_from_i(isc_88, *x, **y, method=method)\n    assert np.isclose(vsc_88, 0.0, *tol)\n", "tokens": ["pvlib", "tests", "test_singlediode", "py", "def", "test_pvsyst_breakdown", "method", "brk_params", "recomb_params", "poa", "temp_cell", "expected", "tol", "test", "pvsyst", "recombination", "loss", "pvsyst_fs_495", "get_pvsyst_fs_495", "first", "evaluate", "pvsyst", "model", "with", "thin", "film", "recombination", "loss", "current", "at", "reference", "conditions", "x", "pvsystem", "calcparams_pvsyst", "effective_irradiance", "poa", "temp_cell", "temp_cell", "alpha_sc", "pvsyst_fs_495", "alpha_sc", "gamma_ref", "pvsyst_fs_495", "gamma_ref", "mu_gamma", "pvsyst_fs_495", "mu_gamma", "i_l_ref", "pvsyst_fs_495", "i_l_ref", "i_o_ref", "pvsyst_fs_495", "i_o_ref", "r_sh_ref", "pvsyst_fs_495", "r_sh_ref", "r_sh_0", "pvsyst_fs_495", "r_sh_0", "r_sh_exp", "pvsyst_fs_495", "r_sh_exp", "r_s", "pvsyst_fs_495", "r_s", "cells_in_series", "pvsyst_fs_495", "cells_in_series", "egref", "pvsyst_fs_495", "egref", "il_pvsyst", "io_pvsyst", "rs_pvsyst", "rsh_pvsyst", "nnsvt_pvsyst", "x", "d2mutau", "nsvbi", "recomb_params", "breakdown_factor", "breakdown_voltage", "breakdown_exp", "brk_params", "voc_est_pvsyst", "estimate_voc", "photocurrent", "il_pvsyst", "saturation_current", "io_pvsyst", "nnsvth", "nnsvt_pvsyst", "vd_pvsyst", "np", "linspace", "0", "voc_est_pvsyst", "1000", "pvsyst", "bishop88", "diode_voltage", "vd_pvsyst", "photocurrent", "il_pvsyst", "saturation_current", "io_pvsyst", "resistance_series", "rs_pvsyst", "resistance_shunt", "rsh_pvsyst", "nnsvth", "nnsvt_pvsyst", "d2mutau", "d2mutau", "nsvbi", "nsvbi", "breakdown_factor", "breakdown_factor", "breakdown_voltage", "breakdown_voltage", "breakdown_exp", "breakdown_exp", "test", "max", "power", "assert", "np", "isclose", "max", "pvsyst", "2", "expected", "pmp", "tol", "test", "short", "circuit", "current", "isc_pvsyst", "np", "interp", "0", "pvsyst", "1", "pvsyst", "0", "assert", "np", "isclose", "isc_pvsyst", "expected", "isc", "tol", "test", "open", "circuit", "voltage", "voc_pvsyst", "np", "interp", "0", "pvsyst", "0", "1", "pvsyst", "1", "1", "assert", "np", "isclose", "voc_pvsyst", "expected", "voc", "tol", "repeat", "tests", "as", "above", "with", "specialized", "bishop88", "functions", "y", "d2mutau", "recomb_params", "0", "nsvbi", "recomb_params", "1", "breakdown_factor", "brk_params", "0", "breakdown_voltage", "brk_params", "1", "breakdown_exp", "brk_params", "2", "mpp_88", "bishop88_mpp", "x", "y", "method", "method", "assert", "np", "isclose", "mpp_88", "2", "expected", "pmp", "tol", "isc_88", "bishop88_i_from_v", "0", "x", "y", "method", "method", "assert", "np", "isclose", "isc_88", "expected", "isc", "tol", "voc_88", "bishop88_v_from_i", "0", "x", "y", "method", "method", "assert", "np", "isclose", "voc_88", "expected", "voc", "tol", "ioc_88", "bishop88_i_from_v", "voc_88", "x", "y", "method", "method", "assert", "np", "isclose", "ioc_88", "0", "0", "tol", "vsc_88", "bishop88_v_from_i", "isc_88", "x", "y", "method", "method", "assert", "np", "isclose", "vsc_88", "0", "0", "tol"], "doc_len": 269}
{"doc_id": "pvlib/tests/test_snow.py::test_fully_covered_nrel", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_fully_covered_nrel", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_fully_covered_nrel():\n    dt = pd.date_range(start=\"2019-1-1 12:00:00\", end=\"2019-1-1 18:00:00\",\n                       freq='1h')\n    snowfall_data = pd.Series([1, 5, .6, 4, .23, -5, 19], index=dt)\n    expected = pd.Series([False, True, False, True, False, False, True],\n                         index=dt)\n    fully_covered = snow.fully_covered_nrel(snowfall_data)\n    assert_series_equal(expected, fully_covered)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_fully_covered_nrel", "dt", "pd", "date_range", "start", "2019", "1", "1", "12", "00", "00", "end", "2019", "1", "1", "18", "00", "00", "freq", "1h", "snowfall_data", "pd", "series", "1", "5", "6", "4", "23", "5", "19", "index", "dt", "expected", "pd", "series", "false", "true", "false", "true", "false", "false", "true", "index", "dt", "fully_covered", "snow", "fully_covered_nrel", "snowfall_data", "assert_series_equal", "expected", "fully_covered"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_snow.py::test_coverage_nrel_hourly", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_coverage_nrel_hourly", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_coverage_nrel_hourly():\n    surface_tilt = 45\n    slide_amount_coefficient = 0.197\n    dt = pd.date_range(start=\"2019-1-1 10:00:00\", end=\"2019-1-1 17:00:00\",\n                       freq='1h')\n    poa_irradiance = pd.Series([400, 200, 100, 1234, 134, 982, 100, 100],\n                               index=dt)\n    temp_air = pd.Series([10, 2, 10, 1234, 34, 982, 10, 10], index=dt)\n    snowfall_data = pd.Series([1, .5, .6, .4, .23, -5, .1, .1], index=dt)\n    snow_coverage = snow.coverage_nrel(\n        snowfall_data, poa_irradiance, temp_air, surface_tilt,\n        threshold_snowfall=0.6)\n\n    slide_amt = slide_amount_coefficient * sind(surface_tilt)\n    covered = 1.0 - slide_amt * np.array([0, 1, 2, 3, 4, 5, 6, 7])\n    expected = pd.Series(covered, index=dt)\n    assert_series_equal(expected, snow_coverage)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_coverage_nrel_hourly", "surface_tilt", "45", "slide_amount_coefficient", "0", "197", "dt", "pd", "date_range", "start", "2019", "1", "1", "10", "00", "00", "end", "2019", "1", "1", "17", "00", "00", "freq", "1h", "poa_irradiance", "pd", "series", "400", "200", "100", "1234", "134", "982", "100", "100", "index", "dt", "temp_air", "pd", "series", "10", "2", "10", "1234", "34", "982", "10", "10", "index", "dt", "snowfall_data", "pd", "series", "1", "5", "6", "4", "23", "5", "1", "1", "index", "dt", "snow_coverage", "snow", "coverage_nrel", "snowfall_data", "poa_irradiance", "temp_air", "surface_tilt", "threshold_snowfall", "0", "6", "slide_amt", "slide_amount_coefficient", "sind", "surface_tilt", "covered", "1", "0", "slide_amt", "np", "array", "0", "1", "2", "3", "4", "5", "6", "7", "expected", "pd", "series", "covered", "index", "dt", "assert_series_equal", "expected", "snow_coverage"], "doc_len": 106}
{"doc_id": "pvlib/tests/test_snow.py::test_coverage_nrel_subhourly", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_coverage_nrel_subhourly", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_coverage_nrel_subhourly():\n    surface_tilt = 45\n    slide_amount_coefficient = 0.197\n    dt = pd.date_range(start=\"2019-1-1 11:00:00\", end=\"2019-1-1 14:00:00\",\n                       freq='15T')\n    poa_irradiance = pd.Series([400, 200, 100, 1234, 134, 982, 100, 100, 100,\n                                100, 100, 100, 0],\n                               index=dt)\n    temp_air = pd.Series([10, 2, 10, 1234, 34, 982, 10, 10, 10, 10, -10, -10,\n                          10], index=dt)\n    snowfall_data = pd.Series([1, .5, .6, .4, .23, -5, .1, .1, 0., 1., 0., 0.,\n                               0.], index=dt)\n    snow_coverage = snow.coverage_nrel(\n        snowfall_data, poa_irradiance, temp_air, surface_tilt)\n    slide_amt = slide_amount_coefficient * sind(surface_tilt) * 0.25\n    covered = np.append(np.array([1., 1., 1., 1.]),\n                        1.0 - slide_amt * np.array([1, 2, 3, 4, 5]))\n    covered = np.append(covered, np.array([1., 1., 1., 1. - slide_amt]))\n    expected = pd.Series(covered, index=dt)\n    assert_series_equal(expected, snow_coverage)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_coverage_nrel_subhourly", "surface_tilt", "45", "slide_amount_coefficient", "0", "197", "dt", "pd", "date_range", "start", "2019", "1", "1", "11", "00", "00", "end", "2019", "1", "1", "14", "00", "00", "freq", "15t", "poa_irradiance", "pd", "series", "400", "200", "100", "1234", "134", "982", "100", "100", "100", "100", "100", "100", "0", "index", "dt", "temp_air", "pd", "series", "10", "2", "10", "1234", "34", "982", "10", "10", "10", "10", "10", "10", "10", "index", "dt", "snowfall_data", "pd", "series", "1", "5", "6", "4", "23", "5", "1", "1", "0", "1", "0", "0", "0", "index", "dt", "snow_coverage", "snow", "coverage_nrel", "snowfall_data", "poa_irradiance", "temp_air", "surface_tilt", "slide_amt", "slide_amount_coefficient", "sind", "surface_tilt", "0", "25", "covered", "np", "append", "np", "array", "1", "1", "1", "1", "1", "0", "slide_amt", "np", "array", "1", "2", "3", "4", "5", "covered", "np", "append", "covered", "np", "array", "1", "1", "1", "1", "slide_amt", "expected", "pd", "series", "covered", "index", "dt", "assert_series_equal", "expected", "snow_coverage"], "doc_len": 136}
{"doc_id": "pvlib/tests/test_snow.py::test_fully_covered_nrel_irregular", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_fully_covered_nrel_irregular", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_fully_covered_nrel_irregular():\n    # test when frequency is not specified and can't be inferred\n    dt = pd.DatetimeIndex([\"2019-1-1 11:00:00\", \"2019-1-1 14:30:00\",\n                           \"2019-1-1 15:07:00\", \"2019-1-1 14:00:00\"])\n    snowfall_data = pd.Series([1, .5, .6, .4], index=dt)\n    snow_coverage = snow.fully_covered_nrel(snowfall_data,\n                                            threshold_snowfall=0.5)\n    covered = np.array([False, False, True, False])\n    expected = pd.Series(covered, index=dt)\n    assert_series_equal(expected, snow_coverage)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_fully_covered_nrel_irregular", "test", "when", "frequency", "is", "not", "specified", "and", "can", "t", "be", "inferred", "dt", "pd", "datetimeindex", "2019", "1", "1", "11", "00", "00", "2019", "1", "1", "14", "30", "00", "2019", "1", "1", "15", "07", "00", "2019", "1", "1", "14", "00", "00", "snowfall_data", "pd", "series", "1", "5", "6", "4", "index", "dt", "snow_coverage", "snow", "fully_covered_nrel", "snowfall_data", "threshold_snowfall", "0", "5", "covered", "np", "array", "false", "false", "true", "false", "expected", "pd", "series", "covered", "index", "dt", "assert_series_equal", "expected", "snow_coverage"], "doc_len": 76}
{"doc_id": "pvlib/tests/test_snow.py::test_coverage_nrel_initial", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_coverage_nrel_initial", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_coverage_nrel_initial():\n    surface_tilt = 45\n    slide_amount_coefficient = 0.197\n    dt = pd.date_range(start=\"2019-1-1 10:00:00\", end=\"2019-1-1 17:00:00\",\n                       freq='1h')\n    poa_irradiance = pd.Series([400, 200, 100, 1234, 134, 982, 100, 100],\n                               index=dt)\n    temp_air = pd.Series([10, 2, 10, 1234, 34, 982, 10, 10], index=dt)\n    snowfall_data = pd.Series([0, .5, .6, .4, .23, -5, .1, .1], index=dt)\n    snow_coverage = snow.coverage_nrel(\n        snowfall_data, poa_irradiance, temp_air, surface_tilt,\n        initial_coverage=0.5, threshold_snowfall=1.)\n    slide_amt = slide_amount_coefficient * sind(surface_tilt)\n    covered = 0.5 - slide_amt * np.array([0, 1, 2, 3, 4, 5, 6, 7])\n    covered = np.where(covered < 0, 0., covered)\n    expected = pd.Series(covered, index=dt)\n    assert_series_equal(expected, snow_coverage)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_coverage_nrel_initial", "surface_tilt", "45", "slide_amount_coefficient", "0", "197", "dt", "pd", "date_range", "start", "2019", "1", "1", "10", "00", "00", "end", "2019", "1", "1", "17", "00", "00", "freq", "1h", "poa_irradiance", "pd", "series", "400", "200", "100", "1234", "134", "982", "100", "100", "index", "dt", "temp_air", "pd", "series", "10", "2", "10", "1234", "34", "982", "10", "10", "index", "dt", "snowfall_data", "pd", "series", "0", "5", "6", "4", "23", "5", "1", "1", "index", "dt", "snow_coverage", "snow", "coverage_nrel", "snowfall_data", "poa_irradiance", "temp_air", "surface_tilt", "initial_coverage", "0", "5", "threshold_snowfall", "1", "slide_amt", "slide_amount_coefficient", "sind", "surface_tilt", "covered", "0", "5", "slide_amt", "np", "array", "0", "1", "2", "3", "4", "5", "6", "7", "covered", "np", "where", "covered", "0", "0", "covered", "expected", "pd", "series", "covered", "index", "dt", "assert_series_equal", "expected", "snow_coverage"], "doc_len": 115}
{"doc_id": "pvlib/tests/test_snow.py::test_dc_loss_nrel", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_dc_loss_nrel", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_dc_loss_nrel():\n    num_strings = 8\n    snow_coverage = pd.Series([1, 1, .5, .6, .2, .4, 0])\n    expected = pd.Series([1, 1, .5, .625, .25, .5, 0])\n    actual = snow.dc_loss_nrel(snow_coverage, num_strings)\n    assert_series_equal(expected, actual)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_dc_loss_nrel", "num_strings", "8", "snow_coverage", "pd", "series", "1", "1", "5", "6", "2", "4", "0", "expected", "pd", "series", "1", "1", "5", "625", "25", "5", "0", "actual", "snow", "dc_loss_nrel", "snow_coverage", "num_strings", "assert_series_equal", "expected", "actual"], "doc_len": 36}
{"doc_id": "pvlib/tests/test_snow.py::test__townsend_effective_snow", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test__townsend_effective_snow", "text": "文件路径: pvlib/tests/test_snow.py\ndef test__townsend_effective_snow():\n    snow_total = np.array([25.4, 25.4, 12.7, 2.54, 0, 0, 0, 0, 0, 0, 12.7,\n                           25.4])\n    snow_events = np.array([2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 3])\n    expected = np.array([19.05, 19.05, 12.7, 0, 0, 0, 0, 0, 0, 0, 9.525,\n                         254 / 15])\n    actual = snow._townsend_effective_snow(snow_total, snow_events)\n    np.testing.assert_allclose(expected, actual, rtol=1e-07)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test__townsend_effective_snow", "snow_total", "np", "array", "25", "4", "25", "4", "12", "7", "2", "54", "0", "0", "0", "0", "0", "0", "12", "7", "25", "4", "snow_events", "np", "array", "2", "2", "1", "0", "0", "0", "0", "0", "0", "0", "2", "3", "expected", "np", "array", "19", "05", "19", "05", "12", "7", "0", "0", "0", "0", "0", "0", "0", "9", "525", "254", "15", "actual", "snow", "_townsend_effective_snow", "snow_total", "snow_events", "np", "testing", "assert_allclose", "expected", "actual", "rtol", "1e", "07"], "doc_len": 75}
{"doc_id": "pvlib/tests/test_snow.py::test_loss_townsend", "file_path": "pvlib/tests/test_snow.py", "class_name": null, "func_name": "test_loss_townsend", "text": "文件路径: pvlib/tests/test_snow.py\ndef test_loss_townsend():\n    snow_total = np.array([25.4, 25.4, 12.7, 2.54, 0, 0, 0, 0, 0, 0, 12.7,\n                           25.4])\n    snow_events = np.array([2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 3])\n    surface_tilt = 20\n    relative_humidity = np.array([80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n                                  80, 80])\n    temp_air = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    poa_global = np.array([350000, 350000, 350000, 350000, 350000, 350000,\n                           350000, 350000, 350000, 350000, 350000, 350000])\n    angle_of_repose = 40\n    slant_height = 2.54\n    lower_edge_height = 0.254\n    expected = np.array([0.07696253, 0.07992262, 0.06216201, 0.01715392, 0, 0,\n                         0, 0, 0, 0, 0.02643821, 0.06068194])\n    actual = snow.loss_townsend(snow_total, snow_events, surface_tilt,\n                                relative_humidity, temp_air,\n                                poa_global, slant_height,\n                                lower_edge_height, angle_of_repose)\n    np.testing.assert_allclose(expected, actual, rtol=1e-05)\n", "tokens": ["pvlib", "tests", "test_snow", "py", "def", "test_loss_townsend", "snow_total", "np", "array", "25", "4", "25", "4", "12", "7", "2", "54", "0", "0", "0", "0", "0", "0", "12", "7", "25", "4", "snow_events", "np", "array", "2", "2", "1", "0", "0", "0", "0", "0", "0", "0", "2", "3", "surface_tilt", "20", "relative_humidity", "np", "array", "80", "80", "80", "80", "80", "80", "80", "80", "80", "80", "80", "80", "temp_air", "np", "array", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "poa_global", "np", "array", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "350000", "angle_of_repose", "40", "slant_height", "2", "54", "lower_edge_height", "0", "254", "expected", "np", "array", "0", "07696253", "0", "07992262", "0", "06216201", "0", "01715392", "0", "0", "0", "0", "0", "0", "0", "02643821", "0", "06068194", "actual", "snow", "loss_townsend", "snow_total", "snow_events", "surface_tilt", "relative_humidity", "temp_air", "poa_global", "slant_height", "lower_edge_height", "angle_of_repose", "np", "testing", "assert_allclose", "expected", "actual", "rtol", "1e", "05"], "doc_len": 138}
{"doc_id": "pvlib/tests/test_soiling.py::expected_output", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_output", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_output():\n    # Sample output (calculated manually)\n    dt = pd.date_range(start=pd.Timestamp(2019, 1, 1, 0, 0, 0),\n                       end=pd.Timestamp(2019, 1, 1, 23, 59, 0), freq='1h')\n\n    expected_no_cleaning = pd.Series(\n        data=[0.96998483, 0.94623958, 0.92468139, 0.90465654, 0.88589707,\n              0.86826366, 0.85167258, 0.83606715, 0.82140458, 0.80764919,\n              0.79476875, 0.78273241, 0.77150951, 0.76106905, 0.75137932,\n              0.74240789, 0.73412165, 0.72648695, 0.71946981, 0.7130361,\n              0.70715176, 0.70178307, 0.69689677, 0.69246034],\n        index=dt)\n    return expected_no_cleaning\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_output", "sample", "output", "calculated", "manually", "dt", "pd", "date_range", "start", "pd", "timestamp", "2019", "1", "1", "0", "0", "0", "end", "pd", "timestamp", "2019", "1", "1", "23", "59", "0", "freq", "1h", "expected_no_cleaning", "pd", "series", "data", "0", "96998483", "0", "94623958", "0", "92468139", "0", "90465654", "0", "88589707", "0", "86826366", "0", "85167258", "0", "83606715", "0", "82140458", "0", "80764919", "0", "79476875", "0", "78273241", "0", "77150951", "0", "76106905", "0", "75137932", "0", "74240789", "0", "73412165", "0", "72648695", "0", "71946981", "0", "7130361", "0", "70715176", "0", "70178307", "0", "69689677", "0", "69246034", "index", "dt", "return", "expected_no_cleaning"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_soiling.py::expected_output_1", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_output_1", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_output_1():\n    dt = pd.date_range(start=pd.Timestamp(2019, 1, 1, 0, 0, 0),\n                       end=pd.Timestamp(2019, 1, 1, 23, 59, 0), freq='1h')\n    expected_output_1 = pd.Series(\n        data=[0.98484972, 0.97277367, 0.96167471, 0.95119603, 1.,\n              0.98484972, 0.97277367, 0.96167471, 1., 1.,\n              0.98484972, 0.97277367, 0.96167471, 0.95119603, 0.94118234,\n              0.93154854, 0.922242, 0.91322759, 0.90448058, 0.89598283,\n              0.88772062, 0.87968325, 0.8718622, 0.86425049],\n        index=dt)\n    return expected_output_1\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_output_1", "dt", "pd", "date_range", "start", "pd", "timestamp", "2019", "1", "1", "0", "0", "0", "end", "pd", "timestamp", "2019", "1", "1", "23", "59", "0", "freq", "1h", "expected_output_1", "pd", "series", "data", "0", "98484972", "0", "97277367", "0", "96167471", "0", "95119603", "1", "0", "98484972", "0", "97277367", "0", "96167471", "1", "1", "0", "98484972", "0", "97277367", "0", "96167471", "0", "95119603", "0", "94118234", "0", "93154854", "0", "922242", "0", "91322759", "0", "90448058", "0", "89598283", "0", "88772062", "0", "87968325", "0", "8718622", "0", "86425049", "index", "dt", "return", "expected_output_1"], "doc_len": 82}
{"doc_id": "pvlib/tests/test_soiling.py::expected_output_2", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_output_2", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_output_2():\n    dt = pd.date_range(start=pd.Timestamp(2019, 1, 1, 0, 0, 0),\n                       end=pd.Timestamp(2019, 1, 1, 23, 59, 0), freq='1h')\n    expected_output_2 = pd.Series(\n        data=[0.95036261, 0.91178179, 0.87774818, 0.84732079, 1.,\n              1., 1., 0.95036261, 1., 1.,\n              1., 1., 0.95036261, 0.91178179, 0.87774818,\n              0.84732079, 0.8201171, 1., 1., 1.,\n              1., 0.95036261, 0.91178179, 0.87774818],\n        index=dt)\n    return expected_output_2\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_output_2", "dt", "pd", "date_range", "start", "pd", "timestamp", "2019", "1", "1", "0", "0", "0", "end", "pd", "timestamp", "2019", "1", "1", "23", "59", "0", "freq", "1h", "expected_output_2", "pd", "series", "data", "0", "95036261", "0", "91178179", "0", "87774818", "0", "84732079", "1", "1", "1", "0", "95036261", "1", "1", "1", "1", "0", "95036261", "0", "91178179", "0", "87774818", "0", "84732079", "0", "8201171", "1", "1", "1", "1", "0", "95036261", "0", "91178179", "0", "87774818", "index", "dt", "return", "expected_output_2"], "doc_len": 74}
{"doc_id": "pvlib/tests/test_soiling.py::expected_output_3", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_output_3", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_output_3():\n    dt = pd.date_range(start=pd.Timestamp(2019, 1, 1, 0, 0, 0),\n                       end=pd.Timestamp(2019, 1, 1, 23, 59, 0), freq='1h')\n    timedelta = [0, 0, 0, 0, 0, 30, 0, 30, 0, 30, 0, -30,\n                 -30, -30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    dt_new = dt + pd.to_timedelta(timedelta, 'm')\n    expected_output_3 = pd.Series(\n        data=[0.96576705, 0.9387675, 0.91437615, 0.89186852, 1.,\n              1., 0.98093819, 0.9387675, 1., 1.,\n              1., 1., 0.96576705, 0.9387675, 0.90291005,\n              0.88122293, 0.86104089, 1., 1., 1.,\n              0.96576705, 0.9387675, 0.91437615, 0.89186852],\n        index=dt_new)\n    return expected_output_3\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_output_3", "dt", "pd", "date_range", "start", "pd", "timestamp", "2019", "1", "1", "0", "0", "0", "end", "pd", "timestamp", "2019", "1", "1", "23", "59", "0", "freq", "1h", "timedelta", "0", "0", "0", "0", "0", "30", "0", "30", "0", "30", "0", "30", "30", "30", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "dt_new", "dt", "pd", "to_timedelta", "timedelta", "m", "expected_output_3", "pd", "series", "data", "0", "96576705", "0", "9387675", "0", "91437615", "0", "89186852", "1", "1", "0", "98093819", "0", "9387675", "1", "1", "1", "1", "0", "96576705", "0", "9387675", "0", "90291005", "0", "88122293", "0", "86104089", "1", "1", "1", "0", "96576705", "0", "9387675", "0", "91437615", "0", "89186852", "index", "dt_new", "return", "expected_output_3"], "doc_len": 107}
{"doc_id": "pvlib/tests/test_soiling.py::rainfall_input", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "rainfall_input", "text": "文件路径: pvlib/tests/test_soiling.py\ndef rainfall_input():\n\n    dt = pd.date_range(start=pd.Timestamp(2019, 1, 1, 0, 0, 0),\n                       end=pd.Timestamp(2019, 1, 1, 23, 59, 0), freq='1h')\n    rainfall = pd.Series(\n        data=[0., 0., 0., 0., 1., 0., 0., 0., 0.5, 0.5, 0., 0., 0., 0., 0.,\n              0., 0.3, 0.3, 0.3, 0.3, 0., 0., 0., 0.], index=dt)\n    return rainfall\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "rainfall_input", "dt", "pd", "date_range", "start", "pd", "timestamp", "2019", "1", "1", "0", "0", "0", "end", "pd", "timestamp", "2019", "1", "1", "23", "59", "0", "freq", "1h", "rainfall", "pd", "series", "data", "0", "0", "0", "0", "1", "0", "0", "0", "0", "5", "0", "5", "0", "0", "0", "0", "0", "0", "0", "3", "0", "3", "0", "3", "0", "3", "0", "0", "0", "0", "index", "dt", "return", "rainfall"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_soiling.py::test_hsu_no_cleaning", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_hsu_no_cleaning", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_hsu_no_cleaning(rainfall_input, expected_output):\n    \"\"\"Test Soiling HSU function\"\"\"\n\n    rainfall = rainfall_input\n    pm2_5 = 1.0\n    pm10 = 2.0\n    depo_veloc = {'2_5': 1.0e-5, '10': 1.0e-4}\n    tilt = 0.\n    expected_no_cleaning = expected_output\n\n    result = hsu(rainfall=rainfall, cleaning_threshold=10., tilt=tilt,\n                 pm2_5=pm2_5, pm10=pm10, depo_veloc=depo_veloc,\n                 rain_accum_period=pd.Timedelta('1h'))\n    assert_series_equal(result, expected_no_cleaning)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_hsu_no_cleaning", "rainfall_input", "expected_output", "test", "soiling", "hsu", "function", "rainfall", "rainfall_input", "pm2_5", "1", "0", "pm10", "2", "0", "depo_veloc", "2_5", "1", "0e", "5", "10", "1", "0e", "4", "tilt", "0", "expected_no_cleaning", "expected_output", "result", "hsu", "rainfall", "rainfall", "cleaning_threshold", "10", "tilt", "tilt", "pm2_5", "pm2_5", "pm10", "pm10", "depo_veloc", "depo_veloc", "rain_accum_period", "pd", "timedelta", "1h", "assert_series_equal", "result", "expected_no_cleaning"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_soiling.py::test_hsu", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_hsu", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_hsu(rainfall_input, expected_output_2):\n    \"\"\"Test Soiling HSU function with cleanings\"\"\"\n\n    rainfall = rainfall_input\n    pm2_5 = 1.0\n    pm10 = 2.0\n    depo_veloc = {'2_5': 1.0e-4, '10': 1.0e-4}\n    tilt = 0.\n\n    # three cleaning events at 4:00-6:00, 8:00-11:00, and 17:00-20:00\n    result = hsu(rainfall=rainfall, cleaning_threshold=0.5, tilt=tilt,\n                 pm2_5=pm2_5, pm10=pm10, depo_veloc=depo_veloc,\n                 rain_accum_period=pd.Timedelta('3h'))\n\n    assert_series_equal(result, expected_output_2)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_hsu", "rainfall_input", "expected_output_2", "test", "soiling", "hsu", "function", "with", "cleanings", "rainfall", "rainfall_input", "pm2_5", "1", "0", "pm10", "2", "0", "depo_veloc", "2_5", "1", "0e", "4", "10", "1", "0e", "4", "tilt", "0", "three", "cleaning", "events", "at", "4", "00", "6", "00", "8", "00", "11", "00", "and", "17", "00", "20", "00", "result", "hsu", "rainfall", "rainfall", "cleaning_threshold", "0", "5", "tilt", "tilt", "pm2_5", "pm2_5", "pm10", "pm10", "depo_veloc", "depo_veloc", "rain_accum_period", "pd", "timedelta", "3h", "assert_series_equal", "result", "expected_output_2"], "doc_len": 72}
{"doc_id": "pvlib/tests/test_soiling.py::test_hsu_defaults", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_hsu_defaults", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_hsu_defaults(rainfall_input, expected_output_1):\n    \"\"\"\n    Test Soiling HSU function with default deposition velocity and default rain\n    accumulation period.\n    \"\"\"\n    result = hsu(rainfall=rainfall_input, cleaning_threshold=0.5, tilt=0.0,\n                 pm2_5=1.0e-2, pm10=2.0e-2)\n    assert np.allclose(result.values, expected_output_1)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_hsu_defaults", "rainfall_input", "expected_output_1", "test", "soiling", "hsu", "function", "with", "default", "deposition", "velocity", "and", "default", "rain", "accumulation", "period", "result", "hsu", "rainfall", "rainfall_input", "cleaning_threshold", "0", "5", "tilt", "0", "0", "pm2_5", "1", "0e", "2", "pm10", "2", "0e", "2", "assert", "np", "allclose", "result", "values", "expected_output_1"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_soiling.py::test_hsu_variable_time_intervals", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_hsu_variable_time_intervals", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_hsu_variable_time_intervals(rainfall_input, expected_output_3):\n    \"\"\"\n    Test Soiling HSU function with variable time intervals.\n    \"\"\"\n    depo_veloc = {'2_5': 1.0e-4, '10': 1.0e-4}\n    rain = pd.DataFrame(data=rainfall_input)\n    # define time deltas in minutes\n    timedelta = [0, 0, 0, 0, 0, 30, 0, 30, 0, 30, 0, -30,\n                 -30, -30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    rain['mins_added'] = pd.to_timedelta(timedelta, 'm')\n    rain['new_time'] = rain.index + rain['mins_added']\n    rain_var_times = rain.set_index('new_time').iloc[:, 0]\n    result = hsu(\n        rainfall=rain_var_times, cleaning_threshold=0.5, tilt=50.0,\n        pm2_5=1, pm10=2, depo_veloc=depo_veloc,\n        rain_accum_period=pd.Timedelta('2h'))\n    assert np.allclose(result, expected_output_3)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_hsu_variable_time_intervals", "rainfall_input", "expected_output_3", "test", "soiling", "hsu", "function", "with", "variable", "time", "intervals", "depo_veloc", "2_5", "1", "0e", "4", "10", "1", "0e", "4", "rain", "pd", "dataframe", "data", "rainfall_input", "define", "time", "deltas", "in", "minutes", "timedelta", "0", "0", "0", "0", "0", "30", "0", "30", "0", "30", "0", "30", "30", "30", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "rain", "mins_added", "pd", "to_timedelta", "timedelta", "m", "rain", "new_time", "rain", "index", "rain", "mins_added", "rain_var_times", "rain", "set_index", "new_time", "iloc", "0", "result", "hsu", "rainfall", "rain_var_times", "cleaning_threshold", "0", "5", "tilt", "50", "0", "pm2_5", "1", "pm10", "2", "depo_veloc", "depo_veloc", "rain_accum_period", "pd", "timedelta", "2h", "assert", "np", "allclose", "result", "expected_output_3"], "doc_len": 103}
{"doc_id": "pvlib/tests/test_soiling.py::greensboro_rain", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "greensboro_rain", "text": "文件路径: pvlib/tests/test_soiling.py\ndef greensboro_rain():\n    # get TMY3 data with rain\n    greensboro, _ = read_tmy3(DATA_DIR / '723170TYA.CSV', coerce_year=1990)\n    return greensboro.Lprecipdepth\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "greensboro_rain", "get", "tmy3", "data", "with", "rain", "greensboro", "_", "read_tmy3", "data_dir", "723170tya", "csv", "coerce_year", "1990", "return", "greensboro", "lprecipdepth"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_soiling.py::expected_kimber_nowash", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_kimber_nowash", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_kimber_nowash():\n    return pd.read_csv(\n        DATA_DIR / 'greensboro_kimber_soil_nowash.dat',\n        parse_dates=True, index_col='timestamp')\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_kimber_nowash", "return", "pd", "read_csv", "data_dir", "greensboro_kimber_soil_nowash", "dat", "parse_dates", "true", "index_col", "timestamp"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_soiling.py::test_kimber_nowash", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_kimber_nowash", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_kimber_nowash(greensboro_rain, expected_kimber_nowash):\n    \"\"\"Test Kimber soiling model with no manual washes\"\"\"\n    # Greensboro typical expected annual rainfall is 8345mm\n    assert greensboro_rain.sum() == 8345\n    # calculate soiling with no wash dates\n    nowash = kimber(greensboro_rain)\n    # test no washes\n    assert np.allclose(nowash.values, expected_kimber_nowash['soiling'].values)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_kimber_nowash", "greensboro_rain", "expected_kimber_nowash", "test", "kimber", "soiling", "model", "with", "no", "manual", "washes", "greensboro", "typical", "expected", "annual", "rainfall", "is", "8345mm", "assert", "greensboro_rain", "sum", "8345", "calculate", "soiling", "with", "no", "wash", "dates", "nowash", "kimber", "greensboro_rain", "test", "no", "washes", "assert", "np", "allclose", "nowash", "values", "expected_kimber_nowash", "soiling", "values"], "doc_len": 47}
{"doc_id": "pvlib/tests/test_soiling.py::expected_kimber_manwash", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_kimber_manwash", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_kimber_manwash():\n    return pd.read_csv(\n        DATA_DIR / 'greensboro_kimber_soil_manwash.dat',\n        parse_dates=True, index_col='timestamp')\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_kimber_manwash", "return", "pd", "read_csv", "data_dir", "greensboro_kimber_soil_manwash", "dat", "parse_dates", "true", "index_col", "timestamp"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_soiling.py::test_kimber_manwash", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_kimber_manwash", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_kimber_manwash(greensboro_rain, expected_kimber_manwash):\n    \"\"\"Test Kimber soiling model with a manual wash\"\"\"\n    # a manual wash date\n    manwash = [datetime.date(1990, 2, 15), ]\n    # calculate soiling with manual wash\n    manwash = kimber(greensboro_rain, manual_wash_dates=manwash)\n    # test manual wash\n    assert np.allclose(\n        manwash.values,\n        expected_kimber_manwash['soiling'].values)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_kimber_manwash", "greensboro_rain", "expected_kimber_manwash", "test", "kimber", "soiling", "model", "with", "a", "manual", "wash", "a", "manual", "wash", "date", "manwash", "datetime", "date", "1990", "2", "15", "calculate", "soiling", "with", "manual", "wash", "manwash", "kimber", "greensboro_rain", "manual_wash_dates", "manwash", "test", "manual", "wash", "assert", "np", "allclose", "manwash", "values", "expected_kimber_manwash", "soiling", "values"], "doc_len": 47}
{"doc_id": "pvlib/tests/test_soiling.py::expected_kimber_norain", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_kimber_norain", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_kimber_norain():\n    # expected soiling reaches maximum\n    soiling_loss_rate = 0.0015\n    max_loss_rate = 0.3\n    norain = np.ones(8760) * soiling_loss_rate/24\n    norain[0] = 0.0\n    norain = np.cumsum(norain)\n    return np.where(norain > max_loss_rate, max_loss_rate, norain)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_kimber_norain", "expected", "soiling", "reaches", "maximum", "soiling_loss_rate", "0", "0015", "max_loss_rate", "0", "3", "norain", "np", "ones", "8760", "soiling_loss_rate", "24", "norain", "0", "0", "0", "norain", "np", "cumsum", "norain", "return", "np", "where", "norain", "max_loss_rate", "max_loss_rate", "norain"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_soiling.py::test_kimber_norain", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_kimber_norain", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_kimber_norain(greensboro_rain, expected_kimber_norain):\n    \"\"\"Test Kimber soiling model with no rain\"\"\"\n    # a year with no rain\n    norain = pd.Series(0, index=greensboro_rain.index)\n    # calculate soiling with no rain\n    norain = kimber(norain)\n    # test no rain, soiling reaches maximum\n    assert np.allclose(norain.values, expected_kimber_norain)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_kimber_norain", "greensboro_rain", "expected_kimber_norain", "test", "kimber", "soiling", "model", "with", "no", "rain", "a", "year", "with", "no", "rain", "norain", "pd", "series", "0", "index", "greensboro_rain", "index", "calculate", "soiling", "with", "no", "rain", "norain", "kimber", "norain", "test", "no", "rain", "soiling", "reaches", "maximum", "assert", "np", "allclose", "norain", "values", "expected_kimber_norain"], "doc_len": 47}
{"doc_id": "pvlib/tests/test_soiling.py::expected_kimber_initial_soil", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "expected_kimber_initial_soil", "text": "文件路径: pvlib/tests/test_soiling.py\ndef expected_kimber_initial_soil():\n    # expected soiling reaches maximum\n    soiling_loss_rate = 0.0015\n    max_loss_rate = 0.3\n    norain = np.ones(8760) * soiling_loss_rate/24\n    norain[0] = 0.1\n    norain = np.cumsum(norain)\n    return np.where(norain > max_loss_rate, max_loss_rate, norain)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "expected_kimber_initial_soil", "expected", "soiling", "reaches", "maximum", "soiling_loss_rate", "0", "0015", "max_loss_rate", "0", "3", "norain", "np", "ones", "8760", "soiling_loss_rate", "24", "norain", "0", "0", "1", "norain", "np", "cumsum", "norain", "return", "np", "where", "norain", "max_loss_rate", "max_loss_rate", "norain"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_soiling.py::test_kimber_initial_soil", "file_path": "pvlib/tests/test_soiling.py", "class_name": null, "func_name": "test_kimber_initial_soil", "text": "文件路径: pvlib/tests/test_soiling.py\ndef test_kimber_initial_soil(greensboro_rain, expected_kimber_initial_soil):\n    \"\"\"Test Kimber soiling model with initial soiling\"\"\"\n    # a year with no rain\n    norain = pd.Series(0, index=greensboro_rain.index)\n    # calculate soiling with no rain\n    norain = kimber(norain, initial_soiling=0.1)\n    # test no rain, soiling reaches maximum\n    assert np.allclose(norain.values, expected_kimber_initial_soil)\n", "tokens": ["pvlib", "tests", "test_soiling", "py", "def", "test_kimber_initial_soil", "greensboro_rain", "expected_kimber_initial_soil", "test", "kimber", "soiling", "model", "with", "initial", "soiling", "a", "year", "with", "no", "rain", "norain", "pd", "series", "0", "index", "greensboro_rain", "index", "calculate", "soiling", "with", "no", "rain", "norain", "kimber", "norain", "initial_soiling", "0", "1", "test", "no", "rain", "soiling", "reaches", "maximum", "assert", "np", "allclose", "norain", "values", "expected_kimber_initial_soil"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_solarposition.py::expected_solpos_multi", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "expected_solpos_multi", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef expected_solpos_multi():\n    return pd.DataFrame({'elevation': [39.872046, 39.505196],\n                         'apparent_zenith': [50.111622, 50.478260],\n                         'azimuth': [194.340241, 194.311132],\n                         'apparent_elevation': [39.888378, 39.521740]},\n                        index=['2003-10-17T12:30:30Z', '2003-10-18T12:30:30Z'])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "expected_solpos_multi", "return", "pd", "dataframe", "elevation", "39", "872046", "39", "505196", "apparent_zenith", "50", "111622", "50", "478260", "azimuth", "194", "340241", "194", "311132", "apparent_elevation", "39", "888378", "39", "521740", "index", "2003", "10", "17t12", "30", "30z", "2003", "10", "18t12", "30", "30z"], "doc_len": 40}
{"doc_id": "pvlib/tests/test_solarposition.py::expected_rise_set_spa", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "expected_rise_set_spa", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef expected_rise_set_spa():\n    # for Golden, CO, from NREL SPA website\n    times = pd.DatetimeIndex([datetime.datetime(2015, 1, 2),\n                              datetime.datetime(2015, 8, 2),\n                              ]).tz_localize('MST')\n    sunrise = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 7, 21, 55),\n                                datetime.datetime(2015, 8, 2, 5, 0, 27)\n                                ]).tz_localize('MST').tolist()\n    sunset = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 16, 47, 43),\n                               datetime.datetime(2015, 8, 2, 19, 13, 58)\n                               ]).tz_localize('MST').tolist()\n    transit = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 12, 4, 45),\n                                datetime.datetime(2015, 8, 2, 12, 6, 58)\n                                ]).tz_localize('MST').tolist()\n    return pd.DataFrame({'sunrise': sunrise,\n                         'sunset': sunset,\n                         'transit': transit},\n                        index=times)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "expected_rise_set_spa", "for", "golden", "co", "from", "nrel", "spa", "website", "times", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "datetime", "datetime", "2015", "8", "2", "tz_localize", "mst", "sunrise", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "7", "21", "55", "datetime", "datetime", "2015", "8", "2", "5", "0", "27", "tz_localize", "mst", "tolist", "sunset", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "16", "47", "43", "datetime", "datetime", "2015", "8", "2", "19", "13", "58", "tz_localize", "mst", "tolist", "transit", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "12", "4", "45", "datetime", "datetime", "2015", "8", "2", "12", "6", "58", "tz_localize", "mst", "tolist", "return", "pd", "dataframe", "sunrise", "sunrise", "sunset", "sunset", "transit", "transit", "index", "times"], "doc_len": 105}
{"doc_id": "pvlib/tests/test_solarposition.py::expected_rise_set_ephem", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "expected_rise_set_ephem", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef expected_rise_set_ephem():\n    # for Golden, CO, from USNO websites\n    times = pd.DatetimeIndex([datetime.datetime(2015, 1, 1),\n                              datetime.datetime(2015, 1, 2),\n                              datetime.datetime(2015, 1, 3),\n                              datetime.datetime(2015, 8, 2),\n                              ]).tz_localize('MST')\n    sunrise = pd.DatetimeIndex([datetime.datetime(2015, 1, 1, 7, 22, 0),\n                                datetime.datetime(2015, 1, 2, 7, 22, 0),\n                                datetime.datetime(2015, 1, 3, 7, 22, 0),\n                                datetime.datetime(2015, 8, 2, 5, 0, 0)\n                                ]).tz_localize('MST').tolist()\n    sunset = pd.DatetimeIndex([datetime.datetime(2015, 1, 1, 16, 47, 0),\n                               datetime.datetime(2015, 1, 2, 16, 48, 0),\n                               datetime.datetime(2015, 1, 3, 16, 49, 0),\n                               datetime.datetime(2015, 8, 2, 19, 13, 0)\n                               ]).tz_localize('MST').tolist()\n    transit = pd.DatetimeIndex([datetime.datetime(2015, 1, 1, 12, 4, 0),\n                                datetime.datetime(2015, 1, 2, 12, 5, 0),\n                                datetime.datetime(2015, 1, 3, 12, 5, 0),\n                                datetime.datetime(2015, 8, 2, 12, 7, 0)\n                                ]).tz_localize('MST').tolist()\n    return pd.DataFrame({'sunrise': sunrise,\n                         'sunset': sunset,\n                         'transit': transit},\n                        index=times)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "expected_rise_set_ephem", "for", "golden", "co", "from", "usno", "websites", "times", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "1", "datetime", "datetime", "2015", "1", "2", "datetime", "datetime", "2015", "1", "3", "datetime", "datetime", "2015", "8", "2", "tz_localize", "mst", "sunrise", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "1", "7", "22", "0", "datetime", "datetime", "2015", "1", "2", "7", "22", "0", "datetime", "datetime", "2015", "1", "3", "7", "22", "0", "datetime", "datetime", "2015", "8", "2", "5", "0", "0", "tz_localize", "mst", "tolist", "sunset", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "1", "16", "47", "0", "datetime", "datetime", "2015", "1", "2", "16", "48", "0", "datetime", "datetime", "2015", "1", "3", "16", "49", "0", "datetime", "datetime", "2015", "8", "2", "19", "13", "0", "tz_localize", "mst", "tolist", "transit", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "1", "12", "4", "0", "datetime", "datetime", "2015", "1", "2", "12", "5", "0", "datetime", "datetime", "2015", "1", "3", "12", "5", "0", "datetime", "datetime", "2015", "8", "2", "12", "7", "0", "tz_localize", "mst", "tolist", "return", "pd", "dataframe", "sunrise", "sunrise", "sunset", "sunset", "transit", "transit", "index", "times"], "doc_len": 162}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_c_physical", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_c_physical", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_c_physical(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    ephem_data = solarposition.spa_c(times, golden_mst.latitude,\n                                     golden_mst.longitude,\n                                     pressure=82000,\n                                     temperature=11)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_c_physical", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "ephem_data", "solarposition", "spa_c", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_c_physical_dst", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_c_physical_dst", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_c_physical_dst(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.spa_c(times, golden.latitude,\n                                     golden.longitude,\n                                     pressure=82000,\n                                     temperature=11)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_c_physical_dst", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "spa_c", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_python_numpy_physical", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_python_numpy_physical", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_python_numpy_physical(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    ephem_data = solarposition.spa_python(times, golden_mst.latitude,\n                                          golden_mst.longitude,\n                                          pressure=82000,\n                                          temperature=11, delta_t=67,\n                                          atmos_refract=0.5667,\n                                          how='numpy')\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_python_numpy_physical", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "ephem_data", "solarposition", "spa_python", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numpy", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_python_numpy_physical_dst", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_python_numpy_physical_dst", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_python_numpy_physical_dst(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.spa_python(times, golden.latitude,\n                                          golden.longitude,\n                                          pressure=82000,\n                                          temperature=11, delta_t=67,\n                                          atmos_refract=0.5667,\n                                          how='numpy')\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_python_numpy_physical_dst", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "spa_python", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numpy", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_solarposition.py::test_sun_rise_set_transit_spa", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_sun_rise_set_transit_spa", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_sun_rise_set_transit_spa(expected_rise_set_spa, golden):\n    # solution from NREL SAP web calculator\n    south = Location(-35.0, 0.0, tz='UTC')\n    times = pd.DatetimeIndex([datetime.datetime(1996, 7, 5, 0),\n                              datetime.datetime(2004, 12, 4, 0)]\n                             ).tz_localize('UTC')\n    sunrise = pd.DatetimeIndex([datetime.datetime(1996, 7, 5, 7, 8, 15),\n                                datetime.datetime(2004, 12, 4, 4, 38, 57)]\n                               ).tz_localize('UTC').tolist()\n    sunset = pd.DatetimeIndex([datetime.datetime(1996, 7, 5, 17, 1, 4),\n                               datetime.datetime(2004, 12, 4, 19, 2, 3)]\n                              ).tz_localize('UTC').tolist()\n    transit = pd.DatetimeIndex([datetime.datetime(1996, 7, 5, 12, 4, 36),\n                                datetime.datetime(2004, 12, 4, 11, 50, 22)]\n                               ).tz_localize('UTC').tolist()\n    frame = pd.DataFrame({'sunrise': sunrise,\n                          'sunset': sunset,\n                          'transit': transit}, index=times)\n\n    result = solarposition.sun_rise_set_transit_spa(times, south.latitude,\n                                                    south.longitude,\n                                                    delta_t=65.0)\n    result_rounded = pd.DataFrame(index=result.index)\n    # need to iterate because to_datetime does not accept 2D data\n    # the rounding fails on pandas < 0.17\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('1s')\n\n    assert_frame_equal(frame, result_rounded)\n\n    # test for Golden, CO compare to NREL SPA\n    result = solarposition.sun_rise_set_transit_spa(\n        expected_rise_set_spa.index, golden.latitude, golden.longitude,\n        delta_t=65.0)\n\n    # round to nearest minute\n    result_rounded = pd.DataFrame(index=result.index)\n    # need to iterate because to_datetime does not accept 2D data\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('s').tz_convert('MST')\n\n    assert_frame_equal(expected_rise_set_spa, result_rounded)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_sun_rise_set_transit_spa", "expected_rise_set_spa", "golden", "solution", "from", "nrel", "sap", "web", "calculator", "south", "location", "35", "0", "0", "0", "tz", "utc", "times", "pd", "datetimeindex", "datetime", "datetime", "1996", "7", "5", "0", "datetime", "datetime", "2004", "12", "4", "0", "tz_localize", "utc", "sunrise", "pd", "datetimeindex", "datetime", "datetime", "1996", "7", "5", "7", "8", "15", "datetime", "datetime", "2004", "12", "4", "4", "38", "57", "tz_localize", "utc", "tolist", "sunset", "pd", "datetimeindex", "datetime", "datetime", "1996", "7", "5", "17", "1", "4", "datetime", "datetime", "2004", "12", "4", "19", "2", "3", "tz_localize", "utc", "tolist", "transit", "pd", "datetimeindex", "datetime", "datetime", "1996", "7", "5", "12", "4", "36", "datetime", "datetime", "2004", "12", "4", "11", "50", "22", "tz_localize", "utc", "tolist", "frame", "pd", "dataframe", "sunrise", "sunrise", "sunset", "sunset", "transit", "transit", "index", "times", "result", "solarposition", "sun_rise_set_transit_spa", "times", "south", "latitude", "south", "longitude", "delta_t", "65", "0", "result_rounded", "pd", "dataframe", "index", "result", "index", "need", "to", "iterate", "because", "to_datetime", "does", "not", "accept", "2d", "data", "the", "rounding", "fails", "on", "pandas", "0", "17", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "1s", "assert_frame_equal", "frame", "result_rounded", "test", "for", "golden", "co", "compare", "to", "nrel", "spa", "result", "solarposition", "sun_rise_set_transit_spa", "expected_rise_set_spa", "index", "golden", "latitude", "golden", "longitude", "delta_t", "65", "0", "round", "to", "nearest", "minute", "result_rounded", "pd", "dataframe", "index", "result", "index", "need", "to", "iterate", "because", "to_datetime", "does", "not", "accept", "2d", "data", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "s", "tz_convert", "mst", "assert_frame_equal", "expected_rise_set_spa", "result_rounded"], "doc_len": 222}
{"doc_id": "pvlib/tests/test_solarposition.py::test_sun_rise_set_transit_ephem", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_sun_rise_set_transit_ephem", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_sun_rise_set_transit_ephem(expected_rise_set_ephem, golden):\n    # test for Golden, CO compare to USNO, using local midnight\n    result = solarposition.sun_rise_set_transit_ephem(\n        expected_rise_set_ephem.index, golden.latitude, golden.longitude,\n        next_or_previous='next', altitude=golden.altitude, pressure=0,\n        temperature=11, horizon='-0:34')\n    # round to nearest minute\n    result_rounded = pd.DataFrame(index=result.index)\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('min').tz_convert('MST')\n    assert_frame_equal(expected_rise_set_ephem, result_rounded)\n\n    # test next sunrise/sunset with times\n    times = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 3, 0, 0),\n                              datetime.datetime(2015, 1, 2, 10, 15, 0),\n                              datetime.datetime(2015, 1, 2, 15, 3, 0),\n                              datetime.datetime(2015, 1, 2, 21, 6, 7)\n                              ]).tz_localize('MST')\n    expected = pd.DataFrame(index=times,\n                            columns=['sunrise', 'sunset'],\n                            dtype='datetime64[ns]')\n    idx_sunrise = pd.to_datetime(['2015-01-02', '2015-01-03', '2015-01-03',\n                                  '2015-01-03']).tz_localize('MST')\n    expected['sunrise'] = \\\n        expected_rise_set_ephem.loc[idx_sunrise, 'sunrise'].tolist()\n    idx_sunset = pd.to_datetime(['2015-01-02', '2015-01-02', '2015-01-02',\n                                 '2015-01-03']).tz_localize('MST')\n    expected['sunset'] = \\\n        expected_rise_set_ephem.loc[idx_sunset, 'sunset'].tolist()\n    idx_transit = pd.to_datetime(['2015-01-02', '2015-01-02', '2015-01-03',\n                                  '2015-01-03']).tz_localize('MST')\n    expected['transit'] = \\\n        expected_rise_set_ephem.loc[idx_transit, 'transit'].tolist()\n\n    result = solarposition.sun_rise_set_transit_ephem(times,\n                                                      golden.latitude,\n                                                      golden.longitude,\n                                                      next_or_previous='next',\n                                                      altitude=golden.altitude,\n                                                      pressure=0,\n                                                      temperature=11,\n                                                      horizon='-0:34')\n    # round to nearest minute\n    result_rounded = pd.DataFrame(index=result.index)\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('min').tz_convert('MST')\n    assert_frame_equal(expected, result_rounded)\n\n    # test previous sunrise/sunset with times\n    times = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 3, 0, 0),\n                              datetime.datetime(2015, 1, 2, 10, 15, 0),\n                              datetime.datetime(2015, 1, 3, 3, 0, 0),\n                              datetime.datetime(2015, 1, 3, 13, 6, 7)\n                              ]).tz_localize('MST')\n    expected = pd.DataFrame(index=times,\n                            columns=['sunrise', 'sunset'],\n                            dtype='datetime64[ns]')\n    idx_sunrise = pd.to_datetime(['2015-01-01', '2015-01-02', '2015-01-02',\n                                  '2015-01-03']).tz_localize('MST')\n    expected['sunrise'] = \\\n        expected_rise_set_ephem.loc[idx_sunrise, 'sunrise'].tolist()\n    idx_sunset = pd.to_datetime(['2015-01-01', '2015-01-01', '2015-01-02',\n                                 '2015-01-02']).tz_localize('MST')\n    expected['sunset'] = \\\n        expected_rise_set_ephem.loc[idx_sunset, 'sunset'].tolist()\n    idx_transit = pd.to_datetime(['2015-01-01', '2015-01-01', '2015-01-02',\n                                  '2015-01-03']).tz_localize('MST')\n    expected['transit'] = \\\n        expected_rise_set_ephem.loc[idx_transit, 'transit'].tolist()\n\n    result = solarposition.sun_rise_set_transit_ephem(\n        times,\n        golden.latitude, golden.longitude, next_or_previous='previous',\n        altitude=golden.altitude, pressure=0, temperature=11, horizon='-0:34')\n    # round to nearest minute\n    result_rounded = pd.DataFrame(index=result.index)\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('min').tz_convert('MST')\n    assert_frame_equal(expected, result_rounded)\n\n    # test with different timezone\n    times = times.tz_convert('UTC')\n    expected = expected.tz_convert('UTC')  # resuse result from previous\n    for col, data in expected.iteritems():\n        expected[col] = data.dt.tz_convert('UTC')\n    result = solarposition.sun_rise_set_transit_ephem(\n        times,\n        golden.latitude, golden.longitude, next_or_previous='previous',\n        altitude=golden.altitude, pressure=0, temperature=11, horizon='-0:34')\n    # round to nearest minute\n    result_rounded = pd.DataFrame(index=result.index)\n    for col, data in result.iteritems():\n        result_rounded[col] = data.dt.round('min').tz_convert(times.tz)\n    assert_frame_equal(expected, result_rounded)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_sun_rise_set_transit_ephem", "expected_rise_set_ephem", "golden", "test", "for", "golden", "co", "compare", "to", "usno", "using", "local", "midnight", "result", "solarposition", "sun_rise_set_transit_ephem", "expected_rise_set_ephem", "index", "golden", "latitude", "golden", "longitude", "next_or_previous", "next", "altitude", "golden", "altitude", "pressure", "0", "temperature", "11", "horizon", "0", "34", "round", "to", "nearest", "minute", "result_rounded", "pd", "dataframe", "index", "result", "index", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "min", "tz_convert", "mst", "assert_frame_equal", "expected_rise_set_ephem", "result_rounded", "test", "next", "sunrise", "sunset", "with", "times", "times", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "3", "0", "0", "datetime", "datetime", "2015", "1", "2", "10", "15", "0", "datetime", "datetime", "2015", "1", "2", "15", "3", "0", "datetime", "datetime", "2015", "1", "2", "21", "6", "7", "tz_localize", "mst", "expected", "pd", "dataframe", "index", "times", "columns", "sunrise", "sunset", "dtype", "datetime64", "ns", "idx_sunrise", "pd", "to_datetime", "2015", "01", "02", "2015", "01", "03", "2015", "01", "03", "2015", "01", "03", "tz_localize", "mst", "expected", "sunrise", "expected_rise_set_ephem", "loc", "idx_sunrise", "sunrise", "tolist", "idx_sunset", "pd", "to_datetime", "2015", "01", "02", "2015", "01", "02", "2015", "01", "02", "2015", "01", "03", "tz_localize", "mst", "expected", "sunset", "expected_rise_set_ephem", "loc", "idx_sunset", "sunset", "tolist", "idx_transit", "pd", "to_datetime", "2015", "01", "02", "2015", "01", "02", "2015", "01", "03", "2015", "01", "03", "tz_localize", "mst", "expected", "transit", "expected_rise_set_ephem", "loc", "idx_transit", "transit", "tolist", "result", "solarposition", "sun_rise_set_transit_ephem", "times", "golden", "latitude", "golden", "longitude", "next_or_previous", "next", "altitude", "golden", "altitude", "pressure", "0", "temperature", "11", "horizon", "0", "34", "round", "to", "nearest", "minute", "result_rounded", "pd", "dataframe", "index", "result", "index", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "min", "tz_convert", "mst", "assert_frame_equal", "expected", "result_rounded", "test", "previous", "sunrise", "sunset", "with", "times", "times", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "3", "0", "0", "datetime", "datetime", "2015", "1", "2", "10", "15", "0", "datetime", "datetime", "2015", "1", "3", "3", "0", "0", "datetime", "datetime", "2015", "1", "3", "13", "6", "7", "tz_localize", "mst", "expected", "pd", "dataframe", "index", "times", "columns", "sunrise", "sunset", "dtype", "datetime64", "ns", "idx_sunrise", "pd", "to_datetime", "2015", "01", "01", "2015", "01", "02", "2015", "01", "02", "2015", "01", "03", "tz_localize", "mst", "expected", "sunrise", "expected_rise_set_ephem", "loc", "idx_sunrise", "sunrise", "tolist", "idx_sunset", "pd", "to_datetime", "2015", "01", "01", "2015", "01", "01", "2015", "01", "02", "2015", "01", "02", "tz_localize", "mst", "expected", "sunset", "expected_rise_set_ephem", "loc", "idx_sunset", "sunset", "tolist", "idx_transit", "pd", "to_datetime", "2015", "01", "01", "2015", "01", "01", "2015", "01", "02", "2015", "01", "03", "tz_localize", "mst", "expected", "transit", "expected_rise_set_ephem", "loc", "idx_transit", "transit", "tolist", "result", "solarposition", "sun_rise_set_transit_ephem", "times", "golden", "latitude", "golden", "longitude", "next_or_previous", "previous", "altitude", "golden", "altitude", "pressure", "0", "temperature", "11", "horizon", "0", "34", "round", "to", "nearest", "minute", "result_rounded", "pd", "dataframe", "index", "result", "index", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "min", "tz_convert", "mst", "assert_frame_equal", "expected", "result_rounded", "test", "with", "different", "timezone", "times", "times", "tz_convert", "utc", "expected", "expected", "tz_convert", "utc", "resuse", "result", "from", "previous", "for", "col", "data", "in", "expected", "iteritems", "expected", "col", "data", "dt", "tz_convert", "utc", "result", "solarposition", "sun_rise_set_transit_ephem", "times", "golden", "latitude", "golden", "longitude", "next_or_previous", "previous", "altitude", "golden", "altitude", "pressure", "0", "temperature", "11", "horizon", "0", "34", "round", "to", "nearest", "minute", "result_rounded", "pd", "dataframe", "index", "result", "index", "for", "col", "data", "in", "result", "iteritems", "result_rounded", "col", "data", "dt", "round", "min", "tz_convert", "times", "tz", "assert_frame_equal", "expected", "result_rounded"], "doc_len": 488}
{"doc_id": "pvlib/tests/test_solarposition.py::test_sun_rise_set_transit_ephem_error", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_sun_rise_set_transit_ephem_error", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_sun_rise_set_transit_ephem_error(expected_rise_set_ephem, golden):\n    with pytest.raises(ValueError):\n        solarposition.sun_rise_set_transit_ephem(expected_rise_set_ephem.index,\n                                                 golden.latitude,\n                                                 golden.longitude,\n                                                 next_or_previous='other')\n    tz_naive = pd.DatetimeIndex([datetime.datetime(2015, 1, 2, 3, 0, 0)])\n    with pytest.raises(ValueError):\n        solarposition.sun_rise_set_transit_ephem(tz_naive,\n                                                 golden.latitude,\n                                                 golden.longitude,\n                                                 next_or_previous='next')\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_sun_rise_set_transit_ephem_error", "expected_rise_set_ephem", "golden", "with", "pytest", "raises", "valueerror", "solarposition", "sun_rise_set_transit_ephem", "expected_rise_set_ephem", "index", "golden", "latitude", "golden", "longitude", "next_or_previous", "other", "tz_naive", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "3", "0", "0", "with", "pytest", "raises", "valueerror", "solarposition", "sun_rise_set_transit_ephem", "tz_naive", "golden", "latitude", "golden", "longitude", "next_or_previous", "next"], "doc_len": 46}
{"doc_id": "pvlib/tests/test_solarposition.py::test_sun_rise_set_transit_ephem_horizon", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_sun_rise_set_transit_ephem_horizon", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_sun_rise_set_transit_ephem_horizon(golden):\n    times = pd.DatetimeIndex([datetime.datetime(2016, 1, 3, 0, 0, 0)\n                              ]).tz_localize('MST')\n    # center of sun disk\n    center = solarposition.sun_rise_set_transit_ephem(\n        times,\n        latitude=golden.latitude, longitude=golden.longitude)\n    edge = solarposition.sun_rise_set_transit_ephem(\n        times,\n        latitude=golden.latitude, longitude=golden.longitude, horizon='-0:34')\n    result_rounded = (edge['sunrise'] - center['sunrise']).dt.round('min')\n\n    sunrise_delta = datetime.datetime(2016, 1, 3, 7, 17, 11) - \\\n        datetime.datetime(2016, 1, 3, 7, 21, 33)\n    expected = pd.Series(index=times,\n                         data=sunrise_delta,\n                         name='sunrise').dt.round('min')\n    assert_series_equal(expected, result_rounded)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_sun_rise_set_transit_ephem_horizon", "golden", "times", "pd", "datetimeindex", "datetime", "datetime", "2016", "1", "3", "0", "0", "0", "tz_localize", "mst", "center", "of", "sun", "disk", "center", "solarposition", "sun_rise_set_transit_ephem", "times", "latitude", "golden", "latitude", "longitude", "golden", "longitude", "edge", "solarposition", "sun_rise_set_transit_ephem", "times", "latitude", "golden", "latitude", "longitude", "golden", "longitude", "horizon", "0", "34", "result_rounded", "edge", "sunrise", "center", "sunrise", "dt", "round", "min", "sunrise_delta", "datetime", "datetime", "2016", "1", "3", "7", "17", "11", "datetime", "datetime", "2016", "1", "3", "7", "21", "33", "expected", "pd", "series", "index", "times", "data", "sunrise_delta", "name", "sunrise", "dt", "round", "min", "assert_series_equal", "expected", "result_rounded"], "doc_len": 87}
{"doc_id": "pvlib/tests/test_solarposition.py::test_pyephem_physical", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_pyephem_physical", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_pyephem_physical(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    ephem_data = solarposition.pyephem(times, golden_mst.latitude,\n                                       golden_mst.longitude, pressure=82000,\n                                       temperature=11)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos.round(2),\n                       ephem_data[expected_solpos.columns].round(2))\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_pyephem_physical", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "ephem_data", "solarposition", "pyephem", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "round", "2", "ephem_data", "expected_solpos", "columns", "round", "2"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_solarposition.py::test_pyephem_physical_dst", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_pyephem_physical_dst", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_pyephem_physical_dst(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.pyephem(times, golden.latitude,\n                                       golden.longitude, pressure=82000,\n                                       temperature=11)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos.round(2),\n                       ephem_data[expected_solpos.columns].round(2))\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_pyephem_physical_dst", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "pyephem", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "round", "2", "ephem_data", "expected_solpos", "columns", "round", "2"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_solarposition.py::test_calc_time", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_calc_time", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_calc_time():\n    import pytz\n    import math\n    # validation from USNO solar position calculator online\n\n    epoch = datetime.datetime(1970, 1, 1)\n    epoch_dt = pytz.utc.localize(epoch)\n\n    loc = tus\n    loc.pressure = 0\n    actual_time = pytz.timezone(loc.tz).localize(\n        datetime.datetime(2014, 10, 10, 8, 30))\n    lb = pytz.timezone(loc.tz).localize(datetime.datetime(2014, 10, 10, tol))\n    ub = pytz.timezone(loc.tz).localize(datetime.datetime(2014, 10, 10, 10))\n    alt = solarposition.calc_time(lb, ub, loc.latitude, loc.longitude,\n                                  'alt', math.radians(24.7))\n    az = solarposition.calc_time(lb, ub, loc.latitude, loc.longitude,\n                                 'az', math.radians(116.3))\n    actual_timestamp = (actual_time - epoch_dt).total_seconds()\n\n    assert_allclose((alt.replace(second=0, microsecond=0) -\n                     epoch_dt).total_seconds(), actual_timestamp)\n    assert_allclose((az.replace(second=0, microsecond=0) -\n                     epoch_dt).total_seconds(), actual_timestamp)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_calc_time", "import", "pytz", "import", "math", "validation", "from", "usno", "solar", "position", "calculator", "online", "epoch", "datetime", "datetime", "1970", "1", "1", "epoch_dt", "pytz", "utc", "localize", "epoch", "loc", "tus", "loc", "pressure", "0", "actual_time", "pytz", "timezone", "loc", "tz", "localize", "datetime", "datetime", "2014", "10", "10", "8", "30", "lb", "pytz", "timezone", "loc", "tz", "localize", "datetime", "datetime", "2014", "10", "10", "tol", "ub", "pytz", "timezone", "loc", "tz", "localize", "datetime", "datetime", "2014", "10", "10", "10", "alt", "solarposition", "calc_time", "lb", "ub", "loc", "latitude", "loc", "longitude", "alt", "math", "radians", "24", "7", "az", "solarposition", "calc_time", "lb", "ub", "loc", "latitude", "loc", "longitude", "az", "math", "radians", "116", "3", "actual_timestamp", "actual_time", "epoch_dt", "total_seconds", "assert_allclose", "alt", "replace", "second", "0", "microsecond", "0", "epoch_dt", "total_seconds", "actual_timestamp", "assert_allclose", "az", "replace", "second", "0", "microsecond", "0", "epoch_dt", "total_seconds", "actual_timestamp"], "doc_len": 122}
{"doc_id": "pvlib/tests/test_solarposition.py::test_earthsun_distance", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_earthsun_distance", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_earthsun_distance():\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D')\n    distance = solarposition.pyephem_earthsun_distance(times).values[0]\n    assert_allclose(1, distance, atol=0.1)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_earthsun_distance", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "distance", "solarposition", "pyephem_earthsun_distance", "times", "values", "0", "assert_allclose", "1", "distance", "atol", "0", "1"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_solarposition.py::test_ephemeris_physical", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_ephemeris_physical", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_ephemeris_physical(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    ephem_data = solarposition.ephemeris(times, golden_mst.latitude,\n                                         golden_mst.longitude,\n                                         pressure=82000,\n                                         temperature=11)\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 2)\n    ephem_data = np.round(ephem_data, 2)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_ephemeris_physical", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "ephem_data", "solarposition", "ephemeris", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "2", "ephem_data", "np", "round", "ephem_data", "2", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_solarposition.py::test_ephemeris_physical_dst", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_ephemeris_physical_dst", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_ephemeris_physical_dst(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.ephemeris(times, golden.latitude,\n                                         golden.longitude, pressure=82000,\n                                         temperature=11)\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 2)\n    ephem_data = np.round(ephem_data, 2)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_ephemeris_physical_dst", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "ephemeris", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "2", "ephem_data", "np", "round", "ephem_data", "2", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_solarposition.py::test_ephemeris_physical_no_tz", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_ephemeris_physical_no_tz", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_ephemeris_physical_no_tz(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 19, 30, 30),\n                          periods=1, freq='D')\n    ephem_data = solarposition.ephemeris(times, golden_mst.latitude,\n                                         golden_mst.longitude,\n                                         pressure=82000,\n                                         temperature=11)\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 2)\n    ephem_data = np.round(ephem_data, 2)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_ephemeris_physical_no_tz", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "19", "30", "30", "periods", "1", "freq", "d", "ephem_data", "solarposition", "ephemeris", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "2", "ephem_data", "np", "round", "ephem_data", "2", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_error", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_error", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_error(golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    with pytest.raises(ValueError):\n        solarposition.get_solarposition(times, golden.latitude,\n                                        golden.longitude,\n                                        pressure=82000,\n                                        temperature=11,\n                                        method='error this')\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_error", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "with", "pytest", "raises", "valueerror", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "method", "error", "this"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_pressure", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_pressure", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_pressure(\n        pressure, expected, golden, expected_solpos):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.get_solarposition(times, golden.latitude,\n                                                 golden.longitude,\n                                                 pressure=pressure,\n                                                 temperature=11)\n    if isinstance(expected, str) and expected == 'expected_solpos':\n        expected = expected_solpos\n    this_expected = expected.copy()\n    this_expected.index = times\n    this_expected = np.round(this_expected, 5)\n    ephem_data = np.round(ephem_data, 5)\n    assert_frame_equal(this_expected, ephem_data[this_expected.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_pressure", "pressure", "expected", "golden", "expected_solpos", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "pressure", "pressure", "temperature", "11", "if", "isinstance", "expected", "str", "and", "expected", "expected_solpos", "expected", "expected_solpos", "this_expected", "expected", "copy", "this_expected", "index", "times", "this_expected", "np", "round", "this_expected", "5", "ephem_data", "np", "round", "ephem_data", "5", "assert_frame_equal", "this_expected", "ephem_data", "this_expected", "columns"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_altitude", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_altitude", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_altitude(\n        altitude, expected, golden, expected_solpos):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.get_solarposition(times, golden.latitude,\n                                                 golden.longitude,\n                                                 altitude=altitude,\n                                                 temperature=11)\n    if isinstance(expected, str) and expected == 'expected_solpos':\n        expected = expected_solpos\n    this_expected = expected.copy()\n    this_expected.index = times\n    this_expected = np.round(this_expected, 5)\n    ephem_data = np.round(ephem_data, 5)\n    assert_frame_equal(this_expected, ephem_data[this_expected.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_altitude", "altitude", "expected", "golden", "expected_solpos", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "altitude", "altitude", "temperature", "11", "if", "isinstance", "expected", "str", "and", "expected", "expected_solpos", "expected", "expected_solpos", "this_expected", "expected", "copy", "this_expected", "index", "times", "this_expected", "np", "round", "this_expected", "5", "ephem_data", "np", "round", "ephem_data", "5", "assert_frame_equal", "this_expected", "ephem_data", "this_expected", "columns"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_deltat", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_deltat", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_deltat(delta_t, method, expected_solpos_multi,\n                                  golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=2, freq='D', tz=golden.tz)\n    with warnings.catch_warnings():\n        # don't warn on method reload or num threads\n        warnings.simplefilter(\"ignore\")\n        ephem_data = solarposition.get_solarposition(times, golden.latitude,\n                                                     golden.longitude,\n                                                     pressure=82000,\n                                                     delta_t=delta_t,\n                                                     temperature=11,\n                                                     method=method)\n    this_expected = expected_solpos_multi\n    this_expected.index = times\n    this_expected = np.round(this_expected, 5)\n    ephem_data = np.round(ephem_data, 5)\n    assert_frame_equal(this_expected, ephem_data[this_expected.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_deltat", "delta_t", "method", "expected_solpos_multi", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "2", "freq", "d", "tz", "golden", "tz", "with", "warnings", "catch_warnings", "don", "t", "warn", "on", "method", "reload", "or", "num", "threads", "warnings", "simplefilter", "ignore", "ephem_data", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "delta_t", "delta_t", "temperature", "11", "method", "method", "this_expected", "expected_solpos_multi", "this_expected", "index", "times", "this_expected", "np", "round", "this_expected", "5", "ephem_data", "np", "round", "ephem_data", "5", "assert_frame_equal", "this_expected", "ephem_data", "this_expected", "columns"], "doc_len": 79}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_no_kwargs", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_no_kwargs", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_no_kwargs(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.get_solarposition(times, golden.latitude,\n                                                 golden.longitude)\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 2)\n    ephem_data = np.round(ephem_data, 2)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_no_kwargs", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "2", "ephem_data", "np", "round", "ephem_data", "2", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 52}
{"doc_id": "pvlib/tests/test_solarposition.py::test_get_solarposition_method_pyephem", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_get_solarposition_method_pyephem", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_get_solarposition_method_pyephem(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n    ephem_data = solarposition.get_solarposition(times, golden.latitude,\n                                                 golden.longitude,\n                                                 method='pyephem')\n    expected_solpos.index = times\n    expected_solpos = np.round(expected_solpos, 2)\n    ephem_data = np.round(ephem_data, 2)\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_get_solarposition_method_pyephem", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "ephem_data", "solarposition", "get_solarposition", "times", "golden", "latitude", "golden", "longitude", "method", "pyephem", "expected_solpos", "index", "times", "expected_solpos", "np", "round", "expected_solpos", "2", "ephem_data", "np", "round", "ephem_data", "2", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_solarposition.py::test_nrel_earthsun_distance", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_nrel_earthsun_distance", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_nrel_earthsun_distance():\n    times = pd.DatetimeIndex([datetime.datetime(2015, 1, 2),\n                              datetime.datetime(2015, 8, 2)]\n                             ).tz_localize('MST')\n    result = solarposition.nrel_earthsun_distance(times, delta_t=64.0)\n    expected = pd.Series(np.array([0.983289204601, 1.01486146446]),\n                         index=times)\n    assert_series_equal(expected, result)\n\n    times = datetime.datetime(2015, 1, 2)\n    result = solarposition.nrel_earthsun_distance(times, delta_t=64.0)\n    expected = pd.Series(np.array([0.983289204601]),\n                         index=pd.DatetimeIndex([times, ]))\n    assert_series_equal(expected, result)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_nrel_earthsun_distance", "times", "pd", "datetimeindex", "datetime", "datetime", "2015", "1", "2", "datetime", "datetime", "2015", "8", "2", "tz_localize", "mst", "result", "solarposition", "nrel_earthsun_distance", "times", "delta_t", "64", "0", "expected", "pd", "series", "np", "array", "0", "983289204601", "1", "01486146446", "index", "times", "assert_series_equal", "expected", "result", "times", "datetime", "datetime", "2015", "1", "2", "result", "solarposition", "nrel_earthsun_distance", "times", "delta_t", "64", "0", "expected", "pd", "series", "np", "array", "0", "983289204601", "index", "pd", "datetimeindex", "times", "assert_series_equal", "expected", "result"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_solarposition.py::test_equation_of_time", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_equation_of_time", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_equation_of_time():\n    times = pd.date_range(start=\"1/1/2015 0:00\", end=\"12/31/2015 23:00\",\n                          freq=\"H\")\n    output = solarposition.spa_python(times, 37.8, -122.25, 100)\n    eot = output['equation_of_time']\n    eot_rng = eot.max() - eot.min()  # range of values, around 30 minutes\n    eot_1 = solarposition.equation_of_time_spencer71(times.dayofyear)\n    eot_2 = solarposition.equation_of_time_pvcdrom(times.dayofyear)\n    assert np.allclose(eot_1 / eot_rng, eot / eot_rng, atol=0.3)  # spencer\n    assert np.allclose(eot_2 / eot_rng, eot / eot_rng, atol=0.4)  # pvcdrom\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_equation_of_time", "times", "pd", "date_range", "start", "1", "1", "2015", "0", "00", "end", "12", "31", "2015", "23", "00", "freq", "h", "output", "solarposition", "spa_python", "times", "37", "8", "122", "25", "100", "eot", "output", "equation_of_time", "eot_rng", "eot", "max", "eot", "min", "range", "of", "values", "around", "30", "minutes", "eot_1", "solarposition", "equation_of_time_spencer71", "times", "dayofyear", "eot_2", "solarposition", "equation_of_time_pvcdrom", "times", "dayofyear", "assert", "np", "allclose", "eot_1", "eot_rng", "eot", "eot_rng", "atol", "0", "3", "spencer", "assert", "np", "allclose", "eot_2", "eot_rng", "eot", "eot_rng", "atol", "0", "4", "pvcdrom"], "doc_len": 78}
{"doc_id": "pvlib/tests/test_solarposition.py::test_declination", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_declination", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_declination():\n    times = pd.date_range(start=\"1/1/2015 0:00\", end=\"12/31/2015 23:00\",\n                          freq=\"H\")\n    atmos_refract = 0.5667\n    delta_t = spa.calculate_deltat(times.year, times.month)\n    unixtime = np.array([calendar.timegm(t.timetuple()) for t in times])\n    _, _, declination = spa.solar_position(unixtime, 37.8, -122.25, 100,\n                                           1013.25, 25, delta_t, atmos_refract,\n                                           sst=True)\n    declination = np.deg2rad(declination)\n    declination_rng = declination.max() - declination.min()\n    declination_1 = solarposition.declination_cooper69(times.dayofyear)\n    declination_2 = solarposition.declination_spencer71(times.dayofyear)\n    a, b = declination_1 / declination_rng, declination / declination_rng\n    assert np.allclose(a, b, atol=0.03)  # cooper\n    a, b = declination_2 / declination_rng, declination / declination_rng\n    assert np.allclose(a, b, atol=0.02)  # spencer\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_declination", "times", "pd", "date_range", "start", "1", "1", "2015", "0", "00", "end", "12", "31", "2015", "23", "00", "freq", "h", "atmos_refract", "0", "5667", "delta_t", "spa", "calculate_deltat", "times", "year", "times", "month", "unixtime", "np", "array", "calendar", "timegm", "t", "timetuple", "for", "t", "in", "times", "_", "_", "declination", "spa", "solar_position", "unixtime", "37", "8", "122", "25", "100", "1013", "25", "25", "delta_t", "atmos_refract", "sst", "true", "declination", "np", "deg2rad", "declination", "declination_rng", "declination", "max", "declination", "min", "declination_1", "solarposition", "declination_cooper69", "times", "dayofyear", "declination_2", "solarposition", "declination_spencer71", "times", "dayofyear", "a", "b", "declination_1", "declination_rng", "declination", "declination_rng", "assert", "np", "allclose", "a", "b", "atol", "0", "03", "cooper", "a", "b", "declination_2", "declination_rng", "declination", "declination_rng", "assert", "np", "allclose", "a", "b", "atol", "0", "02", "spencer"], "doc_len": 111}
{"doc_id": "pvlib/tests/test_solarposition.py::test_analytical_zenith", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_analytical_zenith", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_analytical_zenith():\n    times = pd.date_range(start=\"1/1/2015 0:00\", end=\"12/31/2015 23:00\",\n                          freq=\"H\").tz_localize('Etc/GMT+8')\n    lat, lon = 37.8, -122.25\n    lat_rad = np.deg2rad(lat)\n    output = solarposition.spa_python(times, lat, lon, 100)\n    solar_zenith = np.deg2rad(output['zenith'])  # spa\n    # spencer\n    eot = solarposition.equation_of_time_spencer71(times.dayofyear)\n    hour_angle = np.deg2rad(solarposition.hour_angle(times, lon, eot))\n    decl = solarposition.declination_spencer71(times.dayofyear)\n    zenith_1 = solarposition.solar_zenith_analytical(lat_rad, hour_angle, decl)\n    # pvcdrom and cooper\n    eot = solarposition.equation_of_time_pvcdrom(times.dayofyear)\n    hour_angle = np.deg2rad(solarposition.hour_angle(times, lon, eot))\n    decl = solarposition.declination_cooper69(times.dayofyear)\n    zenith_2 = solarposition.solar_zenith_analytical(lat_rad, hour_angle, decl)\n    assert np.allclose(zenith_1, solar_zenith, atol=0.015)\n    assert np.allclose(zenith_2, solar_zenith, atol=0.025)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_analytical_zenith", "times", "pd", "date_range", "start", "1", "1", "2015", "0", "00", "end", "12", "31", "2015", "23", "00", "freq", "h", "tz_localize", "etc", "gmt", "8", "lat", "lon", "37", "8", "122", "25", "lat_rad", "np", "deg2rad", "lat", "output", "solarposition", "spa_python", "times", "lat", "lon", "100", "solar_zenith", "np", "deg2rad", "output", "zenith", "spa", "spencer", "eot", "solarposition", "equation_of_time_spencer71", "times", "dayofyear", "hour_angle", "np", "deg2rad", "solarposition", "hour_angle", "times", "lon", "eot", "decl", "solarposition", "declination_spencer71", "times", "dayofyear", "zenith_1", "solarposition", "solar_zenith_analytical", "lat_rad", "hour_angle", "decl", "pvcdrom", "and", "cooper", "eot", "solarposition", "equation_of_time_pvcdrom", "times", "dayofyear", "hour_angle", "np", "deg2rad", "solarposition", "hour_angle", "times", "lon", "eot", "decl", "solarposition", "declination_cooper69", "times", "dayofyear", "zenith_2", "solarposition", "solar_zenith_analytical", "lat_rad", "hour_angle", "decl", "assert", "np", "allclose", "zenith_1", "solar_zenith", "atol", "0", "015", "assert", "np", "allclose", "zenith_2", "solar_zenith", "atol", "0", "025"], "doc_len": 118}
{"doc_id": "pvlib/tests/test_solarposition.py::test_analytical_azimuth", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_analytical_azimuth", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_analytical_azimuth():\n    times = pd.date_range(start=\"1/1/2015 0:00\", end=\"12/31/2015 23:00\",\n                          freq=\"H\").tz_localize('Etc/GMT+8')\n    lat, lon = 37.8, -122.25\n    lat_rad = np.deg2rad(lat)\n    output = solarposition.spa_python(times, lat, lon, 100)\n    solar_azimuth = np.deg2rad(output['azimuth'])  # spa\n    solar_zenith = np.deg2rad(output['zenith'])\n    # spencer\n    eot = solarposition.equation_of_time_spencer71(times.dayofyear)\n    hour_angle = np.deg2rad(solarposition.hour_angle(times, lon, eot))\n    decl = solarposition.declination_spencer71(times.dayofyear)\n    zenith = solarposition.solar_zenith_analytical(lat_rad, hour_angle, decl)\n    azimuth_1 = solarposition.solar_azimuth_analytical(lat_rad, hour_angle,\n                                                       decl, zenith)\n    # pvcdrom and cooper\n    eot = solarposition.equation_of_time_pvcdrom(times.dayofyear)\n    hour_angle = np.deg2rad(solarposition.hour_angle(times, lon, eot))\n    decl = solarposition.declination_cooper69(times.dayofyear)\n    zenith = solarposition.solar_zenith_analytical(lat_rad, hour_angle, decl)\n    azimuth_2 = solarposition.solar_azimuth_analytical(lat_rad, hour_angle,\n                                                       decl, zenith)\n\n    idx = np.where(solar_zenith < np.pi/2)\n    assert np.allclose(azimuth_1[idx], solar_azimuth.values[idx], atol=0.01)\n    assert np.allclose(azimuth_2[idx], solar_azimuth.values[idx], atol=0.017)\n\n    # test for NaN values at boundary conditions (PR #431)\n    test_angles = np.radians(np.array(\n                   [[   0., -180.,  -20.],\n                    [   0.,    0.,   -5.],\n                    [   0.,    0.,    0.],\n                    [   0.,    0.,   15.],\n                    [   0.,  180.,   20.],\n                    [  30.,    0.,  -20.],\n                    [  30.,    0.,   -5.],\n                    [  30.,    0.,    0.],\n                    [  30.,  180.,    5.],\n                    [  30.,    0.,   10.],\n                    [ -30.,    0.,  -20.],\n                    [ -30.,    0.,  -15.],\n                    [ -30.,    0.,    0.],\n                    [ -30., -180.,    5.],\n                    [ -30.,  180.,   10.]]))\n\n    zeniths = solarposition.solar_zenith_analytical(*test_angles.T)\n    azimuths = solarposition.solar_azimuth_analytical(*test_angles.T,\n                                                      zenith=zeniths)\n\n    assert not np.isnan(azimuths).any()\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_analytical_azimuth", "times", "pd", "date_range", "start", "1", "1", "2015", "0", "00", "end", "12", "31", "2015", "23", "00", "freq", "h", "tz_localize", "etc", "gmt", "8", "lat", "lon", "37", "8", "122", "25", "lat_rad", "np", "deg2rad", "lat", "output", "solarposition", "spa_python", "times", "lat", "lon", "100", "solar_azimuth", "np", "deg2rad", "output", "azimuth", "spa", "solar_zenith", "np", "deg2rad", "output", "zenith", "spencer", "eot", "solarposition", "equation_of_time_spencer71", "times", "dayofyear", "hour_angle", "np", "deg2rad", "solarposition", "hour_angle", "times", "lon", "eot", "decl", "solarposition", "declination_spencer71", "times", "dayofyear", "zenith", "solarposition", "solar_zenith_analytical", "lat_rad", "hour_angle", "decl", "azimuth_1", "solarposition", "solar_azimuth_analytical", "lat_rad", "hour_angle", "decl", "zenith", "pvcdrom", "and", "cooper", "eot", "solarposition", "equation_of_time_pvcdrom", "times", "dayofyear", "hour_angle", "np", "deg2rad", "solarposition", "hour_angle", "times", "lon", "eot", "decl", "solarposition", "declination_cooper69", "times", "dayofyear", "zenith", "solarposition", "solar_zenith_analytical", "lat_rad", "hour_angle", "decl", "azimuth_2", "solarposition", "solar_azimuth_analytical", "lat_rad", "hour_angle", "decl", "zenith", "idx", "np", "where", "solar_zenith", "np", "pi", "2", "assert", "np", "allclose", "azimuth_1", "idx", "solar_azimuth", "values", "idx", "atol", "0", "01", "assert", "np", "allclose", "azimuth_2", "idx", "solar_azimuth", "values", "idx", "atol", "0", "017", "test", "for", "nan", "values", "at", "boundary", "conditions", "pr", "431", "test_angles", "np", "radians", "np", "array", "0", "180", "20", "0", "0", "5", "0", "0", "0", "0", "0", "15", "0", "180", "20", "30", "0", "20", "30", "0", "5", "30", "0", "0", "30", "180", "5", "30", "0", "10", "30", "0", "20", "30", "0", "15", "30", "0", "0", "30", "180", "5", "30", "180", "10", "zeniths", "solarposition", "solar_zenith_analytical", "test_angles", "t", "azimuths", "solarposition", "solar_azimuth_analytical", "test_angles", "t", "zenith", "zeniths", "assert", "not", "np", "isnan", "azimuths", "any"], "doc_len": 227}
{"doc_id": "pvlib/tests/test_solarposition.py::test_hour_angle", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_hour_angle", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_hour_angle():\n    \"\"\"\n    Test conversion from hours to hour angles in degrees given the following\n    inputs from NREL SPA calculator at Golden, CO\n    date,times,eot,sunrise,sunset\n    1/2/2015,7:21:55,-3.935172,-70.699400,70.512721\n    1/2/2015,16:47:43,-4.117227,-70.699400,70.512721\n    1/2/2015,12:04:45,-4.026295,-70.699400,70.512721\n    \"\"\"\n    longitude = -105.1786  # degrees\n    times = pd.DatetimeIndex([\n        '2015-01-02 07:21:55.2132',\n        '2015-01-02 16:47:42.9828',\n        '2015-01-02 12:04:44.6340'\n    ]).tz_localize('Etc/GMT+7')\n    eot = np.array([-3.935172, -4.117227, -4.026295])\n    hours = solarposition.hour_angle(times, longitude, eot)\n    expected = (-70.682338, 70.72118825000001, 0.000801250)\n    # FIXME: there are differences from expected NREL SPA calculator values\n    # sunrise: 4 seconds, sunset: 48 seconds, transit: 0.2 seconds\n    # but the differences may be due to other SPA input parameters\n    assert np.allclose(hours, expected)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_hour_angle", "test", "conversion", "from", "hours", "to", "hour", "angles", "in", "degrees", "given", "the", "following", "inputs", "from", "nrel", "spa", "calculator", "at", "golden", "co", "date", "times", "eot", "sunrise", "sunset", "1", "2", "2015", "7", "21", "55", "3", "935172", "70", "699400", "70", "512721", "1", "2", "2015", "16", "47", "43", "4", "117227", "70", "699400", "70", "512721", "1", "2", "2015", "12", "04", "45", "4", "026295", "70", "699400", "70", "512721", "longitude", "105", "1786", "degrees", "times", "pd", "datetimeindex", "2015", "01", "02", "07", "21", "55", "2132", "2015", "01", "02", "16", "47", "42", "9828", "2015", "01", "02", "12", "04", "44", "6340", "tz_localize", "etc", "gmt", "7", "eot", "np", "array", "3", "935172", "4", "117227", "4", "026295", "hours", "solarposition", "hour_angle", "times", "longitude", "eot", "expected", "70", "682338", "70", "72118825000001", "0", "000801250", "fixme", "there", "are", "differences", "from", "expected", "nrel", "spa", "calculator", "values", "sunrise", "4", "seconds", "sunset", "48", "seconds", "transit", "0", "2", "seconds", "but", "the", "differences", "may", "be", "due", "to", "other", "spa", "input", "parameters", "assert", "np", "allclose", "hours", "expected"], "doc_len": 157}
{"doc_id": "pvlib/tests/test_solarposition.py::test_sun_rise_set_transit_geometric", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_sun_rise_set_transit_geometric", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_sun_rise_set_transit_geometric(expected_rise_set_spa, golden_mst):\n    \"\"\"Test geometric calculations for sunrise, sunset, and transit times\"\"\"\n    times = expected_rise_set_spa.index\n    latitude = golden_mst.latitude\n    longitude = golden_mst.longitude\n    eot = solarposition.equation_of_time_spencer71(times.dayofyear)  # minutes\n    decl = solarposition.declination_spencer71(times.dayofyear)  # radians\n    sr, ss, st = solarposition.sun_rise_set_transit_geometric(\n        times, latitude=latitude, longitude=longitude, declination=decl,\n        equation_of_time=eot)\n    # sunrise: 2015-01-02 07:26:39.763224487, 2015-08-02 05:04:35.688533801\n    # sunset:  2015-01-02 16:41:29.951096777, 2015-08-02 19:09:46.597355085\n    # transit: 2015-01-02 12:04:04.857160632, 2015-08-02 12:07:11.142944443\n    test_sunrise = solarposition._times_to_hours_after_local_midnight(sr)\n    test_sunset = solarposition._times_to_hours_after_local_midnight(ss)\n    test_transit = solarposition._times_to_hours_after_local_midnight(st)\n    # convert expected SPA sunrise, sunset, transit to local datetime indices\n    expected_sunrise = pd.DatetimeIndex(expected_rise_set_spa.sunrise.values,\n                                        tz='UTC').tz_convert(golden_mst.tz)\n    expected_sunset = pd.DatetimeIndex(expected_rise_set_spa.sunset.values,\n                                       tz='UTC').tz_convert(golden_mst.tz)\n    expected_transit = pd.DatetimeIndex(expected_rise_set_spa.transit.values,\n                                        tz='UTC').tz_convert(golden_mst.tz)\n    # convert expected times to hours since midnight as arrays of floats\n    expected_sunrise = solarposition._times_to_hours_after_local_midnight(\n        expected_sunrise)\n    expected_sunset = solarposition._times_to_hours_after_local_midnight(\n        expected_sunset)\n    expected_transit = solarposition._times_to_hours_after_local_midnight(\n        expected_transit)\n    # geometric time has about 4-6 minute error compared to SPA sunset/sunrise\n    expected_sunrise_error = np.array(\n        [0.07910089555555544, 0.06908014805555496])  # 4.8[min], 4.2[min]\n    expected_sunset_error = np.array(\n        [-0.1036246955555562, -0.06983406805555603])  # -6.2[min], -4.2[min]\n    expected_transit_error = np.array(\n        [-0.011150788888889096, 0.0036508177777765383])  # -40[sec], 13.3[sec]\n    assert np.allclose(test_sunrise, expected_sunrise,\n                       atol=np.abs(expected_sunrise_error).max())\n    assert np.allclose(test_sunset, expected_sunset,\n                       atol=np.abs(expected_sunset_error).max())\n    assert np.allclose(test_transit, expected_transit,\n                       atol=np.abs(expected_transit_error).max())\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_sun_rise_set_transit_geometric", "expected_rise_set_spa", "golden_mst", "test", "geometric", "calculations", "for", "sunrise", "sunset", "and", "transit", "times", "times", "expected_rise_set_spa", "index", "latitude", "golden_mst", "latitude", "longitude", "golden_mst", "longitude", "eot", "solarposition", "equation_of_time_spencer71", "times", "dayofyear", "minutes", "decl", "solarposition", "declination_spencer71", "times", "dayofyear", "radians", "sr", "ss", "st", "solarposition", "sun_rise_set_transit_geometric", "times", "latitude", "latitude", "longitude", "longitude", "declination", "decl", "equation_of_time", "eot", "sunrise", "2015", "01", "02", "07", "26", "39", "763224487", "2015", "08", "02", "05", "04", "35", "688533801", "sunset", "2015", "01", "02", "16", "41", "29", "951096777", "2015", "08", "02", "19", "09", "46", "597355085", "transit", "2015", "01", "02", "12", "04", "04", "857160632", "2015", "08", "02", "12", "07", "11", "142944443", "test_sunrise", "solarposition", "_times_to_hours_after_local_midnight", "sr", "test_sunset", "solarposition", "_times_to_hours_after_local_midnight", "ss", "test_transit", "solarposition", "_times_to_hours_after_local_midnight", "st", "convert", "expected", "spa", "sunrise", "sunset", "transit", "to", "local", "datetime", "indices", "expected_sunrise", "pd", "datetimeindex", "expected_rise_set_spa", "sunrise", "values", "tz", "utc", "tz_convert", "golden_mst", "tz", "expected_sunset", "pd", "datetimeindex", "expected_rise_set_spa", "sunset", "values", "tz", "utc", "tz_convert", "golden_mst", "tz", "expected_transit", "pd", "datetimeindex", "expected_rise_set_spa", "transit", "values", "tz", "utc", "tz_convert", "golden_mst", "tz", "convert", "expected", "times", "to", "hours", "since", "midnight", "as", "arrays", "of", "floats", "expected_sunrise", "solarposition", "_times_to_hours_after_local_midnight", "expected_sunrise", "expected_sunset", "solarposition", "_times_to_hours_after_local_midnight", "expected_sunset", "expected_transit", "solarposition", "_times_to_hours_after_local_midnight", "expected_transit", "geometric", "time", "has", "about", "4", "6", "minute", "error", "compared", "to", "spa", "sunset", "sunrise", "expected_sunrise_error", "np", "array", "0", "07910089555555544", "0", "06908014805555496", "4", "8", "min", "4", "2", "min", "expected_sunset_error", "np", "array", "0", "1036246955555562", "0", "06983406805555603", "6", "2", "min", "4", "2", "min", "expected_transit_error", "np", "array", "0", "011150788888889096", "0", "0036508177777765383", "40", "sec", "13", "3", "sec", "assert", "np", "allclose", "test_sunrise", "expected_sunrise", "atol", "np", "abs", "expected_sunrise_error", "max", "assert", "np", "allclose", "test_sunset", "expected_sunset", "atol", "np", "abs", "expected_sunset_error", "max", "assert", "np", "allclose", "test_transit", "expected_transit", "atol", "np", "abs", "expected_transit_error", "max"], "doc_len": 256}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_python_numba_physical", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_python_numba_physical", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_python_numba_physical(expected_solpos, golden_mst):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 12, 30, 30),\n                          periods=1, freq='D', tz=golden_mst.tz)\n    with warnings.catch_warnings():\n        # don't warn on method reload or num threads\n        # ensure that numpy is the most recently used method so that\n        # we can use the warns filter below\n        warnings.simplefilter(\"ignore\")\n        ephem_data = solarposition.spa_python(times, golden_mst.latitude,\n                                              golden_mst.longitude,\n                                              pressure=82000,\n                                              temperature=11, delta_t=67,\n                                              atmos_refract=0.5667,\n                                              how='numpy', numthreads=1)\n    with pytest.warns(UserWarning):\n        ephem_data = solarposition.spa_python(times, golden_mst.latitude,\n                                              golden_mst.longitude,\n                                              pressure=82000,\n                                              temperature=11, delta_t=67,\n                                              atmos_refract=0.5667,\n                                              how='numba', numthreads=1)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_python_numba_physical", "expected_solpos", "golden_mst", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz", "golden_mst", "tz", "with", "warnings", "catch_warnings", "don", "t", "warn", "on", "method", "reload", "or", "num", "threads", "ensure", "that", "numpy", "is", "the", "most", "recently", "used", "method", "so", "that", "we", "can", "use", "the", "warns", "filter", "below", "warnings", "simplefilter", "ignore", "ephem_data", "solarposition", "spa_python", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numpy", "numthreads", "1", "with", "pytest", "warns", "userwarning", "ephem_data", "solarposition", "spa_python", "times", "golden_mst", "latitude", "golden_mst", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numba", "numthreads", "1", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns"], "doc_len": 113}
{"doc_id": "pvlib/tests/test_solarposition.py::test_spa_python_numba_physical_dst", "file_path": "pvlib/tests/test_solarposition.py", "class_name": null, "func_name": "test_spa_python_numba_physical_dst", "text": "文件路径: pvlib/tests/test_solarposition.py\ndef test_spa_python_numba_physical_dst(expected_solpos, golden):\n    times = pd.date_range(datetime.datetime(2003, 10, 17, 13, 30, 30),\n                          periods=1, freq='D', tz=golden.tz)\n\n    with warnings.catch_warnings():\n        # don't warn on method reload or num threads\n        warnings.simplefilter(\"ignore\")\n        ephem_data = solarposition.spa_python(times, golden.latitude,\n                                              golden.longitude, pressure=82000,\n                                              temperature=11, delta_t=67,\n                                              atmos_refract=0.5667,\n                                              how='numba', numthreads=1)\n    expected_solpos.index = times\n    assert_frame_equal(expected_solpos, ephem_data[expected_solpos.columns])\n\n    with pytest.warns(UserWarning):\n        # test that we get a warning when reloading to use numpy only\n        ephem_data = solarposition.spa_python(times, golden.latitude,\n                                              golden.longitude,\n                                              pressure=82000,\n                                              temperature=11, delta_t=67,\n                                              atmos_refract=0.5667,\n                                              how='numpy', numthreads=1)\n", "tokens": ["pvlib", "tests", "test_solarposition", "py", "def", "test_spa_python_numba_physical_dst", "expected_solpos", "golden", "times", "pd", "date_range", "datetime", "datetime", "2003", "10", "17", "13", "30", "30", "periods", "1", "freq", "d", "tz", "golden", "tz", "with", "warnings", "catch_warnings", "don", "t", "warn", "on", "method", "reload", "or", "num", "threads", "warnings", "simplefilter", "ignore", "ephem_data", "solarposition", "spa_python", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numba", "numthreads", "1", "expected_solpos", "index", "times", "assert_frame_equal", "expected_solpos", "ephem_data", "expected_solpos", "columns", "with", "pytest", "warns", "userwarning", "test", "that", "we", "get", "a", "warning", "when", "reloading", "to", "use", "numpy", "only", "ephem_data", "solarposition", "spa_python", "times", "golden", "latitude", "golden", "longitude", "pressure", "82000", "temperature", "11", "delta_t", "67", "atmos_refract", "0", "5667", "how", "numpy", "numthreads", "1"], "doc_len": 107}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_julian_day_dt", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_julian_day_dt", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_julian_day_dt(self):\n        # add 1us manually to the test timestamp (GH #940)\n        dt = times.tz_convert('UTC')[0] + pd.Timedelta(1, unit='us')\n        year = dt.year\n        month = dt.month\n        day = dt.day\n        hour = dt.hour\n        minute = dt.minute\n        second = dt.second\n        microsecond = dt.microsecond\n        assert_almost_equal(JD + 1e-6 / (3600*24),  # modify expected JD by 1us\n                            self.spa.julian_day_dt(\n                                year, month, day, hour,\n                                minute, second, microsecond), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_julian_day_dt", "self", "add", "1us", "manually", "to", "the", "test", "timestamp", "gh", "940", "dt", "times", "tz_convert", "utc", "0", "pd", "timedelta", "1", "unit", "us", "year", "dt", "year", "month", "dt", "month", "day", "dt", "day", "hour", "dt", "hour", "minute", "dt", "minute", "second", "dt", "second", "microsecond", "dt", "microsecond", "assert_almost_equal", "jd", "1e", "6", "3600", "24", "modify", "expected", "jd", "by", "1us", "self", "spa", "julian_day_dt", "year", "month", "day", "hour", "minute", "second", "microsecond", "6"], "doc_len": 70}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_julian_ephemeris_day", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_julian_ephemeris_day", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_julian_ephemeris_day(self):\n        assert_almost_equal(JDE, self.spa.julian_ephemeris_day(JD, delta_t), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_julian_ephemeris_day", "self", "assert_almost_equal", "jde", "self", "spa", "julian_ephemeris_day", "jd", "delta_t", "5"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_julian_century", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_julian_century", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_julian_century(self):\n        assert_almost_equal(JC, self.spa.julian_century(JD), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_julian_century", "self", "assert_almost_equal", "jc", "self", "spa", "julian_century", "jd", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_julian_ephemeris_century", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_julian_ephemeris_century", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_julian_ephemeris_century(self):\n        assert_almost_equal(JCE, self.spa.julian_ephemeris_century(JDE), 10)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_julian_ephemeris_century", "self", "assert_almost_equal", "jce", "self", "spa", "julian_ephemeris_century", "jde", "10"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_julian_ephemeris_millenium", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_julian_ephemeris_millenium", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_julian_ephemeris_millenium(self):\n        assert_almost_equal(JME, self.spa.julian_ephemeris_millennium(JCE), 10)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_julian_ephemeris_millenium", "self", "assert_almost_equal", "jme", "self", "spa", "julian_ephemeris_millennium", "jce", "10"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_heliocentric_longitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_heliocentric_longitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_heliocentric_longitude(self):\n        assert_almost_equal(L, self.spa.heliocentric_longitude(JME), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_heliocentric_longitude", "self", "assert_almost_equal", "l", "self", "spa", "heliocentric_longitude", "jme", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_heliocentric_latitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_heliocentric_latitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_heliocentric_latitude(self):\n        assert_almost_equal(B, self.spa.heliocentric_latitude(JME), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_heliocentric_latitude", "self", "assert_almost_equal", "b", "self", "spa", "heliocentric_latitude", "jme", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_heliocentric_radius_vector", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_heliocentric_radius_vector", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_heliocentric_radius_vector(self):\n        assert_almost_equal(R, self.spa.heliocentric_radius_vector(JME), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_heliocentric_radius_vector", "self", "assert_almost_equal", "r", "self", "spa", "heliocentric_radius_vector", "jme", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_geocentric_longitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_geocentric_longitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_geocentric_longitude(self):\n        assert_almost_equal(Theta, self.spa.geocentric_longitude(L), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_geocentric_longitude", "self", "assert_almost_equal", "theta", "self", "spa", "geocentric_longitude", "l", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_geocentric_latitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_geocentric_latitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_geocentric_latitude(self):\n        assert_almost_equal(beta, self.spa.geocentric_latitude(B), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_geocentric_latitude", "self", "assert_almost_equal", "beta", "self", "spa", "geocentric_latitude", "b", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_mean_elongation", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_mean_elongation", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_mean_elongation(self):\n        assert_almost_equal(X0, self.spa.mean_elongation(JCE), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_mean_elongation", "self", "assert_almost_equal", "x0", "self", "spa", "mean_elongation", "jce", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_mean_anomaly_sun", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_mean_anomaly_sun", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_mean_anomaly_sun(self):\n        assert_almost_equal(X1, self.spa.mean_anomaly_sun(JCE), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_mean_anomaly_sun", "self", "assert_almost_equal", "x1", "self", "spa", "mean_anomaly_sun", "jce", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_mean_anomaly_moon", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_mean_anomaly_moon", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_mean_anomaly_moon(self):\n        assert_almost_equal(X2, self.spa.mean_anomaly_moon(JCE), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_mean_anomaly_moon", "self", "assert_almost_equal", "x2", "self", "spa", "mean_anomaly_moon", "jce", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_moon_argument_latitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_moon_argument_latitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_moon_argument_latitude(self):\n        assert_almost_equal(X3, self.spa.moon_argument_latitude(JCE), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_moon_argument_latitude", "self", "assert_almost_equal", "x3", "self", "spa", "moon_argument_latitude", "jce", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_moon_ascending_longitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_moon_ascending_longitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_moon_ascending_longitude(self):\n        assert_almost_equal(X4, self.spa.moon_ascending_longitude(JCE), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_moon_ascending_longitude", "self", "assert_almost_equal", "x4", "self", "spa", "moon_ascending_longitude", "jce", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_longitude_nutation", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_longitude_nutation", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_longitude_nutation(self):\n        assert_almost_equal(dPsi, self.spa.longitude_nutation(\n            JCE, X0, X1, X2, X3, X4), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_longitude_nutation", "self", "assert_almost_equal", "dpsi", "self", "spa", "longitude_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "6"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_obliquity_nutation", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_obliquity_nutation", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_obliquity_nutation(self):\n        assert_almost_equal(dEpsilon, self.spa.obliquity_nutation(\n            JCE, X0, X1, X2, X3, X4), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_obliquity_nutation", "self", "assert_almost_equal", "depsilon", "self", "spa", "obliquity_nutation", "jce", "x0", "x1", "x2", "x3", "x4", "6"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_mean_ecliptic_obliquity", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_mean_ecliptic_obliquity", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_mean_ecliptic_obliquity(self):\n        assert_almost_equal(epsilon0, self.spa.mean_ecliptic_obliquity(JME), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_mean_ecliptic_obliquity", "self", "assert_almost_equal", "epsilon0", "self", "spa", "mean_ecliptic_obliquity", "jme", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_true_ecliptic_obliquity", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_true_ecliptic_obliquity", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_true_ecliptic_obliquity(self):\n        assert_almost_equal(epsilon, self.spa.true_ecliptic_obliquity(\n            epsilon0, dEpsilon), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_true_ecliptic_obliquity", "self", "assert_almost_equal", "epsilon", "self", "spa", "true_ecliptic_obliquity", "epsilon0", "depsilon", "6"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_aberration_correction", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_aberration_correction", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_aberration_correction(self):\n        assert_almost_equal(dTau, self.spa.aberration_correction(R), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_aberration_correction", "self", "assert_almost_equal", "dtau", "self", "spa", "aberration_correction", "r", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_apparent_sun_longitude", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_apparent_sun_longitude", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_apparent_sun_longitude(self):\n        assert_almost_equal(lamd, self.spa.apparent_sun_longitude(\n            Theta, dPsi, dTau), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_apparent_sun_longitude", "self", "assert_almost_equal", "lamd", "self", "spa", "apparent_sun_longitude", "theta", "dpsi", "dtau", "6"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_mean_sidereal_time", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_mean_sidereal_time", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_mean_sidereal_time(self):\n        assert_almost_equal(v0, self.spa.mean_sidereal_time(JD, JC), 3)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_mean_sidereal_time", "self", "assert_almost_equal", "v0", "self", "spa", "mean_sidereal_time", "jd", "jc", "3"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_apparent_sidereal_time", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_apparent_sidereal_time", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_apparent_sidereal_time(self):\n        assert_almost_equal(v, self.spa.apparent_sidereal_time(\n            v0, dPsi, epsilon), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_apparent_sidereal_time", "self", "assert_almost_equal", "v", "self", "spa", "apparent_sidereal_time", "v0", "dpsi", "epsilon", "5"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_geocentric_sun_right_ascension", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_geocentric_sun_right_ascension", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_geocentric_sun_right_ascension(self):\n        assert_almost_equal(alpha, self.spa.geocentric_sun_right_ascension(\n            lamd, epsilon, beta), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_geocentric_sun_right_ascension", "self", "assert_almost_equal", "alpha", "self", "spa", "geocentric_sun_right_ascension", "lamd", "epsilon", "beta", "6"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_geocentric_sun_declination", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_geocentric_sun_declination", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_geocentric_sun_declination(self):\n        assert_almost_equal(delta, self.spa.geocentric_sun_declination(\n            lamd, epsilon, beta), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_geocentric_sun_declination", "self", "assert_almost_equal", "delta", "self", "spa", "geocentric_sun_declination", "lamd", "epsilon", "beta", "6"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_local_hour_angle", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_local_hour_angle", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_local_hour_angle(self):\n        assert_almost_equal(H, self.spa.local_hour_angle(v, lon, alpha), 4)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_local_hour_angle", "self", "assert_almost_equal", "h", "self", "spa", "local_hour_angle", "v", "lon", "alpha", "4"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_equatorial_horizontal_parallax", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_equatorial_horizontal_parallax", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_equatorial_horizontal_parallax(self):\n        assert_almost_equal(xi, self.spa.equatorial_horizontal_parallax(R), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_equatorial_horizontal_parallax", "self", "assert_almost_equal", "xi", "self", "spa", "equatorial_horizontal_parallax", "r", "6"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_parallax_sun_right_ascension", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_parallax_sun_right_ascension", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_parallax_sun_right_ascension(self):\n        u = self.spa.uterm(lat)\n        x = self.spa.xterm(u, lat, elev)\n        assert_almost_equal(dAlpha, self.spa.parallax_sun_right_ascension(\n            x, xi, H, delta), 4)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_parallax_sun_right_ascension", "self", "u", "self", "spa", "uterm", "lat", "x", "self", "spa", "xterm", "u", "lat", "elev", "assert_almost_equal", "dalpha", "self", "spa", "parallax_sun_right_ascension", "x", "xi", "h", "delta", "4"], "doc_len": 30}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_sun_right_ascension", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_sun_right_ascension", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_sun_right_ascension(self):\n        assert_almost_equal(alpha_prime,\n                            self.spa.topocentric_sun_right_ascension(\n                                alpha, dAlpha), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_sun_right_ascension", "self", "assert_almost_equal", "alpha_prime", "self", "spa", "topocentric_sun_right_ascension", "alpha", "dalpha", "5"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_sun_declination", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_sun_declination", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_sun_declination(self):\n        u = self.spa.uterm(lat)\n        x = self.spa.xterm(u, lat, elev)\n        y = self.spa.yterm(u, lat, elev)\n        assert_almost_equal(delta_prime, self.spa.topocentric_sun_declination(\n            delta, x, y, xi, dAlpha, H), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_sun_declination", "self", "u", "self", "spa", "uterm", "lat", "x", "self", "spa", "xterm", "u", "lat", "elev", "y", "self", "spa", "yterm", "u", "lat", "elev", "assert_almost_equal", "delta_prime", "self", "spa", "topocentric_sun_declination", "delta", "x", "y", "xi", "dalpha", "h", "5"], "doc_len": 39}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_local_hour_angle", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_local_hour_angle", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_local_hour_angle(self):\n        assert_almost_equal(H_prime, self.spa.topocentric_local_hour_angle(\n            H, dAlpha), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_local_hour_angle", "self", "assert_almost_equal", "h_prime", "self", "spa", "topocentric_local_hour_angle", "h", "dalpha", "5"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_elevation_angle_without_atmosphere", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_elevation_angle_without_atmosphere", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_elevation_angle_without_atmosphere(self):\n        assert_almost_equal(\n            e0, self.spa.topocentric_elevation_angle_without_atmosphere(\n                lat, delta_prime, H_prime), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_elevation_angle_without_atmosphere", "self", "assert_almost_equal", "e0", "self", "spa", "topocentric_elevation_angle_without_atmosphere", "lat", "delta_prime", "h_prime", "6"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_atmospheric_refraction_correction", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_atmospheric_refraction_correction", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_atmospheric_refraction_correction(self):\n        assert_almost_equal(de, self.spa.atmospheric_refraction_correction(\n            pressure, temp, e0, atmos_refract), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_atmospheric_refraction_correction", "self", "assert_almost_equal", "de", "self", "spa", "atmospheric_refraction_correction", "pressure", "temp", "e0", "atmos_refract", "6"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_elevation_angle", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_elevation_angle", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_elevation_angle(self):\n        assert_almost_equal(e, self.spa.topocentric_elevation_angle(e0, de), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_elevation_angle", "self", "assert_almost_equal", "e", "self", "spa", "topocentric_elevation_angle", "e0", "de", "6"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_zenith_angle", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_zenith_angle", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_zenith_angle(self):\n        assert_almost_equal(theta, self.spa.topocentric_zenith_angle(e), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_zenith_angle", "self", "assert_almost_equal", "theta", "self", "spa", "topocentric_zenith_angle", "e", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_astronomers_azimuth", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_astronomers_azimuth", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_astronomers_azimuth(self):\n        assert_almost_equal(Gamma, self.spa.topocentric_astronomers_azimuth(\n            H_prime, delta_prime, lat), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_astronomers_azimuth", "self", "assert_almost_equal", "gamma", "self", "spa", "topocentric_astronomers_azimuth", "h_prime", "delta_prime", "lat", "5"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_topocentric_azimuth_angle", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_topocentric_azimuth_angle", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_topocentric_azimuth_angle(self):\n        assert_almost_equal(Phi, self.spa.topocentric_azimuth_angle(Gamma), 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_topocentric_azimuth_angle", "self", "assert_almost_equal", "phi", "self", "spa", "topocentric_azimuth_angle", "gamma", "5"], "doc_len": 15}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_solar_position", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_solar_position", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_solar_position(self):\n        with warnings.catch_warnings():\n            # don't warn on method reload or num threads\n            warnings.simplefilter(\"ignore\")\n            spa_out_0 = self.spa.solar_position(\n                unixtimes, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract)[:-1]\n            spa_out_1 = self.spa.solar_position(\n                unixtimes, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract, sst=True)[:3]\n        assert_almost_equal(np.array([[theta, theta0, e, e0, Phi]]).T,\n                            spa_out_0, 5)\n        assert_almost_equal(np.array([[v, alpha, delta]]).T, spa_out_1, 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_solar_position", "self", "with", "warnings", "catch_warnings", "don", "t", "warn", "on", "method", "reload", "or", "num", "threads", "warnings", "simplefilter", "ignore", "spa_out_0", "self", "spa", "solar_position", "unixtimes", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "1", "spa_out_1", "self", "spa", "solar_position", "unixtimes", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "sst", "true", "3", "assert_almost_equal", "np", "array", "theta", "theta0", "e", "e0", "phi", "t", "spa_out_0", "5", "assert_almost_equal", "np", "array", "v", "alpha", "delta", "t", "spa_out_1", "5"], "doc_len": 71}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_equation_of_time", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_equation_of_time", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_equation_of_time(self):\n        eot = 14.64\n        M = self.spa.sun_mean_longitude(JME)\n        assert_almost_equal(eot, self.spa.equation_of_time(\n            M, alpha, dPsi, epsilon), 2)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_equation_of_time", "self", "eot", "14", "64", "m", "self", "spa", "sun_mean_longitude", "jme", "assert_almost_equal", "eot", "self", "spa", "equation_of_time", "m", "alpha", "dpsi", "epsilon", "2"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_transit_sunrise_sunset", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_transit_sunrise_sunset", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_transit_sunrise_sunset(self):\n        # tests at greenwich\n        times = pd.DatetimeIndex([dt.datetime(1996, 7, 5, 0),\n                                  dt.datetime(2004, 12, 4, 0)]\n                                 ).tz_localize(\n                                     'UTC').view(np.int64)*1.0/10**9\n        sunrise = pd.DatetimeIndex([dt.datetime(1996, 7, 5, 7, 8, 15),\n                                    dt.datetime(2004, 12, 4, 4, 38, 57)]\n                                   ).tz_localize(\n                                       'UTC').view(np.int64)*1.0/10**9\n        sunset = pd.DatetimeIndex([dt.datetime(1996, 7, 5, 17, 1, 4),\n                                   dt.datetime(2004, 12, 4, 19, 2, 2)]\n                                  ).tz_localize(\n                                      'UTC').view(np.int64)*1.0/10**9\n        times = np.array(times)\n        sunrise = np.array(sunrise)\n        sunset = np.array(sunset)\n        result = self.spa.transit_sunrise_sunset(times, -35.0, 0.0, 64.0, 1)\n        assert_almost_equal(sunrise/1e3, result[1]/1e3, 3)\n        assert_almost_equal(sunset/1e3, result[2]/1e3, 3)\n\n        times = pd.DatetimeIndex([dt.datetime(1994, 1, 2), ]\n                                 ).tz_localize(\n                                     'UTC').view(np.int64)*1.0/10**9\n        sunset = pd.DatetimeIndex([dt.datetime(1994, 1, 2, 16, 59, 55), ]\n                                  ).tz_localize(\n                                      'UTC').view(np.int64)*1.0/10**9\n        sunrise = pd.DatetimeIndex([dt.datetime(1994, 1, 2, 7, 8, 12), ]\n                                   ).tz_localize(\n                                       'UTC').view(np.int64)*1.0/10**9\n        times = np.array(times)\n        sunrise = np.array(sunrise)\n        sunset = np.array(sunset)\n        result = self.spa.transit_sunrise_sunset(times, 35.0, 0.0, 64.0, 1)\n        assert_almost_equal(sunrise/1e3, result[1]/1e3, 3)\n        assert_almost_equal(sunset/1e3, result[2]/1e3, 3)\n\n        # tests from USNO\n        # Golden\n        times = pd.DatetimeIndex([dt.datetime(2015, 1, 2),\n                                  dt.datetime(2015, 4, 2),\n                                  dt.datetime(2015, 8, 2),\n                                  dt.datetime(2015, 12, 2)],\n                                 ).tz_localize(\n                                     'UTC').view(np.int64)*1.0/10**9\n        sunrise = pd.DatetimeIndex([dt.datetime(2015, 1, 2, 7, 19),\n                                    dt.datetime(2015, 4, 2, 5, 43),\n                                    dt.datetime(2015, 8, 2, 5, 1),\n                                    dt.datetime(2015, 12, 2, 7, 1)],\n                                   ).tz_localize(\n                                       'MST').view(np.int64)*1.0/10**9\n        sunset = pd.DatetimeIndex([dt.datetime(2015, 1, 2, 16, 49),\n                                   dt.datetime(2015, 4, 2, 18, 24),\n                                   dt.datetime(2015, 8, 2, 19, 10),\n                                   dt.datetime(2015, 12, 2, 16, 38)],\n                                  ).tz_localize(\n                                      'MST').view(np.int64)*1.0/10**9\n        times = np.array(times)\n        sunrise = np.array(sunrise)\n        sunset = np.array(sunset)\n        result = self.spa.transit_sunrise_sunset(times, 39.0, -105.0, 64.0, 1)\n        assert_almost_equal(sunrise/1e3, result[1]/1e3, 1)\n        assert_almost_equal(sunset/1e3, result[2]/1e3, 1)\n\n        # Beijing\n        times = pd.DatetimeIndex([dt.datetime(2015, 1, 2),\n                                  dt.datetime(2015, 4, 2),\n                                  dt.datetime(2015, 8, 2),\n                                  dt.datetime(2015, 12, 2)],\n                                 ).tz_localize(\n                                     'UTC').view(np.int64)*1.0/10**9\n        sunrise = pd.DatetimeIndex([dt.datetime(2015, 1, 2, 7, 36),\n                                    dt.datetime(2015, 4, 2, 5, 58),\n                                    dt.datetime(2015, 8, 2, 5, 13),\n                                    dt.datetime(2015, 12, 2, 7, 17)],\n                                   ).tz_localize('Asia/Shanghai').view(\n                                       np.int64)*1.0/10**9\n        sunset = pd.DatetimeIndex([dt.datetime(2015, 1, 2, 17, 0),\n                                   dt.datetime(2015, 4, 2, 18, 39),\n                                   dt.datetime(2015, 8, 2, 19, 28),\n                                   dt.datetime(2015, 12, 2, 16, 50)],\n                                  ).tz_localize('Asia/Shanghai').view(\n                                      np.int64)*1.0/10**9\n        times = np.array(times)\n        sunrise = np.array(sunrise)\n        sunset = np.array(sunset)\n        result = self.spa.transit_sunrise_sunset(\n            times, 39.917, 116.383, 64.0, 1)\n        assert_almost_equal(sunrise/1e3, result[1]/1e3, 1)\n        assert_almost_equal(sunset/1e3, result[2]/1e3, 1)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_transit_sunrise_sunset", "self", "tests", "at", "greenwich", "times", "pd", "datetimeindex", "dt", "datetime", "1996", "7", "5", "0", "dt", "datetime", "2004", "12", "4", "0", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunrise", "pd", "datetimeindex", "dt", "datetime", "1996", "7", "5", "7", "8", "15", "dt", "datetime", "2004", "12", "4", "4", "38", "57", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunset", "pd", "datetimeindex", "dt", "datetime", "1996", "7", "5", "17", "1", "4", "dt", "datetime", "2004", "12", "4", "19", "2", "2", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "times", "np", "array", "times", "sunrise", "np", "array", "sunrise", "sunset", "np", "array", "sunset", "result", "self", "spa", "transit_sunrise_sunset", "times", "35", "0", "0", "0", "64", "0", "1", "assert_almost_equal", "sunrise", "1e3", "result", "1", "1e3", "3", "assert_almost_equal", "sunset", "1e3", "result", "2", "1e3", "3", "times", "pd", "datetimeindex", "dt", "datetime", "1994", "1", "2", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunset", "pd", "datetimeindex", "dt", "datetime", "1994", "1", "2", "16", "59", "55", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunrise", "pd", "datetimeindex", "dt", "datetime", "1994", "1", "2", "7", "8", "12", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "times", "np", "array", "times", "sunrise", "np", "array", "sunrise", "sunset", "np", "array", "sunset", "result", "self", "spa", "transit_sunrise_sunset", "times", "35", "0", "0", "0", "64", "0", "1", "assert_almost_equal", "sunrise", "1e3", "result", "1", "1e3", "3", "assert_almost_equal", "sunset", "1e3", "result", "2", "1e3", "3", "tests", "from", "usno", "golden", "times", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "dt", "datetime", "2015", "4", "2", "dt", "datetime", "2015", "8", "2", "dt", "datetime", "2015", "12", "2", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunrise", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "7", "19", "dt", "datetime", "2015", "4", "2", "5", "43", "dt", "datetime", "2015", "8", "2", "5", "1", "dt", "datetime", "2015", "12", "2", "7", "1", "tz_localize", "mst", "view", "np", "int64", "1", "0", "10", "9", "sunset", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "16", "49", "dt", "datetime", "2015", "4", "2", "18", "24", "dt", "datetime", "2015", "8", "2", "19", "10", "dt", "datetime", "2015", "12", "2", "16", "38", "tz_localize", "mst", "view", "np", "int64", "1", "0", "10", "9", "times", "np", "array", "times", "sunrise", "np", "array", "sunrise", "sunset", "np", "array", "sunset", "result", "self", "spa", "transit_sunrise_sunset", "times", "39", "0", "105", "0", "64", "0", "1", "assert_almost_equal", "sunrise", "1e3", "result", "1", "1e3", "1", "assert_almost_equal", "sunset", "1e3", "result", "2", "1e3", "1", "beijing", "times", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "dt", "datetime", "2015", "4", "2", "dt", "datetime", "2015", "8", "2", "dt", "datetime", "2015", "12", "2", "tz_localize", "utc", "view", "np", "int64", "1", "0", "10", "9", "sunrise", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "7", "36", "dt", "datetime", "2015", "4", "2", "5", "58", "dt", "datetime", "2015", "8", "2", "5", "13", "dt", "datetime", "2015", "12", "2", "7", "17", "tz_localize", "asia", "shanghai", "view", "np", "int64", "1", "0", "10", "9", "sunset", "pd", "datetimeindex", "dt", "datetime", "2015", "1", "2", "17", "0", "dt", "datetime", "2015", "4", "2", "18", "39", "dt", "datetime", "2015", "8", "2", "19", "28", "dt", "datetime", "2015", "12", "2", "16", "50", "tz_localize", "asia", "shanghai", "view", "np", "int64", "1", "0", "10", "9", "times", "np", "array", "times", "sunrise", "np", "array", "sunrise", "sunset", "np", "array", "sunset", "result", "self", "spa", "transit_sunrise_sunset", "times", "39", "917", "116", "383", "64", "0", "1", "assert_almost_equal", "sunrise", "1e3", "result", "1", "1e3", "1", "assert_almost_equal", "sunset", "1e3", "result", "2", "1e3", "1"], "doc_len": 531}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_earthsun_distance", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_earthsun_distance", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_earthsun_distance(self):\n        times = (pd.date_range('2003-10-17 12:30:30', periods=1, freq='D')\n                   .tz_localize('MST'))\n        unixtimes = times.tz_convert('UTC').view(np.int64)*1.0/10**9\n        unixtimes = np.array(unixtimes)\n        result = self.spa.earthsun_distance(unixtimes, 64.0, 1)\n        assert_almost_equal(R, result, 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_earthsun_distance", "self", "times", "pd", "date_range", "2003", "10", "17", "12", "30", "30", "periods", "1", "freq", "d", "tz_localize", "mst", "unixtimes", "times", "tz_convert", "utc", "view", "np", "int64", "1", "0", "10", "9", "unixtimes", "np", "array", "unixtimes", "result", "self", "spa", "earthsun_distance", "unixtimes", "64", "0", "1", "assert_almost_equal", "r", "result", "6"], "doc_len": 50}
{"doc_id": "pvlib/tests/test_spa.py::SpaBase.test_calculate_deltat", "file_path": "pvlib/tests/test_spa.py", "class_name": "SpaBase", "func_name": "test_calculate_deltat", "text": "文件路径: pvlib/tests/test_spa.py, 类名: SpaBase\n    def test_calculate_deltat(self):\n        result_mix_year = self.spa.calculate_deltat(mix_year_array, month)\n        assert_almost_equal(mix_year_actual, result_mix_year)\n\n        result_mix_month = self.spa.calculate_deltat(year, mix_month_array)\n        assert_almost_equal(mix_month_actual, result_mix_month)\n\n        result_array = self.spa.calculate_deltat(year_array, month_array)\n        assert_almost_equal(dt_actual_array, result_array, 3)\n\n        result_scalar = self.spa.calculate_deltat(year, month)\n        assert_almost_equal(dt_actual, result_scalar)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "spabase", "def", "test_calculate_deltat", "self", "result_mix_year", "self", "spa", "calculate_deltat", "mix_year_array", "month", "assert_almost_equal", "mix_year_actual", "result_mix_year", "result_mix_month", "self", "spa", "calculate_deltat", "year", "mix_month_array", "assert_almost_equal", "mix_month_actual", "result_mix_month", "result_array", "self", "spa", "calculate_deltat", "year_array", "month_array", "assert_almost_equal", "dt_actual_array", "result_array", "3", "result_scalar", "self", "spa", "calculate_deltat", "year", "month", "assert_almost_equal", "dt_actual", "result_scalar"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_spa.py::NumpySpaTest.setUpClass", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumpySpaTest", "func_name": "setUpClass", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumpySpaTest\n    def setUpClass(self):\n        os.environ['PVLIB_USE_NUMBA'] = '0'\n        import pvlib.spa as spa\n        spa = reload(spa)\n        self.spa = spa\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numpyspatest", "def", "setupclass", "self", "os", "environ", "pvlib_use_numba", "0", "import", "pvlib", "spa", "as", "spa", "spa", "reload", "spa", "self", "spa", "spa"], "doc_len": 23}
{"doc_id": "pvlib/tests/test_spa.py::NumpySpaTest.tearDownClass", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumpySpaTest", "func_name": "tearDownClass", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumpySpaTest\n    def tearDownClass(self):\n        del os.environ['PVLIB_USE_NUMBA']\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numpyspatest", "def", "teardownclass", "self", "del", "os", "environ", "pvlib_use_numba"], "doc_len": 12}
{"doc_id": "pvlib/tests/test_spa.py::NumpySpaTest.test_julian_day", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumpySpaTest", "func_name": "test_julian_day", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumpySpaTest\n    def test_julian_day(self):\n        assert_almost_equal(JD, self.spa.julian_day(unixtimes)[0], 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numpyspatest", "def", "test_julian_day", "self", "assert_almost_equal", "jd", "self", "spa", "julian_day", "unixtimes", "0", "6"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::NumbaSpaTest.setUpClass", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumbaSpaTest", "func_name": "setUpClass", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumbaSpaTest\n    def setUpClass(self):\n        os.environ['PVLIB_USE_NUMBA'] = '1'\n        if numba_version_int >= 17:\n            import pvlib.spa as spa\n            spa = reload(spa)\n            self.spa = spa\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numbaspatest", "def", "setupclass", "self", "os", "environ", "pvlib_use_numba", "1", "if", "numba_version_int", "17", "import", "pvlib", "spa", "as", "spa", "spa", "reload", "spa", "self", "spa", "spa"], "doc_len": 26}
{"doc_id": "pvlib/tests/test_spa.py::NumbaSpaTest.tearDownClass", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumbaSpaTest", "func_name": "tearDownClass", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumbaSpaTest\n    def tearDownClass(self):\n        del os.environ['PVLIB_USE_NUMBA']\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numbaspatest", "def", "teardownclass", "self", "del", "os", "environ", "pvlib_use_numba"], "doc_len": 12}
{"doc_id": "pvlib/tests/test_spa.py::NumbaSpaTest.test_julian_day", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumbaSpaTest", "func_name": "test_julian_day", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumbaSpaTest\n    def test_julian_day(self):\n        assert_almost_equal(JD, self.spa.julian_day(unixtimes[0]), 6)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numbaspatest", "def", "test_julian_day", "self", "assert_almost_equal", "jd", "self", "spa", "julian_day", "unixtimes", "0", "6"], "doc_len": 16}
{"doc_id": "pvlib/tests/test_spa.py::NumbaSpaTest.test_solar_position_singlethreaded", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumbaSpaTest", "func_name": "test_solar_position_singlethreaded", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumbaSpaTest\n    def test_solar_position_singlethreaded(self):\n        assert_almost_equal(\n            np.array([[theta, theta0, e, e0, Phi]]).T, self.spa.solar_position(\n                unixtimes, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract, numthreads=1)[:-1], 5)\n        assert_almost_equal(\n            np.array([[v, alpha, delta]]).T, self.spa.solar_position(\n                unixtimes, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract, numthreads=1, sst=True)[:3], 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numbaspatest", "def", "test_solar_position_singlethreaded", "self", "assert_almost_equal", "np", "array", "theta", "theta0", "e", "e0", "phi", "t", "self", "spa", "solar_position", "unixtimes", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "1", "1", "5", "assert_almost_equal", "np", "array", "v", "alpha", "delta", "t", "self", "spa", "solar_position", "unixtimes", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "1", "sst", "true", "3", "5"], "doc_len": 56}
{"doc_id": "pvlib/tests/test_spa.py::NumbaSpaTest.test_solar_position_multithreaded", "file_path": "pvlib/tests/test_spa.py", "class_name": "NumbaSpaTest", "func_name": "test_solar_position_multithreaded", "text": "文件路径: pvlib/tests/test_spa.py, 类名: NumbaSpaTest\n    def test_solar_position_multithreaded(self):\n        result = np.array([theta, theta0, e, e0, Phi])\n        nresult = np.array([result, result, result]).T\n        times = np.array([unixtimes[0], unixtimes[0], unixtimes[0]])\n        assert_almost_equal(\n            nresult, self.spa.solar_position(\n                times, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract, numthreads=3)[:-1], 5)\n        result = np.array([v, alpha, delta])\n        nresult = np.array([result, result, result]).T\n        assert_almost_equal(\n            nresult, self.spa.solar_position(\n                times, lat, lon, elev, pressure, temp, delta_t,\n                atmos_refract, numthreads=3, sst=True)[:3], 5)\n", "tokens": ["pvlib", "tests", "test_spa", "py", "numbaspatest", "def", "test_solar_position_multithreaded", "self", "result", "np", "array", "theta", "theta0", "e", "e0", "phi", "nresult", "np", "array", "result", "result", "result", "t", "times", "np", "array", "unixtimes", "0", "unixtimes", "0", "unixtimes", "0", "assert_almost_equal", "nresult", "self", "spa", "solar_position", "times", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "3", "1", "5", "result", "np", "array", "v", "alpha", "delta", "nresult", "np", "array", "result", "result", "result", "t", "assert_almost_equal", "nresult", "self", "spa", "solar_position", "times", "lat", "lon", "elev", "pressure", "temp", "delta_t", "atmos_refract", "numthreads", "3", "sst", "true", "3", "5"], "doc_len": 81}
{"doc_id": "pvlib/tests/test_spectrum.py::spectrl2_data", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "spectrl2_data", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef spectrl2_data():\n    # reference spectra generated with solar_utils==0.3\n    \"\"\"\n    expected = solar_utils.spectrl2(\n        units=1,\n        location=[40, -80, -5],\n        datetime=[2020, 3, 15, 10, 45, 59],\n        weather=[1013, 15],\n        orientation=[0, 180],\n        atmospheric_conditions=[1.14, 0.65, 0.344, 0.1, 1.42],\n        albedo=[0.3, 0.7, 0.8, 1.3, 2.5, 4.0] + [0.2]*6,\n    )\n    \"\"\"\n    kwargs = {\n        'surface_tilt': 0,\n        'relative_airmass': 1.4899535986910446,\n        'apparent_zenith': 47.912086486816406,\n        'aoi': 47.91208648681641,\n        'ground_albedo': 0.2,\n        'surface_pressure': 101300,\n        'ozone': 0.344,\n        'precipitable_water': 1.42,\n        'aerosol_turbidity_500nm': 0.1,\n        'dayofyear': 75\n    }\n    df = pd.read_csv(SPECTRL2_TEST_DATA, index_col=0)\n    # convert um to nm\n    df['wavelength'] = np.round(df['wavelength'] * 1000, 1)\n    df[['specdif', 'specdir', 'specetr', 'specglo']] /= 1000\n    return kwargs, df\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "spectrl2_data", "reference", "spectra", "generated", "with", "solar_utils", "0", "3", "expected", "solar_utils", "spectrl2", "units", "1", "location", "40", "80", "5", "datetime", "2020", "3", "15", "10", "45", "59", "weather", "1013", "15", "orientation", "0", "180", "atmospheric_conditions", "1", "14", "0", "65", "0", "344", "0", "1", "1", "42", "albedo", "0", "3", "0", "7", "0", "8", "1", "3", "2", "5", "4", "0", "0", "2", "6", "kwargs", "surface_tilt", "0", "relative_airmass", "1", "4899535986910446", "apparent_zenith", "47", "912086486816406", "aoi", "47", "91208648681641", "ground_albedo", "0", "2", "surface_pressure", "101300", "ozone", "0", "344", "precipitable_water", "1", "42", "aerosol_turbidity_500nm", "0", "1", "dayofyear", "75", "df", "pd", "read_csv", "spectrl2_test_data", "index_col", "0", "convert", "um", "to", "nm", "df", "wavelength", "np", "round", "df", "wavelength", "1000", "1", "df", "specdif", "specdir", "specetr", "specglo", "1000", "return", "kwargs", "df"], "doc_len": 117}
{"doc_id": "pvlib/tests/test_spectrum.py::test_spectrl2", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_spectrl2", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_spectrl2(spectrl2_data):\n    # compare against output from solar_utils wrapper around NREL spectrl2_2.c\n    kwargs, expected = spectrl2_data\n    actual = spectrum.spectrl2(**kwargs)\n    assert_allclose(expected['wavelength'].values, actual['wavelength'])\n    assert_allclose(expected['specdif'].values, actual['dhi'].ravel(),\n                    atol=7e-5)\n    assert_allclose(expected['specdir'].values, actual['dni'].ravel(),\n                    atol=1.5e-4)\n    assert_allclose(expected['specetr'], actual['dni_extra'].ravel(),\n                    atol=2e-4)\n    assert_allclose(expected['specglo'], actual['poa_global'].ravel(),\n                    atol=1e-4)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_spectrl2", "spectrl2_data", "compare", "against", "output", "from", "solar_utils", "wrapper", "around", "nrel", "spectrl2_2", "c", "kwargs", "expected", "spectrl2_data", "actual", "spectrum", "spectrl2", "kwargs", "assert_allclose", "expected", "wavelength", "values", "actual", "wavelength", "assert_allclose", "expected", "specdif", "values", "actual", "dhi", "ravel", "atol", "7e", "5", "assert_allclose", "expected", "specdir", "values", "actual", "dni", "ravel", "atol", "1", "5e", "4", "assert_allclose", "expected", "specetr", "actual", "dni_extra", "ravel", "atol", "2e", "4", "assert_allclose", "expected", "specglo", "actual", "poa_global", "ravel", "atol", "1e", "4"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_spectrum.py::test_spectrl2_array", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_spectrl2_array", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_spectrl2_array(spectrl2_data):\n    # test that supplying arrays instead of scalars works\n    kwargs, expected = spectrl2_data\n    kwargs = {k: np.array([v, v, v]) for k, v in kwargs.items()}\n    actual = spectrum.spectrl2(**kwargs)\n\n    assert actual['wavelength'].shape == (122,)\n\n    keys = ['dni_extra', 'dhi', 'dni', 'poa_sky_diffuse', 'poa_ground_diffuse',\n            'poa_direct', 'poa_global']\n    for key in keys:\n        assert actual[key].shape == (122, 3)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_spectrl2_array", "spectrl2_data", "test", "that", "supplying", "arrays", "instead", "of", "scalars", "works", "kwargs", "expected", "spectrl2_data", "kwargs", "k", "np", "array", "v", "v", "v", "for", "k", "v", "in", "kwargs", "items", "actual", "spectrum", "spectrl2", "kwargs", "assert", "actual", "wavelength", "shape", "122", "keys", "dni_extra", "dhi", "dni", "poa_sky_diffuse", "poa_ground_diffuse", "poa_direct", "poa_global", "for", "key", "in", "keys", "assert", "actual", "key", "shape", "122", "3"], "doc_len": 58}
{"doc_id": "pvlib/tests/test_spectrum.py::test_spectrl2_series", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_spectrl2_series", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_spectrl2_series(spectrl2_data):\n    # test that supplying Series instead of scalars works\n    kwargs, expected = spectrl2_data\n    kwargs.pop('dayofyear')\n    index = pd.to_datetime(['2020-03-15 10:45:59']*3)\n    kwargs = {k: pd.Series([v, v, v], index=index) for k, v in kwargs.items()}\n    actual = spectrum.spectrl2(**kwargs)\n\n    assert actual['wavelength'].shape == (122,)\n\n    keys = ['dni_extra', 'dhi', 'dni', 'poa_sky_diffuse', 'poa_ground_diffuse',\n            'poa_direct', 'poa_global']\n    for key in keys:\n        assert actual[key].shape == (122, 3)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_spectrl2_series", "spectrl2_data", "test", "that", "supplying", "series", "instead", "of", "scalars", "works", "kwargs", "expected", "spectrl2_data", "kwargs", "pop", "dayofyear", "index", "pd", "to_datetime", "2020", "03", "15", "10", "45", "59", "3", "kwargs", "k", "pd", "series", "v", "v", "v", "index", "index", "for", "k", "v", "in", "kwargs", "items", "actual", "spectrum", "spectrl2", "kwargs", "assert", "actual", "wavelength", "shape", "122", "keys", "dni_extra", "dhi", "dni", "poa_sky_diffuse", "poa_ground_diffuse", "poa_direct", "poa_global", "for", "key", "in", "keys", "assert", "actual", "key", "shape", "122", "3"], "doc_len": 73}
{"doc_id": "pvlib/tests/test_spectrum.py::test_dayofyear_missing", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_dayofyear_missing", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_dayofyear_missing(spectrl2_data):\n    # test that not specifying dayofyear with non-pandas inputs raises error\n    kwargs, expected = spectrl2_data\n    kwargs.pop('dayofyear')\n    with pytest.raises(ValueError, match='dayofyear must be specified'):\n        _ = spectrum.spectrl2(**kwargs)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_dayofyear_missing", "spectrl2_data", "test", "that", "not", "specifying", "dayofyear", "with", "non", "pandas", "inputs", "raises", "error", "kwargs", "expected", "spectrl2_data", "kwargs", "pop", "dayofyear", "with", "pytest", "raises", "valueerror", "match", "dayofyear", "must", "be", "specified", "_", "spectrum", "spectrl2", "kwargs"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_spectrum.py::test_aoi_gt_90", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_aoi_gt_90", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_aoi_gt_90(spectrl2_data):\n    # test that returned irradiance values are non-negative when aoi > 90\n    # see GH #1348\n    kwargs, _ = spectrl2_data\n    kwargs['apparent_zenith'] = 70\n    kwargs['aoi'] = 130\n    kwargs['surface_tilt'] = 60\n\n    spectra = spectrum.spectrl2(**kwargs)\n    for key in ['poa_direct', 'poa_global']:\n        message = f'{key} contains negative values for aoi>90'\n        assert np.all(spectra[key] >= 0), message\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_aoi_gt_90", "spectrl2_data", "test", "that", "returned", "irradiance", "values", "are", "non", "negative", "when", "aoi", "90", "see", "gh", "1348", "kwargs", "_", "spectrl2_data", "kwargs", "apparent_zenith", "70", "kwargs", "aoi", "130", "kwargs", "surface_tilt", "60", "spectra", "spectrum", "spectrl2", "kwargs", "for", "key", "in", "poa_direct", "poa_global", "message", "f", "key", "contains", "negative", "values", "for", "aoi", "90", "assert", "np", "all", "spectra", "key", "0", "message"], "doc_len": 58}
{"doc_id": "pvlib/tests/test_spectrum.py::test_get_example_spectral_response", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_get_example_spectral_response", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_get_example_spectral_response():\n    # test that the sample sr is read and interpolated correctly\n    sr = spectrum.get_example_spectral_response()\n    assert_equal(len(sr), 185)\n    assert_equal(np.sum(sr.index), 136900)\n    assert_approx_equal(np.sum(sr), 107.6116)\n\n    wavelength = [270, 850, 950, 1200, 4001]\n    expected = [0.0, 0.92778, 1.0, 0.0, 0.0]\n\n    sr = spectrum.get_example_spectral_response(wavelength)\n    assert_equal(len(sr), len(wavelength))\n    assert_allclose(sr, expected, rtol=1e-5)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_get_example_spectral_response", "test", "that", "the", "sample", "sr", "is", "read", "and", "interpolated", "correctly", "sr", "spectrum", "get_example_spectral_response", "assert_equal", "len", "sr", "185", "assert_equal", "np", "sum", "sr", "index", "136900", "assert_approx_equal", "np", "sum", "sr", "107", "6116", "wavelength", "270", "850", "950", "1200", "4001", "expected", "0", "0", "0", "92778", "1", "0", "0", "0", "0", "0", "sr", "spectrum", "get_example_spectral_response", "wavelength", "assert_equal", "len", "sr", "len", "wavelength", "assert_allclose", "sr", "expected", "rtol", "1e", "5"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_spectrum.py::test_get_am15g", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_get_am15g", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_get_am15g():\n    # test that the reference spectrum is read and interpolated correctly\n    e = spectrum.get_am15g()\n    assert_equal(len(e), 2002)\n    assert_equal(np.sum(e.index), 2761442)\n    assert_approx_equal(np.sum(e), 1002.88, significant=6)\n\n    wavelength = [270, 850, 950, 1200, 4001]\n    expected = [0.0, 0.893720, 0.147260, 0.448250, 0.0]\n\n    e = spectrum.get_am15g(wavelength)\n    assert_equal(len(e), len(wavelength))\n    assert_allclose(e, expected, rtol=1e-6)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_get_am15g", "test", "that", "the", "reference", "spectrum", "is", "read", "and", "interpolated", "correctly", "e", "spectrum", "get_am15g", "assert_equal", "len", "e", "2002", "assert_equal", "np", "sum", "e", "index", "2761442", "assert_approx_equal", "np", "sum", "e", "1002", "88", "significant", "6", "wavelength", "270", "850", "950", "1200", "4001", "expected", "0", "0", "0", "893720", "0", "147260", "0", "448250", "0", "0", "e", "spectrum", "get_am15g", "wavelength", "assert_equal", "len", "e", "len", "wavelength", "assert_allclose", "e", "expected", "rtol", "1e", "6"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_spectrum.py::test_calc_spectral_mismatch_field", "file_path": "pvlib/tests/test_spectrum.py", "class_name": null, "func_name": "test_calc_spectral_mismatch_field", "text": "文件路径: pvlib/tests/test_spectrum.py\ndef test_calc_spectral_mismatch_field(spectrl2_data):\n    # test that the mismatch is calculated correctly with\n    # - default and custom reference sepctrum\n    # - single or multiple sun spectra\n\n    # sample data\n    _, e_sun = spectrl2_data\n    e_sun = e_sun.set_index('wavelength')\n    e_sun = e_sun.transpose()\n\n    e_ref = spectrum.get_am15g()\n    sr = spectrum.get_example_spectral_response()\n\n    # test with single sun spectrum, same as ref spectrum\n    mm = spectrum.calc_spectral_mismatch_field(sr, e_sun=e_ref)\n    assert_approx_equal(mm, 1.0, significant=6)\n\n    # test with single sun spectrum\n    mm = spectrum.calc_spectral_mismatch_field(sr, e_sun=e_sun.loc['specglo'])\n    assert_approx_equal(mm, 0.992397, significant=6)\n\n    # test with single sun spectrum, also used as reference spectrum\n    mm = spectrum.calc_spectral_mismatch_field(sr,\n                                               e_sun=e_sun.loc['specglo'],\n                                               e_ref=e_sun.loc['specglo'])\n    assert_approx_equal(mm, 1.0, significant=6)\n\n    # test with multiple sun spectra\n    expected = [0.972982, 0.995581, 0.899782, 0.992397]\n\n    mm = spectrum.calc_spectral_mismatch_field(sr, e_sun=e_sun)\n    assert mm.index is e_sun.index\n    assert_allclose(mm, expected, rtol=1e-6)\n", "tokens": ["pvlib", "tests", "test_spectrum", "py", "def", "test_calc_spectral_mismatch_field", "spectrl2_data", "test", "that", "the", "mismatch", "is", "calculated", "correctly", "with", "default", "and", "custom", "reference", "sepctrum", "single", "or", "multiple", "sun", "spectra", "sample", "data", "_", "e_sun", "spectrl2_data", "e_sun", "e_sun", "set_index", "wavelength", "e_sun", "e_sun", "transpose", "e_ref", "spectrum", "get_am15g", "sr", "spectrum", "get_example_spectral_response", "test", "with", "single", "sun", "spectrum", "same", "as", "ref", "spectrum", "mm", "spectrum", "calc_spectral_mismatch_field", "sr", "e_sun", "e_ref", "assert_approx_equal", "mm", "1", "0", "significant", "6", "test", "with", "single", "sun", "spectrum", "mm", "spectrum", "calc_spectral_mismatch_field", "sr", "e_sun", "e_sun", "loc", "specglo", "assert_approx_equal", "mm", "0", "992397", "significant", "6", "test", "with", "single", "sun", "spectrum", "also", "used", "as", "reference", "spectrum", "mm", "spectrum", "calc_spectral_mismatch_field", "sr", "e_sun", "e_sun", "loc", "specglo", "e_ref", "e_sun", "loc", "specglo", "assert_approx_equal", "mm", "1", "0", "significant", "6", "test", "with", "multiple", "sun", "spectra", "expected", "0", "972982", "0", "995581", "0", "899782", "0", "992397", "mm", "spectrum", "calc_spectral_mismatch_field", "sr", "e_sun", "e_sun", "assert", "mm", "index", "is", "e_sun", "index", "assert_allclose", "mm", "expected", "rtol", "1e", "6"], "doc_len": 143}
{"doc_id": "pvlib/tests/test_temperature.py::sapm_default", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "sapm_default", "text": "文件路径: pvlib/tests/test_temperature.py\ndef sapm_default():\n    return temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'open_rack_glass_glass']\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "sapm_default", "return", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_glass"], "doc_len": 11}
{"doc_id": "pvlib/tests/test_temperature.py::test_sapm_cell", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_sapm_cell", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_sapm_cell(sapm_default):\n    default = temperature.sapm_cell(900, 20, 5, sapm_default['a'],\n                                    sapm_default['b'], sapm_default['deltaT'])\n    assert_allclose(default, 43.509, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_sapm_cell", "sapm_default", "default", "temperature", "sapm_cell", "900", "20", "5", "sapm_default", "a", "sapm_default", "b", "sapm_default", "deltat", "assert_allclose", "default", "43", "509", "3"], "doc_len": 24}
{"doc_id": "pvlib/tests/test_temperature.py::test_sapm_module", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_sapm_module", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_sapm_module(sapm_default):\n    default = temperature.sapm_module(900, 20, 5, sapm_default['a'],\n                                      sapm_default['b'])\n    assert_allclose(default, 40.809, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_sapm_module", "sapm_default", "default", "temperature", "sapm_module", "900", "20", "5", "sapm_default", "a", "sapm_default", "b", "assert_allclose", "default", "40", "809", "3"], "doc_len": 22}
{"doc_id": "pvlib/tests/test_temperature.py::test_sapm_cell_from_module", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_sapm_cell_from_module", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_sapm_cell_from_module(sapm_default):\n    default = temperature.sapm_cell_from_module(50, 900,\n                                                sapm_default['deltaT'])\n    assert_allclose(default, 50 + 900 / 1000 * sapm_default['deltaT'])\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_sapm_cell_from_module", "sapm_default", "default", "temperature", "sapm_cell_from_module", "50", "900", "sapm_default", "deltat", "assert_allclose", "default", "50", "900", "1000", "sapm_default", "deltat"], "doc_len": 21}
{"doc_id": "pvlib/tests/test_temperature.py::test_sapm_ndarray", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_sapm_ndarray", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_sapm_ndarray(sapm_default):\n    temps = np.array([0, 10, 5])\n    irrads = np.array([0, 500, 0])\n    winds = np.array([10, 5, 0])\n    cell_temps = temperature.sapm_cell(irrads, temps, winds, sapm_default['a'],\n                                       sapm_default['b'],\n                                       sapm_default['deltaT'])\n    module_temps = temperature.sapm_module(irrads, temps, winds,\n                                           sapm_default['a'],\n                                           sapm_default['b'])\n    expected_cell = np.array([0., 23.06066166, 5.])\n    expected_module = np.array([0., 21.56066166, 5.])\n    assert_allclose(expected_cell, cell_temps, 3)\n    assert_allclose(expected_module, module_temps, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_sapm_ndarray", "sapm_default", "temps", "np", "array", "0", "10", "5", "irrads", "np", "array", "0", "500", "0", "winds", "np", "array", "10", "5", "0", "cell_temps", "temperature", "sapm_cell", "irrads", "temps", "winds", "sapm_default", "a", "sapm_default", "b", "sapm_default", "deltat", "module_temps", "temperature", "sapm_module", "irrads", "temps", "winds", "sapm_default", "a", "sapm_default", "b", "expected_cell", "np", "array", "0", "23", "06066166", "5", "expected_module", "np", "array", "0", "21", "56066166", "5", "assert_allclose", "expected_cell", "cell_temps", "3", "assert_allclose", "expected_module", "module_temps", "3"], "doc_len": 69}
{"doc_id": "pvlib/tests/test_temperature.py::test_sapm_series", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_sapm_series", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_sapm_series(sapm_default):\n    times = pd.date_range(start='2015-01-01', end='2015-01-02', freq='12H')\n    temps = pd.Series([0, 10, 5], index=times)\n    irrads = pd.Series([0, 500, 0], index=times)\n    winds = pd.Series([10, 5, 0], index=times)\n    cell_temps = temperature.sapm_cell(irrads, temps, winds, sapm_default['a'],\n                                       sapm_default['b'],\n                                       sapm_default['deltaT'])\n    module_temps = temperature.sapm_module(irrads, temps, winds,\n                                           sapm_default['a'],\n                                           sapm_default['b'])\n    expected_cell = pd.Series([0., 23.06066166, 5.], index=times)\n    expected_module = pd.Series([0., 21.56066166, 5.], index=times)\n    assert_series_equal(expected_cell, cell_temps)\n    assert_series_equal(expected_module, module_temps)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_sapm_series", "sapm_default", "times", "pd", "date_range", "start", "2015", "01", "01", "end", "2015", "01", "02", "freq", "12h", "temps", "pd", "series", "0", "10", "5", "index", "times", "irrads", "pd", "series", "0", "500", "0", "index", "times", "winds", "pd", "series", "10", "5", "0", "index", "times", "cell_temps", "temperature", "sapm_cell", "irrads", "temps", "winds", "sapm_default", "a", "sapm_default", "b", "sapm_default", "deltat", "module_temps", "temperature", "sapm_module", "irrads", "temps", "winds", "sapm_default", "a", "sapm_default", "b", "expected_cell", "pd", "series", "0", "23", "06066166", "5", "index", "times", "expected_module", "pd", "series", "0", "21", "56066166", "5", "index", "times", "assert_series_equal", "expected_cell", "cell_temps", "assert_series_equal", "expected_module", "module_temps"], "doc_len": 90}
{"doc_id": "pvlib/tests/test_temperature.py::test_pvsyst_cell_default", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_pvsyst_cell_default", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_pvsyst_cell_default():\n    result = temperature.pvsyst_cell(900, 20, 5)\n    assert_allclose(result, 45.137, 0.001)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_pvsyst_cell_default", "result", "temperature", "pvsyst_cell", "900", "20", "5", "assert_allclose", "result", "45", "137", "0", "001"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_temperature.py::test_pvsyst_cell_kwargs", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_pvsyst_cell_kwargs", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_pvsyst_cell_kwargs():\n    result = temperature.pvsyst_cell(900, 20, wind_speed=5.0, u_c=23.5,\n                                     u_v=6.25, module_efficiency=0.1)\n    assert_allclose(result, 33.315, 0.001)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_pvsyst_cell_kwargs", "result", "temperature", "pvsyst_cell", "900", "20", "wind_speed", "5", "0", "u_c", "23", "5", "u_v", "6", "25", "module_efficiency", "0", "1", "assert_allclose", "result", "33", "315", "0", "001"], "doc_len": 29}
{"doc_id": "pvlib/tests/test_temperature.py::test_pvsyst_cell_ndarray", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_pvsyst_cell_ndarray", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_pvsyst_cell_ndarray():\n    temps = np.array([0, 10, 5])\n    irrads = np.array([0, 500, 0])\n    winds = np.array([10, 5, 0])\n    result = temperature.pvsyst_cell(irrads, temps, wind_speed=winds)\n    expected = np.array([0.0, 23.96551, 5.0])\n    assert_allclose(expected, result, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_pvsyst_cell_ndarray", "temps", "np", "array", "0", "10", "5", "irrads", "np", "array", "0", "500", "0", "winds", "np", "array", "10", "5", "0", "result", "temperature", "pvsyst_cell", "irrads", "temps", "wind_speed", "winds", "expected", "np", "array", "0", "0", "23", "96551", "5", "0", "assert_allclose", "expected", "result", "3"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_temperature.py::test_pvsyst_cell_series", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_pvsyst_cell_series", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_pvsyst_cell_series():\n    times = pd.date_range(start=\"2015-01-01\", end=\"2015-01-02\", freq=\"12H\")\n    temps = pd.Series([0, 10, 5], index=times)\n    irrads = pd.Series([0, 500, 0], index=times)\n    winds = pd.Series([10, 5, 0], index=times)\n\n    result = temperature.pvsyst_cell(irrads, temps, wind_speed=winds)\n    expected = pd.Series([0.0, 23.96551, 5.0], index=times)\n    assert_series_equal(expected, result)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_pvsyst_cell_series", "times", "pd", "date_range", "start", "2015", "01", "01", "end", "2015", "01", "02", "freq", "12h", "temps", "pd", "series", "0", "10", "5", "index", "times", "irrads", "pd", "series", "0", "500", "0", "index", "times", "winds", "pd", "series", "10", "5", "0", "index", "times", "result", "temperature", "pvsyst_cell", "irrads", "temps", "wind_speed", "winds", "expected", "pd", "series", "0", "0", "23", "96551", "5", "0", "index", "times", "assert_series_equal", "expected", "result"], "doc_len": 64}
{"doc_id": "pvlib/tests/test_temperature.py::test_pvsyst_cell_eta_m_deprecated", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_pvsyst_cell_eta_m_deprecated", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_pvsyst_cell_eta_m_deprecated():\n    with pytest.warns(pvlibDeprecationWarning):\n        result = temperature.pvsyst_cell(900, 20, wind_speed=5.0, u_c=23.5,\n                                         u_v=6.25, eta_m=0.1)\n        assert_allclose(result, 33.315, 0.001)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_pvsyst_cell_eta_m_deprecated", "with", "pytest", "warns", "pvlibdeprecationwarning", "result", "temperature", "pvsyst_cell", "900", "20", "wind_speed", "5", "0", "u_c", "23", "5", "u_v", "6", "25", "eta_m", "0", "1", "assert_allclose", "result", "33", "315", "0", "001"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_temperature.py::test_faiman_default", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_faiman_default", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_faiman_default():\n    result = temperature.faiman(900, 20, 5)\n    assert_allclose(result, 35.203, 0.001)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_faiman_default", "result", "temperature", "faiman", "900", "20", "5", "assert_allclose", "result", "35", "203", "0", "001"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_temperature.py::test_faiman_kwargs", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_faiman_kwargs", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_faiman_kwargs():\n    result = temperature.faiman(900, 20, wind_speed=5.0, u0=22.0, u1=6.)\n    assert_allclose(result, 37.308, 0.001)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_faiman_kwargs", "result", "temperature", "faiman", "900", "20", "wind_speed", "5", "0", "u0", "22", "0", "u1", "6", "assert_allclose", "result", "37", "308", "0", "001"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_temperature.py::test_faiman_list", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_faiman_list", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_faiman_list():\n    temps = [0, 10, 5]\n    irrads = [0, 500, 0]\n    winds = [10, 5, 0]\n    result = temperature.faiman(irrads, temps, wind_speed=winds)\n    expected = np.array([0.0, 18.446, 5.0])\n    assert_allclose(expected, result, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_faiman_list", "temps", "0", "10", "5", "irrads", "0", "500", "0", "winds", "10", "5", "0", "result", "temperature", "faiman", "irrads", "temps", "wind_speed", "winds", "expected", "np", "array", "0", "0", "18", "446", "5", "0", "assert_allclose", "expected", "result", "3"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_temperature.py::test_faiman_ndarray", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_faiman_ndarray", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_faiman_ndarray():\n    temps = np.array([0, 10, 5])\n    irrads = np.array([0, 500, 0])\n    winds = np.array([10, 5, 0])\n    result = temperature.faiman(irrads, temps, wind_speed=winds)\n    expected = np.array([0.0, 18.446, 5.0])\n    assert_allclose(expected, result, 3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_faiman_ndarray", "temps", "np", "array", "0", "10", "5", "irrads", "np", "array", "0", "500", "0", "winds", "np", "array", "10", "5", "0", "result", "temperature", "faiman", "irrads", "temps", "wind_speed", "winds", "expected", "np", "array", "0", "0", "18", "446", "5", "0", "assert_allclose", "expected", "result", "3"], "doc_len": 44}
{"doc_id": "pvlib/tests/test_temperature.py::test_ross", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_ross", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_ross():\n    result = temperature.ross(np.array([1000., 600., 1000.]),\n                              np.array([20., 40., 60.]),\n                              np.array([40., 100., 20.]))\n    expected = np.array([45., 100., 60.])\n    assert_allclose(expected, result)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_ross", "result", "temperature", "ross", "np", "array", "1000", "600", "1000", "np", "array", "20", "40", "60", "np", "array", "40", "100", "20", "expected", "np", "array", "45", "100", "60", "assert_allclose", "expected", "result"], "doc_len": 33}
{"doc_id": "pvlib/tests/test_temperature.py::test_faiman_series", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_faiman_series", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_faiman_series():\n    times = pd.date_range(start=\"2015-01-01\", end=\"2015-01-02\", freq=\"12H\")\n    temps = pd.Series([0, 10, 5], index=times)\n    irrads = pd.Series([0, 500, 0], index=times)\n    winds = pd.Series([10, 5, 0], index=times)\n\n    result = temperature.faiman(irrads, temps, wind_speed=winds)\n    expected = pd.Series([0.0, 18.446, 5.0], index=times)\n    assert_series_equal(expected, result)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_faiman_series", "times", "pd", "date_range", "start", "2015", "01", "01", "end", "2015", "01", "02", "freq", "12h", "temps", "pd", "series", "0", "10", "5", "index", "times", "irrads", "pd", "series", "0", "500", "0", "index", "times", "winds", "pd", "series", "10", "5", "0", "index", "times", "result", "temperature", "faiman", "irrads", "temps", "wind_speed", "winds", "expected", "pd", "series", "0", "0", "18", "446", "5", "0", "index", "times", "assert_series_equal", "expected", "result"], "doc_len": 64}
{"doc_id": "pvlib/tests/test_temperature.py::test__temperature_model_params", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test__temperature_model_params", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test__temperature_model_params():\n    params = temperature._temperature_model_params('sapm',\n                                                   'open_rack_glass_glass')\n    assert params == temperature.TEMPERATURE_MODEL_PARAMETERS['sapm'][\n        'open_rack_glass_glass']\n    with pytest.raises(KeyError):\n        temperature._temperature_model_params('sapm', 'not_a_parameter_set')\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test__temperature_model_params", "params", "temperature", "_temperature_model_params", "sapm", "open_rack_glass_glass", "assert", "params", "temperature", "temperature_model_parameters", "sapm", "open_rack_glass_glass", "with", "pytest", "raises", "keyerror", "temperature", "_temperature_model_params", "sapm", "not_a_parameter_set"], "doc_len": 25}
{"doc_id": "pvlib/tests/test_temperature.py::_read_pvwatts_8760", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "_read_pvwatts_8760", "text": "文件路径: pvlib/tests/test_temperature.py\ndef _read_pvwatts_8760(filename):\n    df = pd.read_csv(filename,\n                     skiprows=17,  # ignore location/simulation metadata\n                     skipfooter=1,  # ignore \"Totals\" row\n                     engine='python')\n    df['Year'] = 2019\n    df.index = pd.to_datetime(df[['Year', 'Month', 'Day', 'Hour']])\n    return df\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "_read_pvwatts_8760", "filename", "df", "pd", "read_csv", "filename", "skiprows", "17", "ignore", "location", "simulation", "metadata", "skipfooter", "1", "ignore", "totals", "row", "engine", "python", "df", "year", "2019", "df", "index", "pd", "to_datetime", "df", "year", "month", "day", "hour", "return", "df"], "doc_len": 38}
{"doc_id": "pvlib/tests/test_temperature.py::test_fuentes", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_fuentes", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_fuentes(filename, inoct):\n    # Test against data exported from pvwatts.nrel.gov\n    data = _read_pvwatts_8760(DATA_DIR / filename)\n    data = data.iloc[:24*7, :]  # just use one week\n    inputs = {\n        'poa_global': data['Plane of Array Irradiance (W/m^2)'],\n        'temp_air': data['Ambient Temperature (C)'],\n        'wind_speed': data['Wind Speed (m/s)'],\n        'noct_installed': inoct,\n    }\n    expected_tcell = data['Cell Temperature (C)']\n    expected_tcell.name = 'tmod'\n    actual_tcell = temperature.fuentes(**inputs)\n    # the SSC implementation of PVWatts diverges from the Fuentes model at\n    # at night by setting Tcell=Tamb when POA=0. This not only means that\n    # nighttime values are slightly different (Fuentes models cooling to sky\n    # at night), but because of the thermal inertia, there is a transient\n    # error after dawn as well. Test each case separately:\n    is_night = inputs['poa_global'] == 0\n    is_dawn = is_night.shift(1) & ~is_night\n    is_daytime = (inputs['poa_global'] > 0) & ~is_dawn\n    # the accuracy is probably higher than 3 digits here, but the PVWatts\n    # export data has low precision so can only test up to 3 digits\n    assert_series_equal(expected_tcell[is_daytime].round(3),\n                        actual_tcell[is_daytime].round(3))\n    # use lower precision for dawn times to accommodate the dawn transient\n    error = actual_tcell[is_dawn] - expected_tcell[is_dawn]\n    assert (error.abs() < 0.1).all()\n    # sanity check on night values -- Fuentes not much lower than PVWatts\n    night_difference = expected_tcell[is_night] - actual_tcell[is_night]\n    assert night_difference.max() < 6\n    assert night_difference.min() > 0\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_fuentes", "filename", "inoct", "test", "against", "data", "exported", "from", "pvwatts", "nrel", "gov", "data", "_read_pvwatts_8760", "data_dir", "filename", "data", "data", "iloc", "24", "7", "just", "use", "one", "week", "inputs", "poa_global", "data", "plane", "of", "array", "irradiance", "w", "m", "2", "temp_air", "data", "ambient", "temperature", "c", "wind_speed", "data", "wind", "speed", "m", "s", "noct_installed", "inoct", "expected_tcell", "data", "cell", "temperature", "c", "expected_tcell", "name", "tmod", "actual_tcell", "temperature", "fuentes", "inputs", "the", "ssc", "implementation", "of", "pvwatts", "diverges", "from", "the", "fuentes", "model", "at", "at", "night", "by", "setting", "tcell", "tamb", "when", "poa", "0", "this", "not", "only", "means", "that", "nighttime", "values", "are", "slightly", "different", "fuentes", "models", "cooling", "to", "sky", "at", "night", "but", "because", "of", "the", "thermal", "inertia", "there", "is", "a", "transient", "error", "after", "dawn", "as", "well", "test", "each", "case", "separately", "is_night", "inputs", "poa_global", "0", "is_dawn", "is_night", "shift", "1", "is_night", "is_daytime", "inputs", "poa_global", "0", "is_dawn", "the", "accuracy", "is", "probably", "higher", "than", "3", "digits", "here", "but", "the", "pvwatts", "export", "data", "has", "low", "precision", "so", "can", "only", "test", "up", "to", "3", "digits", "assert_series_equal", "expected_tcell", "is_daytime", "round", "3", "actual_tcell", "is_daytime", "round", "3", "use", "lower", "precision", "for", "dawn", "times", "to", "accommodate", "the", "dawn", "transient", "error", "actual_tcell", "is_dawn", "expected_tcell", "is_dawn", "assert", "error", "abs", "0", "1", "all", "sanity", "check", "on", "night", "values", "fuentes", "not", "much", "lower", "than", "pvwatts", "night_difference", "expected_tcell", "is_night", "actual_tcell", "is_night", "assert", "night_difference", "max", "6", "assert", "night_difference", "min", "0"], "doc_len": 214}
{"doc_id": "pvlib/tests/test_temperature.py::test_fuentes_timezone", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_fuentes_timezone", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_fuentes_timezone(tz):\n    index = pd.date_range('2019-01-01', freq='h', periods=3, tz=tz)\n\n    df = pd.DataFrame({'poa_global': 1000, 'temp_air': 20, 'wind_speed': 1},\n                      index)\n\n    out = temperature.fuentes(df['poa_global'], df['temp_air'],\n                              df['wind_speed'], noct_installed=45)\n\n    assert_series_equal(out, pd.Series([47.85, 50.85, 50.85], index=index,\n                                       name='tmod'))\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_fuentes_timezone", "tz", "index", "pd", "date_range", "2019", "01", "01", "freq", "h", "periods", "3", "tz", "tz", "df", "pd", "dataframe", "poa_global", "1000", "temp_air", "20", "wind_speed", "1", "index", "out", "temperature", "fuentes", "df", "poa_global", "df", "temp_air", "df", "wind_speed", "noct_installed", "45", "assert_series_equal", "out", "pd", "series", "47", "85", "50", "85", "50", "85", "index", "index", "name", "tmod"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_temperature.py::test_noct_sam", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_noct_sam", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_noct_sam():\n    poa_global, temp_air, wind_speed, noct, module_efficiency = (\n        1000., 25., 1., 45., 0.2)\n    expected = 55.230790492\n    result = temperature.noct_sam(poa_global, temp_air, wind_speed, noct,\n                                  module_efficiency)\n    assert_allclose(result, expected)\n    # test with different types\n    result = temperature.noct_sam(np.array(poa_global), np.array(temp_air),\n                                  np.array(wind_speed), np.array(noct),\n                                  np.array(module_efficiency))\n    assert_allclose(result, expected)\n    dr = pd.date_range(start='2020-01-01 12:00:00', end='2020-01-01 13:00:00',\n                       freq='1H')\n    result = temperature.noct_sam(pd.Series(index=dr, data=poa_global),\n                                  pd.Series(index=dr, data=temp_air),\n                                  pd.Series(index=dr, data=wind_speed),\n                                  pd.Series(index=dr, data=noct),\n                                  module_efficiency)\n    assert_series_equal(result, pd.Series(index=dr, data=expected))\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_noct_sam", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "1000", "25", "1", "45", "0", "2", "expected", "55", "230790492", "result", "temperature", "noct_sam", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "assert_allclose", "result", "expected", "test", "with", "different", "types", "result", "temperature", "noct_sam", "np", "array", "poa_global", "np", "array", "temp_air", "np", "array", "wind_speed", "np", "array", "noct", "np", "array", "module_efficiency", "assert_allclose", "result", "expected", "dr", "pd", "date_range", "start", "2020", "01", "01", "12", "00", "00", "end", "2020", "01", "01", "13", "00", "00", "freq", "1h", "result", "temperature", "noct_sam", "pd", "series", "index", "dr", "data", "poa_global", "pd", "series", "index", "dr", "data", "temp_air", "pd", "series", "index", "dr", "data", "wind_speed", "pd", "series", "index", "dr", "data", "noct", "module_efficiency", "assert_series_equal", "result", "pd", "series", "index", "dr", "data", "expected"], "doc_len": 111}
{"doc_id": "pvlib/tests/test_temperature.py::test_noct_sam_against_sam", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_noct_sam_against_sam", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_noct_sam_against_sam():\n    # test is constructed to reproduce output from SAM v2020.11.29.\n    # SAM calculation is the default Detailed PV System model (CEC diode model,\n    # NOCT cell temperature model), with the only change being the soiling\n    # loss is set to 0. Weather input is TMY3 for Phoenix AZ.\n    # Values are taken from the Jan 1 12:00:00 timestamp.\n    poa_total, temp_air, wind_speed, noct, module_efficiency = (\n        860.673, 25, 3, 46.4, 0.20551)\n    poa_total_after_refl = 851.458  # from SAM output\n    # compute effective irradiance\n    # spectral loss coefficients fixed in lib_cec6par.cpp\n    a = np.flipud([0.918093, 0.086257, -0.024459, 0.002816, -0.000126])\n    # reproduce SAM air mass calculation\n    zen = 56.4284\n    elev = 358\n    air_mass = 1. / (tools.cosd(zen) + 0.5057 * (96.080 - zen)**-1.634)\n    air_mass *= np.exp(-0.0001184 * elev)\n    f1 = np.polyval(a, air_mass)\n    effective_irradiance = f1 * poa_total_after_refl\n    transmittance_absorptance = 0.9\n    array_height = 1\n    mount_standoff = 4.0\n    result = temperature.noct_sam(poa_total, temp_air, wind_speed, noct,\n                                  module_efficiency, effective_irradiance,\n                                  transmittance_absorptance, array_height,\n                                  mount_standoff)\n    expected = 43.0655\n    # rtol from limited SAM output precision\n    assert_allclose(result, expected, rtol=1e-5)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_noct_sam_against_sam", "test", "is", "constructed", "to", "reproduce", "output", "from", "sam", "v2020", "11", "29", "sam", "calculation", "is", "the", "default", "detailed", "pv", "system", "model", "cec", "diode", "model", "noct", "cell", "temperature", "model", "with", "the", "only", "change", "being", "the", "soiling", "loss", "is", "set", "to", "0", "weather", "input", "is", "tmy3", "for", "phoenix", "az", "values", "are", "taken", "from", "the", "jan", "1", "12", "00", "00", "timestamp", "poa_total", "temp_air", "wind_speed", "noct", "module_efficiency", "860", "673", "25", "3", "46", "4", "0", "20551", "poa_total_after_refl", "851", "458", "from", "sam", "output", "compute", "effective", "irradiance", "spectral", "loss", "coefficients", "fixed", "in", "lib_cec6par", "cpp", "a", "np", "flipud", "0", "918093", "0", "086257", "0", "024459", "0", "002816", "0", "000126", "reproduce", "sam", "air", "mass", "calculation", "zen", "56", "4284", "elev", "358", "air_mass", "1", "tools", "cosd", "zen", "0", "5057", "96", "080", "zen", "1", "634", "air_mass", "np", "exp", "0", "0001184", "elev", "f1", "np", "polyval", "a", "air_mass", "effective_irradiance", "f1", "poa_total_after_refl", "transmittance_absorptance", "0", "9", "array_height", "1", "mount_standoff", "4", "0", "result", "temperature", "noct_sam", "poa_total", "temp_air", "wind_speed", "noct", "module_efficiency", "effective_irradiance", "transmittance_absorptance", "array_height", "mount_standoff", "expected", "43", "0655", "rtol", "from", "limited", "sam", "output", "precision", "assert_allclose", "result", "expected", "rtol", "1e", "5"], "doc_len": 176}
{"doc_id": "pvlib/tests/test_temperature.py::test_noct_sam_options", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_noct_sam_options", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_noct_sam_options():\n    poa_global, temp_air, wind_speed, noct, module_efficiency = (\n        1000., 25., 1., 45., 0.2)\n    effective_irradiance = 1100.\n    transmittance_absorptance = 0.8\n    array_height = 2\n    mount_standoff = 2.0\n    result = temperature.noct_sam(poa_global, temp_air, wind_speed, noct,\n                                  module_efficiency, effective_irradiance,\n                                  transmittance_absorptance, array_height,\n                                  mount_standoff)\n    expected = 60.477703576\n    assert_allclose(result, expected)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_noct_sam_options", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "1000", "25", "1", "45", "0", "2", "effective_irradiance", "1100", "transmittance_absorptance", "0", "8", "array_height", "2", "mount_standoff", "2", "0", "result", "temperature", "noct_sam", "poa_global", "temp_air", "wind_speed", "noct", "module_efficiency", "effective_irradiance", "transmittance_absorptance", "array_height", "mount_standoff", "expected", "60", "477703576", "assert_allclose", "result", "expected"], "doc_len": 45}
{"doc_id": "pvlib/tests/test_temperature.py::test_noct_sam_errors", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_noct_sam_errors", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_noct_sam_errors():\n    with pytest.raises(ValueError):\n        temperature.noct_sam(1000., 25., 1., 34., 0.2, array_height=3)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_noct_sam_errors", "with", "pytest", "raises", "valueerror", "temperature", "noct_sam", "1000", "25", "1", "34", "0", "2", "array_height", "3"], "doc_len": 20}
{"doc_id": "pvlib/tests/test_temperature.py::test_prilliman", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_prilliman", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_prilliman():\n    # test against values calculated using pvl_MAmodel_2, see pvlib #1081\n    times = pd.date_range('2019-01-01', freq='5min', periods=8)\n    cell_temperature = pd.Series([0, 1, 3, 6, 10, 15, 21, 27], index=times)\n    wind_speed = pd.Series([0, 1, 2, 3, 2, 1, 2, 3])\n\n    # default coeffs\n    expected = pd.Series([0, 0, 0.7047457, 2.21176412, 4.45584299, 7.63635512,\n                          12.26808265, 18.00305776], index=times)\n    actual = temperature.prilliman(cell_temperature, wind_speed, unit_mass=10)\n    assert_series_equal(expected, actual)\n\n    # custom coeffs\n    coefficients = [0.0046, 4.5537e-4, -2.2586e-4, -1.5661e-5]\n    expected = pd.Series([0, 0, 0.70716941, 2.2199537, 4.47537694, 7.6676931,\n                          12.30423167, 18.04215198], index=times)\n    actual = temperature.prilliman(cell_temperature, wind_speed, unit_mass=10,\n                                   coefficients=coefficients)\n    assert_series_equal(expected, actual)\n\n    # even very short inputs < 20 minutes total still work\n    times = pd.date_range('2019-01-01', freq='1min', periods=8)\n    cell_temperature = pd.Series([0, 1, 3, 6, 10, 15, 21, 27], index=times)\n    wind_speed = pd.Series([0, 1, 2, 3, 2, 1, 2, 3])\n    expected = pd.Series([0, 0, 0.53557976, 1.49270094, 2.85940173,\n                          4.63914366, 7.09641845, 10.24899272], index=times)\n    actual = temperature.prilliman(cell_temperature, wind_speed, unit_mass=12)\n    assert_series_equal(expected, actual)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_prilliman", "test", "against", "values", "calculated", "using", "pvl_mamodel_2", "see", "pvlib", "1081", "times", "pd", "date_range", "2019", "01", "01", "freq", "5min", "periods", "8", "cell_temperature", "pd", "series", "0", "1", "3", "6", "10", "15", "21", "27", "index", "times", "wind_speed", "pd", "series", "0", "1", "2", "3", "2", "1", "2", "3", "default", "coeffs", "expected", "pd", "series", "0", "0", "0", "7047457", "2", "21176412", "4", "45584299", "7", "63635512", "12", "26808265", "18", "00305776", "index", "times", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "unit_mass", "10", "assert_series_equal", "expected", "actual", "custom", "coeffs", "coefficients", "0", "0046", "4", "5537e", "4", "2", "2586e", "4", "1", "5661e", "5", "expected", "pd", "series", "0", "0", "0", "70716941", "2", "2199537", "4", "47537694", "7", "6676931", "12", "30423167", "18", "04215198", "index", "times", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "unit_mass", "10", "coefficients", "coefficients", "assert_series_equal", "expected", "actual", "even", "very", "short", "inputs", "20", "minutes", "total", "still", "work", "times", "pd", "date_range", "2019", "01", "01", "freq", "1min", "periods", "8", "cell_temperature", "pd", "series", "0", "1", "3", "6", "10", "15", "21", "27", "index", "times", "wind_speed", "pd", "series", "0", "1", "2", "3", "2", "1", "2", "3", "expected", "pd", "series", "0", "0", "0", "53557976", "1", "49270094", "2", "85940173", "4", "63914366", "7", "09641845", "10", "24899272", "index", "times", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "unit_mass", "12", "assert_series_equal", "expected", "actual"], "doc_len": 197}
{"doc_id": "pvlib/tests/test_temperature.py::test_prilliman_coarse", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_prilliman_coarse", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_prilliman_coarse():\n    # if the input series time step is >= 20 min, input is returned unchanged,\n    # and a warning is emitted\n    times = pd.date_range('2019-01-01', freq='30min', periods=3)\n    cell_temperature = pd.Series([0, 1, 3], index=times)\n    wind_speed = pd.Series([0, 1, 2])\n    msg = re.escape(\"temperature.prilliman only applies smoothing when the \"\n                    \"sampling interval is shorter than 20 minutes (input \"\n                    \"sampling interval: 30.0 minutes); returning \"\n                    \"input temperature series unchanged\")\n    with pytest.warns(UserWarning, match=msg):\n        actual = temperature.prilliman(cell_temperature, wind_speed)\n    assert_series_equal(cell_temperature, actual)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_prilliman_coarse", "if", "the", "input", "series", "time", "step", "is", "20", "min", "input", "is", "returned", "unchanged", "and", "a", "warning", "is", "emitted", "times", "pd", "date_range", "2019", "01", "01", "freq", "30min", "periods", "3", "cell_temperature", "pd", "series", "0", "1", "3", "index", "times", "wind_speed", "pd", "series", "0", "1", "2", "msg", "re", "escape", "temperature", "prilliman", "only", "applies", "smoothing", "when", "the", "sampling", "interval", "is", "shorter", "than", "20", "minutes", "input", "sampling", "interval", "30", "0", "minutes", "returning", "input", "temperature", "series", "unchanged", "with", "pytest", "warns", "userwarning", "match", "msg", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "assert_series_equal", "cell_temperature", "actual"], "doc_len": 90}
{"doc_id": "pvlib/tests/test_temperature.py::test_prilliman_nans", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_prilliman_nans", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_prilliman_nans():\n    # nans in inputs are handled appropriately; nans in input tcell\n    # are ignored but nans in wind speed cause nan in output\n    times = pd.date_range('2019-01-01', freq='1min', periods=8)\n    cell_temperature = pd.Series([0, 1, 3, 6, 10, np.nan, 21, 27], index=times)\n    wind_speed = pd.Series([0, 1, 2, 3, 2, 1, np.nan, 3])\n    actual = temperature.prilliman(cell_temperature, wind_speed)\n    expected = pd.Series([True, True, True, True, True, True, False, True],\n                         index=times)\n    assert_series_equal(actual.notnull(), expected)\n\n    # check that nan temperatures do not mess up the weighted average;\n    # the original implementation did not set weight=0 for nan values,\n    # so the numerator of the weighted average ignored nans but the\n    # denominator (total weight) still included the weight for the nan.\n    cell_temperature = pd.Series([1, 1, 1, 1, 1, np.nan, 1, 1], index=times)\n    wind_speed = pd.Series(1, index=times)\n    actual = temperature.prilliman(cell_temperature, wind_speed)\n    # original implementation would return some values < 1 here\n    expected = pd.Series(1., index=times)\n    assert_series_equal(actual, expected)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_prilliman_nans", "nans", "in", "inputs", "are", "handled", "appropriately", "nans", "in", "input", "tcell", "are", "ignored", "but", "nans", "in", "wind", "speed", "cause", "nan", "in", "output", "times", "pd", "date_range", "2019", "01", "01", "freq", "1min", "periods", "8", "cell_temperature", "pd", "series", "0", "1", "3", "6", "10", "np", "nan", "21", "27", "index", "times", "wind_speed", "pd", "series", "0", "1", "2", "3", "2", "1", "np", "nan", "3", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "expected", "pd", "series", "true", "true", "true", "true", "true", "true", "false", "true", "index", "times", "assert_series_equal", "actual", "notnull", "expected", "check", "that", "nan", "temperatures", "do", "not", "mess", "up", "the", "weighted", "average", "the", "original", "implementation", "did", "not", "set", "weight", "0", "for", "nan", "values", "so", "the", "numerator", "of", "the", "weighted", "average", "ignored", "nans", "but", "the", "denominator", "total", "weight", "still", "included", "the", "weight", "for", "the", "nan", "cell_temperature", "pd", "series", "1", "1", "1", "1", "1", "np", "nan", "1", "1", "index", "times", "wind_speed", "pd", "series", "1", "index", "times", "actual", "temperature", "prilliman", "cell_temperature", "wind_speed", "original", "implementation", "would", "return", "some", "values", "1", "here", "expected", "pd", "series", "1", "index", "times", "assert_series_equal", "actual", "expected"], "doc_len": 170}
{"doc_id": "pvlib/tests/test_temperature.py::test_glm_conversions", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_glm_conversions", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_glm_conversions():\n    # it is easiest and sufficient to test conversion from  & to the same model\n    glm = temperature.GenericLinearModel(module_efficiency=0.1,\n                                         absorptance=0.9)\n\n    inp = {'u0': 25.0, 'u1': 6.84}\n    glm.use_faiman(**inp)\n    out = glm.to_faiman()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n\n    inp = {'u_c': 25, 'u_v': 4}\n    glm.use_pvsyst(**inp)\n    out = glm.to_pvsyst()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n\n    # test with optional parameters\n    inp = {'u_c': 25, 'u_v': 4,\n           'module_efficiency': 0.15,\n           'alpha_absorption': 0.95}\n    glm.use_pvsyst(**inp)\n    out = glm.to_pvsyst()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n\n    inp = {'noct': 47}\n    glm.use_noct_sam(**inp)\n    out = glm.to_noct_sam()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n\n    # test with optional parameters\n    inp = {'noct': 47,\n           'module_efficiency': 0.15,\n           'transmittance_absorptance': 0.95}\n    glm.use_noct_sam(**inp)\n    out = glm.to_noct_sam()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n\n    inp = {'a': -3.5, 'b': -0.1}\n    glm.use_sapm(**inp)\n    out = glm.to_sapm()\n    for k, v in inp.items():\n        assert np.isclose(out[k], v)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_glm_conversions", "it", "is", "easiest", "and", "sufficient", "to", "test", "conversion", "from", "to", "the", "same", "model", "glm", "temperature", "genericlinearmodel", "module_efficiency", "0", "1", "absorptance", "0", "9", "inp", "u0", "25", "0", "u1", "6", "84", "glm", "use_faiman", "inp", "out", "glm", "to_faiman", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v", "inp", "u_c", "25", "u_v", "4", "glm", "use_pvsyst", "inp", "out", "glm", "to_pvsyst", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v", "test", "with", "optional", "parameters", "inp", "u_c", "25", "u_v", "4", "module_efficiency", "0", "15", "alpha_absorption", "0", "95", "glm", "use_pvsyst", "inp", "out", "glm", "to_pvsyst", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v", "inp", "noct", "47", "glm", "use_noct_sam", "inp", "out", "glm", "to_noct_sam", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v", "test", "with", "optional", "parameters", "inp", "noct", "47", "module_efficiency", "0", "15", "transmittance_absorptance", "0", "95", "glm", "use_noct_sam", "inp", "out", "glm", "to_noct_sam", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v", "inp", "a", "3", "5", "b", "0", "1", "glm", "use_sapm", "inp", "out", "glm", "to_sapm", "for", "k", "v", "in", "inp", "items", "assert", "np", "isclose", "out", "k", "v"], "doc_len": 186}
{"doc_id": "pvlib/tests/test_temperature.py::test_glm_simulations", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_glm_simulations", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_glm_simulations():\n\n    glm = temperature.GenericLinearModel(module_efficiency=0.1,\n                                         absorptance=0.9)\n    wind = np.array([1.4, 1/.51, 5.4])\n    weather = (800, 20, wind)\n\n    inp = {'u0': 20.0, 'u1': 5.0}\n    glm.use_faiman(**inp)\n    out = glm(*weather)\n    expected = temperature.faiman(*weather, **inp)\n    assert np.allclose(out, expected)\n\n    out = glm(*weather)\n    assert np.allclose(out, expected)\n\n    out = glm(*weather, module_efficiency=0.1)\n    assert np.allclose(out, expected)\n\n    inp = glm.get_generic_linear()\n    out = temperature.generic_linear(*weather, **inp)\n    assert np.allclose(out, expected)\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_glm_simulations", "glm", "temperature", "genericlinearmodel", "module_efficiency", "0", "1", "absorptance", "0", "9", "wind", "np", "array", "1", "4", "1", "51", "5", "4", "weather", "800", "20", "wind", "inp", "u0", "20", "0", "u1", "5", "0", "glm", "use_faiman", "inp", "out", "glm", "weather", "expected", "temperature", "faiman", "weather", "inp", "assert", "np", "allclose", "out", "expected", "out", "glm", "weather", "assert", "np", "allclose", "out", "expected", "out", "glm", "weather", "module_efficiency", "0", "1", "assert", "np", "allclose", "out", "expected", "inp", "glm", "get_generic_linear", "out", "temperature", "generic_linear", "weather", "inp", "assert", "np", "allclose", "out", "expected"], "doc_len": 83}
{"doc_id": "pvlib/tests/test_temperature.py::test_glm_repr", "file_path": "pvlib/tests/test_temperature.py", "class_name": null, "func_name": "test_glm_repr", "text": "文件路径: pvlib/tests/test_temperature.py\ndef test_glm_repr():\n\n    glm = temperature.GenericLinearModel(module_efficiency=0.1,\n                                         absorptance=0.9)\n    inp = {'u0': 20.0, 'u1': 5.0}\n    glm.use_faiman(**inp)\n    expected = (\"GenericLinearModel: {\"\n                \"'u_const': 16.0, \"\n                \"'du_wind': 4.0, \"\n                \"'eta': 0.1, \"\n                \"'alpha': 0.9}\")\n\n    assert glm.__repr__() == expected\n", "tokens": ["pvlib", "tests", "test_temperature", "py", "def", "test_glm_repr", "glm", "temperature", "genericlinearmodel", "module_efficiency", "0", "1", "absorptance", "0", "9", "inp", "u0", "20", "0", "u1", "5", "0", "glm", "use_faiman", "inp", "expected", "genericlinearmodel", "u_const", "16", "0", "du_wind", "4", "0", "eta", "0", "1", "alpha", "0", "9", "assert", "glm", "__repr__", "expected"], "doc_len": 43}
{"doc_id": "pvlib/tests/test_tools.py::test_build_kwargs", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test_build_kwargs", "text": "文件路径: pvlib/tests/test_tools.py\ndef test_build_kwargs(keys, input_dict, expected):\n    kwargs = tools._build_kwargs(keys, input_dict)\n    assert kwargs == expected\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test_build_kwargs", "keys", "input_dict", "expected", "kwargs", "tools", "_build_kwargs", "keys", "input_dict", "assert", "kwargs", "expected"], "doc_len": 17}
{"doc_id": "pvlib/tests/test_tools.py::_obj_test_golden_sect", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "_obj_test_golden_sect", "text": "文件路径: pvlib/tests/test_tools.py\ndef _obj_test_golden_sect(params, loc):\n    return params[loc] * (1. - params['c'] * params[loc]**params['n'])\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "_obj_test_golden_sect", "params", "loc", "return", "params", "loc", "1", "params", "c", "params", "loc", "params", "n"], "doc_len": 18}
{"doc_id": "pvlib/tests/test_tools.py::test__golden_sect_DataFrame", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test__golden_sect_DataFrame", "text": "文件路径: pvlib/tests/test_tools.py\ndef test__golden_sect_DataFrame(params, lb, ub, expected, func):\n    v, x = tools._golden_sect_DataFrame(params, lb, ub, func)\n    assert np.isclose(x, expected, atol=1e-8)\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test__golden_sect_dataframe", "params", "lb", "ub", "expected", "func", "v", "x", "tools", "_golden_sect_dataframe", "params", "lb", "ub", "func", "assert", "np", "isclose", "x", "expected", "atol", "1e", "8"], "doc_len": 27}
{"doc_id": "pvlib/tests/test_tools.py::test__golden_sect_DataFrame_atol", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test__golden_sect_DataFrame_atol", "text": "文件路径: pvlib/tests/test_tools.py\ndef test__golden_sect_DataFrame_atol():\n    params = {'c': 0.2, 'n': 0.3}\n    expected = 89.14332727531685\n    v, x = tools._golden_sect_DataFrame(\n        params, 0., 100., _obj_test_golden_sect, atol=1e-12)\n    assert np.isclose(x, expected, atol=1e-12)\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test__golden_sect_dataframe_atol", "params", "c", "0", "2", "n", "0", "3", "expected", "89", "14332727531685", "v", "x", "tools", "_golden_sect_dataframe", "params", "0", "100", "_obj_test_golden_sect", "atol", "1e", "12", "assert", "np", "isclose", "x", "expected", "atol", "1e", "12"], "doc_len": 35}
{"doc_id": "pvlib/tests/test_tools.py::test__golden_sect_DataFrame_vector", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test__golden_sect_DataFrame_vector", "text": "文件路径: pvlib/tests/test_tools.py\ndef test__golden_sect_DataFrame_vector():\n    params = {'c': np.array([1., 2.]), 'n': np.array([1., 1.])}\n    lower = np.array([0., 0.001])\n    upper = np.array([1.1, 1.2])\n    expected = np.array([0.5, 0.25])\n    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n                                        _obj_test_golden_sect)\n    assert np.allclose(x, expected, atol=1e-8)\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test__golden_sect_dataframe_vector", "params", "c", "np", "array", "1", "2", "n", "np", "array", "1", "1", "lower", "np", "array", "0", "0", "001", "upper", "np", "array", "1", "1", "1", "2", "expected", "np", "array", "0", "5", "0", "25", "v", "x", "tools", "_golden_sect_dataframe", "params", "lower", "upper", "_obj_test_golden_sect", "assert", "np", "allclose", "x", "expected", "atol", "1e", "8"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_tools.py::test__golden_sect_DataFrame_nans", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test__golden_sect_DataFrame_nans", "text": "文件路径: pvlib/tests/test_tools.py\ndef test__golden_sect_DataFrame_nans():\n    # nan in bounds\n    params = {'c': np.array([1., 2., 1.]), 'n': np.array([1., 1., 1.])}\n    lower = np.array([0., 0.001, np.nan])\n    upper = np.array([1.1, 1.2, 1.])\n    expected = np.array([0.5, 0.25, np.nan])\n    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n                                        _obj_test_golden_sect)\n    assert np.allclose(x, expected, atol=1e-8, equal_nan=True)\n    # nan in function values\n    params = {'c': np.array([1., 2., np.nan]), 'n': np.array([1., 1., 1.])}\n    lower = np.array([0., 0.001, 0.])\n    upper = np.array([1.1, 1.2, 1.])\n    expected = np.array([0.5, 0.25, np.nan])\n    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n                                        _obj_test_golden_sect)\n    assert np.allclose(x, expected, atol=1e-8, equal_nan=True)\n    # all nan in bounds\n    params = {'c': np.array([1., 2., 1.]), 'n': np.array([1., 1., 1.])}\n    lower = np.array([np.nan, np.nan, np.nan])\n    upper = np.array([1.1, 1.2, 1.])\n    expected = np.array([np.nan, np.nan, np.nan])\n    v, x = tools._golden_sect_DataFrame(params, lower, upper,\n                                        _obj_test_golden_sect)\n    assert np.allclose(x, expected, atol=1e-8, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test__golden_sect_dataframe_nans", "nan", "in", "bounds", "params", "c", "np", "array", "1", "2", "1", "n", "np", "array", "1", "1", "1", "lower", "np", "array", "0", "0", "001", "np", "nan", "upper", "np", "array", "1", "1", "1", "2", "1", "expected", "np", "array", "0", "5", "0", "25", "np", "nan", "v", "x", "tools", "_golden_sect_dataframe", "params", "lower", "upper", "_obj_test_golden_sect", "assert", "np", "allclose", "x", "expected", "atol", "1e", "8", "equal_nan", "true", "nan", "in", "function", "values", "params", "c", "np", "array", "1", "2", "np", "nan", "n", "np", "array", "1", "1", "1", "lower", "np", "array", "0", "0", "001", "0", "upper", "np", "array", "1", "1", "1", "2", "1", "expected", "np", "array", "0", "5", "0", "25", "np", "nan", "v", "x", "tools", "_golden_sect_dataframe", "params", "lower", "upper", "_obj_test_golden_sect", "assert", "np", "allclose", "x", "expected", "atol", "1e", "8", "equal_nan", "true", "all", "nan", "in", "bounds", "params", "c", "np", "array", "1", "2", "1", "n", "np", "array", "1", "1", "1", "lower", "np", "array", "np", "nan", "np", "nan", "np", "nan", "upper", "np", "array", "1", "1", "1", "2", "1", "expected", "np", "array", "np", "nan", "np", "nan", "np", "nan", "v", "x", "tools", "_golden_sect_dataframe", "params", "lower", "upper", "_obj_test_golden_sect", "assert", "np", "allclose", "x", "expected", "atol", "1e", "8", "equal_nan", "true"], "doc_len": 186}
{"doc_id": "pvlib/tests/test_tools.py::test_degrees_to_index_1", "file_path": "pvlib/tests/test_tools.py", "class_name": null, "func_name": "test_degrees_to_index_1", "text": "文件路径: pvlib/tests/test_tools.py\ndef test_degrees_to_index_1():\n    \"\"\"Test that _degrees_to_index raises an error when something other than\n    'latitude' or 'longitude' is passed.\"\"\"\n    with pytest.raises(IndexError):  # invalid value for coordinate argument\n        tools._degrees_to_index(degrees=22.0, coordinate='width')\n", "tokens": ["pvlib", "tests", "test_tools", "py", "def", "test_degrees_to_index_1", "test", "that", "_degrees_to_index", "raises", "an", "error", "when", "something", "other", "than", "latitude", "or", "longitude", "is", "passed", "with", "pytest", "raises", "indexerror", "invalid", "value", "for", "coordinate", "argument", "tools", "_degrees_to_index", "degrees", "22", "0", "coordinate", "width"], "doc_len": 37}
{"doc_id": "pvlib/tests/test_tracking.py::test_solar_noon", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_solar_noon", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_solar_noon():\n    index = pd.date_range(start='20180701T1200', freq='1s', periods=1)\n    apparent_zenith = pd.Series([10], index=index)\n    apparent_azimuth = pd.Series([180], index=index)\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'tracker_theta': 0, 'aoi': 10,\n                           'surface_azimuth': 90, 'surface_tilt': 0},\n                          index=index, dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_solar_noon", "index", "pd", "date_range", "start", "20180701t1200", "freq", "1s", "periods", "1", "apparent_zenith", "pd", "series", "10", "index", "index", "apparent_azimuth", "pd", "series", "180", "index", "index", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "tracker_theta", "0", "aoi", "10", "surface_azimuth", "90", "surface_tilt", "0", "index", "index", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 67}
{"doc_id": "pvlib/tests/test_tracking.py::test_scalars", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_scalars", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_scalars():\n    apparent_zenith = 10\n    apparent_azimuth = 180\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n    assert isinstance(tracker_data, dict)\n    expect = {'tracker_theta': 0, 'aoi': 10, 'surface_azimuth': 90,\n              'surface_tilt': 0}\n    for k, v in expect.items():\n        assert np.isclose(tracker_data[k], v)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_scalars", "apparent_zenith", "10", "apparent_azimuth", "180", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "assert", "isinstance", "tracker_data", "dict", "expect", "tracker_theta", "0", "aoi", "10", "surface_azimuth", "90", "surface_tilt", "0", "for", "k", "v", "in", "expect", "items", "assert", "np", "isclose", "tracker_data", "k", "v"], "doc_len": 53}
{"doc_id": "pvlib/tests/test_tracking.py::test_arrays", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_arrays", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_arrays():\n    apparent_zenith = np.array([10])\n    apparent_azimuth = np.array([180])\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n    assert isinstance(tracker_data, dict)\n    expect = {'tracker_theta': 0, 'aoi': 10, 'surface_azimuth': 90,\n              'surface_tilt': 0}\n    for k, v in expect.items():\n        assert_allclose(tracker_data[k], v, atol=1e-7)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_arrays", "apparent_zenith", "np", "array", "10", "apparent_azimuth", "np", "array", "180", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "assert", "isinstance", "tracker_data", "dict", "expect", "tracker_theta", "0", "aoi", "10", "surface_azimuth", "90", "surface_tilt", "0", "for", "k", "v", "in", "expect", "items", "assert_allclose", "tracker_data", "k", "v", "atol", "1e", "7"], "doc_len": 58}
{"doc_id": "pvlib/tests/test_tracking.py::test_nans", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_nans", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_nans():\n    apparent_zenith = np.array([10, np.nan, 10])\n    apparent_azimuth = np.array([180, 180, np.nan])\n    with np.errstate(invalid='ignore'):\n        tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                           axis_tilt=0, axis_azimuth=0,\n                                           max_angle=90, backtrack=True,\n                                           gcr=2.0/7.0)\n    expect = {'tracker_theta': np.array([0, nan, nan]),\n              'aoi': np.array([10, nan, nan]),\n              'surface_azimuth': np.array([90, nan, nan]),\n              'surface_tilt': np.array([0, nan, nan])}\n    for k, v in expect.items():\n        assert_allclose(tracker_data[k], v, atol=1e-7)\n\n    # repeat with Series because nans can differ\n    apparent_zenith = pd.Series(apparent_zenith)\n    apparent_azimuth = pd.Series(apparent_azimuth)\n    with np.errstate(invalid='ignore'):\n        tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                           axis_tilt=0, axis_azimuth=0,\n                                           max_angle=90, backtrack=True,\n                                           gcr=2.0/7.0)\n    expect = pd.DataFrame(np.array(\n        [[ 0., 10., 90.,  0.],\n         [nan, nan, nan, nan],\n         [nan, nan, nan, nan]]),\n        columns=['tracker_theta', 'aoi', 'surface_azimuth', 'surface_tilt'])\n    assert_frame_equal(tracker_data, expect)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_nans", "apparent_zenith", "np", "array", "10", "np", "nan", "10", "apparent_azimuth", "np", "array", "180", "180", "np", "nan", "with", "np", "errstate", "invalid", "ignore", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "tracker_theta", "np", "array", "0", "nan", "nan", "aoi", "np", "array", "10", "nan", "nan", "surface_azimuth", "np", "array", "90", "nan", "nan", "surface_tilt", "np", "array", "0", "nan", "nan", "for", "k", "v", "in", "expect", "items", "assert_allclose", "tracker_data", "k", "v", "atol", "1e", "7", "repeat", "with", "series", "because", "nans", "can", "differ", "apparent_zenith", "pd", "series", "apparent_zenith", "apparent_azimuth", "pd", "series", "apparent_azimuth", "with", "np", "errstate", "invalid", "ignore", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "np", "array", "0", "10", "90", "0", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "nan", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "assert_frame_equal", "tracker_data", "expect"], "doc_len": 144}
{"doc_id": "pvlib/tests/test_tracking.py::test_arrays_multi", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_arrays_multi", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_arrays_multi():\n    apparent_zenith = np.array([[10, 10], [10, 10]])\n    apparent_azimuth = np.array([[180, 180], [180, 180]])\n    # singleaxis should fail for num dim > 1\n    with pytest.raises(ValueError):\n        tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                            axis_tilt=0, axis_azimuth=0,\n                            max_angle=90, backtrack=True,\n                            gcr=2.0/7.0)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_arrays_multi", "apparent_zenith", "np", "array", "10", "10", "10", "10", "apparent_azimuth", "np", "array", "180", "180", "180", "180", "singleaxis", "should", "fail", "for", "num", "dim", "1", "with", "pytest", "raises", "valueerror", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0"], "doc_len": 48}
{"doc_id": "pvlib/tests/test_tracking.py::test_azimuth_north_south", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_azimuth_north_south", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_azimuth_north_south():\n    apparent_zenith = pd.Series([60])\n    apparent_azimuth = pd.Series([90])\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=180,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'tracker_theta': -60, 'aoi': 0,\n                           'surface_azimuth': 90, 'surface_tilt': 60},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect['tracker_theta'] *= -1\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_azimuth_north_south", "apparent_zenith", "pd", "series", "60", "apparent_azimuth", "pd", "series", "90", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "180", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "tracker_theta", "60", "aoi", "0", "surface_azimuth", "90", "surface_tilt", "60", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "tracker_theta", "1", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 78}
{"doc_id": "pvlib/tests/test_tracking.py::test_max_angle", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_max_angle", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_max_angle():\n    apparent_zenith = pd.Series([60])\n    apparent_azimuth = pd.Series([90])\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=45, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 15, 'surface_azimuth': 90,\n                           'surface_tilt': 45, 'tracker_theta': 45},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_max_angle", "apparent_zenith", "pd", "series", "60", "apparent_azimuth", "pd", "series", "90", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "45", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "15", "surface_azimuth", "90", "surface_tilt", "45", "tracker_theta", "45", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 54}
{"doc_id": "pvlib/tests/test_tracking.py::test_backtrack", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_backtrack", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_backtrack():\n    apparent_zenith = pd.Series([80])\n    apparent_azimuth = pd.Series([90])\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=False,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 0, 'surface_azimuth': 90,\n                           'surface_tilt': 80, 'tracker_theta': 80},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 52.5716, 'surface_azimuth': 90,\n                           'surface_tilt': 27.42833, 'tracker_theta': 27.4283},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_backtrack", "apparent_zenith", "pd", "series", "80", "apparent_azimuth", "pd", "series", "90", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "false", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "0", "surface_azimuth", "90", "surface_tilt", "80", "tracker_theta", "80", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "52", "5716", "surface_azimuth", "90", "surface_tilt", "27", "42833", "tracker_theta", "27", "4283", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 97}
{"doc_id": "pvlib/tests/test_tracking.py::test_axis_tilt", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_axis_tilt", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_axis_tilt():\n    apparent_zenith = pd.Series([30])\n    apparent_azimuth = pd.Series([135])\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=30, axis_azimuth=180,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 7.286245, 'surface_azimuth': 142.65730,\n                           'surface_tilt': 35.98741,\n                           'tracker_theta': -20.88121},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=30, axis_azimuth=0,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 47.6632, 'surface_azimuth': 50.96969,\n                           'surface_tilt': 42.5152, 'tracker_theta': 31.6655},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_axis_tilt", "apparent_zenith", "pd", "series", "30", "apparent_azimuth", "pd", "series", "135", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "30", "axis_azimuth", "180", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "7", "286245", "surface_azimuth", "142", "65730", "surface_tilt", "35", "98741", "tracker_theta", "20", "88121", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "30", "axis_azimuth", "0", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "47", "6632", "surface_azimuth", "50", "96969", "surface_tilt", "42", "5152", "tracker_theta", "31", "6655", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 102}
{"doc_id": "pvlib/tests/test_tracking.py::test_axis_azimuth", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_axis_azimuth", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_axis_azimuth():\n    apparent_zenith = pd.Series([30])\n    apparent_azimuth = pd.Series([90])\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=90,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 30, 'surface_azimuth': 180,\n                           'surface_tilt': 0, 'tracker_theta': 0},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n\n    apparent_zenith = pd.Series([30])\n    apparent_azimuth = pd.Series([180])\n\n    tracker_data = tracking.singleaxis(apparent_zenith, apparent_azimuth,\n                                       axis_tilt=0, axis_azimuth=90,\n                                       max_angle=90, backtrack=True,\n                                       gcr=2.0/7.0)\n\n    expect = pd.DataFrame({'aoi': 0, 'surface_azimuth': 180,\n                           'surface_tilt': 30, 'tracker_theta': 30},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_axis_azimuth", "apparent_zenith", "pd", "series", "30", "apparent_azimuth", "pd", "series", "90", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "90", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "30", "surface_azimuth", "180", "surface_tilt", "0", "tracker_theta", "0", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data", "apparent_zenith", "pd", "series", "30", "apparent_azimuth", "pd", "series", "180", "tracker_data", "tracking", "singleaxis", "apparent_zenith", "apparent_azimuth", "axis_tilt", "0", "axis_azimuth", "90", "max_angle", "90", "backtrack", "true", "gcr", "2", "0", "7", "0", "expect", "pd", "dataframe", "aoi", "0", "surface_azimuth", "180", "surface_tilt", "30", "tracker_theta", "30", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 102}
{"doc_id": "pvlib/tests/test_tracking.py::test_horizon_flat", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_horizon_flat", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_horizon_flat():\n    # GH 569\n    solar_azimuth = np.array([0, 180, 359])\n    solar_zenith = np.array([100, 45, 100])\n    solar_azimuth = pd.Series(solar_azimuth)\n    solar_zenith = pd.Series(solar_zenith)\n    # depending on platform and numpy versions this will generate\n    # RuntimeWarning: invalid value encountered in > < >=\n    out = tracking.singleaxis(solar_zenith, solar_azimuth, axis_tilt=0,\n                              axis_azimuth=180, backtrack=False, max_angle=180)\n    expected = pd.DataFrame(np.array(\n        [[ nan,  nan,  nan,  nan],\n         [  0.,  45., 270.,   0.],\n         [ nan,  nan,  nan,  nan]]),\n        columns=['tracker_theta', 'aoi', 'surface_azimuth', 'surface_tilt'])\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_horizon_flat", "gh", "569", "solar_azimuth", "np", "array", "0", "180", "359", "solar_zenith", "np", "array", "100", "45", "100", "solar_azimuth", "pd", "series", "solar_azimuth", "solar_zenith", "pd", "series", "solar_zenith", "depending", "on", "platform", "and", "numpy", "versions", "this", "will", "generate", "runtimewarning", "invalid", "value", "encountered", "in", "out", "tracking", "singleaxis", "solar_zenith", "solar_azimuth", "axis_tilt", "0", "axis_azimuth", "180", "backtrack", "false", "max_angle", "180", "expected", "pd", "dataframe", "np", "array", "nan", "nan", "nan", "nan", "0", "45", "270", "0", "nan", "nan", "nan", "nan", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "assert_frame_equal", "out", "expected"], "doc_len": 80}
{"doc_id": "pvlib/tests/test_tracking.py::test_horizon_tilted", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_horizon_tilted", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_horizon_tilted():\n    # GH 569\n    solar_azimuth = np.array([0, 180, 359])\n    solar_zenith = np.full_like(solar_azimuth, 45)\n    solar_azimuth = pd.Series(solar_azimuth)\n    solar_zenith = pd.Series(solar_zenith)\n    out = tracking.singleaxis(solar_zenith, solar_azimuth, axis_tilt=90,\n                              axis_azimuth=180, backtrack=False, max_angle=180)\n    expected = pd.DataFrame(np.array(\n        [[-180.,  45.,   0.,  90.],\n         [   0.,  45., 180.,  90.],\n         [ 179.,  45., 359.,  90.]]),\n        columns=['tracker_theta', 'aoi', 'surface_azimuth', 'surface_tilt'])\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_horizon_tilted", "gh", "569", "solar_azimuth", "np", "array", "0", "180", "359", "solar_zenith", "np", "full_like", "solar_azimuth", "45", "solar_azimuth", "pd", "series", "solar_azimuth", "solar_zenith", "pd", "series", "solar_zenith", "out", "tracking", "singleaxis", "solar_zenith", "solar_azimuth", "axis_tilt", "90", "axis_azimuth", "180", "backtrack", "false", "max_angle", "180", "expected", "pd", "dataframe", "np", "array", "180", "45", "0", "90", "0", "45", "180", "90", "179", "45", "359", "90", "columns", "tracker_theta", "aoi", "surface_azimuth", "surface_tilt", "assert_frame_equal", "out", "expected"], "doc_len": 65}
{"doc_id": "pvlib/tests/test_tracking.py::test_low_sun_angles", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_low_sun_angles", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_low_sun_angles():\n    # GH 656, 824\n    result = tracking.singleaxis(\n        apparent_zenith=80, apparent_azimuth=338, axis_tilt=30,\n        axis_azimuth=180, max_angle=60, backtrack=True, gcr=0.35)\n    expected = {\n        'tracker_theta': np.array([60.0]),\n        'aoi': np.array([80.420987]),\n        'surface_azimuth': np.array([253.897886]),\n        'surface_tilt': np.array([64.341094])}\n    for k, v in result.items():\n        assert_allclose(expected[k], v)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_low_sun_angles", "gh", "656", "824", "result", "tracking", "singleaxis", "apparent_zenith", "80", "apparent_azimuth", "338", "axis_tilt", "30", "axis_azimuth", "180", "max_angle", "60", "backtrack", "true", "gcr", "0", "35", "expected", "tracker_theta", "np", "array", "60", "0", "aoi", "np", "array", "80", "420987", "surface_azimuth", "np", "array", "253", "897886", "surface_tilt", "np", "array", "64", "341094", "for", "k", "v", "in", "result", "items", "assert_allclose", "expected", "k", "v"], "doc_len": 58}
{"doc_id": "pvlib/tests/test_tracking.py::test_SingleAxisTracker_tracking", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_SingleAxisTracker_tracking", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_SingleAxisTracker_tracking():\n    with pytest.warns(pvlibDeprecationWarning):\n        system = tracking.SingleAxisTracker(max_angle=90, axis_tilt=30,\n                                            axis_azimuth=180, gcr=2.0/7.0,\n                                            backtrack=True)\n\n    apparent_zenith = pd.Series([30])\n    apparent_azimuth = pd.Series([135])\n\n    tracker_data = system.singleaxis(apparent_zenith, apparent_azimuth)\n\n    expect = pd.DataFrame({'aoi': 7.286245, 'surface_azimuth': 142.65730,\n                           'surface_tilt': 35.98741,\n                           'tracker_theta': -20.88121},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n\n    # results calculated using PVsyst\n    pvsyst_solar_azimuth = 7.1609\n    pvsyst_solar_height = 27.315\n    pvsyst_axis_tilt = 20.\n    pvsyst_axis_azimuth = 20.\n    with pytest.warns(pvlibDeprecationWarning):\n        pvsyst_system = tracking.SingleAxisTracker(\n            max_angle=60., axis_tilt=pvsyst_axis_tilt,\n            axis_azimuth=180+pvsyst_axis_azimuth, backtrack=False)\n    # the definition of azimuth is different from PYsyst\n    apparent_azimuth = pd.Series([180+pvsyst_solar_azimuth])\n    apparent_zenith = pd.Series([90-pvsyst_solar_height])\n    tracker_data = pvsyst_system.singleaxis(apparent_zenith, apparent_azimuth)\n    expect = pd.DataFrame({'aoi': 41.07852, 'surface_azimuth': 180-18.432,\n                           'surface_tilt': 24.92122,\n                           'tracker_theta': -15.18391},\n                          index=[0], dtype=np.float64)\n    expect = expect[SINGLEAXIS_COL_ORDER]\n\n    assert_frame_equal(expect, tracker_data)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_singleaxistracker_tracking", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "tracking", "singleaxistracker", "max_angle", "90", "axis_tilt", "30", "axis_azimuth", "180", "gcr", "2", "0", "7", "0", "backtrack", "true", "apparent_zenith", "pd", "series", "30", "apparent_azimuth", "pd", "series", "135", "tracker_data", "system", "singleaxis", "apparent_zenith", "apparent_azimuth", "expect", "pd", "dataframe", "aoi", "7", "286245", "surface_azimuth", "142", "65730", "surface_tilt", "35", "98741", "tracker_theta", "20", "88121", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data", "results", "calculated", "using", "pvsyst", "pvsyst_solar_azimuth", "7", "1609", "pvsyst_solar_height", "27", "315", "pvsyst_axis_tilt", "20", "pvsyst_axis_azimuth", "20", "with", "pytest", "warns", "pvlibdeprecationwarning", "pvsyst_system", "tracking", "singleaxistracker", "max_angle", "60", "axis_tilt", "pvsyst_axis_tilt", "axis_azimuth", "180", "pvsyst_axis_azimuth", "backtrack", "false", "the", "definition", "of", "azimuth", "is", "different", "from", "pysyst", "apparent_azimuth", "pd", "series", "180", "pvsyst_solar_azimuth", "apparent_zenith", "pd", "series", "90", "pvsyst_solar_height", "tracker_data", "pvsyst_system", "singleaxis", "apparent_zenith", "apparent_azimuth", "expect", "pd", "dataframe", "aoi", "41", "07852", "surface_azimuth", "180", "18", "432", "surface_tilt", "24", "92122", "tracker_theta", "15", "18391", "index", "0", "dtype", "np", "float64", "expect", "expect", "singleaxis_col_order", "assert_frame_equal", "expect", "tracker_data"], "doc_len": 145}
{"doc_id": "pvlib/tests/test_tracking.py::test_get_aoi", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_get_aoi", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_get_aoi():\n    with pytest.warns(pvlibDeprecationWarning):\n        system = tracking.SingleAxisTracker(max_angle=90, axis_tilt=30,\n                                            axis_azimuth=180, gcr=2.0/7.0,\n                                            backtrack=True)\n    surface_tilt = np.array([30, 0])\n    surface_azimuth = np.array([90, 270])\n    solar_zenith = np.array([70, 10])\n    solar_azimuth = np.array([100, 180])\n    out = system.get_aoi(surface_tilt, surface_azimuth,\n                         solar_zenith, solar_azimuth)\n    expected = np.array([40.632115, 10.])\n    assert_allclose(out, expected, atol=0.000001)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_get_aoi", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "tracking", "singleaxistracker", "max_angle", "90", "axis_tilt", "30", "axis_azimuth", "180", "gcr", "2", "0", "7", "0", "backtrack", "true", "surface_tilt", "np", "array", "30", "0", "surface_azimuth", "np", "array", "90", "270", "solar_zenith", "np", "array", "70", "10", "solar_azimuth", "np", "array", "100", "180", "out", "system", "get_aoi", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "expected", "np", "array", "40", "632115", "10", "assert_allclose", "out", "expected", "atol", "0", "000001"], "doc_len": 65}
{"doc_id": "pvlib/tests/test_tracking.py::test_get_irradiance", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_get_irradiance", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_get_irradiance():\n    with pytest.warns(pvlibDeprecationWarning):\n        system = tracking.SingleAxisTracker(max_angle=90, axis_tilt=30,\n                                            axis_azimuth=180, gcr=2.0/7.0,\n                                            backtrack=True)\n    times = pd.date_range(start='20160101 1200-0700',\n                          end='20160101 1800-0700', freq='6H')\n    # latitude=32, longitude=-111\n    solar_position = pd.DataFrame(np.array(\n        [[55.36421554,  55.38851771,  34.63578446,  34.61148229,\n          172.32003763,  -3.44516534],\n         [96.50000401,  96.50000401,  -6.50000401,  -6.50000401,\n          246.91581654,  -3.56292888]]),\n        columns=['apparent_zenith', 'zenith', 'apparent_elevation',\n                 'elevation', 'azimuth', 'equation_of_time'],\n        index=times)\n    irrads = pd.DataFrame({'dni': [900, 0], 'ghi': [600, 0], 'dhi': [100, 0]},\n                          index=times)\n    solar_zenith = solar_position['apparent_zenith']\n    solar_azimuth = solar_position['azimuth']\n\n    # invalid warnings already generated in horizon test above,\n    # no need to clutter test output here\n    with np.errstate(invalid='ignore'):\n        tracker_data = system.singleaxis(solar_zenith, solar_azimuth)\n\n    # some invalid values in irradiance.py. not our problem here\n    with np.errstate(invalid='ignore'):\n        irradiance = system.get_irradiance(tracker_data['surface_tilt'],\n                                           tracker_data['surface_azimuth'],\n                                           solar_zenith,\n                                           solar_azimuth,\n                                           irrads['dni'],\n                                           irrads['ghi'],\n                                           irrads['dhi'])\n\n    expected = pd.DataFrame(data=np.array(\n        [[961.80070,   815.94490,   145.85580,   135.32820, 10.52757492],\n         [nan, nan, nan, nan, nan]]),\n                            columns=['poa_global', 'poa_direct',\n                                     'poa_diffuse', 'poa_sky_diffuse',\n                                     'poa_ground_diffuse'],\n                            index=times)\n\n    assert_frame_equal(irradiance, expected, check_less_precise=2)\n\n    # test with albedo as a Series\n    irrads['albedo'] = [0.5, 0.5]\n    with np.errstate(invalid='ignore'):\n        irradiance = system.get_irradiance(tracker_data['surface_tilt'],\n                                           tracker_data['surface_azimuth'],\n                                           solar_zenith,\n                                           solar_azimuth,\n                                           irrads['dni'],\n                                           irrads['ghi'],\n                                           irrads['dhi'],\n                                           albedo=irrads['albedo'])\n\n    expected = pd.Series(data=[21.05514984, nan], index=times,\n                         name='poa_ground_diffuse')\n\n    assert_series_equal(irradiance['poa_ground_diffuse'], expected,\n                        check_less_precise=2)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_get_irradiance", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "tracking", "singleaxistracker", "max_angle", "90", "axis_tilt", "30", "axis_azimuth", "180", "gcr", "2", "0", "7", "0", "backtrack", "true", "times", "pd", "date_range", "start", "20160101", "1200", "0700", "end", "20160101", "1800", "0700", "freq", "6h", "latitude", "32", "longitude", "111", "solar_position", "pd", "dataframe", "np", "array", "55", "36421554", "55", "38851771", "34", "63578446", "34", "61148229", "172", "32003763", "3", "44516534", "96", "50000401", "96", "50000401", "6", "50000401", "6", "50000401", "246", "91581654", "3", "56292888", "columns", "apparent_zenith", "zenith", "apparent_elevation", "elevation", "azimuth", "equation_of_time", "index", "times", "irrads", "pd", "dataframe", "dni", "900", "0", "ghi", "600", "0", "dhi", "100", "0", "index", "times", "solar_zenith", "solar_position", "apparent_zenith", "solar_azimuth", "solar_position", "azimuth", "invalid", "warnings", "already", "generated", "in", "horizon", "test", "above", "no", "need", "to", "clutter", "test", "output", "here", "with", "np", "errstate", "invalid", "ignore", "tracker_data", "system", "singleaxis", "solar_zenith", "solar_azimuth", "some", "invalid", "values", "in", "irradiance", "py", "not", "our", "problem", "here", "with", "np", "errstate", "invalid", "ignore", "irradiance", "system", "get_irradiance", "tracker_data", "surface_tilt", "tracker_data", "surface_azimuth", "solar_zenith", "solar_azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "expected", "pd", "dataframe", "data", "np", "array", "961", "80070", "815", "94490", "145", "85580", "135", "32820", "10", "52757492", "nan", "nan", "nan", "nan", "nan", "columns", "poa_global", "poa_direct", "poa_diffuse", "poa_sky_diffuse", "poa_ground_diffuse", "index", "times", "assert_frame_equal", "irradiance", "expected", "check_less_precise", "2", "test", "with", "albedo", "as", "a", "series", "irrads", "albedo", "0", "5", "0", "5", "with", "np", "errstate", "invalid", "ignore", "irradiance", "system", "get_irradiance", "tracker_data", "surface_tilt", "tracker_data", "surface_azimuth", "solar_zenith", "solar_azimuth", "irrads", "dni", "irrads", "ghi", "irrads", "dhi", "albedo", "irrads", "albedo", "expected", "pd", "series", "data", "21", "05514984", "nan", "index", "times", "name", "poa_ground_diffuse", "assert_series_equal", "irradiance", "poa_ground_diffuse", "expected", "check_less_precise", "2"], "doc_len": 242}
{"doc_id": "pvlib/tests/test_tracking.py::test_SingleAxisTracker___repr__", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_SingleAxisTracker___repr__", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_SingleAxisTracker___repr__():\n    with pytest.warns(pvlibDeprecationWarning):\n        system = tracking.SingleAxisTracker(\n            max_angle=45, gcr=.25, module='blah', inverter='blarg',\n            temperature_model_parameters={'a': -3.56})\n    expected = \"\"\"SingleAxisTracker:\n  axis_tilt: 0\n  axis_azimuth: 0\n  max_angle: 45\n  backtrack: True\n  gcr: 0.25\n  cross_axis_tilt: 0.0\n  name: None\n  Array:\n    name: None\n    mount: SingleAxisTrackerMount(axis_tilt=0, axis_azimuth=0, max_angle=45, backtrack=True, gcr=0.25, cross_axis_tilt=0.0, racking_model=None, module_height=None)\n    module: blah\n    albedo: 0.25\n    module_type: None\n    temperature_model_parameters: {'a': -3.56}\n    strings: 1\n    modules_per_string: 1\n  inverter: blarg\"\"\"  # noqa: E501\n    assert system.__repr__() == expected\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_singleaxistracker___repr__", "with", "pytest", "warns", "pvlibdeprecationwarning", "system", "tracking", "singleaxistracker", "max_angle", "45", "gcr", "25", "module", "blah", "inverter", "blarg", "temperature_model_parameters", "a", "3", "56", "expected", "singleaxistracker", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "45", "backtrack", "true", "gcr", "0", "25", "cross_axis_tilt", "0", "0", "name", "none", "array", "name", "none", "mount", "singleaxistrackermount", "axis_tilt", "0", "axis_azimuth", "0", "max_angle", "45", "backtrack", "true", "gcr", "0", "25", "cross_axis_tilt", "0", "0", "racking_model", "none", "module_height", "none", "module", "blah", "albedo", "0", "25", "module_type", "none", "temperature_model_parameters", "a", "3", "56", "strings", "1", "modules_per_string", "1", "inverter", "blarg", "noqa", "e501", "assert", "system", "__repr__", "expected"], "doc_len": 89}
{"doc_id": "pvlib/tests/test_tracking.py::test_calc_axis_tilt", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_calc_axis_tilt", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_calc_axis_tilt():\n    # expected values\n    expected_axis_tilt = 2.239  # [degrees]\n    expected_side_slope = 9.86649274360294  # [degrees]\n    expected = DATA_DIR / 'singleaxis_tracker_wslope.csv'\n    expected = pd.read_csv(expected, index_col='timestamp', parse_dates=True)\n    # solar positions\n    starttime = '2017-01-01T00:30:00-0300'\n    stoptime = '2017-12-31T23:59:59-0300'\n    lat, lon = -27.597300, -48.549610\n    times = pd.DatetimeIndex(pd.date_range(starttime, stoptime, freq='H'))\n    solpos = pvlib.solarposition.get_solarposition(times, lat, lon)\n    # singleaxis tracker w/slope data\n    slope_azimuth, slope_tilt = 77.34, 10.1149\n    axis_azimuth = 0.0\n    max_angle = 75.0\n    # Note: GCR is relative to horizontal distance between rows\n    gcr = 0.33292759  # GCR = length / horizontal_pitch = 1.64 / 5 / cos(9.86)\n    # calculate tracker axis zenith\n    axis_tilt = tracking.calc_axis_tilt(\n        slope_azimuth, slope_tilt, axis_azimuth=axis_azimuth)\n    assert np.isclose(axis_tilt, expected_axis_tilt)\n    # calculate cross-axis tilt and relative rotation\n    cross_axis_tilt = tracking.calc_cross_axis_tilt(\n        slope_azimuth, slope_tilt, axis_azimuth, axis_tilt)\n    assert np.isclose(cross_axis_tilt, expected_side_slope)\n    sat = tracking.singleaxis(\n        solpos.apparent_zenith, solpos.azimuth, axis_tilt, axis_azimuth,\n        max_angle, backtrack=True, gcr=gcr, cross_axis_tilt=cross_axis_tilt)\n    np.testing.assert_allclose(\n        sat['tracker_theta'], expected['tracker_theta'], atol=1e-7)\n    np.testing.assert_allclose(sat['aoi'], expected['aoi'], atol=1e-7)\n    np.testing.assert_allclose(\n        sat['surface_azimuth'], expected['surface_azimuth'], atol=1e-7)\n    np.testing.assert_allclose(\n        sat['surface_tilt'], expected['surface_tilt'], atol=1e-7)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_calc_axis_tilt", "expected", "values", "expected_axis_tilt", "2", "239", "degrees", "expected_side_slope", "9", "86649274360294", "degrees", "expected", "data_dir", "singleaxis_tracker_wslope", "csv", "expected", "pd", "read_csv", "expected", "index_col", "timestamp", "parse_dates", "true", "solar", "positions", "starttime", "2017", "01", "01t00", "30", "00", "0300", "stoptime", "2017", "12", "31t23", "59", "59", "0300", "lat", "lon", "27", "597300", "48", "549610", "times", "pd", "datetimeindex", "pd", "date_range", "starttime", "stoptime", "freq", "h", "solpos", "pvlib", "solarposition", "get_solarposition", "times", "lat", "lon", "singleaxis", "tracker", "w", "slope", "data", "slope_azimuth", "slope_tilt", "77", "34", "10", "1149", "axis_azimuth", "0", "0", "max_angle", "75", "0", "note", "gcr", "is", "relative", "to", "horizontal", "distance", "between", "rows", "gcr", "0", "33292759", "gcr", "length", "horizontal_pitch", "1", "64", "5", "cos", "9", "86", "calculate", "tracker", "axis", "zenith", "axis_tilt", "tracking", "calc_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "axis_azimuth", "assert", "np", "isclose", "axis_tilt", "expected_axis_tilt", "calculate", "cross", "axis", "tilt", "and", "relative", "rotation", "cross_axis_tilt", "tracking", "calc_cross_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "axis_tilt", "assert", "np", "isclose", "cross_axis_tilt", "expected_side_slope", "sat", "tracking", "singleaxis", "solpos", "apparent_zenith", "solpos", "azimuth", "axis_tilt", "axis_azimuth", "max_angle", "backtrack", "true", "gcr", "gcr", "cross_axis_tilt", "cross_axis_tilt", "np", "testing", "assert_allclose", "sat", "tracker_theta", "expected", "tracker_theta", "atol", "1e", "7", "np", "testing", "assert_allclose", "sat", "aoi", "expected", "aoi", "atol", "1e", "7", "np", "testing", "assert_allclose", "sat", "surface_azimuth", "expected", "surface_azimuth", "atol", "1e", "7", "np", "testing", "assert_allclose", "sat", "surface_tilt", "expected", "surface_tilt", "atol", "1e", "7"], "doc_len": 195}
{"doc_id": "pvlib/tests/test_tracking.py::test_slope_aware_backtracking", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_slope_aware_backtracking", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_slope_aware_backtracking():\n    \"\"\"\n    Test validation data set from https://www.nrel.gov/docs/fy20osti/76626.pdf\n    \"\"\"\n    index = pd.date_range('2019-01-01T08:00', '2019-01-01T17:00', freq='h')\n    index = index.tz_localize('Etc/GMT+5')\n    expected_data = pd.DataFrame(index=index, data=[\n        ( 2.404287, 122.79177, -84.440, -10.899),\n        (11.263058, 133.288729, -72.604, -25.747),\n        (18.733558, 145.285552, -59.861, -59.861),\n        (24.109076, 158.939435, -45.578, -45.578),\n        (26.810735, 173.931802, -28.764, -28.764),\n        (26.482495, 189.371536, -8.475, -8.475),\n        (23.170447, 204.13681, 15.120, 15.120),\n        (17.296785, 217.446538, 39.562, 39.562),\n        ( 9.461862, 229.102218, 61.587, 32.339),\n        ( 0.524817, 239.330401, 79.530, 5.490),\n    ], columns=['ApparentElevation', 'SolarAzimuth',\n                'TrueTracking', 'Backtracking'])\n    expected_axis_tilt = 9.666\n    expected_slope_angle = -2.576\n    slope_azimuth, slope_tilt = 180.0, 10.0\n    axis_azimuth = 195.0\n    axis_tilt = tracking.calc_axis_tilt(\n        slope_azimuth, slope_tilt, axis_azimuth)\n    assert np.isclose(axis_tilt, expected_axis_tilt, rtol=1e-3, atol=1e-3)\n    cross_axis_tilt = tracking.calc_cross_axis_tilt(\n        slope_azimuth, slope_tilt, axis_azimuth, axis_tilt)\n    assert np.isclose(\n        cross_axis_tilt, expected_slope_angle, rtol=1e-3, atol=1e-3)\n    sat = tracking.singleaxis(\n        90.0-expected_data['ApparentElevation'], expected_data['SolarAzimuth'],\n        axis_tilt, axis_azimuth, max_angle=90.0, backtrack=True, gcr=0.5,\n        cross_axis_tilt=cross_axis_tilt)\n    assert_series_equal(sat['tracker_theta'],\n                        expected_data['Backtracking'].rename('tracker_theta'),\n                        check_less_precise=True)\n    truetracking = tracking.singleaxis(\n        90.0-expected_data['ApparentElevation'], expected_data['SolarAzimuth'],\n        axis_tilt, axis_azimuth, max_angle=90.0, backtrack=False, gcr=0.5,\n        cross_axis_tilt=cross_axis_tilt)\n    assert_series_equal(truetracking['tracker_theta'],\n                        expected_data['TrueTracking'].rename('tracker_theta'),\n                        check_less_precise=True)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_slope_aware_backtracking", "test", "validation", "data", "set", "from", "https", "www", "nrel", "gov", "docs", "fy20osti", "76626", "pdf", "index", "pd", "date_range", "2019", "01", "01t08", "00", "2019", "01", "01t17", "00", "freq", "h", "index", "index", "tz_localize", "etc", "gmt", "5", "expected_data", "pd", "dataframe", "index", "index", "data", "2", "404287", "122", "79177", "84", "440", "10", "899", "11", "263058", "133", "288729", "72", "604", "25", "747", "18", "733558", "145", "285552", "59", "861", "59", "861", "24", "109076", "158", "939435", "45", "578", "45", "578", "26", "810735", "173", "931802", "28", "764", "28", "764", "26", "482495", "189", "371536", "8", "475", "8", "475", "23", "170447", "204", "13681", "15", "120", "15", "120", "17", "296785", "217", "446538", "39", "562", "39", "562", "9", "461862", "229", "102218", "61", "587", "32", "339", "0", "524817", "239", "330401", "79", "530", "5", "490", "columns", "apparentelevation", "solarazimuth", "truetracking", "backtracking", "expected_axis_tilt", "9", "666", "expected_slope_angle", "2", "576", "slope_azimuth", "slope_tilt", "180", "0", "10", "0", "axis_azimuth", "195", "0", "axis_tilt", "tracking", "calc_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "assert", "np", "isclose", "axis_tilt", "expected_axis_tilt", "rtol", "1e", "3", "atol", "1e", "3", "cross_axis_tilt", "tracking", "calc_cross_axis_tilt", "slope_azimuth", "slope_tilt", "axis_azimuth", "axis_tilt", "assert", "np", "isclose", "cross_axis_tilt", "expected_slope_angle", "rtol", "1e", "3", "atol", "1e", "3", "sat", "tracking", "singleaxis", "90", "0", "expected_data", "apparentelevation", "expected_data", "solarazimuth", "axis_tilt", "axis_azimuth", "max_angle", "90", "0", "backtrack", "true", "gcr", "0", "5", "cross_axis_tilt", "cross_axis_tilt", "assert_series_equal", "sat", "tracker_theta", "expected_data", "backtracking", "rename", "tracker_theta", "check_less_precise", "true", "truetracking", "tracking", "singleaxis", "90", "0", "expected_data", "apparentelevation", "expected_data", "solarazimuth", "axis_tilt", "axis_azimuth", "max_angle", "90", "0", "backtrack", "false", "gcr", "0", "5", "cross_axis_tilt", "cross_axis_tilt", "assert_series_equal", "truetracking", "tracker_theta", "expected_data", "truetracking", "rename", "tracker_theta", "check_less_precise", "true"], "doc_len": 239}
{"doc_id": "pvlib/tests/test_tracking.py::test_singleaxis_aoi_gh1221", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_singleaxis_aoi_gh1221", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_singleaxis_aoi_gh1221():\n    # vertical tracker\n    loc = pvlib.location.Location(40.1134, -88.3695)\n    dr = pd.date_range(\n        start='02-Jun-1998 00:00:00', end='02-Jun-1998 23:55:00', freq='5T',\n        tz='Etc/GMT+6')\n    sp = loc.get_solarposition(dr)\n    tr = pvlib.tracking.singleaxis(\n        sp['apparent_zenith'], sp['azimuth'], axis_tilt=90, axis_azimuth=180,\n        max_angle=0.001, backtrack=False)\n    fixed = pvlib.irradiance.aoi(90, 180, sp['apparent_zenith'], sp['azimuth'])\n    fixed[np.isnan(tr['aoi'])] = np.nan\n    assert np.allclose(tr['aoi'], fixed, equal_nan=True)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_singleaxis_aoi_gh1221", "vertical", "tracker", "loc", "pvlib", "location", "location", "40", "1134", "88", "3695", "dr", "pd", "date_range", "start", "02", "jun", "1998", "00", "00", "00", "end", "02", "jun", "1998", "23", "55", "00", "freq", "5t", "tz", "etc", "gmt", "6", "sp", "loc", "get_solarposition", "dr", "tr", "pvlib", "tracking", "singleaxis", "sp", "apparent_zenith", "sp", "azimuth", "axis_tilt", "90", "axis_azimuth", "180", "max_angle", "0", "001", "backtrack", "false", "fixed", "pvlib", "irradiance", "aoi", "90", "180", "sp", "apparent_zenith", "sp", "azimuth", "fixed", "np", "isnan", "tr", "aoi", "np", "nan", "assert", "np", "allclose", "tr", "aoi", "fixed", "equal_nan", "true"], "doc_len": 85}
{"doc_id": "pvlib/tests/test_tracking.py::test_calc_surface_orientation_types", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_calc_surface_orientation_types", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_calc_surface_orientation_types():\n    # numpy arrays\n    rotations = np.array([-10, 0, 10])\n    expected_tilts = np.array([10, 0, 10], dtype=float)\n    expected_azimuths = np.array([270, 90, 90], dtype=float)\n    out = tracking.calc_surface_orientation(tracker_theta=rotations)\n    np.testing.assert_allclose(expected_tilts, out['surface_tilt'])\n    np.testing.assert_allclose(expected_azimuths, out['surface_azimuth'])\n\n    # pandas Series\n    rotations = pd.Series(rotations)\n    expected_tilts = pd.Series(expected_tilts).rename('surface_tilt')\n    expected_azimuths = pd.Series(expected_azimuths).rename('surface_azimuth')\n    out = tracking.calc_surface_orientation(tracker_theta=rotations)\n    assert_series_equal(expected_tilts, out['surface_tilt'])\n    assert_series_equal(expected_azimuths, out['surface_azimuth'])\n\n    # float\n    for rotation, expected_tilt, expected_azimuth in zip(\n            rotations, expected_tilts, expected_azimuths):\n        out = tracking.calc_surface_orientation(rotation)\n        assert out['surface_tilt'] == pytest.approx(expected_tilt)\n        assert out['surface_azimuth'] == pytest.approx(expected_azimuth)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_calc_surface_orientation_types", "numpy", "arrays", "rotations", "np", "array", "10", "0", "10", "expected_tilts", "np", "array", "10", "0", "10", "dtype", "float", "expected_azimuths", "np", "array", "270", "90", "90", "dtype", "float", "out", "tracking", "calc_surface_orientation", "tracker_theta", "rotations", "np", "testing", "assert_allclose", "expected_tilts", "out", "surface_tilt", "np", "testing", "assert_allclose", "expected_azimuths", "out", "surface_azimuth", "pandas", "series", "rotations", "pd", "series", "rotations", "expected_tilts", "pd", "series", "expected_tilts", "rename", "surface_tilt", "expected_azimuths", "pd", "series", "expected_azimuths", "rename", "surface_azimuth", "out", "tracking", "calc_surface_orientation", "tracker_theta", "rotations", "assert_series_equal", "expected_tilts", "out", "surface_tilt", "assert_series_equal", "expected_azimuths", "out", "surface_azimuth", "float", "for", "rotation", "expected_tilt", "expected_azimuth", "in", "zip", "rotations", "expected_tilts", "expected_azimuths", "out", "tracking", "calc_surface_orientation", "rotation", "assert", "out", "surface_tilt", "pytest", "approx", "expected_tilt", "assert", "out", "surface_azimuth", "pytest", "approx", "expected_azimuth"], "doc_len": 104}
{"doc_id": "pvlib/tests/test_tracking.py::test_calc_surface_orientation_kwargs", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_calc_surface_orientation_kwargs", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_calc_surface_orientation_kwargs():\n    # non-default axis tilt & azimuth\n    rotations = np.array([-10, 0, 10])\n    expected_tilts = np.array([22.2687445, 20.0, 22.2687445])\n    expected_azimuths = np.array([152.72683041, 180.0, 207.27316959])\n    out = tracking.calc_surface_orientation(rotations,\n                                            axis_tilt=20,\n                                            axis_azimuth=180)\n    np.testing.assert_allclose(out['surface_tilt'], expected_tilts)\n    np.testing.assert_allclose(out['surface_azimuth'], expected_azimuths)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_calc_surface_orientation_kwargs", "non", "default", "axis", "tilt", "azimuth", "rotations", "np", "array", "10", "0", "10", "expected_tilts", "np", "array", "22", "2687445", "20", "0", "22", "2687445", "expected_azimuths", "np", "array", "152", "72683041", "180", "0", "207", "27316959", "out", "tracking", "calc_surface_orientation", "rotations", "axis_tilt", "20", "axis_azimuth", "180", "np", "testing", "assert_allclose", "out", "surface_tilt", "expected_tilts", "np", "testing", "assert_allclose", "out", "surface_azimuth", "expected_azimuths"], "doc_len": 55}
{"doc_id": "pvlib/tests/test_tracking.py::test_calc_surface_orientation_special", "file_path": "pvlib/tests/test_tracking.py", "class_name": null, "func_name": "test_calc_surface_orientation_special", "text": "文件路径: pvlib/tests/test_tracking.py\ndef test_calc_surface_orientation_special():\n    # special cases for rotations\n    rotations = np.array([-180, -90, -0, 0, 90, 180])\n    expected_tilts = np.array([180, 90, 0, 0, 90, 180], dtype=float)\n    expected_azimuths = [270, 270, 90, 90, 90, 90]\n    out = tracking.calc_surface_orientation(rotations)\n    np.testing.assert_allclose(out['surface_tilt'], expected_tilts)\n    np.testing.assert_allclose(out['surface_azimuth'], expected_azimuths)\n\n    # special case for axis_tilt\n    rotations = np.array([-10, 0, 10])\n    expected_tilts = np.array([90, 90, 90], dtype=float)\n    expected_azimuths = np.array([350, 0, 10], dtype=float)\n    out = tracking.calc_surface_orientation(rotations, axis_tilt=90)\n    np.testing.assert_allclose(out['surface_tilt'], expected_tilts)\n    np.testing.assert_allclose(out['surface_azimuth'], expected_azimuths)\n\n    # special cases for axis_azimuth\n    rotations = np.array([-10, 0, 10])\n    expected_tilts = np.array([10, 0, 10], dtype=float)\n    expected_azimuth_offsets = np.array([-90, 90, 90], dtype=float)\n    for axis_azimuth in [0, 90, 180, 270, 360]:\n        expected_azimuths = (axis_azimuth + expected_azimuth_offsets) % 360\n        out = tracking.calc_surface_orientation(rotations,\n                                                axis_azimuth=axis_azimuth)\n        np.testing.assert_allclose(out['surface_tilt'], expected_tilts)\n        # the rounding is a bit ugly, but necessary to test approximately equal\n        # in a modulo-360 sense.\n        np.testing.assert_allclose(np.round(out['surface_azimuth'], 4) % 360,\n                                   expected_azimuths, rtol=1e-5, atol=1e-5)\n", "tokens": ["pvlib", "tests", "test_tracking", "py", "def", "test_calc_surface_orientation_special", "special", "cases", "for", "rotations", "rotations", "np", "array", "180", "90", "0", "0", "90", "180", "expected_tilts", "np", "array", "180", "90", "0", "0", "90", "180", "dtype", "float", "expected_azimuths", "270", "270", "90", "90", "90", "90", "out", "tracking", "calc_surface_orientation", "rotations", "np", "testing", "assert_allclose", "out", "surface_tilt", "expected_tilts", "np", "testing", "assert_allclose", "out", "surface_azimuth", "expected_azimuths", "special", "case", "for", "axis_tilt", "rotations", "np", "array", "10", "0", "10", "expected_tilts", "np", "array", "90", "90", "90", "dtype", "float", "expected_azimuths", "np", "array", "350", "0", "10", "dtype", "float", "out", "tracking", "calc_surface_orientation", "rotations", "axis_tilt", "90", "np", "testing", "assert_allclose", "out", "surface_tilt", "expected_tilts", "np", "testing", "assert_allclose", "out", "surface_azimuth", "expected_azimuths", "special", "cases", "for", "axis_azimuth", "rotations", "np", "array", "10", "0", "10", "expected_tilts", "np", "array", "10", "0", "10", "dtype", "float", "expected_azimuth_offsets", "np", "array", "90", "90", "90", "dtype", "float", "for", "axis_azimuth", "in", "0", "90", "180", "270", "360", "expected_azimuths", "axis_azimuth", "expected_azimuth_offsets", "360", "out", "tracking", "calc_surface_orientation", "rotations", "axis_azimuth", "axis_azimuth", "np", "testing", "assert_allclose", "out", "surface_tilt", "expected_tilts", "the", "rounding", "is", "a", "bit", "ugly", "but", "necessary", "to", "test", "approximately", "equal", "in", "a", "modulo", "360", "sense", "np", "testing", "assert_allclose", "np", "round", "out", "surface_azimuth", "4", "360", "expected_azimuths", "rtol", "1e", "5", "atol", "1e", "5"], "doc_len": 180}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test_system", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test_system", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test_system():\n    syst = {'height': 1.0,\n            'pitch': 2.,\n            'surface_tilt': 30.,\n            'surface_azimuth': 180.,\n            'rotation': -30.}  # rotation of right edge relative to horizontal\n    syst['gcr'] = 1.0 / syst['pitch']\n    pts = np.linspace(0, 1, num=3)\n    sqr3 = np.sqrt(3) / 4\n    # c_i,j = cos(angle from point i to edge of row j), j=0 is row = -1\n    # c_i,j = cos(angle from point i to edge of row j), j=0 is row = -1\n    c00 = (-2 - sqr3) / np.sqrt(1.25**2 + (2 + sqr3)**2)  # right edge row -1\n    c01 = -sqr3 / np.sqrt(1.25**2 + sqr3**2)  # right edge row 0\n    c02 = sqr3 / np.sqrt(0.75**2 + sqr3**2)  # left edge of row 0\n    c03 = (2 - sqr3) / np.sqrt(1.25**2 + (2 - sqr3)**2)  # right edge of row 1\n    vf_0 = 0.5 * (c03 - c02 + c01 - c00)  # vf at point 0\n    c10 = (-3 - sqr3) / np.sqrt(1.25**2 + (3 + sqr3)**2)  # right edge row -1\n    c11 = (-1 - sqr3) / np.sqrt(1.25**2 + (1 + sqr3)**2)  # right edge row 0\n    c12 = (-1 + sqr3) / np.sqrt(0.75**2 + (-1 + sqr3)**2)  # left edge row 0\n    c13 = (1 - sqr3) / np.sqrt(1.25**2 + (1 - sqr3)**2)  # right edge row\n    vf_1 = 0.5 * (c13 - c12 + c11 - c10)  # vf at point 1\n    c20 = -(4 + sqr3) / np.sqrt(1.25**2 + (4 + sqr3)**2)  # right edge row -1\n    c21 = (-2 + sqr3) / np.sqrt(0.75**2 + (-2 + sqr3)**2)  # left edge row 0\n    c22 = (-2 - sqr3) / np.sqrt(1.25**2 + (2 + sqr3)**2)  # right edge row 0\n    c23 = (0 - sqr3) / np.sqrt(1.25**2 + (0 - sqr3)**2)  # right edge row 1\n    vf_2 = 0.5 * (c23 - c22 + c21 - c20)  # vf at point 1\n    vfs_ground_sky = np.array([vf_0, vf_1, vf_2])\n    return syst, pts, vfs_ground_sky\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test_system", "syst", "height", "1", "0", "pitch", "2", "surface_tilt", "30", "surface_azimuth", "180", "rotation", "30", "rotation", "of", "right", "edge", "relative", "to", "horizontal", "syst", "gcr", "1", "0", "syst", "pitch", "pts", "np", "linspace", "0", "1", "num", "3", "sqr3", "np", "sqrt", "3", "4", "c_i", "j", "cos", "angle", "from", "point", "i", "to", "edge", "of", "row", "j", "j", "0", "is", "row", "1", "c_i", "j", "cos", "angle", "from", "point", "i", "to", "edge", "of", "row", "j", "j", "0", "is", "row", "1", "c00", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "row", "1", "c01", "sqr3", "np", "sqrt", "1", "25", "2", "sqr3", "2", "right", "edge", "row", "0", "c02", "sqr3", "np", "sqrt", "0", "75", "2", "sqr3", "2", "left", "edge", "of", "row", "0", "c03", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "of", "row", "1", "vf_0", "0", "5", "c03", "c02", "c01", "c00", "vf", "at", "point", "0", "c10", "3", "sqr3", "np", "sqrt", "1", "25", "2", "3", "sqr3", "2", "right", "edge", "row", "1", "c11", "1", "sqr3", "np", "sqrt", "1", "25", "2", "1", "sqr3", "2", "right", "edge", "row", "0", "c12", "1", "sqr3", "np", "sqrt", "0", "75", "2", "1", "sqr3", "2", "left", "edge", "row", "0", "c13", "1", "sqr3", "np", "sqrt", "1", "25", "2", "1", "sqr3", "2", "right", "edge", "row", "vf_1", "0", "5", "c13", "c12", "c11", "c10", "vf", "at", "point", "1", "c20", "4", "sqr3", "np", "sqrt", "1", "25", "2", "4", "sqr3", "2", "right", "edge", "row", "1", "c21", "2", "sqr3", "np", "sqrt", "0", "75", "2", "2", "sqr3", "2", "left", "edge", "row", "0", "c22", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "row", "0", "c23", "0", "sqr3", "np", "sqrt", "1", "25", "2", "0", "sqr3", "2", "right", "edge", "row", "1", "vf_2", "0", "5", "c23", "c22", "c21", "c20", "vf", "at", "point", "1", "vfs_ground_sky", "np", "array", "vf_0", "vf_1", "vf_2", "return", "syst", "pts", "vfs_ground_sky"], "doc_len": 298}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__vf_ground_sky_integ", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__vf_ground_sky_integ", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__vf_ground_sky_integ(test_system):\n    ts, pts, vfs_gnd_sky = test_system\n    # pass rotation here since max_rows=1 for the hand-solved case in\n    # the fixture test_system, which means the ground-to-sky view factor\n    # isn't summed over enough rows for symmetry to hold.\n    vf_integ = infinite_sheds._vf_ground_sky_integ(\n        ts['rotation'], ts['surface_azimuth'],\n        ts['gcr'], ts['height'], ts['pitch'],\n        max_rows=1, npoints=3)\n    expected_vf_integ = np.trapz(vfs_gnd_sky, pts)\n    assert np.isclose(vf_integ, expected_vf_integ, rtol=0.1)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__vf_ground_sky_integ", "test_system", "ts", "pts", "vfs_gnd_sky", "test_system", "pass", "rotation", "here", "since", "max_rows", "1", "for", "the", "hand", "solved", "case", "in", "the", "fixture", "test_system", "which", "means", "the", "ground", "to", "sky", "view", "factor", "isn", "t", "summed", "over", "enough", "rows", "for", "symmetry", "to", "hold", "vf_integ", "infinite_sheds", "_vf_ground_sky_integ", "ts", "rotation", "ts", "surface_azimuth", "ts", "gcr", "ts", "height", "ts", "pitch", "max_rows", "1", "npoints", "3", "expected_vf_integ", "np", "trapz", "vfs_gnd_sky", "pts", "assert", "np", "isclose", "vf_integ", "expected_vf_integ", "rtol", "0", "1"], "doc_len": 75}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__vf_row_sky_integ", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__vf_row_sky_integ", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__vf_row_sky_integ(test_system):\n    ts, _, _ = test_system\n    gcr = ts['gcr']\n    surface_tilt = ts['surface_tilt']\n    f_x = np.array([0., 0.5, 1.])\n    shaded = []\n    noshade = []\n    for x in f_x:\n        s, ns = infinite_sheds._vf_row_sky_integ(\n            x, surface_tilt, gcr, npoints=100)\n        shaded.append(s)\n        noshade.append(ns)\n\n    def analytic(gcr, surface_tilt, x):\n        c = cosd(surface_tilt)\n        a = 1. / gcr\n        dx = np.sqrt(a**2 - 2 * a * c * x + x**2)\n        return - a * (c**2 - 1) * np.arctanh((x - a * c) / dx) - c * dx\n\n    expected_shade = 0.5 * (f_x * cosd(surface_tilt)\n                            - analytic(gcr, surface_tilt, 1 - f_x)\n                            + analytic(gcr, surface_tilt, 1.))\n    expected_noshade = 0.5 * ((1 - f_x) * cosd(surface_tilt)\n                              + analytic(gcr, surface_tilt, 1. - f_x)\n                              - analytic(gcr, surface_tilt, 0.))\n    shaded = np.array(shaded)\n    noshade = np.array(noshade)\n    assert np.allclose(shaded, expected_shade)\n    assert np.allclose(noshade, expected_noshade)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__vf_row_sky_integ", "test_system", "ts", "_", "_", "test_system", "gcr", "ts", "gcr", "surface_tilt", "ts", "surface_tilt", "f_x", "np", "array", "0", "0", "5", "1", "shaded", "noshade", "for", "x", "in", "f_x", "s", "ns", "infinite_sheds", "_vf_row_sky_integ", "x", "surface_tilt", "gcr", "npoints", "100", "shaded", "append", "s", "noshade", "append", "ns", "def", "analytic", "gcr", "surface_tilt", "x", "c", "cosd", "surface_tilt", "a", "1", "gcr", "dx", "np", "sqrt", "a", "2", "2", "a", "c", "x", "x", "2", "return", "a", "c", "2", "1", "np", "arctanh", "x", "a", "c", "dx", "c", "dx", "expected_shade", "0", "5", "f_x", "cosd", "surface_tilt", "analytic", "gcr", "surface_tilt", "1", "f_x", "analytic", "gcr", "surface_tilt", "1", "expected_noshade", "0", "5", "1", "f_x", "cosd", "surface_tilt", "analytic", "gcr", "surface_tilt", "1", "f_x", "analytic", "gcr", "surface_tilt", "0", "shaded", "np", "array", "shaded", "noshade", "np", "array", "noshade", "assert", "np", "allclose", "shaded", "expected_shade", "assert", "np", "allclose", "noshade", "expected_noshade"], "doc_len": 130}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__poa_sky_diffuse_pv", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__poa_sky_diffuse_pv", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__poa_sky_diffuse_pv():\n    dhi = np.array([np.nan, 0.0, 500.])\n    f_x = np.array([0.2, 0.2, 0.5])\n    vf_shade_sky_integ = np.array([1.0, 0.5, 0.2])\n    vf_noshade_sky_integ = np.array([0.0, 0.5, 0.8])\n    poa = infinite_sheds._poa_sky_diffuse_pv(\n        f_x, dhi, vf_shade_sky_integ, vf_noshade_sky_integ)\n    expected_poa = np.array([np.nan, 0.0, 500 * (0.5 * 0.2 + 0.5 * 0.8)])\n    assert np.allclose(poa, expected_poa, equal_nan=True)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__poa_sky_diffuse_pv", "dhi", "np", "array", "np", "nan", "0", "0", "500", "f_x", "np", "array", "0", "2", "0", "2", "0", "5", "vf_shade_sky_integ", "np", "array", "1", "0", "0", "5", "0", "2", "vf_noshade_sky_integ", "np", "array", "0", "0", "0", "5", "0", "8", "poa", "infinite_sheds", "_poa_sky_diffuse_pv", "f_x", "dhi", "vf_shade_sky_integ", "vf_noshade_sky_integ", "expected_poa", "np", "array", "np", "nan", "0", "0", "500", "0", "5", "0", "2", "0", "5", "0", "8", "assert", "np", "allclose", "poa", "expected_poa", "equal_nan", "true"], "doc_len": 72}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__ground_angle", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__ground_angle", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__ground_angle(test_system):\n    ts, _, _ = test_system\n    x = np.array([0., 0.5, 1.0])\n    angles = infinite_sheds._ground_angle(\n        x, ts['surface_tilt'], ts['gcr'])\n    expected_angles = np.array([0., 5.866738789543952, 9.896090638982903])\n    assert np.allclose(angles, expected_angles)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__ground_angle", "test_system", "ts", "_", "_", "test_system", "x", "np", "array", "0", "0", "5", "1", "0", "angles", "infinite_sheds", "_ground_angle", "x", "ts", "surface_tilt", "ts", "gcr", "expected_angles", "np", "array", "0", "5", "866738789543952", "9", "896090638982903", "assert", "np", "allclose", "angles", "expected_angles"], "doc_len": 41}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__ground_angle_zero_gcr", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__ground_angle_zero_gcr", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__ground_angle_zero_gcr():\n    surface_tilt = 30.0\n    x = np.array([0.0, 0.5, 1.0])\n    angles = infinite_sheds._ground_angle(x, surface_tilt, 0)\n    expected_angles = np.array([0, 0, 0])\n    assert np.allclose(angles, expected_angles)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__ground_angle_zero_gcr", "surface_tilt", "30", "0", "x", "np", "array", "0", "0", "0", "5", "1", "0", "angles", "infinite_sheds", "_ground_angle", "x", "surface_tilt", "0", "expected_angles", "np", "array", "0", "0", "0", "assert", "np", "allclose", "angles", "expected_angles"], "doc_len": 36}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__vf_row_ground", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__vf_row_ground", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__vf_row_ground(test_system):\n    ts, _, _ = test_system\n    x = np.array([0., 0.5, 1.0])\n    sqr3 = np.sqrt(3)\n    vfs = infinite_sheds._vf_row_ground(\n        x, ts['surface_tilt'], ts['gcr'])\n    expected_vfs = np.array([\n        0.5 * (1. - sqr3 / 2),\n        0.5 * ((4 + sqr3 / 2) / np.sqrt(17 + 4 * sqr3) - sqr3 / 2),\n        0.5 * ((4 + sqr3) / np.sqrt(20 + 8 * sqr3) - sqr3 / 2)])\n    assert np.allclose(vfs, expected_vfs)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__vf_row_ground", "test_system", "ts", "_", "_", "test_system", "x", "np", "array", "0", "0", "5", "1", "0", "sqr3", "np", "sqrt", "3", "vfs", "infinite_sheds", "_vf_row_ground", "x", "ts", "surface_tilt", "ts", "gcr", "expected_vfs", "np", "array", "0", "5", "1", "sqr3", "2", "0", "5", "4", "sqr3", "2", "np", "sqrt", "17", "4", "sqr3", "sqr3", "2", "0", "5", "4", "sqr3", "np", "sqrt", "20", "8", "sqr3", "sqr3", "2", "assert", "np", "allclose", "vfs", "expected_vfs"], "doc_len": 68}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__vf_row_ground_integ", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__vf_row_ground_integ", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__vf_row_ground_integ(test_system):\n    ts, _, _ = test_system\n    gcr = ts['gcr']\n    surface_tilt = ts['surface_tilt']\n    f_x = np.array([0., 0.5, 1.0])\n    shaded, noshade = infinite_sheds._vf_row_ground_integ(\n        f_x, surface_tilt, gcr)\n\n    def analytic(x, surface_tilt, gcr):\n        c = cosd(surface_tilt)\n        a = 1. / gcr\n        dx = np.sqrt(a**2 + 2 * a * c * x + x**2)\n        return c * dx - a * (c**2 - 1) * np.arctanh((a * c + x) / dx)\n\n    expected_shade = 0.5 * (analytic(f_x, surface_tilt, gcr)\n                            - analytic(0., surface_tilt, gcr)\n                            - f_x * cosd(surface_tilt))\n    expected_noshade = 0.5 * (analytic(1., surface_tilt, gcr)\n                              - analytic(f_x, surface_tilt, gcr)\n                              - (1. - f_x) * cosd(surface_tilt))\n    assert np.allclose(shaded, expected_shade)\n    assert np.allclose(noshade, expected_noshade)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__vf_row_ground_integ", "test_system", "ts", "_", "_", "test_system", "gcr", "ts", "gcr", "surface_tilt", "ts", "surface_tilt", "f_x", "np", "array", "0", "0", "5", "1", "0", "shaded", "noshade", "infinite_sheds", "_vf_row_ground_integ", "f_x", "surface_tilt", "gcr", "def", "analytic", "x", "surface_tilt", "gcr", "c", "cosd", "surface_tilt", "a", "1", "gcr", "dx", "np", "sqrt", "a", "2", "2", "a", "c", "x", "x", "2", "return", "c", "dx", "a", "c", "2", "1", "np", "arctanh", "a", "c", "x", "dx", "expected_shade", "0", "5", "analytic", "f_x", "surface_tilt", "gcr", "analytic", "0", "surface_tilt", "gcr", "f_x", "cosd", "surface_tilt", "expected_noshade", "0", "5", "analytic", "1", "surface_tilt", "gcr", "analytic", "f_x", "surface_tilt", "gcr", "1", "f_x", "cosd", "surface_tilt", "assert", "np", "allclose", "shaded", "expected_shade", "assert", "np", "allclose", "noshade", "expected_noshade"], "doc_len": 107}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__poa_ground_shadows", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__poa_ground_shadows", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__poa_ground_shadows():\n    poa_ground, f_gnd_beam, df, vf_gnd_sky = (300., 0.5, 0.5, 0.2)\n    result = infinite_sheds._poa_ground_shadows(\n        poa_ground, f_gnd_beam, df, vf_gnd_sky)\n    expected = 300. * (0.5 * 0.5 + 0.5 * 0.2)\n    assert np.isclose(result, expected)\n    # vector inputs\n    poa_ground = np.array([300., 300.])\n    f_gnd_beam = np.array([0.5, 0.5])\n    df = np.array([0.5, 0.])\n    vf_gnd_sky = np.array([0.2, 0.2])\n    result = infinite_sheds._poa_ground_shadows(\n        poa_ground, f_gnd_beam, df, vf_gnd_sky)\n    expected_vec = np.array([expected, 300. * 0.5])\n    assert np.allclose(result, expected_vec)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__poa_ground_shadows", "poa_ground", "f_gnd_beam", "df", "vf_gnd_sky", "300", "0", "5", "0", "5", "0", "2", "result", "infinite_sheds", "_poa_ground_shadows", "poa_ground", "f_gnd_beam", "df", "vf_gnd_sky", "expected", "300", "0", "5", "0", "5", "0", "5", "0", "2", "assert", "np", "isclose", "result", "expected", "vector", "inputs", "poa_ground", "np", "array", "300", "300", "f_gnd_beam", "np", "array", "0", "5", "0", "5", "df", "np", "array", "0", "5", "0", "vf_gnd_sky", "np", "array", "0", "2", "0", "2", "result", "infinite_sheds", "_poa_ground_shadows", "poa_ground", "f_gnd_beam", "df", "vf_gnd_sky", "expected_vec", "np", "array", "expected", "300", "0", "5", "assert", "np", "allclose", "result", "expected_vec"], "doc_len": 86}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__shaded_fraction_floats", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__shaded_fraction_floats", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__shaded_fraction_floats():\n    result = infinite_sheds._shaded_fraction(\n        solar_zenith=60., solar_azimuth=180., surface_tilt=60.,\n        surface_azimuth=180., gcr=1.0)\n    assert np.isclose(result, 0.5)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__shaded_fraction_floats", "result", "infinite_sheds", "_shaded_fraction", "solar_zenith", "60", "solar_azimuth", "180", "surface_tilt", "60", "surface_azimuth", "180", "gcr", "1", "0", "assert", "np", "isclose", "result", "0", "5"], "doc_len": 27}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__shaded_fraction_array", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__shaded_fraction_array", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__shaded_fraction_array():\n    solar_zenith = np.array([0., 60., 90., 60.])\n    solar_azimuth = np.array([180., 180., 180., 180.])\n    surface_azimuth = np.array([180., 180., 180., 210.])\n    surface_tilt = np.array([30., 60., 0., 30.])\n    gcr = 1.0\n    result = infinite_sheds._shaded_fraction(\n        solar_zenith, solar_azimuth, surface_tilt, surface_azimuth, gcr)\n    x = 0.75 + np.sqrt(3) / 2\n    expected = np.array([0.0, 0.5, 0., (x - 1) / x])\n    assert np.allclose(result, expected)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__shaded_fraction_array", "solar_zenith", "np", "array", "0", "60", "90", "60", "solar_azimuth", "np", "array", "180", "180", "180", "180", "surface_azimuth", "np", "array", "180", "180", "180", "210", "surface_tilt", "np", "array", "30", "60", "0", "30", "gcr", "1", "0", "result", "infinite_sheds", "_shaded_fraction", "solar_zenith", "solar_azimuth", "surface_tilt", "surface_azimuth", "gcr", "x", "0", "75", "np", "sqrt", "3", "2", "expected", "np", "array", "0", "0", "0", "5", "0", "x", "1", "x", "assert", "np", "allclose", "result", "expected"], "doc_len": 69}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test_get_irradiance_poa", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test_get_irradiance_poa", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test_get_irradiance_poa():\n    # singleton inputs\n    solar_zenith = 0.\n    solar_azimuth = 180.\n    surface_tilt = 0.\n    surface_azimuth = 180.\n    gcr = 0.5\n    height = 1.\n    pitch = 1\n    ghi = 1000\n    dhi = 300\n    dni = 700\n    albedo = 0\n    iam = 1.0\n    npoints = 100\n    res = infinite_sheds.get_irradiance_poa(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni,\n        albedo, iam=iam, npoints=npoints)\n    expected_diffuse = np.array([300.])\n    expected_direct = np.array([700.])\n    expected_global = expected_diffuse + expected_direct\n    assert np.isclose(res['poa_global'], expected_global)\n    assert np.isclose(res['poa_diffuse'], expected_diffuse)\n    assert np.isclose(res['poa_direct'], expected_direct)\n    # vector inputs\n    surface_tilt = np.array([0., 0., 0., 0.])\n    height = 1.\n    surface_azimuth = np.array([180., 180., 180., 180.])\n    gcr = 0.5\n    pitch = 1\n    solar_zenith = np.array([0., 45., 45., 90.])\n    solar_azimuth = np.array([180., 180., 135., 180.])\n    expected_diffuse = np.array([300., 300., 300., 300.])\n    expected_direct = np.array(\n        [700., 350. * np.sqrt(2), 350. * np.sqrt(2), 0.])\n    expected_global = expected_diffuse + expected_direct\n    res = infinite_sheds.get_irradiance_poa(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni,\n        albedo, iam=iam, npoints=npoints)\n    assert np.allclose(res['poa_global'], expected_global)\n    assert np.allclose(res['poa_diffuse'], expected_diffuse)\n    assert np.allclose(res['poa_direct'], expected_direct)\n    # series inputs\n    surface_tilt = pd.Series(surface_tilt)\n    surface_azimuth = pd.Series(data=surface_azimuth, index=surface_tilt.index)\n    solar_zenith = pd.Series(solar_zenith, index=surface_tilt.index)\n    solar_azimuth = pd.Series(data=solar_azimuth, index=surface_tilt.index)\n    expected_diffuse = pd.Series(\n        data=expected_diffuse, index=surface_tilt.index)\n    expected_direct = pd.Series(\n        data=expected_direct, index=surface_tilt.index)\n    expected_global = expected_diffuse + expected_direct\n    expected_global.name = 'poa_global'  # to match output Series\n    res = infinite_sheds.get_irradiance_poa(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni,\n        albedo, iam=iam, npoints=npoints)\n    assert isinstance(res, pd.DataFrame)\n    assert_series_equal(res['poa_global'], expected_global)\n    assert all(k in res.columns for k in [\n        'poa_global', 'poa_diffuse', 'poa_direct', 'poa_ground_diffuse',\n        'poa_sky_diffuse'])\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test_get_irradiance_poa", "singleton", "inputs", "solar_zenith", "0", "solar_azimuth", "180", "surface_tilt", "0", "surface_azimuth", "180", "gcr", "0", "5", "height", "1", "pitch", "1", "ghi", "1000", "dhi", "300", "dni", "700", "albedo", "0", "iam", "1", "0", "npoints", "100", "res", "infinite_sheds", "get_irradiance_poa", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam", "iam", "npoints", "npoints", "expected_diffuse", "np", "array", "300", "expected_direct", "np", "array", "700", "expected_global", "expected_diffuse", "expected_direct", "assert", "np", "isclose", "res", "poa_global", "expected_global", "assert", "np", "isclose", "res", "poa_diffuse", "expected_diffuse", "assert", "np", "isclose", "res", "poa_direct", "expected_direct", "vector", "inputs", "surface_tilt", "np", "array", "0", "0", "0", "0", "height", "1", "surface_azimuth", "np", "array", "180", "180", "180", "180", "gcr", "0", "5", "pitch", "1", "solar_zenith", "np", "array", "0", "45", "45", "90", "solar_azimuth", "np", "array", "180", "180", "135", "180", "expected_diffuse", "np", "array", "300", "300", "300", "300", "expected_direct", "np", "array", "700", "350", "np", "sqrt", "2", "350", "np", "sqrt", "2", "0", "expected_global", "expected_diffuse", "expected_direct", "res", "infinite_sheds", "get_irradiance_poa", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam", "iam", "npoints", "npoints", "assert", "np", "allclose", "res", "poa_global", "expected_global", "assert", "np", "allclose", "res", "poa_diffuse", "expected_diffuse", "assert", "np", "allclose", "res", "poa_direct", "expected_direct", "series", "inputs", "surface_tilt", "pd", "series", "surface_tilt", "surface_azimuth", "pd", "series", "data", "surface_azimuth", "index", "surface_tilt", "index", "solar_zenith", "pd", "series", "solar_zenith", "index", "surface_tilt", "index", "solar_azimuth", "pd", "series", "data", "solar_azimuth", "index", "surface_tilt", "index", "expected_diffuse", "pd", "series", "data", "expected_diffuse", "index", "surface_tilt", "index", "expected_direct", "pd", "series", "data", "expected_direct", "index", "surface_tilt", "index", "expected_global", "expected_diffuse", "expected_direct", "expected_global", "name", "poa_global", "to", "match", "output", "series", "res", "infinite_sheds", "get_irradiance_poa", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam", "iam", "npoints", "npoints", "assert", "isinstance", "res", "pd", "dataframe", "assert_series_equal", "res", "poa_global", "expected_global", "assert", "all", "k", "in", "res", "columns", "for", "k", "in", "poa_global", "poa_diffuse", "poa_direct", "poa_ground_diffuse", "poa_sky_diffuse"], "doc_len": 276}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test__backside_tilt", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test__backside_tilt", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test__backside_tilt():\n    tilt = np.array([0., 30., 30., 180.])\n    system_azimuth = np.array([180., 150., 270., 0.])\n    back_tilt, back_az = infinite_sheds._backside(tilt, system_azimuth)\n    assert np.allclose(back_tilt, np.array([180., 150., 150., 0.]))\n    assert np.allclose(back_az, np.array([0., 330., 90., 180.]))\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test__backside_tilt", "tilt", "np", "array", "0", "30", "30", "180", "system_azimuth", "np", "array", "180", "150", "270", "0", "back_tilt", "back_az", "infinite_sheds", "_backside", "tilt", "system_azimuth", "assert", "np", "allclose", "back_tilt", "np", "array", "180", "150", "150", "0", "assert", "np", "allclose", "back_az", "np", "array", "0", "330", "90", "180"], "doc_len": 47}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test_get_irradiance", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test_get_irradiance", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test_get_irradiance():\n    # singleton inputs\n    solar_zenith = 0.\n    solar_azimuth = 180.\n    surface_tilt = 0.\n    surface_azimuth = 180.\n    gcr = 0.5\n    height = 1.\n    pitch = 1.\n    ghi = 1000.\n    dhi = 300.\n    dni = 700.\n    albedo = 0.\n    iam_front = 1.0\n    iam_back = 1.0\n    npoints = 100\n    result = infinite_sheds.get_irradiance(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni, albedo, iam_front, iam_back,\n        bifaciality=0.8, shade_factor=-0.02, transmission_factor=0,\n        npoints=npoints)\n    expected_front_diffuse = np.array([300.])\n    expected_front_direct = np.array([700.])\n    expected_front_global = expected_front_diffuse + expected_front_direct\n    assert np.isclose(result['poa_front'], expected_front_global)\n    assert np.isclose(result['poa_front_diffuse'], expected_front_diffuse)\n    assert np.isclose(result['poa_front_direct'], expected_front_direct)\n    assert np.isclose(result['poa_global'], result['poa_front'])\n    # series inputs\n    ghi = pd.Series([1000., 500., 500., np.nan])\n    dhi = pd.Series([300., 500., 500., 500.], index=ghi.index)\n    dni = pd.Series([700., 0., 0., 700.], index=ghi.index)\n    solar_zenith = pd.Series([0., 0., 0., 135.], index=ghi.index)\n    surface_tilt = pd.Series([0., 0., 90., 0.], index=ghi.index)\n    result = infinite_sheds.get_irradiance(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni, albedo, iam_front, iam_back,\n        bifaciality=0.8, shade_factor=-0.02, transmission_factor=0,\n        npoints=npoints)\n    result_front = infinite_sheds.get_irradiance_poa(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni,\n        albedo, iam=iam_front)\n    assert isinstance(result, pd.DataFrame)\n    expected_poa_global = pd.Series(\n        [1000., 500., result_front['poa_global'][2] * (1 + 0.8 * 0.98),\n         np.nan], index=ghi.index, name='poa_global')\n    assert_series_equal(result['poa_global'], expected_poa_global)\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test_get_irradiance", "singleton", "inputs", "solar_zenith", "0", "solar_azimuth", "180", "surface_tilt", "0", "surface_azimuth", "180", "gcr", "0", "5", "height", "1", "pitch", "1", "ghi", "1000", "dhi", "300", "dni", "700", "albedo", "0", "iam_front", "1", "0", "iam_back", "1", "0", "npoints", "100", "result", "infinite_sheds", "get_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam_front", "iam_back", "bifaciality", "0", "8", "shade_factor", "0", "02", "transmission_factor", "0", "npoints", "npoints", "expected_front_diffuse", "np", "array", "300", "expected_front_direct", "np", "array", "700", "expected_front_global", "expected_front_diffuse", "expected_front_direct", "assert", "np", "isclose", "result", "poa_front", "expected_front_global", "assert", "np", "isclose", "result", "poa_front_diffuse", "expected_front_diffuse", "assert", "np", "isclose", "result", "poa_front_direct", "expected_front_direct", "assert", "np", "isclose", "result", "poa_global", "result", "poa_front", "series", "inputs", "ghi", "pd", "series", "1000", "500", "500", "np", "nan", "dhi", "pd", "series", "300", "500", "500", "500", "index", "ghi", "index", "dni", "pd", "series", "700", "0", "0", "700", "index", "ghi", "index", "solar_zenith", "pd", "series", "0", "0", "0", "135", "index", "ghi", "index", "surface_tilt", "pd", "series", "0", "0", "90", "0", "index", "ghi", "index", "result", "infinite_sheds", "get_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam_front", "iam_back", "bifaciality", "0", "8", "shade_factor", "0", "02", "transmission_factor", "0", "npoints", "npoints", "result_front", "infinite_sheds", "get_irradiance_poa", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam", "iam_front", "assert", "isinstance", "result", "pd", "dataframe", "expected_poa_global", "pd", "series", "1000", "500", "result_front", "poa_global", "2", "1", "0", "8", "0", "98", "np", "nan", "index", "ghi", "index", "name", "poa_global", "assert_series_equal", "result", "poa_global", "expected_poa_global"], "doc_len": 223}
{"doc_id": "pvlib/tests/bifacial/test_infinite_sheds.py::test_get_irradiance_limiting_gcr", "file_path": "pvlib/tests/bifacial/test_infinite_sheds.py", "class_name": null, "func_name": "test_get_irradiance_limiting_gcr", "text": "文件路径: pvlib/tests/bifacial/test_infinite_sheds.py\ndef test_get_irradiance_limiting_gcr():\n    # test confirms that irradiance on widely spaced rows is approximately\n    # the same as for a single row array\n    solar_zenith = 0.\n    solar_azimuth = 180.\n    surface_tilt = 90.\n    surface_azimuth = 180.\n    gcr = 0.00001\n    height = 1.\n    pitch = 100.\n    ghi = 1000.\n    dhi = 300.\n    dni = 700.\n    albedo = 1.\n    iam_front = 1.0\n    iam_back = 1.0\n    npoints = 100\n    result = infinite_sheds.get_irradiance(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth,\n        gcr, height, pitch, ghi, dhi, dni, albedo, iam_front, iam_back,\n        bifaciality=1., shade_factor=-0.00, transmission_factor=0.,\n        npoints=npoints)\n    expected_ground_diffuse = np.array([500.])\n    expected_sky_diffuse = np.array([150.])\n    expected_direct = np.array([0.])\n    expected_diffuse = expected_ground_diffuse + expected_sky_diffuse\n    expected_poa = expected_diffuse + expected_direct\n    assert np.isclose(result['poa_front'], expected_poa, rtol=0.01)\n    assert np.isclose(result['poa_front_diffuse'], expected_diffuse, rtol=0.01)\n    assert np.isclose(result['poa_front_direct'], expected_direct)\n    assert np.isclose(result['poa_front_sky_diffuse'], expected_sky_diffuse,\n                      rtol=0.01)\n    assert np.isclose(result['poa_front_ground_diffuse'],\n                      expected_ground_diffuse, rtol=0.01)\n    assert np.isclose(result['poa_front'], result['poa_back'])\n    assert np.isclose(result['poa_front_diffuse'], result['poa_back_diffuse'])\n    assert np.isclose(result['poa_front_direct'], result['poa_back_direct'])\n    assert np.isclose(result['poa_front_sky_diffuse'],\n                      result['poa_back_sky_diffuse'])\n    assert np.isclose(result['poa_front_ground_diffuse'],\n                      result['poa_back_ground_diffuse'])\n", "tokens": ["pvlib", "tests", "bifacial", "test_infinite_sheds", "py", "def", "test_get_irradiance_limiting_gcr", "test", "confirms", "that", "irradiance", "on", "widely", "spaced", "rows", "is", "approximately", "the", "same", "as", "for", "a", "single", "row", "array", "solar_zenith", "0", "solar_azimuth", "180", "surface_tilt", "90", "surface_azimuth", "180", "gcr", "0", "00001", "height", "1", "pitch", "100", "ghi", "1000", "dhi", "300", "dni", "700", "albedo", "1", "iam_front", "1", "0", "iam_back", "1", "0", "npoints", "100", "result", "infinite_sheds", "get_irradiance", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "height", "pitch", "ghi", "dhi", "dni", "albedo", "iam_front", "iam_back", "bifaciality", "1", "shade_factor", "0", "00", "transmission_factor", "0", "npoints", "npoints", "expected_ground_diffuse", "np", "array", "500", "expected_sky_diffuse", "np", "array", "150", "expected_direct", "np", "array", "0", "expected_diffuse", "expected_ground_diffuse", "expected_sky_diffuse", "expected_poa", "expected_diffuse", "expected_direct", "assert", "np", "isclose", "result", "poa_front", "expected_poa", "rtol", "0", "01", "assert", "np", "isclose", "result", "poa_front_diffuse", "expected_diffuse", "rtol", "0", "01", "assert", "np", "isclose", "result", "poa_front_direct", "expected_direct", "assert", "np", "isclose", "result", "poa_front_sky_diffuse", "expected_sky_diffuse", "rtol", "0", "01", "assert", "np", "isclose", "result", "poa_front_ground_diffuse", "expected_ground_diffuse", "rtol", "0", "01", "assert", "np", "isclose", "result", "poa_front", "result", "poa_back", "assert", "np", "isclose", "result", "poa_front_diffuse", "result", "poa_back_diffuse", "assert", "np", "isclose", "result", "poa_front_direct", "result", "poa_back_direct", "assert", "np", "isclose", "result", "poa_front_sky_diffuse", "result", "poa_back_sky_diffuse", "assert", "np", "isclose", "result", "poa_front_ground_diffuse", "result", "poa_back_ground_diffuse"], "doc_len": 176}
{"doc_id": "pvlib/tests/bifacial/test_pvfactors.py::example_values", "file_path": "pvlib/tests/bifacial/test_pvfactors.py", "class_name": null, "func_name": "example_values", "text": "文件路径: pvlib/tests/bifacial/test_pvfactors.py\ndef example_values():\n    \"\"\"\n    Example values from the pvfactors github repo README file:\n    https://github.com/SunPower/pvfactors/blob/master/README.rst#quick-start\n    \"\"\"\n    inputs = dict(\n        timestamps=pd.DatetimeIndex([datetime(2017, 8, 31, 11),\n                                     datetime(2017, 8, 31, 12)]),\n        solar_zenith=[20., 10.],\n        solar_azimuth=[110., 140.],\n        surface_tilt=[10., 0.],\n        surface_azimuth=[90., 90.],\n        axis_azimuth=0.,\n        dni=[1000., 300.],\n        dhi=[50., 500.],\n        gcr=0.4,\n        pvrow_height=1.75,\n        pvrow_width=2.44,\n        albedo=0.2,\n        n_pvrows=3,\n        index_observed_pvrow=1,\n        rho_front_pvrow=0.03,\n        rho_back_pvrow=0.05,\n        horizon_band_angle=15.,\n    )\n    outputs = dict(\n        expected_ipoa_front=pd.Series([1034.95474708997, 795.4423259036623],\n                                      index=inputs['timestamps'],\n                                      name=('total_inc_front')),\n        expected_ipoa_back=pd.Series([92.12563846416197, 78.05831585685098],\n                                     index=inputs['timestamps'],\n                                     name=('total_inc_back')),\n    )\n    return inputs, outputs\n", "tokens": ["pvlib", "tests", "bifacial", "test_pvfactors", "py", "def", "example_values", "example", "values", "from", "the", "pvfactors", "github", "repo", "readme", "file", "https", "github", "com", "sunpower", "pvfactors", "blob", "master", "readme", "rst", "quick", "start", "inputs", "dict", "timestamps", "pd", "datetimeindex", "datetime", "2017", "8", "31", "11", "datetime", "2017", "8", "31", "12", "solar_zenith", "20", "10", "solar_azimuth", "110", "140", "surface_tilt", "10", "0", "surface_azimuth", "90", "90", "axis_azimuth", "0", "dni", "1000", "300", "dhi", "50", "500", "gcr", "0", "4", "pvrow_height", "1", "75", "pvrow_width", "2", "44", "albedo", "0", "2", "n_pvrows", "3", "index_observed_pvrow", "1", "rho_front_pvrow", "0", "03", "rho_back_pvrow", "0", "05", "horizon_band_angle", "15", "outputs", "dict", "expected_ipoa_front", "pd", "series", "1034", "95474708997", "795", "4423259036623", "index", "inputs", "timestamps", "name", "total_inc_front", "expected_ipoa_back", "pd", "series", "92", "12563846416197", "78", "05831585685098", "index", "inputs", "timestamps", "name", "total_inc_back", "return", "inputs", "outputs"], "doc_len": 115}
{"doc_id": "pvlib/tests/bifacial/test_pvfactors.py::test_pvfactors_timeseries_list", "file_path": "pvlib/tests/bifacial/test_pvfactors.py", "class_name": null, "func_name": "test_pvfactors_timeseries_list", "text": "文件路径: pvlib/tests/bifacial/test_pvfactors.py\ndef test_pvfactors_timeseries_list(example_values):\n    \"\"\"Test basic pvfactors functionality with list inputs\"\"\"\n    inputs, outputs = example_values\n    ipoa_inc_front, ipoa_inc_back, _, _ = pvfactors_timeseries(**inputs)\n    assert_series_equal(ipoa_inc_front, outputs['expected_ipoa_front'])\n    assert_series_equal(ipoa_inc_back, outputs['expected_ipoa_back'])\n", "tokens": ["pvlib", "tests", "bifacial", "test_pvfactors", "py", "def", "test_pvfactors_timeseries_list", "example_values", "test", "basic", "pvfactors", "functionality", "with", "list", "inputs", "inputs", "outputs", "example_values", "ipoa_inc_front", "ipoa_inc_back", "_", "_", "pvfactors_timeseries", "inputs", "assert_series_equal", "ipoa_inc_front", "outputs", "expected_ipoa_front", "assert_series_equal", "ipoa_inc_back", "outputs", "expected_ipoa_back"], "doc_len": 32}
{"doc_id": "pvlib/tests/bifacial/test_pvfactors.py::test_pvfactors_timeseries_pandas", "file_path": "pvlib/tests/bifacial/test_pvfactors.py", "class_name": null, "func_name": "test_pvfactors_timeseries_pandas", "text": "文件路径: pvlib/tests/bifacial/test_pvfactors.py\ndef test_pvfactors_timeseries_pandas(example_values):\n    \"\"\"Test basic pvfactors functionality with Series inputs\"\"\"\n\n    inputs, outputs = example_values\n    for key in ['solar_zenith', 'solar_azimuth', 'surface_tilt',\n                'surface_azimuth', 'dni', 'dhi']:\n        inputs[key] = pd.Series(inputs[key], index=inputs['timestamps'])\n\n    ipoa_inc_front, ipoa_inc_back, _, _ = pvfactors_timeseries(**inputs)\n    assert_series_equal(ipoa_inc_front, outputs['expected_ipoa_front'])\n    assert_series_equal(ipoa_inc_back, outputs['expected_ipoa_back'])\n", "tokens": ["pvlib", "tests", "bifacial", "test_pvfactors", "py", "def", "test_pvfactors_timeseries_pandas", "example_values", "test", "basic", "pvfactors", "functionality", "with", "series", "inputs", "inputs", "outputs", "example_values", "for", "key", "in", "solar_zenith", "solar_azimuth", "surface_tilt", "surface_azimuth", "dni", "dhi", "inputs", "key", "pd", "series", "inputs", "key", "index", "inputs", "timestamps", "ipoa_inc_front", "ipoa_inc_back", "_", "_", "pvfactors_timeseries", "inputs", "assert_series_equal", "ipoa_inc_front", "outputs", "expected_ipoa_front", "assert_series_equal", "ipoa_inc_back", "outputs", "expected_ipoa_back"], "doc_len": 50}
{"doc_id": "pvlib/tests/bifacial/test_pvfactors.py::test_pvfactors_scalar_orientation", "file_path": "pvlib/tests/bifacial/test_pvfactors.py", "class_name": null, "func_name": "test_pvfactors_scalar_orientation", "text": "文件路径: pvlib/tests/bifacial/test_pvfactors.py\ndef test_pvfactors_scalar_orientation(example_values):\n    \"\"\"test that surface_tilt and surface_azimuth inputs can be scalars\"\"\"\n    # GH 1127, GH 1332\n    inputs, outputs = example_values\n    inputs['surface_tilt'] = 10.\n    inputs['surface_azimuth'] = 90.\n    # the second tilt is supposed to be zero, so we need to\n    # update the expected irradiances too:\n    outputs['expected_ipoa_front'].iloc[1] = 800.6524022701132\n    outputs['expected_ipoa_back'].iloc[1] = 81.72135884745822\n\n    ipoa_inc_front, ipoa_inc_back, _, _ = pvfactors_timeseries(**inputs)\n    assert_series_equal(ipoa_inc_front, outputs['expected_ipoa_front'])\n    assert_series_equal(ipoa_inc_back, outputs['expected_ipoa_back'])\n", "tokens": ["pvlib", "tests", "bifacial", "test_pvfactors", "py", "def", "test_pvfactors_scalar_orientation", "example_values", "test", "that", "surface_tilt", "and", "surface_azimuth", "inputs", "can", "be", "scalars", "gh", "1127", "gh", "1332", "inputs", "outputs", "example_values", "inputs", "surface_tilt", "10", "inputs", "surface_azimuth", "90", "the", "second", "tilt", "is", "supposed", "to", "be", "zero", "so", "we", "need", "to", "update", "the", "expected", "irradiances", "too", "outputs", "expected_ipoa_front", "iloc", "1", "800", "6524022701132", "outputs", "expected_ipoa_back", "iloc", "1", "81", "72135884745822", "ipoa_inc_front", "ipoa_inc_back", "_", "_", "pvfactors_timeseries", "inputs", "assert_series_equal", "ipoa_inc_front", "outputs", "expected_ipoa_front", "assert_series_equal", "ipoa_inc_back", "outputs", "expected_ipoa_back"], "doc_len": 73}
{"doc_id": "pvlib/tests/bifacial/test_utils.py::test_system_fixed_tilt", "file_path": "pvlib/tests/bifacial/test_utils.py", "class_name": null, "func_name": "test_system_fixed_tilt", "text": "文件路径: pvlib/tests/bifacial/test_utils.py\ndef test_system_fixed_tilt():\n    syst = {'height': 1.0,\n            'pitch': 2.,\n            'surface_tilt': 30.,\n            'surface_azimuth': 180.,\n            'axis_azimuth': None,\n            'rotation': -30.}\n    syst['gcr'] = 1.0 / syst['pitch']\n    # view factors from 3 points on the ground between rows to the sky\n    pts = np.linspace(0, 1, num=3)\n    sqr3 = np.sqrt(3) / 4\n    # c_i,j = cos(angle from point i to edge of row j), j=0 is row = -1\n    # c_i,j = cos(angle from point i to edge of row j), j=0 is row = -1\n    c00 = (-2 - sqr3) / np.sqrt(1.25**2 + (2 + sqr3)**2)  # right edge row -1\n    c01 = -sqr3 / np.sqrt(1.25**2 + sqr3**2)  # right edge row 0\n    c02 = sqr3 / np.sqrt(0.75**2 + sqr3**2)  # left edge of row 0\n    c03 = (2 - sqr3) / np.sqrt(1.25**2 + (2 - sqr3)**2)  # right edge of row 1\n    vf_0 = 0.5 * (c03 - c02 + c01 - c00)  # vf at point 0\n    c10 = (-3 - sqr3) / np.sqrt(1.25**2 + (3 + sqr3)**2)  # right edge row -1\n    c11 = (-1 - sqr3) / np.sqrt(1.25**2 + (1 + sqr3)**2)  # right edge row 0\n    c12 = (-1 + sqr3) / np.sqrt(0.75**2 + (-1 + sqr3)**2)  # left edge row 0\n    c13 = (1 - sqr3) / np.sqrt(1.25**2 + (1 - sqr3)**2)  # right edge row\n    vf_1 = 0.5 * (c13 - c12 + c11 - c10)  # vf at point 1\n    c20 = -(4 + sqr3) / np.sqrt(1.25**2 + (4 + sqr3)**2)  # right edge row -1\n    c21 = (-2 + sqr3) / np.sqrt(0.75**2 + (-2 + sqr3)**2)  # left edge row 0\n    c22 = (-2 - sqr3) / np.sqrt(1.25**2 + (2 + sqr3)**2)  # right edge row 0\n    c23 = (0 - sqr3) / np.sqrt(1.25**2 + (0 - sqr3)**2)  # right edge row 1\n    vf_2 = 0.5 * (c23 - c22 + c21 - c20)  # vf at point 1\n    vfs_ground_sky = np.array([vf_0, vf_1, vf_2])\n    return syst, pts, vfs_ground_sky\n", "tokens": ["pvlib", "tests", "bifacial", "test_utils", "py", "def", "test_system_fixed_tilt", "syst", "height", "1", "0", "pitch", "2", "surface_tilt", "30", "surface_azimuth", "180", "axis_azimuth", "none", "rotation", "30", "syst", "gcr", "1", "0", "syst", "pitch", "view", "factors", "from", "3", "points", "on", "the", "ground", "between", "rows", "to", "the", "sky", "pts", "np", "linspace", "0", "1", "num", "3", "sqr3", "np", "sqrt", "3", "4", "c_i", "j", "cos", "angle", "from", "point", "i", "to", "edge", "of", "row", "j", "j", "0", "is", "row", "1", "c_i", "j", "cos", "angle", "from", "point", "i", "to", "edge", "of", "row", "j", "j", "0", "is", "row", "1", "c00", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "row", "1", "c01", "sqr3", "np", "sqrt", "1", "25", "2", "sqr3", "2", "right", "edge", "row", "0", "c02", "sqr3", "np", "sqrt", "0", "75", "2", "sqr3", "2", "left", "edge", "of", "row", "0", "c03", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "of", "row", "1", "vf_0", "0", "5", "c03", "c02", "c01", "c00", "vf", "at", "point", "0", "c10", "3", "sqr3", "np", "sqrt", "1", "25", "2", "3", "sqr3", "2", "right", "edge", "row", "1", "c11", "1", "sqr3", "np", "sqrt", "1", "25", "2", "1", "sqr3", "2", "right", "edge", "row", "0", "c12", "1", "sqr3", "np", "sqrt", "0", "75", "2", "1", "sqr3", "2", "left", "edge", "row", "0", "c13", "1", "sqr3", "np", "sqrt", "1", "25", "2", "1", "sqr3", "2", "right", "edge", "row", "vf_1", "0", "5", "c13", "c12", "c11", "c10", "vf", "at", "point", "1", "c20", "4", "sqr3", "np", "sqrt", "1", "25", "2", "4", "sqr3", "2", "right", "edge", "row", "1", "c21", "2", "sqr3", "np", "sqrt", "0", "75", "2", "2", "sqr3", "2", "left", "edge", "row", "0", "c22", "2", "sqr3", "np", "sqrt", "1", "25", "2", "2", "sqr3", "2", "right", "edge", "row", "0", "c23", "0", "sqr3", "np", "sqrt", "1", "25", "2", "0", "sqr3", "2", "right", "edge", "row", "1", "vf_2", "0", "5", "c23", "c22", "c21", "c20", "vf", "at", "point", "1", "vfs_ground_sky", "np", "array", "vf_0", "vf_1", "vf_2", "return", "syst", "pts", "vfs_ground_sky"], "doc_len": 306}
{"doc_id": "pvlib/tests/bifacial/test_utils.py::test__solar_projection_tangent", "file_path": "pvlib/tests/bifacial/test_utils.py", "class_name": null, "func_name": "test__solar_projection_tangent", "text": "文件路径: pvlib/tests/bifacial/test_utils.py\ndef test__solar_projection_tangent():\n    tan_phi_f = utils._solar_projection_tangent(\n        30, 150, 180)\n    tan_phi_b = utils._solar_projection_tangent(\n        30, 150, 0)\n    assert np.allclose(tan_phi_f, 0.5)\n    assert np.allclose(tan_phi_b, -0.5)\n    assert np.allclose(tan_phi_f, -tan_phi_b)\n", "tokens": ["pvlib", "tests", "bifacial", "test_utils", "py", "def", "test__solar_projection_tangent", "tan_phi_f", "utils", "_solar_projection_tangent", "30", "150", "180", "tan_phi_b", "utils", "_solar_projection_tangent", "30", "150", "0", "assert", "np", "allclose", "tan_phi_f", "0", "5", "assert", "np", "allclose", "tan_phi_b", "0", "5", "assert", "np", "allclose", "tan_phi_f", "tan_phi_b"], "doc_len": 36}
{"doc_id": "pvlib/tests/bifacial/test_utils.py::test__unshaded_ground_fraction", "file_path": "pvlib/tests/bifacial/test_utils.py", "class_name": null, "func_name": "test__unshaded_ground_fraction", "text": "文件路径: pvlib/tests/bifacial/test_utils.py\ndef test__unshaded_ground_fraction(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth, gcr,\n        expected):\n    # frontside, same for both sides\n    f_sky_beam_f = utils._unshaded_ground_fraction(\n        surface_tilt, surface_azimuth, solar_zenith, solar_azimuth, gcr)\n    assert np.allclose(f_sky_beam_f, expected)\n    # backside, should be the same as frontside\n    f_sky_beam_b = utils._unshaded_ground_fraction(\n        180. - surface_tilt, surface_azimuth - 180., solar_zenith,\n        solar_azimuth, gcr)\n    assert np.allclose(f_sky_beam_b, expected)\n", "tokens": ["pvlib", "tests", "bifacial", "test_utils", "py", "def", "test__unshaded_ground_fraction", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "expected", "frontside", "same", "for", "both", "sides", "f_sky_beam_f", "utils", "_unshaded_ground_fraction", "surface_tilt", "surface_azimuth", "solar_zenith", "solar_azimuth", "gcr", "assert", "np", "allclose", "f_sky_beam_f", "expected", "backside", "should", "be", "the", "same", "as", "frontside", "f_sky_beam_b", "utils", "_unshaded_ground_fraction", "180", "surface_tilt", "surface_azimuth", "180", "solar_zenith", "solar_azimuth", "gcr", "assert", "np", "allclose", "f_sky_beam_b", "expected"], "doc_len": 53}
{"doc_id": "pvlib/tests/bifacial/test_utils.py::test__vf_ground_sky_2d", "file_path": "pvlib/tests/bifacial/test_utils.py", "class_name": null, "func_name": "test__vf_ground_sky_2d", "text": "文件路径: pvlib/tests/bifacial/test_utils.py\ndef test__vf_ground_sky_2d(test_system_fixed_tilt):\n    # vector input\n    ts, pts, vfs_gnd_sky = test_system_fixed_tilt\n    vfs, _ = utils._vf_ground_sky_2d(pts, ts['rotation'], ts['gcr'],\n                                     ts['pitch'], ts['height'], max_rows=1)\n    assert np.allclose(vfs, vfs_gnd_sky, rtol=0.1)  # middle point vf is off\n    # test with singleton x\n    vf, _ = utils._vf_ground_sky_2d(pts[0], ts['rotation'], ts['gcr'],\n                                    ts['pitch'], ts['height'], max_rows=1)\n    assert np.isclose(vf, vfs_gnd_sky[0])\n", "tokens": ["pvlib", "tests", "bifacial", "test_utils", "py", "def", "test__vf_ground_sky_2d", "test_system_fixed_tilt", "vector", "input", "ts", "pts", "vfs_gnd_sky", "test_system_fixed_tilt", "vfs", "_", "utils", "_vf_ground_sky_2d", "pts", "ts", "rotation", "ts", "gcr", "ts", "pitch", "ts", "height", "max_rows", "1", "assert", "np", "allclose", "vfs", "vfs_gnd_sky", "rtol", "0", "1", "middle", "point", "vf", "is", "off", "test", "with", "singleton", "x", "vf", "_", "utils", "_vf_ground_sky_2d", "pts", "0", "ts", "rotation", "ts", "gcr", "ts", "pitch", "ts", "height", "max_rows", "1", "assert", "np", "isclose", "vf", "vfs_gnd_sky", "0"], "doc_len": 68}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::bsrn_credentials", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "bsrn_credentials", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef bsrn_credentials():\n    \"\"\"Supplies the BSRN FTP credentials for testing purposes.\n\n    Users should obtain their own credentials as described in the `read_bsrn`\n    documentation.\"\"\"\n    bsrn_username = os.environ[\"BSRN_FTP_USERNAME\"]\n    bsrn_password = os.environ[\"BSRN_FTP_PASSWORD\"]\n    return bsrn_username, bsrn_password\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "bsrn_credentials", "supplies", "the", "bsrn", "ftp", "credentials", "for", "testing", "purposes", "users", "should", "obtain", "their", "own", "credentials", "as", "described", "in", "the", "read_bsrn", "documentation", "bsrn_username", "os", "environ", "bsrn_ftp_username", "bsrn_password", "os", "environ", "bsrn_ftp_password", "return", "bsrn_username", "bsrn_password"], "doc_len": 38}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::expected_index", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "expected_index", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef expected_index():\n    return pd.date_range(start='20160601', periods=43200, freq='1min',\n                         tz='UTC')\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "expected_index", "return", "pd", "date_range", "start", "20160601", "periods", "43200", "freq", "1min", "tz", "utc"], "doc_len": 18}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_read_bsrn", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_read_bsrn", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_read_bsrn(testfile, expected_index):\n    data, metadata = read_bsrn(DATA_DIR / testfile)\n    assert_index_equal(expected_index, data.index)\n    assert 'ghi' in data.columns\n    assert 'dni_std' in data.columns\n    assert 'dhi_min' in data.columns\n    assert 'lwd_max' in data.columns\n    assert 'relative_humidity' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_read_bsrn", "testfile", "expected_index", "data", "metadata", "read_bsrn", "data_dir", "testfile", "assert_index_equal", "expected_index", "data", "index", "assert", "ghi", "in", "data", "columns", "assert", "dni_std", "in", "data", "columns", "assert", "dhi_min", "in", "data", "columns", "assert", "lwd_max", "in", "data", "columns", "assert", "relative_humidity", "in", "data", "columns"], "doc_len": 43}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_read_bsrn_logical_records", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_read_bsrn_logical_records", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_read_bsrn_logical_records(expected_index):\n    # Test if logical records 0300 and 0500 are correct parsed\n    # and that 0100 is not passed when not specified\n    data, metadata = read_bsrn(DATA_DIR / 'bsrn-pay0616.dat.gz',\n                               logical_records=['0300', '0500'])\n    assert_index_equal(expected_index, data.index)\n    assert 'lwu' in data.columns\n    assert 'uva_global' in data.columns\n    assert 'uvb_reflected_std' in data.columns\n    assert 'ghi' not in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_read_bsrn_logical_records", "expected_index", "test", "if", "logical", "records", "0300", "and", "0500", "are", "correct", "parsed", "and", "that", "0100", "is", "not", "passed", "when", "not", "specified", "data", "metadata", "read_bsrn", "data_dir", "bsrn", "pay0616", "dat", "gz", "logical_records", "0300", "0500", "assert_index_equal", "expected_index", "data", "index", "assert", "lwu", "in", "data", "columns", "assert", "uva_global", "in", "data", "columns", "assert", "uvb_reflected_std", "in", "data", "columns", "assert", "ghi", "not", "in", "data", "columns"], "doc_len": 63}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_read_bsrn_bad_logical_record", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_read_bsrn_bad_logical_record", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_read_bsrn_bad_logical_record():\n    # Test if ValueError is raised if an unsupported logical record is passed\n    with pytest.raises(ValueError, match='not in'):\n        read_bsrn(DATA_DIR / 'bsrn-lr0100-pay0616.dat',\n                  logical_records=['dummy'])\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_read_bsrn_bad_logical_record", "test", "if", "valueerror", "is", "raised", "if", "an", "unsupported", "logical", "record", "is", "passed", "with", "pytest", "raises", "valueerror", "match", "not", "in", "read_bsrn", "data_dir", "bsrn", "lr0100", "pay0616", "dat", "logical_records", "dummy"], "doc_len": 34}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_read_bsrn_logical_records_not_found", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_read_bsrn_logical_records_not_found", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_read_bsrn_logical_records_not_found():\n    # Test if an empty dataframe is returned if specified LRs are not present\n    data, metadata = read_bsrn(DATA_DIR / 'bsrn-lr0100-pay0616.dat',\n                               logical_records=['0300', '0500'])\n    assert data.empty  # assert that the dataframe is empty\n    assert 'uva_global' in data.columns\n    assert 'uvb_reflected_std' in data.columns\n    assert 'uva_global_max' in data.columns\n    assert 'dni' not in data.columns\n    assert 'day' not in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_read_bsrn_logical_records_not_found", "test", "if", "an", "empty", "dataframe", "is", "returned", "if", "specified", "lrs", "are", "not", "present", "data", "metadata", "read_bsrn", "data_dir", "bsrn", "lr0100", "pay0616", "dat", "logical_records", "0300", "0500", "assert", "data", "empty", "assert", "that", "the", "dataframe", "is", "empty", "assert", "uva_global", "in", "data", "columns", "assert", "uvb_reflected_std", "in", "data", "columns", "assert", "uva_global_max", "in", "data", "columns", "assert", "dni", "not", "in", "data", "columns", "assert", "day", "not", "in", "data", "columns"], "doc_len": 67}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_get_bsrn", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_get_bsrn", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_get_bsrn(expected_index, bsrn_credentials):\n    # Retrieve irradiance data from the BSRN FTP server\n    # the TAM station is chosen due to its small file sizes\n    temp_dir = tempfile.TemporaryDirectory()  # create temporary directory\n    username, password = bsrn_credentials\n    data, metadata = get_bsrn(\n        start=pd.Timestamp(2016, 6, 1),\n        end=pd.Timestamp(2016, 6, 29),\n        station='tam',\n        username=username,\n        password=password,\n        save_path=temp_dir.name)\n    assert_index_equal(expected_index, data.index)\n    assert 'ghi' in data.columns\n    assert 'dni_std' in data.columns\n    assert 'dhi_min' in data.columns\n    assert 'lwd_max' in data.columns\n    assert 'relative_humidity' in data.columns\n    # test that a local file was saved and is read correctly\n    data2, metadata2 = read_bsrn(os.path.join(temp_dir.name, 'tam0616.dat.gz'))\n    assert_index_equal(expected_index, data2.index)\n    assert 'ghi' in data2.columns\n    temp_dir.cleanup()  # explicitly remove temporary directory\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_get_bsrn", "expected_index", "bsrn_credentials", "retrieve", "irradiance", "data", "from", "the", "bsrn", "ftp", "server", "the", "tam", "station", "is", "chosen", "due", "to", "its", "small", "file", "sizes", "temp_dir", "tempfile", "temporarydirectory", "create", "temporary", "directory", "username", "password", "bsrn_credentials", "data", "metadata", "get_bsrn", "start", "pd", "timestamp", "2016", "6", "1", "end", "pd", "timestamp", "2016", "6", "29", "station", "tam", "username", "username", "password", "password", "save_path", "temp_dir", "name", "assert_index_equal", "expected_index", "data", "index", "assert", "ghi", "in", "data", "columns", "assert", "dni_std", "in", "data", "columns", "assert", "dhi_min", "in", "data", "columns", "assert", "lwd_max", "in", "data", "columns", "assert", "relative_humidity", "in", "data", "columns", "test", "that", "a", "local", "file", "was", "saved", "and", "is", "read", "correctly", "data2", "metadata2", "read_bsrn", "os", "path", "join", "temp_dir", "name", "tam0616", "dat", "gz", "assert_index_equal", "expected_index", "data2", "index", "assert", "ghi", "in", "data2", "columns", "temp_dir", "cleanup", "explicitly", "remove", "temporary", "directory"], "doc_len": 127}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_get_bsrn_bad_station", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_get_bsrn_bad_station", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_get_bsrn_bad_station(bsrn_credentials):\n    # Test if KeyError is raised if a bad station name is passed\n    username, password = bsrn_credentials\n    with pytest.raises(KeyError, match='sub-directory does not exist'):\n        get_bsrn(\n            start=pd.Timestamp(2016, 6, 1),\n            end=pd.Timestamp(2016, 6, 29),\n            station='not_a_station_name',\n            username=username,\n            password=password)\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_get_bsrn_bad_station", "bsrn_credentials", "test", "if", "keyerror", "is", "raised", "if", "a", "bad", "station", "name", "is", "passed", "username", "password", "bsrn_credentials", "with", "pytest", "raises", "keyerror", "match", "sub", "directory", "does", "not", "exist", "get_bsrn", "start", "pd", "timestamp", "2016", "6", "1", "end", "pd", "timestamp", "2016", "6", "29", "station", "not_a_station_name", "username", "username", "password", "password"], "doc_len": 52}
{"doc_id": "pvlib/tests/iotools/test_bsrn.py::test_get_bsrn_no_files", "file_path": "pvlib/tests/iotools/test_bsrn.py", "class_name": null, "func_name": "test_get_bsrn_no_files", "text": "文件路径: pvlib/tests/iotools/test_bsrn.py\ndef test_get_bsrn_no_files(bsrn_credentials):\n    username, password = bsrn_credentials\n    # Test if Warning is given if no files are found for the entire time frame\n    with pytest.warns(UserWarning, match='No files'):\n        get_bsrn(\n            start=pd.Timestamp(1990, 6, 1),\n            end=pd.Timestamp(1990, 6, 29),\n            station='tam',\n            username=username,\n            password=password)\n", "tokens": ["pvlib", "tests", "iotools", "test_bsrn", "py", "def", "test_get_bsrn_no_files", "bsrn_credentials", "username", "password", "bsrn_credentials", "test", "if", "warning", "is", "given", "if", "no", "files", "are", "found", "for", "the", "entire", "time", "frame", "with", "pytest", "warns", "userwarning", "match", "no", "files", "get_bsrn", "start", "pd", "timestamp", "1990", "6", "1", "end", "pd", "timestamp", "1990", "6", "29", "station", "tam", "username", "username", "password", "password"], "doc_len": 52}
{"doc_id": "pvlib/tests/iotools/test_crn.py::columns_mapped", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "columns_mapped", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef columns_mapped():\n    return [\n        'WBANNO', 'UTC_DATE', 'UTC_TIME', 'LST_DATE', 'LST_TIME', 'CRX_VN',\n        'longitude', 'latitude', 'temp_air', 'PRECIPITATION', 'ghi',\n        'ghi_flag',\n        'SURFACE_TEMPERATURE', 'ST_TYPE', 'ST_FLAG', 'relative_humidity',\n        'relative_humidity_flag', 'SOIL_MOISTURE_5', 'SOIL_TEMPERATURE_5',\n        'WETNESS', 'WET_FLAG', 'wind_speed', 'wind_speed_flag']\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "columns_mapped", "return", "wbanno", "utc_date", "utc_time", "lst_date", "lst_time", "crx_vn", "longitude", "latitude", "temp_air", "precipitation", "ghi", "ghi_flag", "surface_temperature", "st_type", "st_flag", "relative_humidity", "relative_humidity_flag", "soil_moisture_5", "soil_temperature_5", "wetness", "wet_flag", "wind_speed", "wind_speed_flag"], "doc_len": 31}
{"doc_id": "pvlib/tests/iotools/test_crn.py::columns_unmapped", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "columns_unmapped", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef columns_unmapped():\n    return [\n        'WBANNO', 'UTC_DATE', 'UTC_TIME', 'LST_DATE', 'LST_TIME', 'CRX_VN',\n        'LONGITUDE', 'LATITUDE', 'AIR_TEMPERATURE', 'PRECIPITATION',\n        'SOLAR_RADIATION', 'SR_FLAG', 'SURFACE_TEMPERATURE', 'ST_TYPE',\n        'ST_FLAG', 'RELATIVE_HUMIDITY', 'RH_FLAG', 'SOIL_MOISTURE_5',\n        'SOIL_TEMPERATURE_5', 'WETNESS', 'WET_FLAG', 'WIND_1_5', 'WIND_FLAG']\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "columns_unmapped", "return", "wbanno", "utc_date", "utc_time", "lst_date", "lst_time", "crx_vn", "longitude", "latitude", "air_temperature", "precipitation", "solar_radiation", "sr_flag", "surface_temperature", "st_type", "st_flag", "relative_humidity", "rh_flag", "soil_moisture_5", "soil_temperature_5", "wetness", "wet_flag", "wind_1_5", "wind_flag"], "doc_len": 31}
{"doc_id": "pvlib/tests/iotools/test_crn.py::dtypes", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "dtypes", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef dtypes():\n    return [\n        dtype('int64'), dtype('int64'), dtype('int64'), dtype('int64'),\n        dtype('int64'), dtype('O'), dtype('float64'), dtype('float64'),\n        dtype('float64'), dtype('float64'), dtype('float64'),\n        dtype('int64'), dtype('float64'), dtype('O'), dtype('int64'),\n        dtype('float64'), dtype('int64'), dtype('float64'),\n        dtype('float64'), dtype('int64'), dtype('int64'), dtype('float64'),\n        dtype('int64')]\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "dtypes", "return", "dtype", "int64", "dtype", "int64", "dtype", "int64", "dtype", "int64", "dtype", "int64", "dtype", "o", "dtype", "float64", "dtype", "float64", "dtype", "float64", "dtype", "float64", "dtype", "float64", "dtype", "int64", "dtype", "float64", "dtype", "o", "dtype", "int64", "dtype", "float64", "dtype", "int64", "dtype", "float64", "dtype", "float64", "dtype", "int64", "dtype", "int64", "dtype", "float64", "dtype", "int64"], "doc_len": 54}
{"doc_id": "pvlib/tests/iotools/test_crn.py::testfile", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "testfile", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef testfile():\n    return DATA_DIR / 'CRNS0101-05-2019-AZ_Tucson_11_W.txt'\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "testfile", "return", "data_dir", "crns0101", "05", "2019", "az_tucson_11_w", "txt"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_crn.py::testfile_problems", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "testfile_problems", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef testfile_problems():\n    return DATA_DIR / 'CRN_with_problems.txt'\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "testfile_problems", "return", "data_dir", "crn_with_problems", "txt"], "doc_len": 11}
{"doc_id": "pvlib/tests/iotools/test_crn.py::test_read_crn", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "test_read_crn", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef test_read_crn(testfile, columns_mapped, dtypes):\n    index = pd.DatetimeIndex(['2019-01-01 16:10:00',\n                              '2019-01-01 16:15:00',\n                              '2019-01-01 16:20:00',\n                              '2019-01-01 16:25:00'],\n                             freq=None).tz_localize('UTC')\n    values = np.array([\n        [53131, 20190101, 1610, 20190101, 910, 3, -111.17, 32.24, nan,\n         0.0, 296.0, 0, 4.4, 'C', 0, 90.0, 0, nan, nan, 24, 0, 0.78, 0],\n        [53131, 20190101, 1615, 20190101, 915, 3, -111.17, 32.24, 3.3,\n         0.0, 183.0, 0, 4.0, 'C', 0, 87.0, 0, nan, nan, 1182, 0, 0.36, 0],\n        [53131, 20190101, 1620, 20190101, 920, 3, -111.17, 32.24, 3.5,\n         0.0, 340.0, 0, 4.3, 'C', 0, 83.0, 0, nan, nan, 1183, 0, 0.53, 0],\n        [53131, 20190101, 1625, 20190101, 925, 3, -111.17, 32.24, 4.0,\n         0.0, 393.0, 0, 4.8, 'C', 0, 81.0, 0, nan, nan, 1223, 0, 0.64, 0]])\n    expected = pd.DataFrame(values, columns=columns_mapped, index=index)\n    for (col, _dtype) in zip(expected.columns, dtypes):\n        expected[col] = expected[col].astype(_dtype)\n    out = crn.read_crn(testfile)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "test_read_crn", "testfile", "columns_mapped", "dtypes", "index", "pd", "datetimeindex", "2019", "01", "01", "16", "10", "00", "2019", "01", "01", "16", "15", "00", "2019", "01", "01", "16", "20", "00", "2019", "01", "01", "16", "25", "00", "freq", "none", "tz_localize", "utc", "values", "np", "array", "53131", "20190101", "1610", "20190101", "910", "3", "111", "17", "32", "24", "nan", "0", "0", "296", "0", "0", "4", "4", "c", "0", "90", "0", "0", "nan", "nan", "24", "0", "0", "78", "0", "53131", "20190101", "1615", "20190101", "915", "3", "111", "17", "32", "24", "3", "3", "0", "0", "183", "0", "0", "4", "0", "c", "0", "87", "0", "0", "nan", "nan", "1182", "0", "0", "36", "0", "53131", "20190101", "1620", "20190101", "920", "3", "111", "17", "32", "24", "3", "5", "0", "0", "340", "0", "0", "4", "3", "c", "0", "83", "0", "0", "nan", "nan", "1183", "0", "0", "53", "0", "53131", "20190101", "1625", "20190101", "925", "3", "111", "17", "32", "24", "4", "0", "0", "0", "393", "0", "0", "4", "8", "c", "0", "81", "0", "0", "nan", "nan", "1223", "0", "0", "64", "0", "expected", "pd", "dataframe", "values", "columns", "columns_mapped", "index", "index", "for", "col", "_dtype", "in", "zip", "expected", "columns", "dtypes", "expected", "col", "expected", "col", "astype", "_dtype", "out", "crn", "read_crn", "testfile", "assert_frame_equal", "out", "expected"], "doc_len": 196}
{"doc_id": "pvlib/tests/iotools/test_crn.py::test_read_crn_map_variables", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "test_read_crn_map_variables", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef test_read_crn_map_variables(testfile, columns_unmapped, dtypes):\n    out = crn.read_crn(testfile, map_variables=False)\n    assert_index_equal(out.columns, pd.Index(columns_unmapped))\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "test_read_crn_map_variables", "testfile", "columns_unmapped", "dtypes", "out", "crn", "read_crn", "testfile", "map_variables", "false", "assert_index_equal", "out", "columns", "pd", "index", "columns_unmapped"], "doc_len": 22}
{"doc_id": "pvlib/tests/iotools/test_crn.py::test_read_crn_problems", "file_path": "pvlib/tests/iotools/test_crn.py", "class_name": null, "func_name": "test_read_crn_problems", "text": "文件路径: pvlib/tests/iotools/test_crn.py\ndef test_read_crn_problems(testfile_problems, columns_mapped, dtypes):\n    # GH1025\n    index = pd.DatetimeIndex(['2020-07-06 12:00:00',\n                              '2020-07-06 13:10:00'],\n                             freq=None).tz_localize('UTC')\n    values = np.array([\n        [92821, 20200706, 1200, 20200706, 700, '3', -80.69, 28.62, 24.9,\n         0.0, np.nan, 0, 25.5, 'C', 0, 93.0, 0, nan, nan, 990, 0, 1.57, 0],\n        [92821, 20200706, 1310, 20200706, 810, '2.623', -80.69, 28.62,\n         26.9, 0.0, 430.0, 0, 30.2, 'C', 0, 87.0, 0, nan, nan, 989, 0,\n         1.64, 0]])\n    expected = pd.DataFrame(values, columns=columns_mapped, index=index)\n    for (col, _dtype) in zip(expected.columns, dtypes):\n        expected[col] = expected[col].astype(_dtype)\n    out = crn.read_crn(testfile_problems)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_crn", "py", "def", "test_read_crn_problems", "testfile_problems", "columns_mapped", "dtypes", "gh1025", "index", "pd", "datetimeindex", "2020", "07", "06", "12", "00", "00", "2020", "07", "06", "13", "10", "00", "freq", "none", "tz_localize", "utc", "values", "np", "array", "92821", "20200706", "1200", "20200706", "700", "3", "80", "69", "28", "62", "24", "9", "0", "0", "np", "nan", "0", "25", "5", "c", "0", "93", "0", "0", "nan", "nan", "990", "0", "1", "57", "0", "92821", "20200706", "1310", "20200706", "810", "2", "623", "80", "69", "28", "62", "26", "9", "0", "0", "430", "0", "0", "30", "2", "c", "0", "87", "0", "0", "nan", "nan", "989", "0", "1", "64", "0", "expected", "pd", "dataframe", "values", "columns", "columns_mapped", "index", "index", "for", "col", "_dtype", "in", "zip", "expected", "columns", "dtypes", "expected", "col", "expected", "col", "astype", "_dtype", "out", "crn", "read_crn", "testfile_problems", "assert_frame_equal", "out", "expected"], "doc_len": 125}
{"doc_id": "pvlib/tests/iotools/test_ecmwf_macc.py::expected_test_data", "file_path": "pvlib/tests/iotools/test_ecmwf_macc.py", "class_name": null, "func_name": "expected_test_data", "text": "文件路径: pvlib/tests/iotools/test_ecmwf_macc.py\ndef expected_test_data():\n    return DATA_DIR / TESTDATA\n", "tokens": ["pvlib", "tests", "iotools", "test_ecmwf_macc", "py", "def", "expected_test_data", "return", "data_dir", "testdata"], "doc_len": 10}
{"doc_id": "pvlib/tests/iotools/test_ecmwf_macc.py::test_get_nearest_indices", "file_path": "pvlib/tests/iotools/test_ecmwf_macc.py", "class_name": null, "func_name": "test_get_nearest_indices", "text": "文件路径: pvlib/tests/iotools/test_ecmwf_macc.py\ndef test_get_nearest_indices(expected_test_data):\n    \"\"\"Test getting indices given latitude, longitude from ECMWF_MACC data.\"\"\"\n    data = ecmwf_macc.ECMWF_MACC(expected_test_data)\n    ilat, ilon = data.get_nearest_indices(38, -122)\n    assert ilat == 17\n    assert ilon == 79\n", "tokens": ["pvlib", "tests", "iotools", "test_ecmwf_macc", "py", "def", "test_get_nearest_indices", "expected_test_data", "test", "getting", "indices", "given", "latitude", "longitude", "from", "ecmwf_macc", "data", "data", "ecmwf_macc", "ecmwf_macc", "expected_test_data", "ilat", "ilon", "data", "get_nearest_indices", "38", "122", "assert", "ilat", "17", "assert", "ilon", "79"], "doc_len": 33}
{"doc_id": "pvlib/tests/iotools/test_ecmwf_macc.py::test_interp_data", "file_path": "pvlib/tests/iotools/test_ecmwf_macc.py", "class_name": null, "func_name": "test_interp_data", "text": "文件路径: pvlib/tests/iotools/test_ecmwf_macc.py\ndef test_interp_data(expected_test_data):\n    \"\"\"Test interpolating UTC time from ECMWF_MACC data.\"\"\"\n    data = ecmwf_macc.ECMWF_MACC(expected_test_data)\n    test9am = data.interp_data(\n        38, -122, datetime.datetime(2012, 11, 1, 9, 0, 0), 'aod550')\n    assert np.isclose(test9am, data.data.variables['aod550'][2, 17, 79])\n    test12pm = data.interp_data(\n        38, -122, datetime.datetime(2012, 11, 1, 12, 0, 0), 'aod550')\n    assert np.isclose(test12pm, data.data.variables['aod550'][3, 17, 79])\n    test113301 = data.interp_data(\n        38, -122, datetime.datetime(2012, 11, 1, 11, 33, 1), 'aod550')\n    expected = test9am + (2 + (33 + 1 / 60) / 60) / 3 * (test12pm - test9am)\n    assert np.isclose(test113301, expected)  # 0.15515305836696536\n", "tokens": ["pvlib", "tests", "iotools", "test_ecmwf_macc", "py", "def", "test_interp_data", "expected_test_data", "test", "interpolating", "utc", "time", "from", "ecmwf_macc", "data", "data", "ecmwf_macc", "ecmwf_macc", "expected_test_data", "test9am", "data", "interp_data", "38", "122", "datetime", "datetime", "2012", "11", "1", "9", "0", "0", "aod550", "assert", "np", "isclose", "test9am", "data", "data", "variables", "aod550", "2", "17", "79", "test12pm", "data", "interp_data", "38", "122", "datetime", "datetime", "2012", "11", "1", "12", "0", "0", "aod550", "assert", "np", "isclose", "test12pm", "data", "data", "variables", "aod550", "3", "17", "79", "test113301", "data", "interp_data", "38", "122", "datetime", "datetime", "2012", "11", "1", "11", "33", "1", "aod550", "expected", "test9am", "2", "33", "1", "60", "60", "3", "test12pm", "test9am", "assert", "np", "isclose", "test113301", "expected", "0", "15515305836696536"], "doc_len": 100}
{"doc_id": "pvlib/tests/iotools/test_ecmwf_macc.py::test_read_ecmwf_macc", "file_path": "pvlib/tests/iotools/test_ecmwf_macc.py", "class_name": null, "func_name": "test_read_ecmwf_macc", "text": "文件路径: pvlib/tests/iotools/test_ecmwf_macc.py\ndef test_read_ecmwf_macc(expected_test_data):\n    \"\"\"Test reading ECMWF_MACC data from netCDF4 file.\"\"\"\n    data = ecmwf_macc.read_ecmwf_macc(\n        expected_test_data, 38, -122)\n    expected_times = [\n        1351738800, 1351749600, 1351760400, 1351771200, 1351782000, 1351792800,\n        1351803600, 1351814400]\n    assert np.allclose(data.index.view(np.int64) // 1000000000, expected_times)\n    expected_aod = np.array([\n        0.39531226, 0.22371339, 0.18373083, 0.15010143, 0.130809, 0.11172834,\n        0.09741255, 0.0921606])\n    expected_tcwv = np.array([\n        26.56172238, 22.75563109, 19.37884304, 16.19186269, 13.31990346,\n        11.65635338, 10.94879802, 10.55725756])\n    assert np.allclose(data.aod550.values, expected_aod)\n    assert np.allclose(data.tcwv.values, expected_tcwv)\n    assert np.allclose(data.precipitable_water.values, expected_tcwv / 10.0)\n    datetimes = (datetime.datetime(2012, 11, 1, 9, 0, 0),\n                 datetime.datetime(2012, 11, 1, 12, 0, 0))\n    data_9am_12pm = ecmwf_macc.read_ecmwf_macc(\n        expected_test_data, 38, -122, datetimes)\n    assert np.allclose(data_9am_12pm.aod550.values, expected_aod[2:4])\n    assert np.allclose(data_9am_12pm.tcwv.values, expected_tcwv[2:4])\n", "tokens": ["pvlib", "tests", "iotools", "test_ecmwf_macc", "py", "def", "test_read_ecmwf_macc", "expected_test_data", "test", "reading", "ecmwf_macc", "data", "from", "netcdf4", "file", "data", "ecmwf_macc", "read_ecmwf_macc", "expected_test_data", "38", "122", "expected_times", "1351738800", "1351749600", "1351760400", "1351771200", "1351782000", "1351792800", "1351803600", "1351814400", "assert", "np", "allclose", "data", "index", "view", "np", "int64", "1000000000", "expected_times", "expected_aod", "np", "array", "0", "39531226", "0", "22371339", "0", "18373083", "0", "15010143", "0", "130809", "0", "11172834", "0", "09741255", "0", "0921606", "expected_tcwv", "np", "array", "26", "56172238", "22", "75563109", "19", "37884304", "16", "19186269", "13", "31990346", "11", "65635338", "10", "94879802", "10", "55725756", "assert", "np", "allclose", "data", "aod550", "values", "expected_aod", "assert", "np", "allclose", "data", "tcwv", "values", "expected_tcwv", "assert", "np", "allclose", "data", "precipitable_water", "values", "expected_tcwv", "10", "0", "datetimes", "datetime", "datetime", "2012", "11", "1", "9", "0", "0", "datetime", "datetime", "2012", "11", "1", "12", "0", "0", "data_9am_12pm", "ecmwf_macc", "read_ecmwf_macc", "expected_test_data", "38", "122", "datetimes", "assert", "np", "allclose", "data_9am_12pm", "aod550", "values", "expected_aod", "2", "4", "assert", "np", "allclose", "data_9am_12pm", "tcwv", "values", "expected_tcwv", "2", "4"], "doc_len": 143}
{"doc_id": "pvlib/tests/iotools/test_ecmwf_macc.py::_create_test_data", "file_path": "pvlib/tests/iotools/test_ecmwf_macc.py", "class_name": null, "func_name": "_create_test_data", "text": "文件路径: pvlib/tests/iotools/test_ecmwf_macc.py\ndef _create_test_data(datafile=DATAFILE, testfile=TESTDATA, start=START,\n                      end=END, resize=RESIZE):  # pragma: no cover\n    \"\"\"\n    Create test data from downloaded data.\n\n    Downloaded data from ECMWF for a single day is 3MB. This creates a subset\n    of the downloaded data that is only 100kb.\n    \"\"\"\n\n    import netCDF4\n\n    if not os.path.exists(datafile):\n        ecmwf_macc.get_ecmwf_macc(datafile, (\"aod550\", \"tcwv\"), start, end)\n\n    data = netCDF4.Dataset(datafile)\n    testdata = netCDF4.Dataset(testfile, 'w', format=\"NETCDF3_64BIT_OFFSET\")\n\n    # attributes\n    testdata.Conventions = data.Conventions\n    testdata.history = \"intentionally blank\"\n\n    # longitude\n    lon_name = 'longitude'\n    lon_test = data.variables[lon_name][::resize]\n    lon_size = lon_test.size\n    lon = testdata.createDimension(lon_name, lon_size)\n    assert not lon.isunlimited()\n    assert lon_test[0] == LON_BND[0]\n    assert (LON_BND[-1] - lon_test[-1]) == (LON_BND[-1] / lon_size)\n    longitudes = testdata.createVariable(lon_name, \"f4\", (lon_name,))\n    longitudes.units = data.variables[lon_name].units\n    longitudes.long_name = lon_name\n    longitudes[:] = lon_test\n\n    # latitude\n    lat_name = 'latitude'\n    lat_test = data.variables[lat_name][::resize]\n    lat = testdata.createDimension(lat_name, lat_test.size)\n    assert not lat.isunlimited()\n    assert lat_test[0] == LAT_BND[0]\n    assert lat_test[-1] == LAT_BND[-1]\n    latitudes = testdata.createVariable(lat_name, \"f4\", (lat_name,))\n    latitudes.units = data.variables[lat_name].units\n    latitudes.long_name = lat_name\n    latitudes[:] = lat_test\n\n    # time\n    time_name = 'time'\n    time_test = data.variables[time_name][:]\n    time = testdata.createDimension(time_name, None)\n    assert time.isunlimited()\n    times = testdata.createVariable(time_name, 'i4', (time_name,))\n    times.units = data.variables[time_name].units\n    times.long_name = time_name\n    times.calendar = data.variables[time_name].calendar\n    times[:] = time_test\n\n    # aod\n    aod_name = 'aod550'\n    aod_vars = data.variables[aod_name]\n    aod_dims = (time_name, lat_name, lon_name)\n    aod_fill_value = getattr(aod_vars, '_FillValue')\n    aods = testdata.createVariable(\n        aod_name, 'i2', aod_dims, fill_value=aod_fill_value)\n    for attr in aod_vars.ncattrs():\n        if attr.startswith('_'):\n            continue\n        setattr(aods, attr, getattr(aod_vars, attr))\n    aods[:] = aod_vars[:, ::resize, ::resize]\n\n    # tcwv\n    tcwv_name = 'tcwv'\n    tcwv_vars = data.variables[tcwv_name]\n    tcwv_dims = (time_name, lat_name, lon_name)\n    tcwv_fill_value = getattr(tcwv_vars, '_FillValue')\n    tcwvs = testdata.createVariable(\n        tcwv_name, 'i2', tcwv_dims, fill_value=tcwv_fill_value)\n    for attr in tcwv_vars.ncattrs():\n        if attr.startswith('_'):\n            continue\n        setattr(tcwvs, attr, getattr(tcwv_vars, attr))\n    tcwvs[:] = tcwv_vars[:, ::resize, ::resize]\n\n    data.close()\n    testdata.close()\n", "tokens": ["pvlib", "tests", "iotools", "test_ecmwf_macc", "py", "def", "_create_test_data", "datafile", "datafile", "testfile", "testdata", "start", "start", "end", "end", "resize", "resize", "pragma", "no", "cover", "create", "test", "data", "from", "downloaded", "data", "downloaded", "data", "from", "ecmwf", "for", "a", "single", "day", "is", "3mb", "this", "creates", "a", "subset", "of", "the", "downloaded", "data", "that", "is", "only", "100kb", "import", "netcdf4", "if", "not", "os", "path", "exists", "datafile", "ecmwf_macc", "get_ecmwf_macc", "datafile", "aod550", "tcwv", "start", "end", "data", "netcdf4", "dataset", "datafile", "testdata", "netcdf4", "dataset", "testfile", "w", "format", "netcdf3_64bit_offset", "attributes", "testdata", "conventions", "data", "conventions", "testdata", "history", "intentionally", "blank", "longitude", "lon_name", "longitude", "lon_test", "data", "variables", "lon_name", "resize", "lon_size", "lon_test", "size", "lon", "testdata", "createdimension", "lon_name", "lon_size", "assert", "not", "lon", "isunlimited", "assert", "lon_test", "0", "lon_bnd", "0", "assert", "lon_bnd", "1", "lon_test", "1", "lon_bnd", "1", "lon_size", "longitudes", "testdata", "createvariable", "lon_name", "f4", "lon_name", "longitudes", "units", "data", "variables", "lon_name", "units", "longitudes", "long_name", "lon_name", "longitudes", "lon_test", "latitude", "lat_name", "latitude", "lat_test", "data", "variables", "lat_name", "resize", "lat", "testdata", "createdimension", "lat_name", "lat_test", "size", "assert", "not", "lat", "isunlimited", "assert", "lat_test", "0", "lat_bnd", "0", "assert", "lat_test", "1", "lat_bnd", "1", "latitudes", "testdata", "createvariable", "lat_name", "f4", "lat_name", "latitudes", "units", "data", "variables", "lat_name", "units", "latitudes", "long_name", "lat_name", "latitudes", "lat_test", "time", "time_name", "time", "time_test", "data", "variables", "time_name", "time", "testdata", "createdimension", "time_name", "none", "assert", "time", "isunlimited", "times", "testdata", "createvariable", "time_name", "i4", "time_name", "times", "units", "data", "variables", "time_name", "units", "times", "long_name", "time_name", "times", "calendar", "data", "variables", "time_name", "calendar", "times", "time_test", "aod", "aod_name", "aod550", "aod_vars", "data", "variables", "aod_name", "aod_dims", "time_name", "lat_name", "lon_name", "aod_fill_value", "getattr", "aod_vars", "_fillvalue", "aods", "testdata", "createvariable", "aod_name", "i2", "aod_dims", "fill_value", "aod_fill_value", "for", "attr", "in", "aod_vars", "ncattrs", "if", "attr", "startswith", "_", "continue", "setattr", "aods", "attr", "getattr", "aod_vars", "attr", "aods", "aod_vars", "resize", "resize", "tcwv", "tcwv_name", "tcwv", "tcwv_vars", "data", "variables", "tcwv_name", "tcwv_dims", "time_name", "lat_name", "lon_name", "tcwv_fill_value", "getattr", "tcwv_vars", "_fillvalue", "tcwvs", "testdata", "createvariable", "tcwv_name", "i2", "tcwv_dims", "fill_value", "tcwv_fill_value", "for", "attr", "in", "tcwv_vars", "ncattrs", "if", "attr", "startswith", "_", "continue", "setattr", "tcwvs", "attr", "getattr", "tcwv_vars", "attr", "tcwvs", "tcwv_vars", "resize", "resize", "data", "close", "testdata", "close"], "doc_len": 306}
{"doc_id": "pvlib/tests/iotools/test_epw.py::test_read_epw", "file_path": "pvlib/tests/iotools/test_epw.py", "class_name": null, "func_name": "test_read_epw", "text": "文件路径: pvlib/tests/iotools/test_epw.py\ndef test_read_epw():\n    epw.read_epw(epw_testfile)\n", "tokens": ["pvlib", "tests", "iotools", "test_epw", "py", "def", "test_read_epw", "epw", "read_epw", "epw_testfile"], "doc_len": 10}
{"doc_id": "pvlib/tests/iotools/test_epw.py::test_read_epw_remote", "file_path": "pvlib/tests/iotools/test_epw.py", "class_name": null, "func_name": "test_read_epw_remote", "text": "文件路径: pvlib/tests/iotools/test_epw.py\ndef test_read_epw_remote():\n    url = 'https://energyplus-weather.s3.amazonaws.com/europe_wmo_region_6/NLD/NLD_Amsterdam.062400_IWEC/NLD_Amsterdam.062400_IWEC.epw'\n    epw.read_epw(url)\n", "tokens": ["pvlib", "tests", "iotools", "test_epw", "py", "def", "test_read_epw_remote", "url", "https", "energyplus", "weather", "s3", "amazonaws", "com", "europe_wmo_region_6", "nld", "nld_amsterdam", "062400_iwec", "nld_amsterdam", "062400_iwec", "epw", "epw", "read_epw", "url"], "doc_len": 24}
{"doc_id": "pvlib/tests/iotools/test_epw.py::test_read_epw_coerce_year", "file_path": "pvlib/tests/iotools/test_epw.py", "class_name": null, "func_name": "test_read_epw_coerce_year", "text": "文件路径: pvlib/tests/iotools/test_epw.py\ndef test_read_epw_coerce_year():\n    coerce_year = 1987\n    data, _ = epw.read_epw(epw_testfile, coerce_year=coerce_year)\n    assert (data.index.year == 1987).all()\n", "tokens": ["pvlib", "tests", "iotools", "test_epw", "py", "def", "test_read_epw_coerce_year", "coerce_year", "1987", "data", "_", "epw", "read_epw", "epw_testfile", "coerce_year", "coerce_year", "assert", "data", "index", "year", "1987", "all"], "doc_len": 22}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_mapping", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_mapping", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_mapping():\n    return {\n        'Direct Normal [W/m^2]': 'dni',\n        'Global PSP [W/m^2]': 'ghi',\n        'Rel Humidity [%]': 'relative_humidity',\n        'Temperature @ 2m [deg C]': 'temp_air',\n        'Non Existant': 'variable',\n    }\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_mapping", "return", "direct", "normal", "w", "m", "2", "dni", "global", "psp", "w", "m", "2", "ghi", "rel", "humidity", "relative_humidity", "temperature", "2m", "deg", "c", "temp_air", "non", "existant", "variable"], "doc_len": 31}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_midc_format_index", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_midc_format_index", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_midc_format_index():\n    data = pd.read_csv(MIDC_TESTFILE)\n    data = midc.format_index(data)\n    start = pd.Timestamp(\"20181014 00:00\")\n    start = start.tz_localize(\"MST\")\n    end = pd.Timestamp(\"20181014 23:59\")\n    end = end.tz_localize(\"MST\")\n    assert type(data.index) == pd.DatetimeIndex\n    assert data.index[0] == start\n    assert data.index[-1] == end\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_midc_format_index", "data", "pd", "read_csv", "midc_testfile", "data", "midc", "format_index", "data", "start", "pd", "timestamp", "20181014", "00", "00", "start", "start", "tz_localize", "mst", "end", "pd", "timestamp", "20181014", "23", "59", "end", "end", "tz_localize", "mst", "assert", "type", "data", "index", "pd", "datetimeindex", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end"], "doc_len": 51}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_midc_format_index_tz_conversion", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_midc_format_index_tz_conversion", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_midc_format_index_tz_conversion():\n    data = pd.read_csv(MIDC_TESTFILE)\n    data = data.rename(columns={'MST': 'PST'})\n    data = midc.format_index(data)\n    assert data.index[0].tz == pytz.timezone('Etc/GMT+8')\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_midc_format_index_tz_conversion", "data", "pd", "read_csv", "midc_testfile", "data", "data", "rename", "columns", "mst", "pst", "data", "midc", "format_index", "data", "assert", "data", "index", "0", "tz", "pytz", "timezone", "etc", "gmt", "8"], "doc_len": 31}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_midc_format_index_raw", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_midc_format_index_raw", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_midc_format_index_raw():\n    data = pd.read_csv(MIDC_RAW_TESTFILE)\n    data = midc.format_index_raw(data)\n    start = pd.Timestamp('20181018 00:00')\n    start = start.tz_localize('MST')\n    end = pd.Timestamp('20181018 23:59')\n    end = end.tz_localize('MST')\n    assert data.index[0] == start\n    assert data.index[-1] == end\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_midc_format_index_raw", "data", "pd", "read_csv", "midc_raw_testfile", "data", "midc", "format_index_raw", "data", "start", "pd", "timestamp", "20181018", "00", "00", "start", "start", "tz_localize", "mst", "end", "pd", "timestamp", "20181018", "23", "59", "end", "end", "tz_localize", "mst", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end"], "doc_len": 45}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_read_midc_var_mapping_as_arg", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_read_midc_var_mapping_as_arg", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_read_midc_var_mapping_as_arg(test_mapping):\n    data = midc.read_midc(MIDC_TESTFILE, variable_map=test_mapping)\n    assert 'ghi' in data.columns\n    assert 'temp_air' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_read_midc_var_mapping_as_arg", "test_mapping", "data", "midc", "read_midc", "midc_testfile", "variable_map", "test_mapping", "assert", "ghi", "in", "data", "columns", "assert", "temp_air", "in", "data", "columns"], "doc_len": 24}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_read_midc_raw_data_from_nrel", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_read_midc_raw_data_from_nrel", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_read_midc_raw_data_from_nrel():\n    start_ts = pd.Timestamp('20181018')\n    end_ts = pd.Timestamp('20181019')\n    var_map = midc.MIDC_VARIABLE_MAP['UAT']\n    data = midc.read_midc_raw_data_from_nrel('UAT', start_ts, end_ts, var_map)\n    for k, v in var_map.items():\n        assert v in data.columns\n    assert data.index.size == 2880\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_read_midc_raw_data_from_nrel", "start_ts", "pd", "timestamp", "20181018", "end_ts", "pd", "timestamp", "20181019", "var_map", "midc", "midc_variable_map", "uat", "data", "midc", "read_midc_raw_data_from_nrel", "uat", "start_ts", "end_ts", "var_map", "for", "k", "v", "in", "var_map", "items", "assert", "v", "in", "data", "columns", "assert", "data", "index", "size", "2880"], "doc_len": 42}
{"doc_id": "pvlib/tests/iotools/test_midc.py::test_read_midc_header_length_mismatch", "file_path": "pvlib/tests/iotools/test_midc.py", "class_name": null, "func_name": "test_read_midc_header_length_mismatch", "text": "文件路径: pvlib/tests/iotools/test_midc.py\ndef test_read_midc_header_length_mismatch(mocker):\n    mock_data = mocker.MagicMock()\n    with MIDC_RAW_SHORT_HEADER_TESTFILE.open() as f:\n        mock_data.text = f.read()\n    mocker.patch('pvlib.iotools.midc.requests.get',\n                 return_value=mock_data)\n    start = pd.Timestamp('2019-11-15T00:00:00-06:00')\n    end = pd.Timestamp('2019-11-15T23:59:00-06:00')\n    data = midc.read_midc_raw_data_from_nrel('', start, end)\n    assert isinstance(data.index, pd.DatetimeIndex)\n    assert data.index[0] == start\n    assert data.index[-1] == end\n", "tokens": ["pvlib", "tests", "iotools", "test_midc", "py", "def", "test_read_midc_header_length_mismatch", "mocker", "mock_data", "mocker", "magicmock", "with", "midc_raw_short_header_testfile", "open", "as", "f", "mock_data", "text", "f", "read", "mocker", "patch", "pvlib", "iotools", "midc", "requests", "get", "return_value", "mock_data", "start", "pd", "timestamp", "2019", "11", "15t00", "00", "00", "06", "00", "end", "pd", "timestamp", "2019", "11", "15t23", "59", "00", "06", "00", "data", "midc", "read_midc_raw_data_from_nrel", "start", "end", "assert", "isinstance", "data", "index", "pd", "datetimeindex", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end"], "doc_len": 70}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::nrel_api_key", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "nrel_api_key", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef nrel_api_key():\n    \"\"\"Supplies pvlib-python's NREL Developer Network API key.\n\n    Azure Pipelines CI utilizes a secret variable set to NREL_API_KEY\n    to mitigate failures associated with using the default key of\n    \"DEMO_KEY\". A user is capable of using their own key this way if\n    desired however the default key should suffice for testing purposes.\n    \"\"\"\n    try:\n        demo_key = os.environ[\"NREL_API_KEY\"]\n    except KeyError:\n        warnings.warn(\n            \"WARNING: NREL API KEY environment variable not set! \"\n            \"Using DEMO_KEY instead. Unexpected failures may occur.\"\n        )\n        demo_key = 'DEMO_KEY'\n    return demo_key\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "nrel_api_key", "supplies", "pvlib", "python", "s", "nrel", "developer", "network", "api", "key", "azure", "pipelines", "ci", "utilizes", "a", "secret", "variable", "set", "to", "nrel_api_key", "to", "mitigate", "failures", "associated", "with", "using", "the", "default", "key", "of", "demo_key", "a", "user", "is", "capable", "of", "using", "their", "own", "key", "this", "way", "if", "desired", "however", "the", "default", "key", "should", "suffice", "for", "testing", "purposes", "try", "demo_key", "os", "environ", "nrel_api_key", "except", "keyerror", "warnings", "warn", "warning", "nrel", "api", "key", "environment", "variable", "not", "set", "using", "demo_key", "instead", "unexpected", "failures", "may", "occur", "demo_key", "demo_key", "return", "demo_key"], "doc_len": 87}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::assert_psm3_equal", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "assert_psm3_equal", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef assert_psm3_equal(data, metadata, expected):\n    \"\"\"check consistency of PSM3 data\"\"\"\n    # check datevec columns\n    assert np.allclose(data.Year, expected.Year)\n    assert np.allclose(data.Month, expected.Month)\n    assert np.allclose(data.Day, expected.Day)\n    assert np.allclose(data.Hour, expected.Hour)\n    assert np.allclose(data.Minute, expected.Minute)\n    # check data columns\n    assert np.allclose(data.GHI, expected.GHI)\n    assert np.allclose(data.DNI, expected.DNI)\n    assert np.allclose(data.DHI, expected.DHI)\n    assert np.allclose(data.Temperature, expected.Temperature)\n    assert np.allclose(data.Pressure, expected.Pressure)\n    assert np.allclose(data['Dew Point'], expected['Dew Point'])\n    assert np.allclose(data['Surface Albedo'], expected['Surface Albedo'])\n    assert np.allclose(data['Wind Speed'], expected['Wind Speed'])\n    assert np.allclose(data['Wind Direction'], expected['Wind Direction'])\n    # check header\n    for mf in METADATA_FIELDS:\n        assert mf in metadata\n    # check timezone\n    assert (data.index.tzinfo.zone == 'Etc/GMT%+d' % -metadata['Time Zone'])\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "assert_psm3_equal", "data", "metadata", "expected", "check", "consistency", "of", "psm3", "data", "check", "datevec", "columns", "assert", "np", "allclose", "data", "year", "expected", "year", "assert", "np", "allclose", "data", "month", "expected", "month", "assert", "np", "allclose", "data", "day", "expected", "day", "assert", "np", "allclose", "data", "hour", "expected", "hour", "assert", "np", "allclose", "data", "minute", "expected", "minute", "check", "data", "columns", "assert", "np", "allclose", "data", "ghi", "expected", "ghi", "assert", "np", "allclose", "data", "dni", "expected", "dni", "assert", "np", "allclose", "data", "dhi", "expected", "dhi", "assert", "np", "allclose", "data", "temperature", "expected", "temperature", "assert", "np", "allclose", "data", "pressure", "expected", "pressure", "assert", "np", "allclose", "data", "dew", "point", "expected", "dew", "point", "assert", "np", "allclose", "data", "surface", "albedo", "expected", "surface", "albedo", "assert", "np", "allclose", "data", "wind", "speed", "expected", "wind", "speed", "assert", "np", "allclose", "data", "wind", "direction", "expected", "wind", "direction", "check", "header", "for", "mf", "in", "metadata_fields", "assert", "mf", "in", "metadata", "check", "timezone", "assert", "data", "index", "tzinfo", "zone", "etc", "gmt", "d", "metadata", "time", "zone"], "doc_len": 150}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_tmy", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_tmy", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_tmy(nrel_api_key):\n    \"\"\"test get_psm3 with a TMY\"\"\"\n    data, metadata = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key,\n                                   PVLIB_EMAIL, names='tmy-2017',\n                                   leap_day=False, map_variables=False)\n    expected = pd.read_csv(TMY_TEST_DATA)\n    assert_psm3_equal(data, metadata, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_tmy", "nrel_api_key", "test", "get_psm3", "with", "a", "tmy", "data", "metadata", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "tmy", "2017", "leap_day", "false", "map_variables", "false", "expected", "pd", "read_csv", "tmy_test_data", "assert_psm3_equal", "data", "metadata", "expected"], "doc_len": 36}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_singleyear", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_singleyear", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_singleyear(nrel_api_key):\n    \"\"\"test get_psm3 with a single year\"\"\"\n    data, metadata = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key,\n                                   PVLIB_EMAIL, names='2017',\n                                   leap_day=False,  map_variables=False,\n                                   interval=30)\n    expected = pd.read_csv(YEAR_TEST_DATA)\n    assert_psm3_equal(data, metadata, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_singleyear", "nrel_api_key", "test", "get_psm3", "with", "a", "single", "year", "data", "metadata", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "2017", "leap_day", "false", "map_variables", "false", "interval", "30", "expected", "pd", "read_csv", "year_test_data", "assert_psm3_equal", "data", "metadata", "expected"], "doc_len": 38}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_5min", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_5min", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_5min(nrel_api_key):\n    \"\"\"test get_psm3 for 5-minute data\"\"\"\n    data, metadata = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key,\n                                   PVLIB_EMAIL, names='2019', interval=5,\n                                   leap_day=False, map_variables=False)\n    assert len(data) == 525600/5\n    first_day = data.loc['2019-01-01']\n    expected = pd.read_csv(YEAR_TEST_DATA_5MIN)\n    assert_psm3_equal(first_day, metadata, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_5min", "nrel_api_key", "test", "get_psm3", "for", "5", "minute", "data", "data", "metadata", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "2019", "interval", "5", "leap_day", "false", "map_variables", "false", "assert", "len", "data", "525600", "5", "first_day", "data", "loc", "2019", "01", "01", "expected", "pd", "read_csv", "year_test_data_5min", "assert_psm3_equal", "first_day", "metadata", "expected"], "doc_len": 49}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_check_leap_day", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_check_leap_day", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_check_leap_day(nrel_api_key):\n    data_2012, _ = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key,\n                                 PVLIB_EMAIL, names=\"2012\", interval=60,\n                                 leap_day=True, map_variables=False)\n    assert len(data_2012) == (8760 + 24)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_check_leap_day", "nrel_api_key", "data_2012", "_", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "2012", "interval", "60", "leap_day", "true", "map_variables", "false", "assert", "len", "data_2012", "8760", "24"], "doc_len": 29}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_tmy_errors", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_tmy_errors", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_tmy_errors(\n    latitude, longitude, api_key, names, interval\n):\n    \"\"\"Test get_psm3() for multiple erroneous input scenarios.\n\n    These scenarios include:\n    * Bad API key -> HTTP 403 forbidden because api_key is rejected\n    * Bad latitude/longitude -> Coordinates were not found in the NSRDB.\n    * Bad name -> Name is not one of the available options.\n    * Bad interval, single year -> Intervals can only be 30 or 60 minutes.\n    \"\"\"\n    with pytest.raises(HTTPError) as excinfo:\n        psm3.get_psm3(latitude, longitude, api_key, PVLIB_EMAIL,\n                      names=names, interval=interval, leap_day=False,\n                      map_variables=False)\n    # ensure the HTTPError caught isn't due to overuse of the API key\n    assert \"OVER_RATE_LIMIT\" not in str(excinfo.value)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_tmy_errors", "latitude", "longitude", "api_key", "names", "interval", "test", "get_psm3", "for", "multiple", "erroneous", "input", "scenarios", "these", "scenarios", "include", "bad", "api", "key", "http", "403", "forbidden", "because", "api_key", "is", "rejected", "bad", "latitude", "longitude", "coordinates", "were", "not", "found", "in", "the", "nsrdb", "bad", "name", "name", "is", "not", "one", "of", "the", "available", "options", "bad", "interval", "single", "year", "intervals", "can", "only", "be", "30", "or", "60", "minutes", "with", "pytest", "raises", "httperror", "as", "excinfo", "psm3", "get_psm3", "latitude", "longitude", "api_key", "pvlib_email", "names", "names", "interval", "interval", "leap_day", "false", "map_variables", "false", "ensure", "the", "httperror", "caught", "isn", "t", "due", "to", "overuse", "of", "the", "api", "key", "assert", "over_rate_limit", "not", "in", "str", "excinfo", "value"], "doc_len": 104}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::io_input", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "io_input", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef io_input(request):\n    \"\"\"file-like object for parse_psm3\"\"\"\n    with MANUAL_TEST_DATA.open() as f:\n        data = f.read()\n    obj = StringIO(data)\n    return obj\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "io_input", "request", "file", "like", "object", "for", "parse_psm3", "with", "manual_test_data", "open", "as", "f", "data", "f", "read", "obj", "stringio", "data", "return", "obj"], "doc_len": 26}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_parse_psm3", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_parse_psm3", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_parse_psm3(io_input):\n    \"\"\"test parse_psm3\"\"\"\n    data, metadata = psm3.parse_psm3(io_input, map_variables=False)\n    expected = pd.read_csv(YEAR_TEST_DATA)\n    assert_psm3_equal(data, metadata, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_parse_psm3", "io_input", "test", "parse_psm3", "data", "metadata", "psm3", "parse_psm3", "io_input", "map_variables", "false", "expected", "pd", "read_csv", "year_test_data", "assert_psm3_equal", "data", "metadata", "expected"], "doc_len": 25}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_read_psm3", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_read_psm3", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_read_psm3():\n    \"\"\"test read_psm3\"\"\"\n    data, metadata = psm3.read_psm3(MANUAL_TEST_DATA, map_variables=False)\n    expected = pd.read_csv(YEAR_TEST_DATA)\n    assert_psm3_equal(data, metadata, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_read_psm3", "test", "read_psm3", "data", "metadata", "psm3", "read_psm3", "manual_test_data", "map_variables", "false", "expected", "pd", "read_csv", "year_test_data", "assert_psm3_equal", "data", "metadata", "expected"], "doc_len": 24}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_read_psm3_map_variables", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_read_psm3_map_variables", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_read_psm3_map_variables():\n    \"\"\"test read_psm3 map_variables=True\"\"\"\n    data, metadata = psm3.read_psm3(MANUAL_TEST_DATA, map_variables=True)\n    columns_mapped = ['Year', 'Month', 'Day', 'Hour', 'Minute', 'dhi', 'dni',\n                      'ghi', 'dhi_clear', 'dni_clear', 'ghi_clear',\n                      'Cloud Type', 'Dew Point', 'solar_zenith',\n                      'Fill Flag', 'albedo', 'wind_speed',\n                      'precipitable_water', 'wind_direction',\n                      'relative_humidity', 'temp_air', 'pressure']\n    data, metadata = psm3.read_psm3(MANUAL_TEST_DATA, map_variables=True)\n    assert_index_equal(data.columns, pd.Index(columns_mapped))\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_read_psm3_map_variables", "test", "read_psm3", "map_variables", "true", "data", "metadata", "psm3", "read_psm3", "manual_test_data", "map_variables", "true", "columns_mapped", "year", "month", "day", "hour", "minute", "dhi", "dni", "ghi", "dhi_clear", "dni_clear", "ghi_clear", "cloud", "type", "dew", "point", "solar_zenith", "fill", "flag", "albedo", "wind_speed", "precipitable_water", "wind_direction", "relative_humidity", "temp_air", "pressure", "data", "metadata", "psm3", "read_psm3", "manual_test_data", "map_variables", "true", "assert_index_equal", "data", "columns", "pd", "index", "columns_mapped"], "doc_len": 57}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_get_psm3_attribute_mapping", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_get_psm3_attribute_mapping", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_get_psm3_attribute_mapping(nrel_api_key):\n    \"\"\"Test that pvlib names can be passed in as attributes and get correctly\n    reverse mapped to PSM3 names\"\"\"\n    data, meta = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key, PVLIB_EMAIL,\n                               names=2019, interval=60,\n                               attributes=['ghi', 'wind_speed'],\n                               leap_day=False, map_variables=True)\n    assert 'ghi' in data.columns\n    assert 'wind_speed' in data.columns\n    assert 'latitude' in meta.keys()\n    assert 'longitude' in meta.keys()\n    assert 'altitude' in meta.keys()\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_get_psm3_attribute_mapping", "nrel_api_key", "test", "that", "pvlib", "names", "can", "be", "passed", "in", "as", "attributes", "and", "get", "correctly", "reverse", "mapped", "to", "psm3", "names", "data", "meta", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "2019", "interval", "60", "attributes", "ghi", "wind_speed", "leap_day", "false", "map_variables", "true", "assert", "ghi", "in", "data", "columns", "assert", "wind_speed", "in", "data", "columns", "assert", "latitude", "in", "meta", "keys", "assert", "longitude", "in", "meta", "keys", "assert", "altitude", "in", "meta", "keys"], "doc_len": 70}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_psm3_variable_map_deprecation_warning", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_psm3_variable_map_deprecation_warning", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_psm3_variable_map_deprecation_warning(nrel_api_key):\n    with pytest.warns(pvlibDeprecationWarning, match='names will be renamed'):\n        _ = psm3.read_psm3(MANUAL_TEST_DATA)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_psm3_variable_map_deprecation_warning", "nrel_api_key", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "names", "will", "be", "renamed", "_", "psm3", "read_psm3", "manual_test_data"], "doc_len": 21}
{"doc_id": "pvlib/tests/iotools/test_psm3.py::test_psm3_leap_day_deprecation_warning", "file_path": "pvlib/tests/iotools/test_psm3.py", "class_name": null, "func_name": "test_psm3_leap_day_deprecation_warning", "text": "文件路径: pvlib/tests/iotools/test_psm3.py\ndef test_psm3_leap_day_deprecation_warning(nrel_api_key):\n    with pytest.warns(pvlibDeprecationWarning,\n                      match='default to leap_day=True'):\n        _, _ = psm3.get_psm3(LATITUDE, LONGITUDE, nrel_api_key, PVLIB_EMAIL,\n                             names=2019, interval=60,\n                             attributes=['ghi', 'wind_speed'],\n                             map_variables=True)\n", "tokens": ["pvlib", "tests", "iotools", "test_psm3", "py", "def", "test_psm3_leap_day_deprecation_warning", "nrel_api_key", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "default", "to", "leap_day", "true", "_", "_", "psm3", "get_psm3", "latitude", "longitude", "nrel_api_key", "pvlib_email", "names", "2019", "interval", "60", "attributes", "ghi", "wind_speed", "map_variables", "true"], "doc_len": 34}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::generate_expected_dataframe", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "generate_expected_dataframe", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef generate_expected_dataframe(values, columns, index):\n    \"\"\"Create dataframe from arrays of values, columns and index, in order to\n    use this dataframe to compare to.\n    \"\"\"\n    expected = pd.DataFrame(index=index, data=values, columns=columns)\n    expected['Int'] = expected['Int'].astype(int)\n    expected.index.name = 'time'\n    expected.index.freq = None\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "generate_expected_dataframe", "values", "columns", "index", "create", "dataframe", "from", "arrays", "of", "values", "columns", "and", "index", "in", "order", "to", "use", "this", "dataframe", "to", "compare", "to", "expected", "pd", "dataframe", "index", "index", "data", "values", "columns", "columns", "expected", "int", "expected", "int", "astype", "int", "expected", "index", "name", "time", "expected", "index", "freq", "none", "return", "expected"], "doc_len": 53}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::expected_radiation_csv", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "expected_radiation_csv", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef expected_radiation_csv():\n    expected = generate_expected_dataframe(\n        data_radiation_csv, columns_radiation_csv, index_radiation_csv)\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "expected_radiation_csv", "expected", "generate_expected_dataframe", "data_radiation_csv", "columns_radiation_csv", "index_radiation_csv", "return", "expected"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::expected_radiation_csv_mapped", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "expected_radiation_csv_mapped", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef expected_radiation_csv_mapped():\n    expected = generate_expected_dataframe(\n        data_radiation_csv, columns_radiation_csv_mapped, index_radiation_csv)\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "expected_radiation_csv_mapped", "expected", "generate_expected_dataframe", "data_radiation_csv", "columns_radiation_csv_mapped", "index_radiation_csv", "return", "expected"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::expected_pv_json", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "expected_pv_json", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef expected_pv_json():\n    expected = generate_expected_dataframe(\n        data_pv_json, columns_pv_json, index_pv_json)\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "expected_pv_json", "expected", "generate_expected_dataframe", "data_pv_json", "columns_pv_json", "index_pv_json", "return", "expected"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::expected_pv_json_mapped", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "expected_pv_json_mapped", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef expected_pv_json_mapped():\n    expected = generate_expected_dataframe(\n        data_pv_json, columns_pv_json_mapped, index_pv_json)\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "expected_pv_json_mapped", "expected", "generate_expected_dataframe", "data_pv_json", "columns_pv_json_mapped", "index_pv_json", "return", "expected"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_hourly", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_hourly", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_hourly(testfile, expected_name, metadata_exp,\n                           inputs_exp, map_variables, pvgis_format, request):\n    # Get expected dataframe from fixture\n    expected = request.getfixturevalue(expected_name)\n    # Read data from file\n    out, inputs, metadata = read_pvgis_hourly(\n        testfile, map_variables=map_variables, pvgis_format=pvgis_format)\n    # Assert whether dataframe, metadata, and inputs are as expected\n    assert_frame_equal(out, expected)\n    assert inputs == inputs_exp\n    assert metadata == metadata_exp\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_hourly", "testfile", "expected_name", "metadata_exp", "inputs_exp", "map_variables", "pvgis_format", "request", "get", "expected", "dataframe", "from", "fixture", "expected", "request", "getfixturevalue", "expected_name", "read", "data", "from", "file", "out", "inputs", "metadata", "read_pvgis_hourly", "testfile", "map_variables", "map_variables", "pvgis_format", "pvgis_format", "assert", "whether", "dataframe", "metadata", "and", "inputs", "are", "as", "expected", "assert_frame_equal", "out", "expected", "assert", "inputs", "inputs_exp", "assert", "metadata", "metadata_exp"], "doc_len": 54}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_hourly_bad_extension", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_hourly_bad_extension", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_hourly_bad_extension():\n    # Test if ValueError is raised if file extension cannot be recognized and\n    # pvgis_format is not specified\n    with pytest.raises(ValueError, match=\"pvgis format 'txt' was unknown\"):\n        read_pvgis_hourly('filename.txt')\n    # Test if ValueError is raised if an unkonwn pvgis_format is specified\n    with pytest.raises(ValueError, match=\"pvgis format 'txt' was unknown\"):\n        read_pvgis_hourly(testfile_pv_json, pvgis_format='txt')\n    # Test if TypeError is raised if input is a buffer and pvgis_format=None\n    with pytest.raises(TypeError, match=\"expected str, bytes or os.PathLike\"):\n        read_pvgis_hourly(io.StringIO())\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_hourly_bad_extension", "test", "if", "valueerror", "is", "raised", "if", "file", "extension", "cannot", "be", "recognized", "and", "pvgis_format", "is", "not", "specified", "with", "pytest", "raises", "valueerror", "match", "pvgis", "format", "txt", "was", "unknown", "read_pvgis_hourly", "filename", "txt", "test", "if", "valueerror", "is", "raised", "if", "an", "unkonwn", "pvgis_format", "is", "specified", "with", "pytest", "raises", "valueerror", "match", "pvgis", "format", "txt", "was", "unknown", "read_pvgis_hourly", "testfile_pv_json", "pvgis_format", "txt", "test", "if", "typeerror", "is", "raised", "if", "input", "is", "a", "buffer", "and", "pvgis_format", "none", "with", "pytest", "raises", "typeerror", "match", "expected", "str", "bytes", "or", "os", "pathlike", "read_pvgis_hourly", "io", "stringio"], "doc_len": 88}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_hourly", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_hourly", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_hourly(requests_mock, testfile, expected_name, args,\n                          map_variables, url_test, request):\n    \"\"\"Test that get_pvgis_hourly generates the correct URI request and that\n    _parse_pvgis_hourly_json and _parse_pvgis_hourly_csv is called correctly\"\"\"\n    # Open local test file containing McClear monthly data\n    with open(testfile, 'r') as test_file:\n        mock_response = test_file.read()\n    # Specify the full URI of a specific example, this ensures that all of the\n    # inputs are passing on correctly\n    requests_mock.get(url_test, text=mock_response)\n    # Make API call - an error is raised if requested URI does not match\n    out, inputs, metadata = get_pvgis_hourly(\n        latitude=45, longitude=8, map_variables=map_variables, **args)\n    # Get expected dataframe from fixture\n    expected = request.getfixturevalue(expected_name)\n    # Compare out and expected dataframes\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_hourly", "requests_mock", "testfile", "expected_name", "args", "map_variables", "url_test", "request", "test", "that", "get_pvgis_hourly", "generates", "the", "correct", "uri", "request", "and", "that", "_parse_pvgis_hourly_json", "and", "_parse_pvgis_hourly_csv", "is", "called", "correctly", "open", "local", "test", "file", "containing", "mcclear", "monthly", "data", "with", "open", "testfile", "r", "as", "test_file", "mock_response", "test_file", "read", "specify", "the", "full", "uri", "of", "a", "specific", "example", "this", "ensures", "that", "all", "of", "the", "inputs", "are", "passing", "on", "correctly", "requests_mock", "get", "url_test", "text", "mock_response", "make", "api", "call", "an", "error", "is", "raised", "if", "requested", "uri", "does", "not", "match", "out", "inputs", "metadata", "get_pvgis_hourly", "latitude", "45", "longitude", "8", "map_variables", "map_variables", "args", "get", "expected", "dataframe", "from", "fixture", "expected", "request", "getfixturevalue", "expected_name", "compare", "out", "and", "expected", "dataframes", "assert_frame_equal", "out", "expected"], "doc_len": 112}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_hourly_bad_status_code", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_hourly_bad_status_code", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_hourly_bad_status_code(requests_mock):\n    # Test if a HTTPError is raised if a bad request is returned\n    requests_mock.get(url_pv_json, status_code=400)\n    with pytest.raises(requests.HTTPError):\n        get_pvgis_hourly(latitude=45, longitude=8, **args_pv_json)\n    # Test if HTTPError is raised and error message is returned if avaiable\n    requests_mock.get(url_pv_json, status_code=400,\n                      json={'message': 'peakpower Mandatory'})\n    with pytest.raises(requests.HTTPError):\n        get_pvgis_hourly(latitude=45, longitude=8, **args_pv_json)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_hourly_bad_status_code", "requests_mock", "test", "if", "a", "httperror", "is", "raised", "if", "a", "bad", "request", "is", "returned", "requests_mock", "get", "url_pv_json", "status_code", "400", "with", "pytest", "raises", "requests", "httperror", "get_pvgis_hourly", "latitude", "45", "longitude", "8", "args_pv_json", "test", "if", "httperror", "is", "raised", "and", "error", "message", "is", "returned", "if", "avaiable", "requests_mock", "get", "url_pv_json", "status_code", "400", "json", "message", "peakpower", "mandatory", "with", "pytest", "raises", "requests", "httperror", "get_pvgis_hourly", "latitude", "45", "longitude", "8", "args_pv_json"], "doc_len": 68}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_hourly_bad_outputformat", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_hourly_bad_outputformat", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_hourly_bad_outputformat(requests_mock):\n    # Test if a ValueError is raised if an unsupported outputformat is used\n    # E.g. 'basic' is a valid PVGIS format, but is not supported by pvlib\n    requests_mock.get(url_bad_outputformat)\n    with pytest.raises(ValueError):\n        get_pvgis_hourly(latitude=45, longitude=8, outputformat='basic')\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_hourly_bad_outputformat", "requests_mock", "test", "if", "a", "valueerror", "is", "raised", "if", "an", "unsupported", "outputformat", "is", "used", "e", "g", "basic", "is", "a", "valid", "pvgis", "format", "but", "is", "not", "supported", "by", "pvlib", "requests_mock", "get", "url_bad_outputformat", "with", "pytest", "raises", "valueerror", "get_pvgis_hourly", "latitude", "45", "longitude", "8", "outputformat", "basic"], "doc_len": 48}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_hourly_additional_inputs", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_hourly_additional_inputs", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_hourly_additional_inputs(requests_mock):\n    # Test additional inputs, including userhorizons\n    # Necessary to pass a test file in order for the parser not to fail\n    with open(testfile_radiation_csv, 'r') as test_file:\n        mock_response = test_file.read()\n    requests_mock.get(url_additional_inputs, text=mock_response)\n    # Make request with userhorizon specified\n    # Test passes if the request made by get_pvgis_hourly matches exactly the\n    # url passed to the mock request (url_additional_inputs)\n    get_pvgis_hourly(\n        latitude=55.6814, longitude=12.5758, outputformat='csv',\n        usehorizon=True, userhorizon=[10, 15, 20, 10], pvcalculation=True,\n        peakpower=5, loss=2, trackingtype=0, components=True,\n        optimalangles=True)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_hourly_additional_inputs", "requests_mock", "test", "additional", "inputs", "including", "userhorizons", "necessary", "to", "pass", "a", "test", "file", "in", "order", "for", "the", "parser", "not", "to", "fail", "with", "open", "testfile_radiation_csv", "r", "as", "test_file", "mock_response", "test_file", "read", "requests_mock", "get", "url_additional_inputs", "text", "mock_response", "make", "request", "with", "userhorizon", "specified", "test", "passes", "if", "the", "request", "made", "by", "get_pvgis_hourly", "matches", "exactly", "the", "url", "passed", "to", "the", "mock", "request", "url_additional_inputs", "get_pvgis_hourly", "latitude", "55", "6814", "longitude", "12", "5758", "outputformat", "csv", "usehorizon", "true", "userhorizon", "10", "15", "20", "10", "pvcalculation", "true", "peakpower", "5", "loss", "2", "trackingtype", "0", "components", "true", "optimalangles", "true"], "doc_len": 92}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_hourly_empty_file", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_hourly_empty_file", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_hourly_empty_file():\n    # Check if a IOError is raised if file does not contain a data section\n    with pytest.raises(ValueError, match='No data section'):\n        read_pvgis_hourly(\n            io.StringIO('1:1\\n2:2\\n3:3\\n4:4\\n5:5\\n'),\n            pvgis_format='csv')\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_hourly_empty_file", "check", "if", "a", "ioerror", "is", "raised", "if", "file", "does", "not", "contain", "a", "data", "section", "with", "pytest", "raises", "valueerror", "match", "no", "data", "section", "read_pvgis_hourly", "io", "stringio", "1", "1", "n2", "2", "n3", "3", "n4", "4", "n5", "5", "n", "pvgis_format", "csv"], "doc_len": 45}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::expected", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "expected", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef expected():\n    return pd.read_csv(DATA_DIR / 'pvgis_tmy_test.dat', index_col='time(UTC)')\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "expected", "return", "pd", "read_csv", "data_dir", "pvgis_tmy_test", "dat", "index_col", "time", "utc"], "doc_len": 16}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::userhorizon_expected", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "userhorizon_expected", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef userhorizon_expected():\n    return pd.read_json(DATA_DIR / 'tmy_45.000_8.000_userhorizon.json')\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "userhorizon_expected", "return", "pd", "read_json", "data_dir", "tmy_45", "000_8", "000_userhorizon", "json"], "doc_len": 15}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::month_year_expected", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "month_year_expected", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef month_year_expected():\n    return [\n        2009, 2012, 2014, 2010, 2011, 2013, 2011, 2011, 2013, 2013, 2013, 2011]\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "month_year_expected", "return", "2009", "2012", "2014", "2010", "2011", "2013", "2011", "2011", "2013", "2013", "2013", "2011"], "doc_len": 20}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::inputs_expected", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "inputs_expected", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef inputs_expected():\n    return {\n        'location': {'latitude': 45.0, 'longitude': 8.0, 'elevation': 250.0},\n        'meteo_data': {\n            'radiation_db': 'PVGIS-SARAH',\n            'meteo_db': 'ERA-Interim',\n            'year_min': 2005,\n            'year_max': 2016,\n            'use_horizon': True,\n            'horizon_db': 'DEM-calculated'}}\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "inputs_expected", "return", "location", "latitude", "45", "0", "longitude", "8", "0", "elevation", "250", "0", "meteo_data", "radiation_db", "pvgis", "sarah", "meteo_db", "era", "interim", "year_min", "2005", "year_max", "2016", "use_horizon", "true", "horizon_db", "dem", "calculated"], "doc_len": 34}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::epw_meta", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "epw_meta", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef epw_meta():\n    return {\n        'loc': 'LOCATION',\n        'city': 'unknown',\n        'state-prov': '-',\n        'country': 'unknown',\n        'data_type': 'ECMWF/ERA',\n        'WMO_code': 'unknown',\n        'latitude': 45.0,\n        'longitude': 8.0,\n        'TZ': 1.0,\n        'altitude': 250.0}\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "epw_meta", "return", "loc", "location", "city", "unknown", "state", "prov", "country", "unknown", "data_type", "ecmwf", "era", "wmo_code", "unknown", "latitude", "45", "0", "longitude", "8", "0", "tz", "1", "0", "altitude", "250", "0"], "doc_len": 33}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::meta_expected", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "meta_expected", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef meta_expected():\n    with (DATA_DIR / 'pvgis_tmy_meta.json').open() as f:\n        return json.load(f)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "meta_expected", "with", "data_dir", "pvgis_tmy_meta", "json", "open", "as", "f", "return", "json", "load", "f"], "doc_len": 18}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::csv_meta", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "csv_meta", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef csv_meta(meta_expected):\n    return [\n        f\"{k}: {v['description']} ({v['units']})\" for k, v\n        in meta_expected['outputs']['tmy_hourly']['variables'].items()]\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "csv_meta", "meta_expected", "return", "f", "k", "v", "description", "v", "units", "for", "k", "v", "in", "meta_expected", "outputs", "tmy_hourly", "variables", "items"], "doc_len": 24}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::pvgis_tmy_mapped_columns", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "pvgis_tmy_mapped_columns", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef pvgis_tmy_mapped_columns():\n    return ['temp_air', 'relative_humidity', 'ghi', 'dni', 'dhi', 'IR(h)',\n            'wind_speed', 'wind_direction', 'pressure']\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "pvgis_tmy_mapped_columns", "return", "temp_air", "relative_humidity", "ghi", "dni", "dhi", "ir", "h", "wind_speed", "wind_direction", "pressure"], "doc_len": 18}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_pvgis_tmy_variable_map_deprecating_warning_0_10", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_pvgis_tmy_variable_map_deprecating_warning_0_10", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_pvgis_tmy_variable_map_deprecating_warning_0_10():\n    with pytest.warns(pvlibDeprecationWarning, match='names will be renamed'):\n        _ = get_pvgis_tmy(45, 8)\n    with pytest.warns(pvlibDeprecationWarning, match='names will be renamed'):\n        fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.epw'\n        _ = read_pvgis_tmy(fn)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_pvgis_tmy_variable_map_deprecating_warning_0_10", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "names", "will", "be", "renamed", "_", "get_pvgis_tmy", "45", "8", "with", "pytest", "warns", "pvlibdeprecationwarning", "match", "names", "will", "be", "renamed", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "epw", "_", "read_pvgis_tmy", "fn"], "doc_len": 38}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy(expected, month_year_expected, inputs_expected,\n                       meta_expected):\n    pvgis_data = get_pvgis_tmy(45, 8, map_variables=False)\n    _compare_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                            meta_expected, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data", "get_pvgis_tmy", "45", "8", "map_variables", "false", "_compare_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data"], "doc_len": 23}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::_compare_pvgis_tmy_json", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "_compare_pvgis_tmy_json", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef _compare_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                            meta_expected, pvgis_data):\n    data, months_selected, inputs, meta = pvgis_data\n    # check each column of output separately\n    for outvar in meta_expected['outputs']['tmy_hourly']['variables'].keys():\n        assert np.allclose(data[outvar], expected[outvar])\n    assert np.allclose(\n        [_['month'] for _ in months_selected], np.arange(1, 13, 1))\n    assert np.allclose(\n        [_['year'] for _ in months_selected], month_year_expected)\n    inputs_loc = inputs['location']\n    assert inputs_loc['latitude'] == inputs_expected['location']['latitude']\n    assert inputs_loc['longitude'] == inputs_expected['location']['longitude']\n    assert inputs_loc['elevation'] == inputs_expected['location']['elevation']\n    inputs_met_data = inputs['meteo_data']\n    expected_met_data = inputs_expected['meteo_data']\n    assert (\n        inputs_met_data['radiation_db'] == expected_met_data['radiation_db'])\n    assert inputs_met_data['year_min'] == expected_met_data['year_min']\n    assert inputs_met_data['year_max'] == expected_met_data['year_max']\n    assert inputs_met_data['use_horizon'] == expected_met_data['use_horizon']\n    assert inputs_met_data['horizon_db'] == expected_met_data['horizon_db']\n    assert meta == meta_expected\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "_compare_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data", "data", "months_selected", "inputs", "meta", "pvgis_data", "check", "each", "column", "of", "output", "separately", "for", "outvar", "in", "meta_expected", "outputs", "tmy_hourly", "variables", "keys", "assert", "np", "allclose", "data", "outvar", "expected", "outvar", "assert", "np", "allclose", "_", "month", "for", "_", "in", "months_selected", "np", "arange", "1", "13", "1", "assert", "np", "allclose", "_", "year", "for", "_", "in", "months_selected", "month_year_expected", "inputs_loc", "inputs", "location", "assert", "inputs_loc", "latitude", "inputs_expected", "location", "latitude", "assert", "inputs_loc", "longitude", "inputs_expected", "location", "longitude", "assert", "inputs_loc", "elevation", "inputs_expected", "location", "elevation", "inputs_met_data", "inputs", "meteo_data", "expected_met_data", "inputs_expected", "meteo_data", "assert", "inputs_met_data", "radiation_db", "expected_met_data", "radiation_db", "assert", "inputs_met_data", "year_min", "expected_met_data", "year_min", "assert", "inputs_met_data", "year_max", "expected_met_data", "year_max", "assert", "inputs_met_data", "use_horizon", "expected_met_data", "use_horizon", "assert", "inputs_met_data", "horizon_db", "expected_met_data", "horizon_db", "assert", "meta", "meta_expected"], "doc_len": 117}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy_kwargs", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy_kwargs", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy_kwargs(userhorizon_expected):\n    _, _, inputs, _ = get_pvgis_tmy(45, 8, usehorizon=False,\n                                    map_variables=False)\n    assert inputs['meteo_data']['use_horizon'] is False\n    data, _, _, _ = get_pvgis_tmy(\n        45, 8, userhorizon=[0, 10, 20, 30, 40, 15, 25, 5], map_variables=False)\n    assert np.allclose(\n        data['G(h)'], userhorizon_expected['G(h)'].values)\n    assert np.allclose(\n        data['Gb(n)'], userhorizon_expected['Gb(n)'].values)\n    assert np.allclose(\n        data['Gd(h)'], userhorizon_expected['Gd(h)'].values)\n    _, _, inputs, _ = get_pvgis_tmy(45, 8, startyear=2005, map_variables=False)\n    assert inputs['meteo_data']['year_min'] == 2005\n    _, _, inputs, _ = get_pvgis_tmy(45, 8, endyear=2016, map_variables=False)\n    assert inputs['meteo_data']['year_max'] == 2016\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy_kwargs", "userhorizon_expected", "_", "_", "inputs", "_", "get_pvgis_tmy", "45", "8", "usehorizon", "false", "map_variables", "false", "assert", "inputs", "meteo_data", "use_horizon", "is", "false", "data", "_", "_", "_", "get_pvgis_tmy", "45", "8", "userhorizon", "0", "10", "20", "30", "40", "15", "25", "5", "map_variables", "false", "assert", "np", "allclose", "data", "g", "h", "userhorizon_expected", "g", "h", "values", "assert", "np", "allclose", "data", "gb", "n", "userhorizon_expected", "gb", "n", "values", "assert", "np", "allclose", "data", "gd", "h", "userhorizon_expected", "gd", "h", "values", "_", "_", "inputs", "_", "get_pvgis_tmy", "45", "8", "startyear", "2005", "map_variables", "false", "assert", "inputs", "meteo_data", "year_min", "2005", "_", "_", "inputs", "_", "get_pvgis_tmy", "45", "8", "endyear", "2016", "map_variables", "false", "assert", "inputs", "meteo_data", "year_max", "2016"], "doc_len": 105}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy_basic", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy_basic", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy_basic(expected, meta_expected):\n    pvgis_data = get_pvgis_tmy(45, 8, outputformat='basic',\n                               map_variables=False)\n    _compare_pvgis_tmy_basic(expected, meta_expected, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy_basic", "expected", "meta_expected", "pvgis_data", "get_pvgis_tmy", "45", "8", "outputformat", "basic", "map_variables", "false", "_compare_pvgis_tmy_basic", "expected", "meta_expected", "pvgis_data"], "doc_len": 21}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::_compare_pvgis_tmy_basic", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "_compare_pvgis_tmy_basic", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef _compare_pvgis_tmy_basic(expected, meta_expected, pvgis_data):\n    data, _, _, _ = pvgis_data\n    # check each column of output separately\n    for outvar in meta_expected['outputs']['tmy_hourly']['variables'].keys():\n        assert np.allclose(data[outvar], expected[outvar])\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "_compare_pvgis_tmy_basic", "expected", "meta_expected", "pvgis_data", "data", "_", "_", "_", "pvgis_data", "check", "each", "column", "of", "output", "separately", "for", "outvar", "in", "meta_expected", "outputs", "tmy_hourly", "variables", "keys", "assert", "np", "allclose", "data", "outvar", "expected", "outvar"], "doc_len": 36}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy_csv", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy_csv", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                           meta_expected, csv_meta):\n    pvgis_data = get_pvgis_tmy(45, 8, outputformat='csv', map_variables=False)\n    _compare_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                           meta_expected, csv_meta, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data", "get_pvgis_tmy", "45", "8", "outputformat", "csv", "map_variables", "false", "_compare_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data"], "doc_len": 27}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::_compare_pvgis_tmy_csv", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "_compare_pvgis_tmy_csv", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef _compare_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                           meta_expected, csv_meta, pvgis_data):\n    data, months_selected, inputs, meta = pvgis_data\n    # check each column of output separately\n    for outvar in meta_expected['outputs']['tmy_hourly']['variables'].keys():\n        assert np.allclose(data[outvar], expected[outvar])\n    assert np.allclose(\n        [_['month'] for _ in months_selected], np.arange(1, 13, 1))\n    assert np.allclose(\n        [_['year'] for _ in months_selected], month_year_expected)\n    assert inputs['latitude'] == inputs_expected['location']['latitude']\n    assert inputs['longitude'] == inputs_expected['location']['longitude']\n    assert inputs['elevation'] == inputs_expected['location']['elevation']\n    for meta_value in meta:\n        if not meta_value:\n            continue\n        # this copyright text tends to change (copyright year range increments\n        # annually, e.g.), so just check the beginning of it:\n        if meta_value.startswith('PVGIS (c) European'):\n            continue\n        assert meta_value in csv_meta\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "_compare_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data", "data", "months_selected", "inputs", "meta", "pvgis_data", "check", "each", "column", "of", "output", "separately", "for", "outvar", "in", "meta_expected", "outputs", "tmy_hourly", "variables", "keys", "assert", "np", "allclose", "data", "outvar", "expected", "outvar", "assert", "np", "allclose", "_", "month", "for", "_", "in", "months_selected", "np", "arange", "1", "13", "1", "assert", "np", "allclose", "_", "year", "for", "_", "in", "months_selected", "month_year_expected", "assert", "inputs", "latitude", "inputs_expected", "location", "latitude", "assert", "inputs", "longitude", "inputs_expected", "location", "longitude", "assert", "inputs", "elevation", "inputs_expected", "location", "elevation", "for", "meta_value", "in", "meta", "if", "not", "meta_value", "continue", "this", "copyright", "text", "tends", "to", "change", "copyright", "year", "range", "increments", "annually", "e", "g", "so", "just", "check", "the", "beginning", "of", "it", "if", "meta_value", "startswith", "pvgis", "c", "european", "continue", "assert", "meta_value", "in", "csv_meta"], "doc_len": 120}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy_epw", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy_epw", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy_epw(expected, epw_meta):\n    pvgis_data = get_pvgis_tmy(45, 8, outputformat='epw', map_variables=False)\n    _compare_pvgis_tmy_epw(expected, epw_meta, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data", "get_pvgis_tmy", "45", "8", "outputformat", "epw", "map_variables", "false", "_compare_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data"], "doc_len": 21}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::_compare_pvgis_tmy_epw", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "_compare_pvgis_tmy_epw", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef _compare_pvgis_tmy_epw(expected, epw_meta, pvgis_data):\n    data, _, _, meta = pvgis_data\n    assert np.allclose(data.ghi, expected['G(h)'])\n    assert np.allclose(data.dni, expected['Gb(n)'])\n    assert np.allclose(data.dhi, expected['Gd(h)'])\n    assert np.allclose(data.temp_air, expected['T2m'])\n    assert meta == epw_meta\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "_compare_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data", "data", "_", "_", "meta", "pvgis_data", "assert", "np", "allclose", "data", "ghi", "expected", "g", "h", "assert", "np", "allclose", "data", "dni", "expected", "gb", "n", "assert", "np", "allclose", "data", "dhi", "expected", "gd", "h", "assert", "np", "allclose", "data", "temp_air", "expected", "t2m", "assert", "meta", "epw_meta"], "doc_len": 49}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_tmy_error", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_tmy_error", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_tmy_error():\n    err_msg = 'outputformat: Incorrect value.'\n    with pytest.raises(requests.HTTPError, match=err_msg):\n        get_pvgis_tmy(45, 8, outputformat='bad')\n    with pytest.raises(requests.HTTPError, match='404 Client Error'):\n        get_pvgis_tmy(45, 8, url='https://re.jrc.ec.europa.eu/')\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_tmy_error", "err_msg", "outputformat", "incorrect", "value", "with", "pytest", "raises", "requests", "httperror", "match", "err_msg", "get_pvgis_tmy", "45", "8", "outputformat", "bad", "with", "pytest", "raises", "requests", "httperror", "match", "404", "client", "error", "get_pvgis_tmy", "45", "8", "url", "https", "re", "jrc", "ec", "europa", "eu"], "doc_len": 42}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_get_pvgis_map_variables", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_get_pvgis_map_variables", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_get_pvgis_map_variables(pvgis_tmy_mapped_columns):\n    actual, _, _, _ = get_pvgis_tmy(45, 8, map_variables=True)\n    assert all([c in pvgis_tmy_mapped_columns for c in actual.columns])\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_get_pvgis_map_variables", "pvgis_tmy_mapped_columns", "actual", "_", "_", "_", "get_pvgis_tmy", "45", "8", "map_variables", "true", "assert", "all", "c", "in", "pvgis_tmy_mapped_columns", "for", "c", "in", "actual", "columns"], "doc_len": 27}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_map_variables", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_map_variables", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_map_variables(pvgis_tmy_mapped_columns):\n    fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.json'\n    actual, _, _, _ = read_pvgis_tmy(fn, map_variables=True)\n    assert all([c in pvgis_tmy_mapped_columns for c in actual.columns])\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_map_variables", "pvgis_tmy_mapped_columns", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "json", "actual", "_", "_", "_", "read_pvgis_tmy", "fn", "map_variables", "true", "assert", "all", "c", "in", "pvgis_tmy_mapped_columns", "for", "c", "in", "actual", "columns"], "doc_len": 32}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_json", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_json", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                             meta_expected):\n    fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.json'\n    # infer outputformat from file extensions\n    pvgis_data = read_pvgis_tmy(fn, map_variables=False)\n    _compare_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                            meta_expected, pvgis_data)\n    # explicit pvgis outputformat\n    pvgis_data = read_pvgis_tmy(fn, pvgis_format='json', map_variables=False)\n    _compare_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                            meta_expected, pvgis_data)\n    with fn.open('r') as fbuf:\n        pvgis_data = read_pvgis_tmy(fbuf, pvgis_format='json',\n                                    map_variables=False)\n        _compare_pvgis_tmy_json(expected, month_year_expected, inputs_expected,\n                                meta_expected, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "json", "infer", "outputformat", "from", "file", "extensions", "pvgis_data", "read_pvgis_tmy", "fn", "map_variables", "false", "_compare_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data", "explicit", "pvgis", "outputformat", "pvgis_data", "read_pvgis_tmy", "fn", "pvgis_format", "json", "map_variables", "false", "_compare_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data", "with", "fn", "open", "r", "as", "fbuf", "pvgis_data", "read_pvgis_tmy", "fbuf", "pvgis_format", "json", "map_variables", "false", "_compare_pvgis_tmy_json", "expected", "month_year_expected", "inputs_expected", "meta_expected", "pvgis_data"], "doc_len": 68}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_epw", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_epw", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_epw(expected, epw_meta):\n    fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.epw'\n    # infer outputformat from file extensions\n    pvgis_data = read_pvgis_tmy(fn, map_variables=False)\n    _compare_pvgis_tmy_epw(expected, epw_meta, pvgis_data)\n    # explicit pvgis outputformat\n    pvgis_data = read_pvgis_tmy(fn, pvgis_format='epw', map_variables=False)\n    _compare_pvgis_tmy_epw(expected, epw_meta, pvgis_data)\n    with fn.open('r') as fbuf:\n        pvgis_data = read_pvgis_tmy(fbuf, pvgis_format='epw',\n                                    map_variables=False)\n        _compare_pvgis_tmy_epw(expected, epw_meta, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_epw", "expected", "epw_meta", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "epw", "infer", "outputformat", "from", "file", "extensions", "pvgis_data", "read_pvgis_tmy", "fn", "map_variables", "false", "_compare_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data", "explicit", "pvgis", "outputformat", "pvgis_data", "read_pvgis_tmy", "fn", "pvgis_format", "epw", "map_variables", "false", "_compare_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data", "with", "fn", "open", "r", "as", "fbuf", "pvgis_data", "read_pvgis_tmy", "fbuf", "pvgis_format", "epw", "map_variables", "false", "_compare_pvgis_tmy_epw", "expected", "epw_meta", "pvgis_data"], "doc_len": 60}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_csv", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_csv", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                            meta_expected, csv_meta):\n    fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.csv'\n    # infer outputformat from file extensions\n    pvgis_data = read_pvgis_tmy(fn, map_variables=False)\n    _compare_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                           meta_expected, csv_meta, pvgis_data)\n    # explicit pvgis outputformat\n    pvgis_data = read_pvgis_tmy(fn, pvgis_format='csv', map_variables=False)\n    _compare_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                           meta_expected, csv_meta, pvgis_data)\n    with fn.open('rb') as fbuf:\n        pvgis_data = read_pvgis_tmy(fbuf, pvgis_format='csv',\n                                    map_variables=False)\n        _compare_pvgis_tmy_csv(expected, month_year_expected, inputs_expected,\n                               meta_expected, csv_meta, pvgis_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "csv", "infer", "outputformat", "from", "file", "extensions", "pvgis_data", "read_pvgis_tmy", "fn", "map_variables", "false", "_compare_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data", "explicit", "pvgis", "outputformat", "pvgis_data", "read_pvgis_tmy", "fn", "pvgis_format", "csv", "map_variables", "false", "_compare_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data", "with", "fn", "open", "rb", "as", "fbuf", "pvgis_data", "read_pvgis_tmy", "fbuf", "pvgis_format", "csv", "map_variables", "false", "_compare_pvgis_tmy_csv", "expected", "month_year_expected", "inputs_expected", "meta_expected", "csv_meta", "pvgis_data"], "doc_len": 72}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_basic", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_basic", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_basic(expected, meta_expected):\n    fn = DATA_DIR / 'tmy_45.000_8.000_2005_2016.txt'\n    # XXX: can't infer outputformat from file extensions for basic\n    with pytest.raises(ValueError, match=\"pvgis format 'txt' was unknown\"):\n        read_pvgis_tmy(fn, map_variables=False)\n    # explicit pvgis outputformat\n    pvgis_data = read_pvgis_tmy(fn, pvgis_format='basic', map_variables=False)\n    _compare_pvgis_tmy_basic(expected, meta_expected, pvgis_data)\n    with fn.open('rb') as fbuf:\n        pvgis_data = read_pvgis_tmy(fbuf, pvgis_format='basic',\n                                    map_variables=False)\n        _compare_pvgis_tmy_basic(expected, meta_expected, pvgis_data)\n        # file buffer raises TypeError if passed to pathlib.Path()\n        with pytest.raises(TypeError):\n            read_pvgis_tmy(fbuf, map_variables=False)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_basic", "expected", "meta_expected", "fn", "data_dir", "tmy_45", "000_8", "000_2005_2016", "txt", "xxx", "can", "t", "infer", "outputformat", "from", "file", "extensions", "for", "basic", "with", "pytest", "raises", "valueerror", "match", "pvgis", "format", "txt", "was", "unknown", "read_pvgis_tmy", "fn", "map_variables", "false", "explicit", "pvgis", "outputformat", "pvgis_data", "read_pvgis_tmy", "fn", "pvgis_format", "basic", "map_variables", "false", "_compare_pvgis_tmy_basic", "expected", "meta_expected", "pvgis_data", "with", "fn", "open", "rb", "as", "fbuf", "pvgis_data", "read_pvgis_tmy", "fbuf", "pvgis_format", "basic", "map_variables", "false", "_compare_pvgis_tmy_basic", "expected", "meta_expected", "pvgis_data", "file", "buffer", "raises", "typeerror", "if", "passed", "to", "pathlib", "path", "with", "pytest", "raises", "typeerror", "read_pvgis_tmy", "fbuf", "map_variables", "false"], "doc_len": 87}
{"doc_id": "pvlib/tests/iotools/test_pvgis.py::test_read_pvgis_tmy_exception", "file_path": "pvlib/tests/iotools/test_pvgis.py", "class_name": null, "func_name": "test_read_pvgis_tmy_exception", "text": "文件路径: pvlib/tests/iotools/test_pvgis.py\ndef test_read_pvgis_tmy_exception():\n    bad_outputformat = 'bad'\n    err_msg = f\"pvgis format '{bad_outputformat:s}' was unknown\"\n    with pytest.raises(ValueError, match=err_msg):\n        read_pvgis_tmy('filename', pvgis_format=bad_outputformat,\n                       map_variables=False)\n", "tokens": ["pvlib", "tests", "iotools", "test_pvgis", "py", "def", "test_read_pvgis_tmy_exception", "bad_outputformat", "bad", "err_msg", "f", "pvgis", "format", "bad_outputformat", "s", "was", "unknown", "with", "pytest", "raises", "valueerror", "match", "err_msg", "read_pvgis_tmy", "filename", "pvgis_format", "bad_outputformat", "map_variables", "false"], "doc_len": 29}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::generate_expected_dataframe", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "generate_expected_dataframe", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef generate_expected_dataframe(values, columns, index, dtypes):\n    \"\"\"Create dataframe from arrays of values, columns and index, in order to\n    use this dataframe to compare to.\n    \"\"\"\n    expected = pd.DataFrame(values, columns=columns, index=index)\n    expected.index.freq = None\n    for (col, _dtype) in zip(expected.columns, dtypes):\n        expected[col] = expected[col].astype(_dtype)\n    return expected\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "generate_expected_dataframe", "values", "columns", "index", "dtypes", "create", "dataframe", "from", "arrays", "of", "values", "columns", "and", "index", "in", "order", "to", "use", "this", "dataframe", "to", "compare", "to", "expected", "pd", "dataframe", "values", "columns", "columns", "index", "index", "expected", "index", "freq", "none", "for", "col", "_dtype", "in", "zip", "expected", "columns", "dtypes", "expected", "col", "expected", "col", "astype", "_dtype", "return", "expected"], "doc_len": 57}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::test_read_cams", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "test_read_cams", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef test_read_cams(testfile, index, columns, values, dtypes):\n    expected = generate_expected_dataframe(values, columns, index, dtypes)\n    out, metadata = sodapro.read_cams(testfile, integrated=False,\n                                      map_variables=True)\n    assert_frame_equal(out, expected, check_less_precise=True)\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "test_read_cams", "testfile", "index", "columns", "values", "dtypes", "expected", "generate_expected_dataframe", "values", "columns", "index", "dtypes", "out", "metadata", "sodapro", "read_cams", "testfile", "integrated", "false", "map_variables", "true", "assert_frame_equal", "out", "expected", "check_less_precise", "true"], "doc_len": 32}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::test_read_cams_integrated_unmapped_label", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "test_read_cams_integrated_unmapped_label", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef test_read_cams_integrated_unmapped_label():\n    # Default label is 'left' for 1 minute time resolution, hence 1 minute is\n    # added for label='right'\n    expected = generate_expected_dataframe(\n        values_radiation_verbose_integrated,\n        columns_radiation_verbose_unmapped,\n        index_verbose+pd.Timedelta(minutes=1), dtypes=dtypes_radiation_verbose)\n    out, metadata = sodapro.read_cams(testfile_radiation_verbose,\n                                      integrated=True, label='right',\n                                      map_variables=False)\n    assert_frame_equal(out, expected, check_less_precise=True)\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "test_read_cams_integrated_unmapped_label", "default", "label", "is", "left", "for", "1", "minute", "time", "resolution", "hence", "1", "minute", "is", "added", "for", "label", "right", "expected", "generate_expected_dataframe", "values_radiation_verbose_integrated", "columns_radiation_verbose_unmapped", "index_verbose", "pd", "timedelta", "minutes", "1", "dtypes", "dtypes_radiation_verbose", "out", "metadata", "sodapro", "read_cams", "testfile_radiation_verbose", "integrated", "true", "label", "right", "map_variables", "false", "assert_frame_equal", "out", "expected", "check_less_precise", "true"], "doc_len": 51}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::test_read_cams_metadata", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "test_read_cams_metadata", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef test_read_cams_metadata():\n    _, metadata = sodapro.read_cams(testfile_mcclear_monthly, integrated=False)\n    assert metadata['Time reference'] == 'Universal time (UT)'\n    assert metadata['noValue'] == 'nan'\n    assert metadata['latitude'] == 55.7906\n    assert metadata['longitude'] == 12.5251\n    assert metadata['altitude'] == 39.0\n    assert metadata['radiation_unit'] == 'W/m^2'\n    assert metadata['time_step'] == '1M'\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "test_read_cams_metadata", "_", "metadata", "sodapro", "read_cams", "testfile_mcclear_monthly", "integrated", "false", "assert", "metadata", "time", "reference", "universal", "time", "ut", "assert", "metadata", "novalue", "nan", "assert", "metadata", "latitude", "55", "7906", "assert", "metadata", "longitude", "12", "5251", "assert", "metadata", "altitude", "39", "0", "assert", "metadata", "radiation_unit", "w", "m", "2", "assert", "metadata", "time_step", "1m"], "doc_len": 50}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::test_get_cams", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "test_get_cams", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef test_get_cams(requests_mock, testfile, index, columns, values, dtypes,\n                  identifier):\n    \"\"\"Test that get_cams generates the correct URI request and that parse_cams\n    is being called correctly\"\"\"\n    # Open local test file containing McClear mothly data\n    with open(testfile, 'r') as test_file:\n        mock_response = test_file.read()\n    # Specify the full URI of a specific example, this ensures that all of the\n    # inputs are passing on correctly\n    url_test_cams = f'https://www.soda-is.com/service/wps?DataInputs=latitude=55.7906;longitude=12.5251;altitude=80;date_begin=2020-01-01;date_end=2020-05-04;time_ref=UT;summarization=P01M;username=pvlib-admin%2540googlegroups.com;verbose=false&Service=WPS&Request=Execute&Identifier=get_{identifier}&version=1.0.0&RawDataOutput=irradiation'  # noqa: E501\n\n    requests_mock.get(url_test_cams, text=mock_response,\n                      headers={'Content-Type': 'application/csv'})\n\n    # Make API call - an error is raised if requested URI does not match\n    out, metadata = sodapro.get_cams(\n        start=pd.Timestamp('2020-01-01'),\n        end=pd.Timestamp('2020-05-04'),\n        latitude=55.7906,\n        longitude=12.5251,\n        email='pvlib-admin@googlegroups.com',\n        identifier=identifier,\n        altitude=80,\n        time_step='1M',\n        verbose=False,\n        integrated=False)\n    expected = generate_expected_dataframe(values, columns, index, dtypes)\n    assert_frame_equal(out, expected, check_less_precise=True)\n\n    # Test if Warning is raised if verbose mode is True and time_step != '1min'\n    with pytest.warns(UserWarning, match='Verbose mode only supports'):\n        _ = sodapro.get_cams(\n            start=pd.Timestamp('2020-01-01'),\n            end=pd.Timestamp('2020-05-04'),\n            latitude=55.7906,\n            longitude=12.5251,\n            email='pvlib-admin@googlegroups.com',\n            identifier=identifier,\n            altitude=80,\n            time_step='1M',\n            verbose=True)\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "test_get_cams", "requests_mock", "testfile", "index", "columns", "values", "dtypes", "identifier", "test", "that", "get_cams", "generates", "the", "correct", "uri", "request", "and", "that", "parse_cams", "is", "being", "called", "correctly", "open", "local", "test", "file", "containing", "mcclear", "mothly", "data", "with", "open", "testfile", "r", "as", "test_file", "mock_response", "test_file", "read", "specify", "the", "full", "uri", "of", "a", "specific", "example", "this", "ensures", "that", "all", "of", "the", "inputs", "are", "passing", "on", "correctly", "url_test_cams", "f", "https", "www", "soda", "is", "com", "service", "wps", "datainputs", "latitude", "55", "7906", "longitude", "12", "5251", "altitude", "80", "date_begin", "2020", "01", "01", "date_end", "2020", "05", "04", "time_ref", "ut", "summarization", "p01m", "username", "pvlib", "admin", "2540googlegroups", "com", "verbose", "false", "service", "wps", "request", "execute", "identifier", "get_", "identifier", "version", "1", "0", "0", "rawdataoutput", "irradiation", "noqa", "e501", "requests_mock", "get", "url_test_cams", "text", "mock_response", "headers", "content", "type", "application", "csv", "make", "api", "call", "an", "error", "is", "raised", "if", "requested", "uri", "does", "not", "match", "out", "metadata", "sodapro", "get_cams", "start", "pd", "timestamp", "2020", "01", "01", "end", "pd", "timestamp", "2020", "05", "04", "latitude", "55", "7906", "longitude", "12", "5251", "email", "pvlib", "admin", "googlegroups", "com", "identifier", "identifier", "altitude", "80", "time_step", "1m", "verbose", "false", "integrated", "false", "expected", "generate_expected_dataframe", "values", "columns", "index", "dtypes", "assert_frame_equal", "out", "expected", "check_less_precise", "true", "test", "if", "warning", "is", "raised", "if", "verbose", "mode", "is", "true", "and", "time_step", "1min", "with", "pytest", "warns", "userwarning", "match", "verbose", "mode", "only", "supports", "_", "sodapro", "get_cams", "start", "pd", "timestamp", "2020", "01", "01", "end", "pd", "timestamp", "2020", "05", "04", "latitude", "55", "7906", "longitude", "12", "5251", "email", "pvlib", "admin", "googlegroups", "com", "identifier", "identifier", "altitude", "80", "time_step", "1m", "verbose", "true"], "doc_len": 244}
{"doc_id": "pvlib/tests/iotools/test_sodapro.py::test_get_cams_bad_request", "file_path": "pvlib/tests/iotools/test_sodapro.py", "class_name": null, "func_name": "test_get_cams_bad_request", "text": "文件路径: pvlib/tests/iotools/test_sodapro.py\ndef test_get_cams_bad_request(requests_mock):\n    \"\"\"Test that a the correct errors/warnings ares raised for invalid\n    requests inputs. Also tests if the specified server url gets used\"\"\"\n\n    # Subset of an xml file returned for errornous requests\n    mock_response_bad = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <ows:Exception exceptionCode=\"NoApplicableCode\" locator=\"None\">\n    <ows:ExceptionText>Failed to execute WPS process [get_mcclear]:\n        Please, register yourself at www.soda-pro.com\n    </ows:ExceptionText>\"\"\"\n\n    url_cams_bad_request = 'https://pro.soda-is.com/service/wps?DataInputs=latitude=55.7906;longitude=12.5251;altitude=-999;date_begin=2020-01-01;date_end=2020-05-04;time_ref=TST;summarization=PT01H;username=test%2540test.com;verbose=false&Service=WPS&Request=Execute&Identifier=get_mcclear&version=1.0.0&RawDataOutput=irradiation'  # noqa: E501\n\n    requests_mock.get(url_cams_bad_request, text=mock_response_bad,\n                      headers={'Content-Type': 'application/xml'})\n\n    # Test if HTTPError is raised if incorrect input is specified\n    # In the below example a non-registrered email is specified\n    with pytest.raises(requests.HTTPError, match='Failed to execute WPS'):\n        _ = sodapro.get_cams(\n            start=pd.Timestamp('2020-01-01'),\n            end=pd.Timestamp('2020-05-04'),\n            latitude=55.7906,\n            longitude=12.5251,\n            email='test@test.com',  # a non-registrered email\n            identifier='mcclear',\n            time_ref='TST',\n            verbose=False,\n            time_step='1h',\n            server='pro.soda-is.com')\n    # Test if value error is raised if incorrect identifier is specified\n    with pytest.raises(ValueError, match='Identifier must be either'):\n        _ = sodapro.get_cams(\n            start=pd.Timestamp('2020-01-01'),\n            end=pd.Timestamp('2020-05-04'),\n            latitude=55.7906,\n            longitude=12.5251,\n            email='test@test.com',\n            identifier='test',  # incorrect identifier\n            server='pro.soda-is.com')\n    # Test if value error is raised if incorrect time step is specified\n    with pytest.raises(ValueError, match='Time step not recognized'):\n        _ = sodapro.get_cams(\n            start=pd.Timestamp('2020-01-01'),\n            end=pd.Timestamp('2020-05-04'),\n            latitude=55.7906,\n            longitude=12.5251,\n            email='test@test.com',\n            identifier='mcclear',\n            time_step='test',  # incorrect time step\n            server='pro.soda-is.com')\n", "tokens": ["pvlib", "tests", "iotools", "test_sodapro", "py", "def", "test_get_cams_bad_request", "requests_mock", "test", "that", "a", "the", "correct", "errors", "warnings", "ares", "raised", "for", "invalid", "requests", "inputs", "also", "tests", "if", "the", "specified", "server", "url", "gets", "used", "subset", "of", "an", "xml", "file", "returned", "for", "errornous", "requests", "mock_response_bad", "xml", "version", "1", "0", "encoding", "utf", "8", "ows", "exception", "exceptioncode", "noapplicablecode", "locator", "none", "ows", "exceptiontext", "failed", "to", "execute", "wps", "process", "get_mcclear", "please", "register", "yourself", "at", "www", "soda", "pro", "com", "ows", "exceptiontext", "url_cams_bad_request", "https", "pro", "soda", "is", "com", "service", "wps", "datainputs", "latitude", "55", "7906", "longitude", "12", "5251", "altitude", "999", "date_begin", "2020", "01", "01", "date_end", "2020", "05", "04", "time_ref", "tst", "summarization", "pt01h", "username", "test", "2540test", "com", "verbose", "false", "service", "wps", "request", "execute", "identifier", "get_mcclear", "version", "1", "0", "0", "rawdataoutput", "irradiation", "noqa", "e501", "requests_mock", "get", "url_cams_bad_request", "text", "mock_response_bad", "headers", "content", "type", "application", "xml", "test", "if", "httperror", "is", "raised", "if", "incorrect", "input", "is", "specified", "in", "the", "below", "example", "a", "non", "registrered", "email", "is", "specified", "with", "pytest", "raises", "requests", "httperror", "match", "failed", "to", "execute", "wps", "_", "sodapro", "get_cams", "start", "pd", "timestamp", "2020", "01", "01", "end", "pd", "timestamp", "2020", "05", "04", "latitude", "55", "7906", "longitude", "12", "5251", "email", "test", "test", "com", "a", "non", "registrered", "email", "identifier", "mcclear", "time_ref", "tst", "verbose", "false", "time_step", "1h", "server", "pro", "soda", "is", "com", "test", "if", "value", "error", "is", "raised", "if", "incorrect", "identifier", "is", "specified", "with", "pytest", "raises", "valueerror", "match", "identifier", "must", "be", "either", "_", "sodapro", "get_cams", "start", "pd", "timestamp", "2020", "01", "01", "end", "pd", "timestamp", "2020", "05", "04", "latitude", "55", "7906", "longitude", "12", "5251", "email", "test", "test", "com", "identifier", "test", "incorrect", "identifier", "server", "pro", "soda", "is", "com", "test", "if", "value", "error", "is", "raised", "if", "incorrect", "time", "step", "is", "specified", "with", "pytest", "raises", "valueerror", "match", "time", "step", "not", "recognized", "_", "sodapro", "get_cams", "start", "pd", "timestamp", "2020", "01", "01", "end", "pd", "timestamp", "2020", "05", "04", "latitude", "55", "7906", "longitude", "12", "5251", "email", "test", "test", "com", "identifier", "mcclear", "time_step", "test", "incorrect", "time", "step", "server", "pro", "soda", "is", "com"], "doc_len": 314}
{"doc_id": "pvlib/tests/iotools/test_solrad.py::test_read_solrad", "file_path": "pvlib/tests/iotools/test_solrad.py", "class_name": null, "func_name": "test_read_solrad", "text": "文件路径: pvlib/tests/iotools/test_solrad.py\ndef test_read_solrad(testfile, index, columns, values, dtypes):\n    expected = pd.DataFrame(values, columns=columns, index=index)\n    for (col, _dtype) in zip(expected.columns, dtypes):\n        expected[col] = expected[col].astype(_dtype)\n    out = solrad.read_solrad(testfile)\n    assert_frame_equal(out, expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_solrad", "py", "def", "test_read_solrad", "testfile", "index", "columns", "values", "dtypes", "expected", "pd", "dataframe", "values", "columns", "columns", "index", "index", "for", "col", "_dtype", "in", "zip", "expected", "columns", "dtypes", "expected", "col", "expected", "col", "astype", "_dtype", "out", "solrad", "read_solrad", "testfile", "assert_frame_equal", "out", "expected"], "doc_len": 41}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml():\n    srml.read_srml(srml_testfile)\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml", "srml", "read_srml", "srml_testfile"], "doc_len": 10}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml_remote", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml_remote", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml_remote():\n    srml.read_srml('http://solardat.uoregon.edu/download/Archive/EUPO1801.txt')\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml_remote", "srml", "read_srml", "http", "solardat", "uoregon", "edu", "download", "archive", "eupo1801", "txt"], "doc_len": 17}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml_columns_exist", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml_columns_exist", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml_columns_exist():\n    data = srml.read_srml(srml_testfile)\n    assert 'ghi_0' in data.columns\n    assert 'ghi_0_flag' in data.columns\n    assert 'dni_1' in data.columns\n    assert 'dni_1_flag' in data.columns\n    assert '7008' in data.columns\n    assert '7008_flag' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml_columns_exist", "data", "srml", "read_srml", "srml_testfile", "assert", "ghi_0", "in", "data", "columns", "assert", "ghi_0_flag", "in", "data", "columns", "assert", "dni_1", "in", "data", "columns", "assert", "dni_1_flag", "in", "data", "columns", "assert", "7008", "in", "data", "columns", "assert", "7008_flag", "in", "data", "columns"], "doc_len": 41}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml_nans_exist", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml_nans_exist", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml_nans_exist():\n    data = srml.read_srml(srml_testfile)\n    assert isnan(data['dni_0'][1119])\n    assert data['dni_0_flag'][1119] == 99\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml_nans_exist", "data", "srml", "read_srml", "srml_testfile", "assert", "isnan", "data", "dni_0", "1119", "assert", "data", "dni_0_flag", "1119", "99"], "doc_len": 21}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml_dt_index", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml_dt_index", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml_dt_index(url, year, month):\n    data = srml.read_srml(url)\n    start = pd.Timestamp(f'{year:04d}{month:02d}01 00:00')\n    start = start.tz_localize('Etc/GMT+8')\n    end = pd.Timestamp(f'{year:04d}{month:02d}31 23:59')\n    end = end.tz_localize('Etc/GMT+8')\n    assert data.index[0] == start\n    assert data.index[-1] == end\n    assert (data.index[59::60].minute == 59).all()\n    assert str(year) not in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml_dt_index", "url", "year", "month", "data", "srml", "read_srml", "url", "start", "pd", "timestamp", "f", "year", "04d", "month", "02d", "01", "00", "00", "start", "start", "tz_localize", "etc", "gmt", "8", "end", "pd", "timestamp", "f", "year", "04d", "month", "02d", "31", "23", "59", "end", "end", "tz_localize", "etc", "gmt", "8", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end", "assert", "data", "index", "59", "60", "minute", "59", "all", "assert", "str", "year", "not", "in", "data", "columns"], "doc_len": 73}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_map_columns", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_map_columns", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_map_columns(column, expected):\n    assert srml.map_columns(column) == expected\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_map_columns", "column", "expected", "assert", "srml", "map_columns", "column", "expected"], "doc_len": 14}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_read_srml_month_from_solardat", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_read_srml_month_from_solardat", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_read_srml_month_from_solardat():\n    url = 'http://solardat.uoregon.edu/download/Archive/EUPO1801.txt'\n    file_data = srml.read_srml(url)\n    requested = srml.read_srml_month_from_solardat('EU', 2018, 1)\n    assert file_data.equals(requested)\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_read_srml_month_from_solardat", "url", "http", "solardat", "uoregon", "edu", "download", "archive", "eupo1801", "txt", "file_data", "srml", "read_srml", "url", "requested", "srml", "read_srml_month_from_solardat", "eu", "2018", "1", "assert", "file_data", "equals", "requested"], "doc_len": 30}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_15_minute_dt_index", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_15_minute_dt_index", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_15_minute_dt_index():\n    data = srml.read_srml_month_from_solardat('TW', 2019, 4, 'RQ')\n    start = pd.Timestamp('20190401 00:00')\n    start = start.tz_localize('Etc/GMT+8')\n    end = pd.Timestamp('20190430 23:45')\n    end = end.tz_localize('Etc/GMT+8')\n    assert data.index[0] == start\n    assert data.index[-1] == end\n    assert (data.index[3::4].minute == 45).all()\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_15_minute_dt_index", "data", "srml", "read_srml_month_from_solardat", "tw", "2019", "4", "rq", "start", "pd", "timestamp", "20190401", "00", "00", "start", "start", "tz_localize", "etc", "gmt", "8", "end", "pd", "timestamp", "20190430", "23", "45", "end", "end", "tz_localize", "etc", "gmt", "8", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end", "assert", "data", "index", "3", "4", "minute", "45", "all"], "doc_len": 56}
{"doc_id": "pvlib/tests/iotools/test_srml.py::test_hourly_dt_index", "file_path": "pvlib/tests/iotools/test_srml.py", "class_name": null, "func_name": "test_hourly_dt_index", "text": "文件路径: pvlib/tests/iotools/test_srml.py\ndef test_hourly_dt_index():\n    data = srml.read_srml_month_from_solardat('CD', 1986, 4, 'PH')\n    start = pd.Timestamp('19860401 00:00')\n    start = start.tz_localize('Etc/GMT+8')\n    end = pd.Timestamp('19860430 23:00')\n    end = end.tz_localize('Etc/GMT+8')\n    assert data.index[0] == start\n    assert data.index[-1] == end\n    assert (data.index.minute == 0).all()\n", "tokens": ["pvlib", "tests", "iotools", "test_srml", "py", "def", "test_hourly_dt_index", "data", "srml", "read_srml_month_from_solardat", "cd", "1986", "4", "ph", "start", "pd", "timestamp", "19860401", "00", "00", "start", "start", "tz_localize", "etc", "gmt", "8", "end", "pd", "timestamp", "19860430", "23", "00", "end", "end", "tz_localize", "etc", "gmt", "8", "assert", "data", "index", "0", "start", "assert", "data", "index", "1", "end", "assert", "data", "index", "minute", "0", "all"], "doc_len": 54}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_read_surfrad_network", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_read_surfrad_network", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_read_surfrad_network():\n    # If this test begins failing, SURFRAD's data structure or data\n    # archive may have changed.\n    local_data, _ = surfrad.read_surfrad(testfile)\n    network_data, _ = surfrad.read_surfrad(network_testfile)\n    assert local_data.equals(network_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_read_surfrad_network", "if", "this", "test", "begins", "failing", "surfrad", "s", "data", "structure", "or", "data", "archive", "may", "have", "changed", "local_data", "_", "surfrad", "read_surfrad", "testfile", "network_data", "_", "surfrad", "read_surfrad", "network_testfile", "assert", "local_data", "equals", "network_data"], "doc_len": 36}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_read_surfrad_https", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_read_surfrad_https", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_read_surfrad_https():\n    # Test reading of https files.\n    # If this test begins failing, SURFRAD's data structure or data\n    # archive may have changed.\n    local_data, _ = surfrad.read_surfrad(testfile)\n    network_data, _ = surfrad.read_surfrad(https_testfile)\n    assert local_data.equals(network_data)\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_read_surfrad_https", "test", "reading", "of", "https", "files", "if", "this", "test", "begins", "failing", "surfrad", "s", "data", "structure", "or", "data", "archive", "may", "have", "changed", "local_data", "_", "surfrad", "read_surfrad", "testfile", "network_data", "_", "surfrad", "read_surfrad", "https_testfile", "assert", "local_data", "equals", "network_data"], "doc_len": 41}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_read_surfrad_columns_no_map", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_read_surfrad_columns_no_map", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_read_surfrad_columns_no_map():\n    data, _ = surfrad.read_surfrad(testfile, map_variables=False)\n    assert 'zen' in data.columns\n    assert 'temp' in data.columns\n    assert 'par' in data.columns\n    assert 'pressure' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_read_surfrad_columns_no_map", "data", "_", "surfrad", "read_surfrad", "testfile", "map_variables", "false", "assert", "zen", "in", "data", "columns", "assert", "temp", "in", "data", "columns", "assert", "par", "in", "data", "columns", "assert", "pressure", "in", "data", "columns"], "doc_len": 34}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_read_surfrad_columns_map", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_read_surfrad_columns_map", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_read_surfrad_columns_map():\n    data, _ = surfrad.read_surfrad(testfile)\n    assert 'solar_zenith' in data.columns\n    assert 'ghi' in data.columns\n    assert 'ghi_flag' in data.columns\n    assert 'dni' in data.columns\n    assert 'dni_flag' in data.columns\n    assert 'dhi' in data.columns\n    assert 'dhi_flag' in data.columns\n    assert 'wind_direction' in data.columns\n    assert 'wind_direction_flag' in data.columns\n    assert 'wind_speed' in data.columns\n    assert 'wind_speed_flag' in data.columns\n    assert 'temp_air' in data.columns\n    assert 'temp_air_flag' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_read_surfrad_columns_map", "data", "_", "surfrad", "read_surfrad", "testfile", "assert", "solar_zenith", "in", "data", "columns", "assert", "ghi", "in", "data", "columns", "assert", "ghi_flag", "in", "data", "columns", "assert", "dni", "in", "data", "columns", "assert", "dni_flag", "in", "data", "columns", "assert", "dhi", "in", "data", "columns", "assert", "dhi_flag", "in", "data", "columns", "assert", "wind_direction", "in", "data", "columns", "assert", "wind_direction_flag", "in", "data", "columns", "assert", "wind_speed", "in", "data", "columns", "assert", "wind_speed_flag", "in", "data", "columns", "assert", "temp_air", "in", "data", "columns", "assert", "temp_air_flag", "in", "data", "columns"], "doc_len": 77}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_format_index", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_format_index", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_format_index():\n    start = pd.Timestamp('20160101 00:00')\n    expected = pd.date_range(start=start, periods=1440, freq='1min', tz='UTC')\n    actual, _ = surfrad.read_surfrad(testfile)\n    assert actual.index.equals(expected)\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_format_index", "start", "pd", "timestamp", "20160101", "00", "00", "expected", "pd", "date_range", "start", "start", "periods", "1440", "freq", "1min", "tz", "utc", "actual", "_", "surfrad", "read_surfrad", "testfile", "assert", "actual", "index", "equals", "expected"], "doc_len": 34}
{"doc_id": "pvlib/tests/iotools/test_surfrad.py::test_read_surfrad_metadata", "file_path": "pvlib/tests/iotools/test_surfrad.py", "class_name": null, "func_name": "test_read_surfrad_metadata", "text": "文件路径: pvlib/tests/iotools/test_surfrad.py\ndef test_read_surfrad_metadata():\n    expected = {'name': 'Alamosa',\n                'latitude': 37.70,\n                'longitude': 105.92,\n                'elevation': 2317,\n                'surfrad_version': 1,\n                'tz': 'UTC'}\n    _, metadata = surfrad.read_surfrad(testfile)\n    assert metadata == expected\n", "tokens": ["pvlib", "tests", "iotools", "test_surfrad", "py", "def", "test_read_surfrad_metadata", "expected", "name", "alamosa", "latitude", "37", "70", "longitude", "105", "92", "elevation", "2317", "surfrad_version", "1", "tz", "utc", "_", "metadata", "surfrad", "read_surfrad", "testfile", "assert", "metadata", "expected"], "doc_len": 30}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy3", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy3", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy3():\n    tmy.read_tmy3(TMY3_TESTFILE)\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy3", "tmy", "read_tmy3", "tmy3_testfile"], "doc_len": 10}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy3_recolumn", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy3_recolumn", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy3_recolumn():\n    data, meta = tmy.read_tmy3(TMY3_TESTFILE)\n    assert 'GHISource' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy3_recolumn", "data", "meta", "tmy", "read_tmy3", "tmy3_testfile", "assert", "ghisource", "in", "data", "columns"], "doc_len": 17}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy3_norecolumn", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy3_norecolumn", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy3_norecolumn():\n    data, _ = tmy.read_tmy3(TMY3_TESTFILE, recolumn=False)\n    assert 'GHI source' in data.columns\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy3_norecolumn", "data", "_", "tmy", "read_tmy3", "tmy3_testfile", "recolumn", "false", "assert", "ghi", "source", "in", "data", "columns"], "doc_len": 20}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy3_coerce_year", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy3_coerce_year", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy3_coerce_year():\n    coerce_year = 1987\n    data, _ = tmy.read_tmy3(TMY3_TESTFILE, coerce_year=coerce_year)\n    assert (data.index[:-1].year == 1987).all()\n    assert data.index[-1].year == 1988\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy3_coerce_year", "coerce_year", "1987", "data", "_", "tmy", "read_tmy3", "tmy3_testfile", "coerce_year", "coerce_year", "assert", "data", "index", "1", "year", "1987", "all", "assert", "data", "index", "1", "year", "1988"], "doc_len": 29}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy3_no_coerce_year", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy3_no_coerce_year", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy3_no_coerce_year():\n    coerce_year = None\n    data, _ = tmy.read_tmy3(TMY3_TESTFILE, coerce_year=coerce_year)\n    assert 1997 and 1999 in data.index.year\n    assert data.index[-2] == pd.Timestamp('1998-12-31 23:00:00-09:00')\n    assert data.index[-1] == pd.Timestamp('1999-01-01 00:00:00-09:00')\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy3_no_coerce_year", "coerce_year", "none", "data", "_", "tmy", "read_tmy3", "tmy3_testfile", "coerce_year", "coerce_year", "assert", "1997", "and", "1999", "in", "data", "index", "year", "assert", "data", "index", "2", "pd", "timestamp", "1998", "12", "31", "23", "00", "00", "09", "00", "assert", "data", "index", "1", "pd", "timestamp", "1999", "01", "01", "00", "00", "00", "09", "00"], "doc_len": 52}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_read_tmy2", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_read_tmy2", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_read_tmy2():\n    tmy.read_tmy2(TMY2_TESTFILE)\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_read_tmy2", "tmy", "read_tmy2", "tmy2_testfile"], "doc_len": 10}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_gh865_read_tmy3_feb_leapyear_hr24", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_gh865_read_tmy3_feb_leapyear_hr24", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_gh865_read_tmy3_feb_leapyear_hr24():\n    \"\"\"correctly parse the 24th hour if the tmy3 file has a leap year in feb\"\"\"\n    data, meta = read_tmy3(TMY3_FEB_LEAPYEAR)\n    # just to be safe, make sure this _IS_ the Greensboro file\n    greensboro = {\n        'USAF': 723170,\n        'Name': '\"GREENSBORO PIEDMONT TRIAD INT\"',\n        'State': 'NC',\n        'TZ': -5.0,\n        'latitude': 36.1,\n        'longitude': -79.95,\n        'altitude': 273.0}\n    assert meta == greensboro\n    # February for Greensboro is 1996, a leap year, so check to make sure there\n    # aren't any rows in the output that contain Feb 29th\n    assert data.index[1414] == pd.Timestamp('1996-02-28 23:00:00-0500')\n    assert data.index[1415] == pd.Timestamp('1996-03-01 00:00:00-0500')\n    # now check if it parses correctly when we try to coerce the year\n    data, _ = read_tmy3(TMY3_FEB_LEAPYEAR, coerce_year=1990)\n    # if get's here w/o an error, then gh865 is fixed, but let's check anyway\n    assert all(data.index[:-1].year == 1990)\n    assert data.index[-1].year == 1991\n    # let's do a quick sanity check, are the indices monotonically increasing?\n    assert all(np.diff(data.index.view(np.int64)) == 3600000000000)\n    # according to the TMY3 manual, each record corresponds to the previous\n    # hour so check that the 1st hour is 1AM and the last hour is midnite\n    assert data.index[0].hour == 1\n    assert data.index[-1].hour == 0\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_gh865_read_tmy3_feb_leapyear_hr24", "correctly", "parse", "the", "24th", "hour", "if", "the", "tmy3", "file", "has", "a", "leap", "year", "in", "feb", "data", "meta", "read_tmy3", "tmy3_feb_leapyear", "just", "to", "be", "safe", "make", "sure", "this", "_is_", "the", "greensboro", "file", "greensboro", "usaf", "723170", "name", "greensboro", "piedmont", "triad", "int", "state", "nc", "tz", "5", "0", "latitude", "36", "1", "longitude", "79", "95", "altitude", "273", "0", "assert", "meta", "greensboro", "february", "for", "greensboro", "is", "1996", "a", "leap", "year", "so", "check", "to", "make", "sure", "there", "aren", "t", "any", "rows", "in", "the", "output", "that", "contain", "feb", "29th", "assert", "data", "index", "1414", "pd", "timestamp", "1996", "02", "28", "23", "00", "00", "0500", "assert", "data", "index", "1415", "pd", "timestamp", "1996", "03", "01", "00", "00", "00", "0500", "now", "check", "if", "it", "parses", "correctly", "when", "we", "try", "to", "coerce", "the", "year", "data", "_", "read_tmy3", "tmy3_feb_leapyear", "coerce_year", "1990", "if", "get", "s", "here", "w", "o", "an", "error", "then", "gh865", "is", "fixed", "but", "let", "s", "check", "anyway", "assert", "all", "data", "index", "1", "year", "1990", "assert", "data", "index", "1", "year", "1991", "let", "s", "do", "a", "quick", "sanity", "check", "are", "the", "indices", "monotonically", "increasing", "assert", "all", "np", "diff", "data", "index", "view", "np", "int64", "3600000000000", "according", "to", "the", "tmy3", "manual", "each", "record", "corresponds", "to", "the", "previous", "hour", "so", "check", "that", "the", "1st", "hour", "is", "1am", "and", "the", "last", "hour", "is", "midnite", "assert", "data", "index", "0", "hour", "1", "assert", "data", "index", "1", "hour", "0"], "doc_len": 222}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::solaranywhere_index", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "solaranywhere_index", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef solaranywhere_index():\n    return pd.date_range('2021-01-01 01:00:00-05:00', periods=8760, freq='1h')\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "solaranywhere_index", "return", "pd", "date_range", "2021", "01", "01", "01", "00", "00", "05", "00", "periods", "8760", "freq", "1h"], "doc_len": 22}
{"doc_id": "pvlib/tests/iotools/test_tmy.py::test_solaranywhere_tmy3", "file_path": "pvlib/tests/iotools/test_tmy.py", "class_name": null, "func_name": "test_solaranywhere_tmy3", "text": "文件路径: pvlib/tests/iotools/test_tmy.py\ndef test_solaranywhere_tmy3(solaranywhere_index):\n    # The SolarAnywhere TMY3 format specifies midnight as 00:00 whereas the\n    # NREL TMY3 format utilizes 24:00. The SolarAnywhere file is therefore\n    # included to test files with  00:00 timestamps are parsed correctly\n    data, meta = tmy.read_tmy3(TMY3_SOLARANYWHERE)\n    pd.testing.assert_index_equal(data.index, solaranywhere_index)\n    assert meta['USAF'] == 0\n    assert meta['Name'] == 'Burlington  United States'\n    assert meta['State'] == 'NA'\n    assert meta['TZ'] == -5.0\n    assert meta['latitude'] == 44.465\n    assert meta['longitude'] == -73.205\n    assert meta['altitude'] == 41.0\n", "tokens": ["pvlib", "tests", "iotools", "test_tmy", "py", "def", "test_solaranywhere_tmy3", "solaranywhere_index", "the", "solaranywhere", "tmy3", "format", "specifies", "midnight", "as", "00", "00", "whereas", "the", "nrel", "tmy3", "format", "utilizes", "24", "00", "the", "solaranywhere", "file", "is", "therefore", "included", "to", "test", "files", "with", "00", "00", "timestamps", "are", "parsed", "correctly", "data", "meta", "tmy", "read_tmy3", "tmy3_solaranywhere", "pd", "testing", "assert_index_equal", "data", "index", "solaranywhere_index", "assert", "meta", "usaf", "0", "assert", "meta", "name", "burlington", "united", "states", "assert", "meta", "state", "na", "assert", "meta", "tz", "5", "0", "assert", "meta", "latitude", "44", "465", "assert", "meta", "longitude", "73", "205", "assert", "meta", "altitude", "41", "0"], "doc_len": 86}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::get_test_iv_params", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "get_test_iv_params", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef get_test_iv_params():\n    return {'IL': 8.0, 'I0': 5e-10, 'Rs': 0.2, 'Rsh': 1000, 'nNsVth': 1.61864}\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "get_test_iv_params", "return", "il", "8", "0", "i0", "5e", "10", "rs", "0", "2", "rsh", "1000", "nnsvth", "1", "61864"], "doc_len": 22}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::test_fit_sandia_simple", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "test_fit_sandia_simple", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef test_fit_sandia_simple(get_test_iv_params, get_bad_iv_curves):\n    test_params = get_test_iv_params\n    testcurve = pvsystem.singlediode(photocurrent=test_params['IL'],\n                                     saturation_current=test_params['I0'],\n                                     resistance_shunt=test_params['Rsh'],\n                                     resistance_series=test_params['Rs'],\n                                     nNsVth=test_params['nNsVth'],\n                                     ivcurve_pnts=300)\n    expected = tuple(test_params[k] for k in ['IL', 'I0', 'Rs', 'Rsh',\n                     'nNsVth'])\n    result = sde.fit_sandia_simple(voltage=testcurve['v'],\n                                   current=testcurve['i'])\n    assert np.allclose(result, expected, rtol=5e-5)\n    result = sde.fit_sandia_simple(voltage=testcurve['v'],\n                                   current=testcurve['i'],\n                                   v_oc=testcurve['v_oc'],\n                                   i_sc=testcurve['i_sc'])\n    assert np.allclose(result, expected, rtol=5e-5)\n    result = sde.fit_sandia_simple(voltage=testcurve['v'],\n                                   current=testcurve['i'],\n                                   v_oc=testcurve['v_oc'],\n                                   i_sc=testcurve['i_sc'],\n                                   v_mp_i_mp=(testcurve['v_mp'],\n                                   testcurve['i_mp']))\n    assert np.allclose(result, expected, rtol=5e-5)\n    result = sde.fit_sandia_simple(voltage=testcurve['v'],\n                                   current=testcurve['i'], vlim=0.1)\n    assert np.allclose(result, expected, rtol=5e-5)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "test_fit_sandia_simple", "get_test_iv_params", "get_bad_iv_curves", "test_params", "get_test_iv_params", "testcurve", "pvsystem", "singlediode", "photocurrent", "test_params", "il", "saturation_current", "test_params", "i0", "resistance_shunt", "test_params", "rsh", "resistance_series", "test_params", "rs", "nnsvth", "test_params", "nnsvth", "ivcurve_pnts", "300", "expected", "tuple", "test_params", "k", "for", "k", "in", "il", "i0", "rs", "rsh", "nnsvth", "result", "sde", "fit_sandia_simple", "voltage", "testcurve", "v", "current", "testcurve", "i", "assert", "np", "allclose", "result", "expected", "rtol", "5e", "5", "result", "sde", "fit_sandia_simple", "voltage", "testcurve", "v", "current", "testcurve", "i", "v_oc", "testcurve", "v_oc", "i_sc", "testcurve", "i_sc", "assert", "np", "allclose", "result", "expected", "rtol", "5e", "5", "result", "sde", "fit_sandia_simple", "voltage", "testcurve", "v", "current", "testcurve", "i", "v_oc", "testcurve", "v_oc", "i_sc", "testcurve", "i_sc", "v_mp_i_mp", "testcurve", "v_mp", "testcurve", "i_mp", "assert", "np", "allclose", "result", "expected", "rtol", "5e", "5", "result", "sde", "fit_sandia_simple", "voltage", "testcurve", "v", "current", "testcurve", "i", "vlim", "0", "1", "assert", "np", "allclose", "result", "expected", "rtol", "5e", "5"], "doc_len": 131}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::test_fit_sandia_simple_bad_iv", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "test_fit_sandia_simple_bad_iv", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef test_fit_sandia_simple_bad_iv(get_bad_iv_curves):\n    # bad IV curves for coverage of if/then in sde._sandia_simple_params\n    v1, i1, v2, i2 = get_bad_iv_curves\n    result = sde.fit_sandia_simple(voltage=v1, current=i1)\n    assert np.allclose(result, (-2.4322856072799985, 8.826830831727355,\n                                111.18558915546389, -63.56227601452038,\n                                -137.9965046659527))\n    result = sde.fit_sandia_simple(voltage=v2, current=i2)\n    assert np.allclose(result, (2.62405311949227, 5.075520636620032,\n                                -65.652554411442, 110.35202827739991,\n                                174.49362093001415))\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "test_fit_sandia_simple_bad_iv", "get_bad_iv_curves", "bad", "iv", "curves", "for", "coverage", "of", "if", "then", "in", "sde", "_sandia_simple_params", "v1", "i1", "v2", "i2", "get_bad_iv_curves", "result", "sde", "fit_sandia_simple", "voltage", "v1", "current", "i1", "assert", "np", "allclose", "result", "2", "4322856072799985", "8", "826830831727355", "111", "18558915546389", "63", "56227601452038", "137", "9965046659527", "result", "sde", "fit_sandia_simple", "voltage", "v2", "current", "i2", "assert", "np", "allclose", "result", "2", "62405311949227", "5", "075520636620032", "65", "652554411442", "110", "35202827739991", "174", "49362093001415"], "doc_len": 66}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::test__fit_sandia_cocontent", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "test__fit_sandia_cocontent", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef test__fit_sandia_cocontent(i, v, nsvth, expected):\n    # test confirms agreement with Matlab code. The returned parameters\n    # are nonsense\n    iph, io, rsh, rs, n = sde._fit_sandia_cocontent(v, i, nsvth)\n    np.testing.assert_allclose(iph, np.array(expected[0]), atol=.0001)\n    np.testing.assert_allclose(io, np.array([expected[1]]), atol=.0001)\n    np.testing.assert_allclose(rs, np.array([expected[2]]), atol=.0001)\n    np.testing.assert_allclose(rsh, np.array([expected[3]]), atol=.0001)\n    np.testing.assert_allclose(n, np.array([expected[4]]), atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "test__fit_sandia_cocontent", "i", "v", "nsvth", "expected", "test", "confirms", "agreement", "with", "matlab", "code", "the", "returned", "parameters", "are", "nonsense", "iph", "io", "rsh", "rs", "n", "sde", "_fit_sandia_cocontent", "v", "i", "nsvth", "np", "testing", "assert_allclose", "iph", "np", "array", "expected", "0", "atol", "0001", "np", "testing", "assert_allclose", "io", "np", "array", "expected", "1", "atol", "0001", "np", "testing", "assert_allclose", "rs", "np", "array", "expected", "2", "atol", "0001", "np", "testing", "assert_allclose", "rsh", "np", "array", "expected", "3", "atol", "0001", "np", "testing", "assert_allclose", "n", "np", "array", "expected", "4", "atol", "0001"], "doc_len": 82}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::test__fit_sandia_cocontent_fail", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "test__fit_sandia_cocontent_fail", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef test__fit_sandia_cocontent_fail():\n    # tests for ValueError\n    exc_text = 'voltage and current should have the same length'\n    with pytest.raises(ValueError, match=exc_text):\n        sde._fit_sandia_cocontent(np.array([0., 1., 2.]), np.array([4., 3.]),\n                                  2.)\n    exc_text = 'at least 6 voltage points are required; ~50 are recommended'\n    with pytest.raises(ValueError, match=exc_text):\n        sde._fit_sandia_cocontent(np.array([0., 1., 2., 3., 4.]),\n                                  np.array([4., 3.9, 3.4, 2., 0.]),\n                                  2.)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "test__fit_sandia_cocontent_fail", "tests", "for", "valueerror", "exc_text", "voltage", "and", "current", "should", "have", "the", "same", "length", "with", "pytest", "raises", "valueerror", "match", "exc_text", "sde", "_fit_sandia_cocontent", "np", "array", "0", "1", "2", "np", "array", "4", "3", "2", "exc_text", "at", "least", "6", "voltage", "points", "are", "required", "50", "are", "recommended", "with", "pytest", "raises", "valueerror", "match", "exc_text", "sde", "_fit_sandia_cocontent", "np", "array", "0", "1", "2", "3", "4", "np", "array", "4", "3", "9", "3", "4", "2", "0", "2"], "doc_len": 73}
{"doc_id": "pvlib/tests/ivtools/test_sde.py::get_bad_iv_curves", "file_path": "pvlib/tests/ivtools/test_sde.py", "class_name": null, "func_name": "get_bad_iv_curves", "text": "文件路径: pvlib/tests/ivtools/test_sde.py\ndef get_bad_iv_curves():\n    # v1, i1 produces a bad value for I0_voc\n    v1 = np.array([0, 0.338798867469060, 0.677597734938121, 1.01639660240718,\n                   1.35519546987624, 1.69399433734530, 2.03279320481436,\n                   2.37159207228342, 2.71039093975248, 3.04918980722154,\n                   3.38798867469060, 3.72678754215966, 4.06558640962873,\n                   4.40438527709779, 4.74318414456685, 5.08198301203591,\n                   5.42078187950497, 5.75958074697403, 6.09837961444309,\n                   6.43717848191215, 6.77597734938121, 7.11477621685027,\n                   7.45357508431933, 7.79237395178839, 8.13117281925745,\n                   8.46997168672651, 8.80877055419557, 9.14756942166463,\n                   9.48636828913369, 9.82516715660275, 10.1639660240718,\n                   10.5027648915409, 10.8415637590099, 11.1803626264790,\n                   11.5191614939481, 11.8579603614171, 12.1967592288862,\n                   12.5355580963552, 12.8743569638243, 13.2131558312934,\n                   13.5519546987624, 13.8907535662315, 14.2295524337005,\n                   14.5683513011696, 14.9071501686387, 15.2459490361077,\n                   15.5847479035768, 15.9235467710458, 16.2623456385149,\n                   16.6011445059840, 16.9399433734530, 17.2787422409221,\n                   17.6175411083911, 17.9563399758602, 18.2951388433293,\n                   18.6339377107983, 18.9727365782674, 19.3115354457364,\n                   19.6503343132055, 19.9891331806746, 20.3279320481436,\n                   20.6667309156127, 21.0055297830817, 21.3443286505508,\n                   21.6831275180199, 22.0219263854889, 22.3607252529580,\n                   22.6995241204270, 23.0383229878961, 23.3771218553652,\n                   23.7159207228342, 24.0547195903033, 24.3935184577724,\n                   24.7323173252414, 25.0711161927105, 25.4099150601795,\n                   25.7487139276486, 26.0875127951177, 26.4263116625867,\n                   26.7651105300558, 27.1039093975248, 27.4427082649939,\n                   27.7815071324630, 28.1203059999320, 28.4591048674011,\n                   28.7979037348701, 29.1367026023392, 29.4755014698083,\n                   29.8143003372773, 30.1530992047464, 30.4918980722154,\n                   30.8306969396845, 31.1694958071536, 31.5082946746226,\n                   31.8470935420917, 32.1858924095607, 32.5246912770298,\n                   32.8634901444989, 33.2022890119679, 33.5410878794370])\n    i1 = np.array([3.39430882774470, 2.80864492110761, 3.28358165429196,\n                   3.41191190551673, 3.11975662808148, 3.35436585834612,\n                   3.23953272899809, 3.60307083325333, 2.80478101508277,\n                   2.80505102853845, 3.16918996870373, 3.21088388439857,\n                   3.46332865310431, 3.09224155015883, 3.17541550741062,\n                   3.32470179290389, 3.33224664316240, 3.07709000050741,\n                   2.89141245343405, 3.01365768561537, 3.23265176770231,\n                   3.32253647634228, 2.97900657569736, 3.31959549243966,\n                   3.03375461550111, 2.97579298978937, 3.25432831375159,\n                   2.89178382564454, 3.00341909207567, 3.72637492250097,\n                   3.28379856976360, 2.96516169245835, 3.25658381110230,\n                   3.41655911533139, 3.02718097944604, 3.11458376760376,\n                   3.24617304369762, 3.45935502367636, 3.21557333256913,\n                   3.27611176482650, 2.86954135732485, 3.32416319254657,\n                   3.15277467598732, 3.08272557013770, 3.15602202666259,\n                   3.49432799877150, 3.53863997177632, 3.10602611478455,\n                   3.05373911151821, 3.09876772570781, 2.97417228624287,\n                   2.84573593699237, 3.16288578405195, 3.06533173612783,\n                   3.02118336639575, 3.34374977225502, 2.97255164138821,\n                   3.19286135682863, 3.10999753817133, 3.26925354620079,\n                   3.11957809501529, 3.20155017481720, 3.31724984405837,\n                   3.42879043512927, 3.17933067619240, 3.47777362613969,\n                   3.20708912539777, 3.48205761174907, 3.16804363684327,\n                   3.14055472378230, 3.13445657434470, 2.91152696252998,\n                   3.10984113847427, 2.80443349399489, 3.23146278164875,\n                   2.94521083406108, 3.17388903141715, 3.05930294897030,\n                   3.18985234673287, 3.27946609274898, 3.33717523113602,\n                   2.76394303462702, 3.19375132937510, 2.82628616689450,\n                   2.85238527394143, 2.82975892599489, 2.79196912313914,\n                   2.72860792049395, 2.75585977414140, 2.44280222448805,\n                   2.36052347370628, 2.26785071765738, 2.10868255743462,\n                   2.06165739407987, 1.90047259509385, 1.39925575828709,\n                   1.24749015957606, 0.867823806536762, 0.432752457749993, 0])\n    # v2, i2 produces a bad value for I0_vmp\n    v2 = np.array([0, 0.365686097622586, 0.731372195245173, 1.09705829286776,\n                   1.46274439049035, 1.82843048811293, 2.19411658573552,\n                   2.55980268335810, 2.92548878098069, 3.29117487860328,\n                   3.65686097622586, 4.02254707384845, 4.38823317147104,\n                   4.75391926909362, 5.11960536671621, 5.48529146433880,\n                   5.85097756196138, 6.21666365958397, 6.58234975720655,\n                   6.94803585482914, 7.31372195245173, 7.67940805007431,\n                   8.04509414769690, 8.41078024531949, 8.77646634294207,\n                   9.14215244056466, 9.50783853818725, 9.87352463580983,\n                   10.2392107334324, 10.6048968310550, 10.9705829286776,\n                   11.3362690263002, 11.7019551239228, 12.0676412215454,\n                   12.4333273191679, 12.7990134167905, 13.1646995144131,\n                   13.5303856120357, 13.8960717096583, 14.2617578072809,\n                   14.6274439049035, 14.9931300025260, 15.3588161001486,\n                   15.7245021977712, 16.0901882953938, 16.4558743930164,\n                   16.8215604906390, 17.1872465882616, 17.5529326858841,\n                   17.9186187835067, 18.2843048811293, 18.6499909787519,\n                   19.0156770763745, 19.3813631739971, 19.7470492716197,\n                   20.1127353692422, 20.4784214668648, 20.8441075644874,\n                   21.2097936621100, 21.5754797597326, 21.9411658573552,\n                   22.3068519549778, 22.6725380526004, 23.0382241502229,\n                   23.4039102478455, 23.7695963454681, 24.1352824430907,\n                   24.5009685407133, 24.8666546383359, 25.2323407359585,\n                   25.5980268335810, 25.9637129312036, 26.3293990288262,\n                   26.6950851264488, 27.0607712240714, 27.4264573216940,\n                   27.7921434193166, 28.1578295169392, 28.5235156145617,\n                   28.8892017121843, 29.2548878098069, 29.6205739074295,\n                   29.9862600050521, 30.3519461026747, 30.7176322002973,\n                   31.0833182979198, 31.4490043955424, 31.8146904931650,\n                   32.1803765907876, 32.5460626884102, 32.9117487860328,\n                   33.2774348836554, 33.6431209812779, 34.0088070789005,\n                   34.3744931765231, 34.7401792741457, 35.1058653717683,\n                   35.4715514693909, 35.8372375670135, 36.2029236646360])\n    i2 = np.array([6.49218806928330, 6.49139336899548, 6.17810697175204,\n                   6.75197816263663, 6.59529074137515, 6.18164578868300,\n                   6.38709397931910, 6.30685422248427, 6.44640615548925,\n                   6.88727230397772, 6.42074852785591, 6.46348580823746,\n                   6.38642309763941, 5.66356277572311, 6.61010381702082,\n                   6.33288284311125, 6.22475343933610, 6.30651399433833,\n                   6.44435022944051, 6.43741711131908, 6.03536180208946,\n                   6.23814639328170, 5.97229140403242, 6.20790000748341,\n                   6.22933550182341, 6.22992127804882, 6.13400871899299,\n                   6.83491312449950, 6.07952797245846, 6.35837746415450,\n                   6.41972128662324, 6.85256717258275, 6.25807797296759,\n                   6.25124948151766, 6.22229212812413, 6.72249444167406,\n                   6.41085549981649, 6.75792874870056, 6.22096181559171,\n                   6.47839564388996, 6.56010208597432, 6.63300966556949,\n                   6.34617546039339, 6.79812221146153, 6.14486056194136,\n                   6.14979256889311, 6.16883037644880, 6.57309183229605,\n                   6.40064681038509, 6.18861448239873, 6.91340138179698,\n                   5.94164388433788, 6.23638991745862, 6.31898940411710,\n                   6.45247884556830, 6.58081455524297, 6.64915284801713,\n                   6.07122119270245, 6.41398258148256, 6.62144271089614,\n                   6.36377197712687, 6.51487678829345, 6.53418950147730,\n                   6.18886469125371, 6.26341063475750, 6.83488211680259,\n                   6.62699397226695, 6.41286837534735, 6.44060085001851,\n                   6.48114130629288, 6.18607038456406, 6.16923370572396,\n                   6.64223126283631, 6.07231852289266, 5.79043710204375,\n                   6.48463886529882, 6.36263392044401, 6.11212476454494,\n                   6.14573900812925, 6.12568047243240, 6.43836230231577,\n                   6.02505694060219, 6.13819468942244, 6.22100593815064,\n                   6.02394682666345, 5.89016573063789, 5.74448527739202,\n                   5.50415294280017, 5.31883018164157, 4.87476769510305,\n                   4.74386713755523, 4.60638346931628, 4.06177345572680,\n                   3.73334482123538, 3.13848311672243, 2.71638862600768,\n                   2.02963773590165, 1.49291145092070, 0.818343889647352, 0])\n\n    return v1, i1, v2, i2\n", "tokens": ["pvlib", "tests", "ivtools", "test_sde", "py", "def", "get_bad_iv_curves", "v1", "i1", "produces", "a", "bad", "value", "for", "i0_voc", "v1", "np", "array", "0", "0", "338798867469060", "0", "677597734938121", "1", "01639660240718", "1", "35519546987624", "1", "69399433734530", "2", "03279320481436", "2", "37159207228342", "2", "71039093975248", "3", "04918980722154", "3", "38798867469060", "3", "72678754215966", "4", "06558640962873", "4", "40438527709779", "4", "74318414456685", "5", "08198301203591", "5", "42078187950497", "5", "75958074697403", "6", "09837961444309", "6", "43717848191215", "6", "77597734938121", "7", "11477621685027", "7", "45357508431933", "7", "79237395178839", "8", "13117281925745", "8", "46997168672651", "8", "80877055419557", "9", "14756942166463", "9", "48636828913369", "9", "82516715660275", "10", "1639660240718", "10", "5027648915409", "10", "8415637590099", "11", "1803626264790", "11", "5191614939481", "11", "8579603614171", "12", "1967592288862", "12", "5355580963552", "12", "8743569638243", "13", "2131558312934", "13", "5519546987624", "13", "8907535662315", "14", "2295524337005", "14", "5683513011696", "14", "9071501686387", "15", "2459490361077", "15", "5847479035768", "15", "9235467710458", "16", "2623456385149", "16", "6011445059840", "16", "9399433734530", "17", "2787422409221", "17", "6175411083911", "17", "9563399758602", "18", "2951388433293", "18", "6339377107983", "18", "9727365782674", "19", "3115354457364", "19", "6503343132055", "19", "9891331806746", "20", "3279320481436", "20", "6667309156127", "21", "0055297830817", "21", "3443286505508", "21", "6831275180199", "22", "0219263854889", "22", "3607252529580", "22", "6995241204270", "23", "0383229878961", "23", "3771218553652", "23", "7159207228342", "24", "0547195903033", "24", "3935184577724", "24", "7323173252414", "25", "0711161927105", "25", "4099150601795", "25", "7487139276486", "26", "0875127951177", "26", "4263116625867", "26", "7651105300558", "27", "1039093975248", "27", "4427082649939", "27", "7815071324630", "28", "1203059999320", "28", "4591048674011", "28", "7979037348701", "29", "1367026023392", "29", "4755014698083", "29", "8143003372773", "30", "1530992047464", "30", "4918980722154", "30", "8306969396845", "31", "1694958071536", "31", "5082946746226", "31", "8470935420917", "32", "1858924095607", "32", "5246912770298", "32", "8634901444989", "33", "2022890119679", "33", "5410878794370", "i1", "np", "array", "3", "39430882774470", "2", "80864492110761", "3", "28358165429196", "3", "41191190551673", "3", "11975662808148", "3", "35436585834612", "3", "23953272899809", "3", "60307083325333", "2", "80478101508277", "2", "80505102853845", "3", "16918996870373", "3", "21088388439857", "3", "46332865310431", "3", "09224155015883", "3", "17541550741062", "3", "32470179290389", "3", "33224664316240", "3", "07709000050741", "2", "89141245343405", "3", "01365768561537", "3", "23265176770231", "3", "32253647634228", "2", "97900657569736", "3", "31959549243966", "3", "03375461550111", "2", "97579298978937", "3", "25432831375159", "2", "89178382564454", "3", "00341909207567", "3", "72637492250097", "3", "28379856976360", "2", "96516169245835", "3", "25658381110230", "3", "41655911533139", "3", "02718097944604", "3", "11458376760376", "3", "24617304369762", "3", "45935502367636", "3", "21557333256913", "3", "27611176482650", "2", "86954135732485", "3", "32416319254657", "3", "15277467598732", "3", "08272557013770", "3", "15602202666259", "3", "49432799877150", "3", "53863997177632", "3", "10602611478455", "3", "05373911151821", "3", "09876772570781", "2", "97417228624287", "2", "84573593699237", "3", "16288578405195", "3", "06533173612783", "3", "02118336639575", "3", "34374977225502", "2", "97255164138821", "3", "19286135682863", "3", "10999753817133", "3", "26925354620079", "3", "11957809501529", "3", "20155017481720", "3", "31724984405837", "3", "42879043512927", "3", "17933067619240", "3", "47777362613969", "3", "20708912539777", "3", "48205761174907", "3", "16804363684327", "3", "14055472378230", "3", "13445657434470", "2", "91152696252998", "3", "10984113847427", "2", "80443349399489", "3", "23146278164875", "2", "94521083406108", "3", "17388903141715", "3", "05930294897030", "3", "18985234673287", "3", "27946609274898", "3", "33717523113602", "2", "76394303462702", "3", "19375132937510", "2", "82628616689450", "2", "85238527394143", "2", "82975892599489", "2", "79196912313914", "2", "72860792049395", "2", "75585977414140", "2", "44280222448805", "2", "36052347370628", "2", "26785071765738", "2", "10868255743462", "2", "06165739407987", "1", "90047259509385", "1", "39925575828709", "1", "24749015957606", "0", "867823806536762", "0", "432752457749993", "0", "v2", "i2", "produces", "a", "bad", "value", "for", "i0_vmp", "v2", "np", "array", "0", "0", "365686097622586", "0", "731372195245173", "1", "09705829286776", "1", "46274439049035", "1", "82843048811293", "2", "19411658573552", "2", "55980268335810", "2", "92548878098069", "3", "29117487860328", "3", "65686097622586", "4", "02254707384845", "4", "38823317147104", "4", "75391926909362", "5", "11960536671621", "5", "48529146433880", "5", "85097756196138", "6", "21666365958397", "6", "58234975720655", "6", "94803585482914", "7", "31372195245173", "7", "67940805007431", "8", "04509414769690", "8", "41078024531949", "8", "77646634294207", "9", "14215244056466", "9", "50783853818725", "9", "87352463580983", "10", "2392107334324", "10", "6048968310550", "10", "9705829286776", "11", "3362690263002", "11", "7019551239228", "12", "0676412215454", "12", "4333273191679", "12", "7990134167905", "13", "1646995144131", "13", "5303856120357", "13", "8960717096583", "14", "2617578072809", "14", "6274439049035", "14", "9931300025260", "15", "3588161001486", "15", "7245021977712", "16", "0901882953938", "16", "4558743930164", "16", "8215604906390", "17", "1872465882616", "17", "5529326858841", "17", "9186187835067", "18", "2843048811293", "18", "6499909787519", "19", "0156770763745", "19", "3813631739971", "19", "7470492716197", "20", "1127353692422", "20", "4784214668648", "20", "8441075644874", "21", "2097936621100", "21", "5754797597326", "21", "9411658573552", "22", "3068519549778", "22", "6725380526004", "23", "0382241502229", "23", "4039102478455", "23", "7695963454681", "24", "1352824430907", "24", "5009685407133", "24", "8666546383359", "25", "2323407359585", "25", "5980268335810", "25", "9637129312036", "26", "3293990288262", "26", "6950851264488", "27", "0607712240714", "27", "4264573216940", "27", "7921434193166", "28", "1578295169392", "28", "5235156145617", "28", "8892017121843", "29", "2548878098069", "29", "6205739074295", "29", "9862600050521", "30", "3519461026747", "30", "7176322002973", "31", "0833182979198", "31", "4490043955424", "31", "8146904931650", "32", "1803765907876", "32", "5460626884102", "32", "9117487860328", "33", "2774348836554", "33", "6431209812779", "34", "0088070789005", "34", "3744931765231", "34", "7401792741457", "35", "1058653717683", "35", "4715514693909", "35", "8372375670135", "36", "2029236646360", "i2", "np", "array", "6", "49218806928330", "6", "49139336899548", "6", "17810697175204", "6", "75197816263663", "6", "59529074137515", "6", "18164578868300", "6", "38709397931910", "6", "30685422248427", "6", "44640615548925", "6", "88727230397772", "6", "42074852785591", "6", "46348580823746", "6", "38642309763941", "5", "66356277572311", "6", "61010381702082", "6", "33288284311125", "6", "22475343933610", "6", "30651399433833", "6", "44435022944051", "6", "43741711131908", "6", "03536180208946", "6", "23814639328170", "5", "97229140403242", "6", "20790000748341", "6", "22933550182341", "6", "22992127804882", "6", "13400871899299", "6", "83491312449950", "6", "07952797245846", "6", "35837746415450", "6", "41972128662324", "6", "85256717258275", "6", "25807797296759", "6", "25124948151766", "6", "22229212812413", "6", "72249444167406", "6", "41085549981649", "6", "75792874870056", "6", "22096181559171", "6", "47839564388996", "6", "56010208597432", "6", "63300966556949", "6", "34617546039339", "6", "79812221146153", "6", "14486056194136", "6", "14979256889311", "6", "16883037644880", "6", "57309183229605", "6", "40064681038509", "6", "18861448239873", "6", "91340138179698", "5", "94164388433788", "6", "23638991745862", "6", "31898940411710", "6", "45247884556830", "6", "58081455524297", "6", "64915284801713", "6", "07122119270245", "6", "41398258148256", "6", "62144271089614", "6", "36377197712687", "6", "51487678829345", "6", "53418950147730", "6", "18886469125371", "6", "26341063475750", "6", "83488211680259", "6", "62699397226695", "6", "41286837534735", "6", "44060085001851", "6", "48114130629288", "6", "18607038456406", "6", "16923370572396", "6", "64223126283631", "6", "07231852289266", "5", "79043710204375", "6", "48463886529882", "6", "36263392044401", "6", "11212476454494", "6", "14573900812925", "6", "12568047243240", "6", "43836230231577", "6", "02505694060219", "6", "13819468942244", "6", "22100593815064", "6", "02394682666345", "5", "89016573063789", "5", "74448527739202", "5", "50415294280017", "5", "31883018164157", "4", "87476769510305", "4", "74386713755523", "4", "60638346931628", "4", "06177345572680", "3", "73334482123538", "3", "13848311672243", "2", "71638862600768", "2", "02963773590165", "1", "49291145092070", "0", "818343889647352", "0", "return", "v1", "i1", "v2", "i2"], "doc_len": 836}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::get_test_iv_params", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "get_test_iv_params", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef get_test_iv_params():\n    return {'IL': 8.0, 'I0': 5e-10, 'Rsh': 1000, 'Rs': 0.2, 'nNsVth': 1.61864}\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "get_test_iv_params", "return", "il", "8", "0", "i0", "5e", "10", "rsh", "1000", "rs", "0", "2", "nnsvth", "1", "61864"], "doc_len": 22}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::cec_params_cansol_cs5p_220p", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "cec_params_cansol_cs5p_220p", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef cec_params_cansol_cs5p_220p():\n    return {'ivcurve': {'V_mp_ref': 46.6, 'I_mp_ref': 4.73, 'V_oc_ref': 58.3,\n                        'I_sc_ref': 5.05},\n            'specs': {'alpha_sc': 0.0025, 'beta_voc': -0.19659,\n                      'gamma_pmp': -0.43, 'cells_in_series': 96},\n            'params': {'I_L_ref': 5.056, 'I_o_ref': 1.01e-10,\n                       'R_sh_ref': 837.51, 'R_s': 1.004, 'a_ref': 2.3674,\n                       'Adjust': 2.3}}\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "cec_params_cansol_cs5p_220p", "return", "ivcurve", "v_mp_ref", "46", "6", "i_mp_ref", "4", "73", "v_oc_ref", "58", "3", "i_sc_ref", "5", "05", "specs", "alpha_sc", "0", "0025", "beta_voc", "0", "19659", "gamma_pmp", "0", "43", "cells_in_series", "96", "params", "i_l_ref", "5", "056", "i_o_ref", "1", "01e", "10", "r_sh_ref", "837", "51", "r_s", "1", "004", "a_ref", "2", "3674", "adjust", "2", "3"], "doc_len": 53}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_cec_sam", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_cec_sam", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_cec_sam(cec_params_cansol_cs5p_220p):\n    input_data = cec_params_cansol_cs5p_220p['ivcurve']\n    specs = cec_params_cansol_cs5p_220p['specs']\n    I_L_ref, I_o_ref, R_s, R_sh_ref, a_ref, Adjust = \\\n        sdm.fit_cec_sam(\n            celltype='polySi', v_mp=input_data['V_mp_ref'],\n            i_mp=input_data['I_mp_ref'], v_oc=input_data['V_oc_ref'],\n            i_sc=input_data['I_sc_ref'], alpha_sc=specs['alpha_sc'],\n            beta_voc=specs['beta_voc'],\n            gamma_pmp=specs['gamma_pmp'],\n            cells_in_series=specs['cells_in_series'])\n    expected = pd.Series(cec_params_cansol_cs5p_220p['params'])\n    modeled = pd.Series(index=expected.index, data=np.nan)\n    modeled['a_ref'] = a_ref\n    modeled['I_L_ref'] = I_L_ref\n    modeled['I_o_ref'] = I_o_ref\n    modeled['R_s'] = R_s\n    modeled['R_sh_ref'] = R_sh_ref\n    modeled['Adjust'] = Adjust\n    assert np.allclose(modeled.values, expected.values, rtol=5e-2)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_cec_sam", "cec_params_cansol_cs5p_220p", "input_data", "cec_params_cansol_cs5p_220p", "ivcurve", "specs", "cec_params_cansol_cs5p_220p", "specs", "i_l_ref", "i_o_ref", "r_s", "r_sh_ref", "a_ref", "adjust", "sdm", "fit_cec_sam", "celltype", "polysi", "v_mp", "input_data", "v_mp_ref", "i_mp", "input_data", "i_mp_ref", "v_oc", "input_data", "v_oc_ref", "i_sc", "input_data", "i_sc_ref", "alpha_sc", "specs", "alpha_sc", "beta_voc", "specs", "beta_voc", "gamma_pmp", "specs", "gamma_pmp", "cells_in_series", "specs", "cells_in_series", "expected", "pd", "series", "cec_params_cansol_cs5p_220p", "params", "modeled", "pd", "series", "index", "expected", "index", "data", "np", "nan", "modeled", "a_ref", "a_ref", "modeled", "i_l_ref", "i_l_ref", "modeled", "i_o_ref", "i_o_ref", "modeled", "r_s", "r_s", "modeled", "r_sh_ref", "r_sh_ref", "modeled", "adjust", "adjust", "assert", "np", "allclose", "modeled", "values", "expected", "values", "rtol", "5e", "2"], "doc_len": 90}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_cec_sam_estimation_failure", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_cec_sam_estimation_failure", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_cec_sam_estimation_failure(cec_params_cansol_cs5p_220p):\n    # Failing to estimate the parameters for the CEC SDM model should raise an\n    # exception.\n    with pytest.raises(RuntimeError):\n        sdm.fit_cec_sam(celltype='polySi', v_mp=0.45, i_mp=5.25, v_oc=0.55,\n                        i_sc=5.5, alpha_sc=0.00275, beta_voc=0.00275,\n                        gamma_pmp=0.0055, cells_in_series=1, temp_ref=25)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_cec_sam_estimation_failure", "cec_params_cansol_cs5p_220p", "failing", "to", "estimate", "the", "parameters", "for", "the", "cec", "sdm", "model", "should", "raise", "an", "exception", "with", "pytest", "raises", "runtimeerror", "sdm", "fit_cec_sam", "celltype", "polysi", "v_mp", "0", "45", "i_mp", "5", "25", "v_oc", "0", "55", "i_sc", "5", "5", "alpha_sc", "0", "00275", "beta_voc", "0", "00275", "gamma_pmp", "0", "0055", "cells_in_series", "1", "temp_ref", "25"], "doc_len": 55}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_desoto", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_desoto", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_desoto():\n    result, _ = sdm.fit_desoto(v_mp=31.0, i_mp=8.71, v_oc=38.3, i_sc=9.43,\n                               alpha_sc=0.005658, beta_voc=-0.13788,\n                               cells_in_series=60)\n    result_expected = {'I_L_ref': 9.45232,\n                       'I_o_ref': 3.22460e-10,\n                       'R_s': 0.297814,\n                       'R_sh_ref': 125.798,\n                       'a_ref': 1.59128,\n                       'alpha_sc': 0.005658,\n                       'EgRef': 1.121,\n                       'dEgdT': -0.0002677,\n                       'irrad_ref': 1000,\n                       'temp_ref': 25}\n    assert np.allclose(pd.Series(result), pd.Series(result_expected),\n                       rtol=1e-4)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_desoto", "result", "_", "sdm", "fit_desoto", "v_mp", "31", "0", "i_mp", "8", "71", "v_oc", "38", "3", "i_sc", "9", "43", "alpha_sc", "0", "005658", "beta_voc", "0", "13788", "cells_in_series", "60", "result_expected", "i_l_ref", "9", "45232", "i_o_ref", "3", "22460e", "10", "r_s", "0", "297814", "r_sh_ref", "125", "798", "a_ref", "1", "59128", "alpha_sc", "0", "005658", "egref", "1", "121", "degdt", "0", "0002677", "irrad_ref", "1000", "temp_ref", "25", "assert", "np", "allclose", "pd", "series", "result", "pd", "series", "result_expected", "rtol", "1e", "4"], "doc_len": 73}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_desoto_failure", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_desoto_failure", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_desoto_failure():\n    with pytest.raises(RuntimeError) as exc:\n        sdm.fit_desoto(v_mp=31.0, i_mp=8.71, v_oc=38.3, i_sc=9.43,\n                       alpha_sc=0.005658, beta_voc=-0.13788,\n                       cells_in_series=10)\n    assert ('Parameter estimation failed') in str(exc.value)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_desoto_failure", "with", "pytest", "raises", "runtimeerror", "as", "exc", "sdm", "fit_desoto", "v_mp", "31", "0", "i_mp", "8", "71", "v_oc", "38", "3", "i_sc", "9", "43", "alpha_sc", "0", "005658", "beta_voc", "0", "13788", "cells_in_series", "10", "assert", "parameter", "estimation", "failed", "in", "str", "exc", "value"], "doc_len": 43}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_desoto_sandia", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_desoto_sandia", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_desoto_sandia(cec_params_cansol_cs5p_220p):\n    # this test computes a set of IV curves for the input fixture, fits\n    # the De Soto model to the calculated IV curves, and compares the fitted\n    # parameters to the starting values\n    params = cec_params_cansol_cs5p_220p['params']\n    params.pop('Adjust')\n    specs = cec_params_cansol_cs5p_220p['specs']\n    effective_irradiance = np.array([400., 500., 600., 700., 800., 900.,\n                                     1000.])\n    temp_cell = np.array([15., 25., 35., 45.])\n    ee = np.tile(effective_irradiance, len(temp_cell))\n    tc = np.repeat(temp_cell, len(effective_irradiance))\n    iph, io, rs, rsh, nnsvth = pvsystem.calcparams_desoto(\n        ee, tc, alpha_sc=specs['alpha_sc'], **params)\n    sim_ivcurves = pvsystem.singlediode(iph, io, rs, rsh, nnsvth, 300)\n    sim_ivcurves['ee'] = ee\n    sim_ivcurves['tc'] = tc\n\n    result = sdm.fit_desoto_sandia(sim_ivcurves, specs)\n    modeled = pd.Series(index=params.keys(), data=np.nan)\n    modeled['a_ref'] = result['a_ref']\n    modeled['I_L_ref'] = result['I_L_ref']\n    modeled['I_o_ref'] = result['I_o_ref']\n    modeled['R_s'] = result['R_s']\n    modeled['R_sh_ref'] = result['R_sh_ref']\n    expected = pd.Series(params)\n    assert np.allclose(modeled[params.keys()].values,\n                       expected[params.keys()].values, rtol=5e-2)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_desoto_sandia", "cec_params_cansol_cs5p_220p", "this", "test", "computes", "a", "set", "of", "iv", "curves", "for", "the", "input", "fixture", "fits", "the", "de", "soto", "model", "to", "the", "calculated", "iv", "curves", "and", "compares", "the", "fitted", "parameters", "to", "the", "starting", "values", "params", "cec_params_cansol_cs5p_220p", "params", "params", "pop", "adjust", "specs", "cec_params_cansol_cs5p_220p", "specs", "effective_irradiance", "np", "array", "400", "500", "600", "700", "800", "900", "1000", "temp_cell", "np", "array", "15", "25", "35", "45", "ee", "np", "tile", "effective_irradiance", "len", "temp_cell", "tc", "np", "repeat", "temp_cell", "len", "effective_irradiance", "iph", "io", "rs", "rsh", "nnsvth", "pvsystem", "calcparams_desoto", "ee", "tc", "alpha_sc", "specs", "alpha_sc", "params", "sim_ivcurves", "pvsystem", "singlediode", "iph", "io", "rs", "rsh", "nnsvth", "300", "sim_ivcurves", "ee", "ee", "sim_ivcurves", "tc", "tc", "result", "sdm", "fit_desoto_sandia", "sim_ivcurves", "specs", "modeled", "pd", "series", "index", "params", "keys", "data", "np", "nan", "modeled", "a_ref", "result", "a_ref", "modeled", "i_l_ref", "result", "i_l_ref", "modeled", "i_o_ref", "result", "i_o_ref", "modeled", "r_s", "result", "r_s", "modeled", "r_sh_ref", "result", "r_sh_ref", "expected", "pd", "series", "params", "assert", "np", "allclose", "modeled", "params", "keys", "values", "expected", "params", "keys", "values", "rtol", "5e", "2"], "doc_len": 157}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::_read_iv_curves_for_test", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "_read_iv_curves_for_test", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef _read_iv_curves_for_test(datafile, npts):\n    \"\"\" read constants and npts IV curves from datafile \"\"\"\n    iv_specs = dict.fromkeys(['cells_in_series', 'alpha_sc', 'beta_voc',\n                              'descr'])\n    ivcurves = dict.fromkeys(['i_sc', 'i_mp', 'v_mp', 'v_oc', 'poa', 'tc',\n                              'ee'])\n\n    infilen = DATA_DIR / datafile\n    with infilen.open(mode='r') as f:\n\n        Ns, aIsc, bVoc, descr = f.readline().split(',')\n\n        iv_specs.update(\n            cells_in_series=int(Ns), alpha_sc=float(aIsc),\n            beta_voc=float(bVoc), descr=descr)\n\n        strN, strM = f.readline().split(',')\n        N = int(strN)\n        M = int(strM)\n\n        isc = np.empty(N)\n        imp = np.empty(N)\n        vmp = np.empty(N)\n        voc = np.empty(N)\n        ee = np.empty(N)\n        poa = np.empty(N)\n        tc = np.empty(N)\n        v = np.empty((N, M))\n        i = np.empty((N, M))\n        v[:] = np.nan  # fill with nan\n        i[:] = np.nan\n\n        for k in range(N):\n            tmp = (float(x) for x in f.readline().split(','))\n            isc[k], imp[k], vmp[k], voc[k], poa[k], tc[k], ee[k] = tmp\n            # read voltage and current\n            tmp = [float(x) for x in f.readline().split(',')]\n            while len(tmp) < M:\n                tmp.append(np.nan)\n            v[k, :] = tmp\n            tmp = [float(x) for x in f.readline().split(',')]\n            while len(tmp) < M:\n                tmp.append(np.nan)\n            i[k, :] = tmp\n\n    ivcurves['i_sc'] = isc[:npts]\n    ivcurves['i_mp'] = imp[:npts]\n    ivcurves['v_oc'] = voc[:npts]\n    ivcurves['v_mp'] = vmp[:npts]\n    ivcurves['ee'] = ee[:npts]\n    ivcurves['tc'] = tc[:npts]\n    ivcurves['v'] = v[:npts]\n    ivcurves['i'] = i[:npts]\n    ivcurves['p_mp'] = ivcurves['v_mp'] * ivcurves['i_mp']  # power\n\n    return iv_specs, ivcurves\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "_read_iv_curves_for_test", "datafile", "npts", "read", "constants", "and", "npts", "iv", "curves", "from", "datafile", "iv_specs", "dict", "fromkeys", "cells_in_series", "alpha_sc", "beta_voc", "descr", "ivcurves", "dict", "fromkeys", "i_sc", "i_mp", "v_mp", "v_oc", "poa", "tc", "ee", "infilen", "data_dir", "datafile", "with", "infilen", "open", "mode", "r", "as", "f", "ns", "aisc", "bvoc", "descr", "f", "readline", "split", "iv_specs", "update", "cells_in_series", "int", "ns", "alpha_sc", "float", "aisc", "beta_voc", "float", "bvoc", "descr", "descr", "strn", "strm", "f", "readline", "split", "n", "int", "strn", "m", "int", "strm", "isc", "np", "empty", "n", "imp", "np", "empty", "n", "vmp", "np", "empty", "n", "voc", "np", "empty", "n", "ee", "np", "empty", "n", "poa", "np", "empty", "n", "tc", "np", "empty", "n", "v", "np", "empty", "n", "m", "i", "np", "empty", "n", "m", "v", "np", "nan", "fill", "with", "nan", "i", "np", "nan", "for", "k", "in", "range", "n", "tmp", "float", "x", "for", "x", "in", "f", "readline", "split", "isc", "k", "imp", "k", "vmp", "k", "voc", "k", "poa", "k", "tc", "k", "ee", "k", "tmp", "read", "voltage", "and", "current", "tmp", "float", "x", "for", "x", "in", "f", "readline", "split", "while", "len", "tmp", "m", "tmp", "append", "np", "nan", "v", "k", "tmp", "tmp", "float", "x", "for", "x", "in", "f", "readline", "split", "while", "len", "tmp", "m", "tmp", "append", "np", "nan", "i", "k", "tmp", "ivcurves", "i_sc", "isc", "npts", "ivcurves", "i_mp", "imp", "npts", "ivcurves", "v_oc", "voc", "npts", "ivcurves", "v_mp", "vmp", "npts", "ivcurves", "ee", "ee", "npts", "ivcurves", "tc", "tc", "npts", "ivcurves", "v", "v", "npts", "ivcurves", "i", "i", "npts", "ivcurves", "p_mp", "ivcurves", "v_mp", "ivcurves", "i_mp", "power", "return", "iv_specs", "ivcurves"], "doc_len": 237}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::_read_pvsyst_expected", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "_read_pvsyst_expected", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef _read_pvsyst_expected(datafile):\n    \"\"\" Read Pvsyst model parameters and diode equation values for each\n    IV curve\n    \"\"\"\n    pvsyst_specs = dict.fromkeys(['cells_in_series', 'alpha_sc', 'beta_voc',\n                                  'descr'])\n    # order required to match file being read\n    paramlist = [\n        'I_L_ref', 'I_o_ref', 'EgRef', 'R_sh_ref', 'R_sh_0', 'R_sh_exp', 'R_s',\n        'gamma_ref', 'mu_gamma']\n    varlist = ['iph', 'io', 'rs', 'rsh', 'u']\n    pvsyst = dict.fromkeys(paramlist + varlist)\n\n    infilen = DATA_DIR / datafile\n    with infilen.open(mode='r') as f:\n\n        Ns, aIsc, bVoc, descr = f.readline().split(',')\n\n        pvsyst_specs.update(\n            cells_in_series=int(Ns), alpha_sc=float(aIsc),\n            beta_voc=float(bVoc), descr=descr)\n\n        tmp = [float(x) for x in f.readline().split(',')]\n        # I_L_ref, I_o_ref, EgRef, R_s, R_sh_ref, R_sh_0, R_sh_exp, gamma_ref,\n        # mu_gamma\n        pvsyst.update(zip(paramlist, tmp))\n\n        strN = f.readline()\n        N = int(strN)\n\n        Iph = np.empty(N)\n        Io = np.empty(N)\n        Rsh = np.empty(N)\n        Rs = np.empty(N)\n        u = np.empty(N)\n\n        for k in range(N):\n            tmp = [float(x) for x in f.readline().split(',')]\n            Iph[k], Io[k], Rsh[k], Rs[k], u[k] = tmp\n\n    pvsyst.update(zip(varlist, [Iph, Io, Rs, Rsh, u]))\n\n    return pvsyst_specs, pvsyst\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "_read_pvsyst_expected", "datafile", "read", "pvsyst", "model", "parameters", "and", "diode", "equation", "values", "for", "each", "iv", "curve", "pvsyst_specs", "dict", "fromkeys", "cells_in_series", "alpha_sc", "beta_voc", "descr", "order", "required", "to", "match", "file", "being", "read", "paramlist", "i_l_ref", "i_o_ref", "egref", "r_sh_ref", "r_sh_0", "r_sh_exp", "r_s", "gamma_ref", "mu_gamma", "varlist", "iph", "io", "rs", "rsh", "u", "pvsyst", "dict", "fromkeys", "paramlist", "varlist", "infilen", "data_dir", "datafile", "with", "infilen", "open", "mode", "r", "as", "f", "ns", "aisc", "bvoc", "descr", "f", "readline", "split", "pvsyst_specs", "update", "cells_in_series", "int", "ns", "alpha_sc", "float", "aisc", "beta_voc", "float", "bvoc", "descr", "descr", "tmp", "float", "x", "for", "x", "in", "f", "readline", "split", "i_l_ref", "i_o_ref", "egref", "r_s", "r_sh_ref", "r_sh_0", "r_sh_exp", "gamma_ref", "mu_gamma", "pvsyst", "update", "zip", "paramlist", "tmp", "strn", "f", "readline", "n", "int", "strn", "iph", "np", "empty", "n", "io", "np", "empty", "n", "rsh", "np", "empty", "n", "rs", "np", "empty", "n", "u", "np", "empty", "n", "for", "k", "in", "range", "n", "tmp", "float", "x", "for", "x", "in", "f", "readline", "split", "iph", "k", "io", "k", "rsh", "k", "rs", "k", "u", "k", "tmp", "pvsyst", "update", "zip", "varlist", "iph", "io", "rs", "rsh", "u", "return", "pvsyst_specs", "pvsyst"], "doc_len": 171}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_fit_pvsyst_sandia", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_fit_pvsyst_sandia", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_fit_pvsyst_sandia(npts=3000):\n\n    # get IV curve data\n    iv_specs, ivcurves = _read_iv_curves_for_test('PVsyst_demo.csv', npts)\n\n    # get known Pvsyst model parameters and five parameters from each fitted\n    # IV curve\n    pvsyst_specs, pvsyst = _read_pvsyst_expected('PVsyst_demo_model.csv')\n\n    modeled = sdm.fit_pvsyst_sandia(ivcurves, iv_specs)\n\n    # calculate IV curves using the fitted model, for comparison with input\n    # IV curves\n    param_res = pvsystem.calcparams_pvsyst(\n        effective_irradiance=ivcurves['ee'], temp_cell=ivcurves['tc'],\n        alpha_sc=iv_specs['alpha_sc'], gamma_ref=modeled['gamma_ref'],\n        mu_gamma=modeled['mu_gamma'], I_L_ref=modeled['I_L_ref'],\n        I_o_ref=modeled['I_o_ref'], R_sh_ref=modeled['R_sh_ref'],\n        R_sh_0=modeled['R_sh_0'], R_s=modeled['R_s'],\n        cells_in_series=iv_specs['cells_in_series'], EgRef=modeled['EgRef'])\n    iv_res = pvsystem.singlediode(*param_res)\n\n    # assertions\n    assert np.allclose(\n        ivcurves['p_mp'], iv_res['p_mp'], equal_nan=True, rtol=0.038)\n    assert np.allclose(\n        ivcurves['v_mp'], iv_res['v_mp'], equal_nan=True, rtol=0.029)\n    assert np.allclose(\n        ivcurves['i_mp'], iv_res['i_mp'], equal_nan=True, rtol=0.021)\n    assert np.allclose(\n        ivcurves['i_sc'], iv_res['i_sc'], equal_nan=True, rtol=0.003)\n    assert np.allclose(\n        ivcurves['v_oc'], iv_res['v_oc'], equal_nan=True, rtol=0.019)\n    # cells_in_series, alpha_sc, beta_voc, descr\n    assert all((iv_specs[k] == pvsyst_specs[k]) for k in iv_specs.keys())\n    # I_L_ref, I_o_ref, EgRef, R_sh_ref, R_sh_0, R_sh_exp, R_s, gamma_ref,\n    # mu_gamma\n    assert np.isclose(modeled['I_L_ref'], pvsyst['I_L_ref'], rtol=6.5e-5)\n    assert np.isclose(modeled['I_o_ref'], pvsyst['I_o_ref'], rtol=0.15)\n    assert np.isclose(modeled['R_s'], pvsyst['R_s'], rtol=0.0035)\n    assert np.isclose(modeled['R_sh_ref'], pvsyst['R_sh_ref'], rtol=0.091)\n    assert np.isclose(modeled['R_sh_0'], pvsyst['R_sh_0'], rtol=0.013)\n    assert np.isclose(modeled['EgRef'], pvsyst['EgRef'], rtol=0.037)\n    assert np.isclose(modeled['gamma_ref'], pvsyst['gamma_ref'], rtol=0.0045)\n    assert np.isclose(modeled['mu_gamma'], pvsyst['mu_gamma'], rtol=0.064)\n\n    # Iph, Io, Rsh, Rs, u\n    mask = np.ones(modeled['u'].shape, dtype=bool)\n    # exclude one curve with different convergence\n    umask = mask.copy()\n    umask[2540] = False\n    assert all(modeled['u'][umask] == pvsyst['u'][:npts][umask])\n    assert np.allclose(\n        modeled['iph'][modeled['u']], pvsyst['iph'][:npts][modeled['u']],\n        equal_nan=True, rtol=0.0009)\n    assert np.allclose(\n        modeled['io'][modeled['u']], pvsyst['io'][:npts][modeled['u']],\n        equal_nan=True, rtol=0.096)\n    assert np.allclose(\n        modeled['rs'][modeled['u']], pvsyst['rs'][:npts][modeled['u']],\n        equal_nan=True, rtol=0.035)\n    # exclude one curve with Rsh outside 63% tolerance\n    rshmask = modeled['u'].copy()\n    rshmask[2545] = False\n    assert np.allclose(\n        modeled['rsh'][rshmask], pvsyst['rsh'][:npts][rshmask],\n        equal_nan=True, rtol=0.63)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_fit_pvsyst_sandia", "npts", "3000", "get", "iv", "curve", "data", "iv_specs", "ivcurves", "_read_iv_curves_for_test", "pvsyst_demo", "csv", "npts", "get", "known", "pvsyst", "model", "parameters", "and", "five", "parameters", "from", "each", "fitted", "iv", "curve", "pvsyst_specs", "pvsyst", "_read_pvsyst_expected", "pvsyst_demo_model", "csv", "modeled", "sdm", "fit_pvsyst_sandia", "ivcurves", "iv_specs", "calculate", "iv", "curves", "using", "the", "fitted", "model", "for", "comparison", "with", "input", "iv", "curves", "param_res", "pvsystem", "calcparams_pvsyst", "effective_irradiance", "ivcurves", "ee", "temp_cell", "ivcurves", "tc", "alpha_sc", "iv_specs", "alpha_sc", "gamma_ref", "modeled", "gamma_ref", "mu_gamma", "modeled", "mu_gamma", "i_l_ref", "modeled", "i_l_ref", "i_o_ref", "modeled", "i_o_ref", "r_sh_ref", "modeled", "r_sh_ref", "r_sh_0", "modeled", "r_sh_0", "r_s", "modeled", "r_s", "cells_in_series", "iv_specs", "cells_in_series", "egref", "modeled", "egref", "iv_res", "pvsystem", "singlediode", "param_res", "assertions", "assert", "np", "allclose", "ivcurves", "p_mp", "iv_res", "p_mp", "equal_nan", "true", "rtol", "0", "038", "assert", "np", "allclose", "ivcurves", "v_mp", "iv_res", "v_mp", "equal_nan", "true", "rtol", "0", "029", "assert", "np", "allclose", "ivcurves", "i_mp", "iv_res", "i_mp", "equal_nan", "true", "rtol", "0", "021", "assert", "np", "allclose", "ivcurves", "i_sc", "iv_res", "i_sc", "equal_nan", "true", "rtol", "0", "003", "assert", "np", "allclose", "ivcurves", "v_oc", "iv_res", "v_oc", "equal_nan", "true", "rtol", "0", "019", "cells_in_series", "alpha_sc", "beta_voc", "descr", "assert", "all", "iv_specs", "k", "pvsyst_specs", "k", "for", "k", "in", "iv_specs", "keys", "i_l_ref", "i_o_ref", "egref", "r_sh_ref", "r_sh_0", "r_sh_exp", "r_s", "gamma_ref", "mu_gamma", "assert", "np", "isclose", "modeled", "i_l_ref", "pvsyst", "i_l_ref", "rtol", "6", "5e", "5", "assert", "np", "isclose", "modeled", "i_o_ref", "pvsyst", "i_o_ref", "rtol", "0", "15", "assert", "np", "isclose", "modeled", "r_s", "pvsyst", "r_s", "rtol", "0", "0035", "assert", "np", "isclose", "modeled", "r_sh_ref", "pvsyst", "r_sh_ref", "rtol", "0", "091", "assert", "np", "isclose", "modeled", "r_sh_0", "pvsyst", "r_sh_0", "rtol", "0", "013", "assert", "np", "isclose", "modeled", "egref", "pvsyst", "egref", "rtol", "0", "037", "assert", "np", "isclose", "modeled", "gamma_ref", "pvsyst", "gamma_ref", "rtol", "0", "0045", "assert", "np", "isclose", "modeled", "mu_gamma", "pvsyst", "mu_gamma", "rtol", "0", "064", "iph", "io", "rsh", "rs", "u", "mask", "np", "ones", "modeled", "u", "shape", "dtype", "bool", "exclude", "one", "curve", "with", "different", "convergence", "umask", "mask", "copy", "umask", "2540", "false", "assert", "all", "modeled", "u", "umask", "pvsyst", "u", "npts", "umask", "assert", "np", "allclose", "modeled", "iph", "modeled", "u", "pvsyst", "iph", "npts", "modeled", "u", "equal_nan", "true", "rtol", "0", "0009", "assert", "np", "allclose", "modeled", "io", "modeled", "u", "pvsyst", "io", "npts", "modeled", "u", "equal_nan", "true", "rtol", "0", "096", "assert", "np", "allclose", "modeled", "rs", "modeled", "u", "pvsyst", "rs", "npts", "modeled", "u", "equal_nan", "true", "rtol", "0", "035", "exclude", "one", "curve", "with", "rsh", "outside", "63", "tolerance", "rshmask", "modeled", "u", "copy", "rshmask", "2545", "false", "assert", "np", "allclose", "modeled", "rsh", "rshmask", "pvsyst", "rsh", "npts", "rshmask", "equal_nan", "true", "rtol", "0", "63"], "doc_len": 379}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__update_rsh_fixed_pt_nans", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__update_rsh_fixed_pt_nans", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__update_rsh_fixed_pt_nans(vmp, imp, iph, io, rs, rsh, nnsvth,\n                                   expected):\n    outrsh = sdm._update_rsh_fixed_pt(vmp, imp, iph, io, rs, rsh, nnsvth)\n    assert np.all(np.isnan(outrsh))\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__update_rsh_fixed_pt_nans", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "expected", "outrsh", "sdm", "_update_rsh_fixed_pt", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "assert", "np", "all", "np", "isnan", "outrsh"], "doc_len": 31}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__update_rsh_fixed_pt_vmp0", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__update_rsh_fixed_pt_vmp0", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__update_rsh_fixed_pt_vmp0():\n    outrsh = sdm._update_rsh_fixed_pt(vmp=0., imp=2., iph=2., io=2., rs=2.,\n                                      rsh=2., nnsvth=2.)\n    assert_allclose(outrsh, np.array([502.]), atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__update_rsh_fixed_pt_vmp0", "outrsh", "sdm", "_update_rsh_fixed_pt", "vmp", "0", "imp", "2", "iph", "2", "io", "2", "rs", "2", "rsh", "2", "nnsvth", "2", "assert_allclose", "outrsh", "np", "array", "502", "atol", "0001"], "doc_len": 31}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__update_rsh_fixed_pt_vector", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__update_rsh_fixed_pt_vector", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__update_rsh_fixed_pt_vector():\n    outrsh = sdm._update_rsh_fixed_pt(rsh=np.array([-1., 3, .5, 2.]),\n                                      rs=np.array([1., -.5, 2., 2.]),\n                                      io=np.array([.2, .3, -.4, 2.]),\n                                      iph=np.array([-.1, 1, 3., 2.]),\n                                      nnsvth=np.array([4., -.2, .1, 2.]),\n                                      imp=np.array([.2, .2, -1., 2.]),\n                                      vmp=np.array([0., -1, 0., 0.]))\n    assert np.all(np.isnan(outrsh[0:3]))\n    assert_allclose(outrsh[3], np.array([502.]), atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__update_rsh_fixed_pt_vector", "outrsh", "sdm", "_update_rsh_fixed_pt", "rsh", "np", "array", "1", "3", "5", "2", "rs", "np", "array", "1", "5", "2", "2", "io", "np", "array", "2", "3", "4", "2", "iph", "np", "array", "1", "1", "3", "2", "nnsvth", "np", "array", "4", "2", "1", "2", "imp", "np", "array", "2", "2", "1", "2", "vmp", "np", "array", "0", "1", "0", "0", "assert", "np", "all", "np", "isnan", "outrsh", "0", "3", "assert_allclose", "outrsh", "3", "np", "array", "502", "atol", "0001"], "doc_len": 75}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__update_io", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__update_io", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__update_io(voc, iph, io, rs, rsh, nnsvth, expected):\n    outio = sdm._update_io(voc, iph, io, rs, rsh, nnsvth)\n    assert_allclose(outio, expected, atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__update_io", "voc", "iph", "io", "rs", "rsh", "nnsvth", "expected", "outio", "sdm", "_update_io", "voc", "iph", "io", "rs", "rsh", "nnsvth", "assert_allclose", "outio", "expected", "atol", "0001"], "doc_len": 28}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__update_io_nan", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__update_io_nan", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__update_io_nan(voc, iph, io, rs, rsh, nnsvth):\n    outio = sdm._update_io(voc, iph, io, rs, rsh, nnsvth)\n    assert np.isnan(outio)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__update_io_nan", "voc", "iph", "io", "rs", "rsh", "nnsvth", "outio", "sdm", "_update_io", "voc", "iph", "io", "rs", "rsh", "nnsvth", "assert", "np", "isnan", "outio"], "doc_len": 26}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__calc_theta_phi_exact", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__calc_theta_phi_exact", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__calc_theta_phi_exact(vmp, imp, iph, io, rs, rsh, nnsvth, expected):\n    theta, phi = sdm._calc_theta_phi_exact(vmp, imp, iph, io, rs, rsh, nnsvth)\n    assert_allclose(theta, expected[0], atol=.0001)\n    assert_allclose(phi, expected[1], atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__calc_theta_phi_exact", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "expected", "theta", "phi", "sdm", "_calc_theta_phi_exact", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "assert_allclose", "theta", "expected", "0", "atol", "0001", "assert_allclose", "phi", "expected", "1", "atol", "0001"], "doc_len": 38}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__calc_theta_phi_exact_both_nan", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__calc_theta_phi_exact_both_nan", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__calc_theta_phi_exact_both_nan(vmp, imp, iph, io, rs, rsh, nnsvth):\n    theta, phi = sdm._calc_theta_phi_exact(vmp, imp, iph, io, rs, rsh, nnsvth)\n    assert np.isnan(theta)\n    assert np.isnan(phi)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__calc_theta_phi_exact_both_nan", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "theta", "phi", "sdm", "_calc_theta_phi_exact", "vmp", "imp", "iph", "io", "rs", "rsh", "nnsvth", "assert", "np", "isnan", "theta", "assert", "np", "isnan", "phi"], "doc_len": 33}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__calc_theta_phi_exact_one_nan", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__calc_theta_phi_exact_one_nan", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__calc_theta_phi_exact_one_nan():\n    theta, phi = sdm._calc_theta_phi_exact(imp=2., iph=2., vmp=2., io=2.,\n                                           nnsvth=2., rs=0., rsh=2.)\n    assert np.isnan(theta)\n    assert_allclose(phi, 2., atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__calc_theta_phi_exact_one_nan", "theta", "phi", "sdm", "_calc_theta_phi_exact", "imp", "2", "iph", "2", "vmp", "2", "io", "2", "nnsvth", "2", "rs", "0", "rsh", "2", "assert", "np", "isnan", "theta", "assert_allclose", "phi", "2", "atol", "0001"], "doc_len": 34}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test__calc_theta_phi_exact_vector", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test__calc_theta_phi_exact_vector", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test__calc_theta_phi_exact_vector():\n    theta, phi = sdm._calc_theta_phi_exact(imp=np.array([1., -1.]),\n                                           iph=np.array([-1., 1.]),\n                                           vmp=np.array([1., -1.]),\n                                           io=np.array([-1., 1.]),\n                                           nnsvth=np.array([1., -1.]),\n                                           rs=np.array([-1., 1.]),\n                                           rsh=np.array([1., -1.]))\n    assert np.isnan(theta[0])\n    assert np.isnan(theta[1])\n    assert np.isnan(phi[0])\n    assert_allclose(phi[1], 2.2079, atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test__calc_theta_phi_exact_vector", "theta", "phi", "sdm", "_calc_theta_phi_exact", "imp", "np", "array", "1", "1", "iph", "np", "array", "1", "1", "vmp", "np", "array", "1", "1", "io", "np", "array", "1", "1", "nnsvth", "np", "array", "1", "1", "rs", "np", "array", "1", "1", "rsh", "np", "array", "1", "1", "assert", "np", "isnan", "theta", "0", "assert", "np", "isnan", "theta", "1", "assert", "np", "isnan", "phi", "0", "assert_allclose", "phi", "1", "2", "2079", "atol", "0001"], "doc_len": 68}
{"doc_id": "pvlib/tests/ivtools/test_sdm.py::test_pvsyst_temperature_coeff", "file_path": "pvlib/tests/ivtools/test_sdm.py", "class_name": null, "func_name": "test_pvsyst_temperature_coeff", "text": "文件路径: pvlib/tests/ivtools/test_sdm.py\ndef test_pvsyst_temperature_coeff():\n    # test for consistency with dP/dT estimated with secant rule\n    params = {'alpha_sc': 0., 'gamma_ref': 1.1, 'mu_gamma': 0.,\n              'I_L_ref': 6., 'I_o_ref': 5.e-9, 'R_sh_ref': 200.,\n              'R_sh_0': 2000., 'R_s': 0.5, 'cells_in_series': 60}\n    expected = -0.004886706494879083\n    # params defines a Pvsyst model for a notional module.\n    # expected value is created by calculating power at 1000 W/m2, and cell\n    # temperature of 24 and 26C, using pvsystem.calcparams_pvsyst and\n    # pvsystem.singlediode. The derivative (value for expected) is estimated\n    # as the slope (p_mp at 26C - p_mp at 24C) / 2\n    # using the secant rule for derivatives.\n    gamma_pdc = sdm.pvsyst_temperature_coeff(\n        params['alpha_sc'], params['gamma_ref'], params['mu_gamma'],\n        params['I_L_ref'], params['I_o_ref'], params['R_sh_ref'],\n        params['R_sh_0'], params['R_s'], params['cells_in_series'])\n    assert_allclose(gamma_pdc, expected, rtol=0.0005)\n", "tokens": ["pvlib", "tests", "ivtools", "test_sdm", "py", "def", "test_pvsyst_temperature_coeff", "test", "for", "consistency", "with", "dp", "dt", "estimated", "with", "secant", "rule", "params", "alpha_sc", "0", "gamma_ref", "1", "1", "mu_gamma", "0", "i_l_ref", "6", "i_o_ref", "5", "e", "9", "r_sh_ref", "200", "r_sh_0", "2000", "r_s", "0", "5", "cells_in_series", "60", "expected", "0", "004886706494879083", "params", "defines", "a", "pvsyst", "model", "for", "a", "notional", "module", "expected", "value", "is", "created", "by", "calculating", "power", "at", "1000", "w", "m2", "and", "cell", "temperature", "of", "24", "and", "26c", "using", "pvsystem", "calcparams_pvsyst", "and", "pvsystem", "singlediode", "the", "derivative", "value", "for", "expected", "is", "estimated", "as", "the", "slope", "p_mp", "at", "26c", "p_mp", "at", "24c", "2", "using", "the", "secant", "rule", "for", "derivatives", "gamma_pdc", "sdm", "pvsyst_temperature_coeff", "params", "alpha_sc", "params", "gamma_ref", "params", "mu_gamma", "params", "i_l_ref", "params", "i_o_ref", "params", "r_sh_ref", "params", "r_sh_0", "params", "r_s", "params", "cells_in_series", "assert_allclose", "gamma_pdc", "expected", "rtol", "0", "0005"], "doc_len": 126}
{"doc_id": "pvlib/tests/ivtools/test_utils.py::ivcurve", "file_path": "pvlib/tests/ivtools/test_utils.py", "class_name": null, "func_name": "ivcurve", "text": "文件路径: pvlib/tests/ivtools/test_utils.py\ndef ivcurve():\n    voltage = np.array([0., 1., 5., 10., 25., 25.00001, 30., 28., 45., 47.,\n                        49., 51., np.nan])\n    current = np.array([7., 6., 6., 5., 4., 3., 2.7, 2.5, np.nan, 0.5, -1., 0.,\n                        np.nan])\n    return voltage, current\n", "tokens": ["pvlib", "tests", "ivtools", "test_utils", "py", "def", "ivcurve", "voltage", "np", "array", "0", "1", "5", "10", "25", "25", "00001", "30", "28", "45", "47", "49", "51", "np", "nan", "current", "np", "array", "7", "6", "6", "5", "4", "3", "2", "7", "2", "5", "np", "nan", "0", "5", "1", "0", "np", "nan", "return", "voltage", "current"], "doc_len": 49}
{"doc_id": "pvlib/tests/ivtools/test_utils.py::test__numdiff", "file_path": "pvlib/tests/ivtools/test_utils.py", "class_name": null, "func_name": "test__numdiff", "text": "文件路径: pvlib/tests/ivtools/test_utils.py\ndef test__numdiff():\n    iv = pd.read_csv(DATA_DIR / 'ivtools_numdiff.csv',\n                     names=['I', 'V', 'dIdV', 'd2IdV2'], dtype=float)\n    df, d2f = _numdiff(iv.V, iv.I)\n    assert np.allclose(iv.dIdV, df, equal_nan=True)\n    assert np.allclose(iv.d2IdV2, d2f, equal_nan=True)\n", "tokens": ["pvlib", "tests", "ivtools", "test_utils", "py", "def", "test__numdiff", "iv", "pd", "read_csv", "data_dir", "ivtools_numdiff", "csv", "names", "i", "v", "didv", "d2idv2", "dtype", "float", "df", "d2f", "_numdiff", "iv", "v", "iv", "i", "assert", "np", "allclose", "iv", "didv", "df", "equal_nan", "true", "assert", "np", "allclose", "iv", "d2idv2", "d2f", "equal_nan", "true"], "doc_len": 43}
{"doc_id": "pvlib/tests/ivtools/test_utils.py::test_rectify_iv_curve", "file_path": "pvlib/tests/ivtools/test_utils.py", "class_name": null, "func_name": "test_rectify_iv_curve", "text": "文件路径: pvlib/tests/ivtools/test_utils.py\ndef test_rectify_iv_curve(ivcurve):\n    voltage, current = ivcurve\n\n    vexp_no_dec = np.array([0., 1.,  5., 10., 25., 25.00001, 28., 30., 47.,\n                            51.])\n    iexp_no_dec = np.array([7., 6., 6., 5., 4., 3., 2.5, 2.7, 0.5, 0.])\n    v, i = rectify_iv_curve(voltage, current)\n    np.testing.assert_allclose(v, vexp_no_dec, atol=.0001)\n    np.testing.assert_allclose(i, iexp_no_dec, atol=.0001)\n\n    vexp = np.array([0., 1., 5., 10., 25., 28., 30., 47., 51.])\n    iexp = np.array([7., 6., 6., 5., 3.5, 2.5, 2.7, 0.5, 0.])\n    v, i = rectify_iv_curve(voltage, current, decimals=4)\n    np.testing.assert_allclose(v, vexp, atol=.0001)\n    np.testing.assert_allclose(i, iexp, atol=.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_utils", "py", "def", "test_rectify_iv_curve", "ivcurve", "voltage", "current", "ivcurve", "vexp_no_dec", "np", "array", "0", "1", "5", "10", "25", "25", "00001", "28", "30", "47", "51", "iexp_no_dec", "np", "array", "7", "6", "6", "5", "4", "3", "2", "5", "2", "7", "0", "5", "0", "v", "i", "rectify_iv_curve", "voltage", "current", "np", "testing", "assert_allclose", "v", "vexp_no_dec", "atol", "0001", "np", "testing", "assert_allclose", "i", "iexp_no_dec", "atol", "0001", "vexp", "np", "array", "0", "1", "5", "10", "25", "28", "30", "47", "51", "iexp", "np", "array", "7", "6", "6", "5", "3", "5", "2", "5", "2", "7", "0", "5", "0", "v", "i", "rectify_iv_curve", "voltage", "current", "decimals", "4", "np", "testing", "assert_allclose", "v", "vexp", "atol", "0001", "np", "testing", "assert_allclose", "i", "iexp", "atol", "0001"], "doc_len": 109}
{"doc_id": "pvlib/tests/ivtools/test_utils.py::test__schmumaker_qspline", "file_path": "pvlib/tests/ivtools/test_utils.py", "class_name": null, "func_name": "test__schmumaker_qspline", "text": "文件路径: pvlib/tests/ivtools/test_utils.py\ndef test__schmumaker_qspline(x, y, expected):\n    [t, c, yhat, kflag] = _schumaker_qspline(x, y)\n    np.testing.assert_allclose(c, expected[0], atol=0.0001)\n    np.testing.assert_allclose(t, expected[1], atol=0.0001)\n    np.testing.assert_allclose(yhat, expected[2], atol=0.0001)\n    np.testing.assert_allclose(kflag, expected[3], atol=0.0001)\n", "tokens": ["pvlib", "tests", "ivtools", "test_utils", "py", "def", "test__schmumaker_qspline", "x", "y", "expected", "t", "c", "yhat", "kflag", "_schumaker_qspline", "x", "y", "np", "testing", "assert_allclose", "c", "expected", "0", "atol", "0", "0001", "np", "testing", "assert_allclose", "t", "expected", "1", "atol", "0", "0001", "np", "testing", "assert_allclose", "yhat", "expected", "2", "atol", "0", "0001", "np", "testing", "assert_allclose", "kflag", "expected", "3", "atol", "0", "0001"], "doc_len": 53}
