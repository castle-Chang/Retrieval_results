{"doc_id": "doc/sphinxext/gallery_generator.py::execfile", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": null, "func_name": "execfile", "text": "文件路径: doc/sphinxext/gallery_generator.py\ndef execfile(filename, globals=None, locals=None):\n    with open(filename, \"rb\") as fp:\n        exec(compile(fp.read(), filename, 'exec'), globals, locals)\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "def", "execfile", "filename", "globals", "none", "locals", "none", "with", "open", "filename", "rb", "as", "fp", "exec", "compile", "fp", "read", "filename", "exec", "globals", "locals"], "doc_len": 25}
{"doc_id": "doc/sphinxext/gallery_generator.py::create_thumbnail", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": null, "func_name": "create_thumbnail", "text": "文件路径: doc/sphinxext/gallery_generator.py\ndef create_thumbnail(infile, thumbfile,\n                     width=275, height=275,\n                     cx=0.5, cy=0.5, border=4):\n    baseout, extout = op.splitext(thumbfile)\n\n    im = matplotlib.image.imread(infile)\n    rows, cols = im.shape[:2]\n    x0 = int(cx * cols - .5 * width)\n    y0 = int(cy * rows - .5 * height)\n    xslice = slice(x0, x0 + width)\n    yslice = slice(y0, y0 + height)\n    thumb = im[yslice, xslice]\n    thumb[:border, :, :3] = thumb[-border:, :, :3] = 0\n    thumb[:, :border, :3] = thumb[:, -border:, :3] = 0\n\n    dpi = 100\n    fig = plt.figure(figsize=(width / dpi, height / dpi), dpi=dpi)\n\n    ax = fig.add_axes([0, 0, 1, 1], aspect='auto',\n                      frameon=False, xticks=[], yticks=[])\n    if all(thumb.shape):\n        ax.imshow(thumb, aspect='auto', resample=True,\n                  interpolation='bilinear')\n    else:\n        warnings.warn(\n            f\"Bad thumbnail crop. {thumbfile} will be empty.\"\n        )\n    fig.savefig(thumbfile, dpi=dpi)\n    return fig\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "def", "create_thumbnail", "infile", "thumbfile", "width", "275", "height", "275", "cx", "0", "5", "cy", "0", "5", "border", "4", "baseout", "extout", "op", "splitext", "thumbfile", "im", "matplotlib", "image", "imread", "infile", "rows", "cols", "im", "shape", "2", "x0", "int", "cx", "cols", "5", "width", "y0", "int", "cy", "rows", "5", "height", "xslice", "slice", "x0", "x0", "width", "yslice", "slice", "y0", "y0", "height", "thumb", "im", "yslice", "xslice", "thumb", "border", "3", "thumb", "border", "3", "0", "thumb", "border", "3", "thumb", "border", "3", "0", "dpi", "100", "fig", "plt", "figure", "figsize", "width", "dpi", "height", "dpi", "dpi", "dpi", "ax", "fig", "add_axes", "0", "0", "1", "1", "aspect", "auto", "frameon", "false", "xticks", "yticks", "if", "all", "thumb", "shape", "ax", "imshow", "thumb", "aspect", "auto", "resample", "true", "interpolation", "bilinear", "else", "warnings", "warn", "f", "bad", "thumbnail", "crop", "thumbfile", "will", "be", "empty", "fig", "savefig", "thumbfile", "dpi", "dpi", "return", "fig"], "doc_len": 131}
{"doc_id": "doc/sphinxext/gallery_generator.py::indent", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": null, "func_name": "indent", "text": "文件路径: doc/sphinxext/gallery_generator.py\ndef indent(s, N=4):\n    \"\"\"indent a string\"\"\"\n    return s.replace('\\n', '\\n' + N * ' ')\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "def", "indent", "s", "n", "4", "indent", "a", "string", "return", "s", "replace", "n", "n", "n"], "doc_len": 18}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.__init__", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "__init__", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def __init__(self, filename, target_dir):\n        self.filename = filename\n        self.target_dir = target_dir\n        self.thumbloc = .5, .5\n        self.extract_docstring()\n        with open(filename) as fid:\n            self.filetext = fid.read()\n\n        outfilename = op.join(target_dir, self.rstfilename)\n\n        # Only actually run it if the output RST file doesn't\n        # exist or it was modified less recently than the example\n        file_mtime = op.getmtime(filename)\n        if not op.exists(outfilename) or op.getmtime(outfilename) < file_mtime:\n            self.exec_file()\n        else:\n            print(f\"skipping {self.filename}\")\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "__init__", "self", "filename", "target_dir", "self", "filename", "filename", "self", "target_dir", "target_dir", "self", "thumbloc", "5", "5", "self", "extract_docstring", "with", "open", "filename", "as", "fid", "self", "filetext", "fid", "read", "outfilename", "op", "join", "target_dir", "self", "rstfilename", "only", "actually", "run", "it", "if", "the", "output", "rst", "file", "doesn", "t", "exist", "or", "it", "was", "modified", "less", "recently", "than", "the", "example", "file_mtime", "op", "getmtime", "filename", "if", "not", "op", "exists", "outfilename", "or", "op", "getmtime", "outfilename", "file_mtime", "self", "exec_file", "else", "print", "f", "skipping", "self", "filename"], "doc_len": 80}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.dirname", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "dirname", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def dirname(self):\n        return op.split(self.filename)[0]\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "dirname", "self", "return", "op", "split", "self", "filename", "0"], "doc_len": 14}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.fname", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "fname", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def fname(self):\n        return op.split(self.filename)[1]\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "fname", "self", "return", "op", "split", "self", "filename", "1"], "doc_len": 14}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.modulename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "modulename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def modulename(self):\n        return op.splitext(self.fname)[0]\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "modulename", "self", "return", "op", "splitext", "self", "fname", "0"], "doc_len": 14}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.pyfilename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "pyfilename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def pyfilename(self):\n        return self.modulename + '.py'\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "pyfilename", "self", "return", "self", "modulename", "py"], "doc_len": 12}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.rstfilename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "rstfilename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def rstfilename(self):\n        return self.modulename + \".rst\"\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "rstfilename", "self", "return", "self", "modulename", "rst"], "doc_len": 12}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.htmlfilename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "htmlfilename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def htmlfilename(self):\n        return self.modulename + '.html'\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "htmlfilename", "self", "return", "self", "modulename", "html"], "doc_len": 12}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.pngfilename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "pngfilename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def pngfilename(self):\n        pngfile = self.modulename + '.png'\n        return \"_images/\" + pngfile\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "pngfilename", "self", "pngfile", "self", "modulename", "png", "return", "_images", "pngfile"], "doc_len": 15}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.thumbfilename", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "thumbfilename", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def thumbfilename(self):\n        pngfile = self.modulename + '_thumb.png'\n        return pngfile\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "thumbfilename", "self", "pngfile", "self", "modulename", "_thumb", "png", "return", "pngfile"], "doc_len": 15}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.sphinxtag", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "sphinxtag", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def sphinxtag(self):\n        return self.modulename\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "sphinxtag", "self", "return", "self", "modulename"], "doc_len": 11}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.pagetitle", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "pagetitle", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def pagetitle(self):\n        return self.docstring.strip().split('\\n')[0].strip()\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "pagetitle", "self", "return", "self", "docstring", "strip", "split", "n", "0", "strip"], "doc_len": 16}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.plotfunc", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "plotfunc", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def plotfunc(self):\n        match = re.search(r\"sns\\.(.+plot)\\(\", self.filetext)\n        if match:\n            return match.group(1)\n        match = re.search(r\"sns\\.(.+map)\\(\", self.filetext)\n        if match:\n            return match.group(1)\n        match = re.search(r\"sns\\.(.+Grid)\\(\", self.filetext)\n        if match:\n            return match.group(1)\n        return \"\"\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "plotfunc", "self", "match", "re", "search", "r", "sns", "plot", "self", "filetext", "if", "match", "return", "match", "group", "1", "match", "re", "search", "r", "sns", "map", "self", "filetext", "if", "match", "return", "match", "group", "1", "match", "re", "search", "r", "sns", "grid", "self", "filetext", "if", "match", "return", "match", "group", "1", "return"], "doc_len": 51}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.components", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "components", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def components(self):\n\n        objects = re.findall(r\"sns\\.(\\w+)\\(\", self.filetext)\n\n        refs = []\n        for obj in objects:\n            if obj[0].isupper():\n                refs.append(f\":class:`{obj}`\")\n            else:\n                refs.append(f\":func:`{obj}`\")\n        return \", \".join(refs)\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "components", "self", "objects", "re", "findall", "r", "sns", "w", "self", "filetext", "refs", "for", "obj", "in", "objects", "if", "obj", "0", "isupper", "refs", "append", "f", "class", "obj", "else", "refs", "append", "f", "func", "obj", "return", "join", "refs"], "doc_len": 39}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.extract_docstring", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "extract_docstring", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def extract_docstring(self):\n        \"\"\" Extract a module-level docstring\n        \"\"\"\n        lines = open(self.filename).readlines()\n        start_row = 0\n        if lines[0].startswith('#!'):\n            lines.pop(0)\n            start_row = 1\n\n        docstring = ''\n        first_par = ''\n        line_iter = lines.__iter__()\n        tokens = tokenize.generate_tokens(lambda: next(line_iter))\n        for tok_type, tok_content, _, (erow, _), _ in tokens:\n            tok_type = token.tok_name[tok_type]\n            if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\n                continue\n            elif tok_type == 'STRING':\n                docstring = eval(tok_content)\n                # If the docstring is formatted with several paragraphs,\n                # extract the first one:\n                paragraphs = '\\n'.join(line.rstrip()\n                                       for line in docstring.split('\\n')\n                                       ).split('\\n\\n')\n                if len(paragraphs) > 0:\n                    first_par = paragraphs[0]\n            break\n\n        thumbloc = None\n        for i, line in enumerate(docstring.split(\"\\n\")):\n            m = re.match(r\"^_thumb: (\\.\\d+),\\s*(\\.\\d+)\", line)\n            if m:\n                thumbloc = float(m.group(1)), float(m.group(2))\n                break\n        if thumbloc is not None:\n            self.thumbloc = thumbloc\n            docstring = \"\\n\".join([l for l in docstring.split(\"\\n\")\n                                   if not l.startswith(\"_thumb\")])\n\n        self.docstring = docstring\n        self.short_desc = first_par\n        self.end_line = erow + 1 + start_row\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "extract_docstring", "self", "extract", "a", "module", "level", "docstring", "lines", "open", "self", "filename", "readlines", "start_row", "0", "if", "lines", "0", "startswith", "lines", "pop", "0", "start_row", "1", "docstring", "first_par", "line_iter", "lines", "__iter__", "tokens", "tokenize", "generate_tokens", "lambda", "next", "line_iter", "for", "tok_type", "tok_content", "_", "erow", "_", "_", "in", "tokens", "tok_type", "token", "tok_name", "tok_type", "if", "tok_type", "in", "newline", "comment", "nl", "indent", "dedent", "continue", "elif", "tok_type", "string", "docstring", "eval", "tok_content", "if", "the", "docstring", "is", "formatted", "with", "several", "paragraphs", "extract", "the", "first", "one", "paragraphs", "n", "join", "line", "rstrip", "for", "line", "in", "docstring", "split", "n", "split", "n", "n", "if", "len", "paragraphs", "0", "first_par", "paragraphs", "0", "break", "thumbloc", "none", "for", "i", "line", "in", "enumerate", "docstring", "split", "n", "m", "re", "match", "r", "_thumb", "d", "s", "d", "line", "if", "m", "thumbloc", "float", "m", "group", "1", "float", "m", "group", "2", "break", "if", "thumbloc", "is", "not", "none", "self", "thumbloc", "thumbloc", "docstring", "n", "join", "l", "for", "l", "in", "docstring", "split", "n", "if", "not", "l", "startswith", "_thumb", "self", "docstring", "docstring", "self", "short_desc", "first_par", "self", "end_line", "erow", "1", "start_row"], "doc_len": 167}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.exec_file", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "exec_file", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def exec_file(self):\n        print(f\"running {self.filename}\")\n\n        plt.close('all')\n        my_globals = {'pl': plt,\n                      'plt': plt}\n        execfile(self.filename, my_globals)\n\n        fig = plt.gcf()\n        fig.canvas.draw()\n        pngfile = op.join(self.target_dir, self.pngfilename)\n        thumbfile = op.join(\"example_thumbs\", self.thumbfilename)\n        self.html = f\"<img src=../{self.pngfilename}>\"\n        fig.savefig(pngfile, dpi=75, bbox_inches=\"tight\")\n\n        cx, cy = self.thumbloc\n        create_thumbnail(pngfile, thumbfile, cx=cx, cy=cy)\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "exec_file", "self", "print", "f", "running", "self", "filename", "plt", "close", "all", "my_globals", "pl", "plt", "plt", "plt", "execfile", "self", "filename", "my_globals", "fig", "plt", "gcf", "fig", "canvas", "draw", "pngfile", "op", "join", "self", "target_dir", "self", "pngfilename", "thumbfile", "op", "join", "example_thumbs", "self", "thumbfilename", "self", "html", "f", "img", "src", "self", "pngfilename", "fig", "savefig", "pngfile", "dpi", "75", "bbox_inches", "tight", "cx", "cy", "self", "thumbloc", "create_thumbnail", "pngfile", "thumbfile", "cx", "cx", "cy", "cy"], "doc_len": 69}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.toctree_entry", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "toctree_entry", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def toctree_entry(self):\n        return f\"   ./{op.splitext(self.htmlfilename)[0]}\\n\\n\"\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "toctree_entry", "self", "return", "f", "op", "splitext", "self", "htmlfilename", "0", "n", "n"], "doc_len": 17}
{"doc_id": "doc/sphinxext/gallery_generator.py::ExampleGenerator.contents_entry", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": "ExampleGenerator", "func_name": "contents_entry", "text": "文件路径: doc/sphinxext/gallery_generator.py, 类名: ExampleGenerator\n    def contents_entry(self):\n        return (\".. raw:: html\\n\\n\"\n                \"    <div class='thumb align-center'>\\n\"\n                \"    <a href=./{}>\\n\"\n                \"    <img src=../_static/{}>\\n\"\n                \"    <span class='thumb-label'>\\n\"\n                \"    <p>{}</p>\\n\"\n                \"    </span>\\n\"\n                \"    </a>\\n\"\n                \"    </div>\\n\\n\"\n                \"\\n\\n\"\n                \"\".format(self.htmlfilename,\n                          self.thumbfilename,\n                          self.plotfunc))\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "examplegenerator", "def", "contents_entry", "self", "return", "raw", "html", "n", "n", "div", "class", "thumb", "align", "center", "n", "a", "href", "n", "img", "src", "_static", "n", "span", "class", "thumb", "label", "n", "p", "p", "n", "span", "n", "a", "n", "div", "n", "n", "n", "n", "format", "self", "htmlfilename", "self", "thumbfilename", "self", "plotfunc"], "doc_len": 50}
{"doc_id": "doc/sphinxext/gallery_generator.py::main", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": null, "func_name": "main", "text": "文件路径: doc/sphinxext/gallery_generator.py\ndef main(app):\n    static_dir = op.join(app.builder.srcdir, '_static')\n    target_dir = op.join(app.builder.srcdir, 'examples')\n    image_dir = op.join(app.builder.srcdir, 'examples/_images')\n    thumb_dir = op.join(app.builder.srcdir, \"example_thumbs\")\n    source_dir = op.abspath(op.join(app.builder.srcdir, '..', 'examples'))\n    if not op.exists(static_dir):\n        os.makedirs(static_dir)\n\n    if not op.exists(target_dir):\n        os.makedirs(target_dir)\n\n    if not op.exists(image_dir):\n        os.makedirs(image_dir)\n\n    if not op.exists(thumb_dir):\n        os.makedirs(thumb_dir)\n\n    if not op.exists(source_dir):\n        os.makedirs(source_dir)\n\n    banner_data = []\n\n    toctree = (\"\\n\\n\"\n               \".. toctree::\\n\"\n               \"   :hidden:\\n\\n\")\n    contents = \"\\n\\n\"\n\n    # Write individual example files\n    for filename in sorted(glob.glob(op.join(source_dir, \"*.py\"))):\n\n        ex = ExampleGenerator(filename, target_dir)\n\n        banner_data.append({\"title\": ex.pagetitle,\n                            \"url\": op.join('examples', ex.htmlfilename),\n                            \"thumb\": op.join(ex.thumbfilename)})\n        shutil.copyfile(filename, op.join(target_dir, ex.pyfilename))\n        output = RST_TEMPLATE.format(sphinx_tag=ex.sphinxtag,\n                                     docstring=ex.docstring,\n                                     end_line=ex.end_line,\n                                     components=ex.components,\n                                     fname=ex.pyfilename,\n                                     img_file=ex.pngfilename)\n        with open(op.join(target_dir, ex.rstfilename), 'w') as f:\n            f.write(output)\n\n        toctree += ex.toctree_entry()\n        contents += ex.contents_entry()\n\n    if len(banner_data) < 10:\n        banner_data = (4 * banner_data)[:10]\n\n    # write index file\n    index_file = op.join(target_dir, 'index.rst')\n    with open(index_file, 'w') as index:\n        index.write(INDEX_TEMPLATE.format(sphinx_tag=\"example_gallery\",\n                                          toctree=toctree,\n                                          contents=contents))\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "def", "main", "app", "static_dir", "op", "join", "app", "builder", "srcdir", "_static", "target_dir", "op", "join", "app", "builder", "srcdir", "examples", "image_dir", "op", "join", "app", "builder", "srcdir", "examples", "_images", "thumb_dir", "op", "join", "app", "builder", "srcdir", "example_thumbs", "source_dir", "op", "abspath", "op", "join", "app", "builder", "srcdir", "examples", "if", "not", "op", "exists", "static_dir", "os", "makedirs", "static_dir", "if", "not", "op", "exists", "target_dir", "os", "makedirs", "target_dir", "if", "not", "op", "exists", "image_dir", "os", "makedirs", "image_dir", "if", "not", "op", "exists", "thumb_dir", "os", "makedirs", "thumb_dir", "if", "not", "op", "exists", "source_dir", "os", "makedirs", "source_dir", "banner_data", "toctree", "n", "n", "toctree", "n", "hidden", "n", "n", "contents", "n", "n", "write", "individual", "example", "files", "for", "filename", "in", "sorted", "glob", "glob", "op", "join", "source_dir", "py", "ex", "examplegenerator", "filename", "target_dir", "banner_data", "append", "title", "ex", "pagetitle", "url", "op", "join", "examples", "ex", "htmlfilename", "thumb", "op", "join", "ex", "thumbfilename", "shutil", "copyfile", "filename", "op", "join", "target_dir", "ex", "pyfilename", "output", "rst_template", "format", "sphinx_tag", "ex", "sphinxtag", "docstring", "ex", "docstring", "end_line", "ex", "end_line", "components", "ex", "components", "fname", "ex", "pyfilename", "img_file", "ex", "pngfilename", "with", "open", "op", "join", "target_dir", "ex", "rstfilename", "w", "as", "f", "f", "write", "output", "toctree", "ex", "toctree_entry", "contents", "ex", "contents_entry", "if", "len", "banner_data", "10", "banner_data", "4", "banner_data", "10", "write", "index", "file", "index_file", "op", "join", "target_dir", "index", "rst", "with", "open", "index_file", "w", "as", "index", "index", "write", "index_template", "format", "sphinx_tag", "example_gallery", "toctree", "toctree", "contents", "contents"], "doc_len": 212}
{"doc_id": "doc/sphinxext/gallery_generator.py::setup", "file_path": "doc/sphinxext/gallery_generator.py", "class_name": null, "func_name": "setup", "text": "文件路径: doc/sphinxext/gallery_generator.py\ndef setup(app):\n    app.connect('builder-inited', main)\n", "tokens": ["doc", "sphinxext", "gallery_generator", "py", "def", "setup", "app", "app", "connect", "builder", "inited", "main"], "doc_len": 12}
{"doc_id": "doc/sphinxext/tutorial_builder.py::main", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "main", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef main(app):\n\n    content_yaml = Path(app.builder.srcdir) / \"tutorial.yaml\"\n    tutorial_rst = Path(app.builder.srcdir) / \"tutorial.rst\"\n\n    tutorial_dir = Path(app.builder.srcdir) / \"tutorial\"\n    tutorial_dir.mkdir(exist_ok=True)\n\n    with open(content_yaml) as fid:\n        sections = yaml.load(fid, yaml.BaseLoader)\n\n    for section in sections:\n        title = section[\"title\"]\n        section[\"header\"] = \"\\n\".join([title, \"-\" * len(title)]) if title else \"\"\n\n    env = Environment().from_string(TEMPLATE)\n    content = env.render(sections=sections)\n\n    with open(tutorial_rst, \"w\") as fid:\n        fid.write(content)\n\n    for section in sections:\n        for page in section[\"pages\"]:\n            if (\n                not (svg_path := tutorial_dir / f\"{page}.svg\").exists()\n                or svg_path.stat().st_mtime < Path(__file__).stat().st_mtime\n            ):\n                write_thumbnail(svg_path, page)\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "main", "app", "content_yaml", "path", "app", "builder", "srcdir", "tutorial", "yaml", "tutorial_rst", "path", "app", "builder", "srcdir", "tutorial", "rst", "tutorial_dir", "path", "app", "builder", "srcdir", "tutorial", "tutorial_dir", "mkdir", "exist_ok", "true", "with", "open", "content_yaml", "as", "fid", "sections", "yaml", "load", "fid", "yaml", "baseloader", "for", "section", "in", "sections", "title", "section", "title", "section", "header", "n", "join", "title", "len", "title", "if", "title", "else", "env", "environment", "from_string", "template", "content", "env", "render", "sections", "sections", "with", "open", "tutorial_rst", "w", "as", "fid", "fid", "write", "content", "for", "section", "in", "sections", "for", "page", "in", "section", "pages", "if", "not", "svg_path", "tutorial_dir", "f", "page", "svg", "exists", "or", "svg_path", "stat", "st_mtime", "path", "__file__", "stat", "st_mtime", "write_thumbnail", "svg_path", "page"], "doc_len": 105}
{"doc_id": "doc/sphinxext/tutorial_builder.py::write_thumbnail", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "write_thumbnail", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef write_thumbnail(svg_path, page):\n\n    with (\n        sns.axes_style(\"dark\"),\n        sns.plotting_context(\"notebook\"),\n        sns.color_palette(\"deep\")\n    ):\n        fig = globals()[page]()\n        for ax in fig.axes:\n            ax.set(xticklabels=[], yticklabels=[], xlabel=\"\", ylabel=\"\", title=\"\")\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            fig.tight_layout()\n        fig.savefig(svg_path, format=\"svg\")\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "write_thumbnail", "svg_path", "page", "with", "sns", "axes_style", "dark", "sns", "plotting_context", "notebook", "sns", "color_palette", "deep", "fig", "globals", "page", "for", "ax", "in", "fig", "axes", "ax", "set", "xticklabels", "yticklabels", "xlabel", "ylabel", "title", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "ignore", "fig", "tight_layout", "fig", "savefig", "svg_path", "format", "svg"], "doc_len": 46}
{"doc_id": "doc/sphinxext/tutorial_builder.py::introduction", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "introduction", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef introduction():\n\n    tips = sns.load_dataset(\"tips\")\n    fmri = sns.load_dataset(\"fmri\").query(\"region == 'parietal'\")\n    penguins = sns.load_dataset(\"penguins\")\n\n    f = mpl.figure.Figure(figsize=(5, 5))\n    with sns.axes_style(\"whitegrid\"):\n        f.subplots(2, 2)\n\n    sns.scatterplot(\n        tips, x=\"total_bill\", y=\"tip\", hue=\"sex\", size=\"size\",\n        alpha=.75, palette=[\"C0\", \".5\"], legend=False, ax=f.axes[0],\n    )\n    sns.kdeplot(\n        tips.query(\"size != 5\"), x=\"total_bill\", hue=\"size\",\n        palette=\"blend:C0,.5\", fill=True, linewidth=.5,\n        legend=False, common_norm=False, ax=f.axes[1],\n    )\n    sns.lineplot(\n        fmri, x=\"timepoint\", y=\"signal\", hue=\"event\",\n        errorbar=(\"se\", 2), legend=False, palette=[\"C0\", \".5\"], ax=f.axes[2],\n    )\n    sns.boxplot(\n        penguins, x=\"bill_depth_mm\", y=\"species\", hue=\"sex\",\n        whiskerprops=dict(linewidth=1.5), medianprops=dict(linewidth=1.5),\n        boxprops=dict(linewidth=1.5), capprops=dict(linewidth=0),\n        width=.5, palette=[\"C0\", \".8\"], whis=5, ax=f.axes[3],\n    )\n    f.axes[3].legend_ = None\n    for ax in f.axes:\n        ax.set(xticks=[], yticks=[])\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "introduction", "tips", "sns", "load_dataset", "tips", "fmri", "sns", "load_dataset", "fmri", "query", "region", "parietal", "penguins", "sns", "load_dataset", "penguins", "f", "mpl", "figure", "figure", "figsize", "5", "5", "with", "sns", "axes_style", "whitegrid", "f", "subplots", "2", "2", "sns", "scatterplot", "tips", "x", "total_bill", "y", "tip", "hue", "sex", "size", "size", "alpha", "75", "palette", "c0", "5", "legend", "false", "ax", "f", "axes", "0", "sns", "kdeplot", "tips", "query", "size", "5", "x", "total_bill", "hue", "size", "palette", "blend", "c0", "5", "fill", "true", "linewidth", "5", "legend", "false", "common_norm", "false", "ax", "f", "axes", "1", "sns", "lineplot", "fmri", "x", "timepoint", "y", "signal", "hue", "event", "errorbar", "se", "2", "legend", "false", "palette", "c0", "5", "ax", "f", "axes", "2", "sns", "boxplot", "penguins", "x", "bill_depth_mm", "y", "species", "hue", "sex", "whiskerprops", "dict", "linewidth", "1", "5", "medianprops", "dict", "linewidth", "1", "5", "boxprops", "dict", "linewidth", "1", "5", "capprops", "dict", "linewidth", "0", "width", "5", "palette", "c0", "8", "whis", "5", "ax", "f", "axes", "3", "f", "axes", "3", "legend_", "none", "for", "ax", "in", "f", "axes", "ax", "set", "xticks", "yticks", "return", "f"], "doc_len": 160}
{"doc_id": "doc/sphinxext/tutorial_builder.py::function_overview", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "function_overview", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef function_overview():\n\n    from matplotlib.patches import FancyBboxPatch\n\n    f = mpl.figure.Figure(figsize=(7, 5))\n    with sns.axes_style(\"white\"):\n        ax = f.subplots()\n    f.subplots_adjust(0, 0, 1, 1)\n    ax.set_axis_off()\n    ax.set(xlim=(0, 1), ylim=(0, 1))\n\n    deep = sns.color_palette(\"deep\")\n    colors = dict(relational=deep[0], distributions=deep[1], categorical=deep[2])\n    dark = sns.color_palette(\"dark\")\n    text_colors = dict(relational=dark[0], distributions=dark[1], categorical=dark[2])\n\n    functions = dict(\n        relational=[\"scatterplot\", \"lineplot\"],\n        distributions=[\"histplot\", \"kdeplot\", \"ecdfplot\", \"rugplot\"],\n        categorical=[\n            \"stripplot\", \"swarmplot\", \"boxplot\", \"violinplot\", \"pointplot\", \"barplot\"\n        ],\n    )\n    pad, w, h = .06, .2, .15\n    xs, y = np.arange(0, 1, 1 / 3) + pad * 1.05, .7\n    for x, mod in zip(xs, functions):\n        color = colors[mod] + (.2,)\n        text_color = text_colors[mod]\n        ax.add_artist(FancyBboxPatch((x, y), w, h, f\"round,pad={pad}\", color=\"white\"))\n        ax.add_artist(FancyBboxPatch(\n            (x, y), w, h, f\"round,pad={pad}\",\n            linewidth=1, edgecolor=text_color, facecolor=color,\n        ))\n        ax.text(\n            x + w / 2, y + h / 2, f\"{mod[:3]}plot\\n({mod})\",\n            ha=\"center\", va=\"center\", size=20, color=text_color\n        )\n        for i, func in enumerate(functions[mod]):\n            x_i, y_i = x + w / 2, y - i * .1 - h / 2 - pad\n            xy = x_i - w / 2, y_i - pad / 3\n            ax.add_artist(\n                FancyBboxPatch(xy, w, h / 4, f\"round,pad={pad / 3}\", color=\"white\")\n            )\n            ax.add_artist(FancyBboxPatch(\n                xy, w, h / 4, f\"round,pad={pad / 3}\",\n                linewidth=1, edgecolor=text_color, facecolor=color\n            ))\n            ax.text(x_i, y_i, func, ha=\"center\", va=\"center\", size=16, color=text_color)\n        ax.plot([x_i, x_i], [y, y_i], zorder=-100, color=text_color, lw=1)\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "function_overview", "from", "matplotlib", "patches", "import", "fancybboxpatch", "f", "mpl", "figure", "figure", "figsize", "7", "5", "with", "sns", "axes_style", "white", "ax", "f", "subplots", "f", "subplots_adjust", "0", "0", "1", "1", "ax", "set_axis_off", "ax", "set", "xlim", "0", "1", "ylim", "0", "1", "deep", "sns", "color_palette", "deep", "colors", "dict", "relational", "deep", "0", "distributions", "deep", "1", "categorical", "deep", "2", "dark", "sns", "color_palette", "dark", "text_colors", "dict", "relational", "dark", "0", "distributions", "dark", "1", "categorical", "dark", "2", "functions", "dict", "relational", "scatterplot", "lineplot", "distributions", "histplot", "kdeplot", "ecdfplot", "rugplot", "categorical", "stripplot", "swarmplot", "boxplot", "violinplot", "pointplot", "barplot", "pad", "w", "h", "06", "2", "15", "xs", "y", "np", "arange", "0", "1", "1", "3", "pad", "1", "05", "7", "for", "x", "mod", "in", "zip", "xs", "functions", "color", "colors", "mod", "2", "text_color", "text_colors", "mod", "ax", "add_artist", "fancybboxpatch", "x", "y", "w", "h", "f", "round", "pad", "pad", "color", "white", "ax", "add_artist", "fancybboxpatch", "x", "y", "w", "h", "f", "round", "pad", "pad", "linewidth", "1", "edgecolor", "text_color", "facecolor", "color", "ax", "text", "x", "w", "2", "y", "h", "2", "f", "mod", "3", "plot", "n", "mod", "ha", "center", "va", "center", "size", "20", "color", "text_color", "for", "i", "func", "in", "enumerate", "functions", "mod", "x_i", "y_i", "x", "w", "2", "y", "i", "1", "h", "2", "pad", "xy", "x_i", "w", "2", "y_i", "pad", "3", "ax", "add_artist", "fancybboxpatch", "xy", "w", "h", "4", "f", "round", "pad", "pad", "3", "color", "white", "ax", "add_artist", "fancybboxpatch", "xy", "w", "h", "4", "f", "round", "pad", "pad", "3", "linewidth", "1", "edgecolor", "text_color", "facecolor", "color", "ax", "text", "x_i", "y_i", "func", "ha", "center", "va", "center", "size", "16", "color", "text_color", "ax", "plot", "x_i", "x_i", "y", "y_i", "zorder", "100", "color", "text_color", "lw", "1", "return", "f"], "doc_len": 256}
{"doc_id": "doc/sphinxext/tutorial_builder.py::data_structure", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "data_structure", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef data_structure():\n\n    f = mpl.figure.Figure(figsize=(7, 5))\n    gs = mpl.gridspec.GridSpec(\n        figure=f, ncols=6, nrows=2, height_ratios=(1, 20),\n        left=0, right=.35, bottom=0, top=.9, wspace=.1, hspace=.01\n    )\n    colors = [c + (.5,) for c in sns.color_palette(\"deep\")]\n    f.add_subplot(gs[0, :], facecolor=\".8\")\n    for i in range(gs.ncols):\n        f.add_subplot(gs[1:, i], facecolor=colors[i])\n\n    gs = mpl.gridspec.GridSpec(\n        figure=f, ncols=2, nrows=2, height_ratios=(1, 8), width_ratios=(1, 11),\n        left=.4, right=1, bottom=.2, top=.8, wspace=.015, hspace=.02\n    )\n    f.add_subplot(gs[0, 1:], facecolor=colors[2])\n    f.add_subplot(gs[1:, 0], facecolor=colors[1])\n    f.add_subplot(gs[1, 1], facecolor=colors[0])\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "data_structure", "f", "mpl", "figure", "figure", "figsize", "7", "5", "gs", "mpl", "gridspec", "gridspec", "figure", "f", "ncols", "6", "nrows", "2", "height_ratios", "1", "20", "left", "0", "right", "35", "bottom", "0", "top", "9", "wspace", "1", "hspace", "01", "colors", "c", "5", "for", "c", "in", "sns", "color_palette", "deep", "f", "add_subplot", "gs", "0", "facecolor", "8", "for", "i", "in", "range", "gs", "ncols", "f", "add_subplot", "gs", "1", "i", "facecolor", "colors", "i", "gs", "mpl", "gridspec", "gridspec", "figure", "f", "ncols", "2", "nrows", "2", "height_ratios", "1", "8", "width_ratios", "1", "11", "left", "4", "right", "1", "bottom", "2", "top", "8", "wspace", "015", "hspace", "02", "f", "add_subplot", "gs", "0", "1", "facecolor", "colors", "2", "f", "add_subplot", "gs", "1", "0", "facecolor", "colors", "1", "f", "add_subplot", "gs", "1", "1", "facecolor", "colors", "0", "return", "f"], "doc_len": 121}
{"doc_id": "doc/sphinxext/tutorial_builder.py::error_bars", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "error_bars", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef error_bars():\n\n    diamonds = sns.load_dataset(\"diamonds\")\n    with sns.axes_style(\"whitegrid\"):\n        g = sns.catplot(\n            diamonds, x=\"carat\", y=\"clarity\", hue=\"clarity\", kind=\"point\",\n            errorbar=(\"sd\", .5), join=False, legend=False, facet_kws={\"despine\": False},\n            palette=\"ch:s=-.2,r=-.2,d=.4,l=.6_r\", scale=.75, capsize=.3,\n        )\n    g.ax.yaxis.set_inverted(False)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "error_bars", "diamonds", "sns", "load_dataset", "diamonds", "with", "sns", "axes_style", "whitegrid", "g", "sns", "catplot", "diamonds", "x", "carat", "y", "clarity", "hue", "clarity", "kind", "point", "errorbar", "sd", "5", "join", "false", "legend", "false", "facet_kws", "despine", "false", "palette", "ch", "s", "2", "r", "2", "d", "4", "l", "6_r", "scale", "75", "capsize", "3", "g", "ax", "yaxis", "set_inverted", "false", "return", "g", "figure"], "doc_len": 58}
{"doc_id": "doc/sphinxext/tutorial_builder.py::properties", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "properties", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef properties():\n\n    f = mpl.figure.Figure(figsize=(5, 5))\n\n    x = np.arange(1, 11)\n    y = np.zeros_like(x)\n\n    p = so.Plot(x, y)\n    ps = 14\n    plots = [\n        p.add(so.Dot(pointsize=ps), color=map(str, x)),\n        p.add(so.Dot(color=\".3\", pointsize=ps), alpha=x),\n        p.add(so.Dot(color=\".9\", pointsize=ps, edgewidth=2), edgecolor=x),\n        p.add(so.Dot(color=\".3\"), pointsize=x).scale(pointsize=(4, 18)),\n        p.add(so.Dot(pointsize=ps, color=\".9\", edgecolor=\".2\"), edgewidth=x),\n        p.add(so.Dot(pointsize=ps, color=\".3\"), marker=map(str, x)),\n        p.add(so.Dot(pointsize=ps, color=\".3\", marker=\"x\"), stroke=x),\n    ]\n\n    with sns.axes_style(\"ticks\"):\n        axs = f.subplots(len(plots))\n    for p, ax in zip(plots, axs):\n        p.on(ax).plot()\n        ax.set(xticks=x, yticks=[], xticklabels=[], ylim=(-.2, .3))\n        sns.despine(ax=ax, left=True)\n    f.legends = []\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "properties", "f", "mpl", "figure", "figure", "figsize", "5", "5", "x", "np", "arange", "1", "11", "y", "np", "zeros_like", "x", "p", "so", "plot", "x", "y", "ps", "14", "plots", "p", "add", "so", "dot", "pointsize", "ps", "color", "map", "str", "x", "p", "add", "so", "dot", "color", "3", "pointsize", "ps", "alpha", "x", "p", "add", "so", "dot", "color", "9", "pointsize", "ps", "edgewidth", "2", "edgecolor", "x", "p", "add", "so", "dot", "color", "3", "pointsize", "x", "scale", "pointsize", "4", "18", "p", "add", "so", "dot", "pointsize", "ps", "color", "9", "edgecolor", "2", "edgewidth", "x", "p", "add", "so", "dot", "pointsize", "ps", "color", "3", "marker", "map", "str", "x", "p", "add", "so", "dot", "pointsize", "ps", "color", "3", "marker", "x", "stroke", "x", "with", "sns", "axes_style", "ticks", "axs", "f", "subplots", "len", "plots", "for", "p", "ax", "in", "zip", "plots", "axs", "p", "on", "ax", "plot", "ax", "set", "xticks", "x", "yticks", "xticklabels", "ylim", "2", "3", "sns", "despine", "ax", "ax", "left", "true", "f", "legends", "return", "f"], "doc_len": 149}
{"doc_id": "doc/sphinxext/tutorial_builder.py::objects_interface", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "objects_interface", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef objects_interface():\n\n    f = mpl.figure.Figure(figsize=(5, 4))\n    C = sns.color_palette(\"deep\")\n    ax = f.subplots()\n    fontsize = 22\n    rects = [((.135, .50), .69), ((.275, .38), .26), ((.59, .38), .40)]\n    for i, (xy, w) in enumerate(rects):\n        ax.add_artist(mpl.patches.Rectangle(xy, w, .09, color=C[i], alpha=.2, lw=0))\n    ax.text(0, .52, \"Plot(data, 'x', 'y', color='var1')\", size=fontsize, color=\".2\")\n    ax.text(0, .40, \".add(Dot(alpha=.5), marker='var2')\", size=fontsize, color=\".2\")\n    annots = [\n        (\"Mapped\\nin all layers\", (.48, .62), (0, 55)),\n        (\"Set directly\", (.41, .35), (0, -55)),\n        (\"Mapped\\nin this layer\", (.80, .35), (0, -55)),\n    ]\n    for i, (text, xy, xytext) in enumerate(annots):\n        ax.annotate(\n            text, xy, xytext,\n            textcoords=\"offset points\", fontsize=18, ha=\"center\", va=\"center\",\n            arrowprops=dict(arrowstyle=\"->\", linewidth=1.5, color=C[i]), color=C[i],\n        )\n    ax.set_axis_off()\n    f.subplots_adjust(0, 0, 1, 1)\n\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "objects_interface", "f", "mpl", "figure", "figure", "figsize", "5", "4", "c", "sns", "color_palette", "deep", "ax", "f", "subplots", "fontsize", "22", "rects", "135", "50", "69", "275", "38", "26", "59", "38", "40", "for", "i", "xy", "w", "in", "enumerate", "rects", "ax", "add_artist", "mpl", "patches", "rectangle", "xy", "w", "09", "color", "c", "i", "alpha", "2", "lw", "0", "ax", "text", "0", "52", "plot", "data", "x", "y", "color", "var1", "size", "fontsize", "color", "2", "ax", "text", "0", "40", "add", "dot", "alpha", "5", "marker", "var2", "size", "fontsize", "color", "2", "annots", "mapped", "nin", "all", "layers", "48", "62", "0", "55", "set", "directly", "41", "35", "0", "55", "mapped", "nin", "this", "layer", "80", "35", "0", "55", "for", "i", "text", "xy", "xytext", "in", "enumerate", "annots", "ax", "annotate", "text", "xy", "xytext", "textcoords", "offset", "points", "fontsize", "18", "ha", "center", "va", "center", "arrowprops", "dict", "arrowstyle", "linewidth", "1", "5", "color", "c", "i", "color", "c", "i", "ax", "set_axis_off", "f", "subplots_adjust", "0", "0", "1", "1", "return", "f"], "doc_len": 149}
{"doc_id": "doc/sphinxext/tutorial_builder.py::relational", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "relational", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef relational():\n\n    mpg = sns.load_dataset(\"mpg\")\n    with sns.axes_style(\"ticks\"):\n        g = sns.relplot(\n            data=mpg, x=\"horsepower\", y=\"mpg\", size=\"displacement\", hue=\"weight\",\n            sizes=(50, 500), hue_norm=(2000, 4500), alpha=.75, legend=False,\n            palette=\"ch:start=-.5,rot=.7,dark=.3,light=.7_r\",\n        )\n    g.figure.set_size_inches(5, 5)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "relational", "mpg", "sns", "load_dataset", "mpg", "with", "sns", "axes_style", "ticks", "g", "sns", "relplot", "data", "mpg", "x", "horsepower", "y", "mpg", "size", "displacement", "hue", "weight", "sizes", "50", "500", "hue_norm", "2000", "4500", "alpha", "75", "legend", "false", "palette", "ch", "start", "5", "rot", "7", "dark", "3", "light", "7_r", "g", "figure", "set_size_inches", "5", "5", "return", "g", "figure"], "doc_len": 55}
{"doc_id": "doc/sphinxext/tutorial_builder.py::distributions", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "distributions", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef distributions():\n\n    penguins = sns.load_dataset(\"penguins\").dropna()\n    with sns.axes_style(\"white\"):\n        g = sns.displot(\n            penguins, x=\"flipper_length_mm\", row=\"island\",\n            binwidth=4, kde=True, line_kws=dict(linewidth=2), legend=False,\n        )\n    sns.despine(left=True)\n    g.figure.set_size_inches(5, 5)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "distributions", "penguins", "sns", "load_dataset", "penguins", "dropna", "with", "sns", "axes_style", "white", "g", "sns", "displot", "penguins", "x", "flipper_length_mm", "row", "island", "binwidth", "4", "kde", "true", "line_kws", "dict", "linewidth", "2", "legend", "false", "sns", "despine", "left", "true", "g", "figure", "set_size_inches", "5", "5", "return", "g", "figure"], "doc_len": 45}
{"doc_id": "doc/sphinxext/tutorial_builder.py::categorical", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "categorical", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef categorical():\n\n    penguins = sns.load_dataset(\"penguins\").dropna()\n    with sns.axes_style(\"whitegrid\"):\n        g = sns.catplot(\n            penguins, x=\"sex\", y=\"body_mass_g\", hue=\"island\", col=\"sex\",\n            kind=\"box\", whis=np.inf, legend=False, sharex=False,\n        )\n    sns.despine(left=True)\n    g.figure.set_size_inches(5, 5)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "categorical", "penguins", "sns", "load_dataset", "penguins", "dropna", "with", "sns", "axes_style", "whitegrid", "g", "sns", "catplot", "penguins", "x", "sex", "y", "body_mass_g", "hue", "island", "col", "sex", "kind", "box", "whis", "np", "inf", "legend", "false", "sharex", "false", "sns", "despine", "left", "true", "g", "figure", "set_size_inches", "5", "5", "return", "g", "figure"], "doc_len": 48}
{"doc_id": "doc/sphinxext/tutorial_builder.py::regression", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "regression", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef regression():\n\n    anscombe = sns.load_dataset(\"anscombe\")\n    with sns.axes_style(\"white\"):\n        g = sns.lmplot(\n            anscombe, x=\"x\", y=\"y\", hue=\"dataset\", col=\"dataset\", col_wrap=2,\n            scatter_kws=dict(edgecolor=\".2\", facecolor=\".7\", s=80),\n            line_kws=dict(lw=4), ci=None,\n        )\n    g.set(xlim=(2, None), ylim=(2, None))\n    g.figure.set_size_inches(5, 5)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "regression", "anscombe", "sns", "load_dataset", "anscombe", "with", "sns", "axes_style", "white", "g", "sns", "lmplot", "anscombe", "x", "x", "y", "y", "hue", "dataset", "col", "dataset", "col_wrap", "2", "scatter_kws", "dict", "edgecolor", "2", "facecolor", "7", "s", "80", "line_kws", "dict", "lw", "4", "ci", "none", "g", "set", "xlim", "2", "none", "ylim", "2", "none", "g", "figure", "set_size_inches", "5", "5", "return", "g", "figure"], "doc_len": 58}
{"doc_id": "doc/sphinxext/tutorial_builder.py::axis_grids", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "axis_grids", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef axis_grids():\n\n    penguins = sns.load_dataset(\"penguins\").sample(200, random_state=0)\n    with sns.axes_style(\"ticks\"):\n        g = sns.pairplot(\n            penguins.drop(\"flipper_length_mm\", axis=1),\n            diag_kind=\"kde\", diag_kws=dict(fill=False),\n            plot_kws=dict(s=40, fc=\"none\", ec=\"C0\", alpha=.75, linewidth=.75),\n        )\n    g.figure.set_size_inches(5, 5)\n    return g.figure\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "axis_grids", "penguins", "sns", "load_dataset", "penguins", "sample", "200", "random_state", "0", "with", "sns", "axes_style", "ticks", "g", "sns", "pairplot", "penguins", "drop", "flipper_length_mm", "axis", "1", "diag_kind", "kde", "diag_kws", "dict", "fill", "false", "plot_kws", "dict", "s", "40", "fc", "none", "ec", "c0", "alpha", "75", "linewidth", "75", "g", "figure", "set_size_inches", "5", "5", "return", "g", "figure"], "doc_len": 52}
{"doc_id": "doc/sphinxext/tutorial_builder.py::aesthetics", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "aesthetics", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef aesthetics():\n\n    f = mpl.figure.Figure(figsize=(5, 5))\n    for i, style in enumerate([\"darkgrid\", \"white\", \"ticks\", \"whitegrid\"], 1):\n        with sns.axes_style(style):\n            ax = f.add_subplot(2, 2, i)\n        ax.set(xticks=[0, .25, .5, .75, 1], yticks=[0, .25, .5, .75, 1])\n    sns.despine(ax=f.axes[1])\n    sns.despine(ax=f.axes[2])\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "aesthetics", "f", "mpl", "figure", "figure", "figsize", "5", "5", "for", "i", "style", "in", "enumerate", "darkgrid", "white", "ticks", "whitegrid", "1", "with", "sns", "axes_style", "style", "ax", "f", "add_subplot", "2", "2", "i", "ax", "set", "xticks", "0", "25", "5", "75", "1", "yticks", "0", "25", "5", "75", "1", "sns", "despine", "ax", "f", "axes", "1", "sns", "despine", "ax", "f", "axes", "2", "return", "f"], "doc_len": 61}
{"doc_id": "doc/sphinxext/tutorial_builder.py::color_palettes", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "color_palettes", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef color_palettes():\n\n    f = mpl.figure.Figure(figsize=(5, 5))\n    palettes = [\"deep\", \"husl\", \"gray\", \"ch:\", \"mako\", \"vlag\", \"icefire\"]\n    axs = f.subplots(len(palettes))\n    x = np.arange(10)\n    for ax, name in zip(axs, palettes):\n        cmap = mpl.colors.ListedColormap(sns.color_palette(name, x.size))\n        ax.pcolormesh(x[None, :], linewidth=.5, edgecolor=\"w\", alpha=.8, cmap=cmap)\n        ax.set_axis_off()\n    return f\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "color_palettes", "f", "mpl", "figure", "figure", "figsize", "5", "5", "palettes", "deep", "husl", "gray", "ch", "mako", "vlag", "icefire", "axs", "f", "subplots", "len", "palettes", "x", "np", "arange", "10", "for", "ax", "name", "in", "zip", "axs", "palettes", "cmap", "mpl", "colors", "listedcolormap", "sns", "color_palette", "name", "x", "size", "ax", "pcolormesh", "x", "none", "linewidth", "5", "edgecolor", "w", "alpha", "8", "cmap", "cmap", "ax", "set_axis_off", "return", "f"], "doc_len": 62}
{"doc_id": "doc/sphinxext/tutorial_builder.py::setup", "file_path": "doc/sphinxext/tutorial_builder.py", "class_name": null, "func_name": "setup", "text": "文件路径: doc/sphinxext/tutorial_builder.py\ndef setup(app):\n    app.connect(\"builder-inited\", main)\n", "tokens": ["doc", "sphinxext", "tutorial_builder", "py", "def", "setup", "app", "app", "connect", "builder", "inited", "main"], "doc_len": 12}
{"doc_id": "doc/tools/extract_examples.py::line_type", "file_path": "doc/tools/extract_examples.py", "class_name": null, "func_name": "line_type", "text": "文件路径: doc/tools/extract_examples.py\ndef line_type(line):\n\n    if line.startswith(\"    \"):\n        return \"code\"\n    else:\n        return \"markdown\"\n", "tokens": ["doc", "tools", "extract_examples", "py", "def", "line_type", "line", "if", "line", "startswith", "return", "code", "else", "return", "markdown"], "doc_len": 15}
{"doc_id": "doc/tools/extract_examples.py::add_cell", "file_path": "doc/tools/extract_examples.py", "class_name": null, "func_name": "add_cell", "text": "文件路径: doc/tools/extract_examples.py\ndef add_cell(nb, lines, cell_type):\n\n    cell_objs = {\n        \"code\": nbformat.v4.new_code_cell,\n        \"markdown\": nbformat.v4.new_markdown_cell,\n    }\n    text = \"\\n\".join(lines)\n    cell = cell_objs[cell_type](text)\n    nb[\"cells\"].append(cell)\n", "tokens": ["doc", "tools", "extract_examples", "py", "def", "add_cell", "nb", "lines", "cell_type", "cell_objs", "code", "nbformat", "v4", "new_code_cell", "markdown", "nbformat", "v4", "new_markdown_cell", "text", "n", "join", "lines", "cell", "cell_objs", "cell_type", "text", "nb", "cells", "append", "cell"], "doc_len": 30}
{"doc_id": "doc/tools/generate_logos.py::poisson_disc_sample", "file_path": "doc/tools/generate_logos.py", "class_name": null, "func_name": "poisson_disc_sample", "text": "文件路径: doc/tools/generate_logos.py\ndef poisson_disc_sample(array_radius, pad_radius, candidates=100, d=2, seed=None):\n    \"\"\"Find positions using poisson-disc sampling.\"\"\"\n    # See http://bost.ocks.org/mike/algorithms/\n    rng = np.random.default_rng(seed)\n    uniform = rng.uniform\n    randint = rng.integers\n\n    # Cache the results\n    key = array_radius, pad_radius, seed\n    if key in XY_CACHE:\n        return XY_CACHE[key]\n\n    # Start at a fixed point we know will work\n    start = np.zeros(d)\n    samples = [start]\n    queue = [start]\n\n    while queue:\n\n        # Pick a sample to expand from\n        s_idx = randint(len(queue))\n        s = queue[s_idx]\n\n        for i in range(candidates):\n            # Generate a candidate from this sample\n            coords = uniform(s - 2 * pad_radius, s + 2 * pad_radius, d)\n\n            # Check the three conditions to accept the candidate\n            in_array = np.sqrt(np.sum(coords ** 2)) < array_radius\n            in_ring = np.all(distance.cdist(samples, [coords]) > pad_radius)\n\n            if in_array and in_ring:\n                # Accept the candidate\n                samples.append(coords)\n                queue.append(coords)\n                break\n\n        if (i + 1) == candidates:\n            # We've exhausted the particular sample\n            queue.pop(s_idx)\n\n    samples = np.array(samples)\n    XY_CACHE[key] = samples\n    return samples\n", "tokens": ["doc", "tools", "generate_logos", "py", "def", "poisson_disc_sample", "array_radius", "pad_radius", "candidates", "100", "d", "2", "seed", "none", "find", "positions", "using", "poisson", "disc", "sampling", "see", "http", "bost", "ocks", "org", "mike", "algorithms", "rng", "np", "random", "default_rng", "seed", "uniform", "rng", "uniform", "randint", "rng", "integers", "cache", "the", "results", "key", "array_radius", "pad_radius", "seed", "if", "key", "in", "xy_cache", "return", "xy_cache", "key", "start", "at", "a", "fixed", "point", "we", "know", "will", "work", "start", "np", "zeros", "d", "samples", "start", "queue", "start", "while", "queue", "pick", "a", "sample", "to", "expand", "from", "s_idx", "randint", "len", "queue", "s", "queue", "s_idx", "for", "i", "in", "range", "candidates", "generate", "a", "candidate", "from", "this", "sample", "coords", "uniform", "s", "2", "pad_radius", "s", "2", "pad_radius", "d", "check", "the", "three", "conditions", "to", "accept", "the", "candidate", "in_array", "np", "sqrt", "np", "sum", "coords", "2", "array_radius", "in_ring", "np", "all", "distance", "cdist", "samples", "coords", "pad_radius", "if", "in_array", "and", "in_ring", "accept", "the", "candidate", "samples", "append", "coords", "queue", "append", "coords", "break", "if", "i", "1", "candidates", "we", "ve", "exhausted", "the", "particular", "sample", "queue", "pop", "s_idx", "samples", "np", "array", "samples", "xy_cache", "key", "samples", "return", "samples"], "doc_len": 164}
{"doc_id": "doc/tools/generate_logos.py::logo", "file_path": "doc/tools/generate_logos.py", "class_name": null, "func_name": "logo", "text": "文件路径: doc/tools/generate_logos.py\ndef logo(\n    ax,\n    color_kws, ring, ring_idx, edge,\n    pdf_means, pdf_sigma, dy, y0, w, h,\n    hist_mean, hist_sigma, hist_y0, lw, skip,\n    scatter, pad, scale,\n):\n\n    # Square, invisible axes with specified limits to center the logo\n    ax.set(xlim=(35 + w, 95 - w), ylim=(-3, 53))\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n\n    # Magic numbers for the logo circle\n    radius = 27\n    center = 65, 25\n\n    # Full x and y grids for a gaussian curve\n    x = np.arange(101)\n    y = gaussian(x.size, pdf_sigma)\n\n    x0 = 30  # Magic number\n    xx = x[x0:]\n\n    # Vertical distances between the PDF curves\n    n = len(pdf_means)\n    dys = np.linspace(0, (n - 1) * dy, n) - (n * dy / 2)\n    dys -= dys.mean()\n\n    # Compute the PDF curves with vertical offsets\n    pdfs = [h * (y[x0 - m:-m] + y0 + dy) for m, dy in zip(pdf_means, dys)]\n\n    # Add in constants to fill from bottom and to top\n    pdfs.insert(0, np.full(xx.shape, -h))\n    pdfs.append(np.full(xx.shape, 50 + h))\n\n    # Color gradient\n    colors = sns.cubehelix_palette(n + 1 + bool(hist_mean), **color_kws)\n\n    # White fill between curves and around edges\n    bg = patches.Circle(\n        center, radius=radius - 1 + ring, color=\"white\",\n        transform=ax.transData, zorder=0,\n    )\n    ax.add_artist(bg)\n\n    # Clipping artist (not shown) for the interior elements\n    fg = patches.Circle(center, radius=radius - edge, transform=ax.transData)\n\n    # Ring artist to surround the circle (optional)\n    if ring:\n        wedge = patches.Wedge(\n            center, r=radius + edge / 2, theta1=0, theta2=360, width=edge / 2,\n            transform=ax.transData, color=colors[ring_idx], alpha=1\n        )\n        ax.add_artist(wedge)\n\n    # Add histogram bars\n    if hist_mean:\n        hist_color = colors.pop(0)\n        hist_y = gaussian(x.size, hist_sigma)\n        hist = 1.1 * h * (hist_y[x0 - hist_mean:-hist_mean] + hist_y0)\n        dx = x[skip] - x[0]\n        hist_x = xx[::skip]\n        hist_h = h + hist[::skip]\n        # Magic number to avoid tiny sliver of bar on edge\n        use = hist_x < center[0] + radius * .5\n        bars = ax.bar(\n            hist_x[use], hist_h[use], bottom=-h, width=dx,\n            align=\"edge\", color=hist_color, ec=\"w\", lw=lw,\n            zorder=3,\n        )\n        for bar in bars:\n            bar.set_clip_path(fg)\n\n    # Add each smooth PDF \"wave\"\n    for i, pdf in enumerate(pdfs[1:], 1):\n        u = ax.fill_between(xx, pdfs[i - 1] + w, pdf, color=colors[i - 1], lw=0)\n        u.set_clip_path(fg)\n\n    # Add scatterplot in top wave area\n    if scatter:\n        seed = sum(map(ord, \"seaborn logo\"))\n        xy = poisson_disc_sample(radius - edge - ring, pad, seed=seed)\n        clearance = distance.cdist(xy + center, np.c_[xx, pdfs[-2]])\n        use = clearance.min(axis=1) > pad / 1.8\n        x, y = xy[use].T\n        sizes = (x - y) % 9\n\n        points = ax.scatter(\n            x + center[0], y + center[1], s=scale * (10 + sizes * 5),\n            zorder=5, color=colors[-1], ec=\"w\", lw=scale / 2,\n        )\n        path = u.get_paths()[0]\n        points.set_clip_path(path, transform=u.get_transform())\n        u.set_visible(False)\n", "tokens": ["doc", "tools", "generate_logos", "py", "def", "logo", "ax", "color_kws", "ring", "ring_idx", "edge", "pdf_means", "pdf_sigma", "dy", "y0", "w", "h", "hist_mean", "hist_sigma", "hist_y0", "lw", "skip", "scatter", "pad", "scale", "square", "invisible", "axes", "with", "specified", "limits", "to", "center", "the", "logo", "ax", "set", "xlim", "35", "w", "95", "w", "ylim", "3", "53", "ax", "set_axis_off", "ax", "set_aspect", "equal", "magic", "numbers", "for", "the", "logo", "circle", "radius", "27", "center", "65", "25", "full", "x", "and", "y", "grids", "for", "a", "gaussian", "curve", "x", "np", "arange", "101", "y", "gaussian", "x", "size", "pdf_sigma", "x0", "30", "magic", "number", "xx", "x", "x0", "vertical", "distances", "between", "the", "pdf", "curves", "n", "len", "pdf_means", "dys", "np", "linspace", "0", "n", "1", "dy", "n", "n", "dy", "2", "dys", "dys", "mean", "compute", "the", "pdf", "curves", "with", "vertical", "offsets", "pdfs", "h", "y", "x0", "m", "m", "y0", "dy", "for", "m", "dy", "in", "zip", "pdf_means", "dys", "add", "in", "constants", "to", "fill", "from", "bottom", "and", "to", "top", "pdfs", "insert", "0", "np", "full", "xx", "shape", "h", "pdfs", "append", "np", "full", "xx", "shape", "50", "h", "color", "gradient", "colors", "sns", "cubehelix_palette", "n", "1", "bool", "hist_mean", "color_kws", "white", "fill", "between", "curves", "and", "around", "edges", "bg", "patches", "circle", "center", "radius", "radius", "1", "ring", "color", "white", "transform", "ax", "transdata", "zorder", "0", "ax", "add_artist", "bg", "clipping", "artist", "not", "shown", "for", "the", "interior", "elements", "fg", "patches", "circle", "center", "radius", "radius", "edge", "transform", "ax", "transdata", "ring", "artist", "to", "surround", "the", "circle", "optional", "if", "ring", "wedge", "patches", "wedge", "center", "r", "radius", "edge", "2", "theta1", "0", "theta2", "360", "width", "edge", "2", "transform", "ax", "transdata", "color", "colors", "ring_idx", "alpha", "1", "ax", "add_artist", "wedge", "add", "histogram", "bars", "if", "hist_mean", "hist_color", "colors", "pop", "0", "hist_y", "gaussian", "x", "size", "hist_sigma", "hist", "1", "1", "h", "hist_y", "x0", "hist_mean", "hist_mean", "hist_y0", "dx", "x", "skip", "x", "0", "hist_x", "xx", "skip", "hist_h", "h", "hist", "skip", "magic", "number", "to", "avoid", "tiny", "sliver", "of", "bar", "on", "edge", "use", "hist_x", "center", "0", "radius", "5", "bars", "ax", "bar", "hist_x", "use", "hist_h", "use", "bottom", "h", "width", "dx", "align", "edge", "color", "hist_color", "ec", "w", "lw", "lw", "zorder", "3", "for", "bar", "in", "bars", "bar", "set_clip_path", "fg", "add", "each", "smooth", "pdf", "wave", "for", "i", "pdf", "in", "enumerate", "pdfs", "1", "1", "u", "ax", "fill_between", "xx", "pdfs", "i", "1", "w", "pdf", "color", "colors", "i", "1", "lw", "0", "u", "set_clip_path", "fg", "add", "scatterplot", "in", "top", "wave", "area", "if", "scatter", "seed", "sum", "map", "ord", "seaborn", "logo", "xy", "poisson_disc_sample", "radius", "edge", "ring", "pad", "seed", "seed", "clearance", "distance", "cdist", "xy", "center", "np", "c_", "xx", "pdfs", "2", "use", "clearance", "min", "axis", "1", "pad", "1", "8", "x", "y", "xy", "use", "t", "sizes", "x", "y", "9", "points", "ax", "scatter", "x", "center", "0", "y", "center", "1", "s", "scale", "10", "sizes", "5", "zorder", "5", "color", "colors", "1", "ec", "w", "lw", "scale", "2", "path", "u", "get_paths", "0", "points", "set_clip_path", "path", "transform", "u", "get_transform", "u", "set_visible", "false"], "doc_len": 441}
{"doc_id": "doc/tools/generate_logos.py::savefig", "file_path": "doc/tools/generate_logos.py", "class_name": null, "func_name": "savefig", "text": "文件路径: doc/tools/generate_logos.py\ndef savefig(fig, shape, variant):\n\n    fig.subplots_adjust(0, 0, 1, 1, 0, 0)\n\n    facecolor = (1, 1, 1, 1) if bg == \"white\" else (1, 1, 1, 0)\n\n    for ext in [\"png\", \"svg\"]:\n        fig.savefig(f\"{STATIC_DIR}/logo-{shape}-{variant}bg.{ext}\", facecolor=facecolor)\n", "tokens": ["doc", "tools", "generate_logos", "py", "def", "savefig", "fig", "shape", "variant", "fig", "subplots_adjust", "0", "0", "1", "1", "0", "0", "facecolor", "1", "1", "1", "1", "if", "bg", "white", "else", "1", "1", "1", "0", "for", "ext", "in", "png", "svg", "fig", "savefig", "f", "static_dir", "logo", "shape", "variant", "bg", "ext", "facecolor", "facecolor"], "doc_len": 46}
{"doc_id": "doc/tools/nb_to_doc.py::pop_recursive", "file_path": "doc/tools/nb_to_doc.py", "class_name": null, "func_name": "pop_recursive", "text": "文件路径: doc/tools/nb_to_doc.py\ndef pop_recursive(d, key, default=None):\n    \"\"\"dict.pop(key) where `key` is a `.`-delimited list of nested keys.\n    >>> d = {'a': {'b': 1, 'c': 2}}\n    >>> pop_recursive(d, 'a.c')\n    2\n    >>> d\n    {'a': {'b': 1}}\n    \"\"\"\n    nested = key.split('.')\n    current = d\n    for k in nested[:-1]:\n        if hasattr(current, 'get'):\n            current = current.get(k, {})\n        else:\n            return default\n    if not hasattr(current, 'pop'):\n        return default\n    return current.pop(nested[-1], default)\n", "tokens": ["doc", "tools", "nb_to_doc", "py", "def", "pop_recursive", "d", "key", "default", "none", "dict", "pop", "key", "where", "key", "is", "a", "delimited", "list", "of", "nested", "keys", "d", "a", "b", "1", "c", "2", "pop_recursive", "d", "a", "c", "2", "d", "a", "b", "1", "nested", "key", "split", "current", "d", "for", "k", "in", "nested", "1", "if", "hasattr", "current", "get", "current", "current", "get", "k", "else", "return", "default", "if", "not", "hasattr", "current", "pop", "return", "default", "return", "current", "pop", "nested", "1", "default"], "doc_len": 71}
{"doc_id": "doc/tools/nb_to_doc.py::strip_output", "file_path": "doc/tools/nb_to_doc.py", "class_name": null, "func_name": "strip_output", "text": "文件路径: doc/tools/nb_to_doc.py\ndef strip_output(nb):\n    \"\"\"\n    Strip the outputs, execution count/prompt number and miscellaneous\n    metadata from a notebook object, unless specified to keep either the\n    outputs or counts.\n    \"\"\"\n    keys = {'metadata': [], 'cell': {'metadata': [\"execution\"]}}\n\n    nb.metadata.pop('signature', None)\n    nb.metadata.pop('widgets', None)\n\n    for field in keys['metadata']:\n        pop_recursive(nb.metadata, field)\n\n    if 'NB_KERNEL' in os.environ:\n        nb.metadata['kernelspec']['name'] = os.environ['NB_KERNEL']\n        nb.metadata['kernelspec']['display_name'] = os.environ['NB_KERNEL']\n\n    for cell in nb.cells:\n\n        if 'outputs' in cell:\n            cell['outputs'] = []\n        if 'prompt_number' in cell:\n            cell['prompt_number'] = None\n        if 'execution_count' in cell:\n            cell['execution_count'] = None\n\n        # Always remove this metadata\n        for output_style in ['collapsed', 'scrolled']:\n            if output_style in cell.metadata:\n                cell.metadata[output_style] = False\n        if 'metadata' in cell:\n            for field in ['collapsed', 'scrolled', 'ExecuteTime']:\n                cell.metadata.pop(field, None)\n        for (extra, fields) in keys['cell'].items():\n            if extra in cell:\n                for field in fields:\n                    pop_recursive(getattr(cell, extra), field)\n    return nb\n", "tokens": ["doc", "tools", "nb_to_doc", "py", "def", "strip_output", "nb", "strip", "the", "outputs", "execution", "count", "prompt", "number", "and", "miscellaneous", "metadata", "from", "a", "notebook", "object", "unless", "specified", "to", "keep", "either", "the", "outputs", "or", "counts", "keys", "metadata", "cell", "metadata", "execution", "nb", "metadata", "pop", "signature", "none", "nb", "metadata", "pop", "widgets", "none", "for", "field", "in", "keys", "metadata", "pop_recursive", "nb", "metadata", "field", "if", "nb_kernel", "in", "os", "environ", "nb", "metadata", "kernelspec", "name", "os", "environ", "nb_kernel", "nb", "metadata", "kernelspec", "display_name", "os", "environ", "nb_kernel", "for", "cell", "in", "nb", "cells", "if", "outputs", "in", "cell", "cell", "outputs", "if", "prompt_number", "in", "cell", "cell", "prompt_number", "none", "if", "execution_count", "in", "cell", "cell", "execution_count", "none", "always", "remove", "this", "metadata", "for", "output_style", "in", "collapsed", "scrolled", "if", "output_style", "in", "cell", "metadata", "cell", "metadata", "output_style", "false", "if", "metadata", "in", "cell", "for", "field", "in", "collapsed", "scrolled", "executetime", "cell", "metadata", "pop", "field", "none", "for", "extra", "fields", "in", "keys", "cell", "items", "if", "extra", "in", "cell", "for", "field", "in", "fields", "pop_recursive", "getattr", "cell", "extra", "field", "return", "nb"], "doc_len": 153}
{"doc_id": "examples/kde_ridgeplot.py::label", "file_path": "examples/kde_ridgeplot.py", "class_name": null, "func_name": "label", "text": "文件路径: examples/kde_ridgeplot.py\ndef label(x, color, label):\n    ax = plt.gca()\n    ax.text(0, .2, label, fontweight=\"bold\", color=color,\n            ha=\"left\", va=\"center\", transform=ax.transAxes)\n", "tokens": ["examples", "kde_ridgeplot", "py", "def", "label", "x", "color", "label", "ax", "plt", "gca", "ax", "text", "0", "2", "label", "fontweight", "bold", "color", "color", "ha", "left", "va", "center", "transform", "ax", "transaxes"], "doc_len": 27}
{"doc_id": "seaborn/algorithms.py::bootstrap", "file_path": "seaborn/algorithms.py", "class_name": null, "func_name": "bootstrap", "text": "文件路径: seaborn/algorithms.py\ndef bootstrap(*args, **kwargs):\n    \"\"\"Resample one or more arrays with replacement and store aggregate values.\n\n    Positional arguments are a sequence of arrays to bootstrap along the first\n    axis and pass to a summary function.\n\n    Keyword arguments:\n        n_boot : int, default=10000\n            Number of iterations\n        axis : int, default=None\n            Will pass axis to ``func`` as a keyword argument.\n        units : array, default=None\n            Array of sampling unit IDs. When used the bootstrap resamples units\n            and then observations within units instead of individual\n            datapoints.\n        func : string or callable, default=\"mean\"\n            Function to call on the args that are passed in. If string, uses as\n            name of function in the numpy namespace. If nans are present in the\n            data, will try to use nan-aware version of named function.\n        seed : Generator | SeedSequence | RandomState | int | None\n            Seed for the random number generator; useful if you want\n            reproducible resamples.\n\n    Returns\n    -------\n    boot_dist: array\n        array of bootstrapped statistic values\n\n    \"\"\"\n    # Ensure list of arrays are same length\n    if len(np.unique(list(map(len, args)))) > 1:\n        raise ValueError(\"All input arrays must have the same length\")\n    n = len(args[0])\n\n    # Default keyword arguments\n    n_boot = kwargs.get(\"n_boot\", 10000)\n    func = kwargs.get(\"func\", \"mean\")\n    axis = kwargs.get(\"axis\", None)\n    units = kwargs.get(\"units\", None)\n    random_seed = kwargs.get(\"random_seed\", None)\n    if random_seed is not None:\n        msg = \"`random_seed` has been renamed to `seed` and will be removed\"\n        warnings.warn(msg)\n    seed = kwargs.get(\"seed\", random_seed)\n    if axis is None:\n        func_kwargs = dict()\n    else:\n        func_kwargs = dict(axis=axis)\n\n    # Initialize the resampler\n    rng = _handle_random_seed(seed)\n\n    # Coerce to arrays\n    args = list(map(np.asarray, args))\n    if units is not None:\n        units = np.asarray(units)\n\n    if isinstance(func, str):\n\n        # Allow named numpy functions\n        f = getattr(np, func)\n\n        # Try to use nan-aware version of function if necessary\n        missing_data = np.isnan(np.sum(np.column_stack(args)))\n\n        if missing_data and not func.startswith(\"nan\"):\n            nanf = getattr(np, f\"nan{func}\", None)\n            if nanf is None:\n                msg = f\"Data contain nans but no nan-aware version of `{func}` found\"\n                warnings.warn(msg, UserWarning)\n            else:\n                f = nanf\n\n    else:\n        f = func\n\n    # Handle numpy changes\n    try:\n        integers = rng.integers\n    except AttributeError:\n        integers = rng.randint\n\n    # Do the bootstrap\n    if units is not None:\n        return _structured_bootstrap(args, n_boot, units, f,\n                                     func_kwargs, integers)\n\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n, n, dtype=np.intp)  # intp is indexing dtype\n        sample = [a.take(resampler, axis=0) for a in args]\n        boot_dist.append(f(*sample, **func_kwargs))\n    return np.array(boot_dist)\n", "tokens": ["seaborn", "algorithms", "py", "def", "bootstrap", "args", "kwargs", "resample", "one", "or", "more", "arrays", "with", "replacement", "and", "store", "aggregate", "values", "positional", "arguments", "are", "a", "sequence", "of", "arrays", "to", "bootstrap", "along", "the", "first", "axis", "and", "pass", "to", "a", "summary", "function", "keyword", "arguments", "n_boot", "int", "default", "10000", "number", "of", "iterations", "axis", "int", "default", "none", "will", "pass", "axis", "to", "func", "as", "a", "keyword", "argument", "units", "array", "default", "none", "array", "of", "sampling", "unit", "ids", "when", "used", "the", "bootstrap", "resamples", "units", "and", "then", "observations", "within", "units", "instead", "of", "individual", "datapoints", "func", "string", "or", "callable", "default", "mean", "function", "to", "call", "on", "the", "args", "that", "are", "passed", "in", "if", "string", "uses", "as", "name", "of", "function", "in", "the", "numpy", "namespace", "if", "nans", "are", "present", "in", "the", "data", "will", "try", "to", "use", "nan", "aware", "version", "of", "named", "function", "seed", "generator", "seedsequence", "randomstate", "int", "none", "seed", "for", "the", "random", "number", "generator", "useful", "if", "you", "want", "reproducible", "resamples", "returns", "boot_dist", "array", "array", "of", "bootstrapped", "statistic", "values", "ensure", "list", "of", "arrays", "are", "same", "length", "if", "len", "np", "unique", "list", "map", "len", "args", "1", "raise", "valueerror", "all", "input", "arrays", "must", "have", "the", "same", "length", "n", "len", "args", "0", "default", "keyword", "arguments", "n_boot", "kwargs", "get", "n_boot", "10000", "func", "kwargs", "get", "func", "mean", "axis", "kwargs", "get", "axis", "none", "units", "kwargs", "get", "units", "none", "random_seed", "kwargs", "get", "random_seed", "none", "if", "random_seed", "is", "not", "none", "msg", "random_seed", "has", "been", "renamed", "to", "seed", "and", "will", "be", "removed", "warnings", "warn", "msg", "seed", "kwargs", "get", "seed", "random_seed", "if", "axis", "is", "none", "func_kwargs", "dict", "else", "func_kwargs", "dict", "axis", "axis", "initialize", "the", "resampler", "rng", "_handle_random_seed", "seed", "coerce", "to", "arrays", "args", "list", "map", "np", "asarray", "args", "if", "units", "is", "not", "none", "units", "np", "asarray", "units", "if", "isinstance", "func", "str", "allow", "named", "numpy", "functions", "f", "getattr", "np", "func", "try", "to", "use", "nan", "aware", "version", "of", "function", "if", "necessary", "missing_data", "np", "isnan", "np", "sum", "np", "column_stack", "args", "if", "missing_data", "and", "not", "func", "startswith", "nan", "nanf", "getattr", "np", "f", "nan", "func", "none", "if", "nanf", "is", "none", "msg", "f", "data", "contain", "nans", "but", "no", "nan", "aware", "version", "of", "func", "found", "warnings", "warn", "msg", "userwarning", "else", "f", "nanf", "else", "f", "func", "handle", "numpy", "changes", "try", "integers", "rng", "integers", "except", "attributeerror", "integers", "rng", "randint", "do", "the", "bootstrap", "if", "units", "is", "not", "none", "return", "_structured_bootstrap", "args", "n_boot", "units", "f", "func_kwargs", "integers", "boot_dist", "for", "i", "in", "range", "int", "n_boot", "resampler", "integers", "0", "n", "n", "dtype", "np", "intp", "intp", "is", "indexing", "dtype", "sample", "a", "take", "resampler", "axis", "0", "for", "a", "in", "args", "boot_dist", "append", "f", "sample", "func_kwargs", "return", "np", "array", "boot_dist"], "doc_len": 407}
{"doc_id": "seaborn/algorithms.py::_structured_bootstrap", "file_path": "seaborn/algorithms.py", "class_name": null, "func_name": "_structured_bootstrap", "text": "文件路径: seaborn/algorithms.py\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n", "tokens": ["seaborn", "algorithms", "py", "def", "_structured_bootstrap", "args", "n_boot", "units", "func", "func_kwargs", "integers", "resample", "units", "instead", "of", "datapoints", "unique_units", "np", "unique", "units", "n_units", "len", "unique_units", "args", "a", "units", "unit", "for", "unit", "in", "unique_units", "for", "a", "in", "args", "boot_dist", "for", "i", "in", "range", "int", "n_boot", "resampler", "integers", "0", "n_units", "n_units", "dtype", "np", "intp", "sample", "a", "i", "for", "i", "in", "resampler", "for", "a", "in", "args", "lengths", "map", "len", "sample", "0", "resampler", "integers", "0", "n", "n", "dtype", "np", "intp", "for", "n", "in", "lengths", "sample", "c", "take", "r", "axis", "0", "for", "c", "r", "in", "zip", "a", "resampler", "for", "a", "in", "sample", "sample", "list", "map", "np", "concatenate", "sample", "boot_dist", "append", "func", "sample", "func_kwargs", "return", "np", "array", "boot_dist"], "doc_len": 110}
{"doc_id": "seaborn/algorithms.py::_handle_random_seed", "file_path": "seaborn/algorithms.py", "class_name": null, "func_name": "_handle_random_seed", "text": "文件路径: seaborn/algorithms.py\ndef _handle_random_seed(seed=None):\n    \"\"\"Given a seed in one of many formats, return a random number generator.\n\n    Generalizes across the numpy 1.17 changes, preferring newer functionality.\n\n    \"\"\"\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    else:\n        try:\n            # General interface for seeding on numpy >= 1.17\n            rng = np.random.default_rng(seed)\n        except AttributeError:\n            # We are on numpy < 1.17, handle options ourselves\n            if isinstance(seed, (numbers.Integral, np.integer)):\n                rng = np.random.RandomState(seed)\n            elif seed is None:\n                rng = np.random.RandomState()\n            else:\n                err = \"{} cannot be used to seed the random number generator\"\n                raise ValueError(err.format(seed))\n    return rng\n", "tokens": ["seaborn", "algorithms", "py", "def", "_handle_random_seed", "seed", "none", "given", "a", "seed", "in", "one", "of", "many", "formats", "return", "a", "random", "number", "generator", "generalizes", "across", "the", "numpy", "1", "17", "changes", "preferring", "newer", "functionality", "if", "isinstance", "seed", "np", "random", "randomstate", "rng", "seed", "else", "try", "general", "interface", "for", "seeding", "on", "numpy", "1", "17", "rng", "np", "random", "default_rng", "seed", "except", "attributeerror", "we", "are", "on", "numpy", "1", "17", "handle", "options", "ourselves", "if", "isinstance", "seed", "numbers", "integral", "np", "integer", "rng", "np", "random", "randomstate", "seed", "elif", "seed", "is", "none", "rng", "np", "random", "randomstate", "else", "err", "cannot", "be", "used", "to", "seed", "the", "random", "number", "generator", "raise", "valueerror", "err", "format", "seed", "return", "rng"], "doc_len": 102}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.set", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "set", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def set(self, **kwargs):\n        \"\"\"Set attributes on each subplot Axes.\"\"\"\n        for ax in self.axes.flat:\n            if ax is not None:  # Handle removed axes\n                ax.set(**kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "set", "self", "kwargs", "set", "attributes", "on", "each", "subplot", "axes", "for", "ax", "in", "self", "axes", "flat", "if", "ax", "is", "not", "none", "handle", "removed", "axes", "ax", "set", "kwargs", "return", "self"], "doc_len": 33}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.fig", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "fig", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def fig(self):\n        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"\n        # Grid.figure is preferred because it matches the Axes attribute name.\n        # But as the maintanace burden on having this property is minimal,\n        # let's be slow about formally deprecating it. For now just note its deprecation\n        # in the docstring; add a warning in version 0.13, and eventually remove it.\n        return self._figure\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "fig", "self", "deprecated", "prefer", "the", "figure", "property", "grid", "figure", "is", "preferred", "because", "it", "matches", "the", "axes", "attribute", "name", "but", "as", "the", "maintanace", "burden", "on", "having", "this", "property", "is", "minimal", "let", "s", "be", "slow", "about", "formally", "deprecating", "it", "for", "now", "just", "note", "its", "deprecation", "in", "the", "docstring", "add", "a", "warning", "in", "version", "0", "13", "and", "eventually", "remove", "it", "return", "self", "_figure"], "doc_len": 65}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.figure", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "figure", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def figure(self):\n        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"\n        return self._figure\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "figure", "self", "access", "the", "class", "matplotlib", "figure", "figure", "object", "underlying", "the", "grid", "return", "self", "_figure"], "doc_len": 20}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.apply", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "apply", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def apply(self, func, *args, **kwargs):\n        \"\"\"\n        Pass the grid to a user-supplied function and return self.\n\n        The `func` must accept an object of this type for its first\n        positional argument. Additional arguments are passed through.\n        The return value of `func` is ignored; this method returns self.\n        See the `pipe` method if you want the return value.\n\n        Added in v0.12.0.\n\n        \"\"\"\n        func(self, *args, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "apply", "self", "func", "args", "kwargs", "pass", "the", "grid", "to", "a", "user", "supplied", "function", "and", "return", "self", "the", "func", "must", "accept", "an", "object", "of", "this", "type", "for", "its", "first", "positional", "argument", "additional", "arguments", "are", "passed", "through", "the", "return", "value", "of", "func", "is", "ignored", "this", "method", "returns", "self", "see", "the", "pipe", "method", "if", "you", "want", "the", "return", "value", "added", "in", "v0", "12", "0", "func", "self", "args", "kwargs", "return", "self"], "doc_len": 72}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.pipe", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "pipe", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def pipe(self, func, *args, **kwargs):\n        \"\"\"\n        Pass the grid to a user-supplied function and return its value.\n\n        The `func` must accept an object of this type for its first\n        positional argument. Additional arguments are passed through.\n        The return value of `func` becomes the return value of this method.\n        See the `apply` method if you want to return self instead.\n\n        Added in v0.12.0.\n\n        \"\"\"\n        return func(self, *args, **kwargs)\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "pipe", "self", "func", "args", "kwargs", "pass", "the", "grid", "to", "a", "user", "supplied", "function", "and", "return", "its", "value", "the", "func", "must", "accept", "an", "object", "of", "this", "type", "for", "its", "first", "positional", "argument", "additional", "arguments", "are", "passed", "through", "the", "return", "value", "of", "func", "becomes", "the", "return", "value", "of", "this", "method", "see", "the", "apply", "method", "if", "you", "want", "to", "return", "self", "instead", "added", "in", "v0", "12", "0", "return", "func", "self", "args", "kwargs"], "doc_len": 74}
{"doc_id": "seaborn/axisgrid.py::_BaseGrid.savefig", "file_path": "seaborn/axisgrid.py", "class_name": "_BaseGrid", "func_name": "savefig", "text": "文件路径: seaborn/axisgrid.py, 类名: _BaseGrid\n    def savefig(self, *args, **kwargs):\n        \"\"\"\n        Save an image of the plot.\n\n        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"\n        by default. Parameters are passed through to the matplotlib function.\n\n        \"\"\"\n        kwargs = kwargs.copy()\n        kwargs.setdefault(\"bbox_inches\", \"tight\")\n        self.figure.savefig(*args, **kwargs)\n", "tokens": ["seaborn", "axisgrid", "py", "_basegrid", "def", "savefig", "self", "args", "kwargs", "save", "an", "image", "of", "the", "plot", "this", "wraps", "meth", "matplotlib", "figure", "figure", "savefig", "using", "bbox_inches", "tight", "by", "default", "parameters", "are", "passed", "through", "to", "the", "matplotlib", "function", "kwargs", "kwargs", "copy", "kwargs", "setdefault", "bbox_inches", "tight", "self", "figure", "savefig", "args", "kwargs"], "doc_len": 47}
{"doc_id": "seaborn/axisgrid.py::Grid.__init__", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "__init__", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def __init__(self):\n\n        self._tight_layout_rect = [0, 0, 1, 1]\n        self._tight_layout_pad = None\n\n        # This attribute is set externally and is a hack to handle newer functions that\n        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\n        self._extract_legend_handles = False\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "__init__", "self", "self", "_tight_layout_rect", "0", "0", "1", "1", "self", "_tight_layout_pad", "none", "this", "attribute", "is", "set", "externally", "and", "is", "a", "hack", "to", "handle", "newer", "functions", "that", "don", "t", "add", "proxy", "artists", "onto", "the", "axes", "we", "need", "an", "overall", "cleaner", "approach", "self", "_extract_legend_handles", "false"], "doc_len": 47}
{"doc_id": "seaborn/axisgrid.py::Grid.tight_layout", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "tight_layout", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def tight_layout(self, *args, **kwargs):\n        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"\n        kwargs = kwargs.copy()\n        kwargs.setdefault(\"rect\", self._tight_layout_rect)\n        if self._tight_layout_pad is not None:\n            kwargs.setdefault(\"pad\", self._tight_layout_pad)\n        self._figure.tight_layout(*args, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "tight_layout", "self", "args", "kwargs", "call", "fig", "tight_layout", "within", "rect", "that", "exclude", "the", "legend", "kwargs", "kwargs", "copy", "kwargs", "setdefault", "rect", "self", "_tight_layout_rect", "if", "self", "_tight_layout_pad", "is", "not", "none", "kwargs", "setdefault", "pad", "self", "_tight_layout_pad", "self", "_figure", "tight_layout", "args", "kwargs", "return", "self"], "doc_len": 44}
{"doc_id": "seaborn/axisgrid.py::Grid.add_legend", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "add_legend", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def add_legend(self, legend_data=None, title=None, label_order=None,\n                   adjust_subtitles=False, **kwargs):\n        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.\n\n        Parameters\n        ----------\n        legend_data : dict\n            Dictionary mapping label names (or two-element tuples where the\n            second element is a label name) to matplotlib artist handles. The\n            default reads from ``self._legend_data``.\n        title : string\n            Title for the legend. The default reads from ``self._hue_var``.\n        label_order : list of labels\n            The order that the legend entries should appear in. The default\n            reads from ``self.hue_names``.\n        adjust_subtitles : bool\n            If True, modify entries with invisible artists to left-align\n            the labels and set the font size to that of a title.\n        kwargs : key, value pairings\n            Other keyword arguments are passed to the underlying legend methods\n            on the Figure or Axes object.\n\n        Returns\n        -------\n        self : Grid instance\n            Returns self for easy chaining.\n\n        \"\"\"\n        # Find the data for the legend\n        if legend_data is None:\n            legend_data = self._legend_data\n        if label_order is None:\n            if self.hue_names is None:\n                label_order = list(legend_data.keys())\n            else:\n                label_order = list(map(utils.to_utf8, self.hue_names))\n\n        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)\n        handles = [legend_data.get(l, blank_handle) for l in label_order]\n        title = self._hue_var if title is None else title\n        title_size = mpl.rcParams[\"legend.title_fontsize\"]\n\n        # Unpack nested labels from a hierarchical legend\n        labels = []\n        for entry in label_order:\n            if isinstance(entry, tuple):\n                _, label = entry\n            else:\n                label = entry\n            labels.append(label)\n\n        # Set default legend kwargs\n        kwargs.setdefault(\"scatterpoints\", 1)\n\n        if self._legend_out:\n\n            kwargs.setdefault(\"frameon\", False)\n            kwargs.setdefault(\"loc\", \"center right\")\n\n            # Draw a full-figure legend outside the grid\n            figlegend = self._figure.legend(handles, labels, **kwargs)\n\n            self._legend = figlegend\n            figlegend.set_title(title, prop={\"size\": title_size})\n\n            if adjust_subtitles:\n                adjust_legend_subtitles(figlegend)\n\n            # Draw the plot to set the bounding boxes correctly\n            _draw_figure(self._figure)\n\n            # Calculate and set the new width of the figure so the legend fits\n            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n            fig_width, fig_height = self._figure.get_size_inches()\n            self._figure.set_size_inches(fig_width + legend_width, fig_height)\n\n            # Draw the plot again to get the new transformations\n            _draw_figure(self._figure)\n\n            # Now calculate how much space we need on the right side\n            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n            space_needed = legend_width / (fig_width + legend_width)\n            margin = .04 if self._margin_titles else .01\n            self._space_needed = margin + space_needed\n            right = 1 - self._space_needed\n\n            # Place the subplot axes to give space for the legend\n            self._figure.subplots_adjust(right=right)\n            self._tight_layout_rect[2] = right\n\n        else:\n            # Draw a legend in the first axis\n            ax = self.axes.flat[0]\n            kwargs.setdefault(\"loc\", \"best\")\n\n            leg = ax.legend(handles, labels, **kwargs)\n            leg.set_title(title, prop={\"size\": title_size})\n            self._legend = leg\n\n            if adjust_subtitles:\n                adjust_legend_subtitles(leg)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "add_legend", "self", "legend_data", "none", "title", "none", "label_order", "none", "adjust_subtitles", "false", "kwargs", "draw", "a", "legend", "maybe", "placing", "it", "outside", "axes", "and", "resizing", "the", "figure", "parameters", "legend_data", "dict", "dictionary", "mapping", "label", "names", "or", "two", "element", "tuples", "where", "the", "second", "element", "is", "a", "label", "name", "to", "matplotlib", "artist", "handles", "the", "default", "reads", "from", "self", "_legend_data", "title", "string", "title", "for", "the", "legend", "the", "default", "reads", "from", "self", "_hue_var", "label_order", "list", "of", "labels", "the", "order", "that", "the", "legend", "entries", "should", "appear", "in", "the", "default", "reads", "from", "self", "hue_names", "adjust_subtitles", "bool", "if", "true", "modify", "entries", "with", "invisible", "artists", "to", "left", "align", "the", "labels", "and", "set", "the", "font", "size", "to", "that", "of", "a", "title", "kwargs", "key", "value", "pairings", "other", "keyword", "arguments", "are", "passed", "to", "the", "underlying", "legend", "methods", "on", "the", "figure", "or", "axes", "object", "returns", "self", "grid", "instance", "returns", "self", "for", "easy", "chaining", "find", "the", "data", "for", "the", "legend", "if", "legend_data", "is", "none", "legend_data", "self", "_legend_data", "if", "label_order", "is", "none", "if", "self", "hue_names", "is", "none", "label_order", "list", "legend_data", "keys", "else", "label_order", "list", "map", "utils", "to_utf8", "self", "hue_names", "blank_handle", "mpl", "patches", "patch", "alpha", "0", "linewidth", "0", "handles", "legend_data", "get", "l", "blank_handle", "for", "l", "in", "label_order", "title", "self", "_hue_var", "if", "title", "is", "none", "else", "title", "title_size", "mpl", "rcparams", "legend", "title_fontsize", "unpack", "nested", "labels", "from", "a", "hierarchical", "legend", "labels", "for", "entry", "in", "label_order", "if", "isinstance", "entry", "tuple", "_", "label", "entry", "else", "label", "entry", "labels", "append", "label", "set", "default", "legend", "kwargs", "kwargs", "setdefault", "scatterpoints", "1", "if", "self", "_legend_out", "kwargs", "setdefault", "frameon", "false", "kwargs", "setdefault", "loc", "center", "right", "draw", "a", "full", "figure", "legend", "outside", "the", "grid", "figlegend", "self", "_figure", "legend", "handles", "labels", "kwargs", "self", "_legend", "figlegend", "figlegend", "set_title", "title", "prop", "size", "title_size", "if", "adjust_subtitles", "adjust_legend_subtitles", "figlegend", "draw", "the", "plot", "to", "set", "the", "bounding", "boxes", "correctly", "_draw_figure", "self", "_figure", "calculate", "and", "set", "the", "new", "width", "of", "the", "figure", "so", "the", "legend", "fits", "legend_width", "figlegend", "get_window_extent", "width", "self", "_figure", "dpi", "fig_width", "fig_height", "self", "_figure", "get_size_inches", "self", "_figure", "set_size_inches", "fig_width", "legend_width", "fig_height", "draw", "the", "plot", "again", "to", "get", "the", "new", "transformations", "_draw_figure", "self", "_figure", "now", "calculate", "how", "much", "space", "we", "need", "on", "the", "right", "side", "legend_width", "figlegend", "get_window_extent", "width", "self", "_figure", "dpi", "space_needed", "legend_width", "fig_width", "legend_width", "margin", "04", "if", "self", "_margin_titles", "else", "01", "self", "_space_needed", "margin", "space_needed", "right", "1", "self", "_space_needed", "place", "the", "subplot", "axes", "to", "give", "space", "for", "the", "legend", "self", "_figure", "subplots_adjust", "right", "right", "self", "_tight_layout_rect", "2", "right", "else", "draw", "a", "legend", "in", "the", "first", "axis", "ax", "self", "axes", "flat", "0", "kwargs", "setdefault", "loc", "best", "leg", "ax", "legend", "handles", "labels", "kwargs", "leg", "set_title", "title", "prop", "size", "title_size", "self", "_legend", "leg", "if", "adjust_subtitles", "adjust_legend_subtitles", "leg", "return", "self"], "doc_len": 428}
{"doc_id": "seaborn/axisgrid.py::Grid._update_legend_data", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "_update_legend_data", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def _update_legend_data(self, ax):\n        \"\"\"Extract the legend data from an axes object and save it.\"\"\"\n        data = {}\n\n        # Get data directly from the legend, which is necessary\n        # for newer functions that don't add labeled proxy artists\n        if ax.legend_ is not None and self._extract_legend_handles:\n            handles = ax.legend_.legendHandles\n            labels = [t.get_text() for t in ax.legend_.texts]\n            data.update({l: h for h, l in zip(handles, labels)})\n\n        handles, labels = ax.get_legend_handles_labels()\n        data.update({l: h for h, l in zip(handles, labels)})\n\n        self._legend_data.update(data)\n\n        # Now clear the legend\n        ax.legend_ = None\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "_update_legend_data", "self", "ax", "extract", "the", "legend", "data", "from", "an", "axes", "object", "and", "save", "it", "data", "get", "data", "directly", "from", "the", "legend", "which", "is", "necessary", "for", "newer", "functions", "that", "don", "t", "add", "labeled", "proxy", "artists", "if", "ax", "legend_", "is", "not", "none", "and", "self", "_extract_legend_handles", "handles", "ax", "legend_", "legendhandles", "labels", "t", "get_text", "for", "t", "in", "ax", "legend_", "texts", "data", "update", "l", "h", "for", "h", "l", "in", "zip", "handles", "labels", "handles", "labels", "ax", "get_legend_handles_labels", "data", "update", "l", "h", "for", "h", "l", "in", "zip", "handles", "labels", "self", "_legend_data", "update", "data", "now", "clear", "the", "legend", "ax", "legend_", "none"], "doc_len": 98}
{"doc_id": "seaborn/axisgrid.py::Grid._get_palette", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "_get_palette", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def _get_palette(self, data, hue, hue_order, palette):\n        \"\"\"Get a list of colors for the hue variable.\"\"\"\n        if hue is None:\n            palette = color_palette(n_colors=1)\n\n        else:\n            hue_names = categorical_order(data[hue], hue_order)\n            n_colors = len(hue_names)\n\n            # By default use either the current color palette or HUSL\n            if palette is None:\n                current_palette = utils.get_color_cycle()\n                if n_colors > len(current_palette):\n                    colors = color_palette(\"husl\", n_colors)\n                else:\n                    colors = color_palette(n_colors=n_colors)\n\n            # Allow for palette to map from hue variable names\n            elif isinstance(palette, dict):\n                color_names = [palette[h] for h in hue_names]\n                colors = color_palette(color_names, n_colors)\n\n            # Otherwise act as if we just got a list of colors\n            else:\n                colors = color_palette(palette, n_colors)\n\n            palette = color_palette(colors, n_colors)\n\n        return palette\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "_get_palette", "self", "data", "hue", "hue_order", "palette", "get", "a", "list", "of", "colors", "for", "the", "hue", "variable", "if", "hue", "is", "none", "palette", "color_palette", "n_colors", "1", "else", "hue_names", "categorical_order", "data", "hue", "hue_order", "n_colors", "len", "hue_names", "by", "default", "use", "either", "the", "current", "color", "palette", "or", "husl", "if", "palette", "is", "none", "current_palette", "utils", "get_color_cycle", "if", "n_colors", "len", "current_palette", "colors", "color_palette", "husl", "n_colors", "else", "colors", "color_palette", "n_colors", "n_colors", "allow", "for", "palette", "to", "map", "from", "hue", "variable", "names", "elif", "isinstance", "palette", "dict", "color_names", "palette", "h", "for", "h", "in", "hue_names", "colors", "color_palette", "color_names", "n_colors", "otherwise", "act", "as", "if", "we", "just", "got", "a", "list", "of", "colors", "else", "colors", "color_palette", "palette", "n_colors", "palette", "color_palette", "colors", "n_colors", "return", "palette"], "doc_len": 113}
{"doc_id": "seaborn/axisgrid.py::Grid.legend", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "legend", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def legend(self):\n        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"\n        try:\n            return self._legend\n        except AttributeError:\n            return None\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "legend", "self", "the", "class", "matplotlib", "legend", "legend", "object", "if", "present", "try", "return", "self", "_legend", "except", "attributeerror", "return", "none"], "doc_len": 23}
{"doc_id": "seaborn/axisgrid.py::Grid.tick_params", "file_path": "seaborn/axisgrid.py", "class_name": "Grid", "func_name": "tick_params", "text": "文件路径: seaborn/axisgrid.py, 类名: Grid\n    def tick_params(self, axis='both', **kwargs):\n        \"\"\"Modify the ticks, tick labels, and gridlines.\n\n        Parameters\n        ----------\n        axis : {'x', 'y', 'both'}\n            The axis on which to apply the formatting.\n        kwargs : keyword arguments\n            Additional keyword arguments to pass to\n            :meth:`matplotlib.axes.Axes.tick_params`.\n\n        Returns\n        -------\n        self : Grid instance\n            Returns self for easy chaining.\n\n        \"\"\"\n        for ax in self.figure.axes:\n            ax.tick_params(axis=axis, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "grid", "def", "tick_params", "self", "axis", "both", "kwargs", "modify", "the", "ticks", "tick", "labels", "and", "gridlines", "parameters", "axis", "x", "y", "both", "the", "axis", "on", "which", "to", "apply", "the", "formatting", "kwargs", "keyword", "arguments", "additional", "keyword", "arguments", "to", "pass", "to", "meth", "matplotlib", "axes", "axes", "tick_params", "returns", "self", "grid", "instance", "returns", "self", "for", "easy", "chaining", "for", "ax", "in", "self", "figure", "axes", "ax", "tick_params", "axis", "axis", "kwargs", "return", "self"], "doc_len": 66}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.__init__", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "__init__", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def __init__(\n        self, data, *,\n        row=None, col=None, hue=None, col_wrap=None,\n        sharex=True, sharey=True, height=3, aspect=1, palette=None,\n        row_order=None, col_order=None, hue_order=None, hue_kws=None,\n        dropna=False, legend_out=True, despine=True,\n        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,\n        gridspec_kws=None,\n    ):\n\n        super().__init__()\n\n        # Determine the hue facet layer information\n        hue_var = hue\n        if hue is None:\n            hue_names = None\n        else:\n            hue_names = categorical_order(data[hue], hue_order)\n\n        colors = self._get_palette(data, hue, hue_order, palette)\n\n        # Set up the lists of names for the row and column facet variables\n        if row is None:\n            row_names = []\n        else:\n            row_names = categorical_order(data[row], row_order)\n\n        if col is None:\n            col_names = []\n        else:\n            col_names = categorical_order(data[col], col_order)\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        hue_kws = hue_kws if hue_kws is not None else {}\n\n        # Make a boolean mask that is True anywhere there is an NA\n        # value in one of the faceting variables, but only if dropna is True\n        none_na = np.zeros(len(data), bool)\n        if dropna:\n            row_na = none_na if row is None else data[row].isnull()\n            col_na = none_na if col is None else data[col].isnull()\n            hue_na = none_na if hue is None else data[hue].isnull()\n            not_na = ~(row_na | col_na | hue_na)\n        else:\n            not_na = ~none_na\n\n        # Compute the grid shape\n        ncol = 1 if col is None else len(col_names)\n        nrow = 1 if row is None else len(row_names)\n        self._n_facets = ncol * nrow\n\n        self._col_wrap = col_wrap\n        if col_wrap is not None:\n            if row is not None:\n                err = \"Cannot use `row` and `col_wrap` together.\"\n                raise ValueError(err)\n            ncol = col_wrap\n            nrow = int(np.ceil(len(col_names) / col_wrap))\n        self._ncol = ncol\n        self._nrow = nrow\n\n        # Calculate the base figure size\n        # This can get stretched later by a legend\n        # TODO this doesn't account for axis labels\n        figsize = (ncol * height * aspect, nrow * height)\n\n        # Validate some inputs\n        if col_wrap is not None:\n            margin_titles = False\n\n        # Build the subplot keyword dictionary\n        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()\n        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()\n        if xlim is not None:\n            subplot_kws[\"xlim\"] = xlim\n        if ylim is not None:\n            subplot_kws[\"ylim\"] = ylim\n\n        # --- Initialize the subplot grid\n\n        with _disable_autolayout():\n            fig = plt.figure(figsize=figsize)\n\n        if col_wrap is None:\n\n            kwargs = dict(squeeze=False,\n                          sharex=sharex, sharey=sharey,\n                          subplot_kw=subplot_kws,\n                          gridspec_kw=gridspec_kws)\n\n            axes = fig.subplots(nrow, ncol, **kwargs)\n\n            if col is None and row is None:\n                axes_dict = {}\n            elif col is None:\n                axes_dict = dict(zip(row_names, axes.flat))\n            elif row is None:\n                axes_dict = dict(zip(col_names, axes.flat))\n            else:\n                facet_product = product(row_names, col_names)\n                axes_dict = dict(zip(facet_product, axes.flat))\n\n        else:\n\n            # If wrapping the col variable we need to make the grid ourselves\n            if gridspec_kws:\n                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")\n\n            n_axes = len(col_names)\n            axes = np.empty(n_axes, object)\n            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)\n            if sharex:\n                subplot_kws[\"sharex\"] = axes[0]\n            if sharey:\n                subplot_kws[\"sharey\"] = axes[0]\n            for i in range(1, n_axes):\n                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)\n\n            axes_dict = dict(zip(col_names, axes))\n\n        # --- Set up the class attributes\n\n        # Attributes that are part of the public API but accessed through\n        # a  property so that Sphinx adds them to the auto class doc\n        self._figure = fig\n        self._axes = axes\n        self._axes_dict = axes_dict\n        self._legend = None\n\n        # Public attributes that aren't explicitly documented\n        # (It's not obvious that having them be public was a good idea)\n        self.data = data\n        self.row_names = row_names\n        self.col_names = col_names\n        self.hue_names = hue_names\n        self.hue_kws = hue_kws\n\n        # Next the private variables\n        self._nrow = nrow\n        self._row_var = row\n        self._ncol = ncol\n        self._col_var = col\n\n        self._margin_titles = margin_titles\n        self._margin_titles_texts = []\n        self._col_wrap = col_wrap\n        self._hue_var = hue_var\n        self._colors = colors\n        self._legend_out = legend_out\n        self._legend_data = {}\n        self._x_var = None\n        self._y_var = None\n        self._sharex = sharex\n        self._sharey = sharey\n        self._dropna = dropna\n        self._not_na = not_na\n\n        # --- Make the axes look good\n\n        self.set_titles()\n        self.tight_layout()\n\n        if despine:\n            self.despine()\n\n        if sharex in [True, 'col']:\n            for ax in self._not_bottom_axes:\n                for label in ax.get_xticklabels():\n                    label.set_visible(False)\n                ax.xaxis.offsetText.set_visible(False)\n                ax.xaxis.label.set_visible(False)\n\n        if sharey in [True, 'row']:\n            for ax in self._not_left_axes:\n                for label in ax.get_yticklabels():\n                    label.set_visible(False)\n                ax.yaxis.offsetText.set_visible(False)\n                ax.yaxis.label.set_visible(False)\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "__init__", "self", "data", "row", "none", "col", "none", "hue", "none", "col_wrap", "none", "sharex", "true", "sharey", "true", "height", "3", "aspect", "1", "palette", "none", "row_order", "none", "col_order", "none", "hue_order", "none", "hue_kws", "none", "dropna", "false", "legend_out", "true", "despine", "true", "margin_titles", "false", "xlim", "none", "ylim", "none", "subplot_kws", "none", "gridspec_kws", "none", "super", "__init__", "determine", "the", "hue", "facet", "layer", "information", "hue_var", "hue", "if", "hue", "is", "none", "hue_names", "none", "else", "hue_names", "categorical_order", "data", "hue", "hue_order", "colors", "self", "_get_palette", "data", "hue", "hue_order", "palette", "set", "up", "the", "lists", "of", "names", "for", "the", "row", "and", "column", "facet", "variables", "if", "row", "is", "none", "row_names", "else", "row_names", "categorical_order", "data", "row", "row_order", "if", "col", "is", "none", "col_names", "else", "col_names", "categorical_order", "data", "col", "col_order", "additional", "dict", "of", "kwarg", "list", "of", "values", "for", "mapping", "the", "hue", "var", "hue_kws", "hue_kws", "if", "hue_kws", "is", "not", "none", "else", "make", "a", "boolean", "mask", "that", "is", "true", "anywhere", "there", "is", "an", "na", "value", "in", "one", "of", "the", "faceting", "variables", "but", "only", "if", "dropna", "is", "true", "none_na", "np", "zeros", "len", "data", "bool", "if", "dropna", "row_na", "none_na", "if", "row", "is", "none", "else", "data", "row", "isnull", "col_na", "none_na", "if", "col", "is", "none", "else", "data", "col", "isnull", "hue_na", "none_na", "if", "hue", "is", "none", "else", "data", "hue", "isnull", "not_na", "row_na", "col_na", "hue_na", "else", "not_na", "none_na", "compute", "the", "grid", "shape", "ncol", "1", "if", "col", "is", "none", "else", "len", "col_names", "nrow", "1", "if", "row", "is", "none", "else", "len", "row_names", "self", "_n_facets", "ncol", "nrow", "self", "_col_wrap", "col_wrap", "if", "col_wrap", "is", "not", "none", "if", "row", "is", "not", "none", "err", "cannot", "use", "row", "and", "col_wrap", "together", "raise", "valueerror", "err", "ncol", "col_wrap", "nrow", "int", "np", "ceil", "len", "col_names", "col_wrap", "self", "_ncol", "ncol", "self", "_nrow", "nrow", "calculate", "the", "base", "figure", "size", "this", "can", "get", "stretched", "later", "by", "a", "legend", "todo", "this", "doesn", "t", "account", "for", "axis", "labels", "figsize", "ncol", "height", "aspect", "nrow", "height", "validate", "some", "inputs", "if", "col_wrap", "is", "not", "none", "margin_titles", "false", "build", "the", "subplot", "keyword", "dictionary", "subplot_kws", "if", "subplot_kws", "is", "none", "else", "subplot_kws", "copy", "gridspec_kws", "if", "gridspec_kws", "is", "none", "else", "gridspec_kws", "copy", "if", "xlim", "is", "not", "none", "subplot_kws", "xlim", "xlim", "if", "ylim", "is", "not", "none", "subplot_kws", "ylim", "ylim", "initialize", "the", "subplot", "grid", "with", "_disable_autolayout", "fig", "plt", "figure", "figsize", "figsize", "if", "col_wrap", "is", "none", "kwargs", "dict", "squeeze", "false", "sharex", "sharex", "sharey", "sharey", "subplot_kw", "subplot_kws", "gridspec_kw", "gridspec_kws", "axes", "fig", "subplots", "nrow", "ncol", "kwargs", "if", "col", "is", "none", "and", "row", "is", "none", "axes_dict", "elif", "col", "is", "none", "axes_dict", "dict", "zip", "row_names", "axes", "flat", "elif", "row", "is", "none", "axes_dict", "dict", "zip", "col_names", "axes", "flat", "else", "facet_product", "product", "row_names", "col_names", "axes_dict", "dict", "zip", "facet_product", "axes", "flat", "else", "if", "wrapping", "the", "col", "variable", "we", "need", "to", "make", "the", "grid", "ourselves", "if", "gridspec_kws", "warnings", "warn", "gridspec_kws", "ignored", "when", "using", "col_wrap", "n_axes", "len", "col_names", "axes", "np", "empty", "n_axes", "object", "axes", "0", "fig", "add_subplot", "nrow", "ncol", "1", "subplot_kws", "if", "sharex", "subplot_kws", "sharex", "axes", "0", "if", "sharey", "subplot_kws", "sharey", "axes", "0", "for", "i", "in", "range", "1", "n_axes", "axes", "i", "fig", "add_subplot", "nrow", "ncol", "i", "1", "subplot_kws", "axes_dict", "dict", "zip", "col_names", "axes", "set", "up", "the", "class", "attributes", "attributes", "that", "are", "part", "of", "the", "public", "api", "but", "accessed", "through", "a", "property", "so", "that", "sphinx", "adds", "them", "to", "the", "auto", "class", "doc", "self", "_figure", "fig", "self", "_axes", "axes", "self", "_axes_dict", "axes_dict", "self", "_legend", "none", "public", "attributes", "that", "aren", "t", "explicitly", "documented", "it", "s", "not", "obvious", "that", "having", "them", "be", "public", "was", "a", "good", "idea", "self", "data", "data", "self", "row_names", "row_names", "self", "col_names", "col_names", "self", "hue_names", "hue_names", "self", "hue_kws", "hue_kws", "next", "the", "private", "variables", "self", "_nrow", "nrow", "self", "_row_var", "row", "self", "_ncol", "ncol", "self", "_col_var", "col", "self", "_margin_titles", "margin_titles", "self", "_margin_titles_texts", "self", "_col_wrap", "col_wrap", "self", "_hue_var", "hue_var", "self", "_colors", "colors", "self", "_legend_out", "legend_out", "self", "_legend_data", "self", "_x_var", "none", "self", "_y_var", "none", "self", "_sharex", "sharex", "self", "_sharey", "sharey", "self", "_dropna", "dropna", "self", "_not_na", "not_na", "make", "the", "axes", "look", "good", "self", "set_titles", "self", "tight_layout", "if", "despine", "self", "despine", "if", "sharex", "in", "true", "col", "for", "ax", "in", "self", "_not_bottom_axes", "for", "label", "in", "ax", "get_xticklabels", "label", "set_visible", "false", "ax", "xaxis", "offsettext", "set_visible", "false", "ax", "xaxis", "label", "set_visible", "false", "if", "sharey", "in", "true", "row", "for", "ax", "in", "self", "_not_left_axes", "for", "label", "in", "ax", "get_yticklabels", "label", "set_visible", "false", "ax", "yaxis", "offsettext", "set_visible", "false", "ax", "yaxis", "label", "set_visible", "false"], "doc_len": 682}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.facet_data", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "facet_data", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def facet_data(self):\n        \"\"\"Generator for name indices and data subsets for each facet.\n\n        Yields\n        ------\n        (i, j, k), data_ijk : tuple of ints, DataFrame\n            The ints provide an index into the {row, col, hue}_names attribute,\n            and the dataframe contains a subset of the full data corresponding\n            to each facet. The generator yields subsets that correspond with\n            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`\n            is None.\n\n        \"\"\"\n        data = self.data\n\n        # Construct masks for the row variable\n        if self.row_names:\n            row_masks = [data[self._row_var] == n for n in self.row_names]\n        else:\n            row_masks = [np.repeat(True, len(self.data))]\n\n        # Construct masks for the column variable\n        if self.col_names:\n            col_masks = [data[self._col_var] == n for n in self.col_names]\n        else:\n            col_masks = [np.repeat(True, len(self.data))]\n\n        # Construct masks for the hue variable\n        if self.hue_names:\n            hue_masks = [data[self._hue_var] == n for n in self.hue_names]\n        else:\n            hue_masks = [np.repeat(True, len(self.data))]\n\n        # Here is the main generator loop\n        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),\n                                                    enumerate(col_masks),\n                                                    enumerate(hue_masks)):\n            data_ijk = data[row & col & hue & self._not_na]\n            yield (i, j, k), data_ijk\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "facet_data", "self", "generator", "for", "name", "indices", "and", "data", "subsets", "for", "each", "facet", "yields", "i", "j", "k", "data_ijk", "tuple", "of", "ints", "dataframe", "the", "ints", "provide", "an", "index", "into", "the", "row", "col", "hue", "_names", "attribute", "and", "the", "dataframe", "contains", "a", "subset", "of", "the", "full", "data", "corresponding", "to", "each", "facet", "the", "generator", "yields", "subsets", "that", "correspond", "with", "the", "self", "axes", "flat", "iterator", "or", "self", "axes", "i", "j", "when", "col_wrap", "is", "none", "data", "self", "data", "construct", "masks", "for", "the", "row", "variable", "if", "self", "row_names", "row_masks", "data", "self", "_row_var", "n", "for", "n", "in", "self", "row_names", "else", "row_masks", "np", "repeat", "true", "len", "self", "data", "construct", "masks", "for", "the", "column", "variable", "if", "self", "col_names", "col_masks", "data", "self", "_col_var", "n", "for", "n", "in", "self", "col_names", "else", "col_masks", "np", "repeat", "true", "len", "self", "data", "construct", "masks", "for", "the", "hue", "variable", "if", "self", "hue_names", "hue_masks", "data", "self", "_hue_var", "n", "for", "n", "in", "self", "hue_names", "else", "hue_masks", "np", "repeat", "true", "len", "self", "data", "here", "is", "the", "main", "generator", "loop", "for", "i", "row", "j", "col", "k", "hue", "in", "product", "enumerate", "row_masks", "enumerate", "col_masks", "enumerate", "hue_masks", "data_ijk", "data", "row", "col", "hue", "self", "_not_na", "yield", "i", "j", "k", "data_ijk"], "doc_len": 190}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.map", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "map", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def map(self, func, *args, **kwargs):\n        \"\"\"Apply a plotting function to each facet's subset of the data.\n\n        Parameters\n        ----------\n        func : callable\n            A plotting function that takes data and keyword arguments. It\n            must plot to the currently active matplotlib Axes and take a\n            `color` keyword argument. If faceting on the `hue` dimension,\n            it must also take a `label` keyword argument.\n        args : strings\n            Column names in self.data that identify variables with data to\n            plot. The data for each variable is passed to `func` in the\n            order the variables are specified in the call.\n        kwargs : keyword arguments\n            All keyword arguments are passed to the plotting function.\n\n        Returns\n        -------\n        self : object\n            Returns self.\n\n        \"\"\"\n        # If color was a keyword argument, grab it here\n        kw_color = kwargs.pop(\"color\", None)\n\n        # How we use the function depends on where it comes from\n        func_module = str(getattr(func, \"__module__\", \"\"))\n\n        # Check for categorical plots without order information\n        if func_module == \"seaborn.categorical\":\n            if \"order\" not in kwargs:\n                warning = (\"Using the {} function without specifying \"\n                           \"`order` is likely to produce an incorrect \"\n                           \"plot.\".format(func.__name__))\n                warnings.warn(warning)\n            if len(args) == 3 and \"hue_order\" not in kwargs:\n                warning = (\"Using the {} function without specifying \"\n                           \"`hue_order` is likely to produce an incorrect \"\n                           \"plot.\".format(func.__name__))\n                warnings.warn(warning)\n\n        # Iterate over the data subsets\n        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n\n            # If this subset is null, move on\n            if not data_ijk.values.size:\n                continue\n\n            # Get the current axis\n            modify_state = not func_module.startswith(\"seaborn\")\n            ax = self.facet_axis(row_i, col_j, modify_state)\n\n            # Decide what color to plot with\n            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n\n            # Insert the other hue aesthetics if appropriate\n            for kw, val_list in self.hue_kws.items():\n                kwargs[kw] = val_list[hue_k]\n\n            # Insert a label in the keyword arguments for the legend\n            if self._hue_var is not None:\n                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])\n\n            # Get the actual data we are going to plot with\n            plot_data = data_ijk[list(args)]\n            if self._dropna:\n                plot_data = plot_data.dropna()\n            plot_args = [v for k, v in plot_data.items()]\n\n            # Some matplotlib functions don't handle pandas objects correctly\n            if func_module.startswith(\"matplotlib\"):\n                plot_args = [v.values for v in plot_args]\n\n            # Draw the plot\n            self._facet_plot(func, ax, plot_args, kwargs)\n\n        # Finalize the annotations and layout\n        self._finalize_grid(args[:2])\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "map", "self", "func", "args", "kwargs", "apply", "a", "plotting", "function", "to", "each", "facet", "s", "subset", "of", "the", "data", "parameters", "func", "callable", "a", "plotting", "function", "that", "takes", "data", "and", "keyword", "arguments", "it", "must", "plot", "to", "the", "currently", "active", "matplotlib", "axes", "and", "take", "a", "color", "keyword", "argument", "if", "faceting", "on", "the", "hue", "dimension", "it", "must", "also", "take", "a", "label", "keyword", "argument", "args", "strings", "column", "names", "in", "self", "data", "that", "identify", "variables", "with", "data", "to", "plot", "the", "data", "for", "each", "variable", "is", "passed", "to", "func", "in", "the", "order", "the", "variables", "are", "specified", "in", "the", "call", "kwargs", "keyword", "arguments", "all", "keyword", "arguments", "are", "passed", "to", "the", "plotting", "function", "returns", "self", "object", "returns", "self", "if", "color", "was", "a", "keyword", "argument", "grab", "it", "here", "kw_color", "kwargs", "pop", "color", "none", "how", "we", "use", "the", "function", "depends", "on", "where", "it", "comes", "from", "func_module", "str", "getattr", "func", "__module__", "check", "for", "categorical", "plots", "without", "order", "information", "if", "func_module", "seaborn", "categorical", "if", "order", "not", "in", "kwargs", "warning", "using", "the", "function", "without", "specifying", "order", "is", "likely", "to", "produce", "an", "incorrect", "plot", "format", "func", "__name__", "warnings", "warn", "warning", "if", "len", "args", "3", "and", "hue_order", "not", "in", "kwargs", "warning", "using", "the", "function", "without", "specifying", "hue_order", "is", "likely", "to", "produce", "an", "incorrect", "plot", "format", "func", "__name__", "warnings", "warn", "warning", "iterate", "over", "the", "data", "subsets", "for", "row_i", "col_j", "hue_k", "data_ijk", "in", "self", "facet_data", "if", "this", "subset", "is", "null", "move", "on", "if", "not", "data_ijk", "values", "size", "continue", "get", "the", "current", "axis", "modify_state", "not", "func_module", "startswith", "seaborn", "ax", "self", "facet_axis", "row_i", "col_j", "modify_state", "decide", "what", "color", "to", "plot", "with", "kwargs", "color", "self", "_facet_color", "hue_k", "kw_color", "insert", "the", "other", "hue", "aesthetics", "if", "appropriate", "for", "kw", "val_list", "in", "self", "hue_kws", "items", "kwargs", "kw", "val_list", "hue_k", "insert", "a", "label", "in", "the", "keyword", "arguments", "for", "the", "legend", "if", "self", "_hue_var", "is", "not", "none", "kwargs", "label", "utils", "to_utf8", "self", "hue_names", "hue_k", "get", "the", "actual", "data", "we", "are", "going", "to", "plot", "with", "plot_data", "data_ijk", "list", "args", "if", "self", "_dropna", "plot_data", "plot_data", "dropna", "plot_args", "v", "for", "k", "v", "in", "plot_data", "items", "some", "matplotlib", "functions", "don", "t", "handle", "pandas", "objects", "correctly", "if", "func_module", "startswith", "matplotlib", "plot_args", "v", "values", "for", "v", "in", "plot_args", "draw", "the", "plot", "self", "_facet_plot", "func", "ax", "plot_args", "kwargs", "finalize", "the", "annotations", "and", "layout", "self", "_finalize_grid", "args", "2", "return", "self"], "doc_len": 370}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.map_dataframe", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "map_dataframe", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def map_dataframe(self, func, *args, **kwargs):\n        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.\n\n        This method is suitable for plotting with functions that accept a\n        long-form DataFrame as a `data` keyword argument and access the\n        data in that DataFrame using string variable names.\n\n        Parameters\n        ----------\n        func : callable\n            A plotting function that takes data and keyword arguments. Unlike\n            the `map` method, a function used here must \"understand\" Pandas\n            objects. It also must plot to the currently active matplotlib Axes\n            and take a `color` keyword argument. If faceting on the `hue`\n            dimension, it must also take a `label` keyword argument.\n        args : strings\n            Column names in self.data that identify variables with data to\n            plot. The data for each variable is passed to `func` in the\n            order the variables are specified in the call.\n        kwargs : keyword arguments\n            All keyword arguments are passed to the plotting function.\n\n        Returns\n        -------\n        self : object\n            Returns self.\n\n        \"\"\"\n\n        # If color was a keyword argument, grab it here\n        kw_color = kwargs.pop(\"color\", None)\n\n        # Iterate over the data subsets\n        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n\n            # If this subset is null, move on\n            if not data_ijk.values.size:\n                continue\n\n            # Get the current axis\n            modify_state = not str(func.__module__).startswith(\"seaborn\")\n            ax = self.facet_axis(row_i, col_j, modify_state)\n\n            # Decide what color to plot with\n            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n\n            # Insert the other hue aesthetics if appropriate\n            for kw, val_list in self.hue_kws.items():\n                kwargs[kw] = val_list[hue_k]\n\n            # Insert a label in the keyword arguments for the legend\n            if self._hue_var is not None:\n                kwargs[\"label\"] = self.hue_names[hue_k]\n\n            # Stick the facet dataframe into the kwargs\n            if self._dropna:\n                data_ijk = data_ijk.dropna()\n            kwargs[\"data\"] = data_ijk\n\n            # Draw the plot\n            self._facet_plot(func, ax, args, kwargs)\n\n        # For axis labels, prefer to use positional args for backcompat\n        # but also extract the x/y kwargs and use if no corresponding arg\n        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]\n        for i, val in enumerate(args[:2]):\n            axis_labels[i] = val\n        self._finalize_grid(axis_labels)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "map_dataframe", "self", "func", "args", "kwargs", "like", "map", "but", "passes", "args", "as", "strings", "and", "inserts", "data", "in", "kwargs", "this", "method", "is", "suitable", "for", "plotting", "with", "functions", "that", "accept", "a", "long", "form", "dataframe", "as", "a", "data", "keyword", "argument", "and", "access", "the", "data", "in", "that", "dataframe", "using", "string", "variable", "names", "parameters", "func", "callable", "a", "plotting", "function", "that", "takes", "data", "and", "keyword", "arguments", "unlike", "the", "map", "method", "a", "function", "used", "here", "must", "understand", "pandas", "objects", "it", "also", "must", "plot", "to", "the", "currently", "active", "matplotlib", "axes", "and", "take", "a", "color", "keyword", "argument", "if", "faceting", "on", "the", "hue", "dimension", "it", "must", "also", "take", "a", "label", "keyword", "argument", "args", "strings", "column", "names", "in", "self", "data", "that", "identify", "variables", "with", "data", "to", "plot", "the", "data", "for", "each", "variable", "is", "passed", "to", "func", "in", "the", "order", "the", "variables", "are", "specified", "in", "the", "call", "kwargs", "keyword", "arguments", "all", "keyword", "arguments", "are", "passed", "to", "the", "plotting", "function", "returns", "self", "object", "returns", "self", "if", "color", "was", "a", "keyword", "argument", "grab", "it", "here", "kw_color", "kwargs", "pop", "color", "none", "iterate", "over", "the", "data", "subsets", "for", "row_i", "col_j", "hue_k", "data_ijk", "in", "self", "facet_data", "if", "this", "subset", "is", "null", "move", "on", "if", "not", "data_ijk", "values", "size", "continue", "get", "the", "current", "axis", "modify_state", "not", "str", "func", "__module__", "startswith", "seaborn", "ax", "self", "facet_axis", "row_i", "col_j", "modify_state", "decide", "what", "color", "to", "plot", "with", "kwargs", "color", "self", "_facet_color", "hue_k", "kw_color", "insert", "the", "other", "hue", "aesthetics", "if", "appropriate", "for", "kw", "val_list", "in", "self", "hue_kws", "items", "kwargs", "kw", "val_list", "hue_k", "insert", "a", "label", "in", "the", "keyword", "arguments", "for", "the", "legend", "if", "self", "_hue_var", "is", "not", "none", "kwargs", "label", "self", "hue_names", "hue_k", "stick", "the", "facet", "dataframe", "into", "the", "kwargs", "if", "self", "_dropna", "data_ijk", "data_ijk", "dropna", "kwargs", "data", "data_ijk", "draw", "the", "plot", "self", "_facet_plot", "func", "ax", "args", "kwargs", "for", "axis", "labels", "prefer", "to", "use", "positional", "args", "for", "backcompat", "but", "also", "extract", "the", "x", "y", "kwargs", "and", "use", "if", "no", "corresponding", "arg", "axis_labels", "kwargs", "get", "x", "none", "kwargs", "get", "y", "none", "for", "i", "val", "in", "enumerate", "args", "2", "axis_labels", "i", "val", "self", "_finalize_grid", "axis_labels", "return", "self"], "doc_len": 336}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._facet_color", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_facet_color", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _facet_color(self, hue_index, kw_color):\n\n        color = self._colors[hue_index]\n        if kw_color is not None:\n            return kw_color\n        elif color is not None:\n            return color\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_facet_color", "self", "hue_index", "kw_color", "color", "self", "_colors", "hue_index", "if", "kw_color", "is", "not", "none", "return", "kw_color", "elif", "color", "is", "not", "none", "return", "color"], "doc_len": 27}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._facet_plot", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_facet_plot", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _facet_plot(self, func, ax, plot_args, plot_kwargs):\n\n        # Draw the plot\n        if str(func.__module__).startswith(\"seaborn\"):\n            plot_kwargs = plot_kwargs.copy()\n            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]\n            for key, val in zip(semantics, plot_args):\n                plot_kwargs[key] = val\n            plot_args = []\n            plot_kwargs[\"ax\"] = ax\n        func(*plot_args, **plot_kwargs)\n\n        # Sort out the supporting information\n        self._update_legend_data(ax)\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_facet_plot", "self", "func", "ax", "plot_args", "plot_kwargs", "draw", "the", "plot", "if", "str", "func", "__module__", "startswith", "seaborn", "plot_kwargs", "plot_kwargs", "copy", "semantics", "x", "y", "hue", "size", "style", "for", "key", "val", "in", "zip", "semantics", "plot_args", "plot_kwargs", "key", "val", "plot_args", "plot_kwargs", "ax", "ax", "func", "plot_args", "plot_kwargs", "sort", "out", "the", "supporting", "information", "self", "_update_legend_data", "ax"], "doc_len": 54}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._finalize_grid", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_finalize_grid", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _finalize_grid(self, axlabels):\n        \"\"\"Finalize the annotations and layout.\"\"\"\n        self.set_axis_labels(*axlabels)\n        self.tight_layout()\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_finalize_grid", "self", "axlabels", "finalize", "the", "annotations", "and", "layout", "self", "set_axis_labels", "axlabels", "self", "tight_layout"], "doc_len": 18}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.facet_axis", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "facet_axis", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def facet_axis(self, row_i, col_j, modify_state=True):\n        \"\"\"Make the axis identified by these indices active and return it.\"\"\"\n\n        # Calculate the actual indices of the axes to plot on\n        if self._col_wrap is not None:\n            ax = self.axes.flat[col_j]\n        else:\n            ax = self.axes[row_i, col_j]\n\n        # Get a reference to the axes object we want, and make it active\n        if modify_state:\n            plt.sca(ax)\n        return ax\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "facet_axis", "self", "row_i", "col_j", "modify_state", "true", "make", "the", "axis", "identified", "by", "these", "indices", "active", "and", "return", "it", "calculate", "the", "actual", "indices", "of", "the", "axes", "to", "plot", "on", "if", "self", "_col_wrap", "is", "not", "none", "ax", "self", "axes", "flat", "col_j", "else", "ax", "self", "axes", "row_i", "col_j", "get", "a", "reference", "to", "the", "axes", "object", "we", "want", "and", "make", "it", "active", "if", "modify_state", "plt", "sca", "ax", "return", "ax"], "doc_len": 69}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.despine", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "despine", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def despine(self, **kwargs):\n        \"\"\"Remove axis spines from the facets.\"\"\"\n        utils.despine(self._figure, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "despine", "self", "kwargs", "remove", "axis", "spines", "from", "the", "facets", "utils", "despine", "self", "_figure", "kwargs", "return", "self"], "doc_len": 21}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_axis_labels", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_axis_labels", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):\n        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"\n        if x_var is not None:\n            self._x_var = x_var\n            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)\n        if y_var is not None:\n            self._y_var = y_var\n            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_axis_labels", "self", "x_var", "none", "y_var", "none", "clear_inner", "true", "kwargs", "set", "axis", "labels", "on", "the", "left", "column", "and", "bottom", "row", "of", "the", "grid", "if", "x_var", "is", "not", "none", "self", "_x_var", "x_var", "self", "set_xlabels", "x_var", "clear_inner", "clear_inner", "kwargs", "if", "y_var", "is", "not", "none", "self", "_y_var", "y_var", "self", "set_ylabels", "y_var", "clear_inner", "clear_inner", "kwargs", "return", "self"], "doc_len": 57}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_xlabels", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_xlabels", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_xlabels(self, label=None, clear_inner=True, **kwargs):\n        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"\n        if label is None:\n            label = self._x_var\n        for ax in self._bottom_axes:\n            ax.set_xlabel(label, **kwargs)\n        if clear_inner:\n            for ax in self._not_bottom_axes:\n                ax.set_xlabel(\"\")\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_xlabels", "self", "label", "none", "clear_inner", "true", "kwargs", "label", "the", "x", "axis", "on", "the", "bottom", "row", "of", "the", "grid", "if", "label", "is", "none", "label", "self", "_x_var", "for", "ax", "in", "self", "_bottom_axes", "ax", "set_xlabel", "label", "kwargs", "if", "clear_inner", "for", "ax", "in", "self", "_not_bottom_axes", "ax", "set_xlabel", "return", "self"], "doc_len": 50}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_ylabels", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_ylabels", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_ylabels(self, label=None, clear_inner=True, **kwargs):\n        \"\"\"Label the y axis on the left column of the grid.\"\"\"\n        if label is None:\n            label = self._y_var\n        for ax in self._left_axes:\n            ax.set_ylabel(label, **kwargs)\n        if clear_inner:\n            for ax in self._not_left_axes:\n                ax.set_ylabel(\"\")\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_ylabels", "self", "label", "none", "clear_inner", "true", "kwargs", "label", "the", "y", "axis", "on", "the", "left", "column", "of", "the", "grid", "if", "label", "is", "none", "label", "self", "_y_var", "for", "ax", "in", "self", "_left_axes", "ax", "set_ylabel", "label", "kwargs", "if", "clear_inner", "for", "ax", "in", "self", "_not_left_axes", "ax", "set_ylabel", "return", "self"], "doc_len": 50}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_xticklabels", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_xticklabels", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_xticklabels(self, labels=None, step=None, **kwargs):\n        \"\"\"Set x axis tick labels of the grid.\"\"\"\n        for ax in self.axes.flat:\n            curr_ticks = ax.get_xticks()\n            ax.set_xticks(curr_ticks)\n            if labels is None:\n                curr_labels = [l.get_text() for l in ax.get_xticklabels()]\n                if step is not None:\n                    xticks = ax.get_xticks()[::step]\n                    curr_labels = curr_labels[::step]\n                    ax.set_xticks(xticks)\n                ax.set_xticklabels(curr_labels, **kwargs)\n            else:\n                ax.set_xticklabels(labels, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_xticklabels", "self", "labels", "none", "step", "none", "kwargs", "set", "x", "axis", "tick", "labels", "of", "the", "grid", "for", "ax", "in", "self", "axes", "flat", "curr_ticks", "ax", "get_xticks", "ax", "set_xticks", "curr_ticks", "if", "labels", "is", "none", "curr_labels", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "if", "step", "is", "not", "none", "xticks", "ax", "get_xticks", "step", "curr_labels", "curr_labels", "step", "ax", "set_xticks", "xticks", "ax", "set_xticklabels", "curr_labels", "kwargs", "else", "ax", "set_xticklabels", "labels", "kwargs", "return", "self"], "doc_len": 70}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_yticklabels", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_yticklabels", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_yticklabels(self, labels=None, **kwargs):\n        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"\n        for ax in self.axes.flat:\n            curr_ticks = ax.get_yticks()\n            ax.set_yticks(curr_ticks)\n            if labels is None:\n                curr_labels = [l.get_text() for l in ax.get_yticklabels()]\n                ax.set_yticklabels(curr_labels, **kwargs)\n            else:\n                ax.set_yticklabels(labels, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_yticklabels", "self", "labels", "none", "kwargs", "set", "y", "axis", "tick", "labels", "on", "the", "left", "column", "of", "the", "grid", "for", "ax", "in", "self", "axes", "flat", "curr_ticks", "ax", "get_yticks", "ax", "set_yticks", "curr_ticks", "if", "labels", "is", "none", "curr_labels", "l", "get_text", "for", "l", "in", "ax", "get_yticklabels", "ax", "set_yticklabels", "curr_labels", "kwargs", "else", "ax", "set_yticklabels", "labels", "kwargs", "return", "self"], "doc_len": 57}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.set_titles", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "set_titles", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def set_titles(self, template=None, row_template=None, col_template=None,\n                   **kwargs):\n        \"\"\"Draw titles either above each facet or on the grid margins.\n\n        Parameters\n        ----------\n        template : string\n            Template for all titles with the formatting keys {col_var} and\n            {col_name} (if using a `col` faceting variable) and/or {row_var}\n            and {row_name} (if using a `row` faceting variable).\n        row_template:\n            Template for the row variable when titles are drawn on the grid\n            margins. Must have {row_var} and {row_name} formatting keys.\n        col_template:\n            Template for the column variable when titles are drawn on the grid\n            margins. Must have {col_var} and {col_name} formatting keys.\n\n        Returns\n        -------\n        self: object\n            Returns self.\n\n        \"\"\"\n        args = dict(row_var=self._row_var, col_var=self._col_var)\n        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])\n\n        # Establish default templates\n        if row_template is None:\n            row_template = \"{row_var} = {row_name}\"\n        if col_template is None:\n            col_template = \"{col_var} = {col_name}\"\n        if template is None:\n            if self._row_var is None:\n                template = col_template\n            elif self._col_var is None:\n                template = row_template\n            else:\n                template = \" | \".join([row_template, col_template])\n\n        row_template = utils.to_utf8(row_template)\n        col_template = utils.to_utf8(col_template)\n        template = utils.to_utf8(template)\n\n        if self._margin_titles:\n\n            # Remove any existing title texts\n            for text in self._margin_titles_texts:\n                text.remove()\n            self._margin_titles_texts = []\n\n            if self.row_names is not None:\n                # Draw the row titles on the right edge of the grid\n                for i, row_name in enumerate(self.row_names):\n                    ax = self.axes[i, -1]\n                    args.update(dict(row_name=row_name))\n                    title = row_template.format(**args)\n                    text = ax.annotate(\n                        title, xy=(1.02, .5), xycoords=\"axes fraction\",\n                        rotation=270, ha=\"left\", va=\"center\",\n                        **kwargs\n                    )\n                    self._margin_titles_texts.append(text)\n\n            if self.col_names is not None:\n                # Draw the column titles  as normal titles\n                for j, col_name in enumerate(self.col_names):\n                    args.update(dict(col_name=col_name))\n                    title = col_template.format(**args)\n                    self.axes[0, j].set_title(title, **kwargs)\n\n            return self\n\n        # Otherwise title each facet with all the necessary information\n        if (self._row_var is not None) and (self._col_var is not None):\n            for i, row_name in enumerate(self.row_names):\n                for j, col_name in enumerate(self.col_names):\n                    args.update(dict(row_name=row_name, col_name=col_name))\n                    title = template.format(**args)\n                    self.axes[i, j].set_title(title, **kwargs)\n        elif self.row_names is not None and len(self.row_names):\n            for i, row_name in enumerate(self.row_names):\n                args.update(dict(row_name=row_name))\n                title = template.format(**args)\n                self.axes[i, 0].set_title(title, **kwargs)\n        elif self.col_names is not None and len(self.col_names):\n            for i, col_name in enumerate(self.col_names):\n                args.update(dict(col_name=col_name))\n                title = template.format(**args)\n                # Index the flat array so col_wrap works\n                self.axes.flat[i].set_title(title, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "set_titles", "self", "template", "none", "row_template", "none", "col_template", "none", "kwargs", "draw", "titles", "either", "above", "each", "facet", "or", "on", "the", "grid", "margins", "parameters", "template", "string", "template", "for", "all", "titles", "with", "the", "formatting", "keys", "col_var", "and", "col_name", "if", "using", "a", "col", "faceting", "variable", "and", "or", "row_var", "and", "row_name", "if", "using", "a", "row", "faceting", "variable", "row_template", "template", "for", "the", "row", "variable", "when", "titles", "are", "drawn", "on", "the", "grid", "margins", "must", "have", "row_var", "and", "row_name", "formatting", "keys", "col_template", "template", "for", "the", "column", "variable", "when", "titles", "are", "drawn", "on", "the", "grid", "margins", "must", "have", "col_var", "and", "col_name", "formatting", "keys", "returns", "self", "object", "returns", "self", "args", "dict", "row_var", "self", "_row_var", "col_var", "self", "_col_var", "kwargs", "size", "kwargs", "pop", "size", "mpl", "rcparams", "axes", "labelsize", "establish", "default", "templates", "if", "row_template", "is", "none", "row_template", "row_var", "row_name", "if", "col_template", "is", "none", "col_template", "col_var", "col_name", "if", "template", "is", "none", "if", "self", "_row_var", "is", "none", "template", "col_template", "elif", "self", "_col_var", "is", "none", "template", "row_template", "else", "template", "join", "row_template", "col_template", "row_template", "utils", "to_utf8", "row_template", "col_template", "utils", "to_utf8", "col_template", "template", "utils", "to_utf8", "template", "if", "self", "_margin_titles", "remove", "any", "existing", "title", "texts", "for", "text", "in", "self", "_margin_titles_texts", "text", "remove", "self", "_margin_titles_texts", "if", "self", "row_names", "is", "not", "none", "draw", "the", "row", "titles", "on", "the", "right", "edge", "of", "the", "grid", "for", "i", "row_name", "in", "enumerate", "self", "row_names", "ax", "self", "axes", "i", "1", "args", "update", "dict", "row_name", "row_name", "title", "row_template", "format", "args", "text", "ax", "annotate", "title", "xy", "1", "02", "5", "xycoords", "axes", "fraction", "rotation", "270", "ha", "left", "va", "center", "kwargs", "self", "_margin_titles_texts", "append", "text", "if", "self", "col_names", "is", "not", "none", "draw", "the", "column", "titles", "as", "normal", "titles", "for", "j", "col_name", "in", "enumerate", "self", "col_names", "args", "update", "dict", "col_name", "col_name", "title", "col_template", "format", "args", "self", "axes", "0", "j", "set_title", "title", "kwargs", "return", "self", "otherwise", "title", "each", "facet", "with", "all", "the", "necessary", "information", "if", "self", "_row_var", "is", "not", "none", "and", "self", "_col_var", "is", "not", "none", "for", "i", "row_name", "in", "enumerate", "self", "row_names", "for", "j", "col_name", "in", "enumerate", "self", "col_names", "args", "update", "dict", "row_name", "row_name", "col_name", "col_name", "title", "template", "format", "args", "self", "axes", "i", "j", "set_title", "title", "kwargs", "elif", "self", "row_names", "is", "not", "none", "and", "len", "self", "row_names", "for", "i", "row_name", "in", "enumerate", "self", "row_names", "args", "update", "dict", "row_name", "row_name", "title", "template", "format", "args", "self", "axes", "i", "0", "set_title", "title", "kwargs", "elif", "self", "col_names", "is", "not", "none", "and", "len", "self", "col_names", "for", "i", "col_name", "in", "enumerate", "self", "col_names", "args", "update", "dict", "col_name", "col_name", "title", "template", "format", "args", "index", "the", "flat", "array", "so", "col_wrap", "works", "self", "axes", "flat", "i", "set_title", "title", "kwargs", "return", "self"], "doc_len": 415}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.refline", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "refline", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\n        \"\"\"Add a reference line(s) to each facet.\n\n        Parameters\n        ----------\n        x, y : numeric\n            Value(s) to draw the line(s) at.\n        color : :mod:`matplotlib color <matplotlib.colors>`\n            Specifies the color of the reference line(s). Pass ``color=None`` to\n            use ``hue`` mapping.\n        linestyle : str\n            Specifies the style of the reference line(s).\n        line_kws : key, value mappings\n            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n            is not None.\n\n        Returns\n        -------\n        :class:`FacetGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        line_kws['color'] = color\n        line_kws['linestyle'] = linestyle\n\n        if x is not None:\n            self.map(plt.axvline, x=x, **line_kws)\n\n        if y is not None:\n            self.map(plt.axhline, y=y, **line_kws)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "refline", "self", "x", "none", "y", "none", "color", "5", "linestyle", "line_kws", "add", "a", "reference", "line", "s", "to", "each", "facet", "parameters", "x", "y", "numeric", "value", "s", "to", "draw", "the", "line", "s", "at", "color", "mod", "matplotlib", "color", "matplotlib", "colors", "specifies", "the", "color", "of", "the", "reference", "line", "s", "pass", "color", "none", "to", "use", "hue", "mapping", "linestyle", "str", "specifies", "the", "style", "of", "the", "reference", "line", "s", "line_kws", "key", "value", "mappings", "other", "keyword", "arguments", "are", "passed", "to", "meth", "matplotlib", "axes", "axes", "axvline", "when", "x", "is", "not", "none", "and", "meth", "matplotlib", "axes", "axes", "axhline", "when", "y", "is", "not", "none", "returns", "class", "facetgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "line_kws", "color", "color", "line_kws", "linestyle", "linestyle", "if", "x", "is", "not", "none", "self", "map", "plt", "axvline", "x", "x", "line_kws", "if", "y", "is", "not", "none", "self", "map", "plt", "axhline", "y", "y", "line_kws", "return", "self"], "doc_len": 139}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def axes(self):\n        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"\n        return self._axes\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "axes", "self", "an", "array", "of", "the", "class", "matplotlib", "axes", "axes", "objects", "in", "the", "grid", "return", "self", "_axes"], "doc_len": 22}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.ax", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "ax", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def ax(self):\n        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"\n        if self.axes.shape == (1, 1):\n            return self.axes[0, 0]\n        else:\n            err = (\n                \"Use the `.axes` attribute when facet variables are assigned.\"\n            )\n            raise AttributeError(err)\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "ax", "self", "the", "class", "matplotlib", "axes", "axes", "when", "no", "faceting", "variables", "are", "assigned", "if", "self", "axes", "shape", "1", "1", "return", "self", "axes", "0", "0", "else", "err", "use", "the", "axes", "attribute", "when", "facet", "variables", "are", "assigned", "raise", "attributeerror", "err"], "doc_len": 43}
{"doc_id": "seaborn/axisgrid.py::FacetGrid.axes_dict", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "axes_dict", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def axes_dict(self):\n        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.\n\n        If only one of ``row`` or ``col`` is assigned, each key is a string\n        representing a level of that variable. If both facet dimensions are\n        assigned, each key is a ``({row_level}, {col_level})`` tuple.\n\n        \"\"\"\n        return self._axes_dict\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "axes_dict", "self", "a", "mapping", "of", "facet", "names", "to", "corresponding", "class", "matplotlib", "axes", "axes", "if", "only", "one", "of", "row", "or", "col", "is", "assigned", "each", "key", "is", "a", "string", "representing", "a", "level", "of", "that", "variable", "if", "both", "facet", "dimensions", "are", "assigned", "each", "key", "is", "a", "row_level", "col_level", "tuple", "return", "self", "_axes_dict"], "doc_len": 54}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._inner_axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_inner_axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _inner_axes(self):\n        \"\"\"Return a flat array of the inner axes.\"\"\"\n        if self._col_wrap is None:\n            return self.axes[:-1, 1:].flat\n        else:\n            axes = []\n            n_empty = self._nrow * self._ncol - self._n_facets\n            for i, ax in enumerate(self.axes):\n                append = (\n                    i % self._ncol\n                    and i < (self._ncol * (self._nrow - 1))\n                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n                )\n                if append:\n                    axes.append(ax)\n            return np.array(axes, object).flat\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_inner_axes", "self", "return", "a", "flat", "array", "of", "the", "inner", "axes", "if", "self", "_col_wrap", "is", "none", "return", "self", "axes", "1", "1", "flat", "else", "axes", "n_empty", "self", "_nrow", "self", "_ncol", "self", "_n_facets", "for", "i", "ax", "in", "enumerate", "self", "axes", "append", "i", "self", "_ncol", "and", "i", "self", "_ncol", "self", "_nrow", "1", "and", "i", "self", "_ncol", "self", "_nrow", "1", "n_empty", "if", "append", "axes", "append", "ax", "return", "np", "array", "axes", "object", "flat"], "doc_len": 72}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._left_axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_left_axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _left_axes(self):\n        \"\"\"Return a flat array of the left column of axes.\"\"\"\n        if self._col_wrap is None:\n            return self.axes[:, 0].flat\n        else:\n            axes = []\n            for i, ax in enumerate(self.axes):\n                if not i % self._ncol:\n                    axes.append(ax)\n            return np.array(axes, object).flat\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_left_axes", "self", "return", "a", "flat", "array", "of", "the", "left", "column", "of", "axes", "if", "self", "_col_wrap", "is", "none", "return", "self", "axes", "0", "flat", "else", "axes", "for", "i", "ax", "in", "enumerate", "self", "axes", "if", "not", "i", "self", "_ncol", "axes", "append", "ax", "return", "np", "array", "axes", "object", "flat"], "doc_len": 50}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._not_left_axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_not_left_axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _not_left_axes(self):\n        \"\"\"Return a flat array of axes that aren't on the left column.\"\"\"\n        if self._col_wrap is None:\n            return self.axes[:, 1:].flat\n        else:\n            axes = []\n            for i, ax in enumerate(self.axes):\n                if i % self._ncol:\n                    axes.append(ax)\n            return np.array(axes, object).flat\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_not_left_axes", "self", "return", "a", "flat", "array", "of", "axes", "that", "aren", "t", "on", "the", "left", "column", "if", "self", "_col_wrap", "is", "none", "return", "self", "axes", "1", "flat", "else", "axes", "for", "i", "ax", "in", "enumerate", "self", "axes", "if", "i", "self", "_ncol", "axes", "append", "ax", "return", "np", "array", "axes", "object", "flat"], "doc_len": 52}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._bottom_axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_bottom_axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _bottom_axes(self):\n        \"\"\"Return a flat array of the bottom row of axes.\"\"\"\n        if self._col_wrap is None:\n            return self.axes[-1, :].flat\n        else:\n            axes = []\n            n_empty = self._nrow * self._ncol - self._n_facets\n            for i, ax in enumerate(self.axes):\n                append = (\n                    i >= (self._ncol * (self._nrow - 1))\n                    or i >= (self._ncol * (self._nrow - 1) - n_empty)\n                )\n                if append:\n                    axes.append(ax)\n            return np.array(axes, object).flat\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_bottom_axes", "self", "return", "a", "flat", "array", "of", "the", "bottom", "row", "of", "axes", "if", "self", "_col_wrap", "is", "none", "return", "self", "axes", "1", "flat", "else", "axes", "n_empty", "self", "_nrow", "self", "_ncol", "self", "_n_facets", "for", "i", "ax", "in", "enumerate", "self", "axes", "append", "i", "self", "_ncol", "self", "_nrow", "1", "or", "i", "self", "_ncol", "self", "_nrow", "1", "n_empty", "if", "append", "axes", "append", "ax", "return", "np", "array", "axes", "object", "flat"], "doc_len": 69}
{"doc_id": "seaborn/axisgrid.py::FacetGrid._not_bottom_axes", "file_path": "seaborn/axisgrid.py", "class_name": "FacetGrid", "func_name": "_not_bottom_axes", "text": "文件路径: seaborn/axisgrid.py, 类名: FacetGrid\n    def _not_bottom_axes(self):\n        \"\"\"Return a flat array of axes that aren't on the bottom row.\"\"\"\n        if self._col_wrap is None:\n            return self.axes[:-1, :].flat\n        else:\n            axes = []\n            n_empty = self._nrow * self._ncol - self._n_facets\n            for i, ax in enumerate(self.axes):\n                append = (\n                    i < (self._ncol * (self._nrow - 1))\n                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n                )\n                if append:\n                    axes.append(ax)\n            return np.array(axes, object).flat\n", "tokens": ["seaborn", "axisgrid", "py", "facetgrid", "def", "_not_bottom_axes", "self", "return", "a", "flat", "array", "of", "axes", "that", "aren", "t", "on", "the", "bottom", "row", "if", "self", "_col_wrap", "is", "none", "return", "self", "axes", "1", "flat", "else", "axes", "n_empty", "self", "_nrow", "self", "_ncol", "self", "_n_facets", "for", "i", "ax", "in", "enumerate", "self", "axes", "append", "i", "self", "_ncol", "self", "_nrow", "1", "and", "i", "self", "_ncol", "self", "_nrow", "1", "n_empty", "if", "append", "axes", "append", "ax", "return", "np", "array", "axes", "object", "flat"], "doc_len": 72}
{"doc_id": "seaborn/axisgrid.py::PairGrid.__init__", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "__init__", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def __init__(\n        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,\n        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,\n        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,\n    ):\n        \"\"\"Initialize the plot figure and PairGrid object.\n\n        Parameters\n        ----------\n        data : DataFrame\n            Tidy (long-form) dataframe where each column is a variable and\n            each row is an observation.\n        hue : string (variable name)\n            Variable in ``data`` to map plot aspects to different colors. This\n            variable will be excluded from the default x and y variables.\n        vars : list of variable names\n            Variables within ``data`` to use, otherwise use every column with\n            a numeric datatype.\n        {x, y}_vars : lists of variable names\n            Variables within ``data`` to use separately for the rows and\n            columns of the figure; i.e. to make a non-square plot.\n        hue_order : list of strings\n            Order for the levels of the hue variable in the palette\n        palette : dict or seaborn color palette\n            Set of colors for mapping the ``hue`` variable. If a dict, keys\n            should be values  in the ``hue`` variable.\n        hue_kws : dictionary of param -> list of values mapping\n            Other keyword arguments to insert into the plotting call to let\n            other plot attributes vary across levels of the hue variable (e.g.\n            the markers in a scatterplot).\n        corner : bool\n            If True, don't add axes to the upper (off-diagonal) triangle of the\n            grid, making this a \"corner\" plot.\n        height : scalar\n            Height (in inches) of each facet.\n        aspect : scalar\n            Aspect * height gives the width (in inches) of each facet.\n        layout_pad : scalar\n            Padding between axes; passed to ``fig.tight_layout``.\n        despine : boolean\n            Remove the top and right spines from the plots.\n        dropna : boolean\n            Drop missing values from the data before plotting.\n\n        See Also\n        --------\n        pairplot : Easily drawing common uses of :class:`PairGrid`.\n        FacetGrid : Subplot grid for plotting conditional relationships.\n\n        Examples\n        --------\n\n        .. include:: ../docstrings/PairGrid.rst\n\n        \"\"\"\n\n        super().__init__()\n\n        # Sort out the variables that define the grid\n        numeric_cols = self._find_numeric_cols(data)\n        if hue in numeric_cols:\n            numeric_cols.remove(hue)\n        if vars is not None:\n            x_vars = list(vars)\n            y_vars = list(vars)\n        if x_vars is None:\n            x_vars = numeric_cols\n        if y_vars is None:\n            y_vars = numeric_cols\n\n        if np.isscalar(x_vars):\n            x_vars = [x_vars]\n        if np.isscalar(y_vars):\n            y_vars = [y_vars]\n\n        self.x_vars = x_vars = list(x_vars)\n        self.y_vars = y_vars = list(y_vars)\n        self.square_grid = self.x_vars == self.y_vars\n\n        if not x_vars:\n            raise ValueError(\"No variables found for grid columns.\")\n        if not y_vars:\n            raise ValueError(\"No variables found for grid rows.\")\n\n        # Create the figure and the array of subplots\n        figsize = len(x_vars) * height * aspect, len(y_vars) * height\n\n        with _disable_autolayout():\n            fig = plt.figure(figsize=figsize)\n\n        axes = fig.subplots(len(y_vars), len(x_vars),\n                            sharex=\"col\", sharey=\"row\",\n                            squeeze=False)\n\n        # Possibly remove upper axes to make a corner grid\n        # Note: setting up the axes is usually the most time-intensive part\n        # of using the PairGrid. We are foregoing the speed improvement that\n        # we would get by just not setting up the hidden axes so that we can\n        # avoid implementing fig.subplots ourselves. But worth thinking about.\n        self._corner = corner\n        if corner:\n            hide_indices = np.triu_indices_from(axes, 1)\n            for i, j in zip(*hide_indices):\n                axes[i, j].remove()\n                axes[i, j] = None\n\n        self._figure = fig\n        self.axes = axes\n        self.data = data\n\n        # Save what we are going to do with the diagonal\n        self.diag_sharey = diag_sharey\n        self.diag_vars = None\n        self.diag_axes = None\n\n        self._dropna = dropna\n\n        # Label the axes\n        self._add_axis_labels()\n\n        # Sort out the hue variable\n        self._hue_var = hue\n        if hue is None:\n            self.hue_names = hue_order = [\"_nolegend_\"]\n            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                      index=data.index)\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n\n        self._orig_palette = palette\n        self._hue_order = hue_order\n        self.palette = self._get_palette(data, hue, hue_order, palette)\n        self._legend_data = {}\n\n        # Make the plot look nice\n        for ax in axes[:-1, :].flat:\n            if ax is None:\n                continue\n            for label in ax.get_xticklabels():\n                label.set_visible(False)\n            ax.xaxis.offsetText.set_visible(False)\n            ax.xaxis.label.set_visible(False)\n\n        for ax in axes[:, 1:].flat:\n            if ax is None:\n                continue\n            for label in ax.get_yticklabels():\n                label.set_visible(False)\n            ax.yaxis.offsetText.set_visible(False)\n            ax.yaxis.label.set_visible(False)\n\n        self._tight_layout_rect = [.01, .01, .99, .99]\n        self._tight_layout_pad = layout_pad\n        self._despine = despine\n        if despine:\n            utils.despine(fig=fig)\n        self.tight_layout(pad=layout_pad)\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "__init__", "self", "data", "hue", "none", "vars", "none", "x_vars", "none", "y_vars", "none", "hue_order", "none", "palette", "none", "hue_kws", "none", "corner", "false", "diag_sharey", "true", "height", "2", "5", "aspect", "1", "layout_pad", "5", "despine", "true", "dropna", "false", "initialize", "the", "plot", "figure", "and", "pairgrid", "object", "parameters", "data", "dataframe", "tidy", "long", "form", "dataframe", "where", "each", "column", "is", "a", "variable", "and", "each", "row", "is", "an", "observation", "hue", "string", "variable", "name", "variable", "in", "data", "to", "map", "plot", "aspects", "to", "different", "colors", "this", "variable", "will", "be", "excluded", "from", "the", "default", "x", "and", "y", "variables", "vars", "list", "of", "variable", "names", "variables", "within", "data", "to", "use", "otherwise", "use", "every", "column", "with", "a", "numeric", "datatype", "x", "y", "_vars", "lists", "of", "variable", "names", "variables", "within", "data", "to", "use", "separately", "for", "the", "rows", "and", "columns", "of", "the", "figure", "i", "e", "to", "make", "a", "non", "square", "plot", "hue_order", "list", "of", "strings", "order", "for", "the", "levels", "of", "the", "hue", "variable", "in", "the", "palette", "palette", "dict", "or", "seaborn", "color", "palette", "set", "of", "colors", "for", "mapping", "the", "hue", "variable", "if", "a", "dict", "keys", "should", "be", "values", "in", "the", "hue", "variable", "hue_kws", "dictionary", "of", "param", "list", "of", "values", "mapping", "other", "keyword", "arguments", "to", "insert", "into", "the", "plotting", "call", "to", "let", "other", "plot", "attributes", "vary", "across", "levels", "of", "the", "hue", "variable", "e", "g", "the", "markers", "in", "a", "scatterplot", "corner", "bool", "if", "true", "don", "t", "add", "axes", "to", "the", "upper", "off", "diagonal", "triangle", "of", "the", "grid", "making", "this", "a", "corner", "plot", "height", "scalar", "height", "in", "inches", "of", "each", "facet", "aspect", "scalar", "aspect", "height", "gives", "the", "width", "in", "inches", "of", "each", "facet", "layout_pad", "scalar", "padding", "between", "axes", "passed", "to", "fig", "tight_layout", "despine", "boolean", "remove", "the", "top", "and", "right", "spines", "from", "the", "plots", "dropna", "boolean", "drop", "missing", "values", "from", "the", "data", "before", "plotting", "see", "also", "pairplot", "easily", "drawing", "common", "uses", "of", "class", "pairgrid", "facetgrid", "subplot", "grid", "for", "plotting", "conditional", "relationships", "examples", "include", "docstrings", "pairgrid", "rst", "super", "__init__", "sort", "out", "the", "variables", "that", "define", "the", "grid", "numeric_cols", "self", "_find_numeric_cols", "data", "if", "hue", "in", "numeric_cols", "numeric_cols", "remove", "hue", "if", "vars", "is", "not", "none", "x_vars", "list", "vars", "y_vars", "list", "vars", "if", "x_vars", "is", "none", "x_vars", "numeric_cols", "if", "y_vars", "is", "none", "y_vars", "numeric_cols", "if", "np", "isscalar", "x_vars", "x_vars", "x_vars", "if", "np", "isscalar", "y_vars", "y_vars", "y_vars", "self", "x_vars", "x_vars", "list", "x_vars", "self", "y_vars", "y_vars", "list", "y_vars", "self", "square_grid", "self", "x_vars", "self", "y_vars", "if", "not", "x_vars", "raise", "valueerror", "no", "variables", "found", "for", "grid", "columns", "if", "not", "y_vars", "raise", "valueerror", "no", "variables", "found", "for", "grid", "rows", "create", "the", "figure", "and", "the", "array", "of", "subplots", "figsize", "len", "x_vars", "height", "aspect", "len", "y_vars", "height", "with", "_disable_autolayout", "fig", "plt", "figure", "figsize", "figsize", "axes", "fig", "subplots", "len", "y_vars", "len", "x_vars", "sharex", "col", "sharey", "row", "squeeze", "false", "possibly", "remove", "upper", "axes", "to", "make", "a", "corner", "grid", "note", "setting", "up", "the", "axes", "is", "usually", "the", "most", "time", "intensive", "part", "of", "using", "the", "pairgrid", "we", "are", "foregoing", "the", "speed", "improvement", "that", "we", "would", "get", "by", "just", "not", "setting", "up", "the", "hidden", "axes", "so", "that", "we", "can", "avoid", "implementing", "fig", "subplots", "ourselves", "but", "worth", "thinking", "about", "self", "_corner", "corner", "if", "corner", "hide_indices", "np", "triu_indices_from", "axes", "1", "for", "i", "j", "in", "zip", "hide_indices", "axes", "i", "j", "remove", "axes", "i", "j", "none", "self", "_figure", "fig", "self", "axes", "axes", "self", "data", "data", "save", "what", "we", "are", "going", "to", "do", "with", "the", "diagonal", "self", "diag_sharey", "diag_sharey", "self", "diag_vars", "none", "self", "diag_axes", "none", "self", "_dropna", "dropna", "label", "the", "axes", "self", "_add_axis_labels", "sort", "out", "the", "hue", "variable", "self", "_hue_var", "hue", "if", "hue", "is", "none", "self", "hue_names", "hue_order", "_nolegend_", "self", "hue_vals", "pd", "series", "_nolegend_", "len", "data", "index", "data", "index", "else", "we", "need", "hue_order", "and", "hue_names", "because", "the", "former", "is", "used", "to", "control", "the", "order", "of", "drawing", "and", "the", "latter", "is", "used", "to", "control", "the", "order", "of", "the", "legend", "hue_names", "can", "become", "string", "typed", "while", "hue_order", "must", "retain", "the", "type", "of", "the", "input", "data", "this", "is", "messy", "but", "results", "from", "the", "fact", "that", "pairgrid", "can", "implement", "the", "hue", "mapping", "logic", "itself", "and", "was", "originally", "written", "exclusively", "that", "way", "but", "now", "can", "delegate", "to", "the", "axes", "level", "functions", "while", "always", "handling", "legend", "creation", "see", "gh2307", "hue_names", "hue_order", "categorical_order", "data", "hue", "hue_order", "if", "dropna", "filter", "na", "from", "the", "list", "of", "unique", "hue", "names", "hue_names", "list", "filter", "pd", "notnull", "hue_names", "self", "hue_names", "hue_names", "self", "hue_vals", "data", "hue", "additional", "dict", "of", "kwarg", "list", "of", "values", "for", "mapping", "the", "hue", "var", "self", "hue_kws", "hue_kws", "if", "hue_kws", "is", "not", "none", "else", "self", "_orig_palette", "palette", "self", "_hue_order", "hue_order", "self", "palette", "self", "_get_palette", "data", "hue", "hue_order", "palette", "self", "_legend_data", "make", "the", "plot", "look", "nice", "for", "ax", "in", "axes", "1", "flat", "if", "ax", "is", "none", "continue", "for", "label", "in", "ax", "get_xticklabels", "label", "set_visible", "false", "ax", "xaxis", "offsettext", "set_visible", "false", "ax", "xaxis", "label", "set_visible", "false", "for", "ax", "in", "axes", "1", "flat", "if", "ax", "is", "none", "continue", "for", "label", "in", "ax", "get_yticklabels", "label", "set_visible", "false", "ax", "yaxis", "offsettext", "set_visible", "false", "ax", "yaxis", "label", "set_visible", "false", "self", "_tight_layout_rect", "01", "01", "99", "99", "self", "_tight_layout_pad", "layout_pad", "self", "_despine", "despine", "if", "despine", "utils", "despine", "fig", "fig", "self", "tight_layout", "pad", "layout_pad"], "doc_len": 814}
{"doc_id": "seaborn/axisgrid.py::PairGrid.map", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "map", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def map(self, func, **kwargs):\n        \"\"\"Plot with the same function in every subplot.\n\n        Parameters\n        ----------\n        func : callable plotting function\n            Must take x, y arrays as positional arguments and draw onto the\n            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n            called ``color`` and  ``label``.\n\n        \"\"\"\n        row_indices, col_indices = np.indices(self.axes.shape)\n        indices = zip(row_indices.flat, col_indices.flat)\n        self._map_bivariate(func, indices, **kwargs)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "map", "self", "func", "kwargs", "plot", "with", "the", "same", "function", "in", "every", "subplot", "parameters", "func", "callable", "plotting", "function", "must", "take", "x", "y", "arrays", "as", "positional", "arguments", "and", "draw", "onto", "the", "currently", "active", "matplotlib", "axes", "also", "needs", "to", "accept", "kwargs", "called", "color", "and", "label", "row_indices", "col_indices", "np", "indices", "self", "axes", "shape", "indices", "zip", "row_indices", "flat", "col_indices", "flat", "self", "_map_bivariate", "func", "indices", "kwargs", "return", "self"], "doc_len": 67}
{"doc_id": "seaborn/axisgrid.py::PairGrid.map_lower", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "map_lower", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def map_lower(self, func, **kwargs):\n        \"\"\"Plot with a bivariate function on the lower diagonal subplots.\n\n        Parameters\n        ----------\n        func : callable plotting function\n            Must take x, y arrays as positional arguments and draw onto the\n            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n            called ``color`` and  ``label``.\n\n        \"\"\"\n        indices = zip(*np.tril_indices_from(self.axes, -1))\n        self._map_bivariate(func, indices, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "map_lower", "self", "func", "kwargs", "plot", "with", "a", "bivariate", "function", "on", "the", "lower", "diagonal", "subplots", "parameters", "func", "callable", "plotting", "function", "must", "take", "x", "y", "arrays", "as", "positional", "arguments", "and", "draw", "onto", "the", "currently", "active", "matplotlib", "axes", "also", "needs", "to", "accept", "kwargs", "called", "color", "and", "label", "indices", "zip", "np", "tril_indices_from", "self", "axes", "1", "self", "_map_bivariate", "func", "indices", "kwargs", "return", "self"], "doc_len": 63}
{"doc_id": "seaborn/axisgrid.py::PairGrid.map_upper", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "map_upper", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def map_upper(self, func, **kwargs):\n        \"\"\"Plot with a bivariate function on the upper diagonal subplots.\n\n        Parameters\n        ----------\n        func : callable plotting function\n            Must take x, y arrays as positional arguments and draw onto the\n            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n            called ``color`` and  ``label``.\n\n        \"\"\"\n        indices = zip(*np.triu_indices_from(self.axes, 1))\n        self._map_bivariate(func, indices, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "map_upper", "self", "func", "kwargs", "plot", "with", "a", "bivariate", "function", "on", "the", "upper", "diagonal", "subplots", "parameters", "func", "callable", "plotting", "function", "must", "take", "x", "y", "arrays", "as", "positional", "arguments", "and", "draw", "onto", "the", "currently", "active", "matplotlib", "axes", "also", "needs", "to", "accept", "kwargs", "called", "color", "and", "label", "indices", "zip", "np", "triu_indices_from", "self", "axes", "1", "self", "_map_bivariate", "func", "indices", "kwargs", "return", "self"], "doc_len": 63}
{"doc_id": "seaborn/axisgrid.py::PairGrid.map_offdiag", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "map_offdiag", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def map_offdiag(self, func, **kwargs):\n        \"\"\"Plot with a bivariate function on the off-diagonal subplots.\n\n        Parameters\n        ----------\n        func : callable plotting function\n            Must take x, y arrays as positional arguments and draw onto the\n            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n            called ``color`` and  ``label``.\n\n        \"\"\"\n        if self.square_grid:\n            self.map_lower(func, **kwargs)\n            if not self._corner:\n                self.map_upper(func, **kwargs)\n        else:\n            indices = []\n            for i, (y_var) in enumerate(self.y_vars):\n                for j, (x_var) in enumerate(self.x_vars):\n                    if x_var != y_var:\n                        indices.append((i, j))\n            self._map_bivariate(func, indices, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "map_offdiag", "self", "func", "kwargs", "plot", "with", "a", "bivariate", "function", "on", "the", "off", "diagonal", "subplots", "parameters", "func", "callable", "plotting", "function", "must", "take", "x", "y", "arrays", "as", "positional", "arguments", "and", "draw", "onto", "the", "currently", "active", "matplotlib", "axes", "also", "needs", "to", "accept", "kwargs", "called", "color", "and", "label", "if", "self", "square_grid", "self", "map_lower", "func", "kwargs", "if", "not", "self", "_corner", "self", "map_upper", "func", "kwargs", "else", "indices", "for", "i", "y_var", "in", "enumerate", "self", "y_vars", "for", "j", "x_var", "in", "enumerate", "self", "x_vars", "if", "x_var", "y_var", "indices", "append", "i", "j", "self", "_map_bivariate", "func", "indices", "kwargs", "return", "self"], "doc_len": 94}
{"doc_id": "seaborn/axisgrid.py::PairGrid.map_diag", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "map_diag", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def map_diag(self, func, **kwargs):\n        \"\"\"Plot with a univariate function on each diagonal subplot.\n\n        Parameters\n        ----------\n        func : callable plotting function\n            Must take an x array as a positional argument and draw onto the\n            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n            called ``color`` and  ``label``.\n\n        \"\"\"\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n                        # Remove main y axis from density axes in a corner plot\n                        if self._corner:\n                            ax.yaxis.set_visible(False)\n                            if self._despine:\n                                utils.despine(ax=ax, left=True)\n                            # TODO add optional density ticks (on the right)\n                            # when drawing a corner plot?\n\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = np.array(diag_vars, np.object_)\n            self.diag_axes = np.array(diag_axes, np.object_)\n\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n            else:\n                hue = None\n\n            if self._dropna:\n                not_na = vector.notna()\n                if hue is not None:\n                    not_na &= hue.notna()\n                vector = vector[not_na]\n                if hue is not None:\n                    hue = hue[not_na]\n\n            plot_kwargs.setdefault(\"hue\", hue)\n            plot_kwargs.setdefault(\"hue_order\", self._hue_order)\n            plot_kwargs.setdefault(\"palette\", self._orig_palette)\n            func(x=vector, **plot_kwargs)\n            ax.legend_ = None\n\n        self._add_axis_labels()\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "map_diag", "self", "func", "kwargs", "plot", "with", "a", "univariate", "function", "on", "each", "diagonal", "subplot", "parameters", "func", "callable", "plotting", "function", "must", "take", "an", "x", "array", "as", "a", "positional", "argument", "and", "draw", "onto", "the", "currently", "active", "matplotlib", "axes", "also", "needs", "to", "accept", "kwargs", "called", "color", "and", "label", "add", "special", "diagonal", "axes", "for", "the", "univariate", "plot", "if", "self", "diag_axes", "is", "none", "diag_vars", "diag_axes", "for", "i", "y_var", "in", "enumerate", "self", "y_vars", "for", "j", "x_var", "in", "enumerate", "self", "x_vars", "if", "x_var", "y_var", "make", "the", "density", "axes", "diag_vars", "append", "x_var", "ax", "self", "axes", "i", "j", "diag_ax", "ax", "twinx", "diag_ax", "set_axis_off", "diag_axes", "append", "diag_ax", "work", "around", "matplotlib", "bug", "https", "github", "com", "matplotlib", "matplotlib", "issues", "15188", "if", "not", "plt", "rcparams", "get", "ytick", "left", "true", "for", "tick", "in", "ax", "yaxis", "majorticks", "tick", "tick1line", "set_visible", "false", "remove", "main", "y", "axis", "from", "density", "axes", "in", "a", "corner", "plot", "if", "self", "_corner", "ax", "yaxis", "set_visible", "false", "if", "self", "_despine", "utils", "despine", "ax", "ax", "left", "true", "todo", "add", "optional", "density", "ticks", "on", "the", "right", "when", "drawing", "a", "corner", "plot", "if", "self", "diag_sharey", "and", "diag_axes", "for", "ax", "in", "diag_axes", "1", "share_axis", "diag_axes", "0", "ax", "y", "self", "diag_vars", "np", "array", "diag_vars", "np", "object_", "self", "diag_axes", "np", "array", "diag_axes", "np", "object_", "if", "hue", "not", "in", "signature", "func", "parameters", "return", "self", "_map_diag_iter_hue", "func", "kwargs", "loop", "over", "diagonal", "variables", "and", "axes", "making", "one", "plot", "in", "each", "for", "var", "ax", "in", "zip", "self", "diag_vars", "self", "diag_axes", "plot_kwargs", "kwargs", "copy", "if", "str", "func", "__module__", "startswith", "seaborn", "plot_kwargs", "ax", "ax", "else", "plt", "sca", "ax", "vector", "self", "data", "var", "if", "self", "_hue_var", "is", "not", "none", "hue", "self", "data", "self", "_hue_var", "else", "hue", "none", "if", "self", "_dropna", "not_na", "vector", "notna", "if", "hue", "is", "not", "none", "not_na", "hue", "notna", "vector", "vector", "not_na", "if", "hue", "is", "not", "none", "hue", "hue", "not_na", "plot_kwargs", "setdefault", "hue", "hue", "plot_kwargs", "setdefault", "hue_order", "self", "_hue_order", "plot_kwargs", "setdefault", "palette", "self", "_orig_palette", "func", "x", "vector", "plot_kwargs", "ax", "legend_", "none", "self", "_add_axis_labels", "return", "self"], "doc_len": 315}
{"doc_id": "seaborn/axisgrid.py::PairGrid._map_diag_iter_hue", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_map_diag_iter_hue", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _map_diag_iter_hue(self, func, **kwargs):\n        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"\n        # Plot on each of the diagonal axes\n        fixed_color = kwargs.pop(\"color\", None)\n\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n            hue_grouped = self.data[var].groupby(self.hue_vals)\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            for k, label_k in enumerate(self._hue_order):\n\n                # Attempt to get data for this level, allowing for empty\n                try:\n                    data_k = hue_grouped.get_group(label_k)\n                except KeyError:\n                    data_k = pd.Series([], dtype=float)\n\n                if fixed_color is None:\n                    color = self.palette[k]\n                else:\n                    color = fixed_color\n\n                if self._dropna:\n                    data_k = utils.remove_na(data_k)\n\n                if str(func.__module__).startswith(\"seaborn\"):\n                    func(x=data_k, label=label_k, color=color, **plot_kwargs)\n                else:\n                    func(data_k, label=label_k, color=color, **plot_kwargs)\n\n        self._add_axis_labels()\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_map_diag_iter_hue", "self", "func", "kwargs", "put", "marginal", "plot", "on", "each", "diagonal", "axes", "iterating", "over", "hue", "plot", "on", "each", "of", "the", "diagonal", "axes", "fixed_color", "kwargs", "pop", "color", "none", "for", "var", "ax", "in", "zip", "self", "diag_vars", "self", "diag_axes", "hue_grouped", "self", "data", "var", "groupby", "self", "hue_vals", "plot_kwargs", "kwargs", "copy", "if", "str", "func", "__module__", "startswith", "seaborn", "plot_kwargs", "ax", "ax", "else", "plt", "sca", "ax", "for", "k", "label_k", "in", "enumerate", "self", "_hue_order", "attempt", "to", "get", "data", "for", "this", "level", "allowing", "for", "empty", "try", "data_k", "hue_grouped", "get_group", "label_k", "except", "keyerror", "data_k", "pd", "series", "dtype", "float", "if", "fixed_color", "is", "none", "color", "self", "palette", "k", "else", "color", "fixed_color", "if", "self", "_dropna", "data_k", "utils", "remove_na", "data_k", "if", "str", "func", "__module__", "startswith", "seaborn", "func", "x", "data_k", "label", "label_k", "color", "color", "plot_kwargs", "else", "func", "data_k", "label", "label_k", "color", "color", "plot_kwargs", "self", "_add_axis_labels", "return", "self"], "doc_len": 136}
{"doc_id": "seaborn/axisgrid.py::PairGrid._map_bivariate", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_map_bivariate", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _map_bivariate(self, func, indices, **kwargs):\n        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"\n        # This is a hack to handle the fact that new distribution plots don't add\n        # their artists onto the axes. This is probably superior in general, but\n        # we'll need a better way to handle it in the axisgrid functions.\n        from .distributions import histplot, kdeplot\n        if func is histplot or func is kdeplot:\n            self._extract_legend_handles = True\n\n        kws = kwargs.copy()  # Use copy as we insert other kwargs\n        for i, j in indices:\n            x_var = self.x_vars[j]\n            y_var = self.y_vars[i]\n            ax = self.axes[i, j]\n            if ax is None:  # i.e. we are in corner mode\n                continue\n            self._plot_bivariate(x_var, y_var, ax, func, **kws)\n        self._add_axis_labels()\n\n        if \"hue\" in signature(func).parameters:\n            self.hue_names = list(self._legend_data)\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_map_bivariate", "self", "func", "indices", "kwargs", "draw", "a", "bivariate", "plot", "on", "the", "indicated", "axes", "this", "is", "a", "hack", "to", "handle", "the", "fact", "that", "new", "distribution", "plots", "don", "t", "add", "their", "artists", "onto", "the", "axes", "this", "is", "probably", "superior", "in", "general", "but", "we", "ll", "need", "a", "better", "way", "to", "handle", "it", "in", "the", "axisgrid", "functions", "from", "distributions", "import", "histplot", "kdeplot", "if", "func", "is", "histplot", "or", "func", "is", "kdeplot", "self", "_extract_legend_handles", "true", "kws", "kwargs", "copy", "use", "copy", "as", "we", "insert", "other", "kwargs", "for", "i", "j", "in", "indices", "x_var", "self", "x_vars", "j", "y_var", "self", "y_vars", "i", "ax", "self", "axes", "i", "j", "if", "ax", "is", "none", "i", "e", "we", "are", "in", "corner", "mode", "continue", "self", "_plot_bivariate", "x_var", "y_var", "ax", "func", "kws", "self", "_add_axis_labels", "if", "hue", "in", "signature", "func", "parameters", "self", "hue_names", "list", "self", "_legend_data"], "doc_len": 134}
{"doc_id": "seaborn/axisgrid.py::PairGrid._plot_bivariate", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_plot_bivariate", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):\n        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"\n        if \"hue\" not in signature(func).parameters:\n            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)\n            return\n\n        kwargs = kwargs.copy()\n        if str(func.__module__).startswith(\"seaborn\"):\n            kwargs[\"ax\"] = ax\n        else:\n            plt.sca(ax)\n\n        if x_var == y_var:\n            axes_vars = [x_var]\n        else:\n            axes_vars = [x_var, y_var]\n\n        if self._hue_var is not None and self._hue_var not in axes_vars:\n            axes_vars.append(self._hue_var)\n\n        data = self.data[axes_vars]\n        if self._dropna:\n            data = data.dropna()\n\n        x = data[x_var]\n        y = data[y_var]\n        if self._hue_var is None:\n            hue = None\n        else:\n            hue = data.get(self._hue_var)\n\n        if \"hue\" not in kwargs:\n            kwargs.update({\n                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,\n            })\n        func(x=x, y=y, **kwargs)\n\n        self._update_legend_data(ax)\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_plot_bivariate", "self", "x_var", "y_var", "ax", "func", "kwargs", "draw", "a", "bivariate", "plot", "on", "the", "specified", "axes", "if", "hue", "not", "in", "signature", "func", "parameters", "self", "_plot_bivariate_iter_hue", "x_var", "y_var", "ax", "func", "kwargs", "return", "kwargs", "kwargs", "copy", "if", "str", "func", "__module__", "startswith", "seaborn", "kwargs", "ax", "ax", "else", "plt", "sca", "ax", "if", "x_var", "y_var", "axes_vars", "x_var", "else", "axes_vars", "x_var", "y_var", "if", "self", "_hue_var", "is", "not", "none", "and", "self", "_hue_var", "not", "in", "axes_vars", "axes_vars", "append", "self", "_hue_var", "data", "self", "data", "axes_vars", "if", "self", "_dropna", "data", "data", "dropna", "x", "data", "x_var", "y", "data", "y_var", "if", "self", "_hue_var", "is", "none", "hue", "none", "else", "hue", "data", "get", "self", "_hue_var", "if", "hue", "not", "in", "kwargs", "kwargs", "update", "hue", "hue", "hue_order", "self", "_hue_order", "palette", "self", "_orig_palette", "func", "x", "x", "y", "y", "kwargs", "self", "_update_legend_data", "ax"], "doc_len": 129}
{"doc_id": "seaborn/axisgrid.py::PairGrid._plot_bivariate_iter_hue", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_plot_bivariate_iter_hue", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):\n        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"\n        kwargs = kwargs.copy()\n        if str(func.__module__).startswith(\"seaborn\"):\n            kwargs[\"ax\"] = ax\n        else:\n            plt.sca(ax)\n\n        if x_var == y_var:\n            axes_vars = [x_var]\n        else:\n            axes_vars = [x_var, y_var]\n\n        hue_grouped = self.data.groupby(self.hue_vals)\n        for k, label_k in enumerate(self._hue_order):\n\n            kws = kwargs.copy()\n\n            # Attempt to get data for this level, allowing for empty\n            try:\n                data_k = hue_grouped.get_group(label_k)\n            except KeyError:\n                data_k = pd.DataFrame(columns=axes_vars,\n                                      dtype=float)\n\n            if self._dropna:\n                data_k = data_k[axes_vars].dropna()\n\n            x = data_k[x_var]\n            y = data_k[y_var]\n\n            for kw, val_list in self.hue_kws.items():\n                kws[kw] = val_list[k]\n            kws.setdefault(\"color\", self.palette[k])\n            if self._hue_var is not None:\n                kws[\"label\"] = label_k\n\n            if str(func.__module__).startswith(\"seaborn\"):\n                func(x=x, y=y, **kws)\n            else:\n                func(x, y, **kws)\n\n        self._update_legend_data(ax)\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_plot_bivariate_iter_hue", "self", "x_var", "y_var", "ax", "func", "kwargs", "draw", "a", "bivariate", "plot", "while", "iterating", "over", "hue", "subsets", "kwargs", "kwargs", "copy", "if", "str", "func", "__module__", "startswith", "seaborn", "kwargs", "ax", "ax", "else", "plt", "sca", "ax", "if", "x_var", "y_var", "axes_vars", "x_var", "else", "axes_vars", "x_var", "y_var", "hue_grouped", "self", "data", "groupby", "self", "hue_vals", "for", "k", "label_k", "in", "enumerate", "self", "_hue_order", "kws", "kwargs", "copy", "attempt", "to", "get", "data", "for", "this", "level", "allowing", "for", "empty", "try", "data_k", "hue_grouped", "get_group", "label_k", "except", "keyerror", "data_k", "pd", "dataframe", "columns", "axes_vars", "dtype", "float", "if", "self", "_dropna", "data_k", "data_k", "axes_vars", "dropna", "x", "data_k", "x_var", "y", "data_k", "y_var", "for", "kw", "val_list", "in", "self", "hue_kws", "items", "kws", "kw", "val_list", "k", "kws", "setdefault", "color", "self", "palette", "k", "if", "self", "_hue_var", "is", "not", "none", "kws", "label", "label_k", "if", "str", "func", "__module__", "startswith", "seaborn", "func", "x", "x", "y", "y", "kws", "else", "func", "x", "y", "kws", "self", "_update_legend_data", "ax"], "doc_len": 145}
{"doc_id": "seaborn/axisgrid.py::PairGrid._add_axis_labels", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_add_axis_labels", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _add_axis_labels(self):\n        \"\"\"Add labels to the left and bottom Axes.\"\"\"\n        for ax, label in zip(self.axes[-1, :], self.x_vars):\n            ax.set_xlabel(label)\n        for ax, label in zip(self.axes[:, 0], self.y_vars):\n            ax.set_ylabel(label)\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_add_axis_labels", "self", "add", "labels", "to", "the", "left", "and", "bottom", "axes", "for", "ax", "label", "in", "zip", "self", "axes", "1", "self", "x_vars", "ax", "set_xlabel", "label", "for", "ax", "label", "in", "zip", "self", "axes", "0", "self", "y_vars", "ax", "set_ylabel", "label"], "doc_len": 41}
{"doc_id": "seaborn/axisgrid.py::PairGrid._find_numeric_cols", "file_path": "seaborn/axisgrid.py", "class_name": "PairGrid", "func_name": "_find_numeric_cols", "text": "文件路径: seaborn/axisgrid.py, 类名: PairGrid\n    def _find_numeric_cols(self, data):\n        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n        numeric_cols = []\n        for col in data:\n            if variable_type(data[col]) == \"numeric\":\n                numeric_cols.append(col)\n        return numeric_cols\n", "tokens": ["seaborn", "axisgrid", "py", "pairgrid", "def", "_find_numeric_cols", "self", "data", "find", "which", "variables", "in", "a", "dataframe", "are", "numeric", "numeric_cols", "for", "col", "in", "data", "if", "variable_type", "data", "col", "numeric", "numeric_cols", "append", "col", "return", "numeric_cols"], "doc_len": 31}
{"doc_id": "seaborn/axisgrid.py::JointGrid.__init__", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "__init__", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def __init__(\n        self, data=None, *,\n        x=None, y=None, hue=None,\n        height=6, ratio=5, space=.2,\n        palette=None, hue_order=None, hue_norm=None,\n        dropna=False, xlim=None, ylim=None, marginal_ticks=False,\n    ):\n\n        # Set up the subplot grid\n        f = plt.figure(figsize=(height, height))\n        gs = plt.GridSpec(ratio + 1, ratio + 1)\n\n        ax_joint = f.add_subplot(gs[1:, :-1])\n        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)\n        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)\n\n        self._figure = f\n        self.ax_joint = ax_joint\n        self.ax_marg_x = ax_marg_x\n        self.ax_marg_y = ax_marg_y\n\n        # Turn off tick visibility for the measure axis on the marginal plots\n        plt.setp(ax_marg_x.get_xticklabels(), visible=False)\n        plt.setp(ax_marg_y.get_yticklabels(), visible=False)\n        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)\n        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)\n\n        # Turn off the ticks on the density axis for the marginal plots\n        if not marginal_ticks:\n            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)\n            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)\n            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)\n            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)\n            plt.setp(ax_marg_x.get_yticklabels(), visible=False)\n            plt.setp(ax_marg_y.get_xticklabels(), visible=False)\n            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)\n            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)\n            ax_marg_x.yaxis.grid(False)\n            ax_marg_y.xaxis.grid(False)\n\n        # Process the input variables\n        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))\n        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]\n\n        # Possibly drop NA\n        if dropna:\n            plot_data = plot_data.dropna()\n\n        def get_var(var):\n            vector = plot_data.get(var, None)\n            if vector is not None:\n                vector = vector.rename(p.variables.get(var, None))\n            return vector\n\n        self.x = get_var(\"x\")\n        self.y = get_var(\"y\")\n        self.hue = get_var(\"hue\")\n\n        for axis in \"xy\":\n            name = p.variables.get(axis, None)\n            if name is not None:\n                getattr(ax_joint, f\"set_{axis}label\")(name)\n\n        if xlim is not None:\n            ax_joint.set_xlim(xlim)\n        if ylim is not None:\n            ax_joint.set_ylim(ylim)\n\n        # Store the semantic mapping parameters for axes-level functions\n        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)\n\n        # Make the grid look nice\n        utils.despine(f)\n        if not marginal_ticks:\n            utils.despine(ax=ax_marg_x, left=True)\n            utils.despine(ax=ax_marg_y, bottom=True)\n        for axes in [ax_marg_x, ax_marg_y]:\n            for axis in [axes.xaxis, axes.yaxis]:\n                axis.label.set_visible(False)\n        f.tight_layout()\n        f.subplots_adjust(hspace=space, wspace=space)\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "__init__", "self", "data", "none", "x", "none", "y", "none", "hue", "none", "height", "6", "ratio", "5", "space", "2", "palette", "none", "hue_order", "none", "hue_norm", "none", "dropna", "false", "xlim", "none", "ylim", "none", "marginal_ticks", "false", "set", "up", "the", "subplot", "grid", "f", "plt", "figure", "figsize", "height", "height", "gs", "plt", "gridspec", "ratio", "1", "ratio", "1", "ax_joint", "f", "add_subplot", "gs", "1", "1", "ax_marg_x", "f", "add_subplot", "gs", "0", "1", "sharex", "ax_joint", "ax_marg_y", "f", "add_subplot", "gs", "1", "1", "sharey", "ax_joint", "self", "_figure", "f", "self", "ax_joint", "ax_joint", "self", "ax_marg_x", "ax_marg_x", "self", "ax_marg_y", "ax_marg_y", "turn", "off", "tick", "visibility", "for", "the", "measure", "axis", "on", "the", "marginal", "plots", "plt", "setp", "ax_marg_x", "get_xticklabels", "visible", "false", "plt", "setp", "ax_marg_y", "get_yticklabels", "visible", "false", "plt", "setp", "ax_marg_x", "get_xticklabels", "minor", "true", "visible", "false", "plt", "setp", "ax_marg_y", "get_yticklabels", "minor", "true", "visible", "false", "turn", "off", "the", "ticks", "on", "the", "density", "axis", "for", "the", "marginal", "plots", "if", "not", "marginal_ticks", "plt", "setp", "ax_marg_x", "yaxis", "get_majorticklines", "visible", "false", "plt", "setp", "ax_marg_x", "yaxis", "get_minorticklines", "visible", "false", "plt", "setp", "ax_marg_y", "xaxis", "get_majorticklines", "visible", "false", "plt", "setp", "ax_marg_y", "xaxis", "get_minorticklines", "visible", "false", "plt", "setp", "ax_marg_x", "get_yticklabels", "visible", "false", "plt", "setp", "ax_marg_y", "get_xticklabels", "visible", "false", "plt", "setp", "ax_marg_x", "get_yticklabels", "minor", "true", "visible", "false", "plt", "setp", "ax_marg_y", "get_xticklabels", "minor", "true", "visible", "false", "ax_marg_x", "yaxis", "grid", "false", "ax_marg_y", "xaxis", "grid", "false", "process", "the", "input", "variables", "p", "vectorplotter", "data", "data", "variables", "dict", "x", "x", "y", "y", "hue", "hue", "plot_data", "p", "plot_data", "loc", "p", "plot_data", "notna", "any", "possibly", "drop", "na", "if", "dropna", "plot_data", "plot_data", "dropna", "def", "get_var", "var", "vector", "plot_data", "get", "var", "none", "if", "vector", "is", "not", "none", "vector", "vector", "rename", "p", "variables", "get", "var", "none", "return", "vector", "self", "x", "get_var", "x", "self", "y", "get_var", "y", "self", "hue", "get_var", "hue", "for", "axis", "in", "xy", "name", "p", "variables", "get", "axis", "none", "if", "name", "is", "not", "none", "getattr", "ax_joint", "f", "set_", "axis", "label", "name", "if", "xlim", "is", "not", "none", "ax_joint", "set_xlim", "xlim", "if", "ylim", "is", "not", "none", "ax_joint", "set_ylim", "ylim", "store", "the", "semantic", "mapping", "parameters", "for", "axes", "level", "functions", "self", "_hue_params", "dict", "palette", "palette", "hue_order", "hue_order", "hue_norm", "hue_norm", "make", "the", "grid", "look", "nice", "utils", "despine", "f", "if", "not", "marginal_ticks", "utils", "despine", "ax", "ax_marg_x", "left", "true", "utils", "despine", "ax", "ax_marg_y", "bottom", "true", "for", "axes", "in", "ax_marg_x", "ax_marg_y", "for", "axis", "in", "axes", "xaxis", "axes", "yaxis", "axis", "label", "set_visible", "false", "f", "tight_layout", "f", "subplots_adjust", "hspace", "space", "wspace", "space"], "doc_len": 376}
{"doc_id": "seaborn/axisgrid.py::JointGrid._inject_kwargs", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "_inject_kwargs", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def _inject_kwargs(self, func, kws, params):\n        \"\"\"Add params to kws if they are accepted by func.\"\"\"\n        func_params = signature(func).parameters\n        for key, val in params.items():\n            if key in func_params:\n                kws.setdefault(key, val)\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "_inject_kwargs", "self", "func", "kws", "params", "add", "params", "to", "kws", "if", "they", "are", "accepted", "by", "func", "func_params", "signature", "func", "parameters", "for", "key", "val", "in", "params", "items", "if", "key", "in", "func_params", "kws", "setdefault", "key", "val"], "doc_len": 38}
{"doc_id": "seaborn/axisgrid.py::JointGrid.plot", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "plot", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def plot(self, joint_func, marginal_func, **kwargs):\n        \"\"\"Draw the plot by passing functions for joint and marginal axes.\n\n        This method passes the ``kwargs`` dictionary to both functions. If you\n        need more control, call :meth:`JointGrid.plot_joint` and\n        :meth:`JointGrid.plot_marginals` directly with specific parameters.\n\n        Parameters\n        ----------\n        joint_func, marginal_func : callables\n            Functions to draw the bivariate and univariate plots. See methods\n            referenced above for information about the required characteristics\n            of these functions.\n        kwargs\n            Additional keyword arguments are passed to both functions.\n\n        Returns\n        -------\n        :class:`JointGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        self.plot_marginals(marginal_func, **kwargs)\n        self.plot_joint(joint_func, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "plot", "self", "joint_func", "marginal_func", "kwargs", "draw", "the", "plot", "by", "passing", "functions", "for", "joint", "and", "marginal", "axes", "this", "method", "passes", "the", "kwargs", "dictionary", "to", "both", "functions", "if", "you", "need", "more", "control", "call", "meth", "jointgrid", "plot_joint", "and", "meth", "jointgrid", "plot_marginals", "directly", "with", "specific", "parameters", "parameters", "joint_func", "marginal_func", "callables", "functions", "to", "draw", "the", "bivariate", "and", "univariate", "plots", "see", "methods", "referenced", "above", "for", "information", "about", "the", "required", "characteristics", "of", "these", "functions", "kwargs", "additional", "keyword", "arguments", "are", "passed", "to", "both", "functions", "returns", "class", "jointgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "self", "plot_marginals", "marginal_func", "kwargs", "self", "plot_joint", "joint_func", "kwargs", "return", "self"], "doc_len": 101}
{"doc_id": "seaborn/axisgrid.py::JointGrid.plot_joint", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "plot_joint", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def plot_joint(self, func, **kwargs):\n        \"\"\"Draw a bivariate plot on the joint axes of the grid.\n\n        Parameters\n        ----------\n        func : plotting callable\n            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,\n            it must accept ``x`` and ``y`` vectors of data as the first two\n            positional arguments, and it must plot on the \"current\" axes.\n            If ``hue`` was defined in the class constructor, the function must\n            accept ``hue`` as a parameter.\n        kwargs\n            Keyword argument are passed to the plotting function.\n\n        Returns\n        -------\n        :class:`JointGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        kwargs = kwargs.copy()\n        if str(func.__module__).startswith(\"seaborn\"):\n            kwargs[\"ax\"] = self.ax_joint\n        else:\n            plt.sca(self.ax_joint)\n        if self.hue is not None:\n            kwargs[\"hue\"] = self.hue\n            self._inject_kwargs(func, kwargs, self._hue_params)\n\n        if str(func.__module__).startswith(\"seaborn\"):\n            func(x=self.x, y=self.y, **kwargs)\n        else:\n            func(self.x, self.y, **kwargs)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "plot_joint", "self", "func", "kwargs", "draw", "a", "bivariate", "plot", "on", "the", "joint", "axes", "of", "the", "grid", "parameters", "func", "plotting", "callable", "if", "a", "seaborn", "function", "it", "should", "accept", "x", "and", "y", "otherwise", "it", "must", "accept", "x", "and", "y", "vectors", "of", "data", "as", "the", "first", "two", "positional", "arguments", "and", "it", "must", "plot", "on", "the", "current", "axes", "if", "hue", "was", "defined", "in", "the", "class", "constructor", "the", "function", "must", "accept", "hue", "as", "a", "parameter", "kwargs", "keyword", "argument", "are", "passed", "to", "the", "plotting", "function", "returns", "class", "jointgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "kwargs", "kwargs", "copy", "if", "str", "func", "__module__", "startswith", "seaborn", "kwargs", "ax", "self", "ax_joint", "else", "plt", "sca", "self", "ax_joint", "if", "self", "hue", "is", "not", "none", "kwargs", "hue", "self", "hue", "self", "_inject_kwargs", "func", "kwargs", "self", "_hue_params", "if", "str", "func", "__module__", "startswith", "seaborn", "func", "x", "self", "x", "y", "self", "y", "kwargs", "else", "func", "self", "x", "self", "y", "kwargs", "return", "self"], "doc_len": 150}
{"doc_id": "seaborn/axisgrid.py::JointGrid.plot_marginals", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "plot_marginals", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def plot_marginals(self, func, **kwargs):\n        \"\"\"Draw univariate plots on each marginal axes.\n\n        Parameters\n        ----------\n        func : plotting callable\n            If a seaborn function, it should  accept ``x`` and ``y`` and plot\n            when only one of them is defined. Otherwise, it must accept a vector\n            of data as the first positional argument and determine its orientation\n            using the ``vertical`` parameter, and it must plot on the \"current\" axes.\n            If ``hue`` was defined in the class constructor, it must accept ``hue``\n            as a parameter.\n        kwargs\n            Keyword argument are passed to the plotting function.\n\n        Returns\n        -------\n        :class:`JointGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        seaborn_func = (\n            str(func.__module__).startswith(\"seaborn\")\n            # deprecated distplot has a legacy API, special case it\n            and not func.__name__ == \"distplot\"\n        )\n        func_params = signature(func).parameters\n        kwargs = kwargs.copy()\n        if self.hue is not None:\n            kwargs[\"hue\"] = self.hue\n            self._inject_kwargs(func, kwargs, self._hue_params)\n\n        if \"legend\" in func_params:\n            kwargs.setdefault(\"legend\", False)\n\n        if \"orientation\" in func_params:\n            # e.g. plt.hist\n            orient_kw_x = {\"orientation\": \"vertical\"}\n            orient_kw_y = {\"orientation\": \"horizontal\"}\n        elif \"vertical\" in func_params:\n            # e.g. sns.distplot (also how did this get backwards?)\n            orient_kw_x = {\"vertical\": False}\n            orient_kw_y = {\"vertical\": True}\n\n        if seaborn_func:\n            func(x=self.x, ax=self.ax_marg_x, **kwargs)\n        else:\n            plt.sca(self.ax_marg_x)\n            func(self.x, **orient_kw_x, **kwargs)\n\n        if seaborn_func:\n            func(y=self.y, ax=self.ax_marg_y, **kwargs)\n        else:\n            plt.sca(self.ax_marg_y)\n            func(self.y, **orient_kw_y, **kwargs)\n\n        self.ax_marg_x.yaxis.get_label().set_visible(False)\n        self.ax_marg_y.xaxis.get_label().set_visible(False)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "plot_marginals", "self", "func", "kwargs", "draw", "univariate", "plots", "on", "each", "marginal", "axes", "parameters", "func", "plotting", "callable", "if", "a", "seaborn", "function", "it", "should", "accept", "x", "and", "y", "and", "plot", "when", "only", "one", "of", "them", "is", "defined", "otherwise", "it", "must", "accept", "a", "vector", "of", "data", "as", "the", "first", "positional", "argument", "and", "determine", "its", "orientation", "using", "the", "vertical", "parameter", "and", "it", "must", "plot", "on", "the", "current", "axes", "if", "hue", "was", "defined", "in", "the", "class", "constructor", "it", "must", "accept", "hue", "as", "a", "parameter", "kwargs", "keyword", "argument", "are", "passed", "to", "the", "plotting", "function", "returns", "class", "jointgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "seaborn_func", "str", "func", "__module__", "startswith", "seaborn", "deprecated", "distplot", "has", "a", "legacy", "api", "special", "case", "it", "and", "not", "func", "__name__", "distplot", "func_params", "signature", "func", "parameters", "kwargs", "kwargs", "copy", "if", "self", "hue", "is", "not", "none", "kwargs", "hue", "self", "hue", "self", "_inject_kwargs", "func", "kwargs", "self", "_hue_params", "if", "legend", "in", "func_params", "kwargs", "setdefault", "legend", "false", "if", "orientation", "in", "func_params", "e", "g", "plt", "hist", "orient_kw_x", "orientation", "vertical", "orient_kw_y", "orientation", "horizontal", "elif", "vertical", "in", "func_params", "e", "g", "sns", "distplot", "also", "how", "did", "this", "get", "backwards", "orient_kw_x", "vertical", "false", "orient_kw_y", "vertical", "true", "if", "seaborn_func", "func", "x", "self", "x", "ax", "self", "ax_marg_x", "kwargs", "else", "plt", "sca", "self", "ax_marg_x", "func", "self", "x", "orient_kw_x", "kwargs", "if", "seaborn_func", "func", "y", "self", "y", "ax", "self", "ax_marg_y", "kwargs", "else", "plt", "sca", "self", "ax_marg_y", "func", "self", "y", "orient_kw_y", "kwargs", "self", "ax_marg_x", "yaxis", "get_label", "set_visible", "false", "self", "ax_marg_y", "xaxis", "get_label", "set_visible", "false", "return", "self"], "doc_len": 241}
{"doc_id": "seaborn/axisgrid.py::JointGrid.refline", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "refline", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def refline(\n        self, *, x=None, y=None, joint=True, marginal=True,\n        color='.5', linestyle='--', **line_kws\n    ):\n        \"\"\"Add a reference line(s) to joint and/or marginal axes.\n\n        Parameters\n        ----------\n        x, y : numeric\n            Value(s) to draw the line(s) at.\n        joint, marginal : bools\n            Whether to add the reference line(s) to the joint/marginal axes.\n        color : :mod:`matplotlib color <matplotlib.colors>`\n            Specifies the color of the reference line(s).\n        linestyle : str\n            Specifies the style of the reference line(s).\n        line_kws : key, value mappings\n            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n            is not None.\n\n        Returns\n        -------\n        :class:`JointGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        line_kws['color'] = color\n        line_kws['linestyle'] = linestyle\n\n        if x is not None:\n            if joint:\n                self.ax_joint.axvline(x, **line_kws)\n            if marginal:\n                self.ax_marg_x.axvline(x, **line_kws)\n\n        if y is not None:\n            if joint:\n                self.ax_joint.axhline(y, **line_kws)\n            if marginal:\n                self.ax_marg_y.axhline(y, **line_kws)\n\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "refline", "self", "x", "none", "y", "none", "joint", "true", "marginal", "true", "color", "5", "linestyle", "line_kws", "add", "a", "reference", "line", "s", "to", "joint", "and", "or", "marginal", "axes", "parameters", "x", "y", "numeric", "value", "s", "to", "draw", "the", "line", "s", "at", "joint", "marginal", "bools", "whether", "to", "add", "the", "reference", "line", "s", "to", "the", "joint", "marginal", "axes", "color", "mod", "matplotlib", "color", "matplotlib", "colors", "specifies", "the", "color", "of", "the", "reference", "line", "s", "linestyle", "str", "specifies", "the", "style", "of", "the", "reference", "line", "s", "line_kws", "key", "value", "mappings", "other", "keyword", "arguments", "are", "passed", "to", "meth", "matplotlib", "axes", "axes", "axvline", "when", "x", "is", "not", "none", "and", "meth", "matplotlib", "axes", "axes", "axhline", "when", "y", "is", "not", "none", "returns", "class", "jointgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "line_kws", "color", "color", "line_kws", "linestyle", "linestyle", "if", "x", "is", "not", "none", "if", "joint", "self", "ax_joint", "axvline", "x", "line_kws", "if", "marginal", "self", "ax_marg_x", "axvline", "x", "line_kws", "if", "y", "is", "not", "none", "if", "joint", "self", "ax_joint", "axhline", "y", "line_kws", "if", "marginal", "self", "ax_marg_y", "axhline", "y", "line_kws", "return", "self"], "doc_len": 168}
{"doc_id": "seaborn/axisgrid.py::JointGrid.set_axis_labels", "file_path": "seaborn/axisgrid.py", "class_name": "JointGrid", "func_name": "set_axis_labels", "text": "文件路径: seaborn/axisgrid.py, 类名: JointGrid\n    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):\n        \"\"\"Set axis labels on the bivariate axes.\n\n        Parameters\n        ----------\n        xlabel, ylabel : strings\n            Label names for the x and y variables.\n        kwargs : key, value mappings\n            Other keyword arguments are passed to the following functions:\n\n            - :meth:`matplotlib.axes.Axes.set_xlabel`\n            - :meth:`matplotlib.axes.Axes.set_ylabel`\n\n        Returns\n        -------\n        :class:`JointGrid` instance\n            Returns ``self`` for easy method chaining.\n\n        \"\"\"\n        self.ax_joint.set_xlabel(xlabel, **kwargs)\n        self.ax_joint.set_ylabel(ylabel, **kwargs)\n        return self\n", "tokens": ["seaborn", "axisgrid", "py", "jointgrid", "def", "set_axis_labels", "self", "xlabel", "ylabel", "kwargs", "set", "axis", "labels", "on", "the", "bivariate", "axes", "parameters", "xlabel", "ylabel", "strings", "label", "names", "for", "the", "x", "and", "y", "variables", "kwargs", "key", "value", "mappings", "other", "keyword", "arguments", "are", "passed", "to", "the", "following", "functions", "meth", "matplotlib", "axes", "axes", "set_xlabel", "meth", "matplotlib", "axes", "axes", "set_ylabel", "returns", "class", "jointgrid", "instance", "returns", "self", "for", "easy", "method", "chaining", "self", "ax_joint", "set_xlabel", "xlabel", "kwargs", "self", "ax_joint", "set_ylabel", "ylabel", "kwargs", "return", "self"], "doc_len": 74}
{"doc_id": "seaborn/axisgrid.py::pairplot", "file_path": "seaborn/axisgrid.py", "class_name": null, "func_name": "pairplot", "text": "文件路径: seaborn/axisgrid.py\ndef pairplot(\n    data, *,\n    hue=None, hue_order=None, palette=None,\n    vars=None, x_vars=None, y_vars=None,\n    kind=\"scatter\", diag_kind=\"auto\", markers=None,\n    height=2.5, aspect=1, corner=False, dropna=False,\n    plot_kws=None, diag_kws=None, grid_kws=None, size=None,\n):\n    \"\"\"Plot pairwise relationships in a dataset.\n\n    By default, this function will create a grid of Axes such that each numeric\n    variable in ``data`` will by shared across the y-axes across a single row and\n    the x-axes across a single column. The diagonal plots are treated\n    differently: a univariate distribution plot is drawn to show the marginal\n    distribution of the data in each column.\n\n    It is also possible to show a subset of variables or plot different\n    variables on the rows and columns.\n\n    This is a high-level interface for :class:`PairGrid` that is intended to\n    make it easy to draw a few common styles. You should use :class:`PairGrid`\n    directly if you need more flexibility.\n\n    Parameters\n    ----------\n    data : `pandas.DataFrame`\n        Tidy (long-form) dataframe where each column is a variable and\n        each row is an observation.\n    hue : name of variable in ``data``\n        Variable in ``data`` to map plot aspects to different colors.\n    hue_order : list of strings\n        Order for the levels of the hue variable in the palette\n    palette : dict or seaborn color palette\n        Set of colors for mapping the ``hue`` variable. If a dict, keys\n        should be values  in the ``hue`` variable.\n    vars : list of variable names\n        Variables within ``data`` to use, otherwise use every column with\n        a numeric datatype.\n    {x, y}_vars : lists of variable names\n        Variables within ``data`` to use separately for the rows and\n        columns of the figure; i.e. to make a non-square plot.\n    kind : {'scatter', 'kde', 'hist', 'reg'}\n        Kind of plot to make.\n    diag_kind : {'auto', 'hist', 'kde', None}\n        Kind of plot for the diagonal subplots. If 'auto', choose based on\n        whether or not ``hue`` is used.\n    markers : single matplotlib marker code or list\n        Either the marker to use for all scatterplot points or a list of markers\n        with a length the same as the number of levels in the hue variable so that\n        differently colored points will also have different scatterplot\n        markers.\n    height : scalar\n        Height (in inches) of each facet.\n    aspect : scalar\n        Aspect * height gives the width (in inches) of each facet.\n    corner : bool\n        If True, don't add axes to the upper (off-diagonal) triangle of the\n        grid, making this a \"corner\" plot.\n    dropna : boolean\n        Drop missing values from the data before plotting.\n    {plot, diag, grid}_kws : dicts\n        Dictionaries of keyword arguments. ``plot_kws`` are passed to the\n        bivariate plotting function, ``diag_kws`` are passed to the univariate\n        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`\n        constructor.\n\n    Returns\n    -------\n    grid : :class:`PairGrid`\n        Returns the underlying :class:`PairGrid` instance for further tweaking.\n\n    See Also\n    --------\n    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.\n    JointGrid : Grid for plotting joint and marginal distributions of two variables.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/pairplot.rst\n\n    \"\"\"\n    # Avoid circular import\n    from .distributions import histplot, kdeplot\n\n    # Handle deprecations\n    if size is not None:\n        height = size\n        msg = (\"The `size` parameter has been renamed to `height`; \"\n               \"please update your code.\")\n        warnings.warn(msg, UserWarning)\n\n    if not isinstance(data, pd.DataFrame):\n        raise TypeError(\n            f\"'data' must be pandas DataFrame object, not: {type(data)}\")\n\n    plot_kws = {} if plot_kws is None else plot_kws.copy()\n    diag_kws = {} if diag_kws is None else diag_kws.copy()\n    grid_kws = {} if grid_kws is None else grid_kws.copy()\n\n    # Resolve \"auto\" diag kind\n    if diag_kind == \"auto\":\n        if hue is None:\n            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n        else:\n            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n\n    # Set up the PairGrid\n    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n                    hue_order=hue_order, palette=palette, corner=corner,\n                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n\n    # Add the markers here as PairGrid has figured out how many levels of the\n    # hue variable are needed and we don't want to duplicate that process\n    if markers is not None:\n        if kind == \"reg\":\n            # Needed until regplot supports style\n            if grid.hue_names is None:\n                n_markers = 1\n            else:\n                n_markers = len(grid.hue_names)\n            if not isinstance(markers, list):\n                markers = [markers] * n_markers\n            if len(markers) != n_markers:\n                raise ValueError(\"markers must be a singleton or a list of \"\n                                 \"markers for each level of the hue variable\")\n            grid.hue_kws = {\"marker\": markers}\n        elif kind == \"scatter\":\n            if isinstance(markers, str):\n                plot_kws[\"marker\"] = markers\n            elif hue is not None:\n                plot_kws[\"style\"] = data[hue]\n                plot_kws[\"markers\"] = markers\n\n    # Draw the marginal plots on the diagonal\n    diag_kws = diag_kws.copy()\n    diag_kws.setdefault(\"legend\", False)\n    if diag_kind == \"hist\":\n        grid.map_diag(histplot, **diag_kws)\n    elif diag_kind == \"kde\":\n        diag_kws.setdefault(\"fill\", True)\n        diag_kws.setdefault(\"warn_singular\", False)\n        grid.map_diag(kdeplot, **diag_kws)\n\n    # Maybe plot on the off-diagonals\n    if diag_kind is not None:\n        plotter = grid.map_offdiag\n    else:\n        plotter = grid.map\n\n    if kind == \"scatter\":\n        from .relational import scatterplot  # Avoid circular import\n        plotter(scatterplot, **plot_kws)\n    elif kind == \"reg\":\n        from .regression import regplot  # Avoid circular import\n        plotter(regplot, **plot_kws)\n    elif kind == \"kde\":\n        from .distributions import kdeplot  # Avoid circular import\n        plot_kws.setdefault(\"warn_singular\", False)\n        plotter(kdeplot, **plot_kws)\n    elif kind == \"hist\":\n        from .distributions import histplot  # Avoid circular import\n        plotter(histplot, **plot_kws)\n\n    # Add a legend\n    if hue is not None:\n        grid.add_legend()\n\n    grid.tight_layout()\n\n    return grid\n", "tokens": ["seaborn", "axisgrid", "py", "def", "pairplot", "data", "hue", "none", "hue_order", "none", "palette", "none", "vars", "none", "x_vars", "none", "y_vars", "none", "kind", "scatter", "diag_kind", "auto", "markers", "none", "height", "2", "5", "aspect", "1", "corner", "false", "dropna", "false", "plot_kws", "none", "diag_kws", "none", "grid_kws", "none", "size", "none", "plot", "pairwise", "relationships", "in", "a", "dataset", "by", "default", "this", "function", "will", "create", "a", "grid", "of", "axes", "such", "that", "each", "numeric", "variable", "in", "data", "will", "by", "shared", "across", "the", "y", "axes", "across", "a", "single", "row", "and", "the", "x", "axes", "across", "a", "single", "column", "the", "diagonal", "plots", "are", "treated", "differently", "a", "univariate", "distribution", "plot", "is", "drawn", "to", "show", "the", "marginal", "distribution", "of", "the", "data", "in", "each", "column", "it", "is", "also", "possible", "to", "show", "a", "subset", "of", "variables", "or", "plot", "different", "variables", "on", "the", "rows", "and", "columns", "this", "is", "a", "high", "level", "interface", "for", "class", "pairgrid", "that", "is", "intended", "to", "make", "it", "easy", "to", "draw", "a", "few", "common", "styles", "you", "should", "use", "class", "pairgrid", "directly", "if", "you", "need", "more", "flexibility", "parameters", "data", "pandas", "dataframe", "tidy", "long", "form", "dataframe", "where", "each", "column", "is", "a", "variable", "and", "each", "row", "is", "an", "observation", "hue", "name", "of", "variable", "in", "data", "variable", "in", "data", "to", "map", "plot", "aspects", "to", "different", "colors", "hue_order", "list", "of", "strings", "order", "for", "the", "levels", "of", "the", "hue", "variable", "in", "the", "palette", "palette", "dict", "or", "seaborn", "color", "palette", "set", "of", "colors", "for", "mapping", "the", "hue", "variable", "if", "a", "dict", "keys", "should", "be", "values", "in", "the", "hue", "variable", "vars", "list", "of", "variable", "names", "variables", "within", "data", "to", "use", "otherwise", "use", "every", "column", "with", "a", "numeric", "datatype", "x", "y", "_vars", "lists", "of", "variable", "names", "variables", "within", "data", "to", "use", "separately", "for", "the", "rows", "and", "columns", "of", "the", "figure", "i", "e", "to", "make", "a", "non", "square", "plot", "kind", "scatter", "kde", "hist", "reg", "kind", "of", "plot", "to", "make", "diag_kind", "auto", "hist", "kde", "none", "kind", "of", "plot", "for", "the", "diagonal", "subplots", "if", "auto", "choose", "based", "on", "whether", "or", "not", "hue", "is", "used", "markers", "single", "matplotlib", "marker", "code", "or", "list", "either", "the", "marker", "to", "use", "for", "all", "scatterplot", "points", "or", "a", "list", "of", "markers", "with", "a", "length", "the", "same", "as", "the", "number", "of", "levels", "in", "the", "hue", "variable", "so", "that", "differently", "colored", "points", "will", "also", "have", "different", "scatterplot", "markers", "height", "scalar", "height", "in", "inches", "of", "each", "facet", "aspect", "scalar", "aspect", "height", "gives", "the", "width", "in", "inches", "of", "each", "facet", "corner", "bool", "if", "true", "don", "t", "add", "axes", "to", "the", "upper", "off", "diagonal", "triangle", "of", "the", "grid", "making", "this", "a", "corner", "plot", "dropna", "boolean", "drop", "missing", "values", "from", "the", "data", "before", "plotting", "plot", "diag", "grid", "_kws", "dicts", "dictionaries", "of", "keyword", "arguments", "plot_kws", "are", "passed", "to", "the", "bivariate", "plotting", "function", "diag_kws", "are", "passed", "to", "the", "univariate", "plotting", "function", "and", "grid_kws", "are", "passed", "to", "the", "class", "pairgrid", "constructor", "returns", "grid", "class", "pairgrid", "returns", "the", "underlying", "class", "pairgrid", "instance", "for", "further", "tweaking", "see", "also", "pairgrid", "subplot", "grid", "for", "more", "flexible", "plotting", "of", "pairwise", "relationships", "jointgrid", "grid", "for", "plotting", "joint", "and", "marginal", "distributions", "of", "two", "variables", "examples", "include", "docstrings", "pairplot", "rst", "avoid", "circular", "import", "from", "distributions", "import", "histplot", "kdeplot", "handle", "deprecations", "if", "size", "is", "not", "none", "height", "size", "msg", "the", "size", "parameter", "has", "been", "renamed", "to", "height", "please", "update", "your", "code", "warnings", "warn", "msg", "userwarning", "if", "not", "isinstance", "data", "pd", "dataframe", "raise", "typeerror", "f", "data", "must", "be", "pandas", "dataframe", "object", "not", "type", "data", "plot_kws", "if", "plot_kws", "is", "none", "else", "plot_kws", "copy", "diag_kws", "if", "diag_kws", "is", "none", "else", "diag_kws", "copy", "grid_kws", "if", "grid_kws", "is", "none", "else", "grid_kws", "copy", "resolve", "auto", "diag", "kind", "if", "diag_kind", "auto", "if", "hue", "is", "none", "diag_kind", "kde", "if", "kind", "kde", "else", "hist", "else", "diag_kind", "hist", "if", "kind", "hist", "else", "kde", "set", "up", "the", "pairgrid", "grid_kws", "setdefault", "diag_sharey", "diag_kind", "hist", "grid", "pairgrid", "data", "vars", "vars", "x_vars", "x_vars", "y_vars", "y_vars", "hue", "hue", "hue_order", "hue_order", "palette", "palette", "corner", "corner", "height", "height", "aspect", "aspect", "dropna", "dropna", "grid_kws", "add", "the", "markers", "here", "as", "pairgrid", "has", "figured", "out", "how", "many", "levels", "of", "the", "hue", "variable", "are", "needed", "and", "we", "don", "t", "want", "to", "duplicate", "that", "process", "if", "markers", "is", "not", "none", "if", "kind", "reg", "needed", "until", "regplot", "supports", "style", "if", "grid", "hue_names", "is", "none", "n_markers", "1", "else", "n_markers", "len", "grid", "hue_names", "if", "not", "isinstance", "markers", "list", "markers", "markers", "n_markers", "if", "len", "markers", "n_markers", "raise", "valueerror", "markers", "must", "be", "a", "singleton", "or", "a", "list", "of", "markers", "for", "each", "level", "of", "the", "hue", "variable", "grid", "hue_kws", "marker", "markers", "elif", "kind", "scatter", "if", "isinstance", "markers", "str", "plot_kws", "marker", "markers", "elif", "hue", "is", "not", "none", "plot_kws", "style", "data", "hue", "plot_kws", "markers", "markers", "draw", "the", "marginal", "plots", "on", "the", "diagonal", "diag_kws", "diag_kws", "copy", "diag_kws", "setdefault", "legend", "false", "if", "diag_kind", "hist", "grid", "map_diag", "histplot", "diag_kws", "elif", "diag_kind", "kde", "diag_kws", "setdefault", "fill", "true", "diag_kws", "setdefault", "warn_singular", "false", "grid", "map_diag", "kdeplot", "diag_kws", "maybe", "plot", "on", "the", "off", "diagonals", "if", "diag_kind", "is", "not", "none", "plotter", "grid", "map_offdiag", "else", "plotter", "grid", "map", "if", "kind", "scatter", "from", "relational", "import", "scatterplot", "avoid", "circular", "import", "plotter", "scatterplot", "plot_kws", "elif", "kind", "reg", "from", "regression", "import", "regplot", "avoid", "circular", "import", "plotter", "regplot", "plot_kws", "elif", "kind", "kde", "from", "distributions", "import", "kdeplot", "avoid", "circular", "import", "plot_kws", "setdefault", "warn_singular", "false", "plotter", "kdeplot", "plot_kws", "elif", "kind", "hist", "from", "distributions", "import", "histplot", "avoid", "circular", "import", "plotter", "histplot", "plot_kws", "add", "a", "legend", "if", "hue", "is", "not", "none", "grid", "add_legend", "grid", "tight_layout", "return", "grid"], "doc_len": 855}
{"doc_id": "seaborn/axisgrid.py::jointplot", "file_path": "seaborn/axisgrid.py", "class_name": null, "func_name": "jointplot", "text": "文件路径: seaborn/axisgrid.py\ndef jointplot(\n    data=None, *, x=None, y=None, hue=None, kind=\"scatter\",\n    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,\n    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,\n    joint_kws=None, marginal_kws=None,\n    **kwargs\n):\n    # Avoid circular imports\n    from .relational import scatterplot\n    from .regression import regplot, residplot\n    from .distributions import histplot, kdeplot, _freedman_diaconis_bins\n\n    if kwargs.pop(\"ax\", None) is not None:\n        msg = \"Ignoring `ax`; jointplot is a figure-level function.\"\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    # Set up empty default kwarg dicts\n    joint_kws = {} if joint_kws is None else joint_kws.copy()\n    joint_kws.update(kwargs)\n    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()\n\n    # Handle deprecations of distplot-specific kwargs\n    distplot_keys = [\n        \"rug\", \"fit\", \"hist_kws\", \"norm_hist\" \"hist_kws\", \"rug_kws\",\n    ]\n    unused_keys = []\n    for key in distplot_keys:\n        if key in marginal_kws:\n            unused_keys.append(key)\n            marginal_kws.pop(key)\n    if unused_keys and kind != \"kde\":\n        msg = (\n            \"The marginal plotting function has changed to `histplot`,\"\n            \" which does not accept the following argument(s): {}.\"\n        ).format(\", \".join(unused_keys))\n        warnings.warn(msg, UserWarning)\n\n    # Validate the plot kind\n    plot_kinds = [\"scatter\", \"hist\", \"hex\", \"kde\", \"reg\", \"resid\"]\n    _check_argument(\"kind\", plot_kinds, kind)\n\n    # Raise early if using `hue` with a kind that does not support it\n    if hue is not None and kind in [\"hex\", \"reg\", \"resid\"]:\n        msg = (\n            f\"Use of `hue` with `kind='{kind}'` is not currently supported.\"\n        )\n        raise ValueError(msg)\n\n    # Make a colormap based off the plot color\n    # (Currently used only for kind=\"hex\")\n    if color is None:\n        color = \"C0\"\n    color_rgb = mpl.colors.colorConverter.to_rgb(color)\n    colors = [utils.set_hls_values(color_rgb, l=l)  # noqa\n              for l in np.linspace(1, 0, 12)]\n    cmap = blend_palette(colors, as_cmap=True)\n\n    # Matplotlib's hexbin plot is not na-robust\n    if kind == \"hex\":\n        dropna = True\n\n    # Initialize the JointGrid object\n    grid = JointGrid(\n        data=data, x=x, y=y, hue=hue,\n        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n        dropna=dropna, height=height, ratio=ratio, space=space,\n        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,\n    )\n\n    if grid.hue is not None:\n        marginal_kws.setdefault(\"legend\", False)\n\n    # Plot the data using the grid\n    if kind.startswith(\"scatter\"):\n\n        joint_kws.setdefault(\"color\", color)\n        grid.plot_joint(scatterplot, **joint_kws)\n\n        if grid.hue is None:\n            marg_func = histplot\n        else:\n            marg_func = kdeplot\n            marginal_kws.setdefault(\"warn_singular\", False)\n            marginal_kws.setdefault(\"fill\", True)\n\n        marginal_kws.setdefault(\"color\", color)\n        grid.plot_marginals(marg_func, **marginal_kws)\n\n    elif kind.startswith(\"hist\"):\n\n        # TODO process pair parameters for bins, etc. and pass\n        # to both joint and marginal plots\n\n        joint_kws.setdefault(\"color\", color)\n        grid.plot_joint(histplot, **joint_kws)\n\n        marginal_kws.setdefault(\"kde\", False)\n        marginal_kws.setdefault(\"color\", color)\n\n        marg_x_kws = marginal_kws.copy()\n        marg_y_kws = marginal_kws.copy()\n\n        pair_keys = \"bins\", \"binwidth\", \"binrange\"\n        for key in pair_keys:\n            if isinstance(joint_kws.get(key), tuple):\n                x_val, y_val = joint_kws[key]\n                marg_x_kws.setdefault(key, x_val)\n                marg_y_kws.setdefault(key, y_val)\n\n        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)\n        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)\n\n    elif kind.startswith(\"kde\"):\n\n        joint_kws.setdefault(\"color\", color)\n        joint_kws.setdefault(\"warn_singular\", False)\n        grid.plot_joint(kdeplot, **joint_kws)\n\n        marginal_kws.setdefault(\"color\", color)\n        if \"fill\" in joint_kws:\n            marginal_kws.setdefault(\"fill\", joint_kws[\"fill\"])\n\n        grid.plot_marginals(kdeplot, **marginal_kws)\n\n    elif kind.startswith(\"hex\"):\n\n        x_bins = min(_freedman_diaconis_bins(grid.x), 50)\n        y_bins = min(_freedman_diaconis_bins(grid.y), 50)\n        gridsize = int(np.mean([x_bins, y_bins]))\n\n        joint_kws.setdefault(\"gridsize\", gridsize)\n        joint_kws.setdefault(\"cmap\", cmap)\n        grid.plot_joint(plt.hexbin, **joint_kws)\n\n        marginal_kws.setdefault(\"kde\", False)\n        marginal_kws.setdefault(\"color\", color)\n        grid.plot_marginals(histplot, **marginal_kws)\n\n    elif kind.startswith(\"reg\"):\n\n        marginal_kws.setdefault(\"color\", color)\n        marginal_kws.setdefault(\"kde\", True)\n        grid.plot_marginals(histplot, **marginal_kws)\n\n        joint_kws.setdefault(\"color\", color)\n        grid.plot_joint(regplot, **joint_kws)\n\n    elif kind.startswith(\"resid\"):\n\n        joint_kws.setdefault(\"color\", color)\n        grid.plot_joint(residplot, **joint_kws)\n\n        x, y = grid.ax_joint.collections[0].get_offsets().T\n        marginal_kws.setdefault(\"color\", color)\n        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)\n        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)\n\n    # Make the main axes active in the matplotlib state machine\n    plt.sca(grid.ax_joint)\n\n    return grid\n", "tokens": ["seaborn", "axisgrid", "py", "def", "jointplot", "data", "none", "x", "none", "y", "none", "hue", "none", "kind", "scatter", "height", "6", "ratio", "5", "space", "2", "dropna", "false", "xlim", "none", "ylim", "none", "color", "none", "palette", "none", "hue_order", "none", "hue_norm", "none", "marginal_ticks", "false", "joint_kws", "none", "marginal_kws", "none", "kwargs", "avoid", "circular", "imports", "from", "relational", "import", "scatterplot", "from", "regression", "import", "regplot", "residplot", "from", "distributions", "import", "histplot", "kdeplot", "_freedman_diaconis_bins", "if", "kwargs", "pop", "ax", "none", "is", "not", "none", "msg", "ignoring", "ax", "jointplot", "is", "a", "figure", "level", "function", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "set", "up", "empty", "default", "kwarg", "dicts", "joint_kws", "if", "joint_kws", "is", "none", "else", "joint_kws", "copy", "joint_kws", "update", "kwargs", "marginal_kws", "if", "marginal_kws", "is", "none", "else", "marginal_kws", "copy", "handle", "deprecations", "of", "distplot", "specific", "kwargs", "distplot_keys", "rug", "fit", "hist_kws", "norm_hist", "hist_kws", "rug_kws", "unused_keys", "for", "key", "in", "distplot_keys", "if", "key", "in", "marginal_kws", "unused_keys", "append", "key", "marginal_kws", "pop", "key", "if", "unused_keys", "and", "kind", "kde", "msg", "the", "marginal", "plotting", "function", "has", "changed", "to", "histplot", "which", "does", "not", "accept", "the", "following", "argument", "s", "format", "join", "unused_keys", "warnings", "warn", "msg", "userwarning", "validate", "the", "plot", "kind", "plot_kinds", "scatter", "hist", "hex", "kde", "reg", "resid", "_check_argument", "kind", "plot_kinds", "kind", "raise", "early", "if", "using", "hue", "with", "a", "kind", "that", "does", "not", "support", "it", "if", "hue", "is", "not", "none", "and", "kind", "in", "hex", "reg", "resid", "msg", "f", "use", "of", "hue", "with", "kind", "kind", "is", "not", "currently", "supported", "raise", "valueerror", "msg", "make", "a", "colormap", "based", "off", "the", "plot", "color", "currently", "used", "only", "for", "kind", "hex", "if", "color", "is", "none", "color", "c0", "color_rgb", "mpl", "colors", "colorconverter", "to_rgb", "color", "colors", "utils", "set_hls_values", "color_rgb", "l", "l", "noqa", "for", "l", "in", "np", "linspace", "1", "0", "12", "cmap", "blend_palette", "colors", "as_cmap", "true", "matplotlib", "s", "hexbin", "plot", "is", "not", "na", "robust", "if", "kind", "hex", "dropna", "true", "initialize", "the", "jointgrid", "object", "grid", "jointgrid", "data", "data", "x", "x", "y", "y", "hue", "hue", "palette", "palette", "hue_order", "hue_order", "hue_norm", "hue_norm", "dropna", "dropna", "height", "height", "ratio", "ratio", "space", "space", "xlim", "xlim", "ylim", "ylim", "marginal_ticks", "marginal_ticks", "if", "grid", "hue", "is", "not", "none", "marginal_kws", "setdefault", "legend", "false", "plot", "the", "data", "using", "the", "grid", "if", "kind", "startswith", "scatter", "joint_kws", "setdefault", "color", "color", "grid", "plot_joint", "scatterplot", "joint_kws", "if", "grid", "hue", "is", "none", "marg_func", "histplot", "else", "marg_func", "kdeplot", "marginal_kws", "setdefault", "warn_singular", "false", "marginal_kws", "setdefault", "fill", "true", "marginal_kws", "setdefault", "color", "color", "grid", "plot_marginals", "marg_func", "marginal_kws", "elif", "kind", "startswith", "hist", "todo", "process", "pair", "parameters", "for", "bins", "etc", "and", "pass", "to", "both", "joint", "and", "marginal", "plots", "joint_kws", "setdefault", "color", "color", "grid", "plot_joint", "histplot", "joint_kws", "marginal_kws", "setdefault", "kde", "false", "marginal_kws", "setdefault", "color", "color", "marg_x_kws", "marginal_kws", "copy", "marg_y_kws", "marginal_kws", "copy", "pair_keys", "bins", "binwidth", "binrange", "for", "key", "in", "pair_keys", "if", "isinstance", "joint_kws", "get", "key", "tuple", "x_val", "y_val", "joint_kws", "key", "marg_x_kws", "setdefault", "key", "x_val", "marg_y_kws", "setdefault", "key", "y_val", "histplot", "data", "data", "x", "x", "hue", "hue", "marg_x_kws", "ax", "grid", "ax_marg_x", "histplot", "data", "data", "y", "y", "hue", "hue", "marg_y_kws", "ax", "grid", "ax_marg_y", "elif", "kind", "startswith", "kde", "joint_kws", "setdefault", "color", "color", "joint_kws", "setdefault", "warn_singular", "false", "grid", "plot_joint", "kdeplot", "joint_kws", "marginal_kws", "setdefault", "color", "color", "if", "fill", "in", "joint_kws", "marginal_kws", "setdefault", "fill", "joint_kws", "fill", "grid", "plot_marginals", "kdeplot", "marginal_kws", "elif", "kind", "startswith", "hex", "x_bins", "min", "_freedman_diaconis_bins", "grid", "x", "50", "y_bins", "min", "_freedman_diaconis_bins", "grid", "y", "50", "gridsize", "int", "np", "mean", "x_bins", "y_bins", "joint_kws", "setdefault", "gridsize", "gridsize", "joint_kws", "setdefault", "cmap", "cmap", "grid", "plot_joint", "plt", "hexbin", "joint_kws", "marginal_kws", "setdefault", "kde", "false", "marginal_kws", "setdefault", "color", "color", "grid", "plot_marginals", "histplot", "marginal_kws", "elif", "kind", "startswith", "reg", "marginal_kws", "setdefault", "color", "color", "marginal_kws", "setdefault", "kde", "true", "grid", "plot_marginals", "histplot", "marginal_kws", "joint_kws", "setdefault", "color", "color", "grid", "plot_joint", "regplot", "joint_kws", "elif", "kind", "startswith", "resid", "joint_kws", "setdefault", "color", "color", "grid", "plot_joint", "residplot", "joint_kws", "x", "y", "grid", "ax_joint", "collections", "0", "get_offsets", "t", "marginal_kws", "setdefault", "color", "color", "histplot", "x", "x", "hue", "hue", "ax", "grid", "ax_marg_x", "marginal_kws", "histplot", "y", "y", "hue", "hue", "ax", "grid", "ax_marg_y", "marginal_kws", "make", "the", "main", "axes", "active", "in", "the", "matplotlib", "state", "machine", "plt", "sca", "grid", "ax_joint", "return", "grid"], "doc_len": 617}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew.__init__", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def __init__(\n        self,\n        data=None,\n        variables={},\n        order=None,\n        orient=None,\n        require_numeric=False,\n        legend=\"auto\",\n    ):\n\n        super().__init__(data=data, variables=variables)\n\n        # This method takes care of some bookkeeping that is necessary because the\n        # original categorical plots (prior to the 2021 refactor) had some rules that\n        # don't fit exactly into the logic of _core. It may be wise to have a second\n        # round of refactoring that moves the logic deeper, but this will keep things\n        # relatively sensible for now.\n\n        # For wide data, orient determines assignment to x/y differently from the\n        # wide_structure rules in _core. If we do decide to make orient part of the\n        # _core variable assignment, we'll want to figure out how to express that.\n        if self.input_format == \"wide\" and orient == \"h\":\n            self.plot_data = self.plot_data.rename(columns={\"x\": \"y\", \"y\": \"x\"})\n            orig_variables = set(self.variables)\n            orig_x = self.variables.pop(\"x\", None)\n            orig_y = self.variables.pop(\"y\", None)\n            orig_x_type = self.var_types.pop(\"x\", None)\n            orig_y_type = self.var_types.pop(\"y\", None)\n            if \"x\" in orig_variables:\n                self.variables[\"y\"] = orig_x\n                self.var_types[\"y\"] = orig_x_type\n            if \"y\" in orig_variables:\n                self.variables[\"x\"] = orig_y\n                self.var_types[\"x\"] = orig_y_type\n\n        # The concept of an \"orientation\" is important to the original categorical\n        # plots, but there's no provision for it in _core, so we need to do it here.\n        # Note that it could be useful for the other functions in at least two ways\n        # (orienting a univariate distribution plot from long-form data and selecting\n        # the aggregation axis in lineplot), so we may want to eventually refactor it.\n        self.orient = infer_orient(\n            x=self.plot_data.get(\"x\", None),\n            y=self.plot_data.get(\"y\", None),\n            orient=orient,\n            require_numeric=require_numeric,\n        )\n\n        self.legend = legend\n\n        # Short-circuit in the case of an empty plot\n        if not self.has_xy_data:\n            return\n\n        # Categorical plots can be \"univariate\" in which case they get an anonymous\n        # category label on the opposite axis. Note: this duplicates code in the core\n        # scale_categorical function. We need to do it here because of the next line.\n        if self.cat_axis not in self.variables:\n            self.variables[self.cat_axis] = None\n            self.var_types[self.cat_axis] = \"categorical\"\n            self.plot_data[self.cat_axis] = \"\"\n\n        # Categorical variables have discrete levels that we need to track\n        cat_levels = categorical_order(self.plot_data[self.cat_axis], order)\n        self.var_levels[self.cat_axis] = cat_levels\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "__init__", "self", "data", "none", "variables", "order", "none", "orient", "none", "require_numeric", "false", "legend", "auto", "super", "__init__", "data", "data", "variables", "variables", "this", "method", "takes", "care", "of", "some", "bookkeeping", "that", "is", "necessary", "because", "the", "original", "categorical", "plots", "prior", "to", "the", "2021", "refactor", "had", "some", "rules", "that", "don", "t", "fit", "exactly", "into", "the", "logic", "of", "_core", "it", "may", "be", "wise", "to", "have", "a", "second", "round", "of", "refactoring", "that", "moves", "the", "logic", "deeper", "but", "this", "will", "keep", "things", "relatively", "sensible", "for", "now", "for", "wide", "data", "orient", "determines", "assignment", "to", "x", "y", "differently", "from", "the", "wide_structure", "rules", "in", "_core", "if", "we", "do", "decide", "to", "make", "orient", "part", "of", "the", "_core", "variable", "assignment", "we", "ll", "want", "to", "figure", "out", "how", "to", "express", "that", "if", "self", "input_format", "wide", "and", "orient", "h", "self", "plot_data", "self", "plot_data", "rename", "columns", "x", "y", "y", "x", "orig_variables", "set", "self", "variables", "orig_x", "self", "variables", "pop", "x", "none", "orig_y", "self", "variables", "pop", "y", "none", "orig_x_type", "self", "var_types", "pop", "x", "none", "orig_y_type", "self", "var_types", "pop", "y", "none", "if", "x", "in", "orig_variables", "self", "variables", "y", "orig_x", "self", "var_types", "y", "orig_x_type", "if", "y", "in", "orig_variables", "self", "variables", "x", "orig_y", "self", "var_types", "x", "orig_y_type", "the", "concept", "of", "an", "orientation", "is", "important", "to", "the", "original", "categorical", "plots", "but", "there", "s", "no", "provision", "for", "it", "in", "_core", "so", "we", "need", "to", "do", "it", "here", "note", "that", "it", "could", "be", "useful", "for", "the", "other", "functions", "in", "at", "least", "two", "ways", "orienting", "a", "univariate", "distribution", "plot", "from", "long", "form", "data", "and", "selecting", "the", "aggregation", "axis", "in", "lineplot", "so", "we", "may", "want", "to", "eventually", "refactor", "it", "self", "orient", "infer_orient", "x", "self", "plot_data", "get", "x", "none", "y", "self", "plot_data", "get", "y", "none", "orient", "orient", "require_numeric", "require_numeric", "self", "legend", "legend", "short", "circuit", "in", "the", "case", "of", "an", "empty", "plot", "if", "not", "self", "has_xy_data", "return", "categorical", "plots", "can", "be", "univariate", "in", "which", "case", "they", "get", "an", "anonymous", "category", "label", "on", "the", "opposite", "axis", "note", "this", "duplicates", "code", "in", "the", "core", "scale_categorical", "function", "we", "need", "to", "do", "it", "here", "because", "of", "the", "next", "line", "if", "self", "cat_axis", "not", "in", "self", "variables", "self", "variables", "self", "cat_axis", "none", "self", "var_types", "self", "cat_axis", "categorical", "self", "plot_data", "self", "cat_axis", "categorical", "variables", "have", "discrete", "levels", "that", "we", "need", "to", "track", "cat_levels", "categorical_order", "self", "plot_data", "self", "cat_axis", "order", "self", "var_levels", "self", "cat_axis", "cat_levels"], "doc_len": 374}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._hue_backcompat", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_hue_backcompat", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _hue_backcompat(self, color, palette, hue_order, force_hue=False):\n        \"\"\"Implement backwards compatibility for hue parametrization.\n\n        Note: the force_hue parameter is used so that functions can be shown to\n        pass existing tests during refactoring and then tested for new behavior.\n        It can be removed after completion of the work.\n\n        \"\"\"\n        # The original categorical functions applied a palette to the categorical axis\n        # by default. We want to require an explicit hue mapping, to be more consistent\n        # with how things work elsewhere now. I don't think there's any good way to\n        # do this gently -- because it's triggered by the default value of hue=None,\n        # users would always get a warning, unless we introduce some sentinel \"default\"\n        # argument for this change. That's possible, but asking users to set `hue=None`\n        # on every call is annoying.\n        # We are keeping the logic for implementing the old behavior in with the current\n        # system so that (a) we can punt on that decision and (b) we can ensure that\n        # refactored code passes old tests.\n        default_behavior = color is None or palette is not None\n        if force_hue and \"hue\" not in self.variables and default_behavior:\n            self._redundant_hue = True\n            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]\n            self.variables[\"hue\"] = self.variables[self.cat_axis]\n            self.var_types[\"hue\"] = \"categorical\"\n            hue_order = self.var_levels[self.cat_axis]\n\n            # Because we convert the categorical axis variable to string,\n            # we need to update a dictionary palette too\n            if isinstance(palette, dict):\n                palette = {str(k): v for k, v in palette.items()}\n\n        else:\n            self._redundant_hue = False\n\n        # Previously, categorical plots had a trick where color= could seed the palette.\n        # Because that's an explicit parameterization, we are going to give it one\n        # release cycle with a warning before removing.\n        if \"hue\" in self.variables and palette is None and color is not None:\n            if not isinstance(color, str):\n                color = mpl.colors.to_hex(color)\n            palette = f\"dark:{color}\"\n            msg = (\n                \"Setting a gradient palette using color= is deprecated and will be \"\n                f\"removed in version 0.13. Set `palette='{palette}'` for same effect.\"\n            )\n            warnings.warn(msg, FutureWarning)\n\n        return palette, hue_order\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_hue_backcompat", "self", "color", "palette", "hue_order", "force_hue", "false", "implement", "backwards", "compatibility", "for", "hue", "parametrization", "note", "the", "force_hue", "parameter", "is", "used", "so", "that", "functions", "can", "be", "shown", "to", "pass", "existing", "tests", "during", "refactoring", "and", "then", "tested", "for", "new", "behavior", "it", "can", "be", "removed", "after", "completion", "of", "the", "work", "the", "original", "categorical", "functions", "applied", "a", "palette", "to", "the", "categorical", "axis", "by", "default", "we", "want", "to", "require", "an", "explicit", "hue", "mapping", "to", "be", "more", "consistent", "with", "how", "things", "work", "elsewhere", "now", "i", "don", "t", "think", "there", "s", "any", "good", "way", "to", "do", "this", "gently", "because", "it", "s", "triggered", "by", "the", "default", "value", "of", "hue", "none", "users", "would", "always", "get", "a", "warning", "unless", "we", "introduce", "some", "sentinel", "default", "argument", "for", "this", "change", "that", "s", "possible", "but", "asking", "users", "to", "set", "hue", "none", "on", "every", "call", "is", "annoying", "we", "are", "keeping", "the", "logic", "for", "implementing", "the", "old", "behavior", "in", "with", "the", "current", "system", "so", "that", "a", "we", "can", "punt", "on", "that", "decision", "and", "b", "we", "can", "ensure", "that", "refactored", "code", "passes", "old", "tests", "default_behavior", "color", "is", "none", "or", "palette", "is", "not", "none", "if", "force_hue", "and", "hue", "not", "in", "self", "variables", "and", "default_behavior", "self", "_redundant_hue", "true", "self", "plot_data", "hue", "self", "plot_data", "self", "cat_axis", "self", "variables", "hue", "self", "variables", "self", "cat_axis", "self", "var_types", "hue", "categorical", "hue_order", "self", "var_levels", "self", "cat_axis", "because", "we", "convert", "the", "categorical", "axis", "variable", "to", "string", "we", "need", "to", "update", "a", "dictionary", "palette", "too", "if", "isinstance", "palette", "dict", "palette", "str", "k", "v", "for", "k", "v", "in", "palette", "items", "else", "self", "_redundant_hue", "false", "previously", "categorical", "plots", "had", "a", "trick", "where", "color", "could", "seed", "the", "palette", "because", "that", "s", "an", "explicit", "parameterization", "we", "are", "going", "to", "give", "it", "one", "release", "cycle", "with", "a", "warning", "before", "removing", "if", "hue", "in", "self", "variables", "and", "palette", "is", "none", "and", "color", "is", "not", "none", "if", "not", "isinstance", "color", "str", "color", "mpl", "colors", "to_hex", "color", "palette", "f", "dark", "color", "msg", "setting", "a", "gradient", "palette", "using", "color", "is", "deprecated", "and", "will", "be", "f", "removed", "in", "version", "0", "13", "set", "palette", "palette", "for", "same", "effect", "warnings", "warn", "msg", "futurewarning", "return", "palette", "hue_order"], "doc_len": 343}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._palette_without_hue_backcompat", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_palette_without_hue_backcompat", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _palette_without_hue_backcompat(self, palette, hue_order):\n        \"\"\"Provide one cycle where palette= implies hue= when not provided\"\"\"\n        if \"hue\" not in self.variables and palette is not None:\n            msg = \"Passing `palette` without assigning `hue` is deprecated.\"\n            warnings.warn(msg, FutureWarning, stacklevel=3)\n            self.legend = False\n            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]\n            self.variables[\"hue\"] = self.variables.get(self.cat_axis)\n            self.var_types[\"hue\"] = self.var_types.get(self.cat_axis)\n            hue_order = self.var_levels.get(self.cat_axis)\n        return hue_order\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_palette_without_hue_backcompat", "self", "palette", "hue_order", "provide", "one", "cycle", "where", "palette", "implies", "hue", "when", "not", "provided", "if", "hue", "not", "in", "self", "variables", "and", "palette", "is", "not", "none", "msg", "passing", "palette", "without", "assigning", "hue", "is", "deprecated", "warnings", "warn", "msg", "futurewarning", "stacklevel", "3", "self", "legend", "false", "self", "plot_data", "hue", "self", "plot_data", "self", "cat_axis", "self", "variables", "hue", "self", "variables", "get", "self", "cat_axis", "self", "var_types", "hue", "self", "var_types", "get", "self", "cat_axis", "hue_order", "self", "var_levels", "get", "self", "cat_axis", "return", "hue_order"], "doc_len": 78}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew.cat_axis", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "cat_axis", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def cat_axis(self):\n        return {\"v\": \"x\", \"h\": \"y\"}[self.orient]\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "cat_axis", "self", "return", "v", "x", "h", "y", "self", "orient"], "doc_len": 14}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._get_gray", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_get_gray", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _get_gray(self, colors):\n        \"\"\"Get a grayscale value that looks good with color.\"\"\"\n        if not len(colors):\n            return None\n        unique_colors = np.unique(colors, axis=0)\n        light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]\n        lum = min(light_vals) * .6\n        return (lum, lum, lum)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_get_gray", "self", "colors", "get", "a", "grayscale", "value", "that", "looks", "good", "with", "color", "if", "not", "len", "colors", "return", "none", "unique_colors", "np", "unique", "colors", "axis", "0", "light_vals", "rgb_to_hls", "rgb", "3", "1", "for", "rgb", "in", "unique_colors", "lum", "min", "light_vals", "6", "return", "lum", "lum", "lum"], "doc_len": 46}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._adjust_cat_axis", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_adjust_cat_axis", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _adjust_cat_axis(self, ax, axis):\n        \"\"\"Set ticks and limits for a categorical variable.\"\"\"\n        # Note: in theory, this could happen in _attach for all categorical axes\n        # But two reasons not to do that:\n        # - If it happens before plotting, autoscaling messes up the plot limits\n        # - It would change existing plots from other seaborn functions\n        if self.var_types[axis] != \"categorical\":\n            return\n\n        # If both x/y data are empty, the correct way to set up the plot is\n        # somewhat undefined; because we don't add null category data to the plot in\n        # this case we don't *have* a categorical axis (yet), so best to just bail.\n        if self.plot_data[axis].empty:\n            return\n\n        # We can infer the total number of categories (including those from previous\n        # plots that are not part of the plot we are currently making) from the number\n        # of ticks, which matplotlib sets up while doing unit conversion. This feels\n        # slightly risky, as if we are relying on something that may be a matplotlib\n        # implementation detail. But I cannot think of a better way to keep track of\n        # the state from previous categorical calls (see GH2516 for context)\n        n = len(getattr(ax, f\"get_{axis}ticks\")())\n\n        if axis == \"x\":\n            ax.xaxis.grid(False)\n            ax.set_xlim(-.5, n - .5, auto=None)\n        else:\n            ax.yaxis.grid(False)\n            # Note limits that correspond to previously-inverted y axis\n            ax.set_ylim(n - .5, -.5, auto=None)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_adjust_cat_axis", "self", "ax", "axis", "set", "ticks", "and", "limits", "for", "a", "categorical", "variable", "note", "in", "theory", "this", "could", "happen", "in", "_attach", "for", "all", "categorical", "axes", "but", "two", "reasons", "not", "to", "do", "that", "if", "it", "happens", "before", "plotting", "autoscaling", "messes", "up", "the", "plot", "limits", "it", "would", "change", "existing", "plots", "from", "other", "seaborn", "functions", "if", "self", "var_types", "axis", "categorical", "return", "if", "both", "x", "y", "data", "are", "empty", "the", "correct", "way", "to", "set", "up", "the", "plot", "is", "somewhat", "undefined", "because", "we", "don", "t", "add", "null", "category", "data", "to", "the", "plot", "in", "this", "case", "we", "don", "t", "have", "a", "categorical", "axis", "yet", "so", "best", "to", "just", "bail", "if", "self", "plot_data", "axis", "empty", "return", "we", "can", "infer", "the", "total", "number", "of", "categories", "including", "those", "from", "previous", "plots", "that", "are", "not", "part", "of", "the", "plot", "we", "are", "currently", "making", "from", "the", "number", "of", "ticks", "which", "matplotlib", "sets", "up", "while", "doing", "unit", "conversion", "this", "feels", "slightly", "risky", "as", "if", "we", "are", "relying", "on", "something", "that", "may", "be", "a", "matplotlib", "implementation", "detail", "but", "i", "cannot", "think", "of", "a", "better", "way", "to", "keep", "track", "of", "the", "state", "from", "previous", "categorical", "calls", "see", "gh2516", "for", "context", "n", "len", "getattr", "ax", "f", "get_", "axis", "ticks", "if", "axis", "x", "ax", "xaxis", "grid", "false", "ax", "set_xlim", "5", "n", "5", "auto", "none", "else", "ax", "yaxis", "grid", "false", "note", "limits", "that", "correspond", "to", "previously", "inverted", "y", "axis", "ax", "set_ylim", "n", "5", "5", "auto", "none"], "doc_len": 233}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._native_width", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_native_width", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _native_width(self):\n        \"\"\"Return unit of width separating categories on native numeric scale.\"\"\"\n        unique_values = np.unique(self.comp_data[self.cat_axis])\n        if len(unique_values) > 1:\n            native_width = np.nanmin(np.diff(unique_values))\n        else:\n            native_width = 1\n        return native_width\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_native_width", "self", "return", "unit", "of", "width", "separating", "categories", "on", "native", "numeric", "scale", "unique_values", "np", "unique", "self", "comp_data", "self", "cat_axis", "if", "len", "unique_values", "1", "native_width", "np", "nanmin", "np", "diff", "unique_values", "else", "native_width", "1", "return", "native_width"], "doc_len": 39}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew._nested_offsets", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "_nested_offsets", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def _nested_offsets(self, width, dodge):\n        \"\"\"Return offsets for each hue level for dodged plots.\"\"\"\n        offsets = None\n        if \"hue\" in self.variables:\n            n_levels = len(self._hue_map.levels)\n            if dodge:\n                each_width = width / n_levels\n                offsets = np.linspace(0, width - each_width, n_levels)\n                offsets -= offsets.mean()\n            else:\n                offsets = np.zeros(n_levels)\n        return offsets\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "_nested_offsets", "self", "width", "dodge", "return", "offsets", "for", "each", "hue", "level", "for", "dodged", "plots", "offsets", "none", "if", "hue", "in", "self", "variables", "n_levels", "len", "self", "_hue_map", "levels", "if", "dodge", "each_width", "width", "n_levels", "offsets", "np", "linspace", "0", "width", "each_width", "n_levels", "offsets", "offsets", "mean", "else", "offsets", "np", "zeros", "n_levels", "return", "offsets"], "doc_len": 52}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew.plot_strips", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "plot_strips", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def plot_strips(\n        self,\n        jitter,\n        dodge,\n        color,\n        edgecolor,\n        plot_kws,\n    ):\n\n        width = .8 * self._native_width\n        offsets = self._nested_offsets(width, dodge)\n\n        if jitter is True:\n            jlim = 0.1\n        else:\n            jlim = float(jitter)\n        if \"hue\" in self.variables and dodge:\n            jlim /= len(self._hue_map.levels)\n        jlim *= self._native_width\n        jitterer = partial(np.random.uniform, low=-jlim, high=+jlim)\n\n        iter_vars = [self.cat_axis]\n        if dodge:\n            iter_vars.append(\"hue\")\n\n        ax = self.ax\n        dodge_move = jitter_move = 0\n\n        for sub_vars, sub_data in self.iter_data(iter_vars,\n                                                 from_comp_data=True,\n                                                 allow_empty=True):\n            if offsets is not None and (offsets != 0).any():\n                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]\n\n            jitter_move = jitterer(size=len(sub_data)) if len(sub_data) > 1 else 0\n\n            adjusted_data = sub_data[self.cat_axis] + dodge_move + jitter_move\n            sub_data[self.cat_axis] = adjusted_data\n\n            for var in \"xy\":\n                if self._log_scaled(var):\n                    sub_data[var] = np.power(10, sub_data[var])\n\n            ax = self._get_axes(sub_vars)\n            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)\n\n            if \"hue\" in self.variables:\n                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))\n\n            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"\n                points.set_edgecolors(self._get_gray(points.get_facecolors()))\n            else:\n                points.set_edgecolors(edgecolor)\n\n        # Finalize the axes details\n        if self.legend == \"auto\":\n            show_legend = not self._redundant_hue and self.input_format != \"wide\"\n        else:\n            show_legend = bool(self.legend)\n\n        if show_legend:\n            self.add_legend_data(ax)\n            handles, _ = ax.get_legend_handles_labels()\n            if handles:\n                ax.legend(title=self.legend_title)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "plot_strips", "self", "jitter", "dodge", "color", "edgecolor", "plot_kws", "width", "8", "self", "_native_width", "offsets", "self", "_nested_offsets", "width", "dodge", "if", "jitter", "is", "true", "jlim", "0", "1", "else", "jlim", "float", "jitter", "if", "hue", "in", "self", "variables", "and", "dodge", "jlim", "len", "self", "_hue_map", "levels", "jlim", "self", "_native_width", "jitterer", "partial", "np", "random", "uniform", "low", "jlim", "high", "jlim", "iter_vars", "self", "cat_axis", "if", "dodge", "iter_vars", "append", "hue", "ax", "self", "ax", "dodge_move", "jitter_move", "0", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "iter_vars", "from_comp_data", "true", "allow_empty", "true", "if", "offsets", "is", "not", "none", "and", "offsets", "0", "any", "dodge_move", "offsets", "sub_data", "hue", "map", "self", "_hue_map", "levels", "index", "jitter_move", "jitterer", "size", "len", "sub_data", "if", "len", "sub_data", "1", "else", "0", "adjusted_data", "sub_data", "self", "cat_axis", "dodge_move", "jitter_move", "sub_data", "self", "cat_axis", "adjusted_data", "for", "var", "in", "xy", "if", "self", "_log_scaled", "var", "sub_data", "var", "np", "power", "10", "sub_data", "var", "ax", "self", "_get_axes", "sub_vars", "points", "ax", "scatter", "sub_data", "x", "sub_data", "y", "color", "color", "plot_kws", "if", "hue", "in", "self", "variables", "points", "set_facecolors", "self", "_hue_map", "sub_data", "hue", "if", "edgecolor", "gray", "xxx", "todo", "change", "to", "auto", "points", "set_edgecolors", "self", "_get_gray", "points", "get_facecolors", "else", "points", "set_edgecolors", "edgecolor", "finalize", "the", "axes", "details", "if", "self", "legend", "auto", "show_legend", "not", "self", "_redundant_hue", "and", "self", "input_format", "wide", "else", "show_legend", "bool", "self", "legend", "if", "show_legend", "self", "add_legend_data", "ax", "handles", "_", "ax", "get_legend_handles_labels", "if", "handles", "ax", "legend", "title", "self", "legend_title"], "doc_len": 215}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotterNew.plot_swarms", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotterNew", "func_name": "plot_swarms", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotterNew\n    def plot_swarms(\n        self,\n        dodge,\n        color,\n        edgecolor,\n        warn_thresh,\n        plot_kws,\n    ):\n\n        width = .8 * self._native_width\n        offsets = self._nested_offsets(width, dodge)\n\n        iter_vars = [self.cat_axis]\n        if dodge:\n            iter_vars.append(\"hue\")\n\n        ax = self.ax\n        point_collections = {}\n        dodge_move = 0\n\n        for sub_vars, sub_data in self.iter_data(iter_vars,\n                                                 from_comp_data=True,\n                                                 allow_empty=True):\n\n            if offsets is not None:\n                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]\n\n            if not sub_data.empty:\n                sub_data[self.cat_axis] = sub_data[self.cat_axis] + dodge_move\n\n            for var in \"xy\":\n                if self._log_scaled(var):\n                    sub_data[var] = np.power(10, sub_data[var])\n\n            ax = self._get_axes(sub_vars)\n            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)\n\n            if \"hue\" in self.variables:\n                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))\n\n            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"\n                points.set_edgecolors(self._get_gray(points.get_facecolors()))\n            else:\n                points.set_edgecolors(edgecolor)\n\n            if not sub_data.empty:\n                point_collections[(ax, sub_data[self.cat_axis].iloc[0])] = points\n\n        beeswarm = Beeswarm(\n            width=width, orient=self.orient, warn_thresh=warn_thresh,\n        )\n        for (ax, center), points in point_collections.items():\n            if points.get_offsets().shape[0] > 1:\n\n                def draw(points, renderer, *, center=center):\n\n                    beeswarm(points, center)\n\n                    if self.orient == \"h\":\n                        scalex = False\n                        scaley = ax.get_autoscaley_on()\n                    else:\n                        scalex = ax.get_autoscalex_on()\n                        scaley = False\n\n                    # This prevents us from undoing the nice categorical axis limits\n                    # set in _adjust_cat_axis, because that method currently leave\n                    # the autoscale flag in its original setting. It may be better\n                    # to disable autoscaling there to avoid needing to do this.\n                    fixed_scale = self.var_types[self.cat_axis] == \"categorical\"\n                    ax.update_datalim(points.get_datalim(ax.transData))\n                    if not fixed_scale and (scalex or scaley):\n                        ax.autoscale_view(scalex=scalex, scaley=scaley)\n\n                    super(points.__class__, points).draw(renderer)\n\n                points.draw = draw.__get__(points)\n\n        _draw_figure(ax.figure)\n\n        # Finalize the axes details\n        if self.legend == \"auto\":\n            show_legend = not self._redundant_hue and self.input_format != \"wide\"\n        else:\n            show_legend = bool(self.legend)\n\n        if show_legend:\n            self.add_legend_data(ax)\n            handles, _ = ax.get_legend_handles_labels()\n            if handles:\n                ax.legend(title=self.legend_title)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotternew", "def", "plot_swarms", "self", "dodge", "color", "edgecolor", "warn_thresh", "plot_kws", "width", "8", "self", "_native_width", "offsets", "self", "_nested_offsets", "width", "dodge", "iter_vars", "self", "cat_axis", "if", "dodge", "iter_vars", "append", "hue", "ax", "self", "ax", "point_collections", "dodge_move", "0", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "iter_vars", "from_comp_data", "true", "allow_empty", "true", "if", "offsets", "is", "not", "none", "dodge_move", "offsets", "sub_data", "hue", "map", "self", "_hue_map", "levels", "index", "if", "not", "sub_data", "empty", "sub_data", "self", "cat_axis", "sub_data", "self", "cat_axis", "dodge_move", "for", "var", "in", "xy", "if", "self", "_log_scaled", "var", "sub_data", "var", "np", "power", "10", "sub_data", "var", "ax", "self", "_get_axes", "sub_vars", "points", "ax", "scatter", "sub_data", "x", "sub_data", "y", "color", "color", "plot_kws", "if", "hue", "in", "self", "variables", "points", "set_facecolors", "self", "_hue_map", "sub_data", "hue", "if", "edgecolor", "gray", "xxx", "todo", "change", "to", "auto", "points", "set_edgecolors", "self", "_get_gray", "points", "get_facecolors", "else", "points", "set_edgecolors", "edgecolor", "if", "not", "sub_data", "empty", "point_collections", "ax", "sub_data", "self", "cat_axis", "iloc", "0", "points", "beeswarm", "beeswarm", "width", "width", "orient", "self", "orient", "warn_thresh", "warn_thresh", "for", "ax", "center", "points", "in", "point_collections", "items", "if", "points", "get_offsets", "shape", "0", "1", "def", "draw", "points", "renderer", "center", "center", "beeswarm", "points", "center", "if", "self", "orient", "h", "scalex", "false", "scaley", "ax", "get_autoscaley_on", "else", "scalex", "ax", "get_autoscalex_on", "scaley", "false", "this", "prevents", "us", "from", "undoing", "the", "nice", "categorical", "axis", "limits", "set", "in", "_adjust_cat_axis", "because", "that", "method", "currently", "leave", "the", "autoscale", "flag", "in", "its", "original", "setting", "it", "may", "be", "better", "to", "disable", "autoscaling", "there", "to", "avoid", "needing", "to", "do", "this", "fixed_scale", "self", "var_types", "self", "cat_axis", "categorical", "ax", "update_datalim", "points", "get_datalim", "ax", "transdata", "if", "not", "fixed_scale", "and", "scalex", "or", "scaley", "ax", "autoscale_view", "scalex", "scalex", "scaley", "scaley", "super", "points", "__class__", "points", "draw", "renderer", "points", "draw", "draw", "__get__", "points", "_draw_figure", "ax", "figure", "finalize", "the", "axes", "details", "if", "self", "legend", "auto", "show_legend", "not", "self", "_redundant_hue", "and", "self", "input_format", "wide", "else", "show_legend", "bool", "self", "legend", "if", "show_legend", "self", "add_legend_data", "ax", "handles", "_", "ax", "get_legend_handles_labels", "if", "handles", "ax", "legend", "title", "self", "legend_title"], "doc_len": 302}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.establish_variables", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "establish_variables", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def establish_variables(self, x=None, y=None, hue=None, data=None,\n                            orient=None, order=None, hue_order=None,\n                            units=None):\n        \"\"\"Convert input specification into a common representation.\"\"\"\n        # Option 1:\n        # We are plotting a wide-form dataset\n        # -----------------------------------\n        if x is None and y is None:\n\n            # Do a sanity check on the inputs\n            if hue is not None:\n                error = \"Cannot use `hue` without `x` and `y`\"\n                raise ValueError(error)\n\n            # No hue grouping with wide inputs\n            plot_hues = None\n            hue_title = None\n            hue_names = None\n\n            # No statistical units with wide inputs\n            plot_units = None\n\n            # We also won't get a axes labels here\n            value_label = None\n            group_label = None\n\n            # Option 1a:\n            # The input data is a Pandas DataFrame\n            # ------------------------------------\n\n            if isinstance(data, pd.DataFrame):\n\n                # Order the data correctly\n                if order is None:\n                    order = []\n                    # Reduce to just numeric columns\n                    for col in data:\n                        if variable_type(data[col]) == \"numeric\":\n                            order.append(col)\n                plot_data = data[order]\n                group_names = order\n                group_label = data.columns.name\n\n                # Convert to a list of arrays, the common representation\n                iter_data = plot_data.items()\n                plot_data = [np.asarray(s, float) for k, s in iter_data]\n\n            # Option 1b:\n            # The input data is an array or list\n            # ----------------------------------\n\n            else:\n\n                # We can't reorder the data\n                if order is not None:\n                    error = \"Input data must be a pandas object to reorder\"\n                    raise ValueError(error)\n\n                # The input data is an array\n                if hasattr(data, \"shape\"):\n                    if len(data.shape) == 1:\n                        if np.isscalar(data[0]):\n                            plot_data = [data]\n                        else:\n                            plot_data = list(data)\n                    elif len(data.shape) == 2:\n                        nr, nc = data.shape\n                        if nr == 1 or nc == 1:\n                            plot_data = [data.ravel()]\n                        else:\n                            plot_data = [data[:, i] for i in range(nc)]\n                    else:\n                        error = (\"Input `data` can have no \"\n                                 \"more than 2 dimensions\")\n                        raise ValueError(error)\n\n                # Check if `data` is None to let us bail out here (for testing)\n                elif data is None:\n                    plot_data = [[]]\n\n                # The input data is a flat list\n                elif np.isscalar(data[0]):\n                    plot_data = [data]\n\n                # The input data is a nested list\n                # This will catch some things that might fail later\n                # but exhaustive checks are hard\n                else:\n                    plot_data = data\n\n                # Convert to a list of arrays, the common representation\n                plot_data = [np.asarray(d, float) for d in plot_data]\n\n                # The group names will just be numeric indices\n                group_names = list(range(len(plot_data)))\n\n            # Figure out the plotting orientation\n            orient = \"h\" if str(orient).startswith(\"h\") else \"v\"\n\n        # Option 2:\n        # We are plotting a long-form dataset\n        # -----------------------------------\n\n        else:\n\n            # See if we need to get variables from `data`\n            if data is not None:\n                x = data.get(x, x)\n                y = data.get(y, y)\n                hue = data.get(hue, hue)\n                units = data.get(units, units)\n\n            # Validate the inputs\n            for var in [x, y, hue, units]:\n                if isinstance(var, str):\n                    err = f\"Could not interpret input '{var}'\"\n                    raise ValueError(err)\n\n            # Figure out the plotting orientation\n            orient = infer_orient(\n                x, y, orient, require_numeric=self.require_numeric\n            )\n\n            # Option 2a:\n            # We are plotting a single set of data\n            # ------------------------------------\n            if x is None or y is None:\n\n                # Determine where the data are\n                vals = y if x is None else x\n\n                # Put them into the common representation\n                plot_data = [np.asarray(vals)]\n\n                # Get a label for the value axis\n                if hasattr(vals, \"name\"):\n                    value_label = vals.name\n                else:\n                    value_label = None\n\n                # This plot will not have group labels or hue nesting\n                groups = None\n                group_label = None\n                group_names = []\n                plot_hues = None\n                hue_names = None\n                hue_title = None\n                plot_units = None\n\n            # Option 2b:\n            # We are grouping the data values by another variable\n            # ---------------------------------------------------\n            else:\n\n                # Determine which role each variable will play\n                if orient == \"v\":\n                    vals, groups = y, x\n                else:\n                    vals, groups = x, y\n\n                # Get the categorical axis label\n                group_label = None\n                if hasattr(groups, \"name\"):\n                    group_label = groups.name\n\n                # Get the order on the categorical axis\n                group_names = categorical_order(groups, order)\n\n                # Group the numeric data\n                plot_data, value_label = self._group_longform(vals, groups,\n                                                              group_names)\n\n                # Now handle the hue levels for nested ordering\n                if hue is None:\n                    plot_hues = None\n                    hue_title = None\n                    hue_names = None\n                else:\n\n                    # Get the order of the hue levels\n                    hue_names = categorical_order(hue, hue_order)\n\n                    # Group the hue data\n                    plot_hues, hue_title = self._group_longform(hue, groups,\n                                                                group_names)\n\n                # Now handle the units for nested observations\n                if units is None:\n                    plot_units = None\n                else:\n                    plot_units, _ = self._group_longform(units, groups,\n                                                         group_names)\n\n        # Assign object attributes\n        # ------------------------\n        self.orient = orient\n        self.plot_data = plot_data\n        self.group_label = group_label\n        self.value_label = value_label\n        self.group_names = group_names\n        self.plot_hues = plot_hues\n        self.hue_title = hue_title\n        self.hue_names = hue_names\n        self.plot_units = plot_units\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "establish_variables", "self", "x", "none", "y", "none", "hue", "none", "data", "none", "orient", "none", "order", "none", "hue_order", "none", "units", "none", "convert", "input", "specification", "into", "a", "common", "representation", "option", "1", "we", "are", "plotting", "a", "wide", "form", "dataset", "if", "x", "is", "none", "and", "y", "is", "none", "do", "a", "sanity", "check", "on", "the", "inputs", "if", "hue", "is", "not", "none", "error", "cannot", "use", "hue", "without", "x", "and", "y", "raise", "valueerror", "error", "no", "hue", "grouping", "with", "wide", "inputs", "plot_hues", "none", "hue_title", "none", "hue_names", "none", "no", "statistical", "units", "with", "wide", "inputs", "plot_units", "none", "we", "also", "won", "t", "get", "a", "axes", "labels", "here", "value_label", "none", "group_label", "none", "option", "1a", "the", "input", "data", "is", "a", "pandas", "dataframe", "if", "isinstance", "data", "pd", "dataframe", "order", "the", "data", "correctly", "if", "order", "is", "none", "order", "reduce", "to", "just", "numeric", "columns", "for", "col", "in", "data", "if", "variable_type", "data", "col", "numeric", "order", "append", "col", "plot_data", "data", "order", "group_names", "order", "group_label", "data", "columns", "name", "convert", "to", "a", "list", "of", "arrays", "the", "common", "representation", "iter_data", "plot_data", "items", "plot_data", "np", "asarray", "s", "float", "for", "k", "s", "in", "iter_data", "option", "1b", "the", "input", "data", "is", "an", "array", "or", "list", "else", "we", "can", "t", "reorder", "the", "data", "if", "order", "is", "not", "none", "error", "input", "data", "must", "be", "a", "pandas", "object", "to", "reorder", "raise", "valueerror", "error", "the", "input", "data", "is", "an", "array", "if", "hasattr", "data", "shape", "if", "len", "data", "shape", "1", "if", "np", "isscalar", "data", "0", "plot_data", "data", "else", "plot_data", "list", "data", "elif", "len", "data", "shape", "2", "nr", "nc", "data", "shape", "if", "nr", "1", "or", "nc", "1", "plot_data", "data", "ravel", "else", "plot_data", "data", "i", "for", "i", "in", "range", "nc", "else", "error", "input", "data", "can", "have", "no", "more", "than", "2", "dimensions", "raise", "valueerror", "error", "check", "if", "data", "is", "none", "to", "let", "us", "bail", "out", "here", "for", "testing", "elif", "data", "is", "none", "plot_data", "the", "input", "data", "is", "a", "flat", "list", "elif", "np", "isscalar", "data", "0", "plot_data", "data", "the", "input", "data", "is", "a", "nested", "list", "this", "will", "catch", "some", "things", "that", "might", "fail", "later", "but", "exhaustive", "checks", "are", "hard", "else", "plot_data", "data", "convert", "to", "a", "list", "of", "arrays", "the", "common", "representation", "plot_data", "np", "asarray", "d", "float", "for", "d", "in", "plot_data", "the", "group", "names", "will", "just", "be", "numeric", "indices", "group_names", "list", "range", "len", "plot_data", "figure", "out", "the", "plotting", "orientation", "orient", "h", "if", "str", "orient", "startswith", "h", "else", "v", "option", "2", "we", "are", "plotting", "a", "long", "form", "dataset", "else", "see", "if", "we", "need", "to", "get", "variables", "from", "data", "if", "data", "is", "not", "none", "x", "data", "get", "x", "x", "y", "data", "get", "y", "y", "hue", "data", "get", "hue", "hue", "units", "data", "get", "units", "units", "validate", "the", "inputs", "for", "var", "in", "x", "y", "hue", "units", "if", "isinstance", "var", "str", "err", "f", "could", "not", "interpret", "input", "var", "raise", "valueerror", "err", "figure", "out", "the", "plotting", "orientation", "orient", "infer_orient", "x", "y", "orient", "require_numeric", "self", "require_numeric", "option", "2a", "we", "are", "plotting", "a", "single", "set", "of", "data", "if", "x", "is", "none", "or", "y", "is", "none", "determine", "where", "the", "data", "are", "vals", "y", "if", "x", "is", "none", "else", "x", "put", "them", "into", "the", "common", "representation", "plot_data", "np", "asarray", "vals", "get", "a", "label", "for", "the", "value", "axis", "if", "hasattr", "vals", "name", "value_label", "vals", "name", "else", "value_label", "none", "this", "plot", "will", "not", "have", "group", "labels", "or", "hue", "nesting", "groups", "none", "group_label", "none", "group_names", "plot_hues", "none", "hue_names", "none", "hue_title", "none", "plot_units", "none", "option", "2b", "we", "are", "grouping", "the", "data", "values", "by", "another", "variable", "else", "determine", "which", "role", "each", "variable", "will", "play", "if", "orient", "v", "vals", "groups", "y", "x", "else", "vals", "groups", "x", "y", "get", "the", "categorical", "axis", "label", "group_label", "none", "if", "hasattr", "groups", "name", "group_label", "groups", "name", "get", "the", "order", "on", "the", "categorical", "axis", "group_names", "categorical_order", "groups", "order", "group", "the", "numeric", "data", "plot_data", "value_label", "self", "_group_longform", "vals", "groups", "group_names", "now", "handle", "the", "hue", "levels", "for", "nested", "ordering", "if", "hue", "is", "none", "plot_hues", "none", "hue_title", "none", "hue_names", "none", "else", "get", "the", "order", "of", "the", "hue", "levels", "hue_names", "categorical_order", "hue", "hue_order", "group", "the", "hue", "data", "plot_hues", "hue_title", "self", "_group_longform", "hue", "groups", "group_names", "now", "handle", "the", "units", "for", "nested", "observations", "if", "units", "is", "none", "plot_units", "none", "else", "plot_units", "_", "self", "_group_longform", "units", "groups", "group_names", "assign", "object", "attributes", "self", "orient", "orient", "self", "plot_data", "plot_data", "self", "group_label", "group_label", "self", "value_label", "value_label", "self", "group_names", "group_names", "self", "plot_hues", "plot_hues", "self", "hue_title", "hue_title", "self", "hue_names", "hue_names", "self", "plot_units", "plot_units"], "doc_len": 698}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter._group_longform", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "_group_longform", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def _group_longform(self, vals, grouper, order):\n        \"\"\"Group a long-form variable by another with correct order.\"\"\"\n        # Ensure that the groupby will work\n        if not isinstance(vals, pd.Series):\n            if isinstance(grouper, pd.Series):\n                index = grouper.index\n            else:\n                index = None\n            vals = pd.Series(vals, index=index)\n\n        # Group the val data\n        grouped_vals = vals.groupby(grouper)\n        out_data = []\n        for g in order:\n            try:\n                g_vals = grouped_vals.get_group(g)\n            except KeyError:\n                g_vals = np.array([])\n            out_data.append(g_vals)\n\n        # Get the vals axis label\n        label = vals.name\n\n        return out_data, label\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "_group_longform", "self", "vals", "grouper", "order", "group", "a", "long", "form", "variable", "by", "another", "with", "correct", "order", "ensure", "that", "the", "groupby", "will", "work", "if", "not", "isinstance", "vals", "pd", "series", "if", "isinstance", "grouper", "pd", "series", "index", "grouper", "index", "else", "index", "none", "vals", "pd", "series", "vals", "index", "index", "group", "the", "val", "data", "grouped_vals", "vals", "groupby", "grouper", "out_data", "for", "g", "in", "order", "try", "g_vals", "grouped_vals", "get_group", "g", "except", "keyerror", "g_vals", "np", "array", "out_data", "append", "g_vals", "get", "the", "vals", "axis", "label", "label", "vals", "name", "return", "out_data", "label"], "doc_len": 86}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.establish_colors", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "establish_colors", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def establish_colors(self, color, palette, saturation):\n        \"\"\"Get a list of colors for the main component of the plots.\"\"\"\n        if self.hue_names is None:\n            n_colors = len(self.plot_data)\n        else:\n            n_colors = len(self.hue_names)\n\n        # Determine the main colors\n        if color is None and palette is None:\n            # Determine whether the current palette will have enough values\n            # If not, we'll default to the husl palette so each is distinct\n            current_palette = utils.get_color_cycle()\n            if n_colors <= len(current_palette):\n                colors = color_palette(n_colors=n_colors)\n            else:\n                colors = husl_palette(n_colors, l=.7)  # noqa\n\n        elif palette is None:\n            # When passing a specific color, the interpretation depends\n            # on whether there is a hue variable or not.\n            # If so, we will make a blend palette so that the different\n            # levels have some amount of variation.\n            if self.hue_names is None:\n                colors = [color] * n_colors\n            else:\n                if self.default_palette == \"light\":\n                    colors = light_palette(color, n_colors)\n                elif self.default_palette == \"dark\":\n                    colors = dark_palette(color, n_colors)\n                else:\n                    raise RuntimeError(\"No default palette specified\")\n        else:\n\n            # Let `palette` be a dict mapping level to color\n            if isinstance(palette, dict):\n                if self.hue_names is None:\n                    levels = self.group_names\n                else:\n                    levels = self.hue_names\n                palette = [palette[l] for l in levels]\n\n            colors = color_palette(palette, n_colors)\n\n        # Desaturate a bit because these are patches\n        if saturation < 1:\n            colors = color_palette(colors, desat=saturation)\n\n        # Convert the colors to a common representations\n        rgb_colors = color_palette(colors)\n\n        # Determine the gray color to use for the lines framing the plot\n        light_vals = [rgb_to_hls(*c)[1] for c in rgb_colors]\n        lum = min(light_vals) * .6\n        gray = mpl.colors.rgb2hex((lum, lum, lum))\n\n        # Assign object attributes\n        self.colors = rgb_colors\n        self.gray = gray\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "establish_colors", "self", "color", "palette", "saturation", "get", "a", "list", "of", "colors", "for", "the", "main", "component", "of", "the", "plots", "if", "self", "hue_names", "is", "none", "n_colors", "len", "self", "plot_data", "else", "n_colors", "len", "self", "hue_names", "determine", "the", "main", "colors", "if", "color", "is", "none", "and", "palette", "is", "none", "determine", "whether", "the", "current", "palette", "will", "have", "enough", "values", "if", "not", "we", "ll", "default", "to", "the", "husl", "palette", "so", "each", "is", "distinct", "current_palette", "utils", "get_color_cycle", "if", "n_colors", "len", "current_palette", "colors", "color_palette", "n_colors", "n_colors", "else", "colors", "husl_palette", "n_colors", "l", "7", "noqa", "elif", "palette", "is", "none", "when", "passing", "a", "specific", "color", "the", "interpretation", "depends", "on", "whether", "there", "is", "a", "hue", "variable", "or", "not", "if", "so", "we", "will", "make", "a", "blend", "palette", "so", "that", "the", "different", "levels", "have", "some", "amount", "of", "variation", "if", "self", "hue_names", "is", "none", "colors", "color", "n_colors", "else", "if", "self", "default_palette", "light", "colors", "light_palette", "color", "n_colors", "elif", "self", "default_palette", "dark", "colors", "dark_palette", "color", "n_colors", "else", "raise", "runtimeerror", "no", "default", "palette", "specified", "else", "let", "palette", "be", "a", "dict", "mapping", "level", "to", "color", "if", "isinstance", "palette", "dict", "if", "self", "hue_names", "is", "none", "levels", "self", "group_names", "else", "levels", "self", "hue_names", "palette", "palette", "l", "for", "l", "in", "levels", "colors", "color_palette", "palette", "n_colors", "desaturate", "a", "bit", "because", "these", "are", "patches", "if", "saturation", "1", "colors", "color_palette", "colors", "desat", "saturation", "convert", "the", "colors", "to", "a", "common", "representations", "rgb_colors", "color_palette", "colors", "determine", "the", "gray", "color", "to", "use", "for", "the", "lines", "framing", "the", "plot", "light_vals", "rgb_to_hls", "c", "1", "for", "c", "in", "rgb_colors", "lum", "min", "light_vals", "6", "gray", "mpl", "colors", "rgb2hex", "lum", "lum", "lum", "assign", "object", "attributes", "self", "colors", "rgb_colors", "self", "gray", "gray"], "doc_len": 261}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.hue_offsets", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "hue_offsets", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def hue_offsets(self):\n        \"\"\"A list of center positions for plots when hue nesting is used.\"\"\"\n        n_levels = len(self.hue_names)\n        if self.dodge:\n            each_width = self.width / n_levels\n            offsets = np.linspace(0, self.width - each_width, n_levels)\n            offsets -= offsets.mean()\n        else:\n            offsets = np.zeros(n_levels)\n\n        return offsets\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "hue_offsets", "self", "a", "list", "of", "center", "positions", "for", "plots", "when", "hue", "nesting", "is", "used", "n_levels", "len", "self", "hue_names", "if", "self", "dodge", "each_width", "self", "width", "n_levels", "offsets", "np", "linspace", "0", "self", "width", "each_width", "n_levels", "offsets", "offsets", "mean", "else", "offsets", "np", "zeros", "n_levels", "return", "offsets"], "doc_len": 48}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.nested_width", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "nested_width", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def nested_width(self):\n        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"\n        if self.dodge:\n            width = self.width / len(self.hue_names) * .98\n        else:\n            width = self.width\n        return width\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "nested_width", "self", "a", "float", "with", "the", "width", "of", "plot", "elements", "when", "hue", "nesting", "is", "used", "if", "self", "dodge", "width", "self", "width", "len", "self", "hue_names", "98", "else", "width", "self", "width", "return", "width"], "doc_len": 36}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.annotate_axes", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "annotate_axes", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def annotate_axes(self, ax):\n        \"\"\"Add descriptive labels to an Axes object.\"\"\"\n        if self.orient == \"v\":\n            xlabel, ylabel = self.group_label, self.value_label\n        else:\n            xlabel, ylabel = self.value_label, self.group_label\n\n        if xlabel is not None:\n            ax.set_xlabel(xlabel)\n        if ylabel is not None:\n            ax.set_ylabel(ylabel)\n\n        group_names = self.group_names\n        if not group_names:\n            group_names = [\"\" for _ in range(len(self.plot_data))]\n\n        if self.orient == \"v\":\n            ax.set_xticks(np.arange(len(self.plot_data)))\n            ax.set_xticklabels(group_names)\n        else:\n            ax.set_yticks(np.arange(len(self.plot_data)))\n            ax.set_yticklabels(group_names)\n\n        if self.orient == \"v\":\n            ax.xaxis.grid(False)\n            ax.set_xlim(-.5, len(self.plot_data) - .5, auto=None)\n        else:\n            ax.yaxis.grid(False)\n            ax.set_ylim(-.5, len(self.plot_data) - .5, auto=None)\n\n        if self.hue_names is not None:\n            ax.legend(loc=\"best\", title=self.hue_title)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "annotate_axes", "self", "ax", "add", "descriptive", "labels", "to", "an", "axes", "object", "if", "self", "orient", "v", "xlabel", "ylabel", "self", "group_label", "self", "value_label", "else", "xlabel", "ylabel", "self", "value_label", "self", "group_label", "if", "xlabel", "is", "not", "none", "ax", "set_xlabel", "xlabel", "if", "ylabel", "is", "not", "none", "ax", "set_ylabel", "ylabel", "group_names", "self", "group_names", "if", "not", "group_names", "group_names", "for", "_", "in", "range", "len", "self", "plot_data", "if", "self", "orient", "v", "ax", "set_xticks", "np", "arange", "len", "self", "plot_data", "ax", "set_xticklabels", "group_names", "else", "ax", "set_yticks", "np", "arange", "len", "self", "plot_data", "ax", "set_yticklabels", "group_names", "if", "self", "orient", "v", "ax", "xaxis", "grid", "false", "ax", "set_xlim", "5", "len", "self", "plot_data", "5", "auto", "none", "else", "ax", "yaxis", "grid", "false", "ax", "set_ylim", "5", "len", "self", "plot_data", "5", "auto", "none", "if", "self", "hue_names", "is", "not", "none", "ax", "legend", "loc", "best", "title", "self", "hue_title"], "doc_len": 131}
{"doc_id": "seaborn/categorical.py::_CategoricalPlotter.add_legend_data", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalPlotter", "func_name": "add_legend_data", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalPlotter\n    def add_legend_data(self, ax, color, label):\n        \"\"\"Add a dummy patch object so we can get legend data.\"\"\"\n        rect = plt.Rectangle([0, 0], 0, 0,\n                             linewidth=self.linewidth / 2,\n                             edgecolor=self.gray,\n                             facecolor=color,\n                             label=label)\n        ax.add_patch(rect)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalplotter", "def", "add_legend_data", "self", "ax", "color", "label", "add", "a", "dummy", "patch", "object", "so", "we", "can", "get", "legend", "data", "rect", "plt", "rectangle", "0", "0", "0", "0", "linewidth", "self", "linewidth", "2", "edgecolor", "self", "gray", "facecolor", "color", "label", "label", "ax", "add_patch", "rect"], "doc_len": 42}
{"doc_id": "seaborn/categorical.py::_BoxPlotter.__init__", "file_path": "seaborn/categorical.py", "class_name": "_BoxPlotter", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _BoxPlotter\n    def __init__(self, x, y, hue, data, order, hue_order,\n                 orient, color, palette, saturation,\n                 width, dodge, fliersize, linewidth):\n\n        self.establish_variables(x, y, hue, data, orient, order, hue_order)\n        self.establish_colors(color, palette, saturation)\n\n        self.dodge = dodge\n        self.width = width\n        self.fliersize = fliersize\n\n        if linewidth is None:\n            linewidth = mpl.rcParams[\"lines.linewidth\"]\n        self.linewidth = linewidth\n", "tokens": ["seaborn", "categorical", "py", "_boxplotter", "def", "__init__", "self", "x", "y", "hue", "data", "order", "hue_order", "orient", "color", "palette", "saturation", "width", "dodge", "fliersize", "linewidth", "self", "establish_variables", "x", "y", "hue", "data", "orient", "order", "hue_order", "self", "establish_colors", "color", "palette", "saturation", "self", "dodge", "dodge", "self", "width", "width", "self", "fliersize", "fliersize", "if", "linewidth", "is", "none", "linewidth", "mpl", "rcparams", "lines", "linewidth", "self", "linewidth", "linewidth"], "doc_len": 56}
{"doc_id": "seaborn/categorical.py::_BoxPlotter.draw_boxplot", "file_path": "seaborn/categorical.py", "class_name": "_BoxPlotter", "func_name": "draw_boxplot", "text": "文件路径: seaborn/categorical.py, 类名: _BoxPlotter\n    def draw_boxplot(self, ax, kws):\n        \"\"\"Use matplotlib to draw a boxplot on an Axes.\"\"\"\n        vert = self.orient == \"v\"\n\n        props = {}\n        for obj in [\"box\", \"whisker\", \"cap\", \"median\", \"flier\"]:\n            props[obj] = kws.pop(obj + \"props\", {})\n\n        for i, group_data in enumerate(self.plot_data):\n\n            if self.plot_hues is None:\n\n                # Handle case where there is data at this level\n                if group_data.size == 0:\n                    continue\n\n                # Draw a single box or a set of boxes\n                # with a single level of grouping\n                box_data = np.asarray(remove_na(group_data))\n\n                # Handle case where there is no non-null data\n                if box_data.size == 0:\n                    continue\n\n                artist_dict = ax.boxplot(box_data,\n                                         vert=vert,\n                                         patch_artist=True,\n                                         positions=[i],\n                                         widths=self.width,\n                                         **kws)\n                color = self.colors[i]\n                self.restyle_boxplot(artist_dict, color, props)\n            else:\n                # Draw nested groups of boxes\n                offsets = self.hue_offsets\n                for j, hue_level in enumerate(self.hue_names):\n\n                    # Add a legend for this hue level\n                    if not i:\n                        self.add_legend_data(ax, self.colors[j], hue_level)\n\n                    # Handle case where there is data at this level\n                    if group_data.size == 0:\n                        continue\n\n                    hue_mask = self.plot_hues[i] == hue_level\n                    box_data = np.asarray(remove_na(group_data[hue_mask]))\n\n                    # Handle case where there is no non-null data\n                    if box_data.size == 0:\n                        continue\n\n                    center = i + offsets[j]\n                    artist_dict = ax.boxplot(box_data,\n                                             vert=vert,\n                                             patch_artist=True,\n                                             positions=[center],\n                                             widths=self.nested_width,\n                                             **kws)\n                    self.restyle_boxplot(artist_dict, self.colors[j], props)\n", "tokens": ["seaborn", "categorical", "py", "_boxplotter", "def", "draw_boxplot", "self", "ax", "kws", "use", "matplotlib", "to", "draw", "a", "boxplot", "on", "an", "axes", "vert", "self", "orient", "v", "props", "for", "obj", "in", "box", "whisker", "cap", "median", "flier", "props", "obj", "kws", "pop", "obj", "props", "for", "i", "group_data", "in", "enumerate", "self", "plot_data", "if", "self", "plot_hues", "is", "none", "handle", "case", "where", "there", "is", "data", "at", "this", "level", "if", "group_data", "size", "0", "continue", "draw", "a", "single", "box", "or", "a", "set", "of", "boxes", "with", "a", "single", "level", "of", "grouping", "box_data", "np", "asarray", "remove_na", "group_data", "handle", "case", "where", "there", "is", "no", "non", "null", "data", "if", "box_data", "size", "0", "continue", "artist_dict", "ax", "boxplot", "box_data", "vert", "vert", "patch_artist", "true", "positions", "i", "widths", "self", "width", "kws", "color", "self", "colors", "i", "self", "restyle_boxplot", "artist_dict", "color", "props", "else", "draw", "nested", "groups", "of", "boxes", "offsets", "self", "hue_offsets", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "add", "a", "legend", "for", "this", "hue", "level", "if", "not", "i", "self", "add_legend_data", "ax", "self", "colors", "j", "hue_level", "handle", "case", "where", "there", "is", "data", "at", "this", "level", "if", "group_data", "size", "0", "continue", "hue_mask", "self", "plot_hues", "i", "hue_level", "box_data", "np", "asarray", "remove_na", "group_data", "hue_mask", "handle", "case", "where", "there", "is", "no", "non", "null", "data", "if", "box_data", "size", "0", "continue", "center", "i", "offsets", "j", "artist_dict", "ax", "boxplot", "box_data", "vert", "vert", "patch_artist", "true", "positions", "center", "widths", "self", "nested_width", "kws", "self", "restyle_boxplot", "artist_dict", "self", "colors", "j", "props"], "doc_len": 217}
{"doc_id": "seaborn/categorical.py::_BoxPlotter.restyle_boxplot", "file_path": "seaborn/categorical.py", "class_name": "_BoxPlotter", "func_name": "restyle_boxplot", "text": "文件路径: seaborn/categorical.py, 类名: _BoxPlotter\n    def restyle_boxplot(self, artist_dict, color, props):\n        \"\"\"Take a drawn matplotlib boxplot and make it look nice.\"\"\"\n        for box in artist_dict[\"boxes\"]:\n            box.update(dict(facecolor=color,\n                            zorder=.9,\n                            edgecolor=self.gray,\n                            linewidth=self.linewidth))\n            box.update(props[\"box\"])\n        for whisk in artist_dict[\"whiskers\"]:\n            whisk.update(dict(color=self.gray,\n                              linewidth=self.linewidth,\n                              linestyle=\"-\"))\n            whisk.update(props[\"whisker\"])\n        for cap in artist_dict[\"caps\"]:\n            cap.update(dict(color=self.gray,\n                            linewidth=self.linewidth))\n            cap.update(props[\"cap\"])\n        for med in artist_dict[\"medians\"]:\n            med.update(dict(color=self.gray,\n                            linewidth=self.linewidth))\n            med.update(props[\"median\"])\n        for fly in artist_dict[\"fliers\"]:\n            fly.update(dict(markerfacecolor=self.gray,\n                            marker=\"d\",\n                            markeredgecolor=self.gray,\n                            markersize=self.fliersize))\n            fly.update(props[\"flier\"])\n", "tokens": ["seaborn", "categorical", "py", "_boxplotter", "def", "restyle_boxplot", "self", "artist_dict", "color", "props", "take", "a", "drawn", "matplotlib", "boxplot", "and", "make", "it", "look", "nice", "for", "box", "in", "artist_dict", "boxes", "box", "update", "dict", "facecolor", "color", "zorder", "9", "edgecolor", "self", "gray", "linewidth", "self", "linewidth", "box", "update", "props", "box", "for", "whisk", "in", "artist_dict", "whiskers", "whisk", "update", "dict", "color", "self", "gray", "linewidth", "self", "linewidth", "linestyle", "whisk", "update", "props", "whisker", "for", "cap", "in", "artist_dict", "caps", "cap", "update", "dict", "color", "self", "gray", "linewidth", "self", "linewidth", "cap", "update", "props", "cap", "for", "med", "in", "artist_dict", "medians", "med", "update", "dict", "color", "self", "gray", "linewidth", "self", "linewidth", "med", "update", "props", "median", "for", "fly", "in", "artist_dict", "fliers", "fly", "update", "dict", "markerfacecolor", "self", "gray", "marker", "d", "markeredgecolor", "self", "gray", "markersize", "self", "fliersize", "fly", "update", "props", "flier"], "doc_len": 120}
{"doc_id": "seaborn/categorical.py::_BoxPlotter.plot", "file_path": "seaborn/categorical.py", "class_name": "_BoxPlotter", "func_name": "plot", "text": "文件路径: seaborn/categorical.py, 类名: _BoxPlotter\n    def plot(self, ax, boxplot_kws):\n        \"\"\"Make the plot.\"\"\"\n        self.draw_boxplot(ax, boxplot_kws)\n        self.annotate_axes(ax)\n        if self.orient == \"h\":\n            ax.invert_yaxis()\n", "tokens": ["seaborn", "categorical", "py", "_boxplotter", "def", "plot", "self", "ax", "boxplot_kws", "make", "the", "plot", "self", "draw_boxplot", "ax", "boxplot_kws", "self", "annotate_axes", "ax", "if", "self", "orient", "h", "ax", "invert_yaxis"], "doc_len": 25}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.__init__", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def __init__(self, x, y, hue, data, order, hue_order,\n                 bw, cut, scale, scale_hue, gridsize,\n                 width, inner, split, dodge, orient, linewidth,\n                 color, palette, saturation):\n\n        self.establish_variables(x, y, hue, data, orient, order, hue_order)\n        self.establish_colors(color, palette, saturation)\n        self.estimate_densities(bw, cut, scale, scale_hue, gridsize)\n\n        self.gridsize = gridsize\n        self.width = width\n        self.dodge = dodge\n\n        if inner is not None:\n            if not any([inner.startswith(\"quart\"),\n                        inner.startswith(\"box\"),\n                        inner.startswith(\"stick\"),\n                        inner.startswith(\"point\")]):\n                err = f\"Inner style '{inner}' not recognized\"\n                raise ValueError(err)\n        self.inner = inner\n\n        if split and self.hue_names is not None and len(self.hue_names) != 2:\n            msg = \"There must be exactly two hue levels to use `split`.'\"\n            raise ValueError(msg)\n        self.split = split\n\n        if linewidth is None:\n            linewidth = mpl.rcParams[\"lines.linewidth\"]\n        self.linewidth = linewidth\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "__init__", "self", "x", "y", "hue", "data", "order", "hue_order", "bw", "cut", "scale", "scale_hue", "gridsize", "width", "inner", "split", "dodge", "orient", "linewidth", "color", "palette", "saturation", "self", "establish_variables", "x", "y", "hue", "data", "orient", "order", "hue_order", "self", "establish_colors", "color", "palette", "saturation", "self", "estimate_densities", "bw", "cut", "scale", "scale_hue", "gridsize", "self", "gridsize", "gridsize", "self", "width", "width", "self", "dodge", "dodge", "if", "inner", "is", "not", "none", "if", "not", "any", "inner", "startswith", "quart", "inner", "startswith", "box", "inner", "startswith", "stick", "inner", "startswith", "point", "err", "f", "inner", "style", "inner", "not", "recognized", "raise", "valueerror", "err", "self", "inner", "inner", "if", "split", "and", "self", "hue_names", "is", "not", "none", "and", "len", "self", "hue_names", "2", "msg", "there", "must", "be", "exactly", "two", "hue", "levels", "to", "use", "split", "raise", "valueerror", "msg", "self", "split", "split", "if", "linewidth", "is", "none", "linewidth", "mpl", "rcparams", "lines", "linewidth", "self", "linewidth", "linewidth"], "doc_len": 132}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.estimate_densities", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "estimate_densities", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):\n        \"\"\"Find the support and density for all of the data.\"\"\"\n        # Initialize data structures to keep track of plotting data\n        if self.hue_names is None:\n            support = []\n            density = []\n            counts = np.zeros(len(self.plot_data))\n            max_density = np.zeros(len(self.plot_data))\n        else:\n            support = [[] for _ in self.plot_data]\n            density = [[] for _ in self.plot_data]\n            size = len(self.group_names), len(self.hue_names)\n            counts = np.zeros(size)\n            max_density = np.zeros(size)\n\n        for i, group_data in enumerate(self.plot_data):\n\n            # Option 1: we have a single level of grouping\n            # --------------------------------------------\n\n            if self.plot_hues is None:\n\n                # Strip missing datapoints\n                kde_data = remove_na(group_data)\n\n                # Handle special case of no data at this level\n                if kde_data.size == 0:\n                    support.append(np.array([]))\n                    density.append(np.array([1.]))\n                    counts[i] = 0\n                    max_density[i] = 0\n                    continue\n\n                # Handle special case of a single unique datapoint\n                elif np.unique(kde_data).size == 1:\n                    support.append(np.unique(kde_data))\n                    density.append(np.array([1.]))\n                    counts[i] = 1\n                    max_density[i] = 0\n                    continue\n\n                # Fit the KDE and get the used bandwidth size\n                kde, bw_used = self.fit_kde(kde_data, bw)\n\n                # Determine the support grid and get the density over it\n                support_i = self.kde_support(kde_data, bw_used, cut, gridsize)\n                density_i = kde.evaluate(support_i)\n\n                # Update the data structures with these results\n                support.append(support_i)\n                density.append(density_i)\n                counts[i] = kde_data.size\n                max_density[i] = density_i.max()\n\n            # Option 2: we have nested grouping by a hue variable\n            # ---------------------------------------------------\n\n            else:\n                for j, hue_level in enumerate(self.hue_names):\n\n                    # Handle special case of no data at this category level\n                    if not group_data.size:\n                        support[i].append(np.array([]))\n                        density[i].append(np.array([1.]))\n                        counts[i, j] = 0\n                        max_density[i, j] = 0\n                        continue\n\n                    # Select out the observations for this hue level\n                    hue_mask = self.plot_hues[i] == hue_level\n\n                    # Strip missing datapoints\n                    kde_data = remove_na(group_data[hue_mask])\n\n                    # Handle special case of no data at this level\n                    if kde_data.size == 0:\n                        support[i].append(np.array([]))\n                        density[i].append(np.array([1.]))\n                        counts[i, j] = 0\n                        max_density[i, j] = 0\n                        continue\n\n                    # Handle special case of a single unique datapoint\n                    elif np.unique(kde_data).size == 1:\n                        support[i].append(np.unique(kde_data))\n                        density[i].append(np.array([1.]))\n                        counts[i, j] = 1\n                        max_density[i, j] = 0\n                        continue\n\n                    # Fit the KDE and get the used bandwidth size\n                    kde, bw_used = self.fit_kde(kde_data, bw)\n\n                    # Determine the support grid and get the density over it\n                    support_ij = self.kde_support(kde_data, bw_used,\n                                                  cut, gridsize)\n                    density_ij = kde.evaluate(support_ij)\n\n                    # Update the data structures with these results\n                    support[i].append(support_ij)\n                    density[i].append(density_ij)\n                    counts[i, j] = kde_data.size\n                    max_density[i, j] = density_ij.max()\n\n        # Scale the height of the density curve.\n        # For a violinplot the density is non-quantitative.\n        # The objective here is to scale the curves relative to 1 so that\n        # they can be multiplied by the width parameter during plotting.\n\n        if scale == \"area\":\n            self.scale_area(density, max_density, scale_hue)\n\n        elif scale == \"width\":\n            self.scale_width(density)\n\n        elif scale == \"count\":\n            self.scale_count(density, counts, scale_hue)\n\n        else:\n            raise ValueError(f\"scale method '{scale}' not recognized\")\n\n        # Set object attributes that will be used while plotting\n        self.support = support\n        self.density = density\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "estimate_densities", "self", "bw", "cut", "scale", "scale_hue", "gridsize", "find", "the", "support", "and", "density", "for", "all", "of", "the", "data", "initialize", "data", "structures", "to", "keep", "track", "of", "plotting", "data", "if", "self", "hue_names", "is", "none", "support", "density", "counts", "np", "zeros", "len", "self", "plot_data", "max_density", "np", "zeros", "len", "self", "plot_data", "else", "support", "for", "_", "in", "self", "plot_data", "density", "for", "_", "in", "self", "plot_data", "size", "len", "self", "group_names", "len", "self", "hue_names", "counts", "np", "zeros", "size", "max_density", "np", "zeros", "size", "for", "i", "group_data", "in", "enumerate", "self", "plot_data", "option", "1", "we", "have", "a", "single", "level", "of", "grouping", "if", "self", "plot_hues", "is", "none", "strip", "missing", "datapoints", "kde_data", "remove_na", "group_data", "handle", "special", "case", "of", "no", "data", "at", "this", "level", "if", "kde_data", "size", "0", "support", "append", "np", "array", "density", "append", "np", "array", "1", "counts", "i", "0", "max_density", "i", "0", "continue", "handle", "special", "case", "of", "a", "single", "unique", "datapoint", "elif", "np", "unique", "kde_data", "size", "1", "support", "append", "np", "unique", "kde_data", "density", "append", "np", "array", "1", "counts", "i", "1", "max_density", "i", "0", "continue", "fit", "the", "kde", "and", "get", "the", "used", "bandwidth", "size", "kde", "bw_used", "self", "fit_kde", "kde_data", "bw", "determine", "the", "support", "grid", "and", "get", "the", "density", "over", "it", "support_i", "self", "kde_support", "kde_data", "bw_used", "cut", "gridsize", "density_i", "kde", "evaluate", "support_i", "update", "the", "data", "structures", "with", "these", "results", "support", "append", "support_i", "density", "append", "density_i", "counts", "i", "kde_data", "size", "max_density", "i", "density_i", "max", "option", "2", "we", "have", "nested", "grouping", "by", "a", "hue", "variable", "else", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "handle", "special", "case", "of", "no", "data", "at", "this", "category", "level", "if", "not", "group_data", "size", "support", "i", "append", "np", "array", "density", "i", "append", "np", "array", "1", "counts", "i", "j", "0", "max_density", "i", "j", "0", "continue", "select", "out", "the", "observations", "for", "this", "hue", "level", "hue_mask", "self", "plot_hues", "i", "hue_level", "strip", "missing", "datapoints", "kde_data", "remove_na", "group_data", "hue_mask", "handle", "special", "case", "of", "no", "data", "at", "this", "level", "if", "kde_data", "size", "0", "support", "i", "append", "np", "array", "density", "i", "append", "np", "array", "1", "counts", "i", "j", "0", "max_density", "i", "j", "0", "continue", "handle", "special", "case", "of", "a", "single", "unique", "datapoint", "elif", "np", "unique", "kde_data", "size", "1", "support", "i", "append", "np", "unique", "kde_data", "density", "i", "append", "np", "array", "1", "counts", "i", "j", "1", "max_density", "i", "j", "0", "continue", "fit", "the", "kde", "and", "get", "the", "used", "bandwidth", "size", "kde", "bw_used", "self", "fit_kde", "kde_data", "bw", "determine", "the", "support", "grid", "and", "get", "the", "density", "over", "it", "support_ij", "self", "kde_support", "kde_data", "bw_used", "cut", "gridsize", "density_ij", "kde", "evaluate", "support_ij", "update", "the", "data", "structures", "with", "these", "results", "support", "i", "append", "support_ij", "density", "i", "append", "density_ij", "counts", "i", "j", "kde_data", "size", "max_density", "i", "j", "density_ij", "max", "scale", "the", "height", "of", "the", "density", "curve", "for", "a", "violinplot", "the", "density", "is", "non", "quantitative", "the", "objective", "here", "is", "to", "scale", "the", "curves", "relative", "to", "1", "so", "that", "they", "can", "be", "multiplied", "by", "the", "width", "parameter", "during", "plotting", "if", "scale", "area", "self", "scale_area", "density", "max_density", "scale_hue", "elif", "scale", "width", "self", "scale_width", "density", "elif", "scale", "count", "self", "scale_count", "density", "counts", "scale_hue", "else", "raise", "valueerror", "f", "scale", "method", "scale", "not", "recognized", "set", "object", "attributes", "that", "will", "be", "used", "while", "plotting", "self", "support", "support", "self", "density", "density"], "doc_len": 507}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.fit_kde", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "fit_kde", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def fit_kde(self, x, bw):\n        \"\"\"Estimate a KDE for a vector of data with flexible bandwidth.\"\"\"\n        kde = gaussian_kde(x, bw)\n\n        # Extract the numeric bandwidth from the KDE object\n        bw_used = kde.factor\n\n        # At this point, bw will be a numeric scale factor.\n        # To get the actual bandwidth of the kernel, we multiple by the\n        # unbiased standard deviation of the data, which we will use\n        # elsewhere to compute the range of the support.\n        bw_used = bw_used * x.std(ddof=1)\n\n        return kde, bw_used\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "fit_kde", "self", "x", "bw", "estimate", "a", "kde", "for", "a", "vector", "of", "data", "with", "flexible", "bandwidth", "kde", "gaussian_kde", "x", "bw", "extract", "the", "numeric", "bandwidth", "from", "the", "kde", "object", "bw_used", "kde", "factor", "at", "this", "point", "bw", "will", "be", "a", "numeric", "scale", "factor", "to", "get", "the", "actual", "bandwidth", "of", "the", "kernel", "we", "multiple", "by", "the", "unbiased", "standard", "deviation", "of", "the", "data", "which", "we", "will", "use", "elsewhere", "to", "compute", "the", "range", "of", "the", "support", "bw_used", "bw_used", "x", "std", "ddof", "1", "return", "kde", "bw_used"], "doc_len": 84}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.kde_support", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "kde_support", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def kde_support(self, x, bw, cut, gridsize):\n        \"\"\"Define a grid of support for the violin.\"\"\"\n        support_min = x.min() - bw * cut\n        support_max = x.max() + bw * cut\n        return np.linspace(support_min, support_max, gridsize)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "kde_support", "self", "x", "bw", "cut", "gridsize", "define", "a", "grid", "of", "support", "for", "the", "violin", "support_min", "x", "min", "bw", "cut", "support_max", "x", "max", "bw", "cut", "return", "np", "linspace", "support_min", "support_max", "gridsize"], "doc_len": 35}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.scale_area", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "scale_area", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def scale_area(self, density, max_density, scale_hue):\n        \"\"\"Scale the relative area under the KDE curve.\n\n        This essentially preserves the \"standard\" KDE scaling, but the\n        resulting maximum density will be 1 so that the curve can be\n        properly multiplied by the violin width.\n\n        \"\"\"\n        if self.hue_names is None:\n            for d in density:\n                if d.size > 1:\n                    d /= max_density.max()\n        else:\n            for i, group in enumerate(density):\n                for d in group:\n                    if scale_hue:\n                        max = max_density[i].max()\n                    else:\n                        max = max_density.max()\n                    if d.size > 1:\n                        d /= max\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "scale_area", "self", "density", "max_density", "scale_hue", "scale", "the", "relative", "area", "under", "the", "kde", "curve", "this", "essentially", "preserves", "the", "standard", "kde", "scaling", "but", "the", "resulting", "maximum", "density", "will", "be", "1", "so", "that", "the", "curve", "can", "be", "properly", "multiplied", "by", "the", "violin", "width", "if", "self", "hue_names", "is", "none", "for", "d", "in", "density", "if", "d", "size", "1", "d", "max_density", "max", "else", "for", "i", "group", "in", "enumerate", "density", "for", "d", "in", "group", "if", "scale_hue", "max", "max_density", "i", "max", "else", "max", "max_density", "max", "if", "d", "size", "1", "d", "max"], "doc_len": 88}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.scale_width", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "scale_width", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def scale_width(self, density):\n        \"\"\"Scale each density curve to the same height.\"\"\"\n        if self.hue_names is None:\n            for d in density:\n                d /= d.max()\n        else:\n            for group in density:\n                for d in group:\n                    d /= d.max()\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "scale_width", "self", "density", "scale", "each", "density", "curve", "to", "the", "same", "height", "if", "self", "hue_names", "is", "none", "for", "d", "in", "density", "d", "d", "max", "else", "for", "group", "in", "density", "for", "d", "in", "group", "d", "d", "max"], "doc_len": 40}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.scale_count", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "scale_count", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def scale_count(self, density, counts, scale_hue):\n        \"\"\"Scale each density curve by the number of observations.\"\"\"\n        if self.hue_names is None:\n            if counts.max() == 0:\n                d = 0\n            else:\n                for count, d in zip(counts, density):\n                    d /= d.max()\n                    d *= count / counts.max()\n        else:\n            for i, group in enumerate(density):\n                for j, d in enumerate(group):\n                    if counts[i].max() == 0:\n                        d = 0\n                    else:\n                        count = counts[i, j]\n                        if scale_hue:\n                            scaler = count / counts[i].max()\n                        else:\n                            scaler = count / counts.max()\n                        d /= d.max()\n                        d *= scaler\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "scale_count", "self", "density", "counts", "scale_hue", "scale", "each", "density", "curve", "by", "the", "number", "of", "observations", "if", "self", "hue_names", "is", "none", "if", "counts", "max", "0", "d", "0", "else", "for", "count", "d", "in", "zip", "counts", "density", "d", "d", "max", "d", "count", "counts", "max", "else", "for", "i", "group", "in", "enumerate", "density", "for", "j", "d", "in", "enumerate", "group", "if", "counts", "i", "max", "0", "d", "0", "else", "count", "counts", "i", "j", "if", "scale_hue", "scaler", "count", "counts", "i", "max", "else", "scaler", "count", "counts", "max", "d", "d", "max", "d", "scaler"], "doc_len": 87}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.dwidth", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "dwidth", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def dwidth(self):\n\n        if self.hue_names is None or not self.dodge:\n            return self.width / 2\n        elif self.split:\n            return self.width / 2\n        else:\n            return self.width / (2 * len(self.hue_names))\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "dwidth", "self", "if", "self", "hue_names", "is", "none", "or", "not", "self", "dodge", "return", "self", "width", "2", "elif", "self", "split", "return", "self", "width", "2", "else", "return", "self", "width", "2", "len", "self", "hue_names"], "doc_len": 35}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_violins", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_violins", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_violins(self, ax):\n        \"\"\"Draw the violins onto `ax`.\"\"\"\n        fill_func = ax.fill_betweenx if self.orient == \"v\" else ax.fill_between\n        for i, group_data in enumerate(self.plot_data):\n\n            kws = dict(edgecolor=self.gray, linewidth=self.linewidth)\n\n            # Option 1: we have a single level of grouping\n            # --------------------------------------------\n\n            if self.plot_hues is None:\n\n                support, density = self.support[i], self.density[i]\n\n                # Handle special case of no observations in this bin\n                if support.size == 0:\n                    continue\n\n                # Handle special case of a single observation\n                elif support.size == 1:\n                    val = support.item()\n                    d = density.item()\n                    self.draw_single_observation(ax, i, val, d)\n                    continue\n\n                # Draw the violin for this group\n                grid = np.ones(self.gridsize) * i\n                fill_func(support,\n                          grid - density * self.dwidth,\n                          grid + density * self.dwidth,\n                          facecolor=self.colors[i],\n                          **kws)\n\n                # Draw the interior representation of the data\n                if self.inner is None:\n                    continue\n\n                # Get a nan-free vector of datapoints\n                violin_data = remove_na(group_data)\n\n                # Draw box and whisker information\n                if self.inner.startswith(\"box\"):\n                    self.draw_box_lines(ax, violin_data, i)\n\n                # Draw quartile lines\n                elif self.inner.startswith(\"quart\"):\n                    self.draw_quartiles(ax, violin_data, support, density, i)\n\n                # Draw stick observations\n                elif self.inner.startswith(\"stick\"):\n                    self.draw_stick_lines(ax, violin_data, support, density, i)\n\n                # Draw point observations\n                elif self.inner.startswith(\"point\"):\n                    self.draw_points(ax, violin_data, i)\n\n            # Option 2: we have nested grouping by a hue variable\n            # ---------------------------------------------------\n\n            else:\n                offsets = self.hue_offsets\n                for j, hue_level in enumerate(self.hue_names):\n\n                    support, density = self.support[i][j], self.density[i][j]\n                    kws[\"facecolor\"] = self.colors[j]\n\n                    # Add legend data, but just for one set of violins\n                    if not i:\n                        self.add_legend_data(ax, self.colors[j], hue_level)\n\n                    # Handle the special case where we have no observations\n                    if support.size == 0:\n                        continue\n\n                    # Handle the special case where we have one observation\n                    elif support.size == 1:\n                        val = support.item()\n                        d = density.item()\n                        if self.split:\n                            d = d / 2\n                        at_group = i + offsets[j]\n                        self.draw_single_observation(ax, at_group, val, d)\n                        continue\n\n                    # Option 2a: we are drawing a single split violin\n                    # -----------------------------------------------\n\n                    if self.split:\n\n                        grid = np.ones(self.gridsize) * i\n                        if j:\n                            fill_func(support,\n                                      grid,\n                                      grid + density * self.dwidth,\n                                      **kws)\n                        else:\n                            fill_func(support,\n                                      grid - density * self.dwidth,\n                                      grid,\n                                      **kws)\n\n                        # Draw the interior representation of the data\n                        if self.inner is None:\n                            continue\n\n                        # Get a nan-free vector of datapoints\n                        hue_mask = self.plot_hues[i] == hue_level\n                        violin_data = remove_na(group_data[hue_mask])\n\n                        # Draw quartile lines\n                        if self.inner.startswith(\"quart\"):\n                            self.draw_quartiles(ax, violin_data,\n                                                support, density, i,\n                                                [\"left\", \"right\"][j])\n\n                        # Draw stick observations\n                        elif self.inner.startswith(\"stick\"):\n                            self.draw_stick_lines(ax, violin_data,\n                                                  support, density, i,\n                                                  [\"left\", \"right\"][j])\n\n                        # The box and point interior plots are drawn for\n                        # all data at the group level, so we just do that once\n                        if j and any(self.plot_hues[0] == hue_level):\n                            continue\n\n                        # Get the whole vector for this group level\n                        violin_data = remove_na(group_data)\n\n                        # Draw box and whisker information\n                        if self.inner.startswith(\"box\"):\n                            self.draw_box_lines(ax, violin_data, i)\n\n                        # Draw point observations\n                        elif self.inner.startswith(\"point\"):\n                            self.draw_points(ax, violin_data, i)\n\n                    # Option 2b: we are drawing full nested violins\n                    # -----------------------------------------------\n\n                    else:\n                        grid = np.ones(self.gridsize) * (i + offsets[j])\n                        fill_func(support,\n                                  grid - density * self.dwidth,\n                                  grid + density * self.dwidth,\n                                  **kws)\n\n                        # Draw the interior representation\n                        if self.inner is None:\n                            continue\n\n                        # Get a nan-free vector of datapoints\n                        hue_mask = self.plot_hues[i] == hue_level\n                        violin_data = remove_na(group_data[hue_mask])\n\n                        # Draw box and whisker information\n                        if self.inner.startswith(\"box\"):\n                            self.draw_box_lines(ax, violin_data, i + offsets[j])\n\n                        # Draw quartile lines\n                        elif self.inner.startswith(\"quart\"):\n                            self.draw_quartiles(ax, violin_data,\n                                                support, density,\n                                                i + offsets[j])\n\n                        # Draw stick observations\n                        elif self.inner.startswith(\"stick\"):\n                            self.draw_stick_lines(ax, violin_data,\n                                                  support, density,\n                                                  i + offsets[j])\n\n                        # Draw point observations\n                        elif self.inner.startswith(\"point\"):\n                            self.draw_points(ax, violin_data, i + offsets[j])\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_violins", "self", "ax", "draw", "the", "violins", "onto", "ax", "fill_func", "ax", "fill_betweenx", "if", "self", "orient", "v", "else", "ax", "fill_between", "for", "i", "group_data", "in", "enumerate", "self", "plot_data", "kws", "dict", "edgecolor", "self", "gray", "linewidth", "self", "linewidth", "option", "1", "we", "have", "a", "single", "level", "of", "grouping", "if", "self", "plot_hues", "is", "none", "support", "density", "self", "support", "i", "self", "density", "i", "handle", "special", "case", "of", "no", "observations", "in", "this", "bin", "if", "support", "size", "0", "continue", "handle", "special", "case", "of", "a", "single", "observation", "elif", "support", "size", "1", "val", "support", "item", "d", "density", "item", "self", "draw_single_observation", "ax", "i", "val", "d", "continue", "draw", "the", "violin", "for", "this", "group", "grid", "np", "ones", "self", "gridsize", "i", "fill_func", "support", "grid", "density", "self", "dwidth", "grid", "density", "self", "dwidth", "facecolor", "self", "colors", "i", "kws", "draw", "the", "interior", "representation", "of", "the", "data", "if", "self", "inner", "is", "none", "continue", "get", "a", "nan", "free", "vector", "of", "datapoints", "violin_data", "remove_na", "group_data", "draw", "box", "and", "whisker", "information", "if", "self", "inner", "startswith", "box", "self", "draw_box_lines", "ax", "violin_data", "i", "draw", "quartile", "lines", "elif", "self", "inner", "startswith", "quart", "self", "draw_quartiles", "ax", "violin_data", "support", "density", "i", "draw", "stick", "observations", "elif", "self", "inner", "startswith", "stick", "self", "draw_stick_lines", "ax", "violin_data", "support", "density", "i", "draw", "point", "observations", "elif", "self", "inner", "startswith", "point", "self", "draw_points", "ax", "violin_data", "i", "option", "2", "we", "have", "nested", "grouping", "by", "a", "hue", "variable", "else", "offsets", "self", "hue_offsets", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "support", "density", "self", "support", "i", "j", "self", "density", "i", "j", "kws", "facecolor", "self", "colors", "j", "add", "legend", "data", "but", "just", "for", "one", "set", "of", "violins", "if", "not", "i", "self", "add_legend_data", "ax", "self", "colors", "j", "hue_level", "handle", "the", "special", "case", "where", "we", "have", "no", "observations", "if", "support", "size", "0", "continue", "handle", "the", "special", "case", "where", "we", "have", "one", "observation", "elif", "support", "size", "1", "val", "support", "item", "d", "density", "item", "if", "self", "split", "d", "d", "2", "at_group", "i", "offsets", "j", "self", "draw_single_observation", "ax", "at_group", "val", "d", "continue", "option", "2a", "we", "are", "drawing", "a", "single", "split", "violin", "if", "self", "split", "grid", "np", "ones", "self", "gridsize", "i", "if", "j", "fill_func", "support", "grid", "grid", "density", "self", "dwidth", "kws", "else", "fill_func", "support", "grid", "density", "self", "dwidth", "grid", "kws", "draw", "the", "interior", "representation", "of", "the", "data", "if", "self", "inner", "is", "none", "continue", "get", "a", "nan", "free", "vector", "of", "datapoints", "hue_mask", "self", "plot_hues", "i", "hue_level", "violin_data", "remove_na", "group_data", "hue_mask", "draw", "quartile", "lines", "if", "self", "inner", "startswith", "quart", "self", "draw_quartiles", "ax", "violin_data", "support", "density", "i", "left", "right", "j", "draw", "stick", "observations", "elif", "self", "inner", "startswith", "stick", "self", "draw_stick_lines", "ax", "violin_data", "support", "density", "i", "left", "right", "j", "the", "box", "and", "point", "interior", "plots", "are", "drawn", "for", "all", "data", "at", "the", "group", "level", "so", "we", "just", "do", "that", "once", "if", "j", "and", "any", "self", "plot_hues", "0", "hue_level", "continue", "get", "the", "whole", "vector", "for", "this", "group", "level", "violin_data", "remove_na", "group_data", "draw", "box", "and", "whisker", "information", "if", "self", "inner", "startswith", "box", "self", "draw_box_lines", "ax", "violin_data", "i", "draw", "point", "observations", "elif", "self", "inner", "startswith", "point", "self", "draw_points", "ax", "violin_data", "i", "option", "2b", "we", "are", "drawing", "full", "nested", "violins", "else", "grid", "np", "ones", "self", "gridsize", "i", "offsets", "j", "fill_func", "support", "grid", "density", "self", "dwidth", "grid", "density", "self", "dwidth", "kws", "draw", "the", "interior", "representation", "if", "self", "inner", "is", "none", "continue", "get", "a", "nan", "free", "vector", "of", "datapoints", "hue_mask", "self", "plot_hues", "i", "hue_level", "violin_data", "remove_na", "group_data", "hue_mask", "draw", "box", "and", "whisker", "information", "if", "self", "inner", "startswith", "box", "self", "draw_box_lines", "ax", "violin_data", "i", "offsets", "j", "draw", "quartile", "lines", "elif", "self", "inner", "startswith", "quart", "self", "draw_quartiles", "ax", "violin_data", "support", "density", "i", "offsets", "j", "draw", "stick", "observations", "elif", "self", "inner", "startswith", "stick", "self", "draw_stick_lines", "ax", "violin_data", "support", "density", "i", "offsets", "j", "draw", "point", "observations", "elif", "self", "inner", "startswith", "point", "self", "draw_points", "ax", "violin_data", "i", "offsets", "j"], "doc_len": 603}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_single_observation", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_single_observation", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_single_observation(self, ax, at_group, at_quant, density):\n        \"\"\"Draw a line to mark a single observation.\"\"\"\n        d_width = density * self.dwidth\n        if self.orient == \"v\":\n            ax.plot([at_group - d_width, at_group + d_width],\n                    [at_quant, at_quant],\n                    color=self.gray,\n                    linewidth=self.linewidth)\n        else:\n            ax.plot([at_quant, at_quant],\n                    [at_group - d_width, at_group + d_width],\n                    color=self.gray,\n                    linewidth=self.linewidth)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_single_observation", "self", "ax", "at_group", "at_quant", "density", "draw", "a", "line", "to", "mark", "a", "single", "observation", "d_width", "density", "self", "dwidth", "if", "self", "orient", "v", "ax", "plot", "at_group", "d_width", "at_group", "d_width", "at_quant", "at_quant", "color", "self", "gray", "linewidth", "self", "linewidth", "else", "ax", "plot", "at_quant", "at_quant", "at_group", "d_width", "at_group", "d_width", "color", "self", "gray", "linewidth", "self", "linewidth"], "doc_len": 56}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_box_lines", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_box_lines", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_box_lines(self, ax, data, center):\n        \"\"\"Draw boxplot information at center of the density.\"\"\"\n        # Compute the boxplot statistics\n        q25, q50, q75 = np.percentile(data, [25, 50, 75])\n        whisker_lim = 1.5 * (q75 - q25)\n        h1 = np.min(data[data >= (q25 - whisker_lim)])\n        h2 = np.max(data[data <= (q75 + whisker_lim)])\n\n        # Draw a boxplot using lines and a point\n        if self.orient == \"v\":\n            ax.plot([center, center], [h1, h2],\n                    linewidth=self.linewidth,\n                    color=self.gray)\n            ax.plot([center, center], [q25, q75],\n                    linewidth=self.linewidth * 3,\n                    color=self.gray)\n            ax.scatter(center, q50,\n                       zorder=3,\n                       color=\"white\",\n                       edgecolor=self.gray,\n                       s=np.square(self.linewidth * 2))\n        else:\n            ax.plot([h1, h2], [center, center],\n                    linewidth=self.linewidth,\n                    color=self.gray)\n            ax.plot([q25, q75], [center, center],\n                    linewidth=self.linewidth * 3,\n                    color=self.gray)\n            ax.scatter(q50, center,\n                       zorder=3,\n                       color=\"white\",\n                       edgecolor=self.gray,\n                       s=np.square(self.linewidth * 2))\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_box_lines", "self", "ax", "data", "center", "draw", "boxplot", "information", "at", "center", "of", "the", "density", "compute", "the", "boxplot", "statistics", "q25", "q50", "q75", "np", "percentile", "data", "25", "50", "75", "whisker_lim", "1", "5", "q75", "q25", "h1", "np", "min", "data", "data", "q25", "whisker_lim", "h2", "np", "max", "data", "data", "q75", "whisker_lim", "draw", "a", "boxplot", "using", "lines", "and", "a", "point", "if", "self", "orient", "v", "ax", "plot", "center", "center", "h1", "h2", "linewidth", "self", "linewidth", "color", "self", "gray", "ax", "plot", "center", "center", "q25", "q75", "linewidth", "self", "linewidth", "3", "color", "self", "gray", "ax", "scatter", "center", "q50", "zorder", "3", "color", "white", "edgecolor", "self", "gray", "s", "np", "square", "self", "linewidth", "2", "else", "ax", "plot", "h1", "h2", "center", "center", "linewidth", "self", "linewidth", "color", "self", "gray", "ax", "plot", "q25", "q75", "center", "center", "linewidth", "self", "linewidth", "3", "color", "self", "gray", "ax", "scatter", "q50", "center", "zorder", "3", "color", "white", "edgecolor", "self", "gray", "s", "np", "square", "self", "linewidth", "2"], "doc_len": 147}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_quartiles", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_quartiles", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_quartiles(self, ax, data, support, density, center, split=False):\n        \"\"\"Draw the quartiles as lines at width of density.\"\"\"\n        q25, q50, q75 = np.percentile(data, [25, 50, 75])\n\n        self.draw_to_density(ax, center, q25, support, density, split,\n                             linewidth=self.linewidth,\n                             dashes=[self.linewidth * 1.5] * 2)\n        self.draw_to_density(ax, center, q50, support, density, split,\n                             linewidth=self.linewidth,\n                             dashes=[self.linewidth * 3] * 2)\n        self.draw_to_density(ax, center, q75, support, density, split,\n                             linewidth=self.linewidth,\n                             dashes=[self.linewidth * 1.5] * 2)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_quartiles", "self", "ax", "data", "support", "density", "center", "split", "false", "draw", "the", "quartiles", "as", "lines", "at", "width", "of", "density", "q25", "q50", "q75", "np", "percentile", "data", "25", "50", "75", "self", "draw_to_density", "ax", "center", "q25", "support", "density", "split", "linewidth", "self", "linewidth", "dashes", "self", "linewidth", "1", "5", "2", "self", "draw_to_density", "ax", "center", "q50", "support", "density", "split", "linewidth", "self", "linewidth", "dashes", "self", "linewidth", "3", "2", "self", "draw_to_density", "ax", "center", "q75", "support", "density", "split", "linewidth", "self", "linewidth", "dashes", "self", "linewidth", "1", "5", "2"], "doc_len": 82}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_points", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_points", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_points(self, ax, data, center):\n        \"\"\"Draw individual observations as points at middle of the violin.\"\"\"\n        kws = dict(s=np.square(self.linewidth * 2),\n                   color=self.gray,\n                   edgecolor=self.gray)\n\n        grid = np.ones(len(data)) * center\n\n        if self.orient == \"v\":\n            ax.scatter(grid, data, **kws)\n        else:\n            ax.scatter(data, grid, **kws)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_points", "self", "ax", "data", "center", "draw", "individual", "observations", "as", "points", "at", "middle", "of", "the", "violin", "kws", "dict", "s", "np", "square", "self", "linewidth", "2", "color", "self", "gray", "edgecolor", "self", "gray", "grid", "np", "ones", "len", "data", "center", "if", "self", "orient", "v", "ax", "scatter", "grid", "data", "kws", "else", "ax", "scatter", "data", "grid", "kws"], "doc_len": 55}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_stick_lines", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_stick_lines", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_stick_lines(self, ax, data, support, density,\n                         center, split=False):\n        \"\"\"Draw individual observations as sticks at width of density.\"\"\"\n        for val in data:\n            self.draw_to_density(ax, center, val, support, density, split,\n                                 linewidth=self.linewidth * .5)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_stick_lines", "self", "ax", "data", "support", "density", "center", "split", "false", "draw", "individual", "observations", "as", "sticks", "at", "width", "of", "density", "for", "val", "in", "data", "self", "draw_to_density", "ax", "center", "val", "support", "density", "split", "linewidth", "self", "linewidth", "5"], "doc_len": 39}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.draw_to_density", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "draw_to_density", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def draw_to_density(self, ax, center, val, support, density, split, **kws):\n        \"\"\"Draw a line orthogonal to the value axis at width of density.\"\"\"\n        idx = np.argmin(np.abs(support - val))\n        width = self.dwidth * density[idx] * .99\n\n        kws[\"color\"] = self.gray\n\n        if self.orient == \"v\":\n            if split == \"left\":\n                ax.plot([center - width, center], [val, val], **kws)\n            elif split == \"right\":\n                ax.plot([center, center + width], [val, val], **kws)\n            else:\n                ax.plot([center - width, center + width], [val, val], **kws)\n        else:\n            if split == \"left\":\n                ax.plot([val, val], [center - width, center], **kws)\n            elif split == \"right\":\n                ax.plot([val, val], [center, center + width], **kws)\n            else:\n                ax.plot([val, val], [center - width, center + width], **kws)\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "draw_to_density", "self", "ax", "center", "val", "support", "density", "split", "kws", "draw", "a", "line", "orthogonal", "to", "the", "value", "axis", "at", "width", "of", "density", "idx", "np", "argmin", "np", "abs", "support", "val", "width", "self", "dwidth", "density", "idx", "99", "kws", "color", "self", "gray", "if", "self", "orient", "v", "if", "split", "left", "ax", "plot", "center", "width", "center", "val", "val", "kws", "elif", "split", "right", "ax", "plot", "center", "center", "width", "val", "val", "kws", "else", "ax", "plot", "center", "width", "center", "width", "val", "val", "kws", "else", "if", "split", "left", "ax", "plot", "val", "val", "center", "width", "center", "kws", "elif", "split", "right", "ax", "plot", "val", "val", "center", "center", "width", "kws", "else", "ax", "plot", "val", "val", "center", "width", "center", "width", "kws"], "doc_len": 112}
{"doc_id": "seaborn/categorical.py::_ViolinPlotter.plot", "file_path": "seaborn/categorical.py", "class_name": "_ViolinPlotter", "func_name": "plot", "text": "文件路径: seaborn/categorical.py, 类名: _ViolinPlotter\n    def plot(self, ax):\n        \"\"\"Make the violin plot.\"\"\"\n        self.draw_violins(ax)\n        self.annotate_axes(ax)\n        if self.orient == \"h\":\n            ax.invert_yaxis()\n", "tokens": ["seaborn", "categorical", "py", "_violinplotter", "def", "plot", "self", "ax", "make", "the", "violin", "plot", "self", "draw_violins", "ax", "self", "annotate_axes", "ax", "if", "self", "orient", "h", "ax", "invert_yaxis"], "doc_len": 24}
{"doc_id": "seaborn/categorical.py::_CategoricalStatPlotter.nested_width", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalStatPlotter", "func_name": "nested_width", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalStatPlotter\n    def nested_width(self):\n        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"\n        if self.dodge:\n            width = self.width / len(self.hue_names)\n        else:\n            width = self.width\n        return width\n", "tokens": ["seaborn", "categorical", "py", "_categoricalstatplotter", "def", "nested_width", "self", "a", "float", "with", "the", "width", "of", "plot", "elements", "when", "hue", "nesting", "is", "used", "if", "self", "dodge", "width", "self", "width", "len", "self", "hue_names", "else", "width", "self", "width", "return", "width"], "doc_len": 35}
{"doc_id": "seaborn/categorical.py::_CategoricalStatPlotter.estimate_statistic", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalStatPlotter", "func_name": "estimate_statistic", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalStatPlotter\n    def estimate_statistic(self, estimator, errorbar, n_boot, seed):\n\n        if self.hue_names is None:\n            statistic = []\n            confint = []\n        else:\n            statistic = [[] for _ in self.plot_data]\n            confint = [[] for _ in self.plot_data]\n\n        var = {\"v\": \"y\", \"h\": \"x\"}[self.orient]\n\n        agg = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n\n        for i, group_data in enumerate(self.plot_data):\n\n            # Option 1: we have a single layer of grouping\n            # --------------------------------------------\n            if self.plot_hues is None:\n\n                df = pd.DataFrame({var: group_data})\n                if self.plot_units is not None:\n                    df[\"units\"] = self.plot_units[i]\n\n                res = agg(df, var)\n\n                statistic.append(res[var])\n                if errorbar is not None:\n                    confint.append((res[f\"{var}min\"], res[f\"{var}max\"]))\n\n            # Option 2: we are grouping by a hue layer\n            # ----------------------------------------\n\n            else:\n                for hue_level in self.hue_names:\n\n                    if not self.plot_hues[i].size:\n                        statistic[i].append(np.nan)\n                        if errorbar is not None:\n                            confint[i].append((np.nan, np.nan))\n                        continue\n\n                    hue_mask = self.plot_hues[i] == hue_level\n                    df = pd.DataFrame({var: group_data[hue_mask]})\n                    if self.plot_units is not None:\n                        df[\"units\"] = self.plot_units[i][hue_mask]\n\n                    res = agg(df, var)\n\n                    statistic[i].append(res[var])\n                    if errorbar is not None:\n                        confint[i].append((res[f\"{var}min\"], res[f\"{var}max\"]))\n\n        # Save the resulting values for plotting\n        self.statistic = np.array(statistic)\n        self.confint = np.array(confint)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalstatplotter", "def", "estimate_statistic", "self", "estimator", "errorbar", "n_boot", "seed", "if", "self", "hue_names", "is", "none", "statistic", "confint", "else", "statistic", "for", "_", "in", "self", "plot_data", "confint", "for", "_", "in", "self", "plot_data", "var", "v", "y", "h", "x", "self", "orient", "agg", "estimateaggregator", "estimator", "errorbar", "n_boot", "n_boot", "seed", "seed", "for", "i", "group_data", "in", "enumerate", "self", "plot_data", "option", "1", "we", "have", "a", "single", "layer", "of", "grouping", "if", "self", "plot_hues", "is", "none", "df", "pd", "dataframe", "var", "group_data", "if", "self", "plot_units", "is", "not", "none", "df", "units", "self", "plot_units", "i", "res", "agg", "df", "var", "statistic", "append", "res", "var", "if", "errorbar", "is", "not", "none", "confint", "append", "res", "f", "var", "min", "res", "f", "var", "max", "option", "2", "we", "are", "grouping", "by", "a", "hue", "layer", "else", "for", "hue_level", "in", "self", "hue_names", "if", "not", "self", "plot_hues", "i", "size", "statistic", "i", "append", "np", "nan", "if", "errorbar", "is", "not", "none", "confint", "i", "append", "np", "nan", "np", "nan", "continue", "hue_mask", "self", "plot_hues", "i", "hue_level", "df", "pd", "dataframe", "var", "group_data", "hue_mask", "if", "self", "plot_units", "is", "not", "none", "df", "units", "self", "plot_units", "i", "hue_mask", "res", "agg", "df", "var", "statistic", "i", "append", "res", "var", "if", "errorbar", "is", "not", "none", "confint", "i", "append", "res", "f", "var", "min", "res", "f", "var", "max", "save", "the", "resulting", "values", "for", "plotting", "self", "statistic", "np", "array", "statistic", "self", "confint", "np", "array", "confint"], "doc_len": 209}
{"doc_id": "seaborn/categorical.py::_CategoricalStatPlotter.draw_confints", "file_path": "seaborn/categorical.py", "class_name": "_CategoricalStatPlotter", "func_name": "draw_confints", "text": "文件路径: seaborn/categorical.py, 类名: _CategoricalStatPlotter\n    def draw_confints(self, ax, at_group, confint, colors,\n                      errwidth=None, capsize=None, **kws):\n\n        if errwidth is not None:\n            kws.setdefault(\"lw\", errwidth)\n        else:\n            kws.setdefault(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.8)\n\n        for at, (ci_low, ci_high), color in zip(at_group,\n                                                confint,\n                                                colors):\n            if self.orient == \"v\":\n                ax.plot([at, at], [ci_low, ci_high], color=color, **kws)\n                if capsize is not None:\n                    ax.plot([at - capsize / 2, at + capsize / 2],\n                            [ci_low, ci_low], color=color, **kws)\n                    ax.plot([at - capsize / 2, at + capsize / 2],\n                            [ci_high, ci_high], color=color, **kws)\n            else:\n                ax.plot([ci_low, ci_high], [at, at], color=color, **kws)\n                if capsize is not None:\n                    ax.plot([ci_low, ci_low],\n                            [at - capsize / 2, at + capsize / 2],\n                            color=color, **kws)\n                    ax.plot([ci_high, ci_high],\n                            [at - capsize / 2, at + capsize / 2],\n                            color=color, **kws)\n", "tokens": ["seaborn", "categorical", "py", "_categoricalstatplotter", "def", "draw_confints", "self", "ax", "at_group", "confint", "colors", "errwidth", "none", "capsize", "none", "kws", "if", "errwidth", "is", "not", "none", "kws", "setdefault", "lw", "errwidth", "else", "kws", "setdefault", "lw", "mpl", "rcparams", "lines", "linewidth", "1", "8", "for", "at", "ci_low", "ci_high", "color", "in", "zip", "at_group", "confint", "colors", "if", "self", "orient", "v", "ax", "plot", "at", "at", "ci_low", "ci_high", "color", "color", "kws", "if", "capsize", "is", "not", "none", "ax", "plot", "at", "capsize", "2", "at", "capsize", "2", "ci_low", "ci_low", "color", "color", "kws", "ax", "plot", "at", "capsize", "2", "at", "capsize", "2", "ci_high", "ci_high", "color", "color", "kws", "else", "ax", "plot", "ci_low", "ci_high", "at", "at", "color", "color", "kws", "if", "capsize", "is", "not", "none", "ax", "plot", "ci_low", "ci_low", "at", "capsize", "2", "at", "capsize", "2", "color", "color", "kws", "ax", "plot", "ci_high", "ci_high", "at", "capsize", "2", "at", "capsize", "2", "color", "color", "kws"], "doc_len": 130}
{"doc_id": "seaborn/categorical.py::_BarPlotter.__init__", "file_path": "seaborn/categorical.py", "class_name": "_BarPlotter", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _BarPlotter\n    def __init__(self, x, y, hue, data, order, hue_order,\n                 estimator, errorbar, n_boot, units, seed,\n                 orient, color, palette, saturation, width,\n                 errcolor, errwidth, capsize, dodge):\n        \"\"\"Initialize the plotter.\"\"\"\n        self.establish_variables(x, y, hue, data, orient,\n                                 order, hue_order, units)\n        self.establish_colors(color, palette, saturation)\n        self.estimate_statistic(estimator, errorbar, n_boot, seed)\n\n        self.dodge = dodge\n        self.width = width\n\n        self.errcolor = errcolor\n        self.errwidth = errwidth\n        self.capsize = capsize\n", "tokens": ["seaborn", "categorical", "py", "_barplotter", "def", "__init__", "self", "x", "y", "hue", "data", "order", "hue_order", "estimator", "errorbar", "n_boot", "units", "seed", "orient", "color", "palette", "saturation", "width", "errcolor", "errwidth", "capsize", "dodge", "initialize", "the", "plotter", "self", "establish_variables", "x", "y", "hue", "data", "orient", "order", "hue_order", "units", "self", "establish_colors", "color", "palette", "saturation", "self", "estimate_statistic", "estimator", "errorbar", "n_boot", "seed", "self", "dodge", "dodge", "self", "width", "width", "self", "errcolor", "errcolor", "self", "errwidth", "errwidth", "self", "capsize", "capsize"], "doc_len": 66}
{"doc_id": "seaborn/categorical.py::_BarPlotter.draw_bars", "file_path": "seaborn/categorical.py", "class_name": "_BarPlotter", "func_name": "draw_bars", "text": "文件路径: seaborn/categorical.py, 类名: _BarPlotter\n    def draw_bars(self, ax, kws):\n        \"\"\"Draw the bars onto `ax`.\"\"\"\n        # Get the right matplotlib function depending on the orientation\n        barfunc = ax.bar if self.orient == \"v\" else ax.barh\n        barpos = np.arange(len(self.statistic))\n\n        if self.plot_hues is None:\n\n            # Draw the bars\n            barfunc(barpos, self.statistic, self.width,\n                    color=self.colors, align=\"center\", **kws)\n\n            # Draw the confidence intervals\n            errcolors = [self.errcolor] * len(barpos)\n            self.draw_confints(ax,\n                               barpos,\n                               self.confint,\n                               errcolors,\n                               self.errwidth,\n                               self.capsize)\n\n        else:\n\n            for j, hue_level in enumerate(self.hue_names):\n\n                # Draw the bars\n                offpos = barpos + self.hue_offsets[j]\n                barfunc(offpos, self.statistic[:, j], self.nested_width,\n                        color=self.colors[j], align=\"center\",\n                        label=hue_level, **kws)\n\n                # Draw the confidence intervals\n                if self.confint.size:\n                    confint = self.confint[:, j]\n                    errcolors = [self.errcolor] * len(offpos)\n                    self.draw_confints(ax,\n                                       offpos,\n                                       confint,\n                                       errcolors,\n                                       self.errwidth,\n                                       self.capsize)\n", "tokens": ["seaborn", "categorical", "py", "_barplotter", "def", "draw_bars", "self", "ax", "kws", "draw", "the", "bars", "onto", "ax", "get", "the", "right", "matplotlib", "function", "depending", "on", "the", "orientation", "barfunc", "ax", "bar", "if", "self", "orient", "v", "else", "ax", "barh", "barpos", "np", "arange", "len", "self", "statistic", "if", "self", "plot_hues", "is", "none", "draw", "the", "bars", "barfunc", "barpos", "self", "statistic", "self", "width", "color", "self", "colors", "align", "center", "kws", "draw", "the", "confidence", "intervals", "errcolors", "self", "errcolor", "len", "barpos", "self", "draw_confints", "ax", "barpos", "self", "confint", "errcolors", "self", "errwidth", "self", "capsize", "else", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "draw", "the", "bars", "offpos", "barpos", "self", "hue_offsets", "j", "barfunc", "offpos", "self", "statistic", "j", "self", "nested_width", "color", "self", "colors", "j", "align", "center", "label", "hue_level", "kws", "draw", "the", "confidence", "intervals", "if", "self", "confint", "size", "confint", "self", "confint", "j", "errcolors", "self", "errcolor", "len", "offpos", "self", "draw_confints", "ax", "offpos", "confint", "errcolors", "self", "errwidth", "self", "capsize"], "doc_len": 138}
{"doc_id": "seaborn/categorical.py::_BarPlotter.plot", "file_path": "seaborn/categorical.py", "class_name": "_BarPlotter", "func_name": "plot", "text": "文件路径: seaborn/categorical.py, 类名: _BarPlotter\n    def plot(self, ax, bar_kws):\n        \"\"\"Make the plot.\"\"\"\n        self.draw_bars(ax, bar_kws)\n        self.annotate_axes(ax)\n        if self.orient == \"h\":\n            ax.invert_yaxis()\n", "tokens": ["seaborn", "categorical", "py", "_barplotter", "def", "plot", "self", "ax", "bar_kws", "make", "the", "plot", "self", "draw_bars", "ax", "bar_kws", "self", "annotate_axes", "ax", "if", "self", "orient", "h", "ax", "invert_yaxis"], "doc_len": 25}
{"doc_id": "seaborn/categorical.py::_PointPlotter.__init__", "file_path": "seaborn/categorical.py", "class_name": "_PointPlotter", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _PointPlotter\n    def __init__(self, x, y, hue, data, order, hue_order,\n                 estimator, errorbar, n_boot, units, seed,\n                 markers, linestyles, dodge, join, scale,\n                 orient, color, palette, errwidth, capsize, label):\n        \"\"\"Initialize the plotter.\"\"\"\n        self.establish_variables(x, y, hue, data, orient,\n                                 order, hue_order, units)\n        self.establish_colors(color, palette, 1)\n        self.estimate_statistic(estimator, errorbar, n_boot, seed)\n\n        # Override the default palette for single-color plots\n        if hue is None and color is None and palette is None:\n            self.colors = [color_palette()[0]] * len(self.colors)\n\n        # Don't join single-layer plots with different colors\n        if hue is None and palette is not None:\n            join = False\n\n        # Use a good default for `dodge=True`\n        if dodge is True and self.hue_names is not None:\n            dodge = .025 * len(self.hue_names)\n\n        # Make sure we have a marker for each hue level\n        if isinstance(markers, str):\n            markers = [markers] * len(self.colors)\n        self.markers = markers\n\n        # Make sure we have a line style for each hue level\n        if isinstance(linestyles, str):\n            linestyles = [linestyles] * len(self.colors)\n        self.linestyles = linestyles\n\n        # Set the other plot components\n        self.dodge = dodge\n        self.join = join\n        self.scale = scale\n        self.errwidth = errwidth\n        self.capsize = capsize\n        self.label = label\n", "tokens": ["seaborn", "categorical", "py", "_pointplotter", "def", "__init__", "self", "x", "y", "hue", "data", "order", "hue_order", "estimator", "errorbar", "n_boot", "units", "seed", "markers", "linestyles", "dodge", "join", "scale", "orient", "color", "palette", "errwidth", "capsize", "label", "initialize", "the", "plotter", "self", "establish_variables", "x", "y", "hue", "data", "orient", "order", "hue_order", "units", "self", "establish_colors", "color", "palette", "1", "self", "estimate_statistic", "estimator", "errorbar", "n_boot", "seed", "override", "the", "default", "palette", "for", "single", "color", "plots", "if", "hue", "is", "none", "and", "color", "is", "none", "and", "palette", "is", "none", "self", "colors", "color_palette", "0", "len", "self", "colors", "don", "t", "join", "single", "layer", "plots", "with", "different", "colors", "if", "hue", "is", "none", "and", "palette", "is", "not", "none", "join", "false", "use", "a", "good", "default", "for", "dodge", "true", "if", "dodge", "is", "true", "and", "self", "hue_names", "is", "not", "none", "dodge", "025", "len", "self", "hue_names", "make", "sure", "we", "have", "a", "marker", "for", "each", "hue", "level", "if", "isinstance", "markers", "str", "markers", "markers", "len", "self", "colors", "self", "markers", "markers", "make", "sure", "we", "have", "a", "line", "style", "for", "each", "hue", "level", "if", "isinstance", "linestyles", "str", "linestyles", "linestyles", "len", "self", "colors", "self", "linestyles", "linestyles", "set", "the", "other", "plot", "components", "self", "dodge", "dodge", "self", "join", "join", "self", "scale", "scale", "self", "errwidth", "errwidth", "self", "capsize", "capsize", "self", "label", "label"], "doc_len": 190}
{"doc_id": "seaborn/categorical.py::_PointPlotter.hue_offsets", "file_path": "seaborn/categorical.py", "class_name": "_PointPlotter", "func_name": "hue_offsets", "text": "文件路径: seaborn/categorical.py, 类名: _PointPlotter\n    def hue_offsets(self):\n        \"\"\"Offsets relative to the center position for each hue level.\"\"\"\n        if self.dodge:\n            offset = np.linspace(0, self.dodge, len(self.hue_names))\n            offset -= offset.mean()\n        else:\n            offset = np.zeros(len(self.hue_names))\n        return offset\n", "tokens": ["seaborn", "categorical", "py", "_pointplotter", "def", "hue_offsets", "self", "offsets", "relative", "to", "the", "center", "position", "for", "each", "hue", "level", "if", "self", "dodge", "offset", "np", "linspace", "0", "self", "dodge", "len", "self", "hue_names", "offset", "offset", "mean", "else", "offset", "np", "zeros", "len", "self", "hue_names", "return", "offset"], "doc_len": 41}
{"doc_id": "seaborn/categorical.py::_PointPlotter.draw_points", "file_path": "seaborn/categorical.py", "class_name": "_PointPlotter", "func_name": "draw_points", "text": "文件路径: seaborn/categorical.py, 类名: _PointPlotter\n    def draw_points(self, ax):\n        \"\"\"Draw the main data components of the plot.\"\"\"\n        # Get the center positions on the categorical axis\n        pointpos = np.arange(len(self.statistic))\n\n        # Get the size of the plot elements\n        lw = mpl.rcParams[\"lines.linewidth\"] * 1.8 * self.scale\n        mew = lw * .75\n        markersize = np.pi * np.square(lw) * 2\n\n        if self.plot_hues is None:\n\n            # Draw lines joining each estimate point\n            if self.join:\n                color = self.colors[0]\n                ls = self.linestyles[0]\n                if self.orient == \"h\":\n                    ax.plot(self.statistic, pointpos,\n                            color=color, ls=ls, lw=lw)\n                else:\n                    ax.plot(pointpos, self.statistic,\n                            color=color, ls=ls, lw=lw)\n\n            # Draw the confidence intervals\n            self.draw_confints(ax, pointpos, self.confint, self.colors,\n                               self.errwidth, self.capsize)\n\n            # Draw the estimate points\n            marker = self.markers[0]\n            colors = [mpl.colors.colorConverter.to_rgb(c) for c in self.colors]\n            if self.orient == \"h\":\n                x, y = self.statistic, pointpos\n            else:\n                x, y = pointpos, self.statistic\n            ax.scatter(x, y,\n                       linewidth=mew, marker=marker, s=markersize,\n                       facecolor=colors, edgecolor=colors, label=self.label)\n\n        else:\n\n            offsets = self.hue_offsets\n            for j, hue_level in enumerate(self.hue_names):\n\n                # Determine the values to plot for this level\n                statistic = self.statistic[:, j]\n\n                # Determine the position on the categorical and z axes\n                offpos = pointpos + offsets[j]\n                z = j + 1\n\n                # Draw lines joining each estimate point\n                if self.join:\n                    color = self.colors[j]\n                    ls = self.linestyles[j]\n                    if self.orient == \"h\":\n                        ax.plot(statistic, offpos, color=color,\n                                zorder=z, ls=ls, lw=lw)\n                    else:\n                        ax.plot(offpos, statistic, color=color,\n                                zorder=z, ls=ls, lw=lw)\n\n                # Draw the confidence intervals\n                if self.confint.size:\n                    confint = self.confint[:, j]\n                    errcolors = [self.colors[j]] * len(offpos)\n                    self.draw_confints(ax, offpos, confint, errcolors,\n                                       self.errwidth, self.capsize,\n                                       zorder=z)\n\n                # Draw the estimate points\n                n_points = len(remove_na(offpos))\n                marker = self.markers[j]\n                color = mpl.colors.colorConverter.to_rgb(self.colors[j])\n\n                if self.orient == \"h\":\n                    x, y = statistic, offpos\n                else:\n                    x, y = offpos, statistic\n\n                if not len(remove_na(statistic)):\n                    x = y = [np.nan] * n_points\n\n                ax.scatter(x, y, label=hue_level,\n                           facecolor=color, edgecolor=color,\n                           linewidth=mew, marker=marker, s=markersize,\n                           zorder=z)\n", "tokens": ["seaborn", "categorical", "py", "_pointplotter", "def", "draw_points", "self", "ax", "draw", "the", "main", "data", "components", "of", "the", "plot", "get", "the", "center", "positions", "on", "the", "categorical", "axis", "pointpos", "np", "arange", "len", "self", "statistic", "get", "the", "size", "of", "the", "plot", "elements", "lw", "mpl", "rcparams", "lines", "linewidth", "1", "8", "self", "scale", "mew", "lw", "75", "markersize", "np", "pi", "np", "square", "lw", "2", "if", "self", "plot_hues", "is", "none", "draw", "lines", "joining", "each", "estimate", "point", "if", "self", "join", "color", "self", "colors", "0", "ls", "self", "linestyles", "0", "if", "self", "orient", "h", "ax", "plot", "self", "statistic", "pointpos", "color", "color", "ls", "ls", "lw", "lw", "else", "ax", "plot", "pointpos", "self", "statistic", "color", "color", "ls", "ls", "lw", "lw", "draw", "the", "confidence", "intervals", "self", "draw_confints", "ax", "pointpos", "self", "confint", "self", "colors", "self", "errwidth", "self", "capsize", "draw", "the", "estimate", "points", "marker", "self", "markers", "0", "colors", "mpl", "colors", "colorconverter", "to_rgb", "c", "for", "c", "in", "self", "colors", "if", "self", "orient", "h", "x", "y", "self", "statistic", "pointpos", "else", "x", "y", "pointpos", "self", "statistic", "ax", "scatter", "x", "y", "linewidth", "mew", "marker", "marker", "s", "markersize", "facecolor", "colors", "edgecolor", "colors", "label", "self", "label", "else", "offsets", "self", "hue_offsets", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "determine", "the", "values", "to", "plot", "for", "this", "level", "statistic", "self", "statistic", "j", "determine", "the", "position", "on", "the", "categorical", "and", "z", "axes", "offpos", "pointpos", "offsets", "j", "z", "j", "1", "draw", "lines", "joining", "each", "estimate", "point", "if", "self", "join", "color", "self", "colors", "j", "ls", "self", "linestyles", "j", "if", "self", "orient", "h", "ax", "plot", "statistic", "offpos", "color", "color", "zorder", "z", "ls", "ls", "lw", "lw", "else", "ax", "plot", "offpos", "statistic", "color", "color", "zorder", "z", "ls", "ls", "lw", "lw", "draw", "the", "confidence", "intervals", "if", "self", "confint", "size", "confint", "self", "confint", "j", "errcolors", "self", "colors", "j", "len", "offpos", "self", "draw_confints", "ax", "offpos", "confint", "errcolors", "self", "errwidth", "self", "capsize", "zorder", "z", "draw", "the", "estimate", "points", "n_points", "len", "remove_na", "offpos", "marker", "self", "markers", "j", "color", "mpl", "colors", "colorconverter", "to_rgb", "self", "colors", "j", "if", "self", "orient", "h", "x", "y", "statistic", "offpos", "else", "x", "y", "offpos", "statistic", "if", "not", "len", "remove_na", "statistic", "x", "y", "np", "nan", "n_points", "ax", "scatter", "x", "y", "label", "hue_level", "facecolor", "color", "edgecolor", "color", "linewidth", "mew", "marker", "marker", "s", "markersize", "zorder", "z"], "doc_len": 348}
{"doc_id": "seaborn/categorical.py::_PointPlotter.plot", "file_path": "seaborn/categorical.py", "class_name": "_PointPlotter", "func_name": "plot", "text": "文件路径: seaborn/categorical.py, 类名: _PointPlotter\n    def plot(self, ax):\n        \"\"\"Make the plot.\"\"\"\n        self.draw_points(ax)\n        self.annotate_axes(ax)\n        if self.orient == \"h\":\n            ax.invert_yaxis()\n", "tokens": ["seaborn", "categorical", "py", "_pointplotter", "def", "plot", "self", "ax", "make", "the", "plot", "self", "draw_points", "ax", "self", "annotate_axes", "ax", "if", "self", "orient", "h", "ax", "invert_yaxis"], "doc_len": 23}
{"doc_id": "seaborn/categorical.py::_LVPlotter.__init__", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def __init__(self, x, y, hue, data, order, hue_order,\n                 orient, color, palette, saturation,\n                 width, dodge, k_depth, linewidth, scale, outlier_prop,\n                 trust_alpha, showfliers=True):\n\n        self.width = width\n        self.dodge = dodge\n        self.saturation = saturation\n\n        k_depth_methods = ['proportion', 'tukey', 'trustworthy', 'full']\n        if not (k_depth in k_depth_methods or isinstance(k_depth, Number)):\n            msg = (f'k_depth must be one of {k_depth_methods} or a number, '\n                   f'but {k_depth} was passed.')\n            raise ValueError(msg)\n        self.k_depth = k_depth\n\n        if linewidth is None:\n            linewidth = mpl.rcParams[\"lines.linewidth\"]\n        self.linewidth = linewidth\n\n        scales = ['linear', 'exponential', 'area']\n        if scale not in scales:\n            msg = f'scale must be one of {scales}, but {scale} was passed.'\n            raise ValueError(msg)\n        self.scale = scale\n\n        if ((outlier_prop > 1) or (outlier_prop <= 0)):\n            msg = f'outlier_prop {outlier_prop} not in range (0, 1]'\n            raise ValueError(msg)\n        self.outlier_prop = outlier_prop\n\n        if not 0 < trust_alpha < 1:\n            msg = f'trust_alpha {trust_alpha} not in range (0, 1)'\n            raise ValueError(msg)\n        self.trust_alpha = trust_alpha\n\n        self.showfliers = showfliers\n\n        self.establish_variables(x, y, hue, data, orient, order, hue_order)\n        self.establish_colors(color, palette, saturation)\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "__init__", "self", "x", "y", "hue", "data", "order", "hue_order", "orient", "color", "palette", "saturation", "width", "dodge", "k_depth", "linewidth", "scale", "outlier_prop", "trust_alpha", "showfliers", "true", "self", "width", "width", "self", "dodge", "dodge", "self", "saturation", "saturation", "k_depth_methods", "proportion", "tukey", "trustworthy", "full", "if", "not", "k_depth", "in", "k_depth_methods", "or", "isinstance", "k_depth", "number", "msg", "f", "k_depth", "must", "be", "one", "of", "k_depth_methods", "or", "a", "number", "f", "but", "k_depth", "was", "passed", "raise", "valueerror", "msg", "self", "k_depth", "k_depth", "if", "linewidth", "is", "none", "linewidth", "mpl", "rcparams", "lines", "linewidth", "self", "linewidth", "linewidth", "scales", "linear", "exponential", "area", "if", "scale", "not", "in", "scales", "msg", "f", "scale", "must", "be", "one", "of", "scales", "but", "scale", "was", "passed", "raise", "valueerror", "msg", "self", "scale", "scale", "if", "outlier_prop", "1", "or", "outlier_prop", "0", "msg", "f", "outlier_prop", "outlier_prop", "not", "in", "range", "0", "1", "raise", "valueerror", "msg", "self", "outlier_prop", "outlier_prop", "if", "not", "0", "trust_alpha", "1", "msg", "f", "trust_alpha", "trust_alpha", "not", "in", "range", "0", "1", "raise", "valueerror", "msg", "self", "trust_alpha", "trust_alpha", "self", "showfliers", "showfliers", "self", "establish_variables", "x", "y", "hue", "data", "orient", "order", "hue_order", "self", "establish_colors", "color", "palette", "saturation"], "doc_len": 168}
{"doc_id": "seaborn/categorical.py::_LVPlotter._lv_box_ends", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "_lv_box_ends", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def _lv_box_ends(self, vals):\n        \"\"\"Get the number of data points and calculate `depth` of\n        letter-value plot.\"\"\"\n        vals = np.asarray(vals)\n        # Remove infinite values while handling a 'object' dtype\n        # that can come from pd.Float64Dtype() input\n        with pd.option_context('mode.use_inf_as_na', True):\n            vals = vals[~pd.isnull(vals)]\n        n = len(vals)\n        p = self.outlier_prop\n\n        # Select the depth, i.e. number of boxes to draw, based on the method\n        if self.k_depth == 'full':\n            # extend boxes to 100% of the data\n            k = int(np.log2(n)) + 1\n        elif self.k_depth == 'tukey':\n            # This results with 5-8 points in each tail\n            k = int(np.log2(n)) - 3\n        elif self.k_depth == 'proportion':\n            k = int(np.log2(n)) - int(np.log2(n * p)) + 1\n        elif self.k_depth == 'trustworthy':\n            point_conf = 2 * _normal_quantile_func(1 - self.trust_alpha / 2) ** 2\n            k = int(np.log2(n / point_conf)) + 1\n        else:\n            k = int(self.k_depth)  # allow having k as input\n        # If the number happens to be less than 1, set k to 1\n        if k < 1:\n            k = 1\n\n        # Calculate the upper end for each of the k boxes\n        upper = [100 * (1 - 0.5 ** (i + 1)) for i in range(k, 0, -1)]\n        # Calculate the lower end for each of the k boxes\n        lower = [100 * (0.5 ** (i + 1)) for i in range(k, 0, -1)]\n        # Stitch the box ends together\n        percentile_ends = [(i, j) for i, j in zip(lower, upper)]\n        box_ends = [np.percentile(vals, q) for q in percentile_ends]\n        return box_ends, k\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "_lv_box_ends", "self", "vals", "get", "the", "number", "of", "data", "points", "and", "calculate", "depth", "of", "letter", "value", "plot", "vals", "np", "asarray", "vals", "remove", "infinite", "values", "while", "handling", "a", "object", "dtype", "that", "can", "come", "from", "pd", "float64dtype", "input", "with", "pd", "option_context", "mode", "use_inf_as_na", "true", "vals", "vals", "pd", "isnull", "vals", "n", "len", "vals", "p", "self", "outlier_prop", "select", "the", "depth", "i", "e", "number", "of", "boxes", "to", "draw", "based", "on", "the", "method", "if", "self", "k_depth", "full", "extend", "boxes", "to", "100", "of", "the", "data", "k", "int", "np", "log2", "n", "1", "elif", "self", "k_depth", "tukey", "this", "results", "with", "5", "8", "points", "in", "each", "tail", "k", "int", "np", "log2", "n", "3", "elif", "self", "k_depth", "proportion", "k", "int", "np", "log2", "n", "int", "np", "log2", "n", "p", "1", "elif", "self", "k_depth", "trustworthy", "point_conf", "2", "_normal_quantile_func", "1", "self", "trust_alpha", "2", "2", "k", "int", "np", "log2", "n", "point_conf", "1", "else", "k", "int", "self", "k_depth", "allow", "having", "k", "as", "input", "if", "the", "number", "happens", "to", "be", "less", "than", "1", "set", "k", "to", "1", "if", "k", "1", "k", "1", "calculate", "the", "upper", "end", "for", "each", "of", "the", "k", "boxes", "upper", "100", "1", "0", "5", "i", "1", "for", "i", "in", "range", "k", "0", "1", "calculate", "the", "lower", "end", "for", "each", "of", "the", "k", "boxes", "lower", "100", "0", "5", "i", "1", "for", "i", "in", "range", "k", "0", "1", "stitch", "the", "box", "ends", "together", "percentile_ends", "i", "j", "for", "i", "j", "in", "zip", "lower", "upper", "box_ends", "np", "percentile", "vals", "q", "for", "q", "in", "percentile_ends", "return", "box_ends", "k"], "doc_len": 243}
{"doc_id": "seaborn/categorical.py::_LVPlotter._lv_outliers", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "_lv_outliers", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def _lv_outliers(self, vals, k):\n        \"\"\"Find the outliers based on the letter value depth.\"\"\"\n        box_edge = 0.5 ** (k + 1)\n        perc_ends = (100 * box_edge, 100 * (1 - box_edge))\n        edges = np.percentile(vals, perc_ends)\n        lower_out = vals[np.where(vals < edges[0])[0]]\n        upper_out = vals[np.where(vals > edges[1])[0]]\n        return np.concatenate((lower_out, upper_out))\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "_lv_outliers", "self", "vals", "k", "find", "the", "outliers", "based", "on", "the", "letter", "value", "depth", "box_edge", "0", "5", "k", "1", "perc_ends", "100", "box_edge", "100", "1", "box_edge", "edges", "np", "percentile", "vals", "perc_ends", "lower_out", "vals", "np", "where", "vals", "edges", "0", "0", "upper_out", "vals", "np", "where", "vals", "edges", "1", "0", "return", "np", "concatenate", "lower_out", "upper_out"], "doc_len": 55}
{"doc_id": "seaborn/categorical.py::_LVPlotter._width_functions", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "_width_functions", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def _width_functions(self, width_func):\n        # Dictionary of functions for computing the width of the boxes\n        width_functions = {'linear': lambda h, i, k: (i + 1.) / k,\n                           'exponential': lambda h, i, k: 2**(-k + i - 1),\n                           'area': lambda h, i, k: (1 - 2**(-k + i - 2)) / h}\n        return width_functions[width_func]\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "_width_functions", "self", "width_func", "dictionary", "of", "functions", "for", "computing", "the", "width", "of", "the", "boxes", "width_functions", "linear", "lambda", "h", "i", "k", "i", "1", "k", "exponential", "lambda", "h", "i", "k", "2", "k", "i", "1", "area", "lambda", "h", "i", "k", "1", "2", "k", "i", "2", "h", "return", "width_functions", "width_func"], "doc_len": 50}
{"doc_id": "seaborn/categorical.py::_LVPlotter._lvplot", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "_lvplot", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def _lvplot(self, box_data, positions,\n                color=[255. / 256., 185. / 256., 0.],\n                widths=1, ax=None, box_kws=None,\n                flier_kws=None,\n                line_kws=None):\n\n        # -- Default keyword dicts - based on\n        # distributions.plot_univariate_histogram\n        box_kws = {} if box_kws is None else box_kws.copy()\n        flier_kws = {} if flier_kws is None else flier_kws.copy()\n        line_kws = {} if line_kws is None else line_kws.copy()\n\n        # Set the default kwargs for the boxes\n        box_default_kws = dict(edgecolor=self.gray,\n                               linewidth=self.linewidth)\n        for k, v in box_default_kws.items():\n            box_kws.setdefault(k, v)\n\n        # Set the default kwargs for the lines denoting medians\n        line_default_kws = dict(\n            color=\".15\", alpha=0.45, solid_capstyle=\"butt\", linewidth=self.linewidth\n        )\n        for k, v in line_default_kws.items():\n            line_kws.setdefault(k, v)\n\n        # Set the default kwargs for the outliers scatterplot\n        flier_default_kws = dict(marker='d', color=self.gray)\n        for k, v in flier_default_kws.items():\n            flier_kws.setdefault(k, v)\n\n        vert = self.orient == \"v\"\n        x = positions[0]\n        box_data = np.asarray(box_data)\n\n        # If we only have one data point, plot a line\n        if len(box_data) == 1:\n            line_kws.update({\n                'color': box_kws['edgecolor'],\n                'linestyle': box_kws.get('linestyle', '-'),\n                'linewidth': max(box_kws[\"linewidth\"], line_kws[\"linewidth\"])\n            })\n            ys = [box_data[0], box_data[0]]\n            xs = [x - widths / 2, x + widths / 2]\n            if vert:\n                xx, yy = xs, ys\n            else:\n                xx, yy = ys, xs\n            ax.plot(xx, yy, **line_kws)\n        else:\n            # Get the number of data points and calculate \"depth\" of\n            # letter-value plot\n            box_ends, k = self._lv_box_ends(box_data)\n\n            # Anonymous functions for calculating the width and height\n            # of the letter value boxes\n            width = self._width_functions(self.scale)\n\n            # Function to find height of boxes\n            def height(b):\n                return b[1] - b[0]\n\n            # Functions to construct the letter value boxes\n            def vert_perc_box(x, b, i, k, w):\n                rect = Patches.Rectangle((x - widths * w / 2, b[0]),\n                                         widths * w,\n                                         height(b), fill=True)\n                return rect\n\n            def horz_perc_box(x, b, i, k, w):\n                rect = Patches.Rectangle((b[0], x - widths * w / 2),\n                                         height(b), widths * w,\n                                         fill=True)\n                return rect\n\n            # Scale the width of the boxes so the biggest starts at 1\n            w_area = np.array([width(height(b), i, k)\n                               for i, b in enumerate(box_ends)])\n            w_area = w_area / np.max(w_area)\n\n            # Calculate the medians\n            y = np.median(box_data)\n\n            # Calculate the outliers and plot (only if showfliers == True)\n            outliers = []\n            if self.showfliers:\n                outliers = self._lv_outliers(box_data, k)\n            hex_color = mpl.colors.rgb2hex(color)\n\n            if vert:\n                box_func = vert_perc_box\n                xs_median = [x - widths / 2, x + widths / 2]\n                ys_median = [y, y]\n                xs_outliers = np.full(len(outliers), x)\n                ys_outliers = outliers\n\n            else:\n                box_func = horz_perc_box\n                xs_median = [y, y]\n                ys_median = [x - widths / 2, x + widths / 2]\n                xs_outliers = outliers\n                ys_outliers = np.full(len(outliers), x)\n\n            # Plot the medians\n            ax.plot(\n                xs_median,\n                ys_median,\n                **line_kws\n            )\n\n            # Plot outliers (if any)\n            if len(outliers) > 0:\n                ax.scatter(xs_outliers, ys_outliers,\n                           **flier_kws\n                           )\n\n            # Construct a color map from the input color\n            rgb = [hex_color, (1, 1, 1)]\n            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\n            # Make sure that the last boxes contain hue and are not pure white\n            rgb = [hex_color, cmap(.85)]\n            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\n\n            # Update box_kws with `cmap` if not defined in dict until now\n            box_kws.setdefault('cmap', cmap)\n\n            boxes = [box_func(x, b[0], i, k, b[1])\n                     for i, b in enumerate(zip(box_ends, w_area))]\n\n            collection = PatchCollection(boxes, **box_kws)\n\n            # Set the color gradation, first box will have color=hex_color\n            collection.set_array(np.array(np.linspace(1, 0, len(boxes))))\n\n            # Plot the boxes\n            ax.add_collection(collection)\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "_lvplot", "self", "box_data", "positions", "color", "255", "256", "185", "256", "0", "widths", "1", "ax", "none", "box_kws", "none", "flier_kws", "none", "line_kws", "none", "default", "keyword", "dicts", "based", "on", "distributions", "plot_univariate_histogram", "box_kws", "if", "box_kws", "is", "none", "else", "box_kws", "copy", "flier_kws", "if", "flier_kws", "is", "none", "else", "flier_kws", "copy", "line_kws", "if", "line_kws", "is", "none", "else", "line_kws", "copy", "set", "the", "default", "kwargs", "for", "the", "boxes", "box_default_kws", "dict", "edgecolor", "self", "gray", "linewidth", "self", "linewidth", "for", "k", "v", "in", "box_default_kws", "items", "box_kws", "setdefault", "k", "v", "set", "the", "default", "kwargs", "for", "the", "lines", "denoting", "medians", "line_default_kws", "dict", "color", "15", "alpha", "0", "45", "solid_capstyle", "butt", "linewidth", "self", "linewidth", "for", "k", "v", "in", "line_default_kws", "items", "line_kws", "setdefault", "k", "v", "set", "the", "default", "kwargs", "for", "the", "outliers", "scatterplot", "flier_default_kws", "dict", "marker", "d", "color", "self", "gray", "for", "k", "v", "in", "flier_default_kws", "items", "flier_kws", "setdefault", "k", "v", "vert", "self", "orient", "v", "x", "positions", "0", "box_data", "np", "asarray", "box_data", "if", "we", "only", "have", "one", "data", "point", "plot", "a", "line", "if", "len", "box_data", "1", "line_kws", "update", "color", "box_kws", "edgecolor", "linestyle", "box_kws", "get", "linestyle", "linewidth", "max", "box_kws", "linewidth", "line_kws", "linewidth", "ys", "box_data", "0", "box_data", "0", "xs", "x", "widths", "2", "x", "widths", "2", "if", "vert", "xx", "yy", "xs", "ys", "else", "xx", "yy", "ys", "xs", "ax", "plot", "xx", "yy", "line_kws", "else", "get", "the", "number", "of", "data", "points", "and", "calculate", "depth", "of", "letter", "value", "plot", "box_ends", "k", "self", "_lv_box_ends", "box_data", "anonymous", "functions", "for", "calculating", "the", "width", "and", "height", "of", "the", "letter", "value", "boxes", "width", "self", "_width_functions", "self", "scale", "function", "to", "find", "height", "of", "boxes", "def", "height", "b", "return", "b", "1", "b", "0", "functions", "to", "construct", "the", "letter", "value", "boxes", "def", "vert_perc_box", "x", "b", "i", "k", "w", "rect", "patches", "rectangle", "x", "widths", "w", "2", "b", "0", "widths", "w", "height", "b", "fill", "true", "return", "rect", "def", "horz_perc_box", "x", "b", "i", "k", "w", "rect", "patches", "rectangle", "b", "0", "x", "widths", "w", "2", "height", "b", "widths", "w", "fill", "true", "return", "rect", "scale", "the", "width", "of", "the", "boxes", "so", "the", "biggest", "starts", "at", "1", "w_area", "np", "array", "width", "height", "b", "i", "k", "for", "i", "b", "in", "enumerate", "box_ends", "w_area", "w_area", "np", "max", "w_area", "calculate", "the", "medians", "y", "np", "median", "box_data", "calculate", "the", "outliers", "and", "plot", "only", "if", "showfliers", "true", "outliers", "if", "self", "showfliers", "outliers", "self", "_lv_outliers", "box_data", "k", "hex_color", "mpl", "colors", "rgb2hex", "color", "if", "vert", "box_func", "vert_perc_box", "xs_median", "x", "widths", "2", "x", "widths", "2", "ys_median", "y", "y", "xs_outliers", "np", "full", "len", "outliers", "x", "ys_outliers", "outliers", "else", "box_func", "horz_perc_box", "xs_median", "y", "y", "ys_median", "x", "widths", "2", "x", "widths", "2", "xs_outliers", "outliers", "ys_outliers", "np", "full", "len", "outliers", "x", "plot", "the", "medians", "ax", "plot", "xs_median", "ys_median", "line_kws", "plot", "outliers", "if", "any", "if", "len", "outliers", "0", "ax", "scatter", "xs_outliers", "ys_outliers", "flier_kws", "construct", "a", "color", "map", "from", "the", "input", "color", "rgb", "hex_color", "1", "1", "1", "cmap", "mpl", "colors", "linearsegmentedcolormap", "from_list", "new_map", "rgb", "make", "sure", "that", "the", "last", "boxes", "contain", "hue", "and", "are", "not", "pure", "white", "rgb", "hex_color", "cmap", "85", "cmap", "mpl", "colors", "linearsegmentedcolormap", "from_list", "new_map", "rgb", "update", "box_kws", "with", "cmap", "if", "not", "defined", "in", "dict", "until", "now", "box_kws", "setdefault", "cmap", "cmap", "boxes", "box_func", "x", "b", "0", "i", "k", "b", "1", "for", "i", "b", "in", "enumerate", "zip", "box_ends", "w_area", "collection", "patchcollection", "boxes", "box_kws", "set", "the", "color", "gradation", "first", "box", "will", "have", "color", "hex_color", "collection", "set_array", "np", "array", "np", "linspace", "1", "0", "len", "boxes", "plot", "the", "boxes", "ax", "add_collection", "collection"], "doc_len": 542}
{"doc_id": "seaborn/categorical.py::_LVPlotter.draw_letter_value_plot", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "draw_letter_value_plot", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def draw_letter_value_plot(self, ax, box_kws=None, flier_kws=None,\n                               line_kws=None):\n        \"\"\"Use matplotlib to draw a letter value plot on an Axes.\"\"\"\n\n        for i, group_data in enumerate(self.plot_data):\n\n            if self.plot_hues is None:\n\n                # Handle case where there is data at this level\n                if group_data.size == 0:\n                    continue\n\n                # Draw a single box or a set of boxes\n                # with a single level of grouping\n                box_data = remove_na(group_data)\n\n                # Handle case where there is no non-null data\n                if box_data.size == 0:\n                    continue\n\n                color = self.colors[i]\n\n                self._lvplot(box_data,\n                             positions=[i],\n                             color=color,\n                             widths=self.width,\n                             ax=ax,\n                             box_kws=box_kws,\n                             flier_kws=flier_kws,\n                             line_kws=line_kws)\n\n            else:\n                # Draw nested groups of boxes\n                offsets = self.hue_offsets\n                for j, hue_level in enumerate(self.hue_names):\n\n                    # Add a legend for this hue level\n                    if not i:\n                        self.add_legend_data(ax, self.colors[j], hue_level)\n\n                    # Handle case where there is data at this level\n                    if group_data.size == 0:\n                        continue\n\n                    hue_mask = self.plot_hues[i] == hue_level\n                    box_data = remove_na(group_data[hue_mask])\n\n                    # Handle case where there is no non-null data\n                    if box_data.size == 0:\n                        continue\n\n                    color = self.colors[j]\n                    center = i + offsets[j]\n                    self._lvplot(box_data,\n                                 positions=[center],\n                                 color=color,\n                                 widths=self.nested_width,\n                                 ax=ax,\n                                 box_kws=box_kws,\n                                 flier_kws=flier_kws,\n                                 line_kws=line_kws)\n\n        # Autoscale the values axis to make sure all patches are visible\n        ax.autoscale_view(scalex=self.orient == \"h\", scaley=self.orient == \"v\")\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "draw_letter_value_plot", "self", "ax", "box_kws", "none", "flier_kws", "none", "line_kws", "none", "use", "matplotlib", "to", "draw", "a", "letter", "value", "plot", "on", "an", "axes", "for", "i", "group_data", "in", "enumerate", "self", "plot_data", "if", "self", "plot_hues", "is", "none", "handle", "case", "where", "there", "is", "data", "at", "this", "level", "if", "group_data", "size", "0", "continue", "draw", "a", "single", "box", "or", "a", "set", "of", "boxes", "with", "a", "single", "level", "of", "grouping", "box_data", "remove_na", "group_data", "handle", "case", "where", "there", "is", "no", "non", "null", "data", "if", "box_data", "size", "0", "continue", "color", "self", "colors", "i", "self", "_lvplot", "box_data", "positions", "i", "color", "color", "widths", "self", "width", "ax", "ax", "box_kws", "box_kws", "flier_kws", "flier_kws", "line_kws", "line_kws", "else", "draw", "nested", "groups", "of", "boxes", "offsets", "self", "hue_offsets", "for", "j", "hue_level", "in", "enumerate", "self", "hue_names", "add", "a", "legend", "for", "this", "hue", "level", "if", "not", "i", "self", "add_legend_data", "ax", "self", "colors", "j", "hue_level", "handle", "case", "where", "there", "is", "data", "at", "this", "level", "if", "group_data", "size", "0", "continue", "hue_mask", "self", "plot_hues", "i", "hue_level", "box_data", "remove_na", "group_data", "hue_mask", "handle", "case", "where", "there", "is", "no", "non", "null", "data", "if", "box_data", "size", "0", "continue", "color", "self", "colors", "j", "center", "i", "offsets", "j", "self", "_lvplot", "box_data", "positions", "center", "color", "color", "widths", "self", "nested_width", "ax", "ax", "box_kws", "box_kws", "flier_kws", "flier_kws", "line_kws", "line_kws", "autoscale", "the", "values", "axis", "to", "make", "sure", "all", "patches", "are", "visible", "ax", "autoscale_view", "scalex", "self", "orient", "h", "scaley", "self", "orient", "v"], "doc_len": 222}
{"doc_id": "seaborn/categorical.py::_LVPlotter.plot", "file_path": "seaborn/categorical.py", "class_name": "_LVPlotter", "func_name": "plot", "text": "文件路径: seaborn/categorical.py, 类名: _LVPlotter\n    def plot(self, ax, box_kws, flier_kws, line_kws):\n        \"\"\"Make the plot.\"\"\"\n        self.draw_letter_value_plot(ax, box_kws, flier_kws, line_kws)\n        self.annotate_axes(ax)\n        if self.orient == \"h\":\n            ax.invert_yaxis()\n", "tokens": ["seaborn", "categorical", "py", "_lvplotter", "def", "plot", "self", "ax", "box_kws", "flier_kws", "line_kws", "make", "the", "plot", "self", "draw_letter_value_plot", "ax", "box_kws", "flier_kws", "line_kws", "self", "annotate_axes", "ax", "if", "self", "orient", "h", "ax", "invert_yaxis"], "doc_len": 29}
{"doc_id": "seaborn/categorical.py::boxplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "boxplot", "text": "文件路径: seaborn/categorical.py\ndef boxplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    orient=None, color=None, palette=None, saturation=.75, width=.8,\n    dodge=True, fliersize=5, linewidth=None, whis=1.5, ax=None,\n    **kwargs\n):\n\n    plotter = _BoxPlotter(x, y, hue, data, order, hue_order,\n                          orient, color, palette, saturation,\n                          width, dodge, fliersize, linewidth)\n\n    if ax is None:\n        ax = plt.gca()\n    kwargs.update(dict(whis=whis))\n\n    plotter.plot(ax, kwargs)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "boxplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "orient", "none", "color", "none", "palette", "none", "saturation", "75", "width", "8", "dodge", "true", "fliersize", "5", "linewidth", "none", "whis", "1", "5", "ax", "none", "kwargs", "plotter", "_boxplotter", "x", "y", "hue", "data", "order", "hue_order", "orient", "color", "palette", "saturation", "width", "dodge", "fliersize", "linewidth", "if", "ax", "is", "none", "ax", "plt", "gca", "kwargs", "update", "dict", "whis", "whis", "plotter", "plot", "ax", "kwargs", "return", "ax"], "doc_len": 73}
{"doc_id": "seaborn/categorical.py::violinplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "violinplot", "text": "文件路径: seaborn/categorical.py\ndef violinplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    bw=\"scott\", cut=2, scale=\"area\", scale_hue=True, gridsize=100,\n    width=.8, inner=\"box\", split=False, dodge=True, orient=None,\n    linewidth=None, color=None, palette=None, saturation=.75,\n    ax=None, **kwargs,\n):\n\n    plotter = _ViolinPlotter(x, y, hue, data, order, hue_order,\n                             bw, cut, scale, scale_hue, gridsize,\n                             width, inner, split, dodge, orient, linewidth,\n                             color, palette, saturation)\n\n    if ax is None:\n        ax = plt.gca()\n\n    plotter.plot(ax)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "violinplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "bw", "scott", "cut", "2", "scale", "area", "scale_hue", "true", "gridsize", "100", "width", "8", "inner", "box", "split", "false", "dodge", "true", "orient", "none", "linewidth", "none", "color", "none", "palette", "none", "saturation", "75", "ax", "none", "kwargs", "plotter", "_violinplotter", "x", "y", "hue", "data", "order", "hue_order", "bw", "cut", "scale", "scale_hue", "gridsize", "width", "inner", "split", "dodge", "orient", "linewidth", "color", "palette", "saturation", "if", "ax", "is", "none", "ax", "plt", "gca", "plotter", "plot", "ax", "return", "ax"], "doc_len": 82}
{"doc_id": "seaborn/categorical.py::boxenplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "boxenplot", "text": "文件路径: seaborn/categorical.py\ndef boxenplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    orient=None, color=None, palette=None, saturation=.75,\n    width=.8, dodge=True, k_depth='tukey', linewidth=None,\n    scale='exponential', outlier_prop=0.007, trust_alpha=0.05,\n    showfliers=True,\n    ax=None, box_kws=None, flier_kws=None, line_kws=None,\n):\n    plotter = _LVPlotter(x, y, hue, data, order, hue_order,\n                         orient, color, palette, saturation,\n                         width, dodge, k_depth, linewidth, scale,\n                         outlier_prop, trust_alpha, showfliers)\n\n    if ax is None:\n        ax = plt.gca()\n\n    plotter.plot(ax, box_kws, flier_kws, line_kws)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "boxenplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "orient", "none", "color", "none", "palette", "none", "saturation", "75", "width", "8", "dodge", "true", "k_depth", "tukey", "linewidth", "none", "scale", "exponential", "outlier_prop", "0", "007", "trust_alpha", "0", "05", "showfliers", "true", "ax", "none", "box_kws", "none", "flier_kws", "none", "line_kws", "none", "plotter", "_lvplotter", "x", "y", "hue", "data", "order", "hue_order", "orient", "color", "palette", "saturation", "width", "dodge", "k_depth", "linewidth", "scale", "outlier_prop", "trust_alpha", "showfliers", "if", "ax", "is", "none", "ax", "plt", "gca", "plotter", "plot", "ax", "box_kws", "flier_kws", "line_kws", "return", "ax"], "doc_len": 86}
{"doc_id": "seaborn/categorical.py::stripplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "stripplot", "text": "文件路径: seaborn/categorical.py\ndef stripplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    jitter=True, dodge=False, orient=None, color=None, palette=None,\n    size=5, edgecolor=\"gray\", linewidth=0,\n    hue_norm=None, native_scale=False, formatter=None, legend=\"auto\",\n    ax=None, **kwargs\n):\n\n    p = _CategoricalPlotterNew(\n        data=data,\n        variables=_CategoricalPlotterNew.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    color = _default_color(ax.scatter, hue, color, kwargs)\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    # XXX Copying possibly bad default decisions from original code for now\n    kwargs.setdefault(\"zorder\", 3)\n    size = kwargs.get(\"s\", size)\n\n    kwargs.update(dict(\n        s=size ** 2,\n        edgecolor=edgecolor,\n        linewidth=linewidth)\n    )\n\n    p.plot_strips(\n        jitter=jitter,\n        dodge=dodge,\n        color=color,\n        edgecolor=edgecolor,\n        plot_kws=kwargs,\n    )\n\n    # XXX this happens inside a plotting method in the distribution plots\n    # but maybe it's better out here? Alternatively, we have an open issue\n    # suggesting that _attach could add default axes labels, which seems smart.\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.cat_axis)\n\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "stripplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "jitter", "true", "dodge", "false", "orient", "none", "color", "none", "palette", "none", "size", "5", "edgecolor", "gray", "linewidth", "0", "hue_norm", "none", "native_scale", "false", "formatter", "none", "legend", "auto", "ax", "none", "kwargs", "p", "_categoricalplotternew", "data", "data", "variables", "_categoricalplotternew", "get_semantics", "locals", "order", "order", "orient", "orient", "require_numeric", "false", "legend", "legend", "if", "ax", "is", "none", "ax", "plt", "gca", "if", "p", "var_types", "get", "p", "cat_axis", "categorical", "or", "not", "native_scale", "p", "scale_categorical", "p", "cat_axis", "order", "order", "formatter", "formatter", "p", "_attach", "ax", "hue_order", "p", "_palette_without_hue_backcompat", "palette", "hue_order", "palette", "hue_order", "p", "_hue_backcompat", "color", "palette", "hue_order", "color", "_default_color", "ax", "scatter", "hue", "color", "kwargs", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "xxx", "copying", "possibly", "bad", "default", "decisions", "from", "original", "code", "for", "now", "kwargs", "setdefault", "zorder", "3", "size", "kwargs", "get", "s", "size", "kwargs", "update", "dict", "s", "size", "2", "edgecolor", "edgecolor", "linewidth", "linewidth", "p", "plot_strips", "jitter", "jitter", "dodge", "dodge", "color", "color", "edgecolor", "edgecolor", "plot_kws", "kwargs", "xxx", "this", "happens", "inside", "a", "plotting", "method", "in", "the", "distribution", "plots", "but", "maybe", "it", "s", "better", "out", "here", "alternatively", "we", "have", "an", "open", "issue", "suggesting", "that", "_attach", "could", "add", "default", "axes", "labels", "which", "seems", "smart", "p", "_add_axis_labels", "ax", "p", "_adjust_cat_axis", "ax", "axis", "p", "cat_axis", "return", "ax"], "doc_len": 203}
{"doc_id": "seaborn/categorical.py::swarmplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "swarmplot", "text": "文件路径: seaborn/categorical.py\ndef swarmplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    dodge=False, orient=None, color=None, palette=None,\n    size=5, edgecolor=\"gray\", linewidth=0, hue_norm=None,\n    native_scale=False, formatter=None, legend=\"auto\", warn_thresh=.05,\n    ax=None, **kwargs\n):\n\n    p = _CategoricalPlotterNew(\n        data=data,\n        variables=_CategoricalPlotterNew.get_semantics(locals()),\n        order=order,\n        orient=orient,\n        require_numeric=False,\n        legend=legend,\n    )\n\n    if ax is None:\n        ax = plt.gca()\n\n    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:\n        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)\n\n    p._attach(ax)\n\n    if not p.has_xy_data:\n        return ax\n\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n\n    color = _default_color(ax.scatter, hue, color, kwargs)\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    # XXX Copying possibly bad default decisions from original code for now\n    kwargs.setdefault(\"zorder\", 3)\n    size = kwargs.get(\"s\", size)\n\n    if linewidth is None:\n        linewidth = size / 10\n\n    kwargs.update(dict(\n        s=size ** 2,\n        linewidth=linewidth,\n    ))\n\n    p.plot_swarms(\n        dodge=dodge,\n        color=color,\n        edgecolor=edgecolor,\n        warn_thresh=warn_thresh,\n        plot_kws=kwargs,\n    )\n\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.cat_axis)\n\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "swarmplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "dodge", "false", "orient", "none", "color", "none", "palette", "none", "size", "5", "edgecolor", "gray", "linewidth", "0", "hue_norm", "none", "native_scale", "false", "formatter", "none", "legend", "auto", "warn_thresh", "05", "ax", "none", "kwargs", "p", "_categoricalplotternew", "data", "data", "variables", "_categoricalplotternew", "get_semantics", "locals", "order", "order", "orient", "orient", "require_numeric", "false", "legend", "legend", "if", "ax", "is", "none", "ax", "plt", "gca", "if", "p", "var_types", "get", "p", "cat_axis", "categorical", "or", "not", "native_scale", "p", "scale_categorical", "p", "cat_axis", "order", "order", "formatter", "formatter", "p", "_attach", "ax", "if", "not", "p", "has_xy_data", "return", "ax", "hue_order", "p", "_palette_without_hue_backcompat", "palette", "hue_order", "palette", "hue_order", "p", "_hue_backcompat", "color", "palette", "hue_order", "color", "_default_color", "ax", "scatter", "hue", "color", "kwargs", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "xxx", "copying", "possibly", "bad", "default", "decisions", "from", "original", "code", "for", "now", "kwargs", "setdefault", "zorder", "3", "size", "kwargs", "get", "s", "size", "if", "linewidth", "is", "none", "linewidth", "size", "10", "kwargs", "update", "dict", "s", "size", "2", "linewidth", "linewidth", "p", "plot_swarms", "dodge", "dodge", "color", "color", "edgecolor", "edgecolor", "warn_thresh", "warn_thresh", "plot_kws", "kwargs", "p", "_add_axis_labels", "ax", "p", "_adjust_cat_axis", "ax", "axis", "p", "cat_axis", "return", "ax"], "doc_len": 179}
{"doc_id": "seaborn/categorical.py::barplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "barplot", "text": "文件路径: seaborn/categorical.py\ndef barplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    orient=None, color=None, palette=None, saturation=.75, width=.8,\n    errcolor=\".26\", errwidth=None, capsize=None, dodge=True, ci=\"deprecated\",\n    ax=None,\n    **kwargs,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    # Be backwards compatible with len passed directly, which\n    # does not work in Series.agg (maybe a pandas bug?)\n    if estimator is len:\n        estimator = \"size\"\n\n    plotter = _BarPlotter(x, y, hue, data, order, hue_order,\n                          estimator, errorbar, n_boot, units, seed,\n                          orient, color, palette, saturation,\n                          width, errcolor, errwidth, capsize, dodge)\n\n    if ax is None:\n        ax = plt.gca()\n\n    plotter.plot(ax, kwargs)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "barplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "estimator", "mean", "errorbar", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "orient", "none", "color", "none", "palette", "none", "saturation", "75", "width", "8", "errcolor", "26", "errwidth", "none", "capsize", "none", "dodge", "true", "ci", "deprecated", "ax", "none", "kwargs", "errorbar", "utils", "_deprecate_ci", "errorbar", "ci", "be", "backwards", "compatible", "with", "len", "passed", "directly", "which", "does", "not", "work", "in", "series", "agg", "maybe", "a", "pandas", "bug", "if", "estimator", "is", "len", "estimator", "size", "plotter", "_barplotter", "x", "y", "hue", "data", "order", "hue_order", "estimator", "errorbar", "n_boot", "units", "seed", "orient", "color", "palette", "saturation", "width", "errcolor", "errwidth", "capsize", "dodge", "if", "ax", "is", "none", "ax", "plt", "gca", "plotter", "plot", "ax", "kwargs", "return", "ax"], "doc_len": 115}
{"doc_id": "seaborn/categorical.py::pointplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "pointplot", "text": "文件路径: seaborn/categorical.py\ndef pointplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n    markers=\"o\", linestyles=\"-\", dodge=False, join=True, scale=1,\n    orient=None, color=None, palette=None, errwidth=None, ci=\"deprecated\",\n    capsize=None, label=None, ax=None,\n):\n\n    errorbar = utils._deprecate_ci(errorbar, ci)\n\n    plotter = _PointPlotter(x, y, hue, data, order, hue_order,\n                            estimator, errorbar, n_boot, units, seed,\n                            markers, linestyles, dodge, join, scale,\n                            orient, color, palette, errwidth, capsize, label)\n\n    if ax is None:\n        ax = plt.gca()\n\n    plotter.plot(ax)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "pointplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "estimator", "mean", "errorbar", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "markers", "o", "linestyles", "dodge", "false", "join", "true", "scale", "1", "orient", "none", "color", "none", "palette", "none", "errwidth", "none", "ci", "deprecated", "capsize", "none", "label", "none", "ax", "none", "errorbar", "utils", "_deprecate_ci", "errorbar", "ci", "plotter", "_pointplotter", "x", "y", "hue", "data", "order", "hue_order", "estimator", "errorbar", "n_boot", "units", "seed", "markers", "linestyles", "dodge", "join", "scale", "orient", "color", "palette", "errwidth", "capsize", "label", "if", "ax", "is", "none", "ax", "plt", "gca", "plotter", "plot", "ax", "return", "ax"], "doc_len": 94}
{"doc_id": "seaborn/categorical.py::countplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "countplot", "text": "文件路径: seaborn/categorical.py\ndef countplot(\n    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n    orient=None, color=None, palette=None, saturation=.75, width=.8,\n    dodge=True, ax=None, **kwargs\n):\n\n    estimator = \"size\"\n    errorbar = None\n    n_boot = 0\n    units = None\n    seed = None\n    errcolor = None\n    errwidth = None\n    capsize = None\n\n    if x is None and y is not None:\n        orient = \"h\"\n        x = y\n    elif y is None and x is not None:\n        orient = \"v\"\n        y = x\n    elif x is not None and y is not None:\n        raise ValueError(\"Cannot pass values for both `x` and `y`\")\n\n    plotter = _CountPlotter(\n        x, y, hue, data, order, hue_order,\n        estimator, errorbar, n_boot, units, seed,\n        orient, color, palette, saturation,\n        width, errcolor, errwidth, capsize, dodge\n    )\n\n    plotter.value_label = \"count\"\n\n    if ax is None:\n        ax = plt.gca()\n\n    plotter.plot(ax, kwargs)\n    return ax\n", "tokens": ["seaborn", "categorical", "py", "def", "countplot", "data", "none", "x", "none", "y", "none", "hue", "none", "order", "none", "hue_order", "none", "orient", "none", "color", "none", "palette", "none", "saturation", "75", "width", "8", "dodge", "true", "ax", "none", "kwargs", "estimator", "size", "errorbar", "none", "n_boot", "0", "units", "none", "seed", "none", "errcolor", "none", "errwidth", "none", "capsize", "none", "if", "x", "is", "none", "and", "y", "is", "not", "none", "orient", "h", "x", "y", "elif", "y", "is", "none", "and", "x", "is", "not", "none", "orient", "v", "y", "x", "elif", "x", "is", "not", "none", "and", "y", "is", "not", "none", "raise", "valueerror", "cannot", "pass", "values", "for", "both", "x", "and", "y", "plotter", "_countplotter", "x", "y", "hue", "data", "order", "hue_order", "estimator", "errorbar", "n_boot", "units", "seed", "orient", "color", "palette", "saturation", "width", "errcolor", "errwidth", "capsize", "dodge", "plotter", "value_label", "count", "if", "ax", "is", "none", "ax", "plt", "gca", "plotter", "plot", "ax", "kwargs", "return", "ax"], "doc_len": 132}
{"doc_id": "seaborn/categorical.py::catplot", "file_path": "seaborn/categorical.py", "class_name": null, "func_name": "catplot", "text": "文件路径: seaborn/categorical.py\ndef catplot(\n    data=None, *, x=None, y=None, hue=None, row=None, col=None,\n    col_wrap=None, estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000,\n    units=None, seed=None, order=None, hue_order=None, row_order=None,\n    col_order=None, height=5, aspect=1, kind=\"strip\", native_scale=False,\n    formatter=None, orient=None, color=None, palette=None, hue_norm=None,\n    legend=\"auto\", legend_out=True, sharex=True, sharey=True,\n    margin_titles=False, facet_kws=None, ci=\"deprecated\",\n    **kwargs\n):\n\n    # Determine the plotting function\n    try:\n        plot_func = globals()[kind + \"plot\"]\n    except KeyError:\n        err = f\"Plot kind '{kind}' is not recognized\"\n        raise ValueError(err)\n\n    # Check for attempt to plot onto specific axes and warn\n    if \"ax\" in kwargs:\n        msg = (\"catplot is a figure-level function and does not accept \"\n               f\"target axes. You may wish to try {kind}plot\")\n        warnings.warn(msg, UserWarning)\n        kwargs.pop(\"ax\")\n\n    refactored_kinds = [\"strip\", \"swarm\"]\n    if kind in refactored_kinds:\n\n        p = _CategoricalFacetPlotter(\n            data=data,\n            variables=_CategoricalFacetPlotter.get_semantics(locals()),\n            order=order,\n            orient=orient,\n            require_numeric=False,\n            legend=legend,\n        )\n\n        # XXX Copying a fair amount from displot, which is not ideal\n\n        for var in [\"row\", \"col\"]:\n            # Handle faceting variables that lack name information\n            if var in p.variables and p.variables[var] is None:\n                p.variables[var] = f\"_{var}_\"\n\n        # Adapt the plot_data dataframe for use with FacetGrid\n        data = p.plot_data.rename(columns=p.variables)\n        data = data.loc[:, ~data.columns.duplicated()]\n\n        col_name = p.variables.get(\"col\", None)\n        row_name = p.variables.get(\"row\", None)\n\n        if facet_kws is None:\n            facet_kws = {}\n\n        g = FacetGrid(\n            data=data, row=row_name, col=col_name,\n            col_wrap=col_wrap, row_order=row_order,\n            col_order=col_order, height=height,\n            sharex=sharex, sharey=sharey,\n            aspect=aspect,\n            **facet_kws,\n        )\n\n        # Capture this here because scale_categorical is going to insert a (null)\n        # x variable even if it is empty. It's not clear whether that needs to\n        # happen or if disabling that is the cleaner solution.\n        has_xy_data = p.has_xy_data\n\n        if not native_scale or p.var_types[p.cat_axis] == \"categorical\":\n            p.scale_categorical(p.cat_axis, order=order, formatter=formatter)\n\n        p._attach(g)\n\n        if not has_xy_data:\n            return g\n\n        hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n        palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n        p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n        # Set a default color\n        # Otherwise each artist will be plotted separately and trip the color cycle\n        if hue is None and color is None:\n            color = \"C0\"\n\n        if kind == \"strip\":\n\n            # TODO get these defaults programmatically?\n            jitter = kwargs.pop(\"jitter\", True)\n            dodge = kwargs.pop(\"dodge\", False)\n            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default\n\n            plot_kws = kwargs.copy()\n\n            # XXX Copying possibly bad default decisions from original code for now\n            plot_kws.setdefault(\"zorder\", 3)\n            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)\n            plot_kws.setdefault(\"linewidth\", 0)\n\n            p.plot_strips(\n                jitter=jitter,\n                dodge=dodge,\n                color=color,\n                edgecolor=edgecolor,\n                plot_kws=plot_kws,\n            )\n\n        elif kind == \"swarm\":\n\n            # TODO get these defaults programmatically?\n            dodge = kwargs.pop(\"dodge\", False)\n            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default\n            warn_thresh = kwargs.pop(\"warn_thresh\", .05)\n\n            plot_kws = kwargs.copy()\n\n            # XXX Copying possibly bad default decisions from original code for now\n            plot_kws.setdefault(\"zorder\", 3)\n            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)\n\n            if plot_kws.setdefault(\"linewidth\", 0) is None:\n                plot_kws[\"linewidth\"] = np.sqrt(plot_kws[\"s\"]) / 10\n\n            p.plot_swarms(\n                dodge=dodge,\n                color=color,\n                edgecolor=edgecolor,\n                warn_thresh=warn_thresh,\n                plot_kws=plot_kws,\n            )\n\n        # XXX best way to do this housekeeping?\n        for ax in g.axes.flat:\n            p._adjust_cat_axis(ax, axis=p.cat_axis)\n\n        g.set_axis_labels(\n            p.variables.get(\"x\", None),\n            p.variables.get(\"y\", None),\n        )\n        g.set_titles()\n        g.tight_layout()\n\n        # XXX Hack to get the legend data in the right place\n        for ax in g.axes.flat:\n            g._update_legend_data(ax)\n            ax.legend_ = None\n\n        if legend and (hue is not None) and (hue not in [x, row, col]):\n            g.add_legend(title=hue, label_order=hue_order)\n\n        return g\n\n    # Don't allow usage of forthcoming functionality\n    if native_scale is True:\n        err = f\"native_scale not yet implemented for `kind={kind}`\"\n        raise ValueError(err)\n    if formatter is not None:\n        err = f\"formatter not yet implemented for `kind={kind}`\"\n        raise ValueError(err)\n\n    # Alias the input variables to determine categorical order and palette\n    # correctly in the case of a count plot\n    if kind == \"count\":\n        if x is None and y is not None:\n            x_, y_, orient = y, y, \"h\"\n        elif y is None and x is not None:\n            x_, y_, orient = x, x, \"v\"\n        else:\n            raise ValueError(\"Either `x` or `y` must be None for kind='count'\")\n    else:\n        x_, y_ = x, y\n\n    # Determine the order for the whole dataset, which will be used in all\n    # facets to ensure representation of all data in the final plot\n    plotter_class = {\n        \"box\": _BoxPlotter,\n        \"violin\": _ViolinPlotter,\n        \"boxen\": _LVPlotter,\n        \"bar\": _BarPlotter,\n        \"point\": _PointPlotter,\n        \"count\": _CountPlotter,\n    }[kind]\n    p = _CategoricalPlotter()\n    p.require_numeric = plotter_class.require_numeric\n    p.establish_variables(x_, y_, hue, data, orient, order, hue_order)\n    if (\n        order is not None\n        or (sharex and p.orient == \"v\")\n        or (sharey and p.orient == \"h\")\n    ):\n        # Sync categorical axis between facets to have the same categories\n        order = p.group_names\n    elif color is None and hue is None:\n        msg = (\n            \"Setting `{}=False` with `color=None` may cause different levels of the \"\n            \"`{}` variable to share colors. This will change in a future version.\"\n        )\n        if not sharex and p.orient == \"v\":\n            warnings.warn(msg.format(\"sharex\", \"x\"), UserWarning)\n        if not sharey and p.orient == \"h\":\n            warnings.warn(msg.format(\"sharey\", \"y\"), UserWarning)\n\n    hue_order = p.hue_names\n\n    # Determine the palette to use\n    # (FacetGrid will pass a value for ``color`` to the plotting function\n    # so we need to define ``palette`` to get default behavior for the\n    # categorical functions\n    p.establish_colors(color, palette, 1)\n    if kind != \"point\" or hue is not None:\n        palette = p.colors\n\n    # Determine keyword arguments for the facets\n    facet_kws = {} if facet_kws is None else facet_kws\n    facet_kws.update(\n        data=data, row=row, col=col,\n        row_order=row_order, col_order=col_order,\n        col_wrap=col_wrap, height=height, aspect=aspect,\n        sharex=sharex, sharey=sharey,\n        legend_out=legend_out, margin_titles=margin_titles,\n        dropna=False,\n    )\n\n    # Determine keyword arguments for the plotting function\n    plot_kws = dict(\n        order=order, hue_order=hue_order,\n        orient=orient, color=color, palette=palette,\n    )\n    plot_kws.update(kwargs)\n\n    if kind in [\"bar\", \"point\"]:\n        errorbar = utils._deprecate_ci(errorbar, ci)\n        plot_kws.update(\n            estimator=estimator, errorbar=errorbar,\n            n_boot=n_boot, units=units, seed=seed,\n        )\n\n    # Initialize the facets\n    g = FacetGrid(**facet_kws)\n\n    # Draw the plot onto the facets\n    g.map_dataframe(plot_func, x=x, y=y, hue=hue, **plot_kws)\n\n    if p.orient == \"h\":\n        g.set_axis_labels(p.value_label, p.group_label)\n    else:\n        g.set_axis_labels(p.group_label, p.value_label)\n\n    # Special case axis labels for a count type plot\n    if kind == \"count\":\n        if x is None:\n            g.set_axis_labels(x_var=\"count\")\n        if y is None:\n            g.set_axis_labels(y_var=\"count\")\n\n    if legend and (hue is not None) and (hue not in [x, row, col]):\n        hue_order = list(map(utils.to_utf8, hue_order))\n        g.add_legend(title=hue, label_order=hue_order)\n\n    return g\n", "tokens": ["seaborn", "categorical", "py", "def", "catplot", "data", "none", "x", "none", "y", "none", "hue", "none", "row", "none", "col", "none", "col_wrap", "none", "estimator", "mean", "errorbar", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "order", "none", "hue_order", "none", "row_order", "none", "col_order", "none", "height", "5", "aspect", "1", "kind", "strip", "native_scale", "false", "formatter", "none", "orient", "none", "color", "none", "palette", "none", "hue_norm", "none", "legend", "auto", "legend_out", "true", "sharex", "true", "sharey", "true", "margin_titles", "false", "facet_kws", "none", "ci", "deprecated", "kwargs", "determine", "the", "plotting", "function", "try", "plot_func", "globals", "kind", "plot", "except", "keyerror", "err", "f", "plot", "kind", "kind", "is", "not", "recognized", "raise", "valueerror", "err", "check", "for", "attempt", "to", "plot", "onto", "specific", "axes", "and", "warn", "if", "ax", "in", "kwargs", "msg", "catplot", "is", "a", "figure", "level", "function", "and", "does", "not", "accept", "f", "target", "axes", "you", "may", "wish", "to", "try", "kind", "plot", "warnings", "warn", "msg", "userwarning", "kwargs", "pop", "ax", "refactored_kinds", "strip", "swarm", "if", "kind", "in", "refactored_kinds", "p", "_categoricalfacetplotter", "data", "data", "variables", "_categoricalfacetplotter", "get_semantics", "locals", "order", "order", "orient", "orient", "require_numeric", "false", "legend", "legend", "xxx", "copying", "a", "fair", "amount", "from", "displot", "which", "is", "not", "ideal", "for", "var", "in", "row", "col", "handle", "faceting", "variables", "that", "lack", "name", "information", "if", "var", "in", "p", "variables", "and", "p", "variables", "var", "is", "none", "p", "variables", "var", "f", "_", "var", "_", "adapt", "the", "plot_data", "dataframe", "for", "use", "with", "facetgrid", "data", "p", "plot_data", "rename", "columns", "p", "variables", "data", "data", "loc", "data", "columns", "duplicated", "col_name", "p", "variables", "get", "col", "none", "row_name", "p", "variables", "get", "row", "none", "if", "facet_kws", "is", "none", "facet_kws", "g", "facetgrid", "data", "data", "row", "row_name", "col", "col_name", "col_wrap", "col_wrap", "row_order", "row_order", "col_order", "col_order", "height", "height", "sharex", "sharex", "sharey", "sharey", "aspect", "aspect", "facet_kws", "capture", "this", "here", "because", "scale_categorical", "is", "going", "to", "insert", "a", "null", "x", "variable", "even", "if", "it", "is", "empty", "it", "s", "not", "clear", "whether", "that", "needs", "to", "happen", "or", "if", "disabling", "that", "is", "the", "cleaner", "solution", "has_xy_data", "p", "has_xy_data", "if", "not", "native_scale", "or", "p", "var_types", "p", "cat_axis", "categorical", "p", "scale_categorical", "p", "cat_axis", "order", "order", "formatter", "formatter", "p", "_attach", "g", "if", "not", "has_xy_data", "return", "g", "hue_order", "p", "_palette_without_hue_backcompat", "palette", "hue_order", "palette", "hue_order", "p", "_hue_backcompat", "color", "palette", "hue_order", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "set", "a", "default", "color", "otherwise", "each", "artist", "will", "be", "plotted", "separately", "and", "trip", "the", "color", "cycle", "if", "hue", "is", "none", "and", "color", "is", "none", "color", "c0", "if", "kind", "strip", "todo", "get", "these", "defaults", "programmatically", "jitter", "kwargs", "pop", "jitter", "true", "dodge", "kwargs", "pop", "dodge", "false", "edgecolor", "kwargs", "pop", "edgecolor", "gray", "xxx", "todo", "default", "plot_kws", "kwargs", "copy", "xxx", "copying", "possibly", "bad", "default", "decisions", "from", "original", "code", "for", "now", "plot_kws", "setdefault", "zorder", "3", "plot_kws", "setdefault", "s", "plot_kws", "pop", "size", "5", "2", "plot_kws", "setdefault", "linewidth", "0", "p", "plot_strips", "jitter", "jitter", "dodge", "dodge", "color", "color", "edgecolor", "edgecolor", "plot_kws", "plot_kws", "elif", "kind", "swarm", "todo", "get", "these", "defaults", "programmatically", "dodge", "kwargs", "pop", "dodge", "false", "edgecolor", "kwargs", "pop", "edgecolor", "gray", "xxx", "todo", "default", "warn_thresh", "kwargs", "pop", "warn_thresh", "05", "plot_kws", "kwargs", "copy", "xxx", "copying", "possibly", "bad", "default", "decisions", "from", "original", "code", "for", "now", "plot_kws", "setdefault", "zorder", "3", "plot_kws", "setdefault", "s", "plot_kws", "pop", "size", "5", "2", "if", "plot_kws", "setdefault", "linewidth", "0", "is", "none", "plot_kws", "linewidth", "np", "sqrt", "plot_kws", "s", "10", "p", "plot_swarms", "dodge", "dodge", "color", "color", "edgecolor", "edgecolor", "warn_thresh", "warn_thresh", "plot_kws", "plot_kws", "xxx", "best", "way", "to", "do", "this", "housekeeping", "for", "ax", "in", "g", "axes", "flat", "p", "_adjust_cat_axis", "ax", "axis", "p", "cat_axis", "g", "set_axis_labels", "p", "variables", "get", "x", "none", "p", "variables", "get", "y", "none", "g", "set_titles", "g", "tight_layout", "xxx", "hack", "to", "get", "the", "legend", "data", "in", "the", "right", "place", "for", "ax", "in", "g", "axes", "flat", "g", "_update_legend_data", "ax", "ax", "legend_", "none", "if", "legend", "and", "hue", "is", "not", "none", "and", "hue", "not", "in", "x", "row", "col", "g", "add_legend", "title", "hue", "label_order", "hue_order", "return", "g", "don", "t", "allow", "usage", "of", "forthcoming", "functionality", "if", "native_scale", "is", "true", "err", "f", "native_scale", "not", "yet", "implemented", "for", "kind", "kind", "raise", "valueerror", "err", "if", "formatter", "is", "not", "none", "err", "f", "formatter", "not", "yet", "implemented", "for", "kind", "kind", "raise", "valueerror", "err", "alias", "the", "input", "variables", "to", "determine", "categorical", "order", "and", "palette", "correctly", "in", "the", "case", "of", "a", "count", "plot", "if", "kind", "count", "if", "x", "is", "none", "and", "y", "is", "not", "none", "x_", "y_", "orient", "y", "y", "h", "elif", "y", "is", "none", "and", "x", "is", "not", "none", "x_", "y_", "orient", "x", "x", "v", "else", "raise", "valueerror", "either", "x", "or", "y", "must", "be", "none", "for", "kind", "count", "else", "x_", "y_", "x", "y", "determine", "the", "order", "for", "the", "whole", "dataset", "which", "will", "be", "used", "in", "all", "facets", "to", "ensure", "representation", "of", "all", "data", "in", "the", "final", "plot", "plotter_class", "box", "_boxplotter", "violin", "_violinplotter", "boxen", "_lvplotter", "bar", "_barplotter", "point", "_pointplotter", "count", "_countplotter", "kind", "p", "_categoricalplotter", "p", "require_numeric", "plotter_class", "require_numeric", "p", "establish_variables", "x_", "y_", "hue", "data", "orient", "order", "hue_order", "if", "order", "is", "not", "none", "or", "sharex", "and", "p", "orient", "v", "or", "sharey", "and", "p", "orient", "h", "sync", "categorical", "axis", "between", "facets", "to", "have", "the", "same", "categories", "order", "p", "group_names", "elif", "color", "is", "none", "and", "hue", "is", "none", "msg", "setting", "false", "with", "color", "none", "may", "cause", "different", "levels", "of", "the", "variable", "to", "share", "colors", "this", "will", "change", "in", "a", "future", "version", "if", "not", "sharex", "and", "p", "orient", "v", "warnings", "warn", "msg", "format", "sharex", "x", "userwarning", "if", "not", "sharey", "and", "p", "orient", "h", "warnings", "warn", "msg", "format", "sharey", "y", "userwarning", "hue_order", "p", "hue_names", "determine", "the", "palette", "to", "use", "facetgrid", "will", "pass", "a", "value", "for", "color", "to", "the", "plotting", "function", "so", "we", "need", "to", "define", "palette", "to", "get", "default", "behavior", "for", "the", "categorical", "functions", "p", "establish_colors", "color", "palette", "1", "if", "kind", "point", "or", "hue", "is", "not", "none", "palette", "p", "colors", "determine", "keyword", "arguments", "for", "the", "facets", "facet_kws", "if", "facet_kws", "is", "none", "else", "facet_kws", "facet_kws", "update", "data", "data", "row", "row", "col", "col", "row_order", "row_order", "col_order", "col_order", "col_wrap", "col_wrap", "height", "height", "aspect", "aspect", "sharex", "sharex", "sharey", "sharey", "legend_out", "legend_out", "margin_titles", "margin_titles", "dropna", "false", "determine", "keyword", "arguments", "for", "the", "plotting", "function", "plot_kws", "dict", "order", "order", "hue_order", "hue_order", "orient", "orient", "color", "color", "palette", "palette", "plot_kws", "update", "kwargs", "if", "kind", "in", "bar", "point", "errorbar", "utils", "_deprecate_ci", "errorbar", "ci", "plot_kws", "update", "estimator", "estimator", "errorbar", "errorbar", "n_boot", "n_boot", "units", "units", "seed", "seed", "initialize", "the", "facets", "g", "facetgrid", "facet_kws", "draw", "the", "plot", "onto", "the", "facets", "g", "map_dataframe", "plot_func", "x", "x", "y", "y", "hue", "hue", "plot_kws", "if", "p", "orient", "h", "g", "set_axis_labels", "p", "value_label", "p", "group_label", "else", "g", "set_axis_labels", "p", "group_label", "p", "value_label", "special", "case", "axis", "labels", "for", "a", "count", "type", "plot", "if", "kind", "count", "if", "x", "is", "none", "g", "set_axis_labels", "x_var", "count", "if", "y", "is", "none", "g", "set_axis_labels", "y_var", "count", "if", "legend", "and", "hue", "is", "not", "none", "and", "hue", "not", "in", "x", "row", "col", "hue_order", "list", "map", "utils", "to_utf8", "hue_order", "g", "add_legend", "title", "hue", "label_order", "hue_order", "return", "g"], "doc_len": 1075}
{"doc_id": "seaborn/categorical.py::Beeswarm.__init__", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "__init__", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def __init__(self, orient=\"v\", width=0.8, warn_thresh=.05):\n\n        # XXX should we keep the orient parameterization or specify the swarm axis?\n\n        self.orient = orient\n        self.width = width\n        self.warn_thresh = warn_thresh\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "__init__", "self", "orient", "v", "width", "0", "8", "warn_thresh", "05", "xxx", "should", "we", "keep", "the", "orient", "parameterization", "or", "specify", "the", "swarm", "axis", "self", "orient", "orient", "self", "width", "width", "self", "warn_thresh", "warn_thresh"], "doc_len": 35}
{"doc_id": "seaborn/categorical.py::Beeswarm.__call__", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "__call__", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def __call__(self, points, center):\n        \"\"\"Swarm `points`, a PathCollection, around the `center` position.\"\"\"\n        # Convert from point size (area) to diameter\n\n        ax = points.axes\n        dpi = ax.figure.dpi\n\n        # Get the original positions of the points\n        orig_xy_data = points.get_offsets()\n\n        # Reset the categorical positions to the center line\n        cat_idx = 1 if self.orient == \"h\" else 0\n        orig_xy_data[:, cat_idx] = center\n\n        # Transform the data coordinates to point coordinates.\n        # We'll figure out the swarm positions in the latter\n        # and then convert back to data coordinates and replot\n        orig_x_data, orig_y_data = orig_xy_data.T\n        orig_xy = ax.transData.transform(orig_xy_data)\n\n        # Order the variables so that x is the categorical axis\n        if self.orient == \"h\":\n            orig_xy = orig_xy[:, [1, 0]]\n\n        # Add a column with each point's radius\n        sizes = points.get_sizes()\n        if sizes.size == 1:\n            sizes = np.repeat(sizes, orig_xy.shape[0])\n        edge = points.get_linewidth().item()\n        radii = (np.sqrt(sizes) + edge) / 2 * (dpi / 72)\n        orig_xy = np.c_[orig_xy, radii]\n\n        # Sort along the value axis to facilitate the beeswarm\n        sorter = np.argsort(orig_xy[:, 1])\n        orig_xyr = orig_xy[sorter]\n\n        # Adjust points along the categorical axis to prevent overlaps\n        new_xyr = np.empty_like(orig_xyr)\n        new_xyr[sorter] = self.beeswarm(orig_xyr)\n\n        # Transform the point coordinates back to data coordinates\n        if self.orient == \"h\":\n            new_xy = new_xyr[:, [1, 0]]\n        else:\n            new_xy = new_xyr[:, :2]\n        new_x_data, new_y_data = ax.transData.inverted().transform(new_xy).T\n\n        swarm_axis = {\"h\": \"y\", \"v\": \"x\"}[self.orient]\n        log_scale = getattr(ax, f\"get_{swarm_axis}scale\")() == \"log\"\n\n        # Add gutters\n        if self.orient == \"h\":\n            self.add_gutters(new_y_data, center, log_scale=log_scale)\n        else:\n            self.add_gutters(new_x_data, center, log_scale=log_scale)\n\n        # Reposition the points so they do not overlap\n        if self.orient == \"h\":\n            points.set_offsets(np.c_[orig_x_data, new_y_data])\n        else:\n            points.set_offsets(np.c_[new_x_data, orig_y_data])\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "__call__", "self", "points", "center", "swarm", "points", "a", "pathcollection", "around", "the", "center", "position", "convert", "from", "point", "size", "area", "to", "diameter", "ax", "points", "axes", "dpi", "ax", "figure", "dpi", "get", "the", "original", "positions", "of", "the", "points", "orig_xy_data", "points", "get_offsets", "reset", "the", "categorical", "positions", "to", "the", "center", "line", "cat_idx", "1", "if", "self", "orient", "h", "else", "0", "orig_xy_data", "cat_idx", "center", "transform", "the", "data", "coordinates", "to", "point", "coordinates", "we", "ll", "figure", "out", "the", "swarm", "positions", "in", "the", "latter", "and", "then", "convert", "back", "to", "data", "coordinates", "and", "replot", "orig_x_data", "orig_y_data", "orig_xy_data", "t", "orig_xy", "ax", "transdata", "transform", "orig_xy_data", "order", "the", "variables", "so", "that", "x", "is", "the", "categorical", "axis", "if", "self", "orient", "h", "orig_xy", "orig_xy", "1", "0", "add", "a", "column", "with", "each", "point", "s", "radius", "sizes", "points", "get_sizes", "if", "sizes", "size", "1", "sizes", "np", "repeat", "sizes", "orig_xy", "shape", "0", "edge", "points", "get_linewidth", "item", "radii", "np", "sqrt", "sizes", "edge", "2", "dpi", "72", "orig_xy", "np", "c_", "orig_xy", "radii", "sort", "along", "the", "value", "axis", "to", "facilitate", "the", "beeswarm", "sorter", "np", "argsort", "orig_xy", "1", "orig_xyr", "orig_xy", "sorter", "adjust", "points", "along", "the", "categorical", "axis", "to", "prevent", "overlaps", "new_xyr", "np", "empty_like", "orig_xyr", "new_xyr", "sorter", "self", "beeswarm", "orig_xyr", "transform", "the", "point", "coordinates", "back", "to", "data", "coordinates", "if", "self", "orient", "h", "new_xy", "new_xyr", "1", "0", "else", "new_xy", "new_xyr", "2", "new_x_data", "new_y_data", "ax", "transdata", "inverted", "transform", "new_xy", "t", "swarm_axis", "h", "y", "v", "x", "self", "orient", "log_scale", "getattr", "ax", "f", "get_", "swarm_axis", "scale", "log", "add", "gutters", "if", "self", "orient", "h", "self", "add_gutters", "new_y_data", "center", "log_scale", "log_scale", "else", "self", "add_gutters", "new_x_data", "center", "log_scale", "log_scale", "reposition", "the", "points", "so", "they", "do", "not", "overlap", "if", "self", "orient", "h", "points", "set_offsets", "np", "c_", "orig_x_data", "new_y_data", "else", "points", "set_offsets", "np", "c_", "new_x_data", "orig_y_data"], "doc_len": 274}
{"doc_id": "seaborn/categorical.py::Beeswarm.beeswarm", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "beeswarm", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def beeswarm(self, orig_xyr):\n        \"\"\"Adjust x position of points to avoid overlaps.\"\"\"\n        # In this method, `x` is always the categorical axis\n        # Center of the swarm, in point coordinates\n        midline = orig_xyr[0, 0]\n\n        # Start the swarm with the first point\n        swarm = np.atleast_2d(orig_xyr[0])\n\n        # Loop over the remaining points\n        for xyr_i in orig_xyr[1:]:\n\n            # Find the points in the swarm that could possibly\n            # overlap with the point we are currently placing\n            neighbors = self.could_overlap(xyr_i, swarm)\n\n            # Find positions that would be valid individually\n            # with respect to each of the swarm neighbors\n            candidates = self.position_candidates(xyr_i, neighbors)\n\n            # Sort candidates by their centrality\n            offsets = np.abs(candidates[:, 0] - midline)\n            candidates = candidates[np.argsort(offsets)]\n\n            # Find the first candidate that does not overlap any neighbors\n            new_xyr_i = self.first_non_overlapping_candidate(candidates, neighbors)\n\n            # Place it into the swarm\n            swarm = np.vstack([swarm, new_xyr_i])\n\n        return swarm\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "beeswarm", "self", "orig_xyr", "adjust", "x", "position", "of", "points", "to", "avoid", "overlaps", "in", "this", "method", "x", "is", "always", "the", "categorical", "axis", "center", "of", "the", "swarm", "in", "point", "coordinates", "midline", "orig_xyr", "0", "0", "start", "the", "swarm", "with", "the", "first", "point", "swarm", "np", "atleast_2d", "orig_xyr", "0", "loop", "over", "the", "remaining", "points", "for", "xyr_i", "in", "orig_xyr", "1", "find", "the", "points", "in", "the", "swarm", "that", "could", "possibly", "overlap", "with", "the", "point", "we", "are", "currently", "placing", "neighbors", "self", "could_overlap", "xyr_i", "swarm", "find", "positions", "that", "would", "be", "valid", "individually", "with", "respect", "to", "each", "of", "the", "swarm", "neighbors", "candidates", "self", "position_candidates", "xyr_i", "neighbors", "sort", "candidates", "by", "their", "centrality", "offsets", "np", "abs", "candidates", "0", "midline", "candidates", "candidates", "np", "argsort", "offsets", "find", "the", "first", "candidate", "that", "does", "not", "overlap", "any", "neighbors", "new_xyr_i", "self", "first_non_overlapping_candidate", "candidates", "neighbors", "place", "it", "into", "the", "swarm", "swarm", "np", "vstack", "swarm", "new_xyr_i", "return", "swarm"], "doc_len": 143}
{"doc_id": "seaborn/categorical.py::Beeswarm.could_overlap", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "could_overlap", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def could_overlap(self, xyr_i, swarm):\n        \"\"\"Return a list of all swarm points that could overlap with target.\"\"\"\n        # Because we work backwards through the swarm and can short-circuit,\n        # the for-loop is faster than vectorization\n        _, y_i, r_i = xyr_i\n        neighbors = []\n        for xyr_j in reversed(swarm):\n            _, y_j, r_j = xyr_j\n            if (y_i - y_j) < (r_i + r_j):\n                neighbors.append(xyr_j)\n            else:\n                break\n        return np.array(neighbors)[::-1]\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "could_overlap", "self", "xyr_i", "swarm", "return", "a", "list", "of", "all", "swarm", "points", "that", "could", "overlap", "with", "target", "because", "we", "work", "backwards", "through", "the", "swarm", "and", "can", "short", "circuit", "the", "for", "loop", "is", "faster", "than", "vectorization", "_", "y_i", "r_i", "xyr_i", "neighbors", "for", "xyr_j", "in", "reversed", "swarm", "_", "y_j", "r_j", "xyr_j", "if", "y_i", "y_j", "r_i", "r_j", "neighbors", "append", "xyr_j", "else", "break", "return", "np", "array", "neighbors", "1"], "doc_len": 68}
{"doc_id": "seaborn/categorical.py::Beeswarm.position_candidates", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "position_candidates", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def position_candidates(self, xyr_i, neighbors):\n        \"\"\"Return a list of coordinates that might be valid by adjusting x.\"\"\"\n        candidates = [xyr_i]\n        x_i, y_i, r_i = xyr_i\n        left_first = True\n        for x_j, y_j, r_j in neighbors:\n            dy = y_i - y_j\n            dx = np.sqrt(max((r_i + r_j) ** 2 - dy ** 2, 0)) * 1.05\n            cl, cr = (x_j - dx, y_i, r_i), (x_j + dx, y_i, r_i)\n            if left_first:\n                new_candidates = [cl, cr]\n            else:\n                new_candidates = [cr, cl]\n            candidates.extend(new_candidates)\n            left_first = not left_first\n        return np.array(candidates)\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "position_candidates", "self", "xyr_i", "neighbors", "return", "a", "list", "of", "coordinates", "that", "might", "be", "valid", "by", "adjusting", "x", "candidates", "xyr_i", "x_i", "y_i", "r_i", "xyr_i", "left_first", "true", "for", "x_j", "y_j", "r_j", "in", "neighbors", "dy", "y_i", "y_j", "dx", "np", "sqrt", "max", "r_i", "r_j", "2", "dy", "2", "0", "1", "05", "cl", "cr", "x_j", "dx", "y_i", "r_i", "x_j", "dx", "y_i", "r_i", "if", "left_first", "new_candidates", "cl", "cr", "else", "new_candidates", "cr", "cl", "candidates", "extend", "new_candidates", "left_first", "not", "left_first", "return", "np", "array", "candidates"], "doc_len": 79}
{"doc_id": "seaborn/categorical.py::Beeswarm.first_non_overlapping_candidate", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "first_non_overlapping_candidate", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def first_non_overlapping_candidate(self, candidates, neighbors):\n        \"\"\"Find the first candidate that does not overlap with the swarm.\"\"\"\n\n        # If we have no neighbors, all candidates are good.\n        if len(neighbors) == 0:\n            return candidates[0]\n\n        neighbors_x = neighbors[:, 0]\n        neighbors_y = neighbors[:, 1]\n        neighbors_r = neighbors[:, 2]\n\n        for xyr_i in candidates:\n\n            x_i, y_i, r_i = xyr_i\n\n            dx = neighbors_x - x_i\n            dy = neighbors_y - y_i\n            sq_distances = np.square(dx) + np.square(dy)\n\n            sep_needed = np.square(neighbors_r + r_i)\n\n            # Good candidate does not overlap any of neighbors which means that\n            # squared distance between candidate and any of the neighbors has\n            # to be at least square of the summed radii\n            good_candidate = np.all(sq_distances >= sep_needed)\n\n            if good_candidate:\n                return xyr_i\n\n        raise RuntimeError(\n            \"No non-overlapping candidates found. This should not happen.\"\n        )\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "first_non_overlapping_candidate", "self", "candidates", "neighbors", "find", "the", "first", "candidate", "that", "does", "not", "overlap", "with", "the", "swarm", "if", "we", "have", "no", "neighbors", "all", "candidates", "are", "good", "if", "len", "neighbors", "0", "return", "candidates", "0", "neighbors_x", "neighbors", "0", "neighbors_y", "neighbors", "1", "neighbors_r", "neighbors", "2", "for", "xyr_i", "in", "candidates", "x_i", "y_i", "r_i", "xyr_i", "dx", "neighbors_x", "x_i", "dy", "neighbors_y", "y_i", "sq_distances", "np", "square", "dx", "np", "square", "dy", "sep_needed", "np", "square", "neighbors_r", "r_i", "good", "candidate", "does", "not", "overlap", "any", "of", "neighbors", "which", "means", "that", "squared", "distance", "between", "candidate", "and", "any", "of", "the", "neighbors", "has", "to", "be", "at", "least", "square", "of", "the", "summed", "radii", "good_candidate", "np", "all", "sq_distances", "sep_needed", "if", "good_candidate", "return", "xyr_i", "raise", "runtimeerror", "no", "non", "overlapping", "candidates", "found", "this", "should", "not", "happen"], "doc_len": 121}
{"doc_id": "seaborn/categorical.py::Beeswarm.add_gutters", "file_path": "seaborn/categorical.py", "class_name": "Beeswarm", "func_name": "add_gutters", "text": "文件路径: seaborn/categorical.py, 类名: Beeswarm\n    def add_gutters(self, points, center, log_scale=False):\n        \"\"\"Stop points from extending beyond their territory.\"\"\"\n        half_width = self.width / 2\n        if log_scale:\n            low_gutter = 10 ** (np.log10(center) - half_width)\n        else:\n            low_gutter = center - half_width\n        off_low = points < low_gutter\n        if off_low.any():\n            points[off_low] = low_gutter\n        if log_scale:\n            high_gutter = 10 ** (np.log10(center) + half_width)\n        else:\n            high_gutter = center + half_width\n        off_high = points > high_gutter\n        if off_high.any():\n            points[off_high] = high_gutter\n\n        gutter_prop = (off_high + off_low).sum() / len(points)\n        if gutter_prop > self.warn_thresh:\n            msg = (\n                \"{:.1%} of the points cannot be placed; you may want \"\n                \"to decrease the size of the markers or use stripplot.\"\n            ).format(gutter_prop)\n            warnings.warn(msg, UserWarning)\n\n        return points\n", "tokens": ["seaborn", "categorical", "py", "beeswarm", "def", "add_gutters", "self", "points", "center", "log_scale", "false", "stop", "points", "from", "extending", "beyond", "their", "territory", "half_width", "self", "width", "2", "if", "log_scale", "low_gutter", "10", "np", "log10", "center", "half_width", "else", "low_gutter", "center", "half_width", "off_low", "points", "low_gutter", "if", "off_low", "any", "points", "off_low", "low_gutter", "if", "log_scale", "high_gutter", "10", "np", "log10", "center", "half_width", "else", "high_gutter", "center", "half_width", "off_high", "points", "high_gutter", "if", "off_high", "any", "points", "off_high", "high_gutter", "gutter_prop", "off_high", "off_low", "sum", "len", "points", "if", "gutter_prop", "self", "warn_thresh", "msg", "1", "of", "the", "points", "cannot", "be", "placed", "you", "may", "want", "to", "decrease", "the", "size", "of", "the", "markers", "or", "use", "stripplot", "format", "gutter_prop", "warnings", "warn", "msg", "userwarning", "return", "points"], "doc_len": 103}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.__init__", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "__init__", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def __init__(\n        self,\n        data=None,\n        variables={},\n    ):\n\n        super().__init__(data=data, variables=variables)\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "__init__", "self", "data", "none", "variables", "super", "__init__", "data", "data", "variables", "variables"], "doc_len": 16}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.univariate", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "univariate", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def univariate(self):\n        \"\"\"Return True if only x or y are used.\"\"\"\n        # TODO this could go down to core, but putting it here now.\n        # We'd want to be conceptually clear that univariate only applies\n        # to x/y and not to other semantics, which can exist.\n        # We haven't settled on a good conceptual name for x/y.\n        return bool({\"x\", \"y\"} - set(self.variables))\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "univariate", "self", "return", "true", "if", "only", "x", "or", "y", "are", "used", "todo", "this", "could", "go", "down", "to", "core", "but", "putting", "it", "here", "now", "we", "d", "want", "to", "be", "conceptually", "clear", "that", "univariate", "only", "applies", "to", "x", "y", "and", "not", "to", "other", "semantics", "which", "can", "exist", "we", "haven", "t", "settled", "on", "a", "good", "conceptual", "name", "for", "x", "y", "return", "bool", "x", "y", "set", "self", "variables"], "doc_len": 69}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.data_variable", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "data_variable", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def data_variable(self):\n        \"\"\"Return the variable with data for univariate plots.\"\"\"\n        # TODO This could also be in core, but it should have a better name.\n        if not self.univariate:\n            raise AttributeError(\"This is not a univariate plot\")\n        return {\"x\", \"y\"}.intersection(self.variables).pop()\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "data_variable", "self", "return", "the", "variable", "with", "data", "for", "univariate", "plots", "todo", "this", "could", "also", "be", "in", "core", "but", "it", "should", "have", "a", "better", "name", "if", "not", "self", "univariate", "raise", "attributeerror", "this", "is", "not", "a", "univariate", "plot", "return", "x", "y", "intersection", "self", "variables", "pop"], "doc_len": 48}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.has_xy_data", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "has_xy_data", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def has_xy_data(self):\n        \"\"\"Return True at least one of x or y is defined.\"\"\"\n        # TODO see above points about where this should go\n        return bool({\"x\", \"y\"} & set(self.variables))\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "has_xy_data", "self", "return", "true", "at", "least", "one", "of", "x", "or", "y", "is", "defined", "todo", "see", "above", "points", "about", "where", "this", "should", "go", "return", "bool", "x", "y", "set", "self", "variables"], "doc_len": 34}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._add_legend", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_add_legend", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _add_legend(\n        self,\n        ax_obj, artist, fill, element, multiple, alpha, artist_kws, legend_kws,\n    ):\n        \"\"\"Add artists that reflect semantic mappings and put then in a legend.\"\"\"\n        # TODO note that this doesn't handle numeric mappings like the relational plots\n        handles = []\n        labels = []\n        for level in self._hue_map.levels:\n            color = self._hue_map(level)\n\n            kws = self._artist_kws(\n                artist_kws, fill, element, multiple, color, alpha\n            )\n\n            # color gets added to the kws to workaround an issue with barplot's color\n            # cycle integration but it causes problems in this context where we are\n            # setting artist properties directly, so pop it off here\n            if \"facecolor\" in kws:\n                kws.pop(\"color\", None)\n\n            handles.append(artist(**kws))\n            labels.append(level)\n\n        if isinstance(ax_obj, mpl.axes.Axes):\n            ax_obj.legend(handles, labels, title=self.variables[\"hue\"], **legend_kws)\n        else:  # i.e. a FacetGrid. TODO make this better\n            legend_data = dict(zip(labels, handles))\n            ax_obj.add_legend(\n                legend_data,\n                title=self.variables[\"hue\"],\n                label_order=self.var_levels[\"hue\"],\n                **legend_kws\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_add_legend", "self", "ax_obj", "artist", "fill", "element", "multiple", "alpha", "artist_kws", "legend_kws", "add", "artists", "that", "reflect", "semantic", "mappings", "and", "put", "then", "in", "a", "legend", "todo", "note", "that", "this", "doesn", "t", "handle", "numeric", "mappings", "like", "the", "relational", "plots", "handles", "labels", "for", "level", "in", "self", "_hue_map", "levels", "color", "self", "_hue_map", "level", "kws", "self", "_artist_kws", "artist_kws", "fill", "element", "multiple", "color", "alpha", "color", "gets", "added", "to", "the", "kws", "to", "workaround", "an", "issue", "with", "barplot", "s", "color", "cycle", "integration", "but", "it", "causes", "problems", "in", "this", "context", "where", "we", "are", "setting", "artist", "properties", "directly", "so", "pop", "it", "off", "here", "if", "facecolor", "in", "kws", "kws", "pop", "color", "none", "handles", "append", "artist", "kws", "labels", "append", "level", "if", "isinstance", "ax_obj", "mpl", "axes", "axes", "ax_obj", "legend", "handles", "labels", "title", "self", "variables", "hue", "legend_kws", "else", "i", "e", "a", "facetgrid", "todo", "make", "this", "better", "legend_data", "dict", "zip", "labels", "handles", "ax_obj", "add_legend", "legend_data", "title", "self", "variables", "hue", "label_order", "self", "var_levels", "hue", "legend_kws"], "doc_len": 152}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._artist_kws", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_artist_kws", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _artist_kws(self, kws, fill, element, multiple, color, alpha):\n        \"\"\"Handle differences between artists in filled/unfilled plots.\"\"\"\n        kws = kws.copy()\n        if fill:\n            kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)\n            kws.setdefault(\"facecolor\", to_rgba(color, alpha))\n\n            if element == \"bars\":\n                # Make bar() interface with property cycle correctly\n                # https://github.com/matplotlib/matplotlib/issues/19385\n                kws[\"color\"] = \"none\"\n\n            if multiple in [\"stack\", \"fill\"] or element == \"bars\":\n                kws.setdefault(\"edgecolor\", mpl.rcParams[\"patch.edgecolor\"])\n            else:\n                kws.setdefault(\"edgecolor\", to_rgba(color, 1))\n        elif element == \"bars\":\n            kws[\"facecolor\"] = \"none\"\n            kws[\"edgecolor\"] = to_rgba(color, alpha)\n        else:\n            kws[\"color\"] = to_rgba(color, alpha)\n        return kws\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_artist_kws", "self", "kws", "fill", "element", "multiple", "color", "alpha", "handle", "differences", "between", "artists", "in", "filled", "unfilled", "plots", "kws", "kws", "copy", "if", "fill", "kws", "_normalize_kwargs", "kws", "mpl", "collections", "polycollection", "kws", "setdefault", "facecolor", "to_rgba", "color", "alpha", "if", "element", "bars", "make", "bar", "interface", "with", "property", "cycle", "correctly", "https", "github", "com", "matplotlib", "matplotlib", "issues", "19385", "kws", "color", "none", "if", "multiple", "in", "stack", "fill", "or", "element", "bars", "kws", "setdefault", "edgecolor", "mpl", "rcparams", "patch", "edgecolor", "else", "kws", "setdefault", "edgecolor", "to_rgba", "color", "1", "elif", "element", "bars", "kws", "facecolor", "none", "kws", "edgecolor", "to_rgba", "color", "alpha", "else", "kws", "color", "to_rgba", "color", "alpha", "return", "kws"], "doc_len": 99}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._quantile_to_level", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_quantile_to_level", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _quantile_to_level(self, data, quantile):\n        \"\"\"Return data levels corresponding to quantile cuts of mass.\"\"\"\n        isoprop = np.asarray(quantile)\n        values = np.ravel(data)\n        sorted_values = np.sort(values)[::-1]\n        normalized_values = np.cumsum(sorted_values) / values.sum()\n        idx = np.searchsorted(normalized_values, 1 - isoprop)\n        levels = np.take(sorted_values, idx, mode=\"clip\")\n        return levels\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_quantile_to_level", "self", "data", "quantile", "return", "data", "levels", "corresponding", "to", "quantile", "cuts", "of", "mass", "isoprop", "np", "asarray", "quantile", "values", "np", "ravel", "data", "sorted_values", "np", "sort", "values", "1", "normalized_values", "np", "cumsum", "sorted_values", "values", "sum", "idx", "np", "searchsorted", "normalized_values", "1", "isoprop", "levels", "np", "take", "sorted_values", "idx", "mode", "clip", "return", "levels"], "doc_len": 52}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._cmap_from_color", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_cmap_from_color", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _cmap_from_color(self, color):\n        \"\"\"Return a sequential colormap given a color seed.\"\"\"\n        # Like so much else here, this is broadly useful, but keeping it\n        # in this class to signify that I haven't thought overly hard about it...\n        r, g, b, _ = to_rgba(color)\n        h, s, _ = husl.rgb_to_husl(r, g, b)\n        xx = np.linspace(-1, 1, int(1.15 * 256))[:256]\n        ramp = np.zeros((256, 3))\n        ramp[:, 0] = h\n        ramp[:, 1] = s * np.cos(xx)\n        ramp[:, 2] = np.linspace(35, 80, 256)\n        colors = np.clip([husl.husl_to_rgb(*hsl) for hsl in ramp], 0, 1)\n        return mpl.colors.ListedColormap(colors[::-1])\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_cmap_from_color", "self", "color", "return", "a", "sequential", "colormap", "given", "a", "color", "seed", "like", "so", "much", "else", "here", "this", "is", "broadly", "useful", "but", "keeping", "it", "in", "this", "class", "to", "signify", "that", "i", "haven", "t", "thought", "overly", "hard", "about", "it", "r", "g", "b", "_", "to_rgba", "color", "h", "s", "_", "husl", "rgb_to_husl", "r", "g", "b", "xx", "np", "linspace", "1", "1", "int", "1", "15", "256", "256", "ramp", "np", "zeros", "256", "3", "ramp", "0", "h", "ramp", "1", "s", "np", "cos", "xx", "ramp", "2", "np", "linspace", "35", "80", "256", "colors", "np", "clip", "husl", "husl_to_rgb", "hsl", "for", "hsl", "in", "ramp", "0", "1", "return", "mpl", "colors", "listedcolormap", "colors", "1"], "doc_len": 105}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._default_discrete", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_default_discrete", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _default_discrete(self):\n        \"\"\"Find default values for discrete hist estimation based on variable type.\"\"\"\n        if self.univariate:\n            discrete = self.var_types[self.data_variable] == \"categorical\"\n        else:\n            discrete_x = self.var_types[\"x\"] == \"categorical\"\n            discrete_y = self.var_types[\"y\"] == \"categorical\"\n            discrete = discrete_x, discrete_y\n        return discrete\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_default_discrete", "self", "find", "default", "values", "for", "discrete", "hist", "estimation", "based", "on", "variable", "type", "if", "self", "univariate", "discrete", "self", "var_types", "self", "data_variable", "categorical", "else", "discrete_x", "self", "var_types", "x", "categorical", "discrete_y", "self", "var_types", "y", "categorical", "discrete", "discrete_x", "discrete_y", "return", "discrete"], "doc_len": 43}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._resolve_multiple", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_resolve_multiple", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _resolve_multiple(self, curves, multiple):\n        \"\"\"Modify the density data structure to handle multiple densities.\"\"\"\n\n        # Default baselines have all densities starting at 0\n        baselines = {k: np.zeros_like(v) for k, v in curves.items()}\n\n        # TODO we should have some central clearinghouse for checking if any\n        # \"grouping\" (terminnology?) semantics have been assigned\n        if \"hue\" not in self.variables:\n            return curves, baselines\n\n        if multiple in (\"stack\", \"fill\"):\n\n            # Setting stack or fill means that the curves share a\n            # support grid / set of bin edges, so we can make a dataframe\n            # Reverse the column order to plot from top to bottom\n            curves = pd.DataFrame(curves).iloc[:, ::-1]\n\n            # Find column groups that are nested within col/row variables\n            column_groups = {}\n            for i, keyd in enumerate(map(dict, curves.columns)):\n                facet_key = keyd.get(\"col\", None), keyd.get(\"row\", None)\n                column_groups.setdefault(facet_key, [])\n                column_groups[facet_key].append(i)\n\n            baselines = curves.copy()\n            for col_idxs in column_groups.values():\n                cols = curves.columns[col_idxs]\n\n                norm_constant = curves[cols].sum(axis=\"columns\")\n\n                # Take the cumulative sum to stack\n                curves[cols] = curves[cols].cumsum(axis=\"columns\")\n\n                # Normalize by row sum to fill\n                if multiple == \"fill\":\n                    curves[cols] = curves[cols].div(norm_constant, axis=\"index\")\n\n                # Define where each segment starts\n                baselines[cols] = curves[cols].shift(1, axis=1).fillna(0)\n\n        if multiple == \"dodge\":\n\n            # Account for the unique semantic (non-faceting) levels\n            # This will require rethiniking if we add other semantics!\n            hue_levels = self.var_levels[\"hue\"]\n            n = len(hue_levels)\n            for key in curves:\n                level = dict(key)[\"hue\"]\n                hist = curves[key].reset_index(name=\"heights\")\n                level_idx = hue_levels.index(level)\n                if self._log_scaled(self.data_variable):\n                    log_min = np.log10(hist[\"edges\"])\n                    log_max = np.log10(hist[\"edges\"] + hist[\"widths\"])\n                    log_width = (log_max - log_min) / n\n                    new_min = np.power(10, log_min + level_idx * log_width)\n                    new_max = np.power(10, log_min + (level_idx + 1) * log_width)\n                    hist[\"widths\"] = new_max - new_min\n                    hist[\"edges\"] = new_min\n                else:\n                    hist[\"widths\"] /= n\n                    hist[\"edges\"] += level_idx * hist[\"widths\"]\n\n                curves[key] = hist.set_index([\"edges\", \"widths\"])[\"heights\"]\n\n        return curves, baselines\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_resolve_multiple", "self", "curves", "multiple", "modify", "the", "density", "data", "structure", "to", "handle", "multiple", "densities", "default", "baselines", "have", "all", "densities", "starting", "at", "0", "baselines", "k", "np", "zeros_like", "v", "for", "k", "v", "in", "curves", "items", "todo", "we", "should", "have", "some", "central", "clearinghouse", "for", "checking", "if", "any", "grouping", "terminnology", "semantics", "have", "been", "assigned", "if", "hue", "not", "in", "self", "variables", "return", "curves", "baselines", "if", "multiple", "in", "stack", "fill", "setting", "stack", "or", "fill", "means", "that", "the", "curves", "share", "a", "support", "grid", "set", "of", "bin", "edges", "so", "we", "can", "make", "a", "dataframe", "reverse", "the", "column", "order", "to", "plot", "from", "top", "to", "bottom", "curves", "pd", "dataframe", "curves", "iloc", "1", "find", "column", "groups", "that", "are", "nested", "within", "col", "row", "variables", "column_groups", "for", "i", "keyd", "in", "enumerate", "map", "dict", "curves", "columns", "facet_key", "keyd", "get", "col", "none", "keyd", "get", "row", "none", "column_groups", "setdefault", "facet_key", "column_groups", "facet_key", "append", "i", "baselines", "curves", "copy", "for", "col_idxs", "in", "column_groups", "values", "cols", "curves", "columns", "col_idxs", "norm_constant", "curves", "cols", "sum", "axis", "columns", "take", "the", "cumulative", "sum", "to", "stack", "curves", "cols", "curves", "cols", "cumsum", "axis", "columns", "normalize", "by", "row", "sum", "to", "fill", "if", "multiple", "fill", "curves", "cols", "curves", "cols", "div", "norm_constant", "axis", "index", "define", "where", "each", "segment", "starts", "baselines", "cols", "curves", "cols", "shift", "1", "axis", "1", "fillna", "0", "if", "multiple", "dodge", "account", "for", "the", "unique", "semantic", "non", "faceting", "levels", "this", "will", "require", "rethiniking", "if", "we", "add", "other", "semantics", "hue_levels", "self", "var_levels", "hue", "n", "len", "hue_levels", "for", "key", "in", "curves", "level", "dict", "key", "hue", "hist", "curves", "key", "reset_index", "name", "heights", "level_idx", "hue_levels", "index", "level", "if", "self", "_log_scaled", "self", "data_variable", "log_min", "np", "log10", "hist", "edges", "log_max", "np", "log10", "hist", "edges", "hist", "widths", "log_width", "log_max", "log_min", "n", "new_min", "np", "power", "10", "log_min", "level_idx", "log_width", "new_max", "np", "power", "10", "log_min", "level_idx", "1", "log_width", "hist", "widths", "new_max", "new_min", "hist", "edges", "new_min", "else", "hist", "widths", "n", "hist", "edges", "level_idx", "hist", "widths", "curves", "key", "hist", "set_index", "edges", "widths", "heights", "return", "curves", "baselines"], "doc_len": 312}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._compute_univariate_density", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_compute_univariate_density", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _compute_univariate_density(\n        self,\n        data_variable,\n        common_norm,\n        common_grid,\n        estimate_kws,\n        log_scale,\n        warn_singular=True,\n    ):\n\n        # Initialize the estimator object\n        estimator = KDE(**estimate_kws)\n\n        if set(self.variables) - {\"x\", \"y\"}:\n            if common_grid:\n                all_observations = self.comp_data.dropna()\n                estimator.define_support(all_observations[data_variable])\n        else:\n            common_norm = False\n\n        all_data = self.plot_data.dropna()\n        if common_norm and \"weights\" in all_data:\n            whole_weight = all_data[\"weights\"].sum()\n        else:\n            whole_weight = len(all_data)\n\n        densities = {}\n\n        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):\n\n            # Extract the data points from this sub set and remove nulls\n            observations = sub_data[data_variable]\n\n            # Extract the weights for this subset of observations\n            if \"weights\" in self.variables:\n                weights = sub_data[\"weights\"]\n                part_weight = weights.sum()\n            else:\n                weights = None\n                part_weight = len(sub_data)\n\n            # Estimate the density of observations at this level\n            variance = np.nan_to_num(observations.var())\n            singular = len(observations) < 2 or math.isclose(variance, 0)\n            try:\n                if not singular:\n                    # Convoluted approach needed because numerical failures\n                    # can manifest in a few different ways.\n                    density, support = estimator(observations, weights=weights)\n            except np.linalg.LinAlgError:\n                singular = True\n\n            if singular:\n                msg = (\n                    \"Dataset has 0 variance; skipping density estimate. \"\n                    \"Pass `warn_singular=False` to disable this warning.\"\n                )\n                if warn_singular:\n                    warnings.warn(msg, UserWarning, stacklevel=4)\n                continue\n\n            if log_scale:\n                support = np.power(10, support)\n\n            # Apply a scaling factor so that the integral over all subsets is 1\n            if common_norm:\n                density *= part_weight / whole_weight\n\n            # Store the density for this level\n            key = tuple(sub_vars.items())\n            densities[key] = pd.Series(density, index=support)\n\n        return densities\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_compute_univariate_density", "self", "data_variable", "common_norm", "common_grid", "estimate_kws", "log_scale", "warn_singular", "true", "initialize", "the", "estimator", "object", "estimator", "kde", "estimate_kws", "if", "set", "self", "variables", "x", "y", "if", "common_grid", "all_observations", "self", "comp_data", "dropna", "estimator", "define_support", "all_observations", "data_variable", "else", "common_norm", "false", "all_data", "self", "plot_data", "dropna", "if", "common_norm", "and", "weights", "in", "all_data", "whole_weight", "all_data", "weights", "sum", "else", "whole_weight", "len", "all_data", "densities", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "hue", "from_comp_data", "true", "extract", "the", "data", "points", "from", "this", "sub", "set", "and", "remove", "nulls", "observations", "sub_data", "data_variable", "extract", "the", "weights", "for", "this", "subset", "of", "observations", "if", "weights", "in", "self", "variables", "weights", "sub_data", "weights", "part_weight", "weights", "sum", "else", "weights", "none", "part_weight", "len", "sub_data", "estimate", "the", "density", "of", "observations", "at", "this", "level", "variance", "np", "nan_to_num", "observations", "var", "singular", "len", "observations", "2", "or", "math", "isclose", "variance", "0", "try", "if", "not", "singular", "convoluted", "approach", "needed", "because", "numerical", "failures", "can", "manifest", "in", "a", "few", "different", "ways", "density", "support", "estimator", "observations", "weights", "weights", "except", "np", "linalg", "linalgerror", "singular", "true", "if", "singular", "msg", "dataset", "has", "0", "variance", "skipping", "density", "estimate", "pass", "warn_singular", "false", "to", "disable", "this", "warning", "if", "warn_singular", "warnings", "warn", "msg", "userwarning", "stacklevel", "4", "continue", "if", "log_scale", "support", "np", "power", "10", "support", "apply", "a", "scaling", "factor", "so", "that", "the", "integral", "over", "all", "subsets", "is", "1", "if", "common_norm", "density", "part_weight", "whole_weight", "store", "the", "density", "for", "this", "level", "key", "tuple", "sub_vars", "items", "densities", "key", "pd", "series", "density", "index", "support", "return", "densities"], "doc_len": 228}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_univariate_histogram", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_univariate_histogram", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_univariate_histogram(\n        self,\n        multiple,\n        element,\n        fill,\n        common_norm,\n        common_bins,\n        shrink,\n        kde,\n        kde_kws,\n        color,\n        legend,\n        line_kws,\n        estimate_kws,\n        **plot_kws,\n    ):\n\n        # -- Default keyword dicts\n        kde_kws = {} if kde_kws is None else kde_kws.copy()\n        line_kws = {} if line_kws is None else line_kws.copy()\n        estimate_kws = {} if estimate_kws is None else estimate_kws.copy()\n\n        # --  Input checking\n        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\", \"dodge\"], multiple)\n        _check_argument(\"element\", [\"bars\", \"step\", \"poly\"], element)\n\n        auto_bins_with_weights = (\n            \"weights\" in self.variables\n            and estimate_kws[\"bins\"] == \"auto\"\n            and estimate_kws[\"binwidth\"] is None\n            and not estimate_kws[\"discrete\"]\n        )\n        if auto_bins_with_weights:\n            msg = (\n                \"`bins` cannot be 'auto' when using weights. \"\n                \"Setting `bins=10`, but you will likely want to adjust.\"\n            )\n            warnings.warn(msg, UserWarning)\n            estimate_kws[\"bins\"] = 10\n\n        # Simplify downstream code if we are not normalizing\n        if estimate_kws[\"stat\"] == \"count\":\n            common_norm = False\n\n        orient = self.data_variable\n\n        # Now initialize the Histogram estimator\n        estimator = Hist(**estimate_kws)\n        histograms = {}\n\n        # Do pre-compute housekeeping related to multiple groups\n        all_data = self.comp_data.dropna()\n        all_weights = all_data.get(\"weights\", None)\n\n        multiple_histograms = set(self.variables) - {\"x\", \"y\"}\n        if multiple_histograms:\n            if common_bins:\n                bin_kws = estimator._define_bin_params(all_data, orient, None)\n        else:\n            common_norm = False\n\n        if common_norm and all_weights is not None:\n            whole_weight = all_weights.sum()\n        else:\n            whole_weight = len(all_data)\n\n        # Estimate the smoothed kernel densities, for use later\n        if kde:\n            # TODO alternatively, clip at min/max bins?\n            kde_kws.setdefault(\"cut\", 0)\n            kde_kws[\"cumulative\"] = estimate_kws[\"cumulative\"]\n            log_scale = self._log_scaled(self.data_variable)\n            densities = self._compute_univariate_density(\n                self.data_variable,\n                common_norm,\n                common_bins,\n                kde_kws,\n                log_scale,\n                warn_singular=False,\n            )\n\n        # First pass through the data to compute the histograms\n        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):\n\n            # Prepare the relevant data\n            key = tuple(sub_vars.items())\n            orient = self.data_variable\n\n            if \"weights\" in self.variables:\n                sub_data[\"weight\"] = sub_data.pop(\"weights\")\n                part_weight = sub_data[\"weight\"].sum()\n            else:\n                part_weight = len(sub_data)\n\n            # Do the histogram computation\n            if not (multiple_histograms and common_bins):\n                bin_kws = estimator._define_bin_params(sub_data, orient, None)\n            res = estimator._normalize(estimator._eval(sub_data, orient, bin_kws))\n            heights = res[estimator.stat].to_numpy()\n            widths = res[\"space\"].to_numpy()\n            edges = res[orient].to_numpy() - widths / 2\n\n            # Rescale the smoothed curve to match the histogram\n            if kde and key in densities:\n                density = densities[key]\n                if estimator.cumulative:\n                    hist_norm = heights.max()\n                else:\n                    hist_norm = (heights * widths).sum()\n                densities[key] *= hist_norm\n\n            # Convert edges back to original units for plotting\n            if self._log_scaled(self.data_variable):\n                widths = np.power(10, edges + widths) - np.power(10, edges)\n                edges = np.power(10, edges)\n\n            # Pack the histogram data and metadata together\n            edges = edges + (1 - shrink) / 2 * widths\n            widths *= shrink\n            index = pd.MultiIndex.from_arrays([\n                pd.Index(edges, name=\"edges\"),\n                pd.Index(widths, name=\"widths\"),\n            ])\n            hist = pd.Series(heights, index=index, name=\"heights\")\n\n            # Apply scaling to normalize across groups\n            if common_norm:\n                hist *= part_weight / whole_weight\n\n            # Store the finalized histogram data for future plotting\n            histograms[key] = hist\n\n        # Modify the histogram and density data to resolve multiple groups\n        histograms, baselines = self._resolve_multiple(histograms, multiple)\n        if kde:\n            densities, _ = self._resolve_multiple(\n                densities, None if multiple == \"dodge\" else multiple\n            )\n\n        # Set autoscaling-related meta\n        sticky_stat = (0, 1) if multiple == \"fill\" else (0, np.inf)\n        if multiple == \"fill\":\n            # Filled plots should not have any margins\n            bin_vals = histograms.index.to_frame()\n            edges = bin_vals[\"edges\"]\n            widths = bin_vals[\"widths\"]\n            sticky_data = (\n                edges.min(),\n                edges.max() + widths.loc[edges.idxmax()]\n            )\n        else:\n            sticky_data = []\n\n        # --- Handle default visual attributes\n\n        # Note: default linewidth is determined after plotting\n\n        # Default alpha should depend on other parameters\n        if fill:\n            # Note: will need to account for other grouping semantics if added\n            if \"hue\" in self.variables and multiple == \"layer\":\n                default_alpha = .5 if element == \"bars\" else .25\n            elif kde:\n                default_alpha = .5\n            else:\n                default_alpha = .75\n        else:\n            default_alpha = 1\n        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?\n\n        hist_artists = []\n\n        # Go back through the dataset and draw the plots\n        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):\n\n            key = tuple(sub_vars.items())\n            hist = histograms[key].rename(\"heights\").reset_index()\n            bottom = np.asarray(baselines[key])\n\n            ax = self._get_axes(sub_vars)\n\n            # Define the matplotlib attributes that depend on semantic mapping\n            if \"hue\" in self.variables:\n                sub_color = self._hue_map(sub_vars[\"hue\"])\n            else:\n                sub_color = color\n\n            artist_kws = self._artist_kws(\n                plot_kws, fill, element, multiple, sub_color, alpha\n            )\n\n            if element == \"bars\":\n\n                # Use matplotlib bar plotting\n\n                plot_func = ax.bar if self.data_variable == \"x\" else ax.barh\n                artists = plot_func(\n                    hist[\"edges\"],\n                    hist[\"heights\"] - bottom,\n                    hist[\"widths\"],\n                    bottom,\n                    align=\"edge\",\n                    **artist_kws,\n                )\n\n                for bar in artists:\n                    if self.data_variable == \"x\":\n                        bar.sticky_edges.x[:] = sticky_data\n                        bar.sticky_edges.y[:] = sticky_stat\n                    else:\n                        bar.sticky_edges.x[:] = sticky_stat\n                        bar.sticky_edges.y[:] = sticky_data\n\n                hist_artists.extend(artists)\n\n            else:\n\n                # Use either fill_between or plot to draw hull of histogram\n                if element == \"step\":\n\n                    final = hist.iloc[-1]\n                    x = np.append(hist[\"edges\"], final[\"edges\"] + final[\"widths\"])\n                    y = np.append(hist[\"heights\"], final[\"heights\"])\n                    b = np.append(bottom, bottom[-1])\n\n                    if self.data_variable == \"x\":\n                        step = \"post\"\n                        drawstyle = \"steps-post\"\n                    else:\n                        step = \"post\"  # fillbetweenx handles mapping internally\n                        drawstyle = \"steps-pre\"\n\n                elif element == \"poly\":\n\n                    x = hist[\"edges\"] + hist[\"widths\"] / 2\n                    y = hist[\"heights\"]\n                    b = bottom\n\n                    step = None\n                    drawstyle = None\n\n                if self.data_variable == \"x\":\n                    if fill:\n                        artist = ax.fill_between(x, b, y, step=step, **artist_kws)\n                    else:\n                        artist, = ax.plot(x, y, drawstyle=drawstyle, **artist_kws)\n                    artist.sticky_edges.x[:] = sticky_data\n                    artist.sticky_edges.y[:] = sticky_stat\n                else:\n                    if fill:\n                        artist = ax.fill_betweenx(x, b, y, step=step, **artist_kws)\n                    else:\n                        artist, = ax.plot(y, x, drawstyle=drawstyle, **artist_kws)\n                    artist.sticky_edges.x[:] = sticky_stat\n                    artist.sticky_edges.y[:] = sticky_data\n\n                hist_artists.append(artist)\n\n            if kde:\n\n                # Add in the density curves\n\n                try:\n                    density = densities[key]\n                except KeyError:\n                    continue\n                support = density.index\n\n                if \"x\" in self.variables:\n                    line_args = support, density\n                    sticky_x, sticky_y = None, (0, np.inf)\n                else:\n                    line_args = density, support\n                    sticky_x, sticky_y = (0, np.inf), None\n\n                line_kws[\"color\"] = to_rgba(sub_color, 1)\n                line, = ax.plot(\n                    *line_args, **line_kws,\n                )\n\n                if sticky_x is not None:\n                    line.sticky_edges.x[:] = sticky_x\n                if sticky_y is not None:\n                    line.sticky_edges.y[:] = sticky_y\n\n        if element == \"bars\" and \"linewidth\" not in plot_kws:\n\n            # Now we handle linewidth, which depends on the scaling of the plot\n\n            # We will base everything on the minimum bin width\n            hist_metadata = pd.concat([\n                # Use .items for generality over dict or df\n                h.index.to_frame() for _, h in histograms.items()\n            ]).reset_index(drop=True)\n            thin_bar_idx = hist_metadata[\"widths\"].idxmin()\n            binwidth = hist_metadata.loc[thin_bar_idx, \"widths\"]\n            left_edge = hist_metadata.loc[thin_bar_idx, \"edges\"]\n\n            # Set initial value\n            default_linewidth = math.inf\n\n            # Loop through subsets based only on facet variables\n            for sub_vars, _ in self.iter_data():\n\n                ax = self._get_axes(sub_vars)\n\n                # Needed in some cases to get valid transforms.\n                # Innocuous in other cases?\n                ax.autoscale_view()\n\n                # Convert binwidth from data coordinates to pixels\n                pts_x, pts_y = 72 / ax.figure.dpi * abs(\n                    ax.transData.transform([left_edge + binwidth] * 2)\n                    - ax.transData.transform([left_edge] * 2)\n                )\n                if self.data_variable == \"x\":\n                    binwidth_points = pts_x\n                else:\n                    binwidth_points = pts_y\n\n                # The relative size of the lines depends on the appearance\n                # This is a provisional value and may need more tweaking\n                default_linewidth = min(.1 * binwidth_points, default_linewidth)\n\n            # Set the attributes\n            for bar in hist_artists:\n\n                # Don't let the lines get too thick\n                max_linewidth = bar.get_linewidth()\n                if not fill:\n                    max_linewidth *= 1.5\n\n                linewidth = min(default_linewidth, max_linewidth)\n\n                # If not filling, don't let lines disappear\n                if not fill:\n                    min_linewidth = .5\n                    linewidth = max(linewidth, min_linewidth)\n\n                bar.set_linewidth(linewidth)\n\n        # --- Finalize the plot ----\n\n        # Axis labels\n        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]\n        default_x = default_y = \"\"\n        if self.data_variable == \"x\":\n            default_y = estimator.stat.capitalize()\n        if self.data_variable == \"y\":\n            default_x = estimator.stat.capitalize()\n        self._add_axis_labels(ax, default_x, default_y)\n\n        # Legend for semantic variables\n        if \"hue\" in self.variables and legend:\n\n            if fill or element == \"bars\":\n                artist = partial(mpl.patches.Patch)\n            else:\n                artist = partial(mpl.lines.Line2D, [], [])\n\n            ax_obj = self.ax if self.ax is not None else self.facets\n            self._add_legend(\n                ax_obj, artist, fill, element, multiple, alpha, plot_kws, {},\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_univariate_histogram", "self", "multiple", "element", "fill", "common_norm", "common_bins", "shrink", "kde", "kde_kws", "color", "legend", "line_kws", "estimate_kws", "plot_kws", "default", "keyword", "dicts", "kde_kws", "if", "kde_kws", "is", "none", "else", "kde_kws", "copy", "line_kws", "if", "line_kws", "is", "none", "else", "line_kws", "copy", "estimate_kws", "if", "estimate_kws", "is", "none", "else", "estimate_kws", "copy", "input", "checking", "_check_argument", "multiple", "layer", "stack", "fill", "dodge", "multiple", "_check_argument", "element", "bars", "step", "poly", "element", "auto_bins_with_weights", "weights", "in", "self", "variables", "and", "estimate_kws", "bins", "auto", "and", "estimate_kws", "binwidth", "is", "none", "and", "not", "estimate_kws", "discrete", "if", "auto_bins_with_weights", "msg", "bins", "cannot", "be", "auto", "when", "using", "weights", "setting", "bins", "10", "but", "you", "will", "likely", "want", "to", "adjust", "warnings", "warn", "msg", "userwarning", "estimate_kws", "bins", "10", "simplify", "downstream", "code", "if", "we", "are", "not", "normalizing", "if", "estimate_kws", "stat", "count", "common_norm", "false", "orient", "self", "data_variable", "now", "initialize", "the", "histogram", "estimator", "estimator", "hist", "estimate_kws", "histograms", "do", "pre", "compute", "housekeeping", "related", "to", "multiple", "groups", "all_data", "self", "comp_data", "dropna", "all_weights", "all_data", "get", "weights", "none", "multiple_histograms", "set", "self", "variables", "x", "y", "if", "multiple_histograms", "if", "common_bins", "bin_kws", "estimator", "_define_bin_params", "all_data", "orient", "none", "else", "common_norm", "false", "if", "common_norm", "and", "all_weights", "is", "not", "none", "whole_weight", "all_weights", "sum", "else", "whole_weight", "len", "all_data", "estimate", "the", "smoothed", "kernel", "densities", "for", "use", "later", "if", "kde", "todo", "alternatively", "clip", "at", "min", "max", "bins", "kde_kws", "setdefault", "cut", "0", "kde_kws", "cumulative", "estimate_kws", "cumulative", "log_scale", "self", "_log_scaled", "self", "data_variable", "densities", "self", "_compute_univariate_density", "self", "data_variable", "common_norm", "common_bins", "kde_kws", "log_scale", "warn_singular", "false", "first", "pass", "through", "the", "data", "to", "compute", "the", "histograms", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "hue", "from_comp_data", "true", "prepare", "the", "relevant", "data", "key", "tuple", "sub_vars", "items", "orient", "self", "data_variable", "if", "weights", "in", "self", "variables", "sub_data", "weight", "sub_data", "pop", "weights", "part_weight", "sub_data", "weight", "sum", "else", "part_weight", "len", "sub_data", "do", "the", "histogram", "computation", "if", "not", "multiple_histograms", "and", "common_bins", "bin_kws", "estimator", "_define_bin_params", "sub_data", "orient", "none", "res", "estimator", "_normalize", "estimator", "_eval", "sub_data", "orient", "bin_kws", "heights", "res", "estimator", "stat", "to_numpy", "widths", "res", "space", "to_numpy", "edges", "res", "orient", "to_numpy", "widths", "2", "rescale", "the", "smoothed", "curve", "to", "match", "the", "histogram", "if", "kde", "and", "key", "in", "densities", "density", "densities", "key", "if", "estimator", "cumulative", "hist_norm", "heights", "max", "else", "hist_norm", "heights", "widths", "sum", "densities", "key", "hist_norm", "convert", "edges", "back", "to", "original", "units", "for", "plotting", "if", "self", "_log_scaled", "self", "data_variable", "widths", "np", "power", "10", "edges", "widths", "np", "power", "10", "edges", "edges", "np", "power", "10", "edges", "pack", "the", "histogram", "data", "and", "metadata", "together", "edges", "edges", "1", "shrink", "2", "widths", "widths", "shrink", "index", "pd", "multiindex", "from_arrays", "pd", "index", "edges", "name", "edges", "pd", "index", "widths", "name", "widths", "hist", "pd", "series", "heights", "index", "index", "name", "heights", "apply", "scaling", "to", "normalize", "across", "groups", "if", "common_norm", "hist", "part_weight", "whole_weight", "store", "the", "finalized", "histogram", "data", "for", "future", "plotting", "histograms", "key", "hist", "modify", "the", "histogram", "and", "density", "data", "to", "resolve", "multiple", "groups", "histograms", "baselines", "self", "_resolve_multiple", "histograms", "multiple", "if", "kde", "densities", "_", "self", "_resolve_multiple", "densities", "none", "if", "multiple", "dodge", "else", "multiple", "set", "autoscaling", "related", "meta", "sticky_stat", "0", "1", "if", "multiple", "fill", "else", "0", "np", "inf", "if", "multiple", "fill", "filled", "plots", "should", "not", "have", "any", "margins", "bin_vals", "histograms", "index", "to_frame", "edges", "bin_vals", "edges", "widths", "bin_vals", "widths", "sticky_data", "edges", "min", "edges", "max", "widths", "loc", "edges", "idxmax", "else", "sticky_data", "handle", "default", "visual", "attributes", "note", "default", "linewidth", "is", "determined", "after", "plotting", "default", "alpha", "should", "depend", "on", "other", "parameters", "if", "fill", "note", "will", "need", "to", "account", "for", "other", "grouping", "semantics", "if", "added", "if", "hue", "in", "self", "variables", "and", "multiple", "layer", "default_alpha", "5", "if", "element", "bars", "else", "25", "elif", "kde", "default_alpha", "5", "else", "default_alpha", "75", "else", "default_alpha", "1", "alpha", "plot_kws", "pop", "alpha", "default_alpha", "todo", "make", "parameter", "hist_artists", "go", "back", "through", "the", "dataset", "and", "draw", "the", "plots", "for", "sub_vars", "_", "in", "self", "iter_data", "hue", "reverse", "true", "key", "tuple", "sub_vars", "items", "hist", "histograms", "key", "rename", "heights", "reset_index", "bottom", "np", "asarray", "baselines", "key", "ax", "self", "_get_axes", "sub_vars", "define", "the", "matplotlib", "attributes", "that", "depend", "on", "semantic", "mapping", "if", "hue", "in", "self", "variables", "sub_color", "self", "_hue_map", "sub_vars", "hue", "else", "sub_color", "color", "artist_kws", "self", "_artist_kws", "plot_kws", "fill", "element", "multiple", "sub_color", "alpha", "if", "element", "bars", "use", "matplotlib", "bar", "plotting", "plot_func", "ax", "bar", "if", "self", "data_variable", "x", "else", "ax", "barh", "artists", "plot_func", "hist", "edges", "hist", "heights", "bottom", "hist", "widths", "bottom", "align", "edge", "artist_kws", "for", "bar", "in", "artists", "if", "self", "data_variable", "x", "bar", "sticky_edges", "x", "sticky_data", "bar", "sticky_edges", "y", "sticky_stat", "else", "bar", "sticky_edges", "x", "sticky_stat", "bar", "sticky_edges", "y", "sticky_data", "hist_artists", "extend", "artists", "else", "use", "either", "fill_between", "or", "plot", "to", "draw", "hull", "of", "histogram", "if", "element", "step", "final", "hist", "iloc", "1", "x", "np", "append", "hist", "edges", "final", "edges", "final", "widths", "y", "np", "append", "hist", "heights", "final", "heights", "b", "np", "append", "bottom", "bottom", "1", "if", "self", "data_variable", "x", "step", "post", "drawstyle", "steps", "post", "else", "step", "post", "fillbetweenx", "handles", "mapping", "internally", "drawstyle", "steps", "pre", "elif", "element", "poly", "x", "hist", "edges", "hist", "widths", "2", "y", "hist", "heights", "b", "bottom", "step", "none", "drawstyle", "none", "if", "self", "data_variable", "x", "if", "fill", "artist", "ax", "fill_between", "x", "b", "y", "step", "step", "artist_kws", "else", "artist", "ax", "plot", "x", "y", "drawstyle", "drawstyle", "artist_kws", "artist", "sticky_edges", "x", "sticky_data", "artist", "sticky_edges", "y", "sticky_stat", "else", "if", "fill", "artist", "ax", "fill_betweenx", "x", "b", "y", "step", "step", "artist_kws", "else", "artist", "ax", "plot", "y", "x", "drawstyle", "drawstyle", "artist_kws", "artist", "sticky_edges", "x", "sticky_stat", "artist", "sticky_edges", "y", "sticky_data", "hist_artists", "append", "artist", "if", "kde", "add", "in", "the", "density", "curves", "try", "density", "densities", "key", "except", "keyerror", "continue", "support", "density", "index", "if", "x", "in", "self", "variables", "line_args", "support", "density", "sticky_x", "sticky_y", "none", "0", "np", "inf", "else", "line_args", "density", "support", "sticky_x", "sticky_y", "0", "np", "inf", "none", "line_kws", "color", "to_rgba", "sub_color", "1", "line", "ax", "plot", "line_args", "line_kws", "if", "sticky_x", "is", "not", "none", "line", "sticky_edges", "x", "sticky_x", "if", "sticky_y", "is", "not", "none", "line", "sticky_edges", "y", "sticky_y", "if", "element", "bars", "and", "linewidth", "not", "in", "plot_kws", "now", "we", "handle", "linewidth", "which", "depends", "on", "the", "scaling", "of", "the", "plot", "we", "will", "base", "everything", "on", "the", "minimum", "bin", "width", "hist_metadata", "pd", "concat", "use", "items", "for", "generality", "over", "dict", "or", "df", "h", "index", "to_frame", "for", "_", "h", "in", "histograms", "items", "reset_index", "drop", "true", "thin_bar_idx", "hist_metadata", "widths", "idxmin", "binwidth", "hist_metadata", "loc", "thin_bar_idx", "widths", "left_edge", "hist_metadata", "loc", "thin_bar_idx", "edges", "set", "initial", "value", "default_linewidth", "math", "inf", "loop", "through", "subsets", "based", "only", "on", "facet", "variables", "for", "sub_vars", "_", "in", "self", "iter_data", "ax", "self", "_get_axes", "sub_vars", "needed", "in", "some", "cases", "to", "get", "valid", "transforms", "innocuous", "in", "other", "cases", "ax", "autoscale_view", "convert", "binwidth", "from", "data", "coordinates", "to", "pixels", "pts_x", "pts_y", "72", "ax", "figure", "dpi", "abs", "ax", "transdata", "transform", "left_edge", "binwidth", "2", "ax", "transdata", "transform", "left_edge", "2", "if", "self", "data_variable", "x", "binwidth_points", "pts_x", "else", "binwidth_points", "pts_y", "the", "relative", "size", "of", "the", "lines", "depends", "on", "the", "appearance", "this", "is", "a", "provisional", "value", "and", "may", "need", "more", "tweaking", "default_linewidth", "min", "1", "binwidth_points", "default_linewidth", "set", "the", "attributes", "for", "bar", "in", "hist_artists", "don", "t", "let", "the", "lines", "get", "too", "thick", "max_linewidth", "bar", "get_linewidth", "if", "not", "fill", "max_linewidth", "1", "5", "linewidth", "min", "default_linewidth", "max_linewidth", "if", "not", "filling", "don", "t", "let", "lines", "disappear", "if", "not", "fill", "min_linewidth", "5", "linewidth", "max", "linewidth", "min_linewidth", "bar", "set_linewidth", "linewidth", "finalize", "the", "plot", "axis", "labels", "ax", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "axes", "flat", "0", "default_x", "default_y", "if", "self", "data_variable", "x", "default_y", "estimator", "stat", "capitalize", "if", "self", "data_variable", "y", "default_x", "estimator", "stat", "capitalize", "self", "_add_axis_labels", "ax", "default_x", "default_y", "legend", "for", "semantic", "variables", "if", "hue", "in", "self", "variables", "and", "legend", "if", "fill", "or", "element", "bars", "artist", "partial", "mpl", "patches", "patch", "else", "artist", "partial", "mpl", "lines", "line2d", "ax_obj", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "self", "_add_legend", "ax_obj", "artist", "fill", "element", "multiple", "alpha", "plot_kws"], "doc_len": 1204}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_bivariate_histogram", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_bivariate_histogram", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_bivariate_histogram(\n        self,\n        common_bins, common_norm,\n        thresh, pthresh, pmax,\n        color, legend,\n        cbar, cbar_ax, cbar_kws,\n        estimate_kws,\n        **plot_kws,\n    ):\n\n        # Default keyword dicts\n        cbar_kws = {} if cbar_kws is None else cbar_kws.copy()\n\n        # Now initialize the Histogram estimator\n        estimator = Histogram(**estimate_kws)\n\n        # Do pre-compute housekeeping related to multiple groups\n        if set(self.variables) - {\"x\", \"y\"}:\n            all_data = self.comp_data.dropna()\n            if common_bins:\n                estimator.define_bin_params(\n                    all_data[\"x\"],\n                    all_data[\"y\"],\n                    all_data.get(\"weights\", None),\n                )\n        else:\n            common_norm = False\n\n        # -- Determine colormap threshold and norm based on the full data\n\n        full_heights = []\n        for _, sub_data in self.iter_data(from_comp_data=True):\n            sub_heights, _ = estimator(\n                sub_data[\"x\"], sub_data[\"y\"], sub_data.get(\"weights\", None)\n            )\n            full_heights.append(sub_heights)\n\n        common_color_norm = not set(self.variables) - {\"x\", \"y\"} or common_norm\n\n        if pthresh is not None and common_color_norm:\n            thresh = self._quantile_to_level(full_heights, pthresh)\n\n        plot_kws.setdefault(\"vmin\", 0)\n        if common_color_norm:\n            if pmax is not None:\n                vmax = self._quantile_to_level(full_heights, pmax)\n            else:\n                vmax = plot_kws.pop(\"vmax\", max(map(np.max, full_heights)))\n        else:\n            vmax = None\n\n        # Get a default color\n        # (We won't follow the color cycle here, as multiple plots are unlikely)\n        if color is None:\n            color = \"C0\"\n\n        # --- Loop over data (subsets) and draw the histograms\n        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):\n\n            if sub_data.empty:\n                continue\n\n            # Do the histogram computation\n            heights, (x_edges, y_edges) = estimator(\n                sub_data[\"x\"],\n                sub_data[\"y\"],\n                weights=sub_data.get(\"weights\", None),\n            )\n\n            # Check for log scaling on the data axis\n            if self._log_scaled(\"x\"):\n                x_edges = np.power(10, x_edges)\n            if self._log_scaled(\"y\"):\n                y_edges = np.power(10, y_edges)\n\n            # Apply scaling to normalize across groups\n            if estimator.stat != \"count\" and common_norm:\n                heights *= len(sub_data) / len(all_data)\n\n            # Define the specific kwargs for this artist\n            artist_kws = plot_kws.copy()\n            if \"hue\" in self.variables:\n                color = self._hue_map(sub_vars[\"hue\"])\n                cmap = self._cmap_from_color(color)\n                artist_kws[\"cmap\"] = cmap\n            else:\n                cmap = artist_kws.pop(\"cmap\", None)\n                if isinstance(cmap, str):\n                    cmap = color_palette(cmap, as_cmap=True)\n                elif cmap is None:\n                    cmap = self._cmap_from_color(color)\n                artist_kws[\"cmap\"] = cmap\n\n            # Set the upper norm on the colormap\n            if not common_color_norm and pmax is not None:\n                vmax = self._quantile_to_level(heights, pmax)\n            if vmax is not None:\n                artist_kws[\"vmax\"] = vmax\n\n            # Make cells at or below the threshold transparent\n            if not common_color_norm and pthresh:\n                thresh = self._quantile_to_level(heights, pthresh)\n            if thresh is not None:\n                heights = np.ma.masked_less_equal(heights, thresh)\n\n            # Get the axes for this plot\n            ax = self._get_axes(sub_vars)\n\n            # pcolormesh is going to turn the grid off, but we want to keep it\n            # I'm not sure if there's a better way to get the grid state\n            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])\n            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])\n\n            mesh = ax.pcolormesh(\n                x_edges,\n                y_edges,\n                heights.T,\n                **artist_kws,\n            )\n\n            # pcolormesh sets sticky edges, but we only want them if not thresholding\n            if thresh is not None:\n                mesh.sticky_edges.x[:] = []\n                mesh.sticky_edges.y[:] = []\n\n            # Add an optional colorbar\n            # Note, we want to improve this. When hue is used, it will stack\n            # multiple colorbars with redundant ticks in an ugly way.\n            # But it's going to take some work to have multiple colorbars that\n            # share ticks nicely.\n            if cbar:\n                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)\n\n            # Reset the grid state\n            if x_grid:\n                ax.grid(True, axis=\"x\")\n            if y_grid:\n                ax.grid(True, axis=\"y\")\n\n        # --- Finalize the plot\n\n        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]\n        self._add_axis_labels(ax)\n\n        if \"hue\" in self.variables and legend:\n\n            # TODO if possible, I would like to move the contour\n            # intensity information into the legend too and label the\n            # iso proportions rather than the raw density values\n\n            artist_kws = {}\n            artist = partial(mpl.patches.Patch)\n            ax_obj = self.ax if self.ax is not None else self.facets\n            self._add_legend(\n                ax_obj, artist, True, False, \"layer\", 1, artist_kws, {},\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_bivariate_histogram", "self", "common_bins", "common_norm", "thresh", "pthresh", "pmax", "color", "legend", "cbar", "cbar_ax", "cbar_kws", "estimate_kws", "plot_kws", "default", "keyword", "dicts", "cbar_kws", "if", "cbar_kws", "is", "none", "else", "cbar_kws", "copy", "now", "initialize", "the", "histogram", "estimator", "estimator", "histogram", "estimate_kws", "do", "pre", "compute", "housekeeping", "related", "to", "multiple", "groups", "if", "set", "self", "variables", "x", "y", "all_data", "self", "comp_data", "dropna", "if", "common_bins", "estimator", "define_bin_params", "all_data", "x", "all_data", "y", "all_data", "get", "weights", "none", "else", "common_norm", "false", "determine", "colormap", "threshold", "and", "norm", "based", "on", "the", "full", "data", "full_heights", "for", "_", "sub_data", "in", "self", "iter_data", "from_comp_data", "true", "sub_heights", "_", "estimator", "sub_data", "x", "sub_data", "y", "sub_data", "get", "weights", "none", "full_heights", "append", "sub_heights", "common_color_norm", "not", "set", "self", "variables", "x", "y", "or", "common_norm", "if", "pthresh", "is", "not", "none", "and", "common_color_norm", "thresh", "self", "_quantile_to_level", "full_heights", "pthresh", "plot_kws", "setdefault", "vmin", "0", "if", "common_color_norm", "if", "pmax", "is", "not", "none", "vmax", "self", "_quantile_to_level", "full_heights", "pmax", "else", "vmax", "plot_kws", "pop", "vmax", "max", "map", "np", "max", "full_heights", "else", "vmax", "none", "get", "a", "default", "color", "we", "won", "t", "follow", "the", "color", "cycle", "here", "as", "multiple", "plots", "are", "unlikely", "if", "color", "is", "none", "color", "c0", "loop", "over", "data", "subsets", "and", "draw", "the", "histograms", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "hue", "from_comp_data", "true", "if", "sub_data", "empty", "continue", "do", "the", "histogram", "computation", "heights", "x_edges", "y_edges", "estimator", "sub_data", "x", "sub_data", "y", "weights", "sub_data", "get", "weights", "none", "check", "for", "log", "scaling", "on", "the", "data", "axis", "if", "self", "_log_scaled", "x", "x_edges", "np", "power", "10", "x_edges", "if", "self", "_log_scaled", "y", "y_edges", "np", "power", "10", "y_edges", "apply", "scaling", "to", "normalize", "across", "groups", "if", "estimator", "stat", "count", "and", "common_norm", "heights", "len", "sub_data", "len", "all_data", "define", "the", "specific", "kwargs", "for", "this", "artist", "artist_kws", "plot_kws", "copy", "if", "hue", "in", "self", "variables", "color", "self", "_hue_map", "sub_vars", "hue", "cmap", "self", "_cmap_from_color", "color", "artist_kws", "cmap", "cmap", "else", "cmap", "artist_kws", "pop", "cmap", "none", "if", "isinstance", "cmap", "str", "cmap", "color_palette", "cmap", "as_cmap", "true", "elif", "cmap", "is", "none", "cmap", "self", "_cmap_from_color", "color", "artist_kws", "cmap", "cmap", "set", "the", "upper", "norm", "on", "the", "colormap", "if", "not", "common_color_norm", "and", "pmax", "is", "not", "none", "vmax", "self", "_quantile_to_level", "heights", "pmax", "if", "vmax", "is", "not", "none", "artist_kws", "vmax", "vmax", "make", "cells", "at", "or", "below", "the", "threshold", "transparent", "if", "not", "common_color_norm", "and", "pthresh", "thresh", "self", "_quantile_to_level", "heights", "pthresh", "if", "thresh", "is", "not", "none", "heights", "np", "ma", "masked_less_equal", "heights", "thresh", "get", "the", "axes", "for", "this", "plot", "ax", "self", "_get_axes", "sub_vars", "pcolormesh", "is", "going", "to", "turn", "the", "grid", "off", "but", "we", "want", "to", "keep", "it", "i", "m", "not", "sure", "if", "there", "s", "a", "better", "way", "to", "get", "the", "grid", "state", "x_grid", "any", "l", "get_visible", "for", "l", "in", "ax", "xaxis", "get_gridlines", "y_grid", "any", "l", "get_visible", "for", "l", "in", "ax", "yaxis", "get_gridlines", "mesh", "ax", "pcolormesh", "x_edges", "y_edges", "heights", "t", "artist_kws", "pcolormesh", "sets", "sticky", "edges", "but", "we", "only", "want", "them", "if", "not", "thresholding", "if", "thresh", "is", "not", "none", "mesh", "sticky_edges", "x", "mesh", "sticky_edges", "y", "add", "an", "optional", "colorbar", "note", "we", "want", "to", "improve", "this", "when", "hue", "is", "used", "it", "will", "stack", "multiple", "colorbars", "with", "redundant", "ticks", "in", "an", "ugly", "way", "but", "it", "s", "going", "to", "take", "some", "work", "to", "have", "multiple", "colorbars", "that", "share", "ticks", "nicely", "if", "cbar", "ax", "figure", "colorbar", "mesh", "cbar_ax", "ax", "cbar_kws", "reset", "the", "grid", "state", "if", "x_grid", "ax", "grid", "true", "axis", "x", "if", "y_grid", "ax", "grid", "true", "axis", "y", "finalize", "the", "plot", "ax", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "axes", "flat", "0", "self", "_add_axis_labels", "ax", "if", "hue", "in", "self", "variables", "and", "legend", "todo", "if", "possible", "i", "would", "like", "to", "move", "the", "contour", "intensity", "information", "into", "the", "legend", "too", "and", "label", "the", "iso", "proportions", "rather", "than", "the", "raw", "density", "values", "artist_kws", "artist", "partial", "mpl", "patches", "patch", "ax_obj", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "self", "_add_legend", "ax_obj", "artist", "true", "false", "layer", "1", "artist_kws"], "doc_len": 609}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_univariate_density", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_univariate_density", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_univariate_density(\n        self,\n        multiple,\n        common_norm,\n        common_grid,\n        warn_singular,\n        fill,\n        color,\n        legend,\n        estimate_kws,\n        **plot_kws,\n    ):\n\n        # Handle conditional defaults\n        if fill is None:\n            fill = multiple in (\"stack\", \"fill\")\n\n        # Preprocess the matplotlib keyword dictionaries\n        if fill:\n            artist = mpl.collections.PolyCollection\n        else:\n            artist = mpl.lines.Line2D\n        plot_kws = _normalize_kwargs(plot_kws, artist)\n\n        # Input checking\n        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\"], multiple)\n\n        # Always share the evaluation grid when stacking\n        subsets = bool(set(self.variables) - {\"x\", \"y\"})\n        if subsets and multiple in (\"stack\", \"fill\"):\n            common_grid = True\n\n        # Check if the data axis is log scaled\n        log_scale = self._log_scaled(self.data_variable)\n\n        # Do the computation\n        densities = self._compute_univariate_density(\n            self.data_variable,\n            common_norm,\n            common_grid,\n            estimate_kws,\n            log_scale,\n            warn_singular,\n        )\n\n        # Adjust densities based on the `multiple` rule\n        densities, baselines = self._resolve_multiple(densities, multiple)\n\n        # Control the interaction with autoscaling by defining sticky_edges\n        # i.e. we don't want autoscale margins below the density curve\n        sticky_density = (0, 1) if multiple == \"fill\" else (0, np.inf)\n\n        if multiple == \"fill\":\n            # Filled plots should not have any margins\n            sticky_support = densities.index.min(), densities.index.max()\n        else:\n            sticky_support = []\n\n        if fill:\n            if multiple == \"layer\":\n                default_alpha = .25\n            else:\n                default_alpha = .75\n        else:\n            default_alpha = 1\n        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?\n\n        # Now iterate through the subsets and draw the densities\n        # We go backwards so stacked densities read from top-to-bottom\n        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):\n\n            # Extract the support grid and density curve for this level\n            key = tuple(sub_vars.items())\n            try:\n                density = densities[key]\n            except KeyError:\n                continue\n            support = density.index\n            fill_from = baselines[key]\n\n            ax = self._get_axes(sub_vars)\n\n            if \"hue\" in self.variables:\n                sub_color = self._hue_map(sub_vars[\"hue\"])\n            else:\n                sub_color = color\n\n            artist_kws = self._artist_kws(\n                plot_kws, fill, False, multiple, sub_color, alpha\n            )\n\n            # Either plot a curve with observation values on the x axis\n            if \"x\" in self.variables:\n\n                if fill:\n                    artist = ax.fill_between(support, fill_from, density, **artist_kws)\n\n                else:\n                    artist, = ax.plot(support, density, **artist_kws)\n\n                artist.sticky_edges.x[:] = sticky_support\n                artist.sticky_edges.y[:] = sticky_density\n\n            # Or plot a curve with observation values on the y axis\n            else:\n                if fill:\n                    artist = ax.fill_betweenx(support, fill_from, density, **artist_kws)\n                else:\n                    artist, = ax.plot(density, support, **artist_kws)\n\n                artist.sticky_edges.x[:] = sticky_density\n                artist.sticky_edges.y[:] = sticky_support\n\n        # --- Finalize the plot ----\n\n        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]\n        default_x = default_y = \"\"\n        if self.data_variable == \"x\":\n            default_y = \"Density\"\n        if self.data_variable == \"y\":\n            default_x = \"Density\"\n        self._add_axis_labels(ax, default_x, default_y)\n\n        if \"hue\" in self.variables and legend:\n\n            if fill:\n                artist = partial(mpl.patches.Patch)\n            else:\n                artist = partial(mpl.lines.Line2D, [], [])\n\n            ax_obj = self.ax if self.ax is not None else self.facets\n            self._add_legend(\n                ax_obj, artist, fill, False, multiple, alpha, plot_kws, {},\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_univariate_density", "self", "multiple", "common_norm", "common_grid", "warn_singular", "fill", "color", "legend", "estimate_kws", "plot_kws", "handle", "conditional", "defaults", "if", "fill", "is", "none", "fill", "multiple", "in", "stack", "fill", "preprocess", "the", "matplotlib", "keyword", "dictionaries", "if", "fill", "artist", "mpl", "collections", "polycollection", "else", "artist", "mpl", "lines", "line2d", "plot_kws", "_normalize_kwargs", "plot_kws", "artist", "input", "checking", "_check_argument", "multiple", "layer", "stack", "fill", "multiple", "always", "share", "the", "evaluation", "grid", "when", "stacking", "subsets", "bool", "set", "self", "variables", "x", "y", "if", "subsets", "and", "multiple", "in", "stack", "fill", "common_grid", "true", "check", "if", "the", "data", "axis", "is", "log", "scaled", "log_scale", "self", "_log_scaled", "self", "data_variable", "do", "the", "computation", "densities", "self", "_compute_univariate_density", "self", "data_variable", "common_norm", "common_grid", "estimate_kws", "log_scale", "warn_singular", "adjust", "densities", "based", "on", "the", "multiple", "rule", "densities", "baselines", "self", "_resolve_multiple", "densities", "multiple", "control", "the", "interaction", "with", "autoscaling", "by", "defining", "sticky_edges", "i", "e", "we", "don", "t", "want", "autoscale", "margins", "below", "the", "density", "curve", "sticky_density", "0", "1", "if", "multiple", "fill", "else", "0", "np", "inf", "if", "multiple", "fill", "filled", "plots", "should", "not", "have", "any", "margins", "sticky_support", "densities", "index", "min", "densities", "index", "max", "else", "sticky_support", "if", "fill", "if", "multiple", "layer", "default_alpha", "25", "else", "default_alpha", "75", "else", "default_alpha", "1", "alpha", "plot_kws", "pop", "alpha", "default_alpha", "todo", "make", "parameter", "now", "iterate", "through", "the", "subsets", "and", "draw", "the", "densities", "we", "go", "backwards", "so", "stacked", "densities", "read", "from", "top", "to", "bottom", "for", "sub_vars", "_", "in", "self", "iter_data", "hue", "reverse", "true", "extract", "the", "support", "grid", "and", "density", "curve", "for", "this", "level", "key", "tuple", "sub_vars", "items", "try", "density", "densities", "key", "except", "keyerror", "continue", "support", "density", "index", "fill_from", "baselines", "key", "ax", "self", "_get_axes", "sub_vars", "if", "hue", "in", "self", "variables", "sub_color", "self", "_hue_map", "sub_vars", "hue", "else", "sub_color", "color", "artist_kws", "self", "_artist_kws", "plot_kws", "fill", "false", "multiple", "sub_color", "alpha", "either", "plot", "a", "curve", "with", "observation", "values", "on", "the", "x", "axis", "if", "x", "in", "self", "variables", "if", "fill", "artist", "ax", "fill_between", "support", "fill_from", "density", "artist_kws", "else", "artist", "ax", "plot", "support", "density", "artist_kws", "artist", "sticky_edges", "x", "sticky_support", "artist", "sticky_edges", "y", "sticky_density", "or", "plot", "a", "curve", "with", "observation", "values", "on", "the", "y", "axis", "else", "if", "fill", "artist", "ax", "fill_betweenx", "support", "fill_from", "density", "artist_kws", "else", "artist", "ax", "plot", "density", "support", "artist_kws", "artist", "sticky_edges", "x", "sticky_density", "artist", "sticky_edges", "y", "sticky_support", "finalize", "the", "plot", "ax", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "axes", "flat", "0", "default_x", "default_y", "if", "self", "data_variable", "x", "default_y", "density", "if", "self", "data_variable", "y", "default_x", "density", "self", "_add_axis_labels", "ax", "default_x", "default_y", "if", "hue", "in", "self", "variables", "and", "legend", "if", "fill", "artist", "partial", "mpl", "patches", "patch", "else", "artist", "partial", "mpl", "lines", "line2d", "ax_obj", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "self", "_add_legend", "ax_obj", "artist", "fill", "false", "multiple", "alpha", "plot_kws"], "doc_len": 424}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_bivariate_density", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_bivariate_density", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_bivariate_density(\n        self,\n        common_norm,\n        fill,\n        levels,\n        thresh,\n        color,\n        legend,\n        cbar,\n        warn_singular,\n        cbar_ax,\n        cbar_kws,\n        estimate_kws,\n        **contour_kws,\n    ):\n\n        contour_kws = contour_kws.copy()\n\n        estimator = KDE(**estimate_kws)\n\n        if not set(self.variables) - {\"x\", \"y\"}:\n            common_norm = False\n\n        all_data = self.plot_data.dropna()\n\n        # Loop through the subsets and estimate the KDEs\n        densities, supports = {}, {}\n\n        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):\n\n            # Extract the data points from this sub set\n            observations = sub_data[[\"x\", \"y\"]]\n            min_variance = observations.var().fillna(0).min()\n            observations = observations[\"x\"], observations[\"y\"]\n\n            # Extract the weights for this subset of observations\n            if \"weights\" in self.variables:\n                weights = sub_data[\"weights\"]\n            else:\n                weights = None\n\n            # Estimate the density of observations at this level\n            singular = math.isclose(min_variance, 0)\n            try:\n                if not singular:\n                    density, support = estimator(*observations, weights=weights)\n            except np.linalg.LinAlgError:\n                # Testing for 0 variance doesn't catch all cases where scipy raises,\n                # but we can also get a ValueError, so we need this convoluted approach\n                singular = True\n\n            if singular:\n                msg = (\n                    \"KDE cannot be estimated (0 variance or perfect covariance). \"\n                    \"Pass `warn_singular=False` to disable this warning.\"\n                )\n                if warn_singular:\n                    warnings.warn(msg, UserWarning, stacklevel=3)\n                continue\n\n            # Transform the support grid back to the original scale\n            xx, yy = support\n            if self._log_scaled(\"x\"):\n                xx = np.power(10, xx)\n            if self._log_scaled(\"y\"):\n                yy = np.power(10, yy)\n            support = xx, yy\n\n            # Apply a scaling factor so that the integral over all subsets is 1\n            if common_norm:\n                density *= len(sub_data) / len(all_data)\n\n            key = tuple(sub_vars.items())\n            densities[key] = density\n            supports[key] = support\n\n        # Define a grid of iso-proportion levels\n        if thresh is None:\n            thresh = 0\n        if isinstance(levels, Number):\n            levels = np.linspace(thresh, 1, levels)\n        else:\n            if min(levels) < 0 or max(levels) > 1:\n                raise ValueError(\"levels must be in [0, 1]\")\n\n        # Transform from iso-proportions to iso-densities\n        if common_norm:\n            common_levels = self._quantile_to_level(\n                list(densities.values()), levels,\n            )\n            draw_levels = {k: common_levels for k in densities}\n        else:\n            draw_levels = {\n                k: self._quantile_to_level(d, levels)\n                for k, d in densities.items()\n            }\n\n        # Define the coloring of the contours\n        if \"hue\" in self.variables:\n            for param in [\"cmap\", \"colors\"]:\n                if param in contour_kws:\n                    msg = f\"{param} parameter ignored when using hue mapping.\"\n                    warnings.warn(msg, UserWarning)\n                    contour_kws.pop(param)\n        else:\n\n            # Work out a default coloring of the contours\n            coloring_given = set(contour_kws) & {\"cmap\", \"colors\"}\n            if fill and not coloring_given:\n                cmap = self._cmap_from_color(color)\n                contour_kws[\"cmap\"] = cmap\n            if not fill and not coloring_given:\n                contour_kws[\"colors\"] = [color]\n\n            # Use our internal colormap lookup\n            cmap = contour_kws.pop(\"cmap\", None)\n            if isinstance(cmap, str):\n                cmap = color_palette(cmap, as_cmap=True)\n            if cmap is not None:\n                contour_kws[\"cmap\"] = cmap\n\n        # Loop through the subsets again and plot the data\n        for sub_vars, _ in self.iter_data(\"hue\"):\n\n            if \"hue\" in sub_vars:\n                color = self._hue_map(sub_vars[\"hue\"])\n                if fill:\n                    contour_kws[\"cmap\"] = self._cmap_from_color(color)\n                else:\n                    contour_kws[\"colors\"] = [color]\n\n            ax = self._get_axes(sub_vars)\n\n            # Choose the function to plot with\n            # TODO could add a pcolormesh based option as well\n            # Which would look something like element=\"raster\"\n            if fill:\n                contour_func = ax.contourf\n            else:\n                contour_func = ax.contour\n\n            key = tuple(sub_vars.items())\n            if key not in densities:\n                continue\n            density = densities[key]\n            xx, yy = supports[key]\n\n            label = contour_kws.pop(\"label\", None)\n\n            cset = contour_func(\n                xx, yy, density,\n                levels=draw_levels[key],\n                **contour_kws,\n            )\n\n            if \"hue\" not in self.variables:\n                cset.collections[0].set_label(label)\n\n            # Add a color bar representing the contour heights\n            # Note: this shows iso densities, not iso proportions\n            # See more notes in histplot about how this could be improved\n            if cbar:\n                cbar_kws = {} if cbar_kws is None else cbar_kws\n                ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)\n\n        # --- Finalize the plot\n        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]\n        self._add_axis_labels(ax)\n\n        if \"hue\" in self.variables and legend:\n\n            # TODO if possible, I would like to move the contour\n            # intensity information into the legend too and label the\n            # iso proportions rather than the raw density values\n\n            artist_kws = {}\n            if fill:\n                artist = partial(mpl.patches.Patch)\n            else:\n                artist = partial(mpl.lines.Line2D, [], [])\n\n            ax_obj = self.ax if self.ax is not None else self.facets\n            self._add_legend(\n                ax_obj, artist, fill, False, \"layer\", 1, artist_kws, {},\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_bivariate_density", "self", "common_norm", "fill", "levels", "thresh", "color", "legend", "cbar", "warn_singular", "cbar_ax", "cbar_kws", "estimate_kws", "contour_kws", "contour_kws", "contour_kws", "copy", "estimator", "kde", "estimate_kws", "if", "not", "set", "self", "variables", "x", "y", "common_norm", "false", "all_data", "self", "plot_data", "dropna", "loop", "through", "the", "subsets", "and", "estimate", "the", "kdes", "densities", "supports", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "hue", "from_comp_data", "true", "extract", "the", "data", "points", "from", "this", "sub", "set", "observations", "sub_data", "x", "y", "min_variance", "observations", "var", "fillna", "0", "min", "observations", "observations", "x", "observations", "y", "extract", "the", "weights", "for", "this", "subset", "of", "observations", "if", "weights", "in", "self", "variables", "weights", "sub_data", "weights", "else", "weights", "none", "estimate", "the", "density", "of", "observations", "at", "this", "level", "singular", "math", "isclose", "min_variance", "0", "try", "if", "not", "singular", "density", "support", "estimator", "observations", "weights", "weights", "except", "np", "linalg", "linalgerror", "testing", "for", "0", "variance", "doesn", "t", "catch", "all", "cases", "where", "scipy", "raises", "but", "we", "can", "also", "get", "a", "valueerror", "so", "we", "need", "this", "convoluted", "approach", "singular", "true", "if", "singular", "msg", "kde", "cannot", "be", "estimated", "0", "variance", "or", "perfect", "covariance", "pass", "warn_singular", "false", "to", "disable", "this", "warning", "if", "warn_singular", "warnings", "warn", "msg", "userwarning", "stacklevel", "3", "continue", "transform", "the", "support", "grid", "back", "to", "the", "original", "scale", "xx", "yy", "support", "if", "self", "_log_scaled", "x", "xx", "np", "power", "10", "xx", "if", "self", "_log_scaled", "y", "yy", "np", "power", "10", "yy", "support", "xx", "yy", "apply", "a", "scaling", "factor", "so", "that", "the", "integral", "over", "all", "subsets", "is", "1", "if", "common_norm", "density", "len", "sub_data", "len", "all_data", "key", "tuple", "sub_vars", "items", "densities", "key", "density", "supports", "key", "support", "define", "a", "grid", "of", "iso", "proportion", "levels", "if", "thresh", "is", "none", "thresh", "0", "if", "isinstance", "levels", "number", "levels", "np", "linspace", "thresh", "1", "levels", "else", "if", "min", "levels", "0", "or", "max", "levels", "1", "raise", "valueerror", "levels", "must", "be", "in", "0", "1", "transform", "from", "iso", "proportions", "to", "iso", "densities", "if", "common_norm", "common_levels", "self", "_quantile_to_level", "list", "densities", "values", "levels", "draw_levels", "k", "common_levels", "for", "k", "in", "densities", "else", "draw_levels", "k", "self", "_quantile_to_level", "d", "levels", "for", "k", "d", "in", "densities", "items", "define", "the", "coloring", "of", "the", "contours", "if", "hue", "in", "self", "variables", "for", "param", "in", "cmap", "colors", "if", "param", "in", "contour_kws", "msg", "f", "param", "parameter", "ignored", "when", "using", "hue", "mapping", "warnings", "warn", "msg", "userwarning", "contour_kws", "pop", "param", "else", "work", "out", "a", "default", "coloring", "of", "the", "contours", "coloring_given", "set", "contour_kws", "cmap", "colors", "if", "fill", "and", "not", "coloring_given", "cmap", "self", "_cmap_from_color", "color", "contour_kws", "cmap", "cmap", "if", "not", "fill", "and", "not", "coloring_given", "contour_kws", "colors", "color", "use", "our", "internal", "colormap", "lookup", "cmap", "contour_kws", "pop", "cmap", "none", "if", "isinstance", "cmap", "str", "cmap", "color_palette", "cmap", "as_cmap", "true", "if", "cmap", "is", "not", "none", "contour_kws", "cmap", "cmap", "loop", "through", "the", "subsets", "again", "and", "plot", "the", "data", "for", "sub_vars", "_", "in", "self", "iter_data", "hue", "if", "hue", "in", "sub_vars", "color", "self", "_hue_map", "sub_vars", "hue", "if", "fill", "contour_kws", "cmap", "self", "_cmap_from_color", "color", "else", "contour_kws", "colors", "color", "ax", "self", "_get_axes", "sub_vars", "choose", "the", "function", "to", "plot", "with", "todo", "could", "add", "a", "pcolormesh", "based", "option", "as", "well", "which", "would", "look", "something", "like", "element", "raster", "if", "fill", "contour_func", "ax", "contourf", "else", "contour_func", "ax", "contour", "key", "tuple", "sub_vars", "items", "if", "key", "not", "in", "densities", "continue", "density", "densities", "key", "xx", "yy", "supports", "key", "label", "contour_kws", "pop", "label", "none", "cset", "contour_func", "xx", "yy", "density", "levels", "draw_levels", "key", "contour_kws", "if", "hue", "not", "in", "self", "variables", "cset", "collections", "0", "set_label", "label", "add", "a", "color", "bar", "representing", "the", "contour", "heights", "note", "this", "shows", "iso", "densities", "not", "iso", "proportions", "see", "more", "notes", "in", "histplot", "about", "how", "this", "could", "be", "improved", "if", "cbar", "cbar_kws", "if", "cbar_kws", "is", "none", "else", "cbar_kws", "ax", "figure", "colorbar", "cset", "cbar_ax", "ax", "cbar_kws", "finalize", "the", "plot", "ax", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "axes", "flat", "0", "self", "_add_axis_labels", "ax", "if", "hue", "in", "self", "variables", "and", "legend", "todo", "if", "possible", "i", "would", "like", "to", "move", "the", "contour", "intensity", "information", "into", "the", "legend", "too", "and", "label", "the", "iso", "proportions", "rather", "than", "the", "raw", "density", "values", "artist_kws", "if", "fill", "artist", "partial", "mpl", "patches", "patch", "else", "artist", "partial", "mpl", "lines", "line2d", "ax_obj", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "self", "_add_legend", "ax_obj", "artist", "fill", "false", "layer", "1", "artist_kws"], "doc_len": 664}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_univariate_ecdf", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_univariate_ecdf", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):\n\n        estimator = ECDF(**estimate_kws)\n\n        # Set the draw style to step the right way for the data variable\n        drawstyles = dict(x=\"steps-post\", y=\"steps-pre\")\n        plot_kws[\"drawstyle\"] = drawstyles[self.data_variable]\n\n        # Loop through the subsets, transform and plot the data\n        for sub_vars, sub_data in self.iter_data(\n            \"hue\", reverse=True, from_comp_data=True,\n        ):\n\n            # Compute the ECDF\n            if sub_data.empty:\n                continue\n\n            observations = sub_data[self.data_variable]\n            weights = sub_data.get(\"weights\", None)\n            stat, vals = estimator(observations, weights=weights)\n\n            # Assign attributes based on semantic mapping\n            artist_kws = plot_kws.copy()\n            if \"hue\" in self.variables:\n                artist_kws[\"color\"] = self._hue_map(sub_vars[\"hue\"])\n\n            # Return the data variable to the linear domain\n            # This needs an automatic solution; see GH2409\n            if self._log_scaled(self.data_variable):\n                vals = np.power(10, vals)\n                vals[0] = -np.inf\n\n            # Work out the orientation of the plot\n            if self.data_variable == \"x\":\n                plot_args = vals, stat\n                stat_variable = \"y\"\n            else:\n                plot_args = stat, vals\n                stat_variable = \"x\"\n\n            if estimator.stat == \"count\":\n                top_edge = len(observations)\n            else:\n                top_edge = 1\n\n            # Draw the line for this subset\n            ax = self._get_axes(sub_vars)\n            artist, = ax.plot(*plot_args, **artist_kws)\n            sticky_edges = getattr(artist.sticky_edges, stat_variable)\n            sticky_edges[:] = 0, top_edge\n\n        # --- Finalize the plot ----\n        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]\n        stat = estimator.stat.capitalize()\n        default_x = default_y = \"\"\n        if self.data_variable == \"x\":\n            default_y = stat\n        if self.data_variable == \"y\":\n            default_x = stat\n        self._add_axis_labels(ax, default_x, default_y)\n\n        if \"hue\" in self.variables and legend:\n            artist = partial(mpl.lines.Line2D, [], [])\n            alpha = plot_kws.get(\"alpha\", 1)\n            ax_obj = self.ax if self.ax is not None else self.facets\n            self._add_legend(\n                ax_obj, artist, False, False, None, alpha, plot_kws, {},\n            )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_univariate_ecdf", "self", "estimate_kws", "legend", "plot_kws", "estimator", "ecdf", "estimate_kws", "set", "the", "draw", "style", "to", "step", "the", "right", "way", "for", "the", "data", "variable", "drawstyles", "dict", "x", "steps", "post", "y", "steps", "pre", "plot_kws", "drawstyle", "drawstyles", "self", "data_variable", "loop", "through", "the", "subsets", "transform", "and", "plot", "the", "data", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "hue", "reverse", "true", "from_comp_data", "true", "compute", "the", "ecdf", "if", "sub_data", "empty", "continue", "observations", "sub_data", "self", "data_variable", "weights", "sub_data", "get", "weights", "none", "stat", "vals", "estimator", "observations", "weights", "weights", "assign", "attributes", "based", "on", "semantic", "mapping", "artist_kws", "plot_kws", "copy", "if", "hue", "in", "self", "variables", "artist_kws", "color", "self", "_hue_map", "sub_vars", "hue", "return", "the", "data", "variable", "to", "the", "linear", "domain", "this", "needs", "an", "automatic", "solution", "see", "gh2409", "if", "self", "_log_scaled", "self", "data_variable", "vals", "np", "power", "10", "vals", "vals", "0", "np", "inf", "work", "out", "the", "orientation", "of", "the", "plot", "if", "self", "data_variable", "x", "plot_args", "vals", "stat", "stat_variable", "y", "else", "plot_args", "stat", "vals", "stat_variable", "x", "if", "estimator", "stat", "count", "top_edge", "len", "observations", "else", "top_edge", "1", "draw", "the", "line", "for", "this", "subset", "ax", "self", "_get_axes", "sub_vars", "artist", "ax", "plot", "plot_args", "artist_kws", "sticky_edges", "getattr", "artist", "sticky_edges", "stat_variable", "sticky_edges", "0", "top_edge", "finalize", "the", "plot", "ax", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "axes", "flat", "0", "stat", "estimator", "stat", "capitalize", "default_x", "default_y", "if", "self", "data_variable", "x", "default_y", "stat", "if", "self", "data_variable", "y", "default_x", "stat", "self", "_add_axis_labels", "ax", "default_x", "default_y", "if", "hue", "in", "self", "variables", "and", "legend", "artist", "partial", "mpl", "lines", "line2d", "alpha", "plot_kws", "get", "alpha", "1", "ax_obj", "self", "ax", "if", "self", "ax", "is", "not", "none", "else", "self", "facets", "self", "_add_legend", "ax_obj", "artist", "false", "false", "none", "alpha", "plot_kws"], "doc_len": 264}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter.plot_rug", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "plot_rug", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def plot_rug(self, height, expand_margins, legend, **kws):\n\n        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):\n\n            ax = self._get_axes(sub_vars)\n\n            kws.setdefault(\"linewidth\", 1)\n\n            if expand_margins:\n                xmarg, ymarg = ax.margins()\n                if \"x\" in self.variables:\n                    ymarg += height * 2\n                if \"y\" in self.variables:\n                    xmarg += height * 2\n                ax.margins(x=xmarg, y=ymarg)\n\n            if \"hue\" in self.variables:\n                kws.pop(\"c\", None)\n                kws.pop(\"color\", None)\n\n            if \"x\" in self.variables:\n                self._plot_single_rug(sub_data, \"x\", height, ax, kws)\n            if \"y\" in self.variables:\n                self._plot_single_rug(sub_data, \"y\", height, ax, kws)\n\n            # --- Finalize the plot\n            self._add_axis_labels(ax)\n            if \"hue\" in self.variables and legend:\n                # TODO ideally i'd like the legend artist to look like a rug\n                legend_artist = partial(mpl.lines.Line2D, [], [])\n                self._add_legend(\n                    ax, legend_artist, False, False, None, 1, {}, {},\n                )\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "plot_rug", "self", "height", "expand_margins", "legend", "kws", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "from_comp_data", "true", "ax", "self", "_get_axes", "sub_vars", "kws", "setdefault", "linewidth", "1", "if", "expand_margins", "xmarg", "ymarg", "ax", "margins", "if", "x", "in", "self", "variables", "ymarg", "height", "2", "if", "y", "in", "self", "variables", "xmarg", "height", "2", "ax", "margins", "x", "xmarg", "y", "ymarg", "if", "hue", "in", "self", "variables", "kws", "pop", "c", "none", "kws", "pop", "color", "none", "if", "x", "in", "self", "variables", "self", "_plot_single_rug", "sub_data", "x", "height", "ax", "kws", "if", "y", "in", "self", "variables", "self", "_plot_single_rug", "sub_data", "y", "height", "ax", "kws", "finalize", "the", "plot", "self", "_add_axis_labels", "ax", "if", "hue", "in", "self", "variables", "and", "legend", "todo", "ideally", "i", "d", "like", "the", "legend", "artist", "to", "look", "like", "a", "rug", "legend_artist", "partial", "mpl", "lines", "line2d", "self", "_add_legend", "ax", "legend_artist", "false", "false", "none", "1"], "doc_len": 131}
{"doc_id": "seaborn/distributions.py::_DistributionPlotter._plot_single_rug", "file_path": "seaborn/distributions.py", "class_name": "_DistributionPlotter", "func_name": "_plot_single_rug", "text": "文件路径: seaborn/distributions.py, 类名: _DistributionPlotter\n    def _plot_single_rug(self, sub_data, var, height, ax, kws):\n        \"\"\"Draw a rugplot along one axis of the plot.\"\"\"\n        vector = sub_data[var]\n        n = len(vector)\n\n        # Return data to linear domain\n        # This needs an automatic solution; see GH2409\n        if self._log_scaled(var):\n            vector = np.power(10, vector)\n\n        # We'll always add a single collection with varying colors\n        if \"hue\" in self.variables:\n            colors = self._hue_map(sub_data[\"hue\"])\n        else:\n            colors = None\n\n        # Build the array of values for the LineCollection\n        if var == \"x\":\n\n            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)\n            xy_pairs = np.column_stack([\n                np.repeat(vector, 2), np.tile([0, height], n)\n            ])\n\n        if var == \"y\":\n\n            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)\n            xy_pairs = np.column_stack([\n                np.tile([0, height], n), np.repeat(vector, 2)\n            ])\n\n        # Draw the lines on the plot\n        line_segs = xy_pairs.reshape([n, 2, 2])\n        ax.add_collection(LineCollection(\n            line_segs, transform=trans, colors=colors, **kws\n        ))\n\n        ax.autoscale_view(scalex=var == \"x\", scaley=var == \"y\")\n", "tokens": ["seaborn", "distributions", "py", "_distributionplotter", "def", "_plot_single_rug", "self", "sub_data", "var", "height", "ax", "kws", "draw", "a", "rugplot", "along", "one", "axis", "of", "the", "plot", "vector", "sub_data", "var", "n", "len", "vector", "return", "data", "to", "linear", "domain", "this", "needs", "an", "automatic", "solution", "see", "gh2409", "if", "self", "_log_scaled", "var", "vector", "np", "power", "10", "vector", "we", "ll", "always", "add", "a", "single", "collection", "with", "varying", "colors", "if", "hue", "in", "self", "variables", "colors", "self", "_hue_map", "sub_data", "hue", "else", "colors", "none", "build", "the", "array", "of", "values", "for", "the", "linecollection", "if", "var", "x", "trans", "tx", "blended_transform_factory", "ax", "transdata", "ax", "transaxes", "xy_pairs", "np", "column_stack", "np", "repeat", "vector", "2", "np", "tile", "0", "height", "n", "if", "var", "y", "trans", "tx", "blended_transform_factory", "ax", "transaxes", "ax", "transdata", "xy_pairs", "np", "column_stack", "np", "tile", "0", "height", "n", "np", "repeat", "vector", "2", "draw", "the", "lines", "on", "the", "plot", "line_segs", "xy_pairs", "reshape", "n", "2", "2", "ax", "add_collection", "linecollection", "line_segs", "transform", "trans", "colors", "colors", "kws", "ax", "autoscale_view", "scalex", "var", "x", "scaley", "var", "y"], "doc_len": 152}
{"doc_id": "seaborn/distributions.py::histplot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "histplot", "text": "文件路径: seaborn/distributions.py\ndef histplot(\n    data=None, *,\n    # Vector variables\n    x=None, y=None, hue=None, weights=None,\n    # Histogram computation parameters\n    stat=\"count\", bins=\"auto\", binwidth=None, binrange=None,\n    discrete=None, cumulative=False, common_bins=True, common_norm=True,\n    # Histogram appearance parameters\n    multiple=\"layer\", element=\"bars\", fill=True, shrink=1,\n    # Histogram smoothing with a kernel density estimate\n    kde=False, kde_kws=None, line_kws=None,\n    # Bivariate histogram parameters\n    thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None, cbar_kws=None,\n    # Hue mapping parameters\n    palette=None, hue_order=None, hue_norm=None, color=None,\n    # Axes information\n    log_scale=None, legend=True, ax=None,\n    # Other appearance keywords\n    **kwargs,\n):\n\n    p = _DistributionPlotter(\n        data=data,\n        variables=_DistributionPlotter.get_semantics(locals())\n    )\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    if ax is None:\n        ax = plt.gca()\n\n    p._attach(ax, log_scale=log_scale)\n\n    if p.univariate:  # Note, bivariate plots won't cycle\n        if fill:\n            method = ax.bar if element == \"bars\" else ax.fill_between\n        else:\n            method = ax.plot\n        color = _default_color(method, hue, color, kwargs)\n\n    if not p.has_xy_data:\n        return ax\n\n    # Default to discrete bins for categorical variables\n    if discrete is None:\n        discrete = p._default_discrete()\n\n    estimate_kws = dict(\n        stat=stat,\n        bins=bins,\n        binwidth=binwidth,\n        binrange=binrange,\n        discrete=discrete,\n        cumulative=cumulative,\n    )\n\n    if p.univariate:\n\n        p.plot_univariate_histogram(\n            multiple=multiple,\n            element=element,\n            fill=fill,\n            shrink=shrink,\n            common_norm=common_norm,\n            common_bins=common_bins,\n            kde=kde,\n            kde_kws=kde_kws,\n            color=color,\n            legend=legend,\n            estimate_kws=estimate_kws,\n            line_kws=line_kws,\n            **kwargs,\n        )\n\n    else:\n\n        p.plot_bivariate_histogram(\n            common_bins=common_bins,\n            common_norm=common_norm,\n            thresh=thresh,\n            pthresh=pthresh,\n            pmax=pmax,\n            color=color,\n            legend=legend,\n            cbar=cbar,\n            cbar_ax=cbar_ax,\n            cbar_kws=cbar_kws,\n            estimate_kws=estimate_kws,\n            **kwargs,\n        )\n\n    return ax\n", "tokens": ["seaborn", "distributions", "py", "def", "histplot", "data", "none", "vector", "variables", "x", "none", "y", "none", "hue", "none", "weights", "none", "histogram", "computation", "parameters", "stat", "count", "bins", "auto", "binwidth", "none", "binrange", "none", "discrete", "none", "cumulative", "false", "common_bins", "true", "common_norm", "true", "histogram", "appearance", "parameters", "multiple", "layer", "element", "bars", "fill", "true", "shrink", "1", "histogram", "smoothing", "with", "a", "kernel", "density", "estimate", "kde", "false", "kde_kws", "none", "line_kws", "none", "bivariate", "histogram", "parameters", "thresh", "0", "pthresh", "none", "pmax", "none", "cbar", "false", "cbar_ax", "none", "cbar_kws", "none", "hue", "mapping", "parameters", "palette", "none", "hue_order", "none", "hue_norm", "none", "color", "none", "axes", "information", "log_scale", "none", "legend", "true", "ax", "none", "other", "appearance", "keywords", "kwargs", "p", "_distributionplotter", "data", "data", "variables", "_distributionplotter", "get_semantics", "locals", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "if", "ax", "is", "none", "ax", "plt", "gca", "p", "_attach", "ax", "log_scale", "log_scale", "if", "p", "univariate", "note", "bivariate", "plots", "won", "t", "cycle", "if", "fill", "method", "ax", "bar", "if", "element", "bars", "else", "ax", "fill_between", "else", "method", "ax", "plot", "color", "_default_color", "method", "hue", "color", "kwargs", "if", "not", "p", "has_xy_data", "return", "ax", "default", "to", "discrete", "bins", "for", "categorical", "variables", "if", "discrete", "is", "none", "discrete", "p", "_default_discrete", "estimate_kws", "dict", "stat", "stat", "bins", "bins", "binwidth", "binwidth", "binrange", "binrange", "discrete", "discrete", "cumulative", "cumulative", "if", "p", "univariate", "p", "plot_univariate_histogram", "multiple", "multiple", "element", "element", "fill", "fill", "shrink", "shrink", "common_norm", "common_norm", "common_bins", "common_bins", "kde", "kde", "kde_kws", "kde_kws", "color", "color", "legend", "legend", "estimate_kws", "estimate_kws", "line_kws", "line_kws", "kwargs", "else", "p", "plot_bivariate_histogram", "common_bins", "common_bins", "common_norm", "common_norm", "thresh", "thresh", "pthresh", "pthresh", "pmax", "pmax", "color", "color", "legend", "legend", "cbar", "cbar", "cbar_ax", "cbar_ax", "cbar_kws", "cbar_kws", "estimate_kws", "estimate_kws", "kwargs", "return", "ax"], "doc_len": 248}
{"doc_id": "seaborn/distributions.py::kdeplot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "kdeplot", "text": "文件路径: seaborn/distributions.py\ndef kdeplot(\n    data=None, *, x=None, y=None, hue=None, weights=None,\n    palette=None, hue_order=None, hue_norm=None, color=None, fill=None,\n    multiple=\"layer\", common_norm=True, common_grid=False, cumulative=False,\n    bw_method=\"scott\", bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=.05, gridsize=200, cut=3, clip=None,\n    legend=True, cbar=False, cbar_ax=None, cbar_kws=None, ax=None,\n    **kwargs,\n):\n\n    # --- Start with backwards compatability for versions < 0.11.0 ----------------\n\n    # Handle (past) deprecation of `data2`\n    if \"data2\" in kwargs:\n        msg = \"`data2` has been removed (replaced by `y`); please update your code.\"\n        TypeError(msg)\n\n    # Handle deprecation of `vertical`\n    vertical = kwargs.pop(\"vertical\", None)\n    if vertical is not None:\n        if vertical:\n            action_taken = \"assigning data to `y`.\"\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = \"assigning data to `x`.\"\n        msg = textwrap.dedent(f\"\"\"\\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.13.0; please update your code.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    # Handle deprecation of `bw`\n    bw = kwargs.pop(\"bw\", None)\n    if bw is not None:\n        msg = textwrap.dedent(f\"\"\"\\n\n        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.\n        Setting `bw_method={bw}`, but please see the docs for the new parameters\n        and update your code. This will become an error in seaborn v0.13.0.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n        bw_method = bw\n\n    # Handle deprecation of `kernel`\n    if kwargs.pop(\"kernel\", None) is not None:\n        msg = textwrap.dedent(\"\"\"\\n\n        Support for alternate kernels has been removed; using Gaussian kernel.\n        This will become an error in seaborn v0.13.0; please update your code.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    # Handle deprecation of shade_lowest\n    shade_lowest = kwargs.pop(\"shade_lowest\", None)\n    if shade_lowest is not None:\n        if shade_lowest:\n            thresh = 0\n        msg = textwrap.dedent(f\"\"\"\\n\n        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.\n        This will become an error in seaborn v0.13.0; please update your code.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    # Handle \"soft\" deprecation of shade `shade` is not really the right\n    # terminology here, but unlike some of the other deprecated parameters it\n    # is probably very commonly used and much hard to remove. This is therefore\n    # going to be a longer process where, first, `fill` will be introduced and\n    # be used throughout the documentation. In 0.12, when kwarg-only\n    # enforcement hits, we can remove the shade/shade_lowest out of the\n    # function signature all together and pull them out of the kwargs. Then we\n    # can actually fire a FutureWarning, and eventually remove.\n    shade = kwargs.pop(\"shade\", None)\n    if shade is not None:\n        fill = shade\n        msg = textwrap.dedent(f\"\"\"\\n\n        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\")\n        warnings.warn(msg, FutureWarning, stacklevel=2)\n\n    # Handle `n_levels`\n    # This was never in the formal API but it was processed, and appeared in an\n    # example. We can treat as an alias for `levels` now and deprecate later.\n    levels = kwargs.pop(\"n_levels\", levels)\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #\n\n    p = _DistributionPlotter(\n        data=data,\n        variables=_DistributionPlotter.get_semantics(locals()),\n    )\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    if ax is None:\n        ax = plt.gca()\n\n    p._attach(ax, allowed_types=[\"numeric\", \"datetime\"], log_scale=log_scale)\n\n    method = ax.fill_between if fill else ax.plot\n    color = _default_color(method, hue, color, kwargs)\n\n    if not p.has_xy_data:\n        return ax\n\n    # Pack the kwargs for statistics.KDE\n    estimate_kws = dict(\n        bw_method=bw_method,\n        bw_adjust=bw_adjust,\n        gridsize=gridsize,\n        cut=cut,\n        clip=clip,\n        cumulative=cumulative,\n    )\n\n    if p.univariate:\n\n        plot_kws = kwargs.copy()\n\n        p.plot_univariate_density(\n            multiple=multiple,\n            common_norm=common_norm,\n            common_grid=common_grid,\n            fill=fill,\n            color=color,\n            legend=legend,\n            warn_singular=warn_singular,\n            estimate_kws=estimate_kws,\n            **plot_kws,\n        )\n\n    else:\n\n        p.plot_bivariate_density(\n            common_norm=common_norm,\n            fill=fill,\n            levels=levels,\n            thresh=thresh,\n            legend=legend,\n            color=color,\n            warn_singular=warn_singular,\n            cbar=cbar,\n            cbar_ax=cbar_ax,\n            cbar_kws=cbar_kws,\n            estimate_kws=estimate_kws,\n            **kwargs,\n        )\n\n    return ax\n", "tokens": ["seaborn", "distributions", "py", "def", "kdeplot", "data", "none", "x", "none", "y", "none", "hue", "none", "weights", "none", "palette", "none", "hue_order", "none", "hue_norm", "none", "color", "none", "fill", "none", "multiple", "layer", "common_norm", "true", "common_grid", "false", "cumulative", "false", "bw_method", "scott", "bw_adjust", "1", "warn_singular", "true", "log_scale", "none", "levels", "10", "thresh", "05", "gridsize", "200", "cut", "3", "clip", "none", "legend", "true", "cbar", "false", "cbar_ax", "none", "cbar_kws", "none", "ax", "none", "kwargs", "start", "with", "backwards", "compatability", "for", "versions", "0", "11", "0", "handle", "past", "deprecation", "of", "data2", "if", "data2", "in", "kwargs", "msg", "data2", "has", "been", "removed", "replaced", "by", "y", "please", "update", "your", "code", "typeerror", "msg", "handle", "deprecation", "of", "vertical", "vertical", "kwargs", "pop", "vertical", "none", "if", "vertical", "is", "not", "none", "if", "vertical", "action_taken", "assigning", "data", "to", "y", "if", "x", "is", "none", "data", "y", "y", "data", "else", "x", "y", "y", "x", "else", "action_taken", "assigning", "data", "to", "x", "msg", "textwrap", "dedent", "f", "n", "the", "vertical", "parameter", "is", "deprecated", "action_taken", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "please", "update", "your", "code", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "handle", "deprecation", "of", "bw", "bw", "kwargs", "pop", "bw", "none", "if", "bw", "is", "not", "none", "msg", "textwrap", "dedent", "f", "n", "the", "bw", "parameter", "is", "deprecated", "in", "favor", "of", "bw_method", "and", "bw_adjust", "setting", "bw_method", "bw", "but", "please", "see", "the", "docs", "for", "the", "new", "parameters", "and", "update", "your", "code", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "bw_method", "bw", "handle", "deprecation", "of", "kernel", "if", "kwargs", "pop", "kernel", "none", "is", "not", "none", "msg", "textwrap", "dedent", "n", "support", "for", "alternate", "kernels", "has", "been", "removed", "using", "gaussian", "kernel", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "please", "update", "your", "code", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "handle", "deprecation", "of", "shade_lowest", "shade_lowest", "kwargs", "pop", "shade_lowest", "none", "if", "shade_lowest", "is", "not", "none", "if", "shade_lowest", "thresh", "0", "msg", "textwrap", "dedent", "f", "n", "shade_lowest", "has", "been", "replaced", "by", "thresh", "setting", "thresh", "thresh", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "please", "update", "your", "code", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "handle", "soft", "deprecation", "of", "shade", "shade", "is", "not", "really", "the", "right", "terminology", "here", "but", "unlike", "some", "of", "the", "other", "deprecated", "parameters", "it", "is", "probably", "very", "commonly", "used", "and", "much", "hard", "to", "remove", "this", "is", "therefore", "going", "to", "be", "a", "longer", "process", "where", "first", "fill", "will", "be", "introduced", "and", "be", "used", "throughout", "the", "documentation", "in", "0", "12", "when", "kwarg", "only", "enforcement", "hits", "we", "can", "remove", "the", "shade", "shade_lowest", "out", "of", "the", "function", "signature", "all", "together", "and", "pull", "them", "out", "of", "the", "kwargs", "then", "we", "can", "actually", "fire", "a", "futurewarning", "and", "eventually", "remove", "shade", "kwargs", "pop", "shade", "none", "if", "shade", "is", "not", "none", "fill", "shade", "msg", "textwrap", "dedent", "f", "n", "shade", "is", "now", "deprecated", "in", "favor", "of", "fill", "setting", "fill", "shade", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "14", "0", "please", "update", "your", "code", "warnings", "warn", "msg", "futurewarning", "stacklevel", "2", "handle", "n_levels", "this", "was", "never", "in", "the", "formal", "api", "but", "it", "was", "processed", "and", "appeared", "in", "an", "example", "we", "can", "treat", "as", "an", "alias", "for", "levels", "now", "and", "deprecate", "later", "levels", "kwargs", "pop", "n_levels", "levels", "p", "_distributionplotter", "data", "data", "variables", "_distributionplotter", "get_semantics", "locals", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "if", "ax", "is", "none", "ax", "plt", "gca", "p", "_attach", "ax", "allowed_types", "numeric", "datetime", "log_scale", "log_scale", "method", "ax", "fill_between", "if", "fill", "else", "ax", "plot", "color", "_default_color", "method", "hue", "color", "kwargs", "if", "not", "p", "has_xy_data", "return", "ax", "pack", "the", "kwargs", "for", "statistics", "kde", "estimate_kws", "dict", "bw_method", "bw_method", "bw_adjust", "bw_adjust", "gridsize", "gridsize", "cut", "cut", "clip", "clip", "cumulative", "cumulative", "if", "p", "univariate", "plot_kws", "kwargs", "copy", "p", "plot_univariate_density", "multiple", "multiple", "common_norm", "common_norm", "common_grid", "common_grid", "fill", "fill", "color", "color", "legend", "legend", "warn_singular", "warn_singular", "estimate_kws", "estimate_kws", "plot_kws", "else", "p", "plot_bivariate_density", "common_norm", "common_norm", "fill", "fill", "levels", "levels", "thresh", "thresh", "legend", "legend", "color", "color", "warn_singular", "warn_singular", "cbar", "cbar", "cbar_ax", "cbar_ax", "cbar_kws", "cbar_kws", "estimate_kws", "estimate_kws", "kwargs", "return", "ax"], "doc_len": 625}
{"doc_id": "seaborn/distributions.py::ecdfplot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "ecdfplot", "text": "文件路径: seaborn/distributions.py\ndef ecdfplot(\n    data=None, *,\n    # Vector variables\n    x=None, y=None, hue=None, weights=None,\n    # Computation parameters\n    stat=\"proportion\", complementary=False,\n    # Hue mapping parameters\n    palette=None, hue_order=None, hue_norm=None,\n    # Axes information\n    log_scale=None, legend=True, ax=None,\n    # Other appearance keywords\n    **kwargs,\n):\n\n    p = _DistributionPlotter(\n        data=data,\n        variables=_DistributionPlotter.get_semantics(locals())\n    )\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    # We could support other semantics (size, style) here fairly easily\n    # But it would make distplot a bit more complicated.\n    # It's always possible to add features like that later, so I am going to defer.\n    # It will be even easier to wait until after there is a more general/abstract\n    # way to go from semantic specs to artist attributes.\n\n    if ax is None:\n        ax = plt.gca()\n\n    p._attach(ax, log_scale=log_scale)\n\n    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n\n    if not p.has_xy_data:\n        return ax\n\n    # We could add this one day, but it's of dubious value\n    if not p.univariate:\n        raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")\n\n    estimate_kws = dict(\n        stat=stat,\n        complementary=complementary,\n    )\n\n    p.plot_univariate_ecdf(\n        estimate_kws=estimate_kws,\n        legend=legend,\n        **kwargs,\n    )\n\n    return ax\n", "tokens": ["seaborn", "distributions", "py", "def", "ecdfplot", "data", "none", "vector", "variables", "x", "none", "y", "none", "hue", "none", "weights", "none", "computation", "parameters", "stat", "proportion", "complementary", "false", "hue", "mapping", "parameters", "palette", "none", "hue_order", "none", "hue_norm", "none", "axes", "information", "log_scale", "none", "legend", "true", "ax", "none", "other", "appearance", "keywords", "kwargs", "p", "_distributionplotter", "data", "data", "variables", "_distributionplotter", "get_semantics", "locals", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "we", "could", "support", "other", "semantics", "size", "style", "here", "fairly", "easily", "but", "it", "would", "make", "distplot", "a", "bit", "more", "complicated", "it", "s", "always", "possible", "to", "add", "features", "like", "that", "later", "so", "i", "am", "going", "to", "defer", "it", "will", "be", "even", "easier", "to", "wait", "until", "after", "there", "is", "a", "more", "general", "abstract", "way", "to", "go", "from", "semantic", "specs", "to", "artist", "attributes", "if", "ax", "is", "none", "ax", "plt", "gca", "p", "_attach", "ax", "log_scale", "log_scale", "color", "kwargs", "pop", "color", "kwargs", "pop", "c", "none", "kwargs", "color", "_default_color", "ax", "plot", "hue", "color", "kwargs", "if", "not", "p", "has_xy_data", "return", "ax", "we", "could", "add", "this", "one", "day", "but", "it", "s", "of", "dubious", "value", "if", "not", "p", "univariate", "raise", "notimplementederror", "bivariate", "ecdf", "plots", "are", "not", "implemented", "estimate_kws", "dict", "stat", "stat", "complementary", "complementary", "p", "plot_univariate_ecdf", "estimate_kws", "estimate_kws", "legend", "legend", "kwargs", "return", "ax"], "doc_len": 192}
{"doc_id": "seaborn/distributions.py::rugplot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "rugplot", "text": "文件路径: seaborn/distributions.py\ndef rugplot(\n    data=None, *, x=None, y=None, hue=None, height=.025, expand_margins=True,\n    palette=None, hue_order=None, hue_norm=None, legend=True, ax=None, **kwargs\n):\n\n    # A note: I think it would make sense to add multiple= to rugplot and allow\n    # rugs for different hue variables to be shifted orthogonal to the data axis\n    # But is this stacking, or dodging?\n\n    # A note: if we want to add a style semantic to rugplot,\n    # we could make an option that draws the rug using scatterplot\n\n    # A note, it would also be nice to offer some kind of histogram/density\n    # rugplot, since alpha blending doesn't work great in the large n regime\n\n    # --- Start with backwards compatability for versions < 0.11.0 ----------------\n\n    a = kwargs.pop(\"a\", None)\n    axis = kwargs.pop(\"axis\", None)\n\n    if a is not None:\n        data = a\n        msg = textwrap.dedent(\"\"\"\\n\n        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.\n        Please update your code; This will become an error in seaborn v0.13.0.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    if axis is not None:\n        if axis == \"x\":\n            x = data\n        elif axis == \"y\":\n            y = data\n        msg = textwrap.dedent(f\"\"\"\\n\n        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.\n        Please update your code; this will become an error in seaborn v0.13.0.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    vertical = kwargs.pop(\"vertical\", None)\n    if vertical is not None:\n        if vertical:\n            action_taken = \"assigning data to `y`.\"\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = \"assigning data to `x`.\"\n        msg = textwrap.dedent(f\"\"\"\\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.13.0; please update your code.\n        \"\"\")\n        warnings.warn(msg, UserWarning, stacklevel=2)\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #\n\n    weights = None\n    p = _DistributionPlotter(\n        data=data,\n        variables=_DistributionPlotter.get_semantics(locals()),\n    )\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    if ax is None:\n        ax = plt.gca()\n\n    p._attach(ax)\n\n    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n\n    if not p.has_xy_data:\n        return ax\n\n    p.plot_rug(height, expand_margins, legend, **kwargs)\n\n    return ax\n", "tokens": ["seaborn", "distributions", "py", "def", "rugplot", "data", "none", "x", "none", "y", "none", "hue", "none", "height", "025", "expand_margins", "true", "palette", "none", "hue_order", "none", "hue_norm", "none", "legend", "true", "ax", "none", "kwargs", "a", "note", "i", "think", "it", "would", "make", "sense", "to", "add", "multiple", "to", "rugplot", "and", "allow", "rugs", "for", "different", "hue", "variables", "to", "be", "shifted", "orthogonal", "to", "the", "data", "axis", "but", "is", "this", "stacking", "or", "dodging", "a", "note", "if", "we", "want", "to", "add", "a", "style", "semantic", "to", "rugplot", "we", "could", "make", "an", "option", "that", "draws", "the", "rug", "using", "scatterplot", "a", "note", "it", "would", "also", "be", "nice", "to", "offer", "some", "kind", "of", "histogram", "density", "rugplot", "since", "alpha", "blending", "doesn", "t", "work", "great", "in", "the", "large", "n", "regime", "start", "with", "backwards", "compatability", "for", "versions", "0", "11", "0", "a", "kwargs", "pop", "a", "none", "axis", "kwargs", "pop", "axis", "none", "if", "a", "is", "not", "none", "data", "a", "msg", "textwrap", "dedent", "n", "the", "a", "parameter", "has", "been", "replaced", "use", "x", "y", "and", "or", "data", "instead", "please", "update", "your", "code", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "if", "axis", "is", "not", "none", "if", "axis", "x", "x", "data", "elif", "axis", "y", "y", "data", "msg", "textwrap", "dedent", "f", "n", "the", "axis", "parameter", "has", "been", "deprecated", "use", "the", "axis", "parameter", "instead", "please", "update", "your", "code", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "vertical", "kwargs", "pop", "vertical", "none", "if", "vertical", "is", "not", "none", "if", "vertical", "action_taken", "assigning", "data", "to", "y", "if", "x", "is", "none", "data", "y", "y", "data", "else", "x", "y", "y", "x", "else", "action_taken", "assigning", "data", "to", "x", "msg", "textwrap", "dedent", "f", "n", "the", "vertical", "parameter", "is", "deprecated", "action_taken", "this", "will", "become", "an", "error", "in", "seaborn", "v0", "13", "0", "please", "update", "your", "code", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "weights", "none", "p", "_distributionplotter", "data", "data", "variables", "_distributionplotter", "get_semantics", "locals", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "if", "ax", "is", "none", "ax", "plt", "gca", "p", "_attach", "ax", "color", "kwargs", "pop", "color", "kwargs", "pop", "c", "none", "kwargs", "color", "_default_color", "ax", "plot", "hue", "color", "kwargs", "if", "not", "p", "has_xy_data", "return", "ax", "p", "plot_rug", "height", "expand_margins", "legend", "kwargs", "return", "ax"], "doc_len": 351}
{"doc_id": "seaborn/distributions.py::displot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "displot", "text": "文件路径: seaborn/distributions.py\ndef displot(\n    data=None, *,\n    # Vector variables\n    x=None, y=None, hue=None, row=None, col=None, weights=None,\n    # Other plot parameters\n    kind=\"hist\", rug=False, rug_kws=None, log_scale=None, legend=True,\n    # Hue-mapping parameters\n    palette=None, hue_order=None, hue_norm=None, color=None,\n    # Faceting parameters\n    col_wrap=None, row_order=None, col_order=None,\n    height=5, aspect=1, facet_kws=None,\n    **kwargs,\n):\n\n    p = _DistributionFacetPlotter(\n        data=data,\n        variables=_DistributionFacetPlotter.get_semantics(locals())\n    )\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n\n    _check_argument(\"kind\", [\"hist\", \"kde\", \"ecdf\"], kind)\n\n    # --- Initialize the FacetGrid object\n\n    # Check for attempt to plot onto specific axes and warn\n    if \"ax\" in kwargs:\n        msg = (\n            \"`displot` is a figure-level function and does not accept \"\n            \"the ax= parameter. You may wish to try {}plot.\".format(kind)\n        )\n        warnings.warn(msg, UserWarning)\n        kwargs.pop(\"ax\")\n\n    for var in [\"row\", \"col\"]:\n        # Handle faceting variables that lack name information\n        if var in p.variables and p.variables[var] is None:\n            p.variables[var] = f\"_{var}_\"\n\n    # Adapt the plot_data dataframe for use with FacetGrid\n    grid_data = p.plot_data.rename(columns=p.variables)\n    grid_data = grid_data.loc[:, ~grid_data.columns.duplicated()]\n\n    col_name = p.variables.get(\"col\")\n    row_name = p.variables.get(\"row\")\n\n    if facet_kws is None:\n        facet_kws = {}\n\n    g = FacetGrid(\n        data=grid_data, row=row_name, col=col_name,\n        col_wrap=col_wrap, row_order=row_order,\n        col_order=col_order, height=height,\n        aspect=aspect,\n        **facet_kws,\n    )\n\n    # Now attach the axes object to the plotter object\n    if kind == \"kde\":\n        allowed_types = [\"numeric\", \"datetime\"]\n    else:\n        allowed_types = None\n    p._attach(g, allowed_types=allowed_types, log_scale=log_scale)\n\n    # Check for a specification that lacks x/y data and return early\n    if not p.has_xy_data:\n        return g\n\n    if color is None and hue is None:\n        color = \"C0\"\n    # XXX else warn if hue is not None?\n\n    kwargs[\"legend\"] = legend\n\n    # --- Draw the plots\n\n    if kind == \"hist\":\n\n        hist_kws = kwargs.copy()\n\n        # Extract the parameters that will go directly to Histogram\n        estimate_defaults = {}\n        _assign_default_kwargs(estimate_defaults, Histogram.__init__, histplot)\n\n        estimate_kws = {}\n        for key, default_val in estimate_defaults.items():\n            estimate_kws[key] = hist_kws.pop(key, default_val)\n\n        # Handle derivative defaults\n        if estimate_kws[\"discrete\"] is None:\n            estimate_kws[\"discrete\"] = p._default_discrete()\n\n        hist_kws[\"estimate_kws\"] = estimate_kws\n\n        hist_kws.setdefault(\"color\", color)\n\n        if p.univariate:\n\n            _assign_default_kwargs(hist_kws, p.plot_univariate_histogram, histplot)\n            p.plot_univariate_histogram(**hist_kws)\n\n        else:\n\n            _assign_default_kwargs(hist_kws, p.plot_bivariate_histogram, histplot)\n            p.plot_bivariate_histogram(**hist_kws)\n\n    elif kind == \"kde\":\n\n        kde_kws = kwargs.copy()\n\n        # Extract the parameters that will go directly to KDE\n        estimate_defaults = {}\n        _assign_default_kwargs(estimate_defaults, KDE.__init__, kdeplot)\n\n        estimate_kws = {}\n        for key, default_val in estimate_defaults.items():\n            estimate_kws[key] = kde_kws.pop(key, default_val)\n\n        kde_kws[\"estimate_kws\"] = estimate_kws\n        kde_kws[\"color\"] = color\n\n        if p.univariate:\n\n            _assign_default_kwargs(kde_kws, p.plot_univariate_density, kdeplot)\n            p.plot_univariate_density(**kde_kws)\n\n        else:\n\n            _assign_default_kwargs(kde_kws, p.plot_bivariate_density, kdeplot)\n            p.plot_bivariate_density(**kde_kws)\n\n    elif kind == \"ecdf\":\n\n        ecdf_kws = kwargs.copy()\n\n        # Extract the parameters that will go directly to the estimator\n        estimate_kws = {}\n        estimate_defaults = {}\n        _assign_default_kwargs(estimate_defaults, ECDF.__init__, ecdfplot)\n        for key, default_val in estimate_defaults.items():\n            estimate_kws[key] = ecdf_kws.pop(key, default_val)\n\n        ecdf_kws[\"estimate_kws\"] = estimate_kws\n        ecdf_kws[\"color\"] = color\n\n        if p.univariate:\n\n            _assign_default_kwargs(ecdf_kws, p.plot_univariate_ecdf, ecdfplot)\n            p.plot_univariate_ecdf(**ecdf_kws)\n\n        else:\n\n            raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")\n\n    # All plot kinds can include a rug\n    if rug:\n        # TODO with expand_margins=True, each facet expands margins... annoying!\n        if rug_kws is None:\n            rug_kws = {}\n        _assign_default_kwargs(rug_kws, p.plot_rug, rugplot)\n        rug_kws[\"legend\"] = False\n        if color is not None:\n            rug_kws[\"color\"] = color\n        p.plot_rug(**rug_kws)\n\n    # Call FacetGrid annotation methods\n    # Note that the legend is currently set inside the plotting method\n    g.set_axis_labels(\n        x_var=p.variables.get(\"x\", g.axes.flat[0].get_xlabel()),\n        y_var=p.variables.get(\"y\", g.axes.flat[0].get_ylabel()),\n    )\n    g.set_titles()\n    g.tight_layout()\n\n    if data is not None and (x is not None or y is not None):\n        if not isinstance(data, pd.DataFrame):\n            data = pd.DataFrame(data)\n        g.data = pd.merge(\n            data,\n            g.data[g.data.columns.difference(data.columns)],\n            left_index=True,\n            right_index=True,\n        )\n    else:\n        wide_cols = {\n            k: f\"_{k}_\" if v is None else v for k, v in p.variables.items()\n        }\n        g.data = p.plot_data.rename(columns=wide_cols)\n\n    return g\n", "tokens": ["seaborn", "distributions", "py", "def", "displot", "data", "none", "vector", "variables", "x", "none", "y", "none", "hue", "none", "row", "none", "col", "none", "weights", "none", "other", "plot", "parameters", "kind", "hist", "rug", "false", "rug_kws", "none", "log_scale", "none", "legend", "true", "hue", "mapping", "parameters", "palette", "none", "hue_order", "none", "hue_norm", "none", "color", "none", "faceting", "parameters", "col_wrap", "none", "row_order", "none", "col_order", "none", "height", "5", "aspect", "1", "facet_kws", "none", "kwargs", "p", "_distributionfacetplotter", "data", "data", "variables", "_distributionfacetplotter", "get_semantics", "locals", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "_check_argument", "kind", "hist", "kde", "ecdf", "kind", "initialize", "the", "facetgrid", "object", "check", "for", "attempt", "to", "plot", "onto", "specific", "axes", "and", "warn", "if", "ax", "in", "kwargs", "msg", "displot", "is", "a", "figure", "level", "function", "and", "does", "not", "accept", "the", "ax", "parameter", "you", "may", "wish", "to", "try", "plot", "format", "kind", "warnings", "warn", "msg", "userwarning", "kwargs", "pop", "ax", "for", "var", "in", "row", "col", "handle", "faceting", "variables", "that", "lack", "name", "information", "if", "var", "in", "p", "variables", "and", "p", "variables", "var", "is", "none", "p", "variables", "var", "f", "_", "var", "_", "adapt", "the", "plot_data", "dataframe", "for", "use", "with", "facetgrid", "grid_data", "p", "plot_data", "rename", "columns", "p", "variables", "grid_data", "grid_data", "loc", "grid_data", "columns", "duplicated", "col_name", "p", "variables", "get", "col", "row_name", "p", "variables", "get", "row", "if", "facet_kws", "is", "none", "facet_kws", "g", "facetgrid", "data", "grid_data", "row", "row_name", "col", "col_name", "col_wrap", "col_wrap", "row_order", "row_order", "col_order", "col_order", "height", "height", "aspect", "aspect", "facet_kws", "now", "attach", "the", "axes", "object", "to", "the", "plotter", "object", "if", "kind", "kde", "allowed_types", "numeric", "datetime", "else", "allowed_types", "none", "p", "_attach", "g", "allowed_types", "allowed_types", "log_scale", "log_scale", "check", "for", "a", "specification", "that", "lacks", "x", "y", "data", "and", "return", "early", "if", "not", "p", "has_xy_data", "return", "g", "if", "color", "is", "none", "and", "hue", "is", "none", "color", "c0", "xxx", "else", "warn", "if", "hue", "is", "not", "none", "kwargs", "legend", "legend", "draw", "the", "plots", "if", "kind", "hist", "hist_kws", "kwargs", "copy", "extract", "the", "parameters", "that", "will", "go", "directly", "to", "histogram", "estimate_defaults", "_assign_default_kwargs", "estimate_defaults", "histogram", "__init__", "histplot", "estimate_kws", "for", "key", "default_val", "in", "estimate_defaults", "items", "estimate_kws", "key", "hist_kws", "pop", "key", "default_val", "handle", "derivative", "defaults", "if", "estimate_kws", "discrete", "is", "none", "estimate_kws", "discrete", "p", "_default_discrete", "hist_kws", "estimate_kws", "estimate_kws", "hist_kws", "setdefault", "color", "color", "if", "p", "univariate", "_assign_default_kwargs", "hist_kws", "p", "plot_univariate_histogram", "histplot", "p", "plot_univariate_histogram", "hist_kws", "else", "_assign_default_kwargs", "hist_kws", "p", "plot_bivariate_histogram", "histplot", "p", "plot_bivariate_histogram", "hist_kws", "elif", "kind", "kde", "kde_kws", "kwargs", "copy", "extract", "the", "parameters", "that", "will", "go", "directly", "to", "kde", "estimate_defaults", "_assign_default_kwargs", "estimate_defaults", "kde", "__init__", "kdeplot", "estimate_kws", "for", "key", "default_val", "in", "estimate_defaults", "items", "estimate_kws", "key", "kde_kws", "pop", "key", "default_val", "kde_kws", "estimate_kws", "estimate_kws", "kde_kws", "color", "color", "if", "p", "univariate", "_assign_default_kwargs", "kde_kws", "p", "plot_univariate_density", "kdeplot", "p", "plot_univariate_density", "kde_kws", "else", "_assign_default_kwargs", "kde_kws", "p", "plot_bivariate_density", "kdeplot", "p", "plot_bivariate_density", "kde_kws", "elif", "kind", "ecdf", "ecdf_kws", "kwargs", "copy", "extract", "the", "parameters", "that", "will", "go", "directly", "to", "the", "estimator", "estimate_kws", "estimate_defaults", "_assign_default_kwargs", "estimate_defaults", "ecdf", "__init__", "ecdfplot", "for", "key", "default_val", "in", "estimate_defaults", "items", "estimate_kws", "key", "ecdf_kws", "pop", "key", "default_val", "ecdf_kws", "estimate_kws", "estimate_kws", "ecdf_kws", "color", "color", "if", "p", "univariate", "_assign_default_kwargs", "ecdf_kws", "p", "plot_univariate_ecdf", "ecdfplot", "p", "plot_univariate_ecdf", "ecdf_kws", "else", "raise", "notimplementederror", "bivariate", "ecdf", "plots", "are", "not", "implemented", "all", "plot", "kinds", "can", "include", "a", "rug", "if", "rug", "todo", "with", "expand_margins", "true", "each", "facet", "expands", "margins", "annoying", "if", "rug_kws", "is", "none", "rug_kws", "_assign_default_kwargs", "rug_kws", "p", "plot_rug", "rugplot", "rug_kws", "legend", "false", "if", "color", "is", "not", "none", "rug_kws", "color", "color", "p", "plot_rug", "rug_kws", "call", "facetgrid", "annotation", "methods", "note", "that", "the", "legend", "is", "currently", "set", "inside", "the", "plotting", "method", "g", "set_axis_labels", "x_var", "p", "variables", "get", "x", "g", "axes", "flat", "0", "get_xlabel", "y_var", "p", "variables", "get", "y", "g", "axes", "flat", "0", "get_ylabel", "g", "set_titles", "g", "tight_layout", "if", "data", "is", "not", "none", "and", "x", "is", "not", "none", "or", "y", "is", "not", "none", "if", "not", "isinstance", "data", "pd", "dataframe", "data", "pd", "dataframe", "data", "g", "data", "pd", "merge", "data", "g", "data", "g", "data", "columns", "difference", "data", "columns", "left_index", "true", "right_index", "true", "else", "wide_cols", "k", "f", "_", "k", "_", "if", "v", "is", "none", "else", "v", "for", "k", "v", "in", "p", "variables", "items", "g", "data", "p", "plot_data", "rename", "columns", "wide_cols", "return", "g"], "doc_len": 629}
{"doc_id": "seaborn/distributions.py::_freedman_diaconis_bins", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "_freedman_diaconis_bins", "text": "文件路径: seaborn/distributions.py\ndef _freedman_diaconis_bins(a):\n    \"\"\"Calculate number of hist bins using Freedman-Diaconis rule.\"\"\"\n    # From https://stats.stackexchange.com/questions/798/\n    a = np.asarray(a)\n    if len(a) < 2:\n        return 1\n    iqr = np.subtract.reduce(np.nanpercentile(a, [75, 25]))\n    h = 2 * iqr / (len(a) ** (1 / 3))\n    # fall back to sqrt(a) bins if iqr is 0\n    if h == 0:\n        return int(np.sqrt(a.size))\n    else:\n        return int(np.ceil((a.max() - a.min()) / h))\n", "tokens": ["seaborn", "distributions", "py", "def", "_freedman_diaconis_bins", "a", "calculate", "number", "of", "hist", "bins", "using", "freedman", "diaconis", "rule", "from", "https", "stats", "stackexchange", "com", "questions", "798", "a", "np", "asarray", "a", "if", "len", "a", "2", "return", "1", "iqr", "np", "subtract", "reduce", "np", "nanpercentile", "a", "75", "25", "h", "2", "iqr", "len", "a", "1", "3", "fall", "back", "to", "sqrt", "a", "bins", "if", "iqr", "is", "0", "if", "h", "0", "return", "int", "np", "sqrt", "a", "size", "else", "return", "int", "np", "ceil", "a", "max", "a", "min", "h"], "doc_len": 77}
{"doc_id": "seaborn/distributions.py::distplot", "file_path": "seaborn/distributions.py", "class_name": null, "func_name": "distplot", "text": "文件路径: seaborn/distributions.py\ndef distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,\n             hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None,\n             color=None, vertical=False, norm_hist=False, axlabel=None,\n             label=None, ax=None, x=None):\n    \"\"\"\n    DEPRECATED\n\n    This function has been deprecated and will be removed in seaborn v0.14.0.\n    It has been replaced by :func:`histplot` and :func:`displot`, two functions\n    with a modern API and many more capabilities.\n\n    For a guide to updating, please see this notebook:\n\n    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751\n\n    \"\"\"\n\n    if kde and not hist:\n        axes_level_suggestion = (\n            \"`kdeplot` (an axes-level function for kernel density plots)\"\n        )\n    else:\n        axes_level_suggestion = (\n            \"`histplot` (an axes-level function for histograms)\"\n        )\n\n    msg = textwrap.dedent(f\"\"\"\n\n    `distplot` is a deprecated function and will be removed in seaborn v0.14.0.\n\n    Please adapt your code to use either `displot` (a figure-level function with\n    similar flexibility) or {axes_level_suggestion}.\n\n    For a guide to updating your code to use the new functions, please see\n    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751\n    \"\"\")\n    warnings.warn(msg, UserWarning, stacklevel=2)\n\n    if ax is None:\n        ax = plt.gca()\n\n    # Intelligently label the support axis\n    label_ax = bool(axlabel)\n    if axlabel is None and hasattr(a, \"name\"):\n        axlabel = a.name\n        if axlabel is not None:\n            label_ax = True\n\n    # Support new-style API\n    if x is not None:\n        a = x\n\n    # Make a a 1-d float array\n    a = np.asarray(a, float)\n    if a.ndim > 1:\n        a = a.squeeze()\n\n    # Drop null values from array\n    a = remove_na(a)\n\n    # Decide if the hist is normed\n    norm_hist = norm_hist or kde or (fit is not None)\n\n    # Handle dictionary defaults\n    hist_kws = {} if hist_kws is None else hist_kws.copy()\n    kde_kws = {} if kde_kws is None else kde_kws.copy()\n    rug_kws = {} if rug_kws is None else rug_kws.copy()\n    fit_kws = {} if fit_kws is None else fit_kws.copy()\n\n    # Get the color from the current color cycle\n    if color is None:\n        if vertical:\n            line, = ax.plot(0, a.mean())\n        else:\n            line, = ax.plot(a.mean(), 0)\n        color = line.get_color()\n        line.remove()\n\n    # Plug the label into the right kwarg dictionary\n    if label is not None:\n        if hist:\n            hist_kws[\"label\"] = label\n        elif kde:\n            kde_kws[\"label\"] = label\n        elif rug:\n            rug_kws[\"label\"] = label\n        elif fit:\n            fit_kws[\"label\"] = label\n\n    if hist:\n        if bins is None:\n            bins = min(_freedman_diaconis_bins(a), 50)\n        hist_kws.setdefault(\"alpha\", 0.4)\n        hist_kws.setdefault(\"density\", norm_hist)\n\n        orientation = \"horizontal\" if vertical else \"vertical\"\n        hist_color = hist_kws.pop(\"color\", color)\n        ax.hist(a, bins, orientation=orientation,\n                color=hist_color, **hist_kws)\n        if hist_color != color:\n            hist_kws[\"color\"] = hist_color\n\n    axis = \"y\" if vertical else \"x\"\n\n    if kde:\n        kde_color = kde_kws.pop(\"color\", color)\n        kdeplot(**{axis: a}, ax=ax, color=kde_color, **kde_kws)\n        if kde_color != color:\n            kde_kws[\"color\"] = kde_color\n\n    if rug:\n        rug_color = rug_kws.pop(\"color\", color)\n        rugplot(**{axis: a}, ax=ax, color=rug_color, **rug_kws)\n        if rug_color != color:\n            rug_kws[\"color\"] = rug_color\n\n    if fit is not None:\n\n        def pdf(x):\n            return fit.pdf(x, *params)\n\n        fit_color = fit_kws.pop(\"color\", \"#282828\")\n        gridsize = fit_kws.pop(\"gridsize\", 200)\n        cut = fit_kws.pop(\"cut\", 3)\n        clip = fit_kws.pop(\"clip\", (-np.inf, np.inf))\n        bw = gaussian_kde(a).scotts_factor() * a.std(ddof=1)\n        x = _kde_support(a, bw, gridsize, cut, clip)\n        params = fit.fit(a)\n        y = pdf(x)\n        if vertical:\n            x, y = y, x\n        ax.plot(x, y, color=fit_color, **fit_kws)\n        if fit_color != \"#282828\":\n            fit_kws[\"color\"] = fit_color\n\n    if label_ax:\n        if vertical:\n            ax.set_ylabel(axlabel)\n        else:\n            ax.set_xlabel(axlabel)\n\n    return ax\n", "tokens": ["seaborn", "distributions", "py", "def", "distplot", "a", "none", "bins", "none", "hist", "true", "kde", "true", "rug", "false", "fit", "none", "hist_kws", "none", "kde_kws", "none", "rug_kws", "none", "fit_kws", "none", "color", "none", "vertical", "false", "norm_hist", "false", "axlabel", "none", "label", "none", "ax", "none", "x", "none", "deprecated", "this", "function", "has", "been", "deprecated", "and", "will", "be", "removed", "in", "seaborn", "v0", "14", "0", "it", "has", "been", "replaced", "by", "func", "histplot", "and", "func", "displot", "two", "functions", "with", "a", "modern", "api", "and", "many", "more", "capabilities", "for", "a", "guide", "to", "updating", "please", "see", "this", "notebook", "https", "gist", "github", "com", "mwaskom", "de44147ed2974457ad6372750bbe5751", "if", "kde", "and", "not", "hist", "axes_level_suggestion", "kdeplot", "an", "axes", "level", "function", "for", "kernel", "density", "plots", "else", "axes_level_suggestion", "histplot", "an", "axes", "level", "function", "for", "histograms", "msg", "textwrap", "dedent", "f", "distplot", "is", "a", "deprecated", "function", "and", "will", "be", "removed", "in", "seaborn", "v0", "14", "0", "please", "adapt", "your", "code", "to", "use", "either", "displot", "a", "figure", "level", "function", "with", "similar", "flexibility", "or", "axes_level_suggestion", "for", "a", "guide", "to", "updating", "your", "code", "to", "use", "the", "new", "functions", "please", "see", "https", "gist", "github", "com", "mwaskom", "de44147ed2974457ad6372750bbe5751", "warnings", "warn", "msg", "userwarning", "stacklevel", "2", "if", "ax", "is", "none", "ax", "plt", "gca", "intelligently", "label", "the", "support", "axis", "label_ax", "bool", "axlabel", "if", "axlabel", "is", "none", "and", "hasattr", "a", "name", "axlabel", "a", "name", "if", "axlabel", "is", "not", "none", "label_ax", "true", "support", "new", "style", "api", "if", "x", "is", "not", "none", "a", "x", "make", "a", "a", "1", "d", "float", "array", "a", "np", "asarray", "a", "float", "if", "a", "ndim", "1", "a", "a", "squeeze", "drop", "null", "values", "from", "array", "a", "remove_na", "a", "decide", "if", "the", "hist", "is", "normed", "norm_hist", "norm_hist", "or", "kde", "or", "fit", "is", "not", "none", "handle", "dictionary", "defaults", "hist_kws", "if", "hist_kws", "is", "none", "else", "hist_kws", "copy", "kde_kws", "if", "kde_kws", "is", "none", "else", "kde_kws", "copy", "rug_kws", "if", "rug_kws", "is", "none", "else", "rug_kws", "copy", "fit_kws", "if", "fit_kws", "is", "none", "else", "fit_kws", "copy", "get", "the", "color", "from", "the", "current", "color", "cycle", "if", "color", "is", "none", "if", "vertical", "line", "ax", "plot", "0", "a", "mean", "else", "line", "ax", "plot", "a", "mean", "0", "color", "line", "get_color", "line", "remove", "plug", "the", "label", "into", "the", "right", "kwarg", "dictionary", "if", "label", "is", "not", "none", "if", "hist", "hist_kws", "label", "label", "elif", "kde", "kde_kws", "label", "label", "elif", "rug", "rug_kws", "label", "label", "elif", "fit", "fit_kws", "label", "label", "if", "hist", "if", "bins", "is", "none", "bins", "min", "_freedman_diaconis_bins", "a", "50", "hist_kws", "setdefault", "alpha", "0", "4", "hist_kws", "setdefault", "density", "norm_hist", "orientation", "horizontal", "if", "vertical", "else", "vertical", "hist_color", "hist_kws", "pop", "color", "color", "ax", "hist", "a", "bins", "orientation", "orientation", "color", "hist_color", "hist_kws", "if", "hist_color", "color", "hist_kws", "color", "hist_color", "axis", "y", "if", "vertical", "else", "x", "if", "kde", "kde_color", "kde_kws", "pop", "color", "color", "kdeplot", "axis", "a", "ax", "ax", "color", "kde_color", "kde_kws", "if", "kde_color", "color", "kde_kws", "color", "kde_color", "if", "rug", "rug_color", "rug_kws", "pop", "color", "color", "rugplot", "axis", "a", "ax", "ax", "color", "rug_color", "rug_kws", "if", "rug_color", "color", "rug_kws", "color", "rug_color", "if", "fit", "is", "not", "none", "def", "pdf", "x", "return", "fit", "pdf", "x", "params", "fit_color", "fit_kws", "pop", "color", "282828", "gridsize", "fit_kws", "pop", "gridsize", "200", "cut", "fit_kws", "pop", "cut", "3", "clip", "fit_kws", "pop", "clip", "np", "inf", "np", "inf", "bw", "gaussian_kde", "a", "scotts_factor", "a", "std", "ddof", "1", "x", "_kde_support", "a", "bw", "gridsize", "cut", "clip", "params", "fit", "fit", "a", "y", "pdf", "x", "if", "vertical", "x", "y", "y", "x", "ax", "plot", "x", "y", "color", "fit_color", "fit_kws", "if", "fit_color", "282828", "fit_kws", "color", "fit_color", "if", "label_ax", "if", "vertical", "ax", "set_ylabel", "axlabel", "else", "ax", "set_xlabel", "axlabel", "return", "ax"], "doc_len": 544}
{"doc_id": "seaborn/matrix.py::_index_to_label", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "_index_to_label", "text": "文件路径: seaborn/matrix.py\ndef _index_to_label(index):\n    \"\"\"Convert a pandas index or multiindex to an axis label.\"\"\"\n    if isinstance(index, pd.MultiIndex):\n        return \"-\".join(map(to_utf8, index.names))\n    else:\n        return index.name\n", "tokens": ["seaborn", "matrix", "py", "def", "_index_to_label", "index", "convert", "a", "pandas", "index", "or", "multiindex", "to", "an", "axis", "label", "if", "isinstance", "index", "pd", "multiindex", "return", "join", "map", "to_utf8", "index", "names", "else", "return", "index", "name"], "doc_len": 31}
{"doc_id": "seaborn/matrix.py::_index_to_ticklabels", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "_index_to_ticklabels", "text": "文件路径: seaborn/matrix.py\ndef _index_to_ticklabels(index):\n    \"\"\"Convert a pandas index or multiindex into ticklabels.\"\"\"\n    if isinstance(index, pd.MultiIndex):\n        return [\"-\".join(map(to_utf8, i)) for i in index.values]\n    else:\n        return index.values\n", "tokens": ["seaborn", "matrix", "py", "def", "_index_to_ticklabels", "index", "convert", "a", "pandas", "index", "or", "multiindex", "into", "ticklabels", "if", "isinstance", "index", "pd", "multiindex", "return", "join", "map", "to_utf8", "i", "for", "i", "in", "index", "values", "else", "return", "index", "values"], "doc_len": 33}
{"doc_id": "seaborn/matrix.py::_convert_colors", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "_convert_colors", "text": "文件路径: seaborn/matrix.py\ndef _convert_colors(colors):\n    \"\"\"Convert either a list of colors or nested lists of colors to RGB.\"\"\"\n    to_rgb = mpl.colors.to_rgb\n\n    try:\n        to_rgb(colors[0])\n        # If this works, there is only one level of colors\n        return list(map(to_rgb, colors))\n    except ValueError:\n        # If we get here, we have nested lists\n        return [list(map(to_rgb, l)) for l in colors]\n", "tokens": ["seaborn", "matrix", "py", "def", "_convert_colors", "colors", "convert", "either", "a", "list", "of", "colors", "or", "nested", "lists", "of", "colors", "to", "rgb", "to_rgb", "mpl", "colors", "to_rgb", "try", "to_rgb", "colors", "0", "if", "this", "works", "there", "is", "only", "one", "level", "of", "colors", "return", "list", "map", "to_rgb", "colors", "except", "valueerror", "if", "we", "get", "here", "we", "have", "nested", "lists", "return", "list", "map", "to_rgb", "l", "for", "l", "in", "colors"], "doc_len": 61}
{"doc_id": "seaborn/matrix.py::_matrix_mask", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "_matrix_mask", "text": "文件路径: seaborn/matrix.py\ndef _matrix_mask(data, mask):\n    \"\"\"Ensure that data and mask are compatible and add missing values.\n\n    Values will be plotted for cells where ``mask`` is ``False``.\n\n    ``data`` is expected to be a DataFrame; ``mask`` can be an array or\n    a DataFrame.\n\n    \"\"\"\n    if mask is None:\n        mask = np.zeros(data.shape, bool)\n\n    if isinstance(mask, np.ndarray):\n        # For array masks, ensure that shape matches data then convert\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask must have the same shape as data.\")\n\n        mask = pd.DataFrame(mask,\n                            index=data.index,\n                            columns=data.columns,\n                            dtype=bool)\n\n    elif isinstance(mask, pd.DataFrame):\n        # For DataFrame masks, ensure that semantic labels match data\n        if not mask.index.equals(data.index) \\\n           and mask.columns.equals(data.columns):\n            err = \"Mask must have the same index and columns as data.\"\n            raise ValueError(err)\n\n    # Add any cells with missing data to the mask\n    # This works around an issue where `plt.pcolormesh` doesn't represent\n    # missing data properly\n    mask = mask | pd.isnull(data)\n\n    return mask\n", "tokens": ["seaborn", "matrix", "py", "def", "_matrix_mask", "data", "mask", "ensure", "that", "data", "and", "mask", "are", "compatible", "and", "add", "missing", "values", "values", "will", "be", "plotted", "for", "cells", "where", "mask", "is", "false", "data", "is", "expected", "to", "be", "a", "dataframe", "mask", "can", "be", "an", "array", "or", "a", "dataframe", "if", "mask", "is", "none", "mask", "np", "zeros", "data", "shape", "bool", "if", "isinstance", "mask", "np", "ndarray", "for", "array", "masks", "ensure", "that", "shape", "matches", "data", "then", "convert", "if", "mask", "shape", "data", "shape", "raise", "valueerror", "mask", "must", "have", "the", "same", "shape", "as", "data", "mask", "pd", "dataframe", "mask", "index", "data", "index", "columns", "data", "columns", "dtype", "bool", "elif", "isinstance", "mask", "pd", "dataframe", "for", "dataframe", "masks", "ensure", "that", "semantic", "labels", "match", "data", "if", "not", "mask", "index", "equals", "data", "index", "and", "mask", "columns", "equals", "data", "columns", "err", "mask", "must", "have", "the", "same", "index", "and", "columns", "as", "data", "raise", "valueerror", "err", "add", "any", "cells", "with", "missing", "data", "to", "the", "mask", "this", "works", "around", "an", "issue", "where", "plt", "pcolormesh", "doesn", "t", "represent", "missing", "data", "properly", "mask", "mask", "pd", "isnull", "data", "return", "mask"], "doc_len": 166}
{"doc_id": "seaborn/matrix.py::_HeatMapper.__init__", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "__init__", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,\n                 annot_kws, cbar, cbar_kws,\n                 xticklabels=True, yticklabels=True, mask=None):\n        \"\"\"Initialize the plotting object.\"\"\"\n        # We always want to have a DataFrame with semantic information\n        # and an ndarray to pass to matplotlib\n        if isinstance(data, pd.DataFrame):\n            plot_data = data.values\n        else:\n            plot_data = np.asarray(data)\n            data = pd.DataFrame(plot_data)\n\n        # Validate the mask and convert to DataFrame\n        mask = _matrix_mask(data, mask)\n\n        plot_data = np.ma.masked_where(np.asarray(mask), plot_data)\n\n        # Get good names for the rows and columns\n        xtickevery = 1\n        if isinstance(xticklabels, int):\n            xtickevery = xticklabels\n            xticklabels = _index_to_ticklabels(data.columns)\n        elif xticklabels is True:\n            xticklabels = _index_to_ticklabels(data.columns)\n        elif xticklabels is False:\n            xticklabels = []\n\n        ytickevery = 1\n        if isinstance(yticklabels, int):\n            ytickevery = yticklabels\n            yticklabels = _index_to_ticklabels(data.index)\n        elif yticklabels is True:\n            yticklabels = _index_to_ticklabels(data.index)\n        elif yticklabels is False:\n            yticklabels = []\n\n        if not len(xticklabels):\n            self.xticks = []\n            self.xticklabels = []\n        elif isinstance(xticklabels, str) and xticklabels == \"auto\":\n            self.xticks = \"auto\"\n            self.xticklabels = _index_to_ticklabels(data.columns)\n        else:\n            self.xticks, self.xticklabels = self._skip_ticks(xticklabels,\n                                                             xtickevery)\n\n        if not len(yticklabels):\n            self.yticks = []\n            self.yticklabels = []\n        elif isinstance(yticklabels, str) and yticklabels == \"auto\":\n            self.yticks = \"auto\"\n            self.yticklabels = _index_to_ticklabels(data.index)\n        else:\n            self.yticks, self.yticklabels = self._skip_ticks(yticklabels,\n                                                             ytickevery)\n\n        # Get good names for the axis labels\n        xlabel = _index_to_label(data.columns)\n        ylabel = _index_to_label(data.index)\n        self.xlabel = xlabel if xlabel is not None else \"\"\n        self.ylabel = ylabel if ylabel is not None else \"\"\n\n        # Determine good default values for the colormapping\n        self._determine_cmap_params(plot_data, vmin, vmax,\n                                    cmap, center, robust)\n\n        # Sort out the annotations\n        if annot is None or annot is False:\n            annot = False\n            annot_data = None\n        else:\n            if isinstance(annot, bool):\n                annot_data = plot_data\n            else:\n                annot_data = np.asarray(annot)\n                if annot_data.shape != plot_data.shape:\n                    err = \"`data` and `annot` must have same shape.\"\n                    raise ValueError(err)\n            annot = True\n\n        # Save other attributes to the object\n        self.data = data\n        self.plot_data = plot_data\n\n        self.annot = annot\n        self.annot_data = annot_data\n\n        self.fmt = fmt\n        self.annot_kws = {} if annot_kws is None else annot_kws.copy()\n        self.cbar = cbar\n        self.cbar_kws = {} if cbar_kws is None else cbar_kws.copy()\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "__init__", "self", "data", "vmin", "vmax", "cmap", "center", "robust", "annot", "fmt", "annot_kws", "cbar", "cbar_kws", "xticklabels", "true", "yticklabels", "true", "mask", "none", "initialize", "the", "plotting", "object", "we", "always", "want", "to", "have", "a", "dataframe", "with", "semantic", "information", "and", "an", "ndarray", "to", "pass", "to", "matplotlib", "if", "isinstance", "data", "pd", "dataframe", "plot_data", "data", "values", "else", "plot_data", "np", "asarray", "data", "data", "pd", "dataframe", "plot_data", "validate", "the", "mask", "and", "convert", "to", "dataframe", "mask", "_matrix_mask", "data", "mask", "plot_data", "np", "ma", "masked_where", "np", "asarray", "mask", "plot_data", "get", "good", "names", "for", "the", "rows", "and", "columns", "xtickevery", "1", "if", "isinstance", "xticklabels", "int", "xtickevery", "xticklabels", "xticklabels", "_index_to_ticklabels", "data", "columns", "elif", "xticklabels", "is", "true", "xticklabels", "_index_to_ticklabels", "data", "columns", "elif", "xticklabels", "is", "false", "xticklabels", "ytickevery", "1", "if", "isinstance", "yticklabels", "int", "ytickevery", "yticklabels", "yticklabels", "_index_to_ticklabels", "data", "index", "elif", "yticklabels", "is", "true", "yticklabels", "_index_to_ticklabels", "data", "index", "elif", "yticklabels", "is", "false", "yticklabels", "if", "not", "len", "xticklabels", "self", "xticks", "self", "xticklabels", "elif", "isinstance", "xticklabels", "str", "and", "xticklabels", "auto", "self", "xticks", "auto", "self", "xticklabels", "_index_to_ticklabels", "data", "columns", "else", "self", "xticks", "self", "xticklabels", "self", "_skip_ticks", "xticklabels", "xtickevery", "if", "not", "len", "yticklabels", "self", "yticks", "self", "yticklabels", "elif", "isinstance", "yticklabels", "str", "and", "yticklabels", "auto", "self", "yticks", "auto", "self", "yticklabels", "_index_to_ticklabels", "data", "index", "else", "self", "yticks", "self", "yticklabels", "self", "_skip_ticks", "yticklabels", "ytickevery", "get", "good", "names", "for", "the", "axis", "labels", "xlabel", "_index_to_label", "data", "columns", "ylabel", "_index_to_label", "data", "index", "self", "xlabel", "xlabel", "if", "xlabel", "is", "not", "none", "else", "self", "ylabel", "ylabel", "if", "ylabel", "is", "not", "none", "else", "determine", "good", "default", "values", "for", "the", "colormapping", "self", "_determine_cmap_params", "plot_data", "vmin", "vmax", "cmap", "center", "robust", "sort", "out", "the", "annotations", "if", "annot", "is", "none", "or", "annot", "is", "false", "annot", "false", "annot_data", "none", "else", "if", "isinstance", "annot", "bool", "annot_data", "plot_data", "else", "annot_data", "np", "asarray", "annot", "if", "annot_data", "shape", "plot_data", "shape", "err", "data", "and", "annot", "must", "have", "same", "shape", "raise", "valueerror", "err", "annot", "true", "save", "other", "attributes", "to", "the", "object", "self", "data", "data", "self", "plot_data", "plot_data", "self", "annot", "annot", "self", "annot_data", "annot_data", "self", "fmt", "fmt", "self", "annot_kws", "if", "annot_kws", "is", "none", "else", "annot_kws", "copy", "self", "cbar", "cbar", "self", "cbar_kws", "if", "cbar_kws", "is", "none", "else", "cbar_kws", "copy"], "doc_len": 339}
{"doc_id": "seaborn/matrix.py::_HeatMapper._determine_cmap_params", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "_determine_cmap_params", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def _determine_cmap_params(self, plot_data, vmin, vmax,\n                               cmap, center, robust):\n        \"\"\"Use some heuristics to set good defaults for colorbar and range.\"\"\"\n\n        # plot_data is a np.ma.array instance\n        calc_data = plot_data.astype(float).filled(np.nan)\n        if vmin is None:\n            if robust:\n                vmin = np.nanpercentile(calc_data, 2)\n            else:\n                vmin = np.nanmin(calc_data)\n        if vmax is None:\n            if robust:\n                vmax = np.nanpercentile(calc_data, 98)\n            else:\n                vmax = np.nanmax(calc_data)\n        self.vmin, self.vmax = vmin, vmax\n\n        # Choose default colormaps if not provided\n        if cmap is None:\n            if center is None:\n                self.cmap = cm.rocket\n            else:\n                self.cmap = cm.icefire\n        elif isinstance(cmap, str):\n            self.cmap = get_colormap(cmap)\n        elif isinstance(cmap, list):\n            self.cmap = mpl.colors.ListedColormap(cmap)\n        else:\n            self.cmap = cmap\n\n        # Recenter a divergent colormap\n        if center is not None:\n\n            # Copy bad values\n            # in mpl<3.2 only masked values are honored with \"bad\" color spec\n            # (see https://github.com/matplotlib/matplotlib/pull/14257)\n            bad = self.cmap(np.ma.masked_invalid([np.nan]))[0]\n\n            # under/over values are set for sure when cmap extremes\n            # do not map to the same color as +-inf\n            under = self.cmap(-np.inf)\n            over = self.cmap(np.inf)\n            under_set = under != self.cmap(0)\n            over_set = over != self.cmap(self.cmap.N - 1)\n\n            vrange = max(vmax - center, center - vmin)\n            normlize = mpl.colors.Normalize(center - vrange, center + vrange)\n            cmin, cmax = normlize([vmin, vmax])\n            cc = np.linspace(cmin, cmax, 256)\n            self.cmap = mpl.colors.ListedColormap(self.cmap(cc))\n            self.cmap.set_bad(bad)\n            if under_set:\n                self.cmap.set_under(under)\n            if over_set:\n                self.cmap.set_over(over)\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "_determine_cmap_params", "self", "plot_data", "vmin", "vmax", "cmap", "center", "robust", "use", "some", "heuristics", "to", "set", "good", "defaults", "for", "colorbar", "and", "range", "plot_data", "is", "a", "np", "ma", "array", "instance", "calc_data", "plot_data", "astype", "float", "filled", "np", "nan", "if", "vmin", "is", "none", "if", "robust", "vmin", "np", "nanpercentile", "calc_data", "2", "else", "vmin", "np", "nanmin", "calc_data", "if", "vmax", "is", "none", "if", "robust", "vmax", "np", "nanpercentile", "calc_data", "98", "else", "vmax", "np", "nanmax", "calc_data", "self", "vmin", "self", "vmax", "vmin", "vmax", "choose", "default", "colormaps", "if", "not", "provided", "if", "cmap", "is", "none", "if", "center", "is", "none", "self", "cmap", "cm", "rocket", "else", "self", "cmap", "cm", "icefire", "elif", "isinstance", "cmap", "str", "self", "cmap", "get_colormap", "cmap", "elif", "isinstance", "cmap", "list", "self", "cmap", "mpl", "colors", "listedcolormap", "cmap", "else", "self", "cmap", "cmap", "recenter", "a", "divergent", "colormap", "if", "center", "is", "not", "none", "copy", "bad", "values", "in", "mpl", "3", "2", "only", "masked", "values", "are", "honored", "with", "bad", "color", "spec", "see", "https", "github", "com", "matplotlib", "matplotlib", "pull", "14257", "bad", "self", "cmap", "np", "ma", "masked_invalid", "np", "nan", "0", "under", "over", "values", "are", "set", "for", "sure", "when", "cmap", "extremes", "do", "not", "map", "to", "the", "same", "color", "as", "inf", "under", "self", "cmap", "np", "inf", "over", "self", "cmap", "np", "inf", "under_set", "under", "self", "cmap", "0", "over_set", "over", "self", "cmap", "self", "cmap", "n", "1", "vrange", "max", "vmax", "center", "center", "vmin", "normlize", "mpl", "colors", "normalize", "center", "vrange", "center", "vrange", "cmin", "cmax", "normlize", "vmin", "vmax", "cc", "np", "linspace", "cmin", "cmax", "256", "self", "cmap", "mpl", "colors", "listedcolormap", "self", "cmap", "cc", "self", "cmap", "set_bad", "bad", "if", "under_set", "self", "cmap", "set_under", "under", "if", "over_set", "self", "cmap", "set_over", "over"], "doc_len": 254}
{"doc_id": "seaborn/matrix.py::_HeatMapper._annotate_heatmap", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "_annotate_heatmap", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def _annotate_heatmap(self, ax, mesh):\n        \"\"\"Add textual labels with the value in each cell.\"\"\"\n        mesh.update_scalarmappable()\n        height, width = self.annot_data.shape\n        xpos, ypos = np.meshgrid(np.arange(width) + .5, np.arange(height) + .5)\n        for x, y, m, color, val in zip(xpos.flat, ypos.flat,\n                                       mesh.get_array(), mesh.get_facecolors(),\n                                       self.annot_data.flat):\n            if m is not np.ma.masked:\n                lum = relative_luminance(color)\n                text_color = \".15\" if lum > .408 else \"w\"\n                annotation = (\"{:\" + self.fmt + \"}\").format(val)\n                text_kwargs = dict(color=text_color, ha=\"center\", va=\"center\")\n                text_kwargs.update(self.annot_kws)\n                ax.text(x, y, annotation, **text_kwargs)\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "_annotate_heatmap", "self", "ax", "mesh", "add", "textual", "labels", "with", "the", "value", "in", "each", "cell", "mesh", "update_scalarmappable", "height", "width", "self", "annot_data", "shape", "xpos", "ypos", "np", "meshgrid", "np", "arange", "width", "5", "np", "arange", "height", "5", "for", "x", "y", "m", "color", "val", "in", "zip", "xpos", "flat", "ypos", "flat", "mesh", "get_array", "mesh", "get_facecolors", "self", "annot_data", "flat", "if", "m", "is", "not", "np", "ma", "masked", "lum", "relative_luminance", "color", "text_color", "15", "if", "lum", "408", "else", "w", "annotation", "self", "fmt", "format", "val", "text_kwargs", "dict", "color", "text_color", "ha", "center", "va", "center", "text_kwargs", "update", "self", "annot_kws", "ax", "text", "x", "y", "annotation", "text_kwargs"], "doc_len": 96}
{"doc_id": "seaborn/matrix.py::_HeatMapper._skip_ticks", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "_skip_ticks", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def _skip_ticks(self, labels, tickevery):\n        \"\"\"Return ticks and labels at evenly spaced intervals.\"\"\"\n        n = len(labels)\n        if tickevery == 0:\n            ticks, labels = [], []\n        elif tickevery == 1:\n            ticks, labels = np.arange(n) + .5, labels\n        else:\n            start, end, step = 0, n, tickevery\n            ticks = np.arange(start, end, step) + .5\n            labels = labels[start:end:step]\n        return ticks, labels\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "_skip_ticks", "self", "labels", "tickevery", "return", "ticks", "and", "labels", "at", "evenly", "spaced", "intervals", "n", "len", "labels", "if", "tickevery", "0", "ticks", "labels", "elif", "tickevery", "1", "ticks", "labels", "np", "arange", "n", "5", "labels", "else", "start", "end", "step", "0", "n", "tickevery", "ticks", "np", "arange", "start", "end", "step", "5", "labels", "labels", "start", "end", "step", "return", "ticks", "labels"], "doc_len": 57}
{"doc_id": "seaborn/matrix.py::_HeatMapper._auto_ticks", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "_auto_ticks", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def _auto_ticks(self, ax, labels, axis):\n        \"\"\"Determine ticks and ticklabels that minimize overlap.\"\"\"\n        transform = ax.figure.dpi_scale_trans.inverted()\n        bbox = ax.get_window_extent().transformed(transform)\n        size = [bbox.width, bbox.height][axis]\n        axis = [ax.xaxis, ax.yaxis][axis]\n        tick, = axis.set_ticks([0])\n        fontsize = tick.label1.get_size()\n        max_ticks = int(size // (fontsize / 72))\n        if max_ticks < 1:\n            return [], []\n        tick_every = len(labels) // max_ticks + 1\n        tick_every = 1 if tick_every == 0 else tick_every\n        ticks, labels = self._skip_ticks(labels, tick_every)\n        return ticks, labels\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "_auto_ticks", "self", "ax", "labels", "axis", "determine", "ticks", "and", "ticklabels", "that", "minimize", "overlap", "transform", "ax", "figure", "dpi_scale_trans", "inverted", "bbox", "ax", "get_window_extent", "transformed", "transform", "size", "bbox", "width", "bbox", "height", "axis", "axis", "ax", "xaxis", "ax", "yaxis", "axis", "tick", "axis", "set_ticks", "0", "fontsize", "tick", "label1", "get_size", "max_ticks", "int", "size", "fontsize", "72", "if", "max_ticks", "1", "return", "tick_every", "len", "labels", "max_ticks", "1", "tick_every", "1", "if", "tick_every", "0", "else", "tick_every", "ticks", "labels", "self", "_skip_ticks", "labels", "tick_every", "return", "ticks", "labels"], "doc_len": 77}
{"doc_id": "seaborn/matrix.py::_HeatMapper.plot", "file_path": "seaborn/matrix.py", "class_name": "_HeatMapper", "func_name": "plot", "text": "文件路径: seaborn/matrix.py, 类名: _HeatMapper\n    def plot(self, ax, cax, kws):\n        \"\"\"Draw the heatmap on the provided Axes.\"\"\"\n        # Remove all the Axes spines\n        despine(ax=ax, left=True, bottom=True)\n\n        # setting vmin/vmax in addition to norm is deprecated\n        # so avoid setting if norm is set\n        if \"norm\" not in kws:\n            kws.setdefault(\"vmin\", self.vmin)\n            kws.setdefault(\"vmax\", self.vmax)\n\n        # Draw the heatmap\n        mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)\n\n        # Set the axis limits\n        ax.set(xlim=(0, self.data.shape[1]), ylim=(0, self.data.shape[0]))\n\n        # Invert the y axis to show the plot in matrix form\n        ax.invert_yaxis()\n\n        # Possibly add a colorbar\n        if self.cbar:\n            cb = ax.figure.colorbar(mesh, cax, ax, **self.cbar_kws)\n            cb.outline.set_linewidth(0)\n            # If rasterized is passed to pcolormesh, also rasterize the\n            # colorbar to avoid white lines on the PDF rendering\n            if kws.get('rasterized', False):\n                cb.solids.set_rasterized(True)\n\n        # Add row and column labels\n        if isinstance(self.xticks, str) and self.xticks == \"auto\":\n            xticks, xticklabels = self._auto_ticks(ax, self.xticklabels, 0)\n        else:\n            xticks, xticklabels = self.xticks, self.xticklabels\n\n        if isinstance(self.yticks, str) and self.yticks == \"auto\":\n            yticks, yticklabels = self._auto_ticks(ax, self.yticklabels, 1)\n        else:\n            yticks, yticklabels = self.yticks, self.yticklabels\n\n        ax.set(xticks=xticks, yticks=yticks)\n        xtl = ax.set_xticklabels(xticklabels)\n        ytl = ax.set_yticklabels(yticklabels, rotation=\"vertical\")\n        plt.setp(ytl, va=\"center\")  # GH2484\n\n        # Possibly rotate them if they overlap\n        _draw_figure(ax.figure)\n\n        if axis_ticklabels_overlap(xtl):\n            plt.setp(xtl, rotation=\"vertical\")\n        if axis_ticklabels_overlap(ytl):\n            plt.setp(ytl, rotation=\"horizontal\")\n\n        # Add the axis labels\n        ax.set(xlabel=self.xlabel, ylabel=self.ylabel)\n\n        # Annotate the cells with the formatted values\n        if self.annot:\n            self._annotate_heatmap(ax, mesh)\n", "tokens": ["seaborn", "matrix", "py", "_heatmapper", "def", "plot", "self", "ax", "cax", "kws", "draw", "the", "heatmap", "on", "the", "provided", "axes", "remove", "all", "the", "axes", "spines", "despine", "ax", "ax", "left", "true", "bottom", "true", "setting", "vmin", "vmax", "in", "addition", "to", "norm", "is", "deprecated", "so", "avoid", "setting", "if", "norm", "is", "set", "if", "norm", "not", "in", "kws", "kws", "setdefault", "vmin", "self", "vmin", "kws", "setdefault", "vmax", "self", "vmax", "draw", "the", "heatmap", "mesh", "ax", "pcolormesh", "self", "plot_data", "cmap", "self", "cmap", "kws", "set", "the", "axis", "limits", "ax", "set", "xlim", "0", "self", "data", "shape", "1", "ylim", "0", "self", "data", "shape", "0", "invert", "the", "y", "axis", "to", "show", "the", "plot", "in", "matrix", "form", "ax", "invert_yaxis", "possibly", "add", "a", "colorbar", "if", "self", "cbar", "cb", "ax", "figure", "colorbar", "mesh", "cax", "ax", "self", "cbar_kws", "cb", "outline", "set_linewidth", "0", "if", "rasterized", "is", "passed", "to", "pcolormesh", "also", "rasterize", "the", "colorbar", "to", "avoid", "white", "lines", "on", "the", "pdf", "rendering", "if", "kws", "get", "rasterized", "false", "cb", "solids", "set_rasterized", "true", "add", "row", "and", "column", "labels", "if", "isinstance", "self", "xticks", "str", "and", "self", "xticks", "auto", "xticks", "xticklabels", "self", "_auto_ticks", "ax", "self", "xticklabels", "0", "else", "xticks", "xticklabels", "self", "xticks", "self", "xticklabels", "if", "isinstance", "self", "yticks", "str", "and", "self", "yticks", "auto", "yticks", "yticklabels", "self", "_auto_ticks", "ax", "self", "yticklabels", "1", "else", "yticks", "yticklabels", "self", "yticks", "self", "yticklabels", "ax", "set", "xticks", "xticks", "yticks", "yticks", "xtl", "ax", "set_xticklabels", "xticklabels", "ytl", "ax", "set_yticklabels", "yticklabels", "rotation", "vertical", "plt", "setp", "ytl", "va", "center", "gh2484", "possibly", "rotate", "them", "if", "they", "overlap", "_draw_figure", "ax", "figure", "if", "axis_ticklabels_overlap", "xtl", "plt", "setp", "xtl", "rotation", "vertical", "if", "axis_ticklabels_overlap", "ytl", "plt", "setp", "ytl", "rotation", "horizontal", "add", "the", "axis", "labels", "ax", "set", "xlabel", "self", "xlabel", "ylabel", "self", "ylabel", "annotate", "the", "cells", "with", "the", "formatted", "values", "if", "self", "annot", "self", "_annotate_heatmap", "ax", "mesh"], "doc_len": 276}
{"doc_id": "seaborn/matrix.py::heatmap", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "heatmap", "text": "文件路径: seaborn/matrix.py\ndef heatmap(\n    data, *,\n    vmin=None, vmax=None, cmap=None, center=None, robust=False,\n    annot=None, fmt=\".2g\", annot_kws=None,\n    linewidths=0, linecolor=\"white\",\n    cbar=True, cbar_kws=None, cbar_ax=None,\n    square=False, xticklabels=\"auto\", yticklabels=\"auto\",\n    mask=None, ax=None,\n    **kwargs\n):\n    \"\"\"Plot rectangular data as a color-encoded matrix.\n\n    This is an Axes-level function and will draw the heatmap into the\n    currently-active Axes if none is provided to the ``ax`` argument.  Part of\n    this Axes space will be taken and used to plot a colormap, unless ``cbar``\n    is False or a separate Axes is provided to ``cbar_ax``.\n\n    Parameters\n    ----------\n    data : rectangular dataset\n        2D dataset that can be coerced into an ndarray. If a Pandas DataFrame\n        is provided, the index/column information will be used to label the\n        columns and rows.\n    vmin, vmax : floats, optional\n        Values to anchor the colormap, otherwise they are inferred from the\n        data and other keyword arguments.\n    cmap : matplotlib colormap name or object, or list of colors, optional\n        The mapping from data values to color space. If not provided, the\n        default will depend on whether ``center`` is set.\n    center : float, optional\n        The value at which to center the colormap when plotting divergent data.\n        Using this parameter will change the default ``cmap`` if none is\n        specified.\n    robust : bool, optional\n        If True and ``vmin`` or ``vmax`` are absent, the colormap range is\n        computed with robust quantiles instead of the extreme values.\n    annot : bool or rectangular dataset, optional\n        If True, write the data value in each cell. If an array-like with the\n        same shape as ``data``, then use this to annotate the heatmap instead\n        of the data. Note that DataFrames will match on position, not index.\n    fmt : str, optional\n        String formatting code to use when adding annotations.\n    annot_kws : dict of key, value mappings, optional\n        Keyword arguments for :meth:`matplotlib.axes.Axes.text` when ``annot``\n        is True.\n    linewidths : float, optional\n        Width of the lines that will divide each cell.\n    linecolor : color, optional\n        Color of the lines that will divide each cell.\n    cbar : bool, optional\n        Whether to draw a colorbar.\n    cbar_kws : dict of key, value mappings, optional\n        Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`.\n    cbar_ax : matplotlib Axes, optional\n        Axes in which to draw the colorbar, otherwise take space from the\n        main Axes.\n    square : bool, optional\n        If True, set the Axes aspect to \"equal\" so each cell will be\n        square-shaped.\n    xticklabels, yticklabels : \"auto\", bool, list-like, or int, optional\n        If True, plot the column names of the dataframe. If False, don't plot\n        the column names. If list-like, plot these alternate labels as the\n        xticklabels. If an integer, use the column names but plot only every\n        n label. If \"auto\", try to densely plot non-overlapping labels.\n    mask : bool array or DataFrame, optional\n        If passed, data will not be shown in cells where ``mask`` is True.\n        Cells with missing values are automatically masked.\n    ax : matplotlib Axes, optional\n        Axes in which to draw the plot, otherwise use the currently-active\n        Axes.\n    kwargs : other keyword arguments\n        All other keyword arguments are passed to\n        :meth:`matplotlib.axes.Axes.pcolormesh`.\n\n    Returns\n    -------\n    ax : matplotlib Axes\n        Axes object with the heatmap.\n\n    See Also\n    --------\n    clustermap : Plot a matrix using hierarchical clustering to arrange the\n                 rows and columns.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/heatmap.rst\n\n    \"\"\"\n    # Initialize the plotter object\n    plotter = _HeatMapper(data, vmin, vmax, cmap, center, robust, annot, fmt,\n                          annot_kws, cbar, cbar_kws, xticklabels,\n                          yticklabels, mask)\n\n    # Add the pcolormesh kwargs here\n    kwargs[\"linewidths\"] = linewidths\n    kwargs[\"edgecolor\"] = linecolor\n\n    # Draw the plot and return the Axes\n    if ax is None:\n        ax = plt.gca()\n    if square:\n        ax.set_aspect(\"equal\")\n    plotter.plot(ax, cbar_ax, kwargs)\n    return ax\n", "tokens": ["seaborn", "matrix", "py", "def", "heatmap", "data", "vmin", "none", "vmax", "none", "cmap", "none", "center", "none", "robust", "false", "annot", "none", "fmt", "2g", "annot_kws", "none", "linewidths", "0", "linecolor", "white", "cbar", "true", "cbar_kws", "none", "cbar_ax", "none", "square", "false", "xticklabels", "auto", "yticklabels", "auto", "mask", "none", "ax", "none", "kwargs", "plot", "rectangular", "data", "as", "a", "color", "encoded", "matrix", "this", "is", "an", "axes", "level", "function", "and", "will", "draw", "the", "heatmap", "into", "the", "currently", "active", "axes", "if", "none", "is", "provided", "to", "the", "ax", "argument", "part", "of", "this", "axes", "space", "will", "be", "taken", "and", "used", "to", "plot", "a", "colormap", "unless", "cbar", "is", "false", "or", "a", "separate", "axes", "is", "provided", "to", "cbar_ax", "parameters", "data", "rectangular", "dataset", "2d", "dataset", "that", "can", "be", "coerced", "into", "an", "ndarray", "if", "a", "pandas", "dataframe", "is", "provided", "the", "index", "column", "information", "will", "be", "used", "to", "label", "the", "columns", "and", "rows", "vmin", "vmax", "floats", "optional", "values", "to", "anchor", "the", "colormap", "otherwise", "they", "are", "inferred", "from", "the", "data", "and", "other", "keyword", "arguments", "cmap", "matplotlib", "colormap", "name", "or", "object", "or", "list", "of", "colors", "optional", "the", "mapping", "from", "data", "values", "to", "color", "space", "if", "not", "provided", "the", "default", "will", "depend", "on", "whether", "center", "is", "set", "center", "float", "optional", "the", "value", "at", "which", "to", "center", "the", "colormap", "when", "plotting", "divergent", "data", "using", "this", "parameter", "will", "change", "the", "default", "cmap", "if", "none", "is", "specified", "robust", "bool", "optional", "if", "true", "and", "vmin", "or", "vmax", "are", "absent", "the", "colormap", "range", "is", "computed", "with", "robust", "quantiles", "instead", "of", "the", "extreme", "values", "annot", "bool", "or", "rectangular", "dataset", "optional", "if", "true", "write", "the", "data", "value", "in", "each", "cell", "if", "an", "array", "like", "with", "the", "same", "shape", "as", "data", "then", "use", "this", "to", "annotate", "the", "heatmap", "instead", "of", "the", "data", "note", "that", "dataframes", "will", "match", "on", "position", "not", "index", "fmt", "str", "optional", "string", "formatting", "code", "to", "use", "when", "adding", "annotations", "annot_kws", "dict", "of", "key", "value", "mappings", "optional", "keyword", "arguments", "for", "meth", "matplotlib", "axes", "axes", "text", "when", "annot", "is", "true", "linewidths", "float", "optional", "width", "of", "the", "lines", "that", "will", "divide", "each", "cell", "linecolor", "color", "optional", "color", "of", "the", "lines", "that", "will", "divide", "each", "cell", "cbar", "bool", "optional", "whether", "to", "draw", "a", "colorbar", "cbar_kws", "dict", "of", "key", "value", "mappings", "optional", "keyword", "arguments", "for", "meth", "matplotlib", "figure", "figure", "colorbar", "cbar_ax", "matplotlib", "axes", "optional", "axes", "in", "which", "to", "draw", "the", "colorbar", "otherwise", "take", "space", "from", "the", "main", "axes", "square", "bool", "optional", "if", "true", "set", "the", "axes", "aspect", "to", "equal", "so", "each", "cell", "will", "be", "square", "shaped", "xticklabels", "yticklabels", "auto", "bool", "list", "like", "or", "int", "optional", "if", "true", "plot", "the", "column", "names", "of", "the", "dataframe", "if", "false", "don", "t", "plot", "the", "column", "names", "if", "list", "like", "plot", "these", "alternate", "labels", "as", "the", "xticklabels", "if", "an", "integer", "use", "the", "column", "names", "but", "plot", "only", "every", "n", "label", "if", "auto", "try", "to", "densely", "plot", "non", "overlapping", "labels", "mask", "bool", "array", "or", "dataframe", "optional", "if", "passed", "data", "will", "not", "be", "shown", "in", "cells", "where", "mask", "is", "true", "cells", "with", "missing", "values", "are", "automatically", "masked", "ax", "matplotlib", "axes", "optional", "axes", "in", "which", "to", "draw", "the", "plot", "otherwise", "use", "the", "currently", "active", "axes", "kwargs", "other", "keyword", "arguments", "all", "other", "keyword", "arguments", "are", "passed", "to", "meth", "matplotlib", "axes", "axes", "pcolormesh", "returns", "ax", "matplotlib", "axes", "axes", "object", "with", "the", "heatmap", "see", "also", "clustermap", "plot", "a", "matrix", "using", "hierarchical", "clustering", "to", "arrange", "the", "rows", "and", "columns", "examples", "include", "docstrings", "heatmap", "rst", "initialize", "the", "plotter", "object", "plotter", "_heatmapper", "data", "vmin", "vmax", "cmap", "center", "robust", "annot", "fmt", "annot_kws", "cbar", "cbar_kws", "xticklabels", "yticklabels", "mask", "add", "the", "pcolormesh", "kwargs", "here", "kwargs", "linewidths", "linewidths", "kwargs", "edgecolor", "linecolor", "draw", "the", "plot", "and", "return", "the", "axes", "if", "ax", "is", "none", "ax", "plt", "gca", "if", "square", "ax", "set_aspect", "equal", "plotter", "plot", "ax", "cbar_ax", "kwargs", "return", "ax"], "doc_len": 596}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter.__init__", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "__init__", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def __init__(self, data, linkage, metric, method, axis, label, rotate):\n        \"\"\"Plot a dendrogram of the relationships between the columns of data\n\n        Parameters\n        ----------\n        data : pandas.DataFrame\n            Rectangular data\n        \"\"\"\n        self.axis = axis\n        if self.axis == 1:\n            data = data.T\n\n        if isinstance(data, pd.DataFrame):\n            array = data.values\n        else:\n            array = np.asarray(data)\n            data = pd.DataFrame(array)\n\n        self.array = array\n        self.data = data\n\n        self.shape = self.data.shape\n        self.metric = metric\n        self.method = method\n        self.axis = axis\n        self.label = label\n        self.rotate = rotate\n\n        if linkage is None:\n            self.linkage = self.calculated_linkage\n        else:\n            self.linkage = linkage\n        self.dendrogram = self.calculate_dendrogram()\n\n        # Dendrogram ends are always at multiples of 5, who knows why\n        ticks = 10 * np.arange(self.data.shape[0]) + 5\n\n        if self.label:\n            ticklabels = _index_to_ticklabels(self.data.index)\n            ticklabels = [ticklabels[i] for i in self.reordered_ind]\n            if self.rotate:\n                self.xticks = []\n                self.yticks = ticks\n                self.xticklabels = []\n\n                self.yticklabels = ticklabels\n                self.ylabel = _index_to_label(self.data.index)\n                self.xlabel = ''\n            else:\n                self.xticks = ticks\n                self.yticks = []\n                self.xticklabels = ticklabels\n                self.yticklabels = []\n                self.ylabel = ''\n                self.xlabel = _index_to_label(self.data.index)\n        else:\n            self.xticks, self.yticks = [], []\n            self.yticklabels, self.xticklabels = [], []\n            self.xlabel, self.ylabel = '', ''\n\n        self.dependent_coord = self.dendrogram['dcoord']\n        self.independent_coord = self.dendrogram['icoord']\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "__init__", "self", "data", "linkage", "metric", "method", "axis", "label", "rotate", "plot", "a", "dendrogram", "of", "the", "relationships", "between", "the", "columns", "of", "data", "parameters", "data", "pandas", "dataframe", "rectangular", "data", "self", "axis", "axis", "if", "self", "axis", "1", "data", "data", "t", "if", "isinstance", "data", "pd", "dataframe", "array", "data", "values", "else", "array", "np", "asarray", "data", "data", "pd", "dataframe", "array", "self", "array", "array", "self", "data", "data", "self", "shape", "self", "data", "shape", "self", "metric", "metric", "self", "method", "method", "self", "axis", "axis", "self", "label", "label", "self", "rotate", "rotate", "if", "linkage", "is", "none", "self", "linkage", "self", "calculated_linkage", "else", "self", "linkage", "linkage", "self", "dendrogram", "self", "calculate_dendrogram", "dendrogram", "ends", "are", "always", "at", "multiples", "of", "5", "who", "knows", "why", "ticks", "10", "np", "arange", "self", "data", "shape", "0", "5", "if", "self", "label", "ticklabels", "_index_to_ticklabels", "self", "data", "index", "ticklabels", "ticklabels", "i", "for", "i", "in", "self", "reordered_ind", "if", "self", "rotate", "self", "xticks", "self", "yticks", "ticks", "self", "xticklabels", "self", "yticklabels", "ticklabels", "self", "ylabel", "_index_to_label", "self", "data", "index", "self", "xlabel", "else", "self", "xticks", "ticks", "self", "yticks", "self", "xticklabels", "ticklabels", "self", "yticklabels", "self", "ylabel", "self", "xlabel", "_index_to_label", "self", "data", "index", "else", "self", "xticks", "self", "yticks", "self", "yticklabels", "self", "xticklabels", "self", "xlabel", "self", "ylabel", "self", "dependent_coord", "self", "dendrogram", "dcoord", "self", "independent_coord", "self", "dendrogram", "icoord"], "doc_len": 199}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter._calculate_linkage_scipy", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "_calculate_linkage_scipy", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def _calculate_linkage_scipy(self):\n        linkage = hierarchy.linkage(self.array, method=self.method,\n                                    metric=self.metric)\n        return linkage\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "_calculate_linkage_scipy", "self", "linkage", "hierarchy", "linkage", "self", "array", "method", "self", "method", "metric", "self", "metric", "return", "linkage"], "doc_len": 20}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter._calculate_linkage_fastcluster", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "_calculate_linkage_fastcluster", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def _calculate_linkage_fastcluster(self):\n        import fastcluster\n        # Fastcluster has a memory-saving vectorized version, but only\n        # with certain linkage methods, and mostly with euclidean metric\n        # vector_methods = ('single', 'centroid', 'median', 'ward')\n        euclidean_methods = ('centroid', 'median', 'ward')\n        euclidean = self.metric == 'euclidean' and self.method in \\\n            euclidean_methods\n        if euclidean or self.method == 'single':\n            return fastcluster.linkage_vector(self.array,\n                                              method=self.method,\n                                              metric=self.metric)\n        else:\n            linkage = fastcluster.linkage(self.array, method=self.method,\n                                          metric=self.metric)\n            return linkage\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "_calculate_linkage_fastcluster", "self", "import", "fastcluster", "fastcluster", "has", "a", "memory", "saving", "vectorized", "version", "but", "only", "with", "certain", "linkage", "methods", "and", "mostly", "with", "euclidean", "metric", "vector_methods", "single", "centroid", "median", "ward", "euclidean_methods", "centroid", "median", "ward", "euclidean", "self", "metric", "euclidean", "and", "self", "method", "in", "euclidean_methods", "if", "euclidean", "or", "self", "method", "single", "return", "fastcluster", "linkage_vector", "self", "array", "method", "self", "method", "metric", "self", "metric", "else", "linkage", "fastcluster", "linkage", "self", "array", "method", "self", "method", "metric", "self", "metric", "return", "linkage"], "doc_len": 76}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter.calculated_linkage", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "calculated_linkage", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def calculated_linkage(self):\n\n        try:\n            return self._calculate_linkage_fastcluster()\n        except ImportError:\n            if np.product(self.shape) >= 10000:\n                msg = (\"Clustering large matrix with scipy. Installing \"\n                       \"`fastcluster` may give better performance.\")\n                warnings.warn(msg)\n\n        return self._calculate_linkage_scipy()\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "calculated_linkage", "self", "try", "return", "self", "_calculate_linkage_fastcluster", "except", "importerror", "if", "np", "product", "self", "shape", "10000", "msg", "clustering", "large", "matrix", "with", "scipy", "installing", "fastcluster", "may", "give", "better", "performance", "warnings", "warn", "msg", "return", "self", "_calculate_linkage_scipy"], "doc_len": 37}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter.calculate_dendrogram", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "calculate_dendrogram", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def calculate_dendrogram(self):\n        \"\"\"Calculates a dendrogram based on the linkage matrix\n\n        Made a separate function, not a property because don't want to\n        recalculate the dendrogram every time it is accessed.\n\n        Returns\n        -------\n        dendrogram : dict\n            Dendrogram dictionary as returned by scipy.cluster.hierarchy\n            .dendrogram. The important key-value pairing is\n            \"reordered_ind\" which indicates the re-ordering of the matrix\n        \"\"\"\n        return hierarchy.dendrogram(self.linkage, no_plot=True,\n                                    color_threshold=-np.inf)\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "calculate_dendrogram", "self", "calculates", "a", "dendrogram", "based", "on", "the", "linkage", "matrix", "made", "a", "separate", "function", "not", "a", "property", "because", "don", "t", "want", "to", "recalculate", "the", "dendrogram", "every", "time", "it", "is", "accessed", "returns", "dendrogram", "dict", "dendrogram", "dictionary", "as", "returned", "by", "scipy", "cluster", "hierarchy", "dendrogram", "the", "important", "key", "value", "pairing", "is", "reordered_ind", "which", "indicates", "the", "re", "ordering", "of", "the", "matrix", "return", "hierarchy", "dendrogram", "self", "linkage", "no_plot", "true", "color_threshold", "np", "inf"], "doc_len": 72}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter.reordered_ind", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "reordered_ind", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def reordered_ind(self):\n        \"\"\"Indices of the matrix, reordered by the dendrogram\"\"\"\n        return self.dendrogram['leaves']\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "reordered_ind", "self", "indices", "of", "the", "matrix", "reordered", "by", "the", "dendrogram", "return", "self", "dendrogram", "leaves"], "doc_len": 19}
{"doc_id": "seaborn/matrix.py::_DendrogramPlotter.plot", "file_path": "seaborn/matrix.py", "class_name": "_DendrogramPlotter", "func_name": "plot", "text": "文件路径: seaborn/matrix.py, 类名: _DendrogramPlotter\n    def plot(self, ax, tree_kws):\n        \"\"\"Plots a dendrogram of the similarities between data on the axes\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            Axes object upon which the dendrogram is plotted\n\n        \"\"\"\n        tree_kws = {} if tree_kws is None else tree_kws.copy()\n        tree_kws.setdefault(\"linewidths\", .5)\n        tree_kws.setdefault(\"colors\", tree_kws.pop(\"color\", (.2, .2, .2)))\n\n        if self.rotate and self.axis == 0:\n            coords = zip(self.dependent_coord, self.independent_coord)\n        else:\n            coords = zip(self.independent_coord, self.dependent_coord)\n        lines = LineCollection([list(zip(x, y)) for x, y in coords],\n                               **tree_kws)\n\n        ax.add_collection(lines)\n        number_of_leaves = len(self.reordered_ind)\n        max_dependent_coord = max(map(max, self.dependent_coord))\n\n        if self.rotate:\n            ax.yaxis.set_ticks_position('right')\n\n            # Constants 10 and 1.05 come from\n            # `scipy.cluster.hierarchy._plot_dendrogram`\n            ax.set_ylim(0, number_of_leaves * 10)\n            ax.set_xlim(0, max_dependent_coord * 1.05)\n\n            ax.invert_xaxis()\n            ax.invert_yaxis()\n        else:\n            # Constants 10 and 1.05 come from\n            # `scipy.cluster.hierarchy._plot_dendrogram`\n            ax.set_xlim(0, number_of_leaves * 10)\n            ax.set_ylim(0, max_dependent_coord * 1.05)\n\n        despine(ax=ax, bottom=True, left=True)\n\n        ax.set(xticks=self.xticks, yticks=self.yticks,\n               xlabel=self.xlabel, ylabel=self.ylabel)\n        xtl = ax.set_xticklabels(self.xticklabels)\n        ytl = ax.set_yticklabels(self.yticklabels, rotation='vertical')\n\n        # Force a draw of the plot to avoid matplotlib window error\n        _draw_figure(ax.figure)\n\n        if len(ytl) > 0 and axis_ticklabels_overlap(ytl):\n            plt.setp(ytl, rotation=\"horizontal\")\n        if len(xtl) > 0 and axis_ticklabels_overlap(xtl):\n            plt.setp(xtl, rotation=\"vertical\")\n        return self\n", "tokens": ["seaborn", "matrix", "py", "_dendrogramplotter", "def", "plot", "self", "ax", "tree_kws", "plots", "a", "dendrogram", "of", "the", "similarities", "between", "data", "on", "the", "axes", "parameters", "ax", "matplotlib", "axes", "axes", "axes", "object", "upon", "which", "the", "dendrogram", "is", "plotted", "tree_kws", "if", "tree_kws", "is", "none", "else", "tree_kws", "copy", "tree_kws", "setdefault", "linewidths", "5", "tree_kws", "setdefault", "colors", "tree_kws", "pop", "color", "2", "2", "2", "if", "self", "rotate", "and", "self", "axis", "0", "coords", "zip", "self", "dependent_coord", "self", "independent_coord", "else", "coords", "zip", "self", "independent_coord", "self", "dependent_coord", "lines", "linecollection", "list", "zip", "x", "y", "for", "x", "y", "in", "coords", "tree_kws", "ax", "add_collection", "lines", "number_of_leaves", "len", "self", "reordered_ind", "max_dependent_coord", "max", "map", "max", "self", "dependent_coord", "if", "self", "rotate", "ax", "yaxis", "set_ticks_position", "right", "constants", "10", "and", "1", "05", "come", "from", "scipy", "cluster", "hierarchy", "_plot_dendrogram", "ax", "set_ylim", "0", "number_of_leaves", "10", "ax", "set_xlim", "0", "max_dependent_coord", "1", "05", "ax", "invert_xaxis", "ax", "invert_yaxis", "else", "constants", "10", "and", "1", "05", "come", "from", "scipy", "cluster", "hierarchy", "_plot_dendrogram", "ax", "set_xlim", "0", "number_of_leaves", "10", "ax", "set_ylim", "0", "max_dependent_coord", "1", "05", "despine", "ax", "ax", "bottom", "true", "left", "true", "ax", "set", "xticks", "self", "xticks", "yticks", "self", "yticks", "xlabel", "self", "xlabel", "ylabel", "self", "ylabel", "xtl", "ax", "set_xticklabels", "self", "xticklabels", "ytl", "ax", "set_yticklabels", "self", "yticklabels", "rotation", "vertical", "force", "a", "draw", "of", "the", "plot", "to", "avoid", "matplotlib", "window", "error", "_draw_figure", "ax", "figure", "if", "len", "ytl", "0", "and", "axis_ticklabels_overlap", "ytl", "plt", "setp", "ytl", "rotation", "horizontal", "if", "len", "xtl", "0", "and", "axis_ticklabels_overlap", "xtl", "plt", "setp", "xtl", "rotation", "vertical", "return", "self"], "doc_len": 228}
{"doc_id": "seaborn/matrix.py::dendrogram", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "dendrogram", "text": "文件路径: seaborn/matrix.py\ndef dendrogram(\n    data, *,\n    linkage=None, axis=1, label=True, metric='euclidean',\n    method='average', rotate=False, tree_kws=None, ax=None\n):\n    \"\"\"Draw a tree diagram of relationships within a matrix\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        Rectangular data\n    linkage : numpy.array, optional\n        Linkage matrix\n    axis : int, optional\n        Which axis to use to calculate linkage. 0 is rows, 1 is columns.\n    label : bool, optional\n        If True, label the dendrogram at leaves with column or row names\n    metric : str, optional\n        Distance metric. Anything valid for scipy.spatial.distance.pdist\n    method : str, optional\n        Linkage method to use. Anything valid for\n        scipy.cluster.hierarchy.linkage\n    rotate : bool, optional\n        When plotting the matrix, whether to rotate it 90 degrees\n        counter-clockwise, so the leaves face right\n    tree_kws : dict, optional\n        Keyword arguments for the ``matplotlib.collections.LineCollection``\n        that is used for plotting the lines of the dendrogram tree.\n    ax : matplotlib axis, optional\n        Axis to plot on, otherwise uses current axis\n\n    Returns\n    -------\n    dendrogramplotter : _DendrogramPlotter\n        A Dendrogram plotter object.\n\n    Notes\n    -----\n    Access the reordered dendrogram indices with\n    dendrogramplotter.reordered_ind\n\n    \"\"\"\n    if _no_scipy:\n        raise RuntimeError(\"dendrogram requires scipy to be installed\")\n\n    plotter = _DendrogramPlotter(data, linkage=linkage, axis=axis,\n                                 metric=metric, method=method,\n                                 label=label, rotate=rotate)\n    if ax is None:\n        ax = plt.gca()\n\n    return plotter.plot(ax=ax, tree_kws=tree_kws)\n", "tokens": ["seaborn", "matrix", "py", "def", "dendrogram", "data", "linkage", "none", "axis", "1", "label", "true", "metric", "euclidean", "method", "average", "rotate", "false", "tree_kws", "none", "ax", "none", "draw", "a", "tree", "diagram", "of", "relationships", "within", "a", "matrix", "parameters", "data", "pandas", "dataframe", "rectangular", "data", "linkage", "numpy", "array", "optional", "linkage", "matrix", "axis", "int", "optional", "which", "axis", "to", "use", "to", "calculate", "linkage", "0", "is", "rows", "1", "is", "columns", "label", "bool", "optional", "if", "true", "label", "the", "dendrogram", "at", "leaves", "with", "column", "or", "row", "names", "metric", "str", "optional", "distance", "metric", "anything", "valid", "for", "scipy", "spatial", "distance", "pdist", "method", "str", "optional", "linkage", "method", "to", "use", "anything", "valid", "for", "scipy", "cluster", "hierarchy", "linkage", "rotate", "bool", "optional", "when", "plotting", "the", "matrix", "whether", "to", "rotate", "it", "90", "degrees", "counter", "clockwise", "so", "the", "leaves", "face", "right", "tree_kws", "dict", "optional", "keyword", "arguments", "for", "the", "matplotlib", "collections", "linecollection", "that", "is", "used", "for", "plotting", "the", "lines", "of", "the", "dendrogram", "tree", "ax", "matplotlib", "axis", "optional", "axis", "to", "plot", "on", "otherwise", "uses", "current", "axis", "returns", "dendrogramplotter", "_dendrogramplotter", "a", "dendrogram", "plotter", "object", "notes", "access", "the", "reordered", "dendrogram", "indices", "with", "dendrogramplotter", "reordered_ind", "if", "_no_scipy", "raise", "runtimeerror", "dendrogram", "requires", "scipy", "to", "be", "installed", "plotter", "_dendrogramplotter", "data", "linkage", "linkage", "axis", "axis", "metric", "metric", "method", "method", "label", "label", "rotate", "rotate", "if", "ax", "is", "none", "ax", "plt", "gca", "return", "plotter", "plot", "ax", "ax", "tree_kws", "tree_kws"], "doc_len": 208}
{"doc_id": "seaborn/matrix.py::ClusterGrid.__init__", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "__init__", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=None,\n                 figsize=None, row_colors=None, col_colors=None, mask=None,\n                 dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):\n        \"\"\"Grid object for organizing clustered heatmap input on to axes\"\"\"\n        if _no_scipy:\n            raise RuntimeError(\"ClusterGrid requires scipy to be available\")\n\n        if isinstance(data, pd.DataFrame):\n            self.data = data\n        else:\n            self.data = pd.DataFrame(data)\n\n        self.data2d = self.format_data(self.data, pivot_kws, z_score,\n                                       standard_scale)\n\n        self.mask = _matrix_mask(self.data2d, mask)\n\n        self._figure = plt.figure(figsize=figsize)\n\n        self.row_colors, self.row_color_labels = \\\n            self._preprocess_colors(data, row_colors, axis=0)\n        self.col_colors, self.col_color_labels = \\\n            self._preprocess_colors(data, col_colors, axis=1)\n\n        try:\n            row_dendrogram_ratio, col_dendrogram_ratio = dendrogram_ratio\n        except TypeError:\n            row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio\n\n        try:\n            row_colors_ratio, col_colors_ratio = colors_ratio\n        except TypeError:\n            row_colors_ratio = col_colors_ratio = colors_ratio\n\n        width_ratios = self.dim_ratios(self.row_colors,\n                                       row_dendrogram_ratio,\n                                       row_colors_ratio)\n        height_ratios = self.dim_ratios(self.col_colors,\n                                        col_dendrogram_ratio,\n                                        col_colors_ratio)\n\n        nrows = 2 if self.col_colors is None else 3\n        ncols = 2 if self.row_colors is None else 3\n\n        self.gs = gridspec.GridSpec(nrows, ncols,\n                                    width_ratios=width_ratios,\n                                    height_ratios=height_ratios)\n\n        self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-1, 0])\n        self.ax_col_dendrogram = self._figure.add_subplot(self.gs[0, -1])\n        self.ax_row_dendrogram.set_axis_off()\n        self.ax_col_dendrogram.set_axis_off()\n\n        self.ax_row_colors = None\n        self.ax_col_colors = None\n\n        if self.row_colors is not None:\n            self.ax_row_colors = self._figure.add_subplot(\n                self.gs[-1, 1])\n        if self.col_colors is not None:\n            self.ax_col_colors = self._figure.add_subplot(\n                self.gs[1, -1])\n\n        self.ax_heatmap = self._figure.add_subplot(self.gs[-1, -1])\n        if cbar_pos is None:\n            self.ax_cbar = self.cax = None\n        else:\n            # Initialize the colorbar axes in the gridspec so that tight_layout\n            # works. We will move it where it belongs later. This is a hack.\n            self.ax_cbar = self._figure.add_subplot(self.gs[0, 0])\n            self.cax = self.ax_cbar  # Backwards compatibility\n        self.cbar_pos = cbar_pos\n\n        self.dendrogram_row = None\n        self.dendrogram_col = None\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "__init__", "self", "data", "pivot_kws", "none", "z_score", "none", "standard_scale", "none", "figsize", "none", "row_colors", "none", "col_colors", "none", "mask", "none", "dendrogram_ratio", "none", "colors_ratio", "none", "cbar_pos", "none", "grid", "object", "for", "organizing", "clustered", "heatmap", "input", "on", "to", "axes", "if", "_no_scipy", "raise", "runtimeerror", "clustergrid", "requires", "scipy", "to", "be", "available", "if", "isinstance", "data", "pd", "dataframe", "self", "data", "data", "else", "self", "data", "pd", "dataframe", "data", "self", "data2d", "self", "format_data", "self", "data", "pivot_kws", "z_score", "standard_scale", "self", "mask", "_matrix_mask", "self", "data2d", "mask", "self", "_figure", "plt", "figure", "figsize", "figsize", "self", "row_colors", "self", "row_color_labels", "self", "_preprocess_colors", "data", "row_colors", "axis", "0", "self", "col_colors", "self", "col_color_labels", "self", "_preprocess_colors", "data", "col_colors", "axis", "1", "try", "row_dendrogram_ratio", "col_dendrogram_ratio", "dendrogram_ratio", "except", "typeerror", "row_dendrogram_ratio", "col_dendrogram_ratio", "dendrogram_ratio", "try", "row_colors_ratio", "col_colors_ratio", "colors_ratio", "except", "typeerror", "row_colors_ratio", "col_colors_ratio", "colors_ratio", "width_ratios", "self", "dim_ratios", "self", "row_colors", "row_dendrogram_ratio", "row_colors_ratio", "height_ratios", "self", "dim_ratios", "self", "col_colors", "col_dendrogram_ratio", "col_colors_ratio", "nrows", "2", "if", "self", "col_colors", "is", "none", "else", "3", "ncols", "2", "if", "self", "row_colors", "is", "none", "else", "3", "self", "gs", "gridspec", "gridspec", "nrows", "ncols", "width_ratios", "width_ratios", "height_ratios", "height_ratios", "self", "ax_row_dendrogram", "self", "_figure", "add_subplot", "self", "gs", "1", "0", "self", "ax_col_dendrogram", "self", "_figure", "add_subplot", "self", "gs", "0", "1", "self", "ax_row_dendrogram", "set_axis_off", "self", "ax_col_dendrogram", "set_axis_off", "self", "ax_row_colors", "none", "self", "ax_col_colors", "none", "if", "self", "row_colors", "is", "not", "none", "self", "ax_row_colors", "self", "_figure", "add_subplot", "self", "gs", "1", "1", "if", "self", "col_colors", "is", "not", "none", "self", "ax_col_colors", "self", "_figure", "add_subplot", "self", "gs", "1", "1", "self", "ax_heatmap", "self", "_figure", "add_subplot", "self", "gs", "1", "1", "if", "cbar_pos", "is", "none", "self", "ax_cbar", "self", "cax", "none", "else", "initialize", "the", "colorbar", "axes", "in", "the", "gridspec", "so", "that", "tight_layout", "works", "we", "will", "move", "it", "where", "it", "belongs", "later", "this", "is", "a", "hack", "self", "ax_cbar", "self", "_figure", "add_subplot", "self", "gs", "0", "0", "self", "cax", "self", "ax_cbar", "backwards", "compatibility", "self", "cbar_pos", "cbar_pos", "self", "dendrogram_row", "none", "self", "dendrogram_col", "none"], "doc_len": 289}
{"doc_id": "seaborn/matrix.py::ClusterGrid._preprocess_colors", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "_preprocess_colors", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def _preprocess_colors(self, data, colors, axis):\n        \"\"\"Preprocess {row/col}_colors to extract labels and convert colors.\"\"\"\n        labels = None\n\n        if colors is not None:\n            if isinstance(colors, (pd.DataFrame, pd.Series)):\n\n                # If data is unindexed, raise\n                if (not hasattr(data, \"index\") and axis == 0) or (\n                    not hasattr(data, \"columns\") and axis == 1\n                ):\n                    axis_name = \"col\" if axis else \"row\"\n                    msg = (f\"{axis_name}_colors indices can't be matched with data \"\n                           f\"indices. Provide {axis_name}_colors as a non-indexed \"\n                           \"datatype, e.g. by using `.to_numpy()``\")\n                    raise TypeError(msg)\n\n                # Ensure colors match data indices\n                if axis == 0:\n                    colors = colors.reindex(data.index)\n                else:\n                    colors = colors.reindex(data.columns)\n\n                # Replace na's with white color\n                # TODO We should set these to transparent instead\n                colors = colors.astype(object).fillna('white')\n\n                # Extract color values and labels from frame/series\n                if isinstance(colors, pd.DataFrame):\n                    labels = list(colors.columns)\n                    colors = colors.T.values\n                else:\n                    if colors.name is None:\n                        labels = [\"\"]\n                    else:\n                        labels = [colors.name]\n                    colors = colors.values\n\n            colors = _convert_colors(colors)\n\n        return colors, labels\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "_preprocess_colors", "self", "data", "colors", "axis", "preprocess", "row", "col", "_colors", "to", "extract", "labels", "and", "convert", "colors", "labels", "none", "if", "colors", "is", "not", "none", "if", "isinstance", "colors", "pd", "dataframe", "pd", "series", "if", "data", "is", "unindexed", "raise", "if", "not", "hasattr", "data", "index", "and", "axis", "0", "or", "not", "hasattr", "data", "columns", "and", "axis", "1", "axis_name", "col", "if", "axis", "else", "row", "msg", "f", "axis_name", "_colors", "indices", "can", "t", "be", "matched", "with", "data", "f", "indices", "provide", "axis_name", "_colors", "as", "a", "non", "indexed", "datatype", "e", "g", "by", "using", "to_numpy", "raise", "typeerror", "msg", "ensure", "colors", "match", "data", "indices", "if", "axis", "0", "colors", "colors", "reindex", "data", "index", "else", "colors", "colors", "reindex", "data", "columns", "replace", "na", "s", "with", "white", "color", "todo", "we", "should", "set", "these", "to", "transparent", "instead", "colors", "colors", "astype", "object", "fillna", "white", "extract", "color", "values", "and", "labels", "from", "frame", "series", "if", "isinstance", "colors", "pd", "dataframe", "labels", "list", "colors", "columns", "colors", "colors", "t", "values", "else", "if", "colors", "name", "is", "none", "labels", "else", "labels", "colors", "name", "colors", "colors", "values", "colors", "_convert_colors", "colors", "return", "colors", "labels"], "doc_len": 170}
{"doc_id": "seaborn/matrix.py::ClusterGrid.format_data", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "format_data", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def format_data(self, data, pivot_kws, z_score=None,\n                    standard_scale=None):\n        \"\"\"Extract variables from data or use directly.\"\"\"\n\n        # Either the data is already in 2d matrix format, or need to do a pivot\n        if pivot_kws is not None:\n            data2d = data.pivot(**pivot_kws)\n        else:\n            data2d = data\n\n        if z_score is not None and standard_scale is not None:\n            raise ValueError(\n                'Cannot perform both z-scoring and standard-scaling on data')\n\n        if z_score is not None:\n            data2d = self.z_score(data2d, z_score)\n        if standard_scale is not None:\n            data2d = self.standard_scale(data2d, standard_scale)\n        return data2d\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "format_data", "self", "data", "pivot_kws", "z_score", "none", "standard_scale", "none", "extract", "variables", "from", "data", "or", "use", "directly", "either", "the", "data", "is", "already", "in", "2d", "matrix", "format", "or", "need", "to", "do", "a", "pivot", "if", "pivot_kws", "is", "not", "none", "data2d", "data", "pivot", "pivot_kws", "else", "data2d", "data", "if", "z_score", "is", "not", "none", "and", "standard_scale", "is", "not", "none", "raise", "valueerror", "cannot", "perform", "both", "z", "scoring", "and", "standard", "scaling", "on", "data", "if", "z_score", "is", "not", "none", "data2d", "self", "z_score", "data2d", "z_score", "if", "standard_scale", "is", "not", "none", "data2d", "self", "standard_scale", "data2d", "standard_scale", "return", "data2d"], "doc_len": 91}
{"doc_id": "seaborn/matrix.py::ClusterGrid.z_score", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "z_score", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def z_score(data2d, axis=1):\n        \"\"\"Standarize the mean and variance of the data axis\n\n        Parameters\n        ----------\n        data2d : pandas.DataFrame\n            Data to normalize\n        axis : int\n            Which axis to normalize across. If 0, normalize across rows, if 1,\n            normalize across columns.\n\n        Returns\n        -------\n        normalized : pandas.DataFrame\n            Noramlized data with a mean of 0 and variance of 1 across the\n            specified axis.\n        \"\"\"\n        if axis == 1:\n            z_scored = data2d\n        else:\n            z_scored = data2d.T\n\n        z_scored = (z_scored - z_scored.mean()) / z_scored.std()\n\n        if axis == 1:\n            return z_scored\n        else:\n            return z_scored.T\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "z_score", "data2d", "axis", "1", "standarize", "the", "mean", "and", "variance", "of", "the", "data", "axis", "parameters", "data2d", "pandas", "dataframe", "data", "to", "normalize", "axis", "int", "which", "axis", "to", "normalize", "across", "if", "0", "normalize", "across", "rows", "if", "1", "normalize", "across", "columns", "returns", "normalized", "pandas", "dataframe", "noramlized", "data", "with", "a", "mean", "of", "0", "and", "variance", "of", "1", "across", "the", "specified", "axis", "if", "axis", "1", "z_scored", "data2d", "else", "z_scored", "data2d", "t", "z_scored", "z_scored", "z_scored", "mean", "z_scored", "std", "if", "axis", "1", "return", "z_scored", "else", "return", "z_scored", "t"], "doc_len": 85}
{"doc_id": "seaborn/matrix.py::ClusterGrid.standard_scale", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "standard_scale", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def standard_scale(data2d, axis=1):\n        \"\"\"Divide the data by the difference between the max and min\n\n        Parameters\n        ----------\n        data2d : pandas.DataFrame\n            Data to normalize\n        axis : int\n            Which axis to normalize across. If 0, normalize across rows, if 1,\n            normalize across columns.\n\n        Returns\n        -------\n        standardized : pandas.DataFrame\n            Noramlized data with a mean of 0 and variance of 1 across the\n            specified axis.\n\n        \"\"\"\n        # Normalize these values to range from 0 to 1\n        if axis == 1:\n            standardized = data2d\n        else:\n            standardized = data2d.T\n\n        subtract = standardized.min()\n        standardized = (standardized - subtract) / (\n            standardized.max() - standardized.min())\n\n        if axis == 1:\n            return standardized\n        else:\n            return standardized.T\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "standard_scale", "data2d", "axis", "1", "divide", "the", "data", "by", "the", "difference", "between", "the", "max", "and", "min", "parameters", "data2d", "pandas", "dataframe", "data", "to", "normalize", "axis", "int", "which", "axis", "to", "normalize", "across", "if", "0", "normalize", "across", "rows", "if", "1", "normalize", "across", "columns", "returns", "standardized", "pandas", "dataframe", "noramlized", "data", "with", "a", "mean", "of", "0", "and", "variance", "of", "1", "across", "the", "specified", "axis", "normalize", "these", "values", "to", "range", "from", "0", "to", "1", "if", "axis", "1", "standardized", "data2d", "else", "standardized", "data2d", "t", "subtract", "standardized", "min", "standardized", "standardized", "subtract", "standardized", "max", "standardized", "min", "if", "axis", "1", "return", "standardized", "else", "return", "standardized", "t"], "doc_len": 100}
{"doc_id": "seaborn/matrix.py::ClusterGrid.dim_ratios", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "dim_ratios", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def dim_ratios(self, colors, dendrogram_ratio, colors_ratio):\n        \"\"\"Get the proportions of the figure taken up by each axes.\"\"\"\n        ratios = [dendrogram_ratio]\n\n        if colors is not None:\n            # Colors are encoded as rgb, so there is an extra dimension\n            if np.ndim(colors) > 2:\n                n_colors = len(colors)\n            else:\n                n_colors = 1\n\n            ratios += [n_colors * colors_ratio]\n\n        # Add the ratio for the heatmap itself\n        ratios.append(1 - sum(ratios))\n\n        return ratios\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "dim_ratios", "self", "colors", "dendrogram_ratio", "colors_ratio", "get", "the", "proportions", "of", "the", "figure", "taken", "up", "by", "each", "axes", "ratios", "dendrogram_ratio", "if", "colors", "is", "not", "none", "colors", "are", "encoded", "as", "rgb", "so", "there", "is", "an", "extra", "dimension", "if", "np", "ndim", "colors", "2", "n_colors", "len", "colors", "else", "n_colors", "1", "ratios", "n_colors", "colors_ratio", "add", "the", "ratio", "for", "the", "heatmap", "itself", "ratios", "append", "1", "sum", "ratios", "return", "ratios"], "doc_len": 67}
{"doc_id": "seaborn/matrix.py::ClusterGrid.color_list_to_matrix_and_cmap", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "color_list_to_matrix_and_cmap", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def color_list_to_matrix_and_cmap(colors, ind, axis=0):\n        \"\"\"Turns a list of colors into a numpy matrix and matplotlib colormap\n\n        These arguments can now be plotted using heatmap(matrix, cmap)\n        and the provided colors will be plotted.\n\n        Parameters\n        ----------\n        colors : list of matplotlib colors\n            Colors to label the rows or columns of a dataframe.\n        ind : list of ints\n            Ordering of the rows or columns, to reorder the original colors\n            by the clustered dendrogram order\n        axis : int\n            Which axis this is labeling\n\n        Returns\n        -------\n        matrix : numpy.array\n            A numpy array of integer values, where each indexes into the cmap\n        cmap : matplotlib.colors.ListedColormap\n\n        \"\"\"\n        try:\n            mpl.colors.to_rgb(colors[0])\n        except ValueError:\n            # We have a 2D color structure\n            m, n = len(colors), len(colors[0])\n            if not all(len(c) == n for c in colors[1:]):\n                raise ValueError(\"Multiple side color vectors must have same size\")\n        else:\n            # We have one vector of colors\n            m, n = 1, len(colors)\n            colors = [colors]\n\n        # Map from unique colors to colormap index value\n        unique_colors = {}\n        matrix = np.zeros((m, n), int)\n        for i, inner in enumerate(colors):\n            for j, color in enumerate(inner):\n                idx = unique_colors.setdefault(color, len(unique_colors))\n                matrix[i, j] = idx\n\n        # Reorder for clustering and transpose for axis\n        matrix = matrix[:, ind]\n        if axis == 0:\n            matrix = matrix.T\n\n        cmap = mpl.colors.ListedColormap(list(unique_colors))\n        return matrix, cmap\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "color_list_to_matrix_and_cmap", "colors", "ind", "axis", "0", "turns", "a", "list", "of", "colors", "into", "a", "numpy", "matrix", "and", "matplotlib", "colormap", "these", "arguments", "can", "now", "be", "plotted", "using", "heatmap", "matrix", "cmap", "and", "the", "provided", "colors", "will", "be", "plotted", "parameters", "colors", "list", "of", "matplotlib", "colors", "colors", "to", "label", "the", "rows", "or", "columns", "of", "a", "dataframe", "ind", "list", "of", "ints", "ordering", "of", "the", "rows", "or", "columns", "to", "reorder", "the", "original", "colors", "by", "the", "clustered", "dendrogram", "order", "axis", "int", "which", "axis", "this", "is", "labeling", "returns", "matrix", "numpy", "array", "a", "numpy", "array", "of", "integer", "values", "where", "each", "indexes", "into", "the", "cmap", "cmap", "matplotlib", "colors", "listedcolormap", "try", "mpl", "colors", "to_rgb", "colors", "0", "except", "valueerror", "we", "have", "a", "2d", "color", "structure", "m", "n", "len", "colors", "len", "colors", "0", "if", "not", "all", "len", "c", "n", "for", "c", "in", "colors", "1", "raise", "valueerror", "multiple", "side", "color", "vectors", "must", "have", "same", "size", "else", "we", "have", "one", "vector", "of", "colors", "m", "n", "1", "len", "colors", "colors", "colors", "map", "from", "unique", "colors", "to", "colormap", "index", "value", "unique_colors", "matrix", "np", "zeros", "m", "n", "int", "for", "i", "inner", "in", "enumerate", "colors", "for", "j", "color", "in", "enumerate", "inner", "idx", "unique_colors", "setdefault", "color", "len", "unique_colors", "matrix", "i", "j", "idx", "reorder", "for", "clustering", "and", "transpose", "for", "axis", "matrix", "matrix", "ind", "if", "axis", "0", "matrix", "matrix", "t", "cmap", "mpl", "colors", "listedcolormap", "list", "unique_colors", "return", "matrix", "cmap"], "doc_len": 220}
{"doc_id": "seaborn/matrix.py::ClusterGrid.plot_dendrograms", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "plot_dendrograms", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def plot_dendrograms(self, row_cluster, col_cluster, metric, method,\n                         row_linkage, col_linkage, tree_kws):\n        # Plot the row dendrogram\n        if row_cluster:\n            self.dendrogram_row = dendrogram(\n                self.data2d, metric=metric, method=method, label=False, axis=0,\n                ax=self.ax_row_dendrogram, rotate=True, linkage=row_linkage,\n                tree_kws=tree_kws\n            )\n        else:\n            self.ax_row_dendrogram.set_xticks([])\n            self.ax_row_dendrogram.set_yticks([])\n        # PLot the column dendrogram\n        if col_cluster:\n            self.dendrogram_col = dendrogram(\n                self.data2d, metric=metric, method=method, label=False,\n                axis=1, ax=self.ax_col_dendrogram, linkage=col_linkage,\n                tree_kws=tree_kws\n            )\n        else:\n            self.ax_col_dendrogram.set_xticks([])\n            self.ax_col_dendrogram.set_yticks([])\n        despine(ax=self.ax_row_dendrogram, bottom=True, left=True)\n        despine(ax=self.ax_col_dendrogram, bottom=True, left=True)\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "plot_dendrograms", "self", "row_cluster", "col_cluster", "metric", "method", "row_linkage", "col_linkage", "tree_kws", "plot", "the", "row", "dendrogram", "if", "row_cluster", "self", "dendrogram_row", "dendrogram", "self", "data2d", "metric", "metric", "method", "method", "label", "false", "axis", "0", "ax", "self", "ax_row_dendrogram", "rotate", "true", "linkage", "row_linkage", "tree_kws", "tree_kws", "else", "self", "ax_row_dendrogram", "set_xticks", "self", "ax_row_dendrogram", "set_yticks", "plot", "the", "column", "dendrogram", "if", "col_cluster", "self", "dendrogram_col", "dendrogram", "self", "data2d", "metric", "metric", "method", "method", "label", "false", "axis", "1", "ax", "self", "ax_col_dendrogram", "linkage", "col_linkage", "tree_kws", "tree_kws", "else", "self", "ax_col_dendrogram", "set_xticks", "self", "ax_col_dendrogram", "set_yticks", "despine", "ax", "self", "ax_row_dendrogram", "bottom", "true", "left", "true", "despine", "ax", "self", "ax_col_dendrogram", "bottom", "true", "left", "true"], "doc_len": 98}
{"doc_id": "seaborn/matrix.py::ClusterGrid.plot_colors", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "plot_colors", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def plot_colors(self, xind, yind, **kws):\n        \"\"\"Plots color labels between the dendrogram and the heatmap\n\n        Parameters\n        ----------\n        heatmap_kws : dict\n            Keyword arguments heatmap\n\n        \"\"\"\n        # Remove any custom colormap and centering\n        # TODO this code has consistently caused problems when we\n        # have missed kwargs that need to be excluded that it might\n        # be better to rewrite *in*clusively.\n        kws = kws.copy()\n        kws.pop('cmap', None)\n        kws.pop('norm', None)\n        kws.pop('center', None)\n        kws.pop('annot', None)\n        kws.pop('vmin', None)\n        kws.pop('vmax', None)\n        kws.pop('robust', None)\n        kws.pop('xticklabels', None)\n        kws.pop('yticklabels', None)\n\n        # Plot the row colors\n        if self.row_colors is not None:\n            matrix, cmap = self.color_list_to_matrix_and_cmap(\n                self.row_colors, yind, axis=0)\n\n            # Get row_color labels\n            if self.row_color_labels is not None:\n                row_color_labels = self.row_color_labels\n            else:\n                row_color_labels = False\n\n            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_row_colors,\n                    xticklabels=row_color_labels, yticklabels=False, **kws)\n\n            # Adjust rotation of labels\n            if row_color_labels is not False:\n                plt.setp(self.ax_row_colors.get_xticklabels(), rotation=90)\n        else:\n            despine(self.ax_row_colors, left=True, bottom=True)\n\n        # Plot the column colors\n        if self.col_colors is not None:\n            matrix, cmap = self.color_list_to_matrix_and_cmap(\n                self.col_colors, xind, axis=1)\n\n            # Get col_color labels\n            if self.col_color_labels is not None:\n                col_color_labels = self.col_color_labels\n            else:\n                col_color_labels = False\n\n            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_col_colors,\n                    xticklabels=False, yticklabels=col_color_labels, **kws)\n\n            # Adjust rotation of labels, place on right side\n            if col_color_labels is not False:\n                self.ax_col_colors.yaxis.tick_right()\n                plt.setp(self.ax_col_colors.get_yticklabels(), rotation=0)\n        else:\n            despine(self.ax_col_colors, left=True, bottom=True)\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "plot_colors", "self", "xind", "yind", "kws", "plots", "color", "labels", "between", "the", "dendrogram", "and", "the", "heatmap", "parameters", "heatmap_kws", "dict", "keyword", "arguments", "heatmap", "remove", "any", "custom", "colormap", "and", "centering", "todo", "this", "code", "has", "consistently", "caused", "problems", "when", "we", "have", "missed", "kwargs", "that", "need", "to", "be", "excluded", "that", "it", "might", "be", "better", "to", "rewrite", "in", "clusively", "kws", "kws", "copy", "kws", "pop", "cmap", "none", "kws", "pop", "norm", "none", "kws", "pop", "center", "none", "kws", "pop", "annot", "none", "kws", "pop", "vmin", "none", "kws", "pop", "vmax", "none", "kws", "pop", "robust", "none", "kws", "pop", "xticklabels", "none", "kws", "pop", "yticklabels", "none", "plot", "the", "row", "colors", "if", "self", "row_colors", "is", "not", "none", "matrix", "cmap", "self", "color_list_to_matrix_and_cmap", "self", "row_colors", "yind", "axis", "0", "get", "row_color", "labels", "if", "self", "row_color_labels", "is", "not", "none", "row_color_labels", "self", "row_color_labels", "else", "row_color_labels", "false", "heatmap", "matrix", "cmap", "cmap", "cbar", "false", "ax", "self", "ax_row_colors", "xticklabels", "row_color_labels", "yticklabels", "false", "kws", "adjust", "rotation", "of", "labels", "if", "row_color_labels", "is", "not", "false", "plt", "setp", "self", "ax_row_colors", "get_xticklabels", "rotation", "90", "else", "despine", "self", "ax_row_colors", "left", "true", "bottom", "true", "plot", "the", "column", "colors", "if", "self", "col_colors", "is", "not", "none", "matrix", "cmap", "self", "color_list_to_matrix_and_cmap", "self", "col_colors", "xind", "axis", "1", "get", "col_color", "labels", "if", "self", "col_color_labels", "is", "not", "none", "col_color_labels", "self", "col_color_labels", "else", "col_color_labels", "false", "heatmap", "matrix", "cmap", "cmap", "cbar", "false", "ax", "self", "ax_col_colors", "xticklabels", "false", "yticklabels", "col_color_labels", "kws", "adjust", "rotation", "of", "labels", "place", "on", "right", "side", "if", "col_color_labels", "is", "not", "false", "self", "ax_col_colors", "yaxis", "tick_right", "plt", "setp", "self", "ax_col_colors", "get_yticklabels", "rotation", "0", "else", "despine", "self", "ax_col_colors", "left", "true", "bottom", "true"], "doc_len": 248}
{"doc_id": "seaborn/matrix.py::ClusterGrid.plot_matrix", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "plot_matrix", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def plot_matrix(self, colorbar_kws, xind, yind, **kws):\n        self.data2d = self.data2d.iloc[yind, xind]\n        self.mask = self.mask.iloc[yind, xind]\n\n        # Try to reorganize specified tick labels, if provided\n        xtl = kws.pop(\"xticklabels\", \"auto\")\n        try:\n            xtl = np.asarray(xtl)[xind]\n        except (TypeError, IndexError):\n            pass\n        ytl = kws.pop(\"yticklabels\", \"auto\")\n        try:\n            ytl = np.asarray(ytl)[yind]\n        except (TypeError, IndexError):\n            pass\n\n        # Reorganize the annotations to match the heatmap\n        annot = kws.pop(\"annot\", None)\n        if annot is None or annot is False:\n            pass\n        else:\n            if isinstance(annot, bool):\n                annot_data = self.data2d\n            else:\n                annot_data = np.asarray(annot)\n                if annot_data.shape != self.data2d.shape:\n                    err = \"`data` and `annot` must have same shape.\"\n                    raise ValueError(err)\n                annot_data = annot_data[yind][:, xind]\n            annot = annot_data\n\n        # Setting ax_cbar=None in clustermap call implies no colorbar\n        kws.setdefault(\"cbar\", self.ax_cbar is not None)\n        heatmap(self.data2d, ax=self.ax_heatmap, cbar_ax=self.ax_cbar,\n                cbar_kws=colorbar_kws, mask=self.mask,\n                xticklabels=xtl, yticklabels=ytl, annot=annot, **kws)\n\n        ytl = self.ax_heatmap.get_yticklabels()\n        ytl_rot = None if not ytl else ytl[0].get_rotation()\n        self.ax_heatmap.yaxis.set_ticks_position('right')\n        self.ax_heatmap.yaxis.set_label_position('right')\n        if ytl_rot is not None:\n            ytl = self.ax_heatmap.get_yticklabels()\n            plt.setp(ytl, rotation=ytl_rot)\n\n        tight_params = dict(h_pad=.02, w_pad=.02)\n        if self.ax_cbar is None:\n            self._figure.tight_layout(**tight_params)\n        else:\n            # Turn the colorbar axes off for tight layout so that its\n            # ticks don't interfere with the rest of the plot layout.\n            # Then move it.\n            self.ax_cbar.set_axis_off()\n            self._figure.tight_layout(**tight_params)\n            self.ax_cbar.set_axis_on()\n            self.ax_cbar.set_position(self.cbar_pos)\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "plot_matrix", "self", "colorbar_kws", "xind", "yind", "kws", "self", "data2d", "self", "data2d", "iloc", "yind", "xind", "self", "mask", "self", "mask", "iloc", "yind", "xind", "try", "to", "reorganize", "specified", "tick", "labels", "if", "provided", "xtl", "kws", "pop", "xticklabels", "auto", "try", "xtl", "np", "asarray", "xtl", "xind", "except", "typeerror", "indexerror", "pass", "ytl", "kws", "pop", "yticklabels", "auto", "try", "ytl", "np", "asarray", "ytl", "yind", "except", "typeerror", "indexerror", "pass", "reorganize", "the", "annotations", "to", "match", "the", "heatmap", "annot", "kws", "pop", "annot", "none", "if", "annot", "is", "none", "or", "annot", "is", "false", "pass", "else", "if", "isinstance", "annot", "bool", "annot_data", "self", "data2d", "else", "annot_data", "np", "asarray", "annot", "if", "annot_data", "shape", "self", "data2d", "shape", "err", "data", "and", "annot", "must", "have", "same", "shape", "raise", "valueerror", "err", "annot_data", "annot_data", "yind", "xind", "annot", "annot_data", "setting", "ax_cbar", "none", "in", "clustermap", "call", "implies", "no", "colorbar", "kws", "setdefault", "cbar", "self", "ax_cbar", "is", "not", "none", "heatmap", "self", "data2d", "ax", "self", "ax_heatmap", "cbar_ax", "self", "ax_cbar", "cbar_kws", "colorbar_kws", "mask", "self", "mask", "xticklabels", "xtl", "yticklabels", "ytl", "annot", "annot", "kws", "ytl", "self", "ax_heatmap", "get_yticklabels", "ytl_rot", "none", "if", "not", "ytl", "else", "ytl", "0", "get_rotation", "self", "ax_heatmap", "yaxis", "set_ticks_position", "right", "self", "ax_heatmap", "yaxis", "set_label_position", "right", "if", "ytl_rot", "is", "not", "none", "ytl", "self", "ax_heatmap", "get_yticklabels", "plt", "setp", "ytl", "rotation", "ytl_rot", "tight_params", "dict", "h_pad", "02", "w_pad", "02", "if", "self", "ax_cbar", "is", "none", "self", "_figure", "tight_layout", "tight_params", "else", "turn", "the", "colorbar", "axes", "off", "for", "tight", "layout", "so", "that", "its", "ticks", "don", "t", "interfere", "with", "the", "rest", "of", "the", "plot", "layout", "then", "move", "it", "self", "ax_cbar", "set_axis_off", "self", "_figure", "tight_layout", "tight_params", "self", "ax_cbar", "set_axis_on", "self", "ax_cbar", "set_position", "self", "cbar_pos"], "doc_len": 251}
{"doc_id": "seaborn/matrix.py::ClusterGrid.plot", "file_path": "seaborn/matrix.py", "class_name": "ClusterGrid", "func_name": "plot", "text": "文件路径: seaborn/matrix.py, 类名: ClusterGrid\n    def plot(self, metric, method, colorbar_kws, row_cluster, col_cluster,\n             row_linkage, col_linkage, tree_kws, **kws):\n\n        # heatmap square=True sets the aspect ratio on the axes, but that is\n        # not compatible with the multi-axes layout of clustergrid\n        if kws.get(\"square\", False):\n            msg = \"``square=True`` ignored in clustermap\"\n            warnings.warn(msg)\n            kws.pop(\"square\")\n\n        colorbar_kws = {} if colorbar_kws is None else colorbar_kws\n\n        self.plot_dendrograms(row_cluster, col_cluster, metric, method,\n                              row_linkage=row_linkage, col_linkage=col_linkage,\n                              tree_kws=tree_kws)\n        try:\n            xind = self.dendrogram_col.reordered_ind\n        except AttributeError:\n            xind = np.arange(self.data2d.shape[1])\n        try:\n            yind = self.dendrogram_row.reordered_ind\n        except AttributeError:\n            yind = np.arange(self.data2d.shape[0])\n\n        self.plot_colors(xind, yind, **kws)\n        self.plot_matrix(colorbar_kws, xind, yind, **kws)\n        return self\n", "tokens": ["seaborn", "matrix", "py", "clustergrid", "def", "plot", "self", "metric", "method", "colorbar_kws", "row_cluster", "col_cluster", "row_linkage", "col_linkage", "tree_kws", "kws", "heatmap", "square", "true", "sets", "the", "aspect", "ratio", "on", "the", "axes", "but", "that", "is", "not", "compatible", "with", "the", "multi", "axes", "layout", "of", "clustergrid", "if", "kws", "get", "square", "false", "msg", "square", "true", "ignored", "in", "clustermap", "warnings", "warn", "msg", "kws", "pop", "square", "colorbar_kws", "if", "colorbar_kws", "is", "none", "else", "colorbar_kws", "self", "plot_dendrograms", "row_cluster", "col_cluster", "metric", "method", "row_linkage", "row_linkage", "col_linkage", "col_linkage", "tree_kws", "tree_kws", "try", "xind", "self", "dendrogram_col", "reordered_ind", "except", "attributeerror", "xind", "np", "arange", "self", "data2d", "shape", "1", "try", "yind", "self", "dendrogram_row", "reordered_ind", "except", "attributeerror", "yind", "np", "arange", "self", "data2d", "shape", "0", "self", "plot_colors", "xind", "yind", "kws", "self", "plot_matrix", "colorbar_kws", "xind", "yind", "kws", "return", "self"], "doc_len": 115}
{"doc_id": "seaborn/matrix.py::clustermap", "file_path": "seaborn/matrix.py", "class_name": null, "func_name": "clustermap", "text": "文件路径: seaborn/matrix.py\ndef clustermap(\n    data, *,\n    pivot_kws=None, method='average', metric='euclidean',\n    z_score=None, standard_scale=None, figsize=(10, 10),\n    cbar_kws=None, row_cluster=True, col_cluster=True,\n    row_linkage=None, col_linkage=None,\n    row_colors=None, col_colors=None, mask=None,\n    dendrogram_ratio=.2, colors_ratio=0.03,\n    cbar_pos=(.02, .8, .05, .18), tree_kws=None,\n    **kwargs\n):\n    \"\"\"\n    Plot a matrix dataset as a hierarchically-clustered heatmap.\n\n    This function requires scipy to be available.\n\n    Parameters\n    ----------\n    data : 2D array-like\n        Rectangular data for clustering. Cannot contain NAs.\n    pivot_kws : dict, optional\n        If `data` is a tidy dataframe, can provide keyword arguments for\n        pivot to create a rectangular dataframe.\n    method : str, optional\n        Linkage method to use for calculating clusters. See\n        :func:`scipy.cluster.hierarchy.linkage` documentation for more\n        information.\n    metric : str, optional\n        Distance metric to use for the data. See\n        :func:`scipy.spatial.distance.pdist` documentation for more options.\n        To use different metrics (or methods) for rows and columns, you may\n        construct each linkage matrix yourself and provide them as\n        `{row,col}_linkage`.\n    z_score : int or None, optional\n        Either 0 (rows) or 1 (columns). Whether or not to calculate z-scores\n        for the rows or the columns. Z scores are: z = (x - mean)/std, so\n        values in each row (column) will get the mean of the row (column)\n        subtracted, then divided by the standard deviation of the row (column).\n        This ensures that each row (column) has mean of 0 and variance of 1.\n    standard_scale : int or None, optional\n        Either 0 (rows) or 1 (columns). Whether or not to standardize that\n        dimension, meaning for each row or column, subtract the minimum and\n        divide each by its maximum.\n    figsize : tuple of (width, height), optional\n        Overall size of the figure.\n    cbar_kws : dict, optional\n        Keyword arguments to pass to `cbar_kws` in :func:`heatmap`, e.g. to\n        add a label to the colorbar.\n    {row,col}_cluster : bool, optional\n        If ``True``, cluster the {rows, columns}.\n    {row,col}_linkage : :class:`numpy.ndarray`, optional\n        Precomputed linkage matrix for the rows or columns. See\n        :func:`scipy.cluster.hierarchy.linkage` for specific formats.\n    {row,col}_colors : list-like or pandas DataFrame/Series, optional\n        List of colors to label for either the rows or columns. Useful to evaluate\n        whether samples within a group are clustered together. Can use nested lists or\n        DataFrame for multiple color levels of labeling. If given as a\n        :class:`pandas.DataFrame` or :class:`pandas.Series`, labels for the colors are\n        extracted from the DataFrames column names or from the name of the Series.\n        DataFrame/Series colors are also matched to the data by their index, ensuring\n        colors are drawn in the correct order.\n    mask : bool array or DataFrame, optional\n        If passed, data will not be shown in cells where `mask` is True.\n        Cells with missing values are automatically masked. Only used for\n        visualizing, not for calculating.\n    {dendrogram,colors}_ratio : float, or pair of floats, optional\n        Proportion of the figure size devoted to the two marginal elements. If\n        a pair is given, they correspond to (row, col) ratios.\n    cbar_pos : tuple of (left, bottom, width, height), optional\n        Position of the colorbar axes in the figure. Setting to ``None`` will\n        disable the colorbar.\n    tree_kws : dict, optional\n        Parameters for the :class:`matplotlib.collections.LineCollection`\n        that is used to plot the lines of the dendrogram tree.\n    kwargs : other keyword arguments\n        All other keyword arguments are passed to :func:`heatmap`.\n\n    Returns\n    -------\n    :class:`ClusterGrid`\n        A :class:`ClusterGrid` instance.\n\n    See Also\n    --------\n    heatmap : Plot rectangular data as a color-encoded matrix.\n\n    Notes\n    -----\n    The returned object has a ``savefig`` method that should be used if you\n    want to save the figure object without clipping the dendrograms.\n\n    To access the reordered row indices, use:\n    ``clustergrid.dendrogram_row.reordered_ind``\n\n    Column indices, use:\n    ``clustergrid.dendrogram_col.reordered_ind``\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/clustermap.rst\n\n    \"\"\"\n    if _no_scipy:\n        raise RuntimeError(\"clustermap requires scipy to be available\")\n\n    plotter = ClusterGrid(data, pivot_kws=pivot_kws, figsize=figsize,\n                          row_colors=row_colors, col_colors=col_colors,\n                          z_score=z_score, standard_scale=standard_scale,\n                          mask=mask, dendrogram_ratio=dendrogram_ratio,\n                          colors_ratio=colors_ratio, cbar_pos=cbar_pos)\n\n    return plotter.plot(metric=metric, method=method,\n                        colorbar_kws=cbar_kws,\n                        row_cluster=row_cluster, col_cluster=col_cluster,\n                        row_linkage=row_linkage, col_linkage=col_linkage,\n                        tree_kws=tree_kws, **kwargs)\n", "tokens": ["seaborn", "matrix", "py", "def", "clustermap", "data", "pivot_kws", "none", "method", "average", "metric", "euclidean", "z_score", "none", "standard_scale", "none", "figsize", "10", "10", "cbar_kws", "none", "row_cluster", "true", "col_cluster", "true", "row_linkage", "none", "col_linkage", "none", "row_colors", "none", "col_colors", "none", "mask", "none", "dendrogram_ratio", "2", "colors_ratio", "0", "03", "cbar_pos", "02", "8", "05", "18", "tree_kws", "none", "kwargs", "plot", "a", "matrix", "dataset", "as", "a", "hierarchically", "clustered", "heatmap", "this", "function", "requires", "scipy", "to", "be", "available", "parameters", "data", "2d", "array", "like", "rectangular", "data", "for", "clustering", "cannot", "contain", "nas", "pivot_kws", "dict", "optional", "if", "data", "is", "a", "tidy", "dataframe", "can", "provide", "keyword", "arguments", "for", "pivot", "to", "create", "a", "rectangular", "dataframe", "method", "str", "optional", "linkage", "method", "to", "use", "for", "calculating", "clusters", "see", "func", "scipy", "cluster", "hierarchy", "linkage", "documentation", "for", "more", "information", "metric", "str", "optional", "distance", "metric", "to", "use", "for", "the", "data", "see", "func", "scipy", "spatial", "distance", "pdist", "documentation", "for", "more", "options", "to", "use", "different", "metrics", "or", "methods", "for", "rows", "and", "columns", "you", "may", "construct", "each", "linkage", "matrix", "yourself", "and", "provide", "them", "as", "row", "col", "_linkage", "z_score", "int", "or", "none", "optional", "either", "0", "rows", "or", "1", "columns", "whether", "or", "not", "to", "calculate", "z", "scores", "for", "the", "rows", "or", "the", "columns", "z", "scores", "are", "z", "x", "mean", "std", "so", "values", "in", "each", "row", "column", "will", "get", "the", "mean", "of", "the", "row", "column", "subtracted", "then", "divided", "by", "the", "standard", "deviation", "of", "the", "row", "column", "this", "ensures", "that", "each", "row", "column", "has", "mean", "of", "0", "and", "variance", "of", "1", "standard_scale", "int", "or", "none", "optional", "either", "0", "rows", "or", "1", "columns", "whether", "or", "not", "to", "standardize", "that", "dimension", "meaning", "for", "each", "row", "or", "column", "subtract", "the", "minimum", "and", "divide", "each", "by", "its", "maximum", "figsize", "tuple", "of", "width", "height", "optional", "overall", "size", "of", "the", "figure", "cbar_kws", "dict", "optional", "keyword", "arguments", "to", "pass", "to", "cbar_kws", "in", "func", "heatmap", "e", "g", "to", "add", "a", "label", "to", "the", "colorbar", "row", "col", "_cluster", "bool", "optional", "if", "true", "cluster", "the", "rows", "columns", "row", "col", "_linkage", "class", "numpy", "ndarray", "optional", "precomputed", "linkage", "matrix", "for", "the", "rows", "or", "columns", "see", "func", "scipy", "cluster", "hierarchy", "linkage", "for", "specific", "formats", "row", "col", "_colors", "list", "like", "or", "pandas", "dataframe", "series", "optional", "list", "of", "colors", "to", "label", "for", "either", "the", "rows", "or", "columns", "useful", "to", "evaluate", "whether", "samples", "within", "a", "group", "are", "clustered", "together", "can", "use", "nested", "lists", "or", "dataframe", "for", "multiple", "color", "levels", "of", "labeling", "if", "given", "as", "a", "class", "pandas", "dataframe", "or", "class", "pandas", "series", "labels", "for", "the", "colors", "are", "extracted", "from", "the", "dataframes", "column", "names", "or", "from", "the", "name", "of", "the", "series", "dataframe", "series", "colors", "are", "also", "matched", "to", "the", "data", "by", "their", "index", "ensuring", "colors", "are", "drawn", "in", "the", "correct", "order", "mask", "bool", "array", "or", "dataframe", "optional", "if", "passed", "data", "will", "not", "be", "shown", "in", "cells", "where", "mask", "is", "true", "cells", "with", "missing", "values", "are", "automatically", "masked", "only", "used", "for", "visualizing", "not", "for", "calculating", "dendrogram", "colors", "_ratio", "float", "or", "pair", "of", "floats", "optional", "proportion", "of", "the", "figure", "size", "devoted", "to", "the", "two", "marginal", "elements", "if", "a", "pair", "is", "given", "they", "correspond", "to", "row", "col", "ratios", "cbar_pos", "tuple", "of", "left", "bottom", "width", "height", "optional", "position", "of", "the", "colorbar", "axes", "in", "the", "figure", "setting", "to", "none", "will", "disable", "the", "colorbar", "tree_kws", "dict", "optional", "parameters", "for", "the", "class", "matplotlib", "collections", "linecollection", "that", "is", "used", "to", "plot", "the", "lines", "of", "the", "dendrogram", "tree", "kwargs", "other", "keyword", "arguments", "all", "other", "keyword", "arguments", "are", "passed", "to", "func", "heatmap", "returns", "class", "clustergrid", "a", "class", "clustergrid", "instance", "see", "also", "heatmap", "plot", "rectangular", "data", "as", "a", "color", "encoded", "matrix", "notes", "the", "returned", "object", "has", "a", "savefig", "method", "that", "should", "be", "used", "if", "you", "want", "to", "save", "the", "figure", "object", "without", "clipping", "the", "dendrograms", "to", "access", "the", "reordered", "row", "indices", "use", "clustergrid", "dendrogram_row", "reordered_ind", "column", "indices", "use", "clustergrid", "dendrogram_col", "reordered_ind", "examples", "include", "docstrings", "clustermap", "rst", "if", "_no_scipy", "raise", "runtimeerror", "clustermap", "requires", "scipy", "to", "be", "available", "plotter", "clustergrid", "data", "pivot_kws", "pivot_kws", "figsize", "figsize", "row_colors", "row_colors", "col_colors", "col_colors", "z_score", "z_score", "standard_scale", "standard_scale", "mask", "mask", "dendrogram_ratio", "dendrogram_ratio", "colors_ratio", "colors_ratio", "cbar_pos", "cbar_pos", "return", "plotter", "plot", "metric", "metric", "method", "method", "colorbar_kws", "cbar_kws", "row_cluster", "row_cluster", "col_cluster", "col_cluster", "row_linkage", "row_linkage", "col_linkage", "col_linkage", "tree_kws", "tree_kws", "kwargs"], "doc_len": 660}
{"doc_id": "seaborn/miscplot.py::palplot", "file_path": "seaborn/miscplot.py", "class_name": null, "func_name": "palplot", "text": "文件路径: seaborn/miscplot.py\ndef palplot(pal, size=1):\n    \"\"\"Plot the values in a color palette as a horizontal array.\n\n    Parameters\n    ----------\n    pal : sequence of matplotlib colors\n        colors, i.e. as returned by seaborn.color_palette()\n    size :\n        scaling factor for size of plot\n\n    \"\"\"\n    n = len(pal)\n    f, ax = plt.subplots(1, 1, figsize=(n * size, size))\n    ax.imshow(np.arange(n).reshape(1, n),\n              cmap=mpl.colors.ListedColormap(list(pal)),\n              interpolation=\"nearest\", aspect=\"auto\")\n    ax.set_xticks(np.arange(n) - .5)\n    ax.set_yticks([-.5, .5])\n    # Ensure nice border between colors\n    ax.set_xticklabels([\"\" for _ in range(n)])\n    # The proper way to set no ticks\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n", "tokens": ["seaborn", "miscplot", "py", "def", "palplot", "pal", "size", "1", "plot", "the", "values", "in", "a", "color", "palette", "as", "a", "horizontal", "array", "parameters", "pal", "sequence", "of", "matplotlib", "colors", "colors", "i", "e", "as", "returned", "by", "seaborn", "color_palette", "size", "scaling", "factor", "for", "size", "of", "plot", "n", "len", "pal", "f", "ax", "plt", "subplots", "1", "1", "figsize", "n", "size", "size", "ax", "imshow", "np", "arange", "n", "reshape", "1", "n", "cmap", "mpl", "colors", "listedcolormap", "list", "pal", "interpolation", "nearest", "aspect", "auto", "ax", "set_xticks", "np", "arange", "n", "5", "ax", "set_yticks", "5", "5", "ensure", "nice", "border", "between", "colors", "ax", "set_xticklabels", "for", "_", "in", "range", "n", "the", "proper", "way", "to", "set", "no", "ticks", "ax", "yaxis", "set_major_locator", "ticker", "nulllocator"], "doc_len": 105}
{"doc_id": "seaborn/miscplot.py::dogplot", "file_path": "seaborn/miscplot.py", "class_name": null, "func_name": "dogplot", "text": "文件路径: seaborn/miscplot.py\ndef dogplot(*_, **__):\n    \"\"\"Who's a good boy?\"\"\"\n    try:\n        from urllib.request import urlopen\n    except ImportError:\n        from urllib2 import urlopen\n    from io import BytesIO\n\n    url = \"https://github.com/mwaskom/seaborn-data/raw/master/png/img{}.png\"\n    pic = np.random.randint(2, 7)\n    data = BytesIO(urlopen(url.format(pic)).read())\n    img = plt.imread(data)\n    f, ax = plt.subplots(figsize=(5, 5), dpi=100)\n    f.subplots_adjust(0, 0, 1, 1)\n    ax.imshow(img)\n    ax.set_axis_off()\n", "tokens": ["seaborn", "miscplot", "py", "def", "dogplot", "_", "__", "who", "s", "a", "good", "boy", "try", "from", "urllib", "request", "import", "urlopen", "except", "importerror", "from", "urllib2", "import", "urlopen", "from", "io", "import", "bytesio", "url", "https", "github", "com", "mwaskom", "seaborn", "data", "raw", "master", "png", "img", "png", "pic", "np", "random", "randint", "2", "7", "data", "bytesio", "urlopen", "url", "format", "pic", "read", "img", "plt", "imread", "data", "f", "ax", "plt", "subplots", "figsize", "5", "5", "dpi", "100", "f", "subplots_adjust", "0", "0", "1", "1", "ax", "imshow", "img", "ax", "set_axis_off"], "doc_len": 77}
{"doc_id": "seaborn/palettes.py::_ColorPalette.__enter__", "file_path": "seaborn/palettes.py", "class_name": "_ColorPalette", "func_name": "__enter__", "text": "文件路径: seaborn/palettes.py, 类名: _ColorPalette\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n", "tokens": ["seaborn", "palettes", "py", "_colorpalette", "def", "__enter__", "self", "open", "the", "context", "from", "rcmod", "import", "set_palette", "self", "_orig_palette", "color_palette", "set_palette", "self", "return", "self"], "doc_len": 21}
{"doc_id": "seaborn/palettes.py::_ColorPalette.__exit__", "file_path": "seaborn/palettes.py", "class_name": "_ColorPalette", "func_name": "__exit__", "text": "文件路径: seaborn/palettes.py, 类名: _ColorPalette\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n", "tokens": ["seaborn", "palettes", "py", "_colorpalette", "def", "__exit__", "self", "args", "close", "the", "context", "from", "rcmod", "import", "set_palette", "set_palette", "self", "_orig_palette"], "doc_len": 18}
{"doc_id": "seaborn/palettes.py::_ColorPalette.as_hex", "file_path": "seaborn/palettes.py", "class_name": "_ColorPalette", "func_name": "as_hex", "text": "文件路径: seaborn/palettes.py, 类名: _ColorPalette\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n", "tokens": ["seaborn", "palettes", "py", "_colorpalette", "def", "as_hex", "self", "return", "a", "color", "palette", "with", "hex", "codes", "instead", "of", "rgb", "values", "hex", "mpl", "colors", "rgb2hex", "rgb", "for", "rgb", "in", "self", "return", "_colorpalette", "hex"], "doc_len": 30}
{"doc_id": "seaborn/palettes.py::_ColorPalette._repr_html_", "file_path": "seaborn/palettes.py", "class_name": "_ColorPalette", "func_name": "_repr_html_", "text": "文件路径: seaborn/palettes.py, 类名: _ColorPalette\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};'\n                'stroke-width:2;stroke:rgb(255,255,255)\"/>'\n            )\n        html += '</svg>'\n        return html\n", "tokens": ["seaborn", "palettes", "py", "_colorpalette", "def", "_repr_html_", "self", "rich", "display", "of", "the", "color", "palette", "in", "an", "html", "frontend", "s", "55", "n", "len", "self", "html", "f", "svg", "width", "n", "s", "height", "s", "for", "i", "c", "in", "enumerate", "self", "as_hex", "html", "f", "rect", "x", "i", "s", "y", "0", "width", "s", "height", "s", "style", "fill", "c", "stroke", "width", "2", "stroke", "rgb", "255", "255", "255", "html", "svg", "return", "html"], "doc_len": 64}
{"doc_id": "seaborn/palettes.py::_patch_colormap_display", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "_patch_colormap_display", "text": "文件路径: seaborn/palettes.py\ndef _patch_colormap_display():\n    \"\"\"Simplify the rich display of matplotlib color maps in a notebook.\"\"\"\n    def _repr_png_(self):\n        \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n        import io\n        from PIL import Image\n        import numpy as np\n        IMAGE_SIZE = (400, 50)\n        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))\n        pixels = self(X, bytes=True)\n        png_bytes = io.BytesIO()\n        Image.fromarray(pixels).save(png_bytes, format='png')\n        return png_bytes.getvalue()\n\n    def _repr_html_(self):\n        \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n        import base64\n        png_bytes = self._repr_png_()\n        png_base64 = base64.b64encode(png_bytes).decode('ascii')\n        return ('<img '\n                + 'alt=\"' + self.name + ' color map\" '\n                + 'title=\"' + self.name + '\"'\n                + 'src=\"data:image/png;base64,' + png_base64 + '\">')\n\n    mpl.colors.Colormap._repr_png_ = _repr_png_\n    mpl.colors.Colormap._repr_html_ = _repr_html_\n", "tokens": ["seaborn", "palettes", "py", "def", "_patch_colormap_display", "simplify", "the", "rich", "display", "of", "matplotlib", "color", "maps", "in", "a", "notebook", "def", "_repr_png_", "self", "generate", "a", "png", "representation", "of", "the", "colormap", "import", "io", "from", "pil", "import", "image", "import", "numpy", "as", "np", "image_size", "400", "50", "x", "np", "tile", "np", "linspace", "0", "1", "image_size", "0", "image_size", "1", "1", "pixels", "self", "x", "bytes", "true", "png_bytes", "io", "bytesio", "image", "fromarray", "pixels", "save", "png_bytes", "format", "png", "return", "png_bytes", "getvalue", "def", "_repr_html_", "self", "generate", "an", "html", "representation", "of", "the", "colormap", "import", "base64", "png_bytes", "self", "_repr_png_", "png_base64", "base64", "b64encode", "png_bytes", "decode", "ascii", "return", "img", "alt", "self", "name", "color", "map", "title", "self", "name", "src", "data", "image", "png", "base64", "png_base64", "mpl", "colors", "colormap", "_repr_png_", "_repr_png_", "mpl", "colors", "colormap", "_repr_html_", "_repr_html_"], "doc_len": 116}
{"doc_id": "seaborn/palettes.py::color_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "color_palette", "text": "文件路径: seaborn/palettes.py\ndef color_palette(palette=None, n_colors=None, desat=None, as_cmap=False):\n    \"\"\"Return a list of colors or continuous colormap defining a palette.\n\n    Possible ``palette`` values include:\n        - Name of a seaborn palette (deep, muted, bright, pastel, dark, colorblind)\n        - Name of matplotlib colormap\n        - 'husl' or 'hls'\n        - 'ch:<cubehelix arguments>'\n        - 'light:<color>', 'dark:<color>', 'blend:<color>,<color>',\n        - A sequence of colors in any format matplotlib accepts\n\n    Calling this function with ``palette=None`` will return the current\n    matplotlib color cycle.\n\n    This function can also be used in a ``with`` statement to temporarily\n    set the color cycle for a plot or set of plots.\n\n    See the :ref:`tutorial <palette_tutorial>` for more information.\n\n    Parameters\n    ----------\n    palette : None, string, or sequence, optional\n        Name of palette or None to return current palette. If a sequence, input\n        colors are used but possibly cycled and desaturated.\n    n_colors : int, optional\n        Number of colors in the palette. If ``None``, the default will depend\n        on how ``palette`` is specified. Named palettes default to 6 colors,\n        but grabbing the current palette or passing in a list of colors will\n        not change the number of colors unless this is specified. Asking for\n        more colors than exist in the palette will cause it to cycle. Ignored\n        when ``as_cmap`` is True.\n    desat : float, optional\n        Proportion to desaturate each color by.\n    as_cmap : bool\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n\n    Returns\n    -------\n    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    set_palette : Set the default color cycle for all plots.\n    set_color_codes : Reassign color codes like ``\"b\"``, ``\"g\"``, etc. to\n                      colors from one of the seaborn palettes.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/color_palette.rst\n\n    \"\"\"\n    if palette is None:\n        palette = get_color_cycle()\n        if n_colors is None:\n            n_colors = len(palette)\n\n    elif not isinstance(palette, str):\n        palette = palette\n        if n_colors is None:\n            n_colors = len(palette)\n    else:\n\n        if n_colors is None:\n            # Use all colors in a qualitative palette or 6 of another kind\n            n_colors = QUAL_PALETTE_SIZES.get(palette, 6)\n\n        if palette in SEABORN_PALETTES:\n            # Named \"seaborn variant\" of matplotlib default color cycle\n            palette = SEABORN_PALETTES[palette]\n\n        elif palette == \"hls\":\n            # Evenly spaced colors in cylindrical RGB space\n            palette = hls_palette(n_colors, as_cmap=as_cmap)\n\n        elif palette == \"husl\":\n            # Evenly spaced colors in cylindrical Lab space\n            palette = husl_palette(n_colors, as_cmap=as_cmap)\n\n        elif palette.lower() == \"jet\":\n            # Paternalism\n            raise ValueError(\"No.\")\n\n        elif palette.startswith(\"ch:\"):\n            # Cubehelix palette with params specified in string\n            args, kwargs = _parse_cubehelix_args(palette)\n            palette = cubehelix_palette(n_colors, *args, **kwargs, as_cmap=as_cmap)\n\n        elif palette.startswith(\"light:\"):\n            # light palette to color specified in string\n            _, color = palette.split(\":\")\n            reverse = color.endswith(\"_r\")\n            if reverse:\n                color = color[:-2]\n            palette = light_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)\n\n        elif palette.startswith(\"dark:\"):\n            # light palette to color specified in string\n            _, color = palette.split(\":\")\n            reverse = color.endswith(\"_r\")\n            if reverse:\n                color = color[:-2]\n            palette = dark_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)\n\n        elif palette.startswith(\"blend:\"):\n            # blend palette between colors specified in string\n            _, colors = palette.split(\":\")\n            colors = colors.split(\",\")\n            palette = blend_palette(colors, n_colors, as_cmap=as_cmap)\n\n        else:\n            try:\n                # Perhaps a named matplotlib colormap?\n                palette = mpl_palette(palette, n_colors, as_cmap=as_cmap)\n            except (ValueError, KeyError):  # Error class changed in mpl36\n                raise ValueError(f\"{palette!r} is not a valid palette name\")\n\n    if desat is not None:\n        palette = [desaturate(c, desat) for c in palette]\n\n    if not as_cmap:\n\n        # Always return as many colors as we asked for\n        pal_cycle = cycle(palette)\n        palette = [next(pal_cycle) for _ in range(n_colors)]\n\n        # Always return in r, g, b tuple format\n        try:\n            palette = map(mpl.colors.colorConverter.to_rgb, palette)\n            palette = _ColorPalette(palette)\n        except ValueError:\n            raise ValueError(f\"Could not generate a palette for {palette}\")\n\n    return palette\n", "tokens": ["seaborn", "palettes", "py", "def", "color_palette", "palette", "none", "n_colors", "none", "desat", "none", "as_cmap", "false", "return", "a", "list", "of", "colors", "or", "continuous", "colormap", "defining", "a", "palette", "possible", "palette", "values", "include", "name", "of", "a", "seaborn", "palette", "deep", "muted", "bright", "pastel", "dark", "colorblind", "name", "of", "matplotlib", "colormap", "husl", "or", "hls", "ch", "cubehelix", "arguments", "light", "color", "dark", "color", "blend", "color", "color", "a", "sequence", "of", "colors", "in", "any", "format", "matplotlib", "accepts", "calling", "this", "function", "with", "palette", "none", "will", "return", "the", "current", "matplotlib", "color", "cycle", "this", "function", "can", "also", "be", "used", "in", "a", "with", "statement", "to", "temporarily", "set", "the", "color", "cycle", "for", "a", "plot", "or", "set", "of", "plots", "see", "the", "ref", "tutorial", "palette_tutorial", "for", "more", "information", "parameters", "palette", "none", "string", "or", "sequence", "optional", "name", "of", "palette", "or", "none", "to", "return", "current", "palette", "if", "a", "sequence", "input", "colors", "are", "used", "but", "possibly", "cycled", "and", "desaturated", "n_colors", "int", "optional", "number", "of", "colors", "in", "the", "palette", "if", "none", "the", "default", "will", "depend", "on", "how", "palette", "is", "specified", "named", "palettes", "default", "to", "6", "colors", "but", "grabbing", "the", "current", "palette", "or", "passing", "in", "a", "list", "of", "colors", "will", "not", "change", "the", "number", "of", "colors", "unless", "this", "is", "specified", "asking", "for", "more", "colors", "than", "exist", "in", "the", "palette", "will", "cause", "it", "to", "cycle", "ignored", "when", "as_cmap", "is", "true", "desat", "float", "optional", "proportion", "to", "desaturate", "each", "color", "by", "as_cmap", "bool", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "returns", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "set_palette", "set", "the", "default", "color", "cycle", "for", "all", "plots", "set_color_codes", "reassign", "color", "codes", "like", "b", "g", "etc", "to", "colors", "from", "one", "of", "the", "seaborn", "palettes", "examples", "include", "docstrings", "color_palette", "rst", "if", "palette", "is", "none", "palette", "get_color_cycle", "if", "n_colors", "is", "none", "n_colors", "len", "palette", "elif", "not", "isinstance", "palette", "str", "palette", "palette", "if", "n_colors", "is", "none", "n_colors", "len", "palette", "else", "if", "n_colors", "is", "none", "use", "all", "colors", "in", "a", "qualitative", "palette", "or", "6", "of", "another", "kind", "n_colors", "qual_palette_sizes", "get", "palette", "6", "if", "palette", "in", "seaborn_palettes", "named", "seaborn", "variant", "of", "matplotlib", "default", "color", "cycle", "palette", "seaborn_palettes", "palette", "elif", "palette", "hls", "evenly", "spaced", "colors", "in", "cylindrical", "rgb", "space", "palette", "hls_palette", "n_colors", "as_cmap", "as_cmap", "elif", "palette", "husl", "evenly", "spaced", "colors", "in", "cylindrical", "lab", "space", "palette", "husl_palette", "n_colors", "as_cmap", "as_cmap", "elif", "palette", "lower", "jet", "paternalism", "raise", "valueerror", "no", "elif", "palette", "startswith", "ch", "cubehelix", "palette", "with", "params", "specified", "in", "string", "args", "kwargs", "_parse_cubehelix_args", "palette", "palette", "cubehelix_palette", "n_colors", "args", "kwargs", "as_cmap", "as_cmap", "elif", "palette", "startswith", "light", "light", "palette", "to", "color", "specified", "in", "string", "_", "color", "palette", "split", "reverse", "color", "endswith", "_r", "if", "reverse", "color", "color", "2", "palette", "light_palette", "color", "n_colors", "reverse", "reverse", "as_cmap", "as_cmap", "elif", "palette", "startswith", "dark", "light", "palette", "to", "color", "specified", "in", "string", "_", "color", "palette", "split", "reverse", "color", "endswith", "_r", "if", "reverse", "color", "color", "2", "palette", "dark_palette", "color", "n_colors", "reverse", "reverse", "as_cmap", "as_cmap", "elif", "palette", "startswith", "blend", "blend", "palette", "between", "colors", "specified", "in", "string", "_", "colors", "palette", "split", "colors", "colors", "split", "palette", "blend_palette", "colors", "n_colors", "as_cmap", "as_cmap", "else", "try", "perhaps", "a", "named", "matplotlib", "colormap", "palette", "mpl_palette", "palette", "n_colors", "as_cmap", "as_cmap", "except", "valueerror", "keyerror", "error", "class", "changed", "in", "mpl36", "raise", "valueerror", "f", "palette", "r", "is", "not", "a", "valid", "palette", "name", "if", "desat", "is", "not", "none", "palette", "desaturate", "c", "desat", "for", "c", "in", "palette", "if", "not", "as_cmap", "always", "return", "as", "many", "colors", "as", "we", "asked", "for", "pal_cycle", "cycle", "palette", "palette", "next", "pal_cycle", "for", "_", "in", "range", "n_colors", "always", "return", "in", "r", "g", "b", "tuple", "format", "try", "palette", "map", "mpl", "colors", "colorconverter", "to_rgb", "palette", "palette", "_colorpalette", "palette", "except", "valueerror", "raise", "valueerror", "f", "could", "not", "generate", "a", "palette", "for", "palette", "return", "palette"], "doc_len": 579}
{"doc_id": "seaborn/palettes.py::hls_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "hls_palette", "text": "文件路径: seaborn/palettes.py\ndef hls_palette(n_colors=6, h=.01, l=.6, s=.65, as_cmap=False):  # noqa\n    \"\"\"\n    Return hues with constant lightness and saturation in the HLS system.\n\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n\n    The `h`, `l`, and `s` values should be between 0 and 1.\n\n    .. note::\n        While the separation of the resulting colors will be mathematically\n        constant, the HLS system does not construct a perceptually-uniform space,\n        so their apparent intensity will vary.\n\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    husl_palette : Make a palette using evenly spaced hues in the HUSL system.\n\n    Examples\n    --------\n    .. include:: ../docstrings/hls_palette.rst\n\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues -= hues.astype(int)\n    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, \"hls\")\n    else:\n        return _ColorPalette(palette)\n", "tokens": ["seaborn", "palettes", "py", "def", "hls_palette", "n_colors", "6", "h", "01", "l", "6", "s", "65", "as_cmap", "false", "noqa", "return", "hues", "with", "constant", "lightness", "and", "saturation", "in", "the", "hls", "system", "the", "hues", "are", "evenly", "sampled", "along", "a", "circular", "path", "the", "resulting", "palette", "will", "be", "appropriate", "for", "categorical", "or", "cyclical", "data", "the", "h", "l", "and", "s", "values", "should", "be", "between", "0", "and", "1", "note", "while", "the", "separation", "of", "the", "resulting", "colors", "will", "be", "mathematically", "constant", "the", "hls", "system", "does", "not", "construct", "a", "perceptually", "uniform", "space", "so", "their", "apparent", "intensity", "will", "vary", "parameters", "n_colors", "int", "number", "of", "colors", "in", "the", "palette", "h", "float", "the", "value", "of", "the", "first", "hue", "l", "float", "the", "lightness", "value", "s", "float", "the", "saturation", "intensity", "as_cmap", "bool", "if", "true", "return", "a", "matplotlib", "colormap", "object", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "husl_palette", "make", "a", "palette", "using", "evenly", "spaced", "hues", "in", "the", "husl", "system", "examples", "include", "docstrings", "hls_palette", "rst", "if", "as_cmap", "n_colors", "256", "hues", "np", "linspace", "0", "1", "int", "n_colors", "1", "1", "hues", "h", "hues", "1", "hues", "hues", "astype", "int", "palette", "colorsys", "hls_to_rgb", "h_i", "l", "s", "for", "h_i", "in", "hues", "if", "as_cmap", "return", "mpl", "colors", "listedcolormap", "palette", "hls", "else", "return", "_colorpalette", "palette"], "doc_len": 196}
{"doc_id": "seaborn/palettes.py::husl_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "husl_palette", "text": "文件路径: seaborn/palettes.py\ndef husl_palette(n_colors=6, h=.01, s=.9, l=.65, as_cmap=False):  # noqa\n    \"\"\"\n    Return hues with constant lightness and saturation in the HUSL system.\n\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n\n    The `h`, `l`, and `s` values should be between 0 and 1.\n\n    This function is similar to :func:`hls_palette`, but it uses a nonlinear color\n    space that is more perceptually uniform.\n\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    hls_palette : Make a palette using evenly spaced hues in the HSL system.\n\n    Examples\n    --------\n    .. include:: ../docstrings/husl_palette.rst\n\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues *= 359\n    s *= 99\n    l *= 99  # noqa\n    palette = [_color_to_rgb((h_i, s, l), input=\"husl\") for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, \"hsl\")\n    else:\n        return _ColorPalette(palette)\n", "tokens": ["seaborn", "palettes", "py", "def", "husl_palette", "n_colors", "6", "h", "01", "s", "9", "l", "65", "as_cmap", "false", "noqa", "return", "hues", "with", "constant", "lightness", "and", "saturation", "in", "the", "husl", "system", "the", "hues", "are", "evenly", "sampled", "along", "a", "circular", "path", "the", "resulting", "palette", "will", "be", "appropriate", "for", "categorical", "or", "cyclical", "data", "the", "h", "l", "and", "s", "values", "should", "be", "between", "0", "and", "1", "this", "function", "is", "similar", "to", "func", "hls_palette", "but", "it", "uses", "a", "nonlinear", "color", "space", "that", "is", "more", "perceptually", "uniform", "parameters", "n_colors", "int", "number", "of", "colors", "in", "the", "palette", "h", "float", "the", "value", "of", "the", "first", "hue", "l", "float", "the", "lightness", "value", "s", "float", "the", "saturation", "intensity", "as_cmap", "bool", "if", "true", "return", "a", "matplotlib", "colormap", "object", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "hls_palette", "make", "a", "palette", "using", "evenly", "spaced", "hues", "in", "the", "hsl", "system", "examples", "include", "docstrings", "husl_palette", "rst", "if", "as_cmap", "n_colors", "256", "hues", "np", "linspace", "0", "1", "int", "n_colors", "1", "1", "hues", "h", "hues", "1", "hues", "359", "s", "99", "l", "99", "noqa", "palette", "_color_to_rgb", "h_i", "s", "l", "input", "husl", "for", "h_i", "in", "hues", "if", "as_cmap", "return", "mpl", "colors", "listedcolormap", "palette", "hsl", "else", "return", "_colorpalette", "palette"], "doc_len": 191}
{"doc_id": "seaborn/palettes.py::mpl_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "mpl_palette", "text": "文件路径: seaborn/palettes.py\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    \"\"\"\n    Return a palette or colormap from the matplotlib registry.\n\n    For continuous palettes, evenly-spaced discrete samples are chosen while\n    excluding the minimum and maximum value in the colormap to provide better\n    contrast at the extremes.\n\n    For qualitative palettes (e.g. those from colorbrewer), exact values are\n    indexed (rather than interpolated), but fewer than `n_colors` can be returned\n    if the palette does not define that many.\n\n    Parameters\n    ----------\n    name : string\n        Name of the palette. This should be a named matplotlib colormap.\n    n_colors : int\n        Number of discrete colors in the palette.\n\n    Returns\n    -------\n    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    Examples\n    --------\n    .. include: ../docstrings/mpl_palette.rst\n\n    \"\"\"\n    if name.endswith(\"_d\"):\n        sub_name = name[:-2]\n        if sub_name.endswith(\"_r\"):\n            reverse = True\n            sub_name = sub_name[:-2]\n        else:\n            reverse = False\n        pal = color_palette(sub_name, 2) + [\"#333333\"]\n        if reverse:\n            pal = pal[::-1]\n        cmap = blend_palette(pal, n_colors, as_cmap=True)\n    else:\n        cmap = get_colormap(name)\n\n    if name in MPL_QUAL_PALS:\n        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]\n    else:\n        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]\n    palette = list(map(tuple, cmap(bins)[:, :3]))\n\n    if as_cmap:\n        return cmap\n    else:\n        return _ColorPalette(palette)\n", "tokens": ["seaborn", "palettes", "py", "def", "mpl_palette", "name", "n_colors", "6", "as_cmap", "false", "return", "a", "palette", "or", "colormap", "from", "the", "matplotlib", "registry", "for", "continuous", "palettes", "evenly", "spaced", "discrete", "samples", "are", "chosen", "while", "excluding", "the", "minimum", "and", "maximum", "value", "in", "the", "colormap", "to", "provide", "better", "contrast", "at", "the", "extremes", "for", "qualitative", "palettes", "e", "g", "those", "from", "colorbrewer", "exact", "values", "are", "indexed", "rather", "than", "interpolated", "but", "fewer", "than", "n_colors", "can", "be", "returned", "if", "the", "palette", "does", "not", "define", "that", "many", "parameters", "name", "string", "name", "of", "the", "palette", "this", "should", "be", "a", "named", "matplotlib", "colormap", "n_colors", "int", "number", "of", "discrete", "colors", "in", "the", "palette", "returns", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "examples", "include", "docstrings", "mpl_palette", "rst", "if", "name", "endswith", "_d", "sub_name", "name", "2", "if", "sub_name", "endswith", "_r", "reverse", "true", "sub_name", "sub_name", "2", "else", "reverse", "false", "pal", "color_palette", "sub_name", "2", "333333", "if", "reverse", "pal", "pal", "1", "cmap", "blend_palette", "pal", "n_colors", "as_cmap", "true", "else", "cmap", "get_colormap", "name", "if", "name", "in", "mpl_qual_pals", "bins", "np", "linspace", "0", "1", "mpl_qual_pals", "name", "n_colors", "else", "bins", "np", "linspace", "0", "1", "int", "n_colors", "2", "1", "1", "palette", "list", "map", "tuple", "cmap", "bins", "3", "if", "as_cmap", "return", "cmap", "else", "return", "_colorpalette", "palette"], "doc_len": 190}
{"doc_id": "seaborn/palettes.py::_color_to_rgb", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "_color_to_rgb", "text": "文件路径: seaborn/palettes.py\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == \"hls\":\n        color = colorsys.hls_to_rgb(*color)\n    elif input == \"husl\":\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == \"xkcd\":\n        color = xkcd_rgb[color]\n\n    return mpl.colors.to_rgb(color)\n", "tokens": ["seaborn", "palettes", "py", "def", "_color_to_rgb", "color", "input", "add", "some", "more", "flexibility", "to", "color", "choices", "if", "input", "hls", "color", "colorsys", "hls_to_rgb", "color", "elif", "input", "husl", "color", "husl", "husl_to_rgb", "color", "color", "tuple", "np", "clip", "color", "0", "1", "elif", "input", "xkcd", "color", "xkcd_rgb", "color", "return", "mpl", "colors", "to_rgb", "color"], "doc_len": 46}
{"doc_id": "seaborn/palettes.py::dark_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "dark_palette", "text": "文件路径: seaborn/palettes.py\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):\n    \"\"\"Make a sequential palette that blends from dark to ``color``.\n\n    This kind of palette is good for data that range between relatively\n    uninteresting low values and interesting high values.\n\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n\n    If you are using the IPython notebook, you can also choose this palette\n    interactively with the :func:`choose_dark_palette` function.\n\n    Parameters\n    ----------\n    color : base color for high values\n        hex, rgb-tuple, or html color name\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette with two colors.\n\n    Examples\n    --------\n    .. include:: ../docstrings/dark_palette.rst\n\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    h, s, l = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = .15 * s, 15\n    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)\n", "tokens": ["seaborn", "palettes", "py", "def", "dark_palette", "color", "n_colors", "6", "reverse", "false", "as_cmap", "false", "input", "rgb", "make", "a", "sequential", "palette", "that", "blends", "from", "dark", "to", "color", "this", "kind", "of", "palette", "is", "good", "for", "data", "that", "range", "between", "relatively", "uninteresting", "low", "values", "and", "interesting", "high", "values", "the", "color", "parameter", "can", "be", "specified", "in", "a", "number", "of", "ways", "including", "all", "options", "for", "defining", "a", "color", "in", "matplotlib", "and", "several", "additional", "color", "spaces", "that", "are", "handled", "by", "seaborn", "you", "can", "also", "use", "the", "database", "of", "named", "colors", "from", "the", "xkcd", "color", "survey", "if", "you", "are", "using", "the", "ipython", "notebook", "you", "can", "also", "choose", "this", "palette", "interactively", "with", "the", "func", "choose_dark_palette", "function", "parameters", "color", "base", "color", "for", "high", "values", "hex", "rgb", "tuple", "or", "html", "color", "name", "n_colors", "int", "optional", "number", "of", "colors", "in", "the", "palette", "reverse", "bool", "optional", "if", "true", "reverse", "the", "direction", "of", "the", "blend", "as_cmap", "bool", "optional", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "input", "rgb", "hls", "husl", "xkcd", "color", "space", "to", "interpret", "the", "input", "color", "the", "first", "three", "options", "apply", "to", "tuple", "inputs", "and", "the", "latter", "applies", "to", "string", "inputs", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "light_palette", "create", "a", "sequential", "palette", "with", "bright", "low", "values", "diverging_palette", "create", "a", "diverging", "palette", "with", "two", "colors", "examples", "include", "docstrings", "dark_palette", "rst", "rgb", "_color_to_rgb", "color", "input", "h", "s", "l", "husl", "rgb_to_husl", "rgb", "gray_s", "gray_l", "15", "s", "15", "gray", "_color_to_rgb", "h", "gray_s", "gray_l", "input", "husl", "colors", "rgb", "gray", "if", "reverse", "else", "gray", "rgb", "return", "blend_palette", "colors", "n_colors", "as_cmap"], "doc_len": 248}
{"doc_id": "seaborn/palettes.py::light_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "light_palette", "text": "文件路径: seaborn/palettes.py\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):\n    \"\"\"Make a sequential palette that blends from light to ``color``.\n\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n\n    If you are using a Jupyter notebook, you can also choose this palette\n    interactively with the :func:`choose_light_palette` function.\n\n    Parameters\n    ----------\n    color : base color for high values\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    diverging_palette : Create a diverging palette with two colors.\n\n    Examples\n    --------\n    .. include:: ../docstrings/light_palette.rst\n\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    h, s, l = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = .15 * s, 95\n    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)\n", "tokens": ["seaborn", "palettes", "py", "def", "light_palette", "color", "n_colors", "6", "reverse", "false", "as_cmap", "false", "input", "rgb", "make", "a", "sequential", "palette", "that", "blends", "from", "light", "to", "color", "the", "color", "parameter", "can", "be", "specified", "in", "a", "number", "of", "ways", "including", "all", "options", "for", "defining", "a", "color", "in", "matplotlib", "and", "several", "additional", "color", "spaces", "that", "are", "handled", "by", "seaborn", "you", "can", "also", "use", "the", "database", "of", "named", "colors", "from", "the", "xkcd", "color", "survey", "if", "you", "are", "using", "a", "jupyter", "notebook", "you", "can", "also", "choose", "this", "palette", "interactively", "with", "the", "func", "choose_light_palette", "function", "parameters", "color", "base", "color", "for", "high", "values", "hex", "code", "html", "color", "name", "or", "tuple", "in", "input", "space", "n_colors", "int", "optional", "number", "of", "colors", "in", "the", "palette", "reverse", "bool", "optional", "if", "true", "reverse", "the", "direction", "of", "the", "blend", "as_cmap", "bool", "optional", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "input", "rgb", "hls", "husl", "xkcd", "color", "space", "to", "interpret", "the", "input", "color", "the", "first", "three", "options", "apply", "to", "tuple", "inputs", "and", "the", "latter", "applies", "to", "string", "inputs", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "low", "values", "diverging_palette", "create", "a", "diverging", "palette", "with", "two", "colors", "examples", "include", "docstrings", "light_palette", "rst", "rgb", "_color_to_rgb", "color", "input", "h", "s", "l", "husl", "rgb_to_husl", "rgb", "gray_s", "gray_l", "15", "s", "95", "gray", "_color_to_rgb", "h", "gray_s", "gray_l", "input", "husl", "colors", "rgb", "gray", "if", "reverse", "else", "gray", "rgb", "return", "blend_palette", "colors", "n_colors", "as_cmap"], "doc_len": 232}
{"doc_id": "seaborn/palettes.py::diverging_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "diverging_palette", "text": "文件路径: seaborn/palettes.py\ndef diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6,  # noqa\n                      center=\"light\", as_cmap=False):\n    \"\"\"Make a diverging palette between two HUSL colors.\n\n    If you are using the IPython notebook, you can also choose this palette\n    interactively with the :func:`choose_diverging_palette` function.\n\n    Parameters\n    ----------\n    h_neg, h_pos : float in [0, 359]\n        Anchor hues for negative and positive extents of the map.\n    s : float in [0, 100], optional\n        Anchor saturation for both extents of the map.\n    l : float in [0, 100], optional\n        Anchor lightness for both extents of the map.\n    sep : int, optional\n        Size of the intermediate region.\n    n : int, optional\n        Number of colors in the palette (if not returning a cmap)\n    center : {\"light\", \"dark\"}, optional\n        Whether the center of the palette is light or dark\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark values.\n    light_palette : Create a sequential palette with light values.\n\n    Examples\n    --------\n    .. include: ../docstrings/diverging_palette.rst\n\n    \"\"\"\n    palfunc = dict(dark=dark_palette, light=light_palette)[center]\n    n_half = int(128 - (sep // 2))\n    neg = palfunc((h_neg, s, l), n_half, reverse=True, input=\"husl\")\n    pos = palfunc((h_pos, s, l), n_half, input=\"husl\")\n    midpoint = dict(light=[(.95, .95, .95)], dark=[(.133, .133, .133)])[center]\n    mid = midpoint * sep\n    pal = blend_palette(np.concatenate([neg, mid, pos]), n, as_cmap=as_cmap)\n    return pal\n", "tokens": ["seaborn", "palettes", "py", "def", "diverging_palette", "h_neg", "h_pos", "s", "75", "l", "50", "sep", "1", "n", "6", "noqa", "center", "light", "as_cmap", "false", "make", "a", "diverging", "palette", "between", "two", "husl", "colors", "if", "you", "are", "using", "the", "ipython", "notebook", "you", "can", "also", "choose", "this", "palette", "interactively", "with", "the", "func", "choose_diverging_palette", "function", "parameters", "h_neg", "h_pos", "float", "in", "0", "359", "anchor", "hues", "for", "negative", "and", "positive", "extents", "of", "the", "map", "s", "float", "in", "0", "100", "optional", "anchor", "saturation", "for", "both", "extents", "of", "the", "map", "l", "float", "in", "0", "100", "optional", "anchor", "lightness", "for", "both", "extents", "of", "the", "map", "sep", "int", "optional", "size", "of", "the", "intermediate", "region", "n", "int", "optional", "number", "of", "colors", "in", "the", "palette", "if", "not", "returning", "a", "cmap", "center", "light", "dark", "optional", "whether", "the", "center", "of", "the", "palette", "is", "light", "or", "dark", "as_cmap", "bool", "optional", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "values", "light_palette", "create", "a", "sequential", "palette", "with", "light", "values", "examples", "include", "docstrings", "diverging_palette", "rst", "palfunc", "dict", "dark", "dark_palette", "light", "light_palette", "center", "n_half", "int", "128", "sep", "2", "neg", "palfunc", "h_neg", "s", "l", "n_half", "reverse", "true", "input", "husl", "pos", "palfunc", "h_pos", "s", "l", "n_half", "input", "husl", "midpoint", "dict", "light", "95", "95", "95", "dark", "133", "133", "133", "center", "mid", "midpoint", "sep", "pal", "blend_palette", "np", "concatenate", "neg", "mid", "pos", "n", "as_cmap", "as_cmap", "return", "pal"], "doc_len": 229}
{"doc_id": "seaborn/palettes.py::blend_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "blend_palette", "text": "文件路径: seaborn/palettes.py\ndef blend_palette(colors, n_colors=6, as_cmap=False, input=\"rgb\"):\n    \"\"\"Make a palette that blends between a list of colors.\n\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = \"blend\"\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]  # no alpha\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n", "tokens": ["seaborn", "palettes", "py", "def", "blend_palette", "colors", "n_colors", "6", "as_cmap", "false", "input", "rgb", "make", "a", "palette", "that", "blends", "between", "a", "list", "of", "colors", "parameters", "colors", "sequence", "of", "colors", "in", "various", "formats", "interpreted", "by", "input", "hex", "code", "html", "color", "name", "or", "tuple", "in", "input", "space", "n_colors", "int", "optional", "number", "of", "colors", "in", "the", "palette", "as_cmap", "bool", "optional", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "examples", "include", "docstrings", "blend_palette", "rst", "colors", "_color_to_rgb", "color", "input", "for", "color", "in", "colors", "name", "blend", "pal", "mpl", "colors", "linearsegmentedcolormap", "from_list", "name", "colors", "if", "not", "as_cmap", "rgb_array", "pal", "np", "linspace", "0", "1", "int", "n_colors", "3", "no", "alpha", "pal", "_colorpalette", "map", "tuple", "rgb_array", "return", "pal"], "doc_len": 117}
{"doc_id": "seaborn/palettes.py::xkcd_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "xkcd_palette", "text": "文件路径: seaborn/palettes.py\ndef xkcd_palette(colors):\n    \"\"\"Make a palette with color names from the xkcd color survey.\n\n    See xkcd for the full list of colors: https://xkcd.com/color/rgb/\n\n    This is just a simple wrapper around the `seaborn.xkcd_rgb` dictionary.\n\n    Parameters\n    ----------\n    colors : list of strings\n        List of keys in the `seaborn.xkcd_rgb` dictionary.\n\n    Returns\n    -------\n    palette\n        A list of colors as RGB tuples.\n\n    See Also\n    --------\n    crayon_palette : Make a palette with Crayola crayon colors.\n\n    \"\"\"\n    palette = [xkcd_rgb[name] for name in colors]\n    return color_palette(palette, len(palette))\n", "tokens": ["seaborn", "palettes", "py", "def", "xkcd_palette", "colors", "make", "a", "palette", "with", "color", "names", "from", "the", "xkcd", "color", "survey", "see", "xkcd", "for", "the", "full", "list", "of", "colors", "https", "xkcd", "com", "color", "rgb", "this", "is", "just", "a", "simple", "wrapper", "around", "the", "seaborn", "xkcd_rgb", "dictionary", "parameters", "colors", "list", "of", "strings", "list", "of", "keys", "in", "the", "seaborn", "xkcd_rgb", "dictionary", "returns", "palette", "a", "list", "of", "colors", "as", "rgb", "tuples", "see", "also", "crayon_palette", "make", "a", "palette", "with", "crayola", "crayon", "colors", "palette", "xkcd_rgb", "name", "for", "name", "in", "colors", "return", "color_palette", "palette", "len", "palette"], "doc_len": 85}
{"doc_id": "seaborn/palettes.py::crayon_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "crayon_palette", "text": "文件路径: seaborn/palettes.py\ndef crayon_palette(colors):\n    \"\"\"Make a palette with color names from Crayola crayons.\n\n    Colors are taken from here:\n    https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors\n\n    This is just a simple wrapper around the `seaborn.crayons` dictionary.\n\n    Parameters\n    ----------\n    colors : list of strings\n        List of keys in the `seaborn.crayons` dictionary.\n\n    Returns\n    -------\n    palette\n        A list of colors as RGB tuples.\n\n    See Also\n    --------\n    xkcd_palette : Make a palette with named colors from the XKCD color survey.\n\n    \"\"\"\n    palette = [crayons[name] for name in colors]\n    return color_palette(palette, len(palette))\n", "tokens": ["seaborn", "palettes", "py", "def", "crayon_palette", "colors", "make", "a", "palette", "with", "color", "names", "from", "crayola", "crayons", "colors", "are", "taken", "from", "here", "https", "en", "wikipedia", "org", "wiki", "list_of_crayola_crayon_colors", "this", "is", "just", "a", "simple", "wrapper", "around", "the", "seaborn", "crayons", "dictionary", "parameters", "colors", "list", "of", "strings", "list", "of", "keys", "in", "the", "seaborn", "crayons", "dictionary", "returns", "palette", "a", "list", "of", "colors", "as", "rgb", "tuples", "see", "also", "xkcd_palette", "make", "a", "palette", "with", "named", "colors", "from", "the", "xkcd", "color", "survey", "palette", "crayons", "name", "for", "name", "in", "colors", "return", "color_palette", "palette", "len", "palette"], "doc_len": 85}
{"doc_id": "seaborn/palettes.py::cubehelix_palette", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "cubehelix_palette", "text": "文件路径: seaborn/palettes.py\ndef cubehelix_palette(n_colors=6, start=0, rot=.4, gamma=1.0, hue=0.8,\n                      light=.85, dark=.15, reverse=False, as_cmap=False):\n    \"\"\"Make a sequential palette from the cubehelix system.\n\n    This produces a colormap with linearly-decreasing (or increasing)\n    brightness. That means that information will be preserved if printed to\n    black and white or viewed by someone who is colorblind.  \"cubehelix\" is\n    also available as a matplotlib-based palette, but this function gives the\n    user more control over the look of the palette and has a different set of\n    defaults.\n\n    In addition to using this function, it is also possible to generate a\n    cubehelix palette generally in seaborn using a string starting with\n    `ch:` and containing other parameters (e.g. `\"ch:s=.25,r=-.5\"`).\n\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    start : float, 0 <= start <= 3\n        The hue value at the start of the helix.\n    rot : float\n        Rotations around the hue wheel over the range of the palette.\n    gamma : float 0 <= gamma\n        Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors.\n    hue : float, 0 <= hue <= 1\n        Saturation of the colors.\n    dark : float 0 <= dark <= 1\n        Intensity of the darkest color in the palette.\n    light : float 0 <= light <= 1\n        Intensity of the lightest color in the palette.\n    reverse : bool\n        If True, the palette will go from dark to light.\n    as_cmap : bool\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n\n    See Also\n    --------\n    choose_cubehelix_palette : Launch an interactive widget to select cubehelix\n                               palette parameters.\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n\n    References\n    ----------\n    Green, D. A. (2011). \"A colour scheme for the display of astronomical\n    intensity images\". Bulletin of the Astromical Society of India, Vol. 39,\n    p. 289-295.\n\n    Examples\n    --------\n    .. include:: ../docstrings/cubehelix_palette.rst\n\n    \"\"\"\n    def get_color_function(p0, p1):\n        # Copied from matplotlib because it lives in private module\n        def color(x):\n            # Apply gamma factor to emphasise low or high intensity values\n            xg = x ** gamma\n\n            # Calculate amplitude and angle of deviation from the black\n            # to white diagonal in the plane of constant\n            # perceived intensity.\n            a = hue * xg * (1 - xg) / 2\n\n            phi = 2 * np.pi * (start / 3 + rot * x)\n\n            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))\n        return color\n\n    cdict = {\n        \"red\": get_color_function(-0.14861, 1.78277),\n        \"green\": get_color_function(-0.29227, -0.90649),\n        \"blue\": get_color_function(1.97294, 0.0),\n    }\n\n    cmap = mpl.colors.LinearSegmentedColormap(\"cubehelix\", cdict)\n\n    x = np.linspace(light, dark, int(n_colors))\n    pal = cmap(x)[:, :3].tolist()\n    if reverse:\n        pal = pal[::-1]\n\n    if as_cmap:\n        x_256 = np.linspace(light, dark, 256)\n        if reverse:\n            x_256 = x_256[::-1]\n        pal_256 = cmap(x_256)\n        cmap = mpl.colors.ListedColormap(pal_256, \"seaborn_cubehelix\")\n        return cmap\n    else:\n        return _ColorPalette(pal)\n", "tokens": ["seaborn", "palettes", "py", "def", "cubehelix_palette", "n_colors", "6", "start", "0", "rot", "4", "gamma", "1", "0", "hue", "0", "8", "light", "85", "dark", "15", "reverse", "false", "as_cmap", "false", "make", "a", "sequential", "palette", "from", "the", "cubehelix", "system", "this", "produces", "a", "colormap", "with", "linearly", "decreasing", "or", "increasing", "brightness", "that", "means", "that", "information", "will", "be", "preserved", "if", "printed", "to", "black", "and", "white", "or", "viewed", "by", "someone", "who", "is", "colorblind", "cubehelix", "is", "also", "available", "as", "a", "matplotlib", "based", "palette", "but", "this", "function", "gives", "the", "user", "more", "control", "over", "the", "look", "of", "the", "palette", "and", "has", "a", "different", "set", "of", "defaults", "in", "addition", "to", "using", "this", "function", "it", "is", "also", "possible", "to", "generate", "a", "cubehelix", "palette", "generally", "in", "seaborn", "using", "a", "string", "starting", "with", "ch", "and", "containing", "other", "parameters", "e", "g", "ch", "s", "25", "r", "5", "parameters", "n_colors", "int", "number", "of", "colors", "in", "the", "palette", "start", "float", "0", "start", "3", "the", "hue", "value", "at", "the", "start", "of", "the", "helix", "rot", "float", "rotations", "around", "the", "hue", "wheel", "over", "the", "range", "of", "the", "palette", "gamma", "float", "0", "gamma", "nonlinearity", "to", "emphasize", "dark", "gamma", "1", "or", "light", "gamma", "1", "colors", "hue", "float", "0", "hue", "1", "saturation", "of", "the", "colors", "dark", "float", "0", "dark", "1", "intensity", "of", "the", "darkest", "color", "in", "the", "palette", "light", "float", "0", "light", "1", "intensity", "of", "the", "lightest", "color", "in", "the", "palette", "reverse", "bool", "if", "true", "the", "palette", "will", "go", "from", "dark", "to", "light", "as_cmap", "bool", "if", "true", "return", "a", "class", "matplotlib", "colors", "listedcolormap", "returns", "palette", "list", "of", "rgb", "tuples", "or", "class", "matplotlib", "colors", "listedcolormap", "see", "also", "choose_cubehelix_palette", "launch", "an", "interactive", "widget", "to", "select", "cubehelix", "palette", "parameters", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "low", "values", "light_palette", "create", "a", "sequential", "palette", "with", "bright", "low", "values", "references", "green", "d", "a", "2011", "a", "colour", "scheme", "for", "the", "display", "of", "astronomical", "intensity", "images", "bulletin", "of", "the", "astromical", "society", "of", "india", "vol", "39", "p", "289", "295", "examples", "include", "docstrings", "cubehelix_palette", "rst", "def", "get_color_function", "p0", "p1", "copied", "from", "matplotlib", "because", "it", "lives", "in", "private", "module", "def", "color", "x", "apply", "gamma", "factor", "to", "emphasise", "low", "or", "high", "intensity", "values", "xg", "x", "gamma", "calculate", "amplitude", "and", "angle", "of", "deviation", "from", "the", "black", "to", "white", "diagonal", "in", "the", "plane", "of", "constant", "perceived", "intensity", "a", "hue", "xg", "1", "xg", "2", "phi", "2", "np", "pi", "start", "3", "rot", "x", "return", "xg", "a", "p0", "np", "cos", "phi", "p1", "np", "sin", "phi", "return", "color", "cdict", "red", "get_color_function", "0", "14861", "1", "78277", "green", "get_color_function", "0", "29227", "0", "90649", "blue", "get_color_function", "1", "97294", "0", "0", "cmap", "mpl", "colors", "linearsegmentedcolormap", "cubehelix", "cdict", "x", "np", "linspace", "light", "dark", "int", "n_colors", "pal", "cmap", "x", "3", "tolist", "if", "reverse", "pal", "pal", "1", "if", "as_cmap", "x_256", "np", "linspace", "light", "dark", "256", "if", "reverse", "x_256", "x_256", "1", "pal_256", "cmap", "x_256", "cmap", "mpl", "colors", "listedcolormap", "pal_256", "seaborn_cubehelix", "return", "cmap", "else", "return", "_colorpalette", "pal"], "doc_len": 454}
{"doc_id": "seaborn/palettes.py::_parse_cubehelix_args", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "_parse_cubehelix_args", "text": "文件路径: seaborn/palettes.py\ndef _parse_cubehelix_args(argstr):\n    \"\"\"Turn stringified cubehelix params into args/kwargs.\"\"\"\n\n    if argstr.startswith(\"ch:\"):\n        argstr = argstr[3:]\n\n    if argstr.endswith(\"_r\"):\n        reverse = True\n        argstr = argstr[:-2]\n    else:\n        reverse = False\n\n    if not argstr:\n        return [], {\"reverse\": reverse}\n\n    all_args = argstr.split(\",\")\n\n    args = [float(a.strip(\" \")) for a in all_args if \"=\" not in a]\n\n    kwargs = [a.split(\"=\") for a in all_args if \"=\" in a]\n    kwargs = {k.strip(\" \"): float(v.strip(\" \")) for k, v in kwargs}\n\n    kwarg_map = dict(\n        s=\"start\", r=\"rot\", g=\"gamma\",\n        h=\"hue\", l=\"light\", d=\"dark\",  # noqa: E741\n    )\n\n    kwargs = {kwarg_map.get(k, k): v for k, v in kwargs.items()}\n\n    if reverse:\n        kwargs[\"reverse\"] = True\n\n    return args, kwargs\n", "tokens": ["seaborn", "palettes", "py", "def", "_parse_cubehelix_args", "argstr", "turn", "stringified", "cubehelix", "params", "into", "args", "kwargs", "if", "argstr", "startswith", "ch", "argstr", "argstr", "3", "if", "argstr", "endswith", "_r", "reverse", "true", "argstr", "argstr", "2", "else", "reverse", "false", "if", "not", "argstr", "return", "reverse", "reverse", "all_args", "argstr", "split", "args", "float", "a", "strip", "for", "a", "in", "all_args", "if", "not", "in", "a", "kwargs", "a", "split", "for", "a", "in", "all_args", "if", "in", "a", "kwargs", "k", "strip", "float", "v", "strip", "for", "k", "v", "in", "kwargs", "kwarg_map", "dict", "s", "start", "r", "rot", "g", "gamma", "h", "hue", "l", "light", "d", "dark", "noqa", "e741", "kwargs", "kwarg_map", "get", "k", "k", "v", "for", "k", "v", "in", "kwargs", "items", "if", "reverse", "kwargs", "reverse", "true", "return", "args", "kwargs"], "doc_len": 110}
{"doc_id": "seaborn/palettes.py::set_color_codes", "file_path": "seaborn/palettes.py", "class_name": null, "func_name": "set_color_codes", "text": "文件路径: seaborn/palettes.py\ndef set_color_codes(palette=\"deep\"):\n    \"\"\"Change how matplotlib color shorthands are interpreted.\n\n    Calling this will change how shorthand codes like \"b\" or \"g\"\n    are interpreted by matplotlib in subsequent plots.\n\n    Parameters\n    ----------\n    palette : {deep, muted, pastel, dark, bright, colorblind}\n        Named seaborn palette to use as the source of colors.\n\n    See Also\n    --------\n    set : Color codes can be set through the high-level seaborn style\n          manager.\n    set_palette : Color codes can also be set through the function that\n                  sets the matplotlib color cycle.\n\n    \"\"\"\n    if palette == \"reset\":\n        colors = [\n            (0., 0., 1.),\n            (0., .5, 0.),\n            (1., 0., 0.),\n            (.75, 0., .75),\n            (.75, .75, 0.),\n            (0., .75, .75),\n            (0., 0., 0.)\n        ]\n    elif not isinstance(palette, str):\n        err = \"set_color_codes requires a named seaborn palette\"\n        raise TypeError(err)\n    elif palette in SEABORN_PALETTES:\n        if not palette.endswith(\"6\"):\n            palette = palette + \"6\"\n        colors = SEABORN_PALETTES[palette] + [(.1, .1, .1)]\n    else:\n        err = f\"Cannot set colors with palette '{palette}'\"\n        raise ValueError(err)\n\n    for code, color in zip(\"bgrmyck\", colors):\n        rgb = mpl.colors.colorConverter.to_rgb(color)\n        mpl.colors.colorConverter.colors[code] = rgb\n        mpl.colors.colorConverter.cache[code] = rgb\n", "tokens": ["seaborn", "palettes", "py", "def", "set_color_codes", "palette", "deep", "change", "how", "matplotlib", "color", "shorthands", "are", "interpreted", "calling", "this", "will", "change", "how", "shorthand", "codes", "like", "b", "or", "g", "are", "interpreted", "by", "matplotlib", "in", "subsequent", "plots", "parameters", "palette", "deep", "muted", "pastel", "dark", "bright", "colorblind", "named", "seaborn", "palette", "to", "use", "as", "the", "source", "of", "colors", "see", "also", "set", "color", "codes", "can", "be", "set", "through", "the", "high", "level", "seaborn", "style", "manager", "set_palette", "color", "codes", "can", "also", "be", "set", "through", "the", "function", "that", "sets", "the", "matplotlib", "color", "cycle", "if", "palette", "reset", "colors", "0", "0", "1", "0", "5", "0", "1", "0", "0", "75", "0", "75", "75", "75", "0", "0", "75", "75", "0", "0", "0", "elif", "not", "isinstance", "palette", "str", "err", "set_color_codes", "requires", "a", "named", "seaborn", "palette", "raise", "typeerror", "err", "elif", "palette", "in", "seaborn_palettes", "if", "not", "palette", "endswith", "6", "palette", "palette", "6", "colors", "seaborn_palettes", "palette", "1", "1", "1", "else", "err", "f", "cannot", "set", "colors", "with", "palette", "palette", "raise", "valueerror", "err", "for", "code", "color", "in", "zip", "bgrmyck", "colors", "rgb", "mpl", "colors", "colorconverter", "to_rgb", "color", "mpl", "colors", "colorconverter", "colors", "code", "rgb", "mpl", "colors", "colorconverter", "cache", "code", "rgb"], "doc_len": 176}
{"doc_id": "seaborn/rcmod.py::set_theme", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "set_theme", "text": "文件路径: seaborn/rcmod.py\ndef set_theme(context=\"notebook\", style=\"darkgrid\", palette=\"deep\",\n              font=\"sans-serif\", font_scale=1, color_codes=True, rc=None):\n    \"\"\"\n    Set aspects of the visual theme for all matplotlib and seaborn plots.\n\n    This function changes the global defaults for all plots using the\n    matplotlib rcParams system. The themeing is decomposed into several distinct\n    sets of parameter values.\n\n    The options are illustrated in the :doc:`aesthetics <../tutorial/aesthetics>`\n    and :doc:`color palette <../tutorial/color_palettes>` tutorials.\n\n    Parameters\n    ----------\n    context : string or dict\n        Scaling parameters, see :func:`plotting_context`.\n    style : string or dict\n        Axes style parameters, see :func:`axes_style`.\n    palette : string or sequence\n        Color palette, see :func:`color_palette`.\n    font : string\n        Font family, see matplotlib font manager.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    color_codes : bool\n        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand\n        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.\n    rc : dict or None\n        Dictionary of rc parameter mappings to override the above.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_theme.rst\n\n    \"\"\"\n    set_context(context, font_scale)\n    set_style(style, rc={\"font.family\": font})\n    set_palette(palette, color_codes=color_codes)\n    if rc is not None:\n        mpl.rcParams.update(rc)\n", "tokens": ["seaborn", "rcmod", "py", "def", "set_theme", "context", "notebook", "style", "darkgrid", "palette", "deep", "font", "sans", "serif", "font_scale", "1", "color_codes", "true", "rc", "none", "set", "aspects", "of", "the", "visual", "theme", "for", "all", "matplotlib", "and", "seaborn", "plots", "this", "function", "changes", "the", "global", "defaults", "for", "all", "plots", "using", "the", "matplotlib", "rcparams", "system", "the", "themeing", "is", "decomposed", "into", "several", "distinct", "sets", "of", "parameter", "values", "the", "options", "are", "illustrated", "in", "the", "doc", "aesthetics", "tutorial", "aesthetics", "and", "doc", "color", "palette", "tutorial", "color_palettes", "tutorials", "parameters", "context", "string", "or", "dict", "scaling", "parameters", "see", "func", "plotting_context", "style", "string", "or", "dict", "axes", "style", "parameters", "see", "func", "axes_style", "palette", "string", "or", "sequence", "color", "palette", "see", "func", "color_palette", "font", "string", "font", "family", "see", "matplotlib", "font", "manager", "font_scale", "float", "optional", "separate", "scaling", "factor", "to", "independently", "scale", "the", "size", "of", "the", "font", "elements", "color_codes", "bool", "if", "true", "and", "palette", "is", "a", "seaborn", "palette", "remap", "the", "shorthand", "color", "codes", "e", "g", "b", "g", "r", "etc", "to", "the", "colors", "from", "this", "palette", "rc", "dict", "or", "none", "dictionary", "of", "rc", "parameter", "mappings", "to", "override", "the", "above", "examples", "include", "docstrings", "set_theme", "rst", "set_context", "context", "font_scale", "set_style", "style", "rc", "font", "family", "font", "set_palette", "palette", "color_codes", "color_codes", "if", "rc", "is", "not", "none", "mpl", "rcparams", "update", "rc"], "doc_len": 193}
{"doc_id": "seaborn/rcmod.py::set", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "set", "text": "文件路径: seaborn/rcmod.py\ndef set(*args, **kwargs):\n    \"\"\"\n    Alias for :func:`set_theme`, which is the preferred interface.\n\n    This function may be removed in the future.\n    \"\"\"\n    set_theme(*args, **kwargs)\n", "tokens": ["seaborn", "rcmod", "py", "def", "set", "args", "kwargs", "alias", "for", "func", "set_theme", "which", "is", "the", "preferred", "interface", "this", "function", "may", "be", "removed", "in", "the", "future", "set_theme", "args", "kwargs"], "doc_len": 27}
{"doc_id": "seaborn/rcmod.py::reset_defaults", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "reset_defaults", "text": "文件路径: seaborn/rcmod.py\ndef reset_defaults():\n    \"\"\"Restore all RC params to default settings.\"\"\"\n    mpl.rcParams.update(mpl.rcParamsDefault)\n", "tokens": ["seaborn", "rcmod", "py", "def", "reset_defaults", "restore", "all", "rc", "params", "to", "default", "settings", "mpl", "rcparams", "update", "mpl", "rcparamsdefault"], "doc_len": 17}
{"doc_id": "seaborn/rcmod.py::reset_orig", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "reset_orig", "text": "文件路径: seaborn/rcmod.py\ndef reset_orig():\n    \"\"\"Restore all RC params to original settings (respects custom rc).\"\"\"\n    from . import _orig_rc_params\n    mpl.rcParams.update(_orig_rc_params)\n", "tokens": ["seaborn", "rcmod", "py", "def", "reset_orig", "restore", "all", "rc", "params", "to", "original", "settings", "respects", "custom", "rc", "from", "import", "_orig_rc_params", "mpl", "rcparams", "update", "_orig_rc_params"], "doc_len": 22}
{"doc_id": "seaborn/rcmod.py::axes_style", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "axes_style", "text": "文件路径: seaborn/rcmod.py\ndef axes_style(style=None, rc=None):\n    \"\"\"\n    Get the parameters that control the general style of the plots.\n\n    The style parameters control properties like the color of the background and\n    whether a grid is enabled by default. This is accomplished using the\n    matplotlib rcParams system.\n\n    The options are illustrated in the\n    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    This function can also be used as a context manager to temporarily\n    alter the global defaults. See :func:`set_theme` or :func:`set_style`\n    to modify the global defaults for all plots.\n\n    Parameters\n    ----------\n    style : None, dict, or one of {darkgrid, whitegrid, dark, white, ticks}\n        A dictionary of parameters or the name of a preconfigured style.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        style dictionaries. This only updates parameters that are\n        considered part of the style definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/axes_style.rst\n\n    \"\"\"\n    if style is None:\n        style_dict = {k: mpl.rcParams[k] for k in _style_keys}\n\n    elif isinstance(style, dict):\n        style_dict = style\n\n    else:\n        styles = [\"white\", \"dark\", \"whitegrid\", \"darkgrid\", \"ticks\"]\n        if style not in styles:\n            raise ValueError(f\"style must be one of {', '.join(styles)}\")\n\n        # Define colors here\n        dark_gray = \".15\"\n        light_gray = \".8\"\n\n        # Common parameters\n        style_dict = {\n\n            \"figure.facecolor\": \"white\",\n            \"axes.labelcolor\": dark_gray,\n\n            \"xtick.direction\": \"out\",\n            \"ytick.direction\": \"out\",\n            \"xtick.color\": dark_gray,\n            \"ytick.color\": dark_gray,\n\n            \"axes.axisbelow\": True,\n            \"grid.linestyle\": \"-\",\n\n\n            \"text.color\": dark_gray,\n            \"font.family\": [\"sans-serif\"],\n            \"font.sans-serif\": [\"Arial\", \"DejaVu Sans\", \"Liberation Sans\",\n                                \"Bitstream Vera Sans\", \"sans-serif\"],\n\n\n            \"lines.solid_capstyle\": \"round\",\n            \"patch.edgecolor\": \"w\",\n            \"patch.force_edgecolor\": True,\n\n            \"image.cmap\": \"rocket\",\n\n            \"xtick.top\": False,\n            \"ytick.right\": False,\n\n        }\n\n        # Set grid on or off\n        if \"grid\" in style:\n            style_dict.update({\n                \"axes.grid\": True,\n            })\n        else:\n            style_dict.update({\n                \"axes.grid\": False,\n            })\n\n        # Set the color of the background, spines, and grids\n        if style.startswith(\"dark\"):\n            style_dict.update({\n\n                \"axes.facecolor\": \"#EAEAF2\",\n                \"axes.edgecolor\": \"white\",\n                \"grid.color\": \"white\",\n\n                \"axes.spines.left\": True,\n                \"axes.spines.bottom\": True,\n                \"axes.spines.right\": True,\n                \"axes.spines.top\": True,\n\n            })\n\n        elif style == \"whitegrid\":\n            style_dict.update({\n\n                \"axes.facecolor\": \"white\",\n                \"axes.edgecolor\": light_gray,\n                \"grid.color\": light_gray,\n\n                \"axes.spines.left\": True,\n                \"axes.spines.bottom\": True,\n                \"axes.spines.right\": True,\n                \"axes.spines.top\": True,\n\n            })\n\n        elif style in [\"white\", \"ticks\"]:\n            style_dict.update({\n\n                \"axes.facecolor\": \"white\",\n                \"axes.edgecolor\": dark_gray,\n                \"grid.color\": light_gray,\n\n                \"axes.spines.left\": True,\n                \"axes.spines.bottom\": True,\n                \"axes.spines.right\": True,\n                \"axes.spines.top\": True,\n\n            })\n\n        # Show or hide the axes ticks\n        if style == \"ticks\":\n            style_dict.update({\n                \"xtick.bottom\": True,\n                \"ytick.left\": True,\n            })\n        else:\n            style_dict.update({\n                \"xtick.bottom\": False,\n                \"ytick.left\": False,\n            })\n\n    # Remove entries that are not defined in the base list of valid keys\n    # This lets us handle matplotlib <=/> 2.0\n    style_dict = {k: v for k, v in style_dict.items() if k in _style_keys}\n\n    # Override these settings with the provided rc dictionary\n    if rc is not None:\n        rc = {k: v for k, v in rc.items() if k in _style_keys}\n        style_dict.update(rc)\n\n    # Wrap in an _AxesStyle object so this can be used in a with statement\n    style_object = _AxesStyle(style_dict)\n\n    return style_object\n", "tokens": ["seaborn", "rcmod", "py", "def", "axes_style", "style", "none", "rc", "none", "get", "the", "parameters", "that", "control", "the", "general", "style", "of", "the", "plots", "the", "style", "parameters", "control", "properties", "like", "the", "color", "of", "the", "background", "and", "whether", "a", "grid", "is", "enabled", "by", "default", "this", "is", "accomplished", "using", "the", "matplotlib", "rcparams", "system", "the", "options", "are", "illustrated", "in", "the", "doc", "aesthetics", "tutorial", "tutorial", "aesthetics", "this", "function", "can", "also", "be", "used", "as", "a", "context", "manager", "to", "temporarily", "alter", "the", "global", "defaults", "see", "func", "set_theme", "or", "func", "set_style", "to", "modify", "the", "global", "defaults", "for", "all", "plots", "parameters", "style", "none", "dict", "or", "one", "of", "darkgrid", "whitegrid", "dark", "white", "ticks", "a", "dictionary", "of", "parameters", "or", "the", "name", "of", "a", "preconfigured", "style", "rc", "dict", "optional", "parameter", "mappings", "to", "override", "the", "values", "in", "the", "preset", "seaborn", "style", "dictionaries", "this", "only", "updates", "parameters", "that", "are", "considered", "part", "of", "the", "style", "definition", "examples", "include", "docstrings", "axes_style", "rst", "if", "style", "is", "none", "style_dict", "k", "mpl", "rcparams", "k", "for", "k", "in", "_style_keys", "elif", "isinstance", "style", "dict", "style_dict", "style", "else", "styles", "white", "dark", "whitegrid", "darkgrid", "ticks", "if", "style", "not", "in", "styles", "raise", "valueerror", "f", "style", "must", "be", "one", "of", "join", "styles", "define", "colors", "here", "dark_gray", "15", "light_gray", "8", "common", "parameters", "style_dict", "figure", "facecolor", "white", "axes", "labelcolor", "dark_gray", "xtick", "direction", "out", "ytick", "direction", "out", "xtick", "color", "dark_gray", "ytick", "color", "dark_gray", "axes", "axisbelow", "true", "grid", "linestyle", "text", "color", "dark_gray", "font", "family", "sans", "serif", "font", "sans", "serif", "arial", "dejavu", "sans", "liberation", "sans", "bitstream", "vera", "sans", "sans", "serif", "lines", "solid_capstyle", "round", "patch", "edgecolor", "w", "patch", "force_edgecolor", "true", "image", "cmap", "rocket", "xtick", "top", "false", "ytick", "right", "false", "set", "grid", "on", "or", "off", "if", "grid", "in", "style", "style_dict", "update", "axes", "grid", "true", "else", "style_dict", "update", "axes", "grid", "false", "set", "the", "color", "of", "the", "background", "spines", "and", "grids", "if", "style", "startswith", "dark", "style_dict", "update", "axes", "facecolor", "eaeaf2", "axes", "edgecolor", "white", "grid", "color", "white", "axes", "spines", "left", "true", "axes", "spines", "bottom", "true", "axes", "spines", "right", "true", "axes", "spines", "top", "true", "elif", "style", "whitegrid", "style_dict", "update", "axes", "facecolor", "white", "axes", "edgecolor", "light_gray", "grid", "color", "light_gray", "axes", "spines", "left", "true", "axes", "spines", "bottom", "true", "axes", "spines", "right", "true", "axes", "spines", "top", "true", "elif", "style", "in", "white", "ticks", "style_dict", "update", "axes", "facecolor", "white", "axes", "edgecolor", "dark_gray", "grid", "color", "light_gray", "axes", "spines", "left", "true", "axes", "spines", "bottom", "true", "axes", "spines", "right", "true", "axes", "spines", "top", "true", "show", "or", "hide", "the", "axes", "ticks", "if", "style", "ticks", "style_dict", "update", "xtick", "bottom", "true", "ytick", "left", "true", "else", "style_dict", "update", "xtick", "bottom", "false", "ytick", "left", "false", "remove", "entries", "that", "are", "not", "defined", "in", "the", "base", "list", "of", "valid", "keys", "this", "lets", "us", "handle", "matplotlib", "2", "0", "style_dict", "k", "v", "for", "k", "v", "in", "style_dict", "items", "if", "k", "in", "_style_keys", "override", "these", "settings", "with", "the", "provided", "rc", "dictionary", "if", "rc", "is", "not", "none", "rc", "k", "v", "for", "k", "v", "in", "rc", "items", "if", "k", "in", "_style_keys", "style_dict", "update", "rc", "wrap", "in", "an", "_axesstyle", "object", "so", "this", "can", "be", "used", "in", "a", "with", "statement", "style_object", "_axesstyle", "style_dict", "return", "style_object"], "doc_len": 484}
{"doc_id": "seaborn/rcmod.py::set_style", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "set_style", "text": "文件路径: seaborn/rcmod.py\ndef set_style(style=None, rc=None):\n    \"\"\"\n    Set the parameters that control the general style of the plots.\n\n    The style parameters control properties like the color of the background and\n    whether a grid is enabled by default. This is accomplished using the\n    matplotlib rcParams system.\n\n    The options are illustrated in the\n    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    See :func:`axes_style` to get the parameter values.\n\n    Parameters\n    ----------\n    style : dict, or one of {darkgrid, whitegrid, dark, white, ticks}\n        A dictionary of parameters or the name of a preconfigured style.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        style dictionaries. This only updates parameters that are\n        considered part of the style definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_style.rst\n\n    \"\"\"\n    style_object = axes_style(style, rc)\n    mpl.rcParams.update(style_object)\n", "tokens": ["seaborn", "rcmod", "py", "def", "set_style", "style", "none", "rc", "none", "set", "the", "parameters", "that", "control", "the", "general", "style", "of", "the", "plots", "the", "style", "parameters", "control", "properties", "like", "the", "color", "of", "the", "background", "and", "whether", "a", "grid", "is", "enabled", "by", "default", "this", "is", "accomplished", "using", "the", "matplotlib", "rcparams", "system", "the", "options", "are", "illustrated", "in", "the", "doc", "aesthetics", "tutorial", "tutorial", "aesthetics", "see", "func", "axes_style", "to", "get", "the", "parameter", "values", "parameters", "style", "dict", "or", "one", "of", "darkgrid", "whitegrid", "dark", "white", "ticks", "a", "dictionary", "of", "parameters", "or", "the", "name", "of", "a", "preconfigured", "style", "rc", "dict", "optional", "parameter", "mappings", "to", "override", "the", "values", "in", "the", "preset", "seaborn", "style", "dictionaries", "this", "only", "updates", "parameters", "that", "are", "considered", "part", "of", "the", "style", "definition", "examples", "include", "docstrings", "set_style", "rst", "style_object", "axes_style", "style", "rc", "mpl", "rcparams", "update", "style_object"], "doc_len": 128}
{"doc_id": "seaborn/rcmod.py::plotting_context", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "plotting_context", "text": "文件路径: seaborn/rcmod.py\ndef plotting_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Get the parameters that control the scaling of plot elements.\n\n    This affects things like the size of the labels, lines, and other elements\n    of the plot, but not the overall style. This is accomplished using the\n    matplotlib rcParams system.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    This function can also be used as a context manager to temporarily\n    alter the global defaults. See :func:`set_theme` or :func:`set_context`\n    to modify the global defaults for all plots.\n\n    Parameters\n    ----------\n    context : None, dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/plotting_context.rst\n\n    \"\"\"\n    if context is None:\n        context_dict = {k: mpl.rcParams[k] for k in _context_keys}\n\n    elif isinstance(context, dict):\n        context_dict = context\n\n    else:\n\n        contexts = [\"paper\", \"notebook\", \"talk\", \"poster\"]\n        if context not in contexts:\n            raise ValueError(f\"context must be in {', '.join(contexts)}\")\n\n        # Set up dictionary of default parameters\n        texts_base_context = {\n\n            \"font.size\": 12,\n            \"axes.labelsize\": 12,\n            \"axes.titlesize\": 12,\n            \"xtick.labelsize\": 11,\n            \"ytick.labelsize\": 11,\n            \"legend.fontsize\": 11,\n            \"legend.title_fontsize\": 12,\n\n        }\n\n        base_context = {\n\n            \"axes.linewidth\": 1.25,\n            \"grid.linewidth\": 1,\n            \"lines.linewidth\": 1.5,\n            \"lines.markersize\": 6,\n            \"patch.linewidth\": 1,\n\n            \"xtick.major.width\": 1.25,\n            \"ytick.major.width\": 1.25,\n            \"xtick.minor.width\": 1,\n            \"ytick.minor.width\": 1,\n\n            \"xtick.major.size\": 6,\n            \"ytick.major.size\": 6,\n            \"xtick.minor.size\": 4,\n            \"ytick.minor.size\": 4,\n\n        }\n        base_context.update(texts_base_context)\n\n        # Scale all the parameters by the same factor depending on the context\n        scaling = dict(paper=.8, notebook=1, talk=1.5, poster=2)[context]\n        context_dict = {k: v * scaling for k, v in base_context.items()}\n\n        # Now independently scale the fonts\n        font_keys = texts_base_context.keys()\n        font_dict = {k: context_dict[k] * font_scale for k in font_keys}\n        context_dict.update(font_dict)\n\n    # Override these settings with the provided rc dictionary\n    if rc is not None:\n        rc = {k: v for k, v in rc.items() if k in _context_keys}\n        context_dict.update(rc)\n\n    # Wrap in a _PlottingContext object so this can be used in a with statement\n    context_object = _PlottingContext(context_dict)\n\n    return context_object\n", "tokens": ["seaborn", "rcmod", "py", "def", "plotting_context", "context", "none", "font_scale", "1", "rc", "none", "get", "the", "parameters", "that", "control", "the", "scaling", "of", "plot", "elements", "this", "affects", "things", "like", "the", "size", "of", "the", "labels", "lines", "and", "other", "elements", "of", "the", "plot", "but", "not", "the", "overall", "style", "this", "is", "accomplished", "using", "the", "matplotlib", "rcparams", "system", "the", "base", "context", "is", "notebook", "and", "the", "other", "contexts", "are", "paper", "talk", "and", "poster", "which", "are", "version", "of", "the", "notebook", "parameters", "scaled", "by", "different", "values", "font", "elements", "can", "also", "be", "scaled", "independently", "of", "but", "relative", "to", "the", "other", "values", "this", "function", "can", "also", "be", "used", "as", "a", "context", "manager", "to", "temporarily", "alter", "the", "global", "defaults", "see", "func", "set_theme", "or", "func", "set_context", "to", "modify", "the", "global", "defaults", "for", "all", "plots", "parameters", "context", "none", "dict", "or", "one", "of", "paper", "notebook", "talk", "poster", "a", "dictionary", "of", "parameters", "or", "the", "name", "of", "a", "preconfigured", "set", "font_scale", "float", "optional", "separate", "scaling", "factor", "to", "independently", "scale", "the", "size", "of", "the", "font", "elements", "rc", "dict", "optional", "parameter", "mappings", "to", "override", "the", "values", "in", "the", "preset", "seaborn", "context", "dictionaries", "this", "only", "updates", "parameters", "that", "are", "considered", "part", "of", "the", "context", "definition", "examples", "include", "docstrings", "plotting_context", "rst", "if", "context", "is", "none", "context_dict", "k", "mpl", "rcparams", "k", "for", "k", "in", "_context_keys", "elif", "isinstance", "context", "dict", "context_dict", "context", "else", "contexts", "paper", "notebook", "talk", "poster", "if", "context", "not", "in", "contexts", "raise", "valueerror", "f", "context", "must", "be", "in", "join", "contexts", "set", "up", "dictionary", "of", "default", "parameters", "texts_base_context", "font", "size", "12", "axes", "labelsize", "12", "axes", "titlesize", "12", "xtick", "labelsize", "11", "ytick", "labelsize", "11", "legend", "fontsize", "11", "legend", "title_fontsize", "12", "base_context", "axes", "linewidth", "1", "25", "grid", "linewidth", "1", "lines", "linewidth", "1", "5", "lines", "markersize", "6", "patch", "linewidth", "1", "xtick", "major", "width", "1", "25", "ytick", "major", "width", "1", "25", "xtick", "minor", "width", "1", "ytick", "minor", "width", "1", "xtick", "major", "size", "6", "ytick", "major", "size", "6", "xtick", "minor", "size", "4", "ytick", "minor", "size", "4", "base_context", "update", "texts_base_context", "scale", "all", "the", "parameters", "by", "the", "same", "factor", "depending", "on", "the", "context", "scaling", "dict", "paper", "8", "notebook", "1", "talk", "1", "5", "poster", "2", "context", "context_dict", "k", "v", "scaling", "for", "k", "v", "in", "base_context", "items", "now", "independently", "scale", "the", "fonts", "font_keys", "texts_base_context", "keys", "font_dict", "k", "context_dict", "k", "font_scale", "for", "k", "in", "font_keys", "context_dict", "update", "font_dict", "override", "these", "settings", "with", "the", "provided", "rc", "dictionary", "if", "rc", "is", "not", "none", "rc", "k", "v", "for", "k", "v", "in", "rc", "items", "if", "k", "in", "_context_keys", "context_dict", "update", "rc", "wrap", "in", "a", "_plottingcontext", "object", "so", "this", "can", "be", "used", "in", "a", "with", "statement", "context_object", "_plottingcontext", "context_dict", "return", "context_object"], "doc_len": 412}
{"doc_id": "seaborn/rcmod.py::set_context", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "set_context", "text": "文件路径: seaborn/rcmod.py\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    This affects things like the size of the labels, lines, and other elements\n    of the plot, but not the overall style. This is accomplished using the\n    matplotlib rcParams system.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n", "tokens": ["seaborn", "rcmod", "py", "def", "set_context", "context", "none", "font_scale", "1", "rc", "none", "set", "the", "parameters", "that", "control", "the", "scaling", "of", "plot", "elements", "this", "affects", "things", "like", "the", "size", "of", "the", "labels", "lines", "and", "other", "elements", "of", "the", "plot", "but", "not", "the", "overall", "style", "this", "is", "accomplished", "using", "the", "matplotlib", "rcparams", "system", "the", "base", "context", "is", "notebook", "and", "the", "other", "contexts", "are", "paper", "talk", "and", "poster", "which", "are", "version", "of", "the", "notebook", "parameters", "scaled", "by", "different", "values", "font", "elements", "can", "also", "be", "scaled", "independently", "of", "but", "relative", "to", "the", "other", "values", "see", "func", "plotting_context", "to", "get", "the", "parameter", "values", "parameters", "context", "dict", "or", "one", "of", "paper", "notebook", "talk", "poster", "a", "dictionary", "of", "parameters", "or", "the", "name", "of", "a", "preconfigured", "set", "font_scale", "float", "optional", "separate", "scaling", "factor", "to", "independently", "scale", "the", "size", "of", "the", "font", "elements", "rc", "dict", "optional", "parameter", "mappings", "to", "override", "the", "values", "in", "the", "preset", "seaborn", "context", "dictionaries", "this", "only", "updates", "parameters", "that", "are", "considered", "part", "of", "the", "context", "definition", "examples", "include", "docstrings", "set_context", "rst", "context_object", "plotting_context", "context", "font_scale", "rc", "mpl", "rcparams", "update", "context_object"], "doc_len": 174}
{"doc_id": "seaborn/rcmod.py::_RCAesthetics.__enter__", "file_path": "seaborn/rcmod.py", "class_name": "_RCAesthetics", "func_name": "__enter__", "text": "文件路径: seaborn/rcmod.py, 类名: _RCAesthetics\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n", "tokens": ["seaborn", "rcmod", "py", "_rcaesthetics", "def", "__enter__", "self", "rc", "mpl", "rcparams", "self", "_orig", "k", "rc", "k", "for", "k", "in", "self", "_keys", "self", "_set", "self"], "doc_len": 23}
{"doc_id": "seaborn/rcmod.py::_RCAesthetics.__exit__", "file_path": "seaborn/rcmod.py", "class_name": "_RCAesthetics", "func_name": "__exit__", "text": "文件路径: seaborn/rcmod.py, 类名: _RCAesthetics\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n", "tokens": ["seaborn", "rcmod", "py", "_rcaesthetics", "def", "__exit__", "self", "exc_type", "exc_value", "exc_tb", "self", "_set", "self", "_orig"], "doc_len": 14}
{"doc_id": "seaborn/rcmod.py::_RCAesthetics.__call__", "file_path": "seaborn/rcmod.py", "class_name": "_RCAesthetics", "func_name": "__call__", "text": "文件路径: seaborn/rcmod.py, 类名: _RCAesthetics\n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n", "tokens": ["seaborn", "rcmod", "py", "_rcaesthetics", "def", "__call__", "self", "func", "functools", "wraps", "func", "def", "wrapper", "args", "kwargs", "with", "self", "return", "func", "args", "kwargs", "return", "wrapper"], "doc_len": 23}
{"doc_id": "seaborn/rcmod.py::set_palette", "file_path": "seaborn/rcmod.py", "class_name": null, "func_name": "set_palette", "text": "文件路径: seaborn/rcmod.py\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    \"\"\"Set the matplotlib color cycle using a seaborn palette.\n\n    Parameters\n    ----------\n    palette : seaborn color paltte | matplotlib colormap | hls | husl\n        Palette definition. Should be something :func:`color_palette` can process.\n    n_colors : int\n        Number of colors in the cycle. The default number of colors will depend\n        on the format of ``palette``, see the :func:`color_palette`\n        documentation for more information.\n    desat : float\n        Proportion to desaturate each color by.\n    color_codes : bool\n        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand\n        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.\n\n    See Also\n    --------\n    color_palette : build a color palette or set the color cycle temporarily\n                    in a ``with`` statement.\n    set_context : set parameters to scale plot elements\n    set_style : set the default parameters for figure style\n\n    \"\"\"\n    colors = palettes.color_palette(palette, n_colors, desat)\n    cyl = cycler('color', colors)\n    mpl.rcParams['axes.prop_cycle'] = cyl\n    if color_codes:\n        try:\n            palettes.set_color_codes(palette)\n        except (ValueError, TypeError):\n            pass\n", "tokens": ["seaborn", "rcmod", "py", "def", "set_palette", "palette", "n_colors", "none", "desat", "none", "color_codes", "false", "set", "the", "matplotlib", "color", "cycle", "using", "a", "seaborn", "palette", "parameters", "palette", "seaborn", "color", "paltte", "matplotlib", "colormap", "hls", "husl", "palette", "definition", "should", "be", "something", "func", "color_palette", "can", "process", "n_colors", "int", "number", "of", "colors", "in", "the", "cycle", "the", "default", "number", "of", "colors", "will", "depend", "on", "the", "format", "of", "palette", "see", "the", "func", "color_palette", "documentation", "for", "more", "information", "desat", "float", "proportion", "to", "desaturate", "each", "color", "by", "color_codes", "bool", "if", "true", "and", "palette", "is", "a", "seaborn", "palette", "remap", "the", "shorthand", "color", "codes", "e", "g", "b", "g", "r", "etc", "to", "the", "colors", "from", "this", "palette", "see", "also", "color_palette", "build", "a", "color", "palette", "or", "set", "the", "color", "cycle", "temporarily", "in", "a", "with", "statement", "set_context", "set", "parameters", "to", "scale", "plot", "elements", "set_style", "set", "the", "default", "parameters", "for", "figure", "style", "colors", "palettes", "color_palette", "palette", "n_colors", "desat", "cyl", "cycler", "color", "colors", "mpl", "rcparams", "axes", "prop_cycle", "cyl", "if", "color_codes", "try", "palettes", "set_color_codes", "palette", "except", "valueerror", "typeerror", "pass"], "doc_len": 159}
{"doc_id": "seaborn/regression.py::_LinearPlotter.establish_variables", "file_path": "seaborn/regression.py", "class_name": "_LinearPlotter", "func_name": "establish_variables", "text": "文件路径: seaborn/regression.py, 类名: _LinearPlotter\n    def establish_variables(self, data, **kws):\n        \"\"\"Extract variables from data or use directly.\"\"\"\n        self.data = data\n\n        # Validate the inputs\n        any_strings = any([isinstance(v, str) for v in kws.values()])\n        if any_strings and data is None:\n            raise ValueError(\"Must pass `data` if using named variables.\")\n\n        # Set the variables\n        for var, val in kws.items():\n            if isinstance(val, str):\n                vector = data[val]\n            elif isinstance(val, list):\n                vector = np.asarray(val)\n            else:\n                vector = val\n            if vector is not None and vector.shape != (1,):\n                vector = np.squeeze(vector)\n            if np.ndim(vector) > 1:\n                err = \"regplot inputs must be 1d\"\n                raise ValueError(err)\n            setattr(self, var, vector)\n", "tokens": ["seaborn", "regression", "py", "_linearplotter", "def", "establish_variables", "self", "data", "kws", "extract", "variables", "from", "data", "or", "use", "directly", "self", "data", "data", "validate", "the", "inputs", "any_strings", "any", "isinstance", "v", "str", "for", "v", "in", "kws", "values", "if", "any_strings", "and", "data", "is", "none", "raise", "valueerror", "must", "pass", "data", "if", "using", "named", "variables", "set", "the", "variables", "for", "var", "val", "in", "kws", "items", "if", "isinstance", "val", "str", "vector", "data", "val", "elif", "isinstance", "val", "list", "vector", "np", "asarray", "val", "else", "vector", "val", "if", "vector", "is", "not", "none", "and", "vector", "shape", "1", "vector", "np", "squeeze", "vector", "if", "np", "ndim", "vector", "1", "err", "regplot", "inputs", "must", "be", "1d", "raise", "valueerror", "err", "setattr", "self", "var", "vector"], "doc_len": 105}
{"doc_id": "seaborn/regression.py::_LinearPlotter.dropna", "file_path": "seaborn/regression.py", "class_name": "_LinearPlotter", "func_name": "dropna", "text": "文件路径: seaborn/regression.py, 类名: _LinearPlotter\n    def dropna(self, *vars):\n        \"\"\"Remove observations with missing data.\"\"\"\n        vals = [getattr(self, var) for var in vars]\n        vals = [v for v in vals if v is not None]\n        not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)\n        for var in vars:\n            val = getattr(self, var)\n            if val is not None:\n                setattr(self, var, val[not_na])\n", "tokens": ["seaborn", "regression", "py", "_linearplotter", "def", "dropna", "self", "vars", "remove", "observations", "with", "missing", "data", "vals", "getattr", "self", "var", "for", "var", "in", "vars", "vals", "v", "for", "v", "in", "vals", "if", "v", "is", "not", "none", "not_na", "np", "all", "np", "column_stack", "pd", "notnull", "v", "for", "v", "in", "vals", "axis", "1", "for", "var", "in", "vars", "val", "getattr", "self", "var", "if", "val", "is", "not", "none", "setattr", "self", "var", "val", "not_na"], "doc_len": 64}
{"doc_id": "seaborn/regression.py::_LinearPlotter.plot", "file_path": "seaborn/regression.py", "class_name": "_LinearPlotter", "func_name": "plot", "text": "文件路径: seaborn/regression.py, 类名: _LinearPlotter\n    def plot(self, ax):\n        raise NotImplementedError\n", "tokens": ["seaborn", "regression", "py", "_linearplotter", "def", "plot", "self", "ax", "raise", "notimplementederror"], "doc_len": 10}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.__init__", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "__init__", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,\n                 x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,\n                 units=None, seed=None, order=1, logistic=False, lowess=False,\n                 robust=False, logx=False, x_partial=None, y_partial=None,\n                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,\n                 color=None, label=None):\n\n        # Set member attributes\n        self.x_estimator = x_estimator\n        self.ci = ci\n        self.x_ci = ci if x_ci == \"ci\" else x_ci\n        self.n_boot = n_boot\n        self.seed = seed\n        self.scatter = scatter\n        self.fit_reg = fit_reg\n        self.order = order\n        self.logistic = logistic\n        self.lowess = lowess\n        self.robust = robust\n        self.logx = logx\n        self.truncate = truncate\n        self.x_jitter = x_jitter\n        self.y_jitter = y_jitter\n        self.color = color\n        self.label = label\n\n        # Validate the regression options:\n        if sum((order > 1, logistic, robust, lowess, logx)) > 1:\n            raise ValueError(\"Mutually exclusive regression options.\")\n\n        # Extract the data vals from the arguments or passed dataframe\n        self.establish_variables(data, x=x, y=y, units=units,\n                                 x_partial=x_partial, y_partial=y_partial)\n\n        # Drop null observations\n        if dropna:\n            self.dropna(\"x\", \"y\", \"units\", \"x_partial\", \"y_partial\")\n\n        # Regress nuisance variables out of the data\n        if self.x_partial is not None:\n            self.x = self.regress_out(self.x, self.x_partial)\n        if self.y_partial is not None:\n            self.y = self.regress_out(self.y, self.y_partial)\n\n        # Possibly bin the predictor variable, which implies a point estimate\n        if x_bins is not None:\n            self.x_estimator = np.mean if x_estimator is None else x_estimator\n            x_discrete, x_bins = self.bin_predictor(x_bins)\n            self.x_discrete = x_discrete\n        else:\n            self.x_discrete = self.x\n\n        # Disable regression in case of singleton inputs\n        if len(self.x) <= 1:\n            self.fit_reg = False\n\n        # Save the range of the x variable for the grid later\n        if self.fit_reg:\n            self.x_range = self.x.min(), self.x.max()\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "__init__", "self", "x", "y", "data", "none", "x_estimator", "none", "x_bins", "none", "x_ci", "ci", "scatter", "true", "fit_reg", "true", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "order", "1", "logistic", "false", "lowess", "false", "robust", "false", "logx", "false", "x_partial", "none", "y_partial", "none", "truncate", "false", "dropna", "true", "x_jitter", "none", "y_jitter", "none", "color", "none", "label", "none", "set", "member", "attributes", "self", "x_estimator", "x_estimator", "self", "ci", "ci", "self", "x_ci", "ci", "if", "x_ci", "ci", "else", "x_ci", "self", "n_boot", "n_boot", "self", "seed", "seed", "self", "scatter", "scatter", "self", "fit_reg", "fit_reg", "self", "order", "order", "self", "logistic", "logistic", "self", "lowess", "lowess", "self", "robust", "robust", "self", "logx", "logx", "self", "truncate", "truncate", "self", "x_jitter", "x_jitter", "self", "y_jitter", "y_jitter", "self", "color", "color", "self", "label", "label", "validate", "the", "regression", "options", "if", "sum", "order", "1", "logistic", "robust", "lowess", "logx", "1", "raise", "valueerror", "mutually", "exclusive", "regression", "options", "extract", "the", "data", "vals", "from", "the", "arguments", "or", "passed", "dataframe", "self", "establish_variables", "data", "x", "x", "y", "y", "units", "units", "x_partial", "x_partial", "y_partial", "y_partial", "drop", "null", "observations", "if", "dropna", "self", "dropna", "x", "y", "units", "x_partial", "y_partial", "regress", "nuisance", "variables", "out", "of", "the", "data", "if", "self", "x_partial", "is", "not", "none", "self", "x", "self", "regress_out", "self", "x", "self", "x_partial", "if", "self", "y_partial", "is", "not", "none", "self", "y", "self", "regress_out", "self", "y", "self", "y_partial", "possibly", "bin", "the", "predictor", "variable", "which", "implies", "a", "point", "estimate", "if", "x_bins", "is", "not", "none", "self", "x_estimator", "np", "mean", "if", "x_estimator", "is", "none", "else", "x_estimator", "x_discrete", "x_bins", "self", "bin_predictor", "x_bins", "self", "x_discrete", "x_discrete", "else", "self", "x_discrete", "self", "x", "disable", "regression", "in", "case", "of", "singleton", "inputs", "if", "len", "self", "x", "1", "self", "fit_reg", "false", "save", "the", "range", "of", "the", "x", "variable", "for", "the", "grid", "later", "if", "self", "fit_reg", "self", "x_range", "self", "x", "min", "self", "x", "max"], "doc_len": 278}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.scatter_data", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "scatter_data", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def scatter_data(self):\n        \"\"\"Data where each observation is a point.\"\"\"\n        x_j = self.x_jitter\n        if x_j is None:\n            x = self.x\n        else:\n            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))\n\n        y_j = self.y_jitter\n        if y_j is None:\n            y = self.y\n        else:\n            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))\n\n        return x, y\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "scatter_data", "self", "data", "where", "each", "observation", "is", "a", "point", "x_j", "self", "x_jitter", "if", "x_j", "is", "none", "x", "self", "x", "else", "x", "self", "x", "np", "random", "uniform", "x_j", "x_j", "len", "self", "x", "y_j", "self", "y_jitter", "if", "y_j", "is", "none", "y", "self", "y", "else", "y", "self", "y", "np", "random", "uniform", "y_j", "y_j", "len", "self", "y", "return", "x", "y"], "doc_len": 61}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.estimate_data", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "estimate_data", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def estimate_data(self):\n        \"\"\"Data with a point estimate and CI for each discrete x value.\"\"\"\n        x, y = self.x_discrete, self.y\n        vals = sorted(np.unique(x))\n        points, cis = [], []\n\n        for val in vals:\n\n            # Get the point estimate of the y variable\n            _y = y[x == val]\n            est = self.x_estimator(_y)\n            points.append(est)\n\n            # Compute the confidence interval for this estimate\n            if self.x_ci is None:\n                cis.append(None)\n            else:\n                units = None\n                if self.x_ci == \"sd\":\n                    sd = np.std(_y)\n                    _ci = est - sd, est + sd\n                else:\n                    if self.units is not None:\n                        units = self.units[x == val]\n                    boots = algo.bootstrap(_y,\n                                           func=self.x_estimator,\n                                           n_boot=self.n_boot,\n                                           units=units,\n                                           seed=self.seed)\n                    _ci = utils.ci(boots, self.x_ci)\n                cis.append(_ci)\n\n        return vals, points, cis\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "estimate_data", "self", "data", "with", "a", "point", "estimate", "and", "ci", "for", "each", "discrete", "x", "value", "x", "y", "self", "x_discrete", "self", "y", "vals", "sorted", "np", "unique", "x", "points", "cis", "for", "val", "in", "vals", "get", "the", "point", "estimate", "of", "the", "y", "variable", "_y", "y", "x", "val", "est", "self", "x_estimator", "_y", "points", "append", "est", "compute", "the", "confidence", "interval", "for", "this", "estimate", "if", "self", "x_ci", "is", "none", "cis", "append", "none", "else", "units", "none", "if", "self", "x_ci", "sd", "sd", "np", "std", "_y", "_ci", "est", "sd", "est", "sd", "else", "if", "self", "units", "is", "not", "none", "units", "self", "units", "x", "val", "boots", "algo", "bootstrap", "_y", "func", "self", "x_estimator", "n_boot", "self", "n_boot", "units", "units", "seed", "self", "seed", "_ci", "utils", "ci", "boots", "self", "x_ci", "cis", "append", "_ci", "return", "vals", "points", "cis"], "doc_len": 126}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_regression", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_regression", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_regression(self, ax=None, x_range=None, grid=None):\n        \"\"\"Fit the regression model.\"\"\"\n        # Create the grid for the regression\n        if grid is None:\n            if self.truncate:\n                x_min, x_max = self.x_range\n            else:\n                if ax is None:\n                    x_min, x_max = x_range\n                else:\n                    x_min, x_max = ax.get_xlim()\n            grid = np.linspace(x_min, x_max, 100)\n        ci = self.ci\n\n        # Fit the regression\n        if self.order > 1:\n            yhat, yhat_boots = self.fit_poly(grid, self.order)\n        elif self.logistic:\n            from statsmodels.genmod.generalized_linear_model import GLM\n            from statsmodels.genmod.families import Binomial\n            yhat, yhat_boots = self.fit_statsmodels(grid, GLM,\n                                                    family=Binomial())\n        elif self.lowess:\n            ci = None\n            grid, yhat = self.fit_lowess()\n        elif self.robust:\n            from statsmodels.robust.robust_linear_model import RLM\n            yhat, yhat_boots = self.fit_statsmodels(grid, RLM)\n        elif self.logx:\n            yhat, yhat_boots = self.fit_logx(grid)\n        else:\n            yhat, yhat_boots = self.fit_fast(grid)\n\n        # Compute the confidence interval at each grid point\n        if ci is None:\n            err_bands = None\n        else:\n            err_bands = utils.ci(yhat_boots, ci, axis=0)\n\n        return grid, yhat, err_bands\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_regression", "self", "ax", "none", "x_range", "none", "grid", "none", "fit", "the", "regression", "model", "create", "the", "grid", "for", "the", "regression", "if", "grid", "is", "none", "if", "self", "truncate", "x_min", "x_max", "self", "x_range", "else", "if", "ax", "is", "none", "x_min", "x_max", "x_range", "else", "x_min", "x_max", "ax", "get_xlim", "grid", "np", "linspace", "x_min", "x_max", "100", "ci", "self", "ci", "fit", "the", "regression", "if", "self", "order", "1", "yhat", "yhat_boots", "self", "fit_poly", "grid", "self", "order", "elif", "self", "logistic", "from", "statsmodels", "genmod", "generalized_linear_model", "import", "glm", "from", "statsmodels", "genmod", "families", "import", "binomial", "yhat", "yhat_boots", "self", "fit_statsmodels", "grid", "glm", "family", "binomial", "elif", "self", "lowess", "ci", "none", "grid", "yhat", "self", "fit_lowess", "elif", "self", "robust", "from", "statsmodels", "robust", "robust_linear_model", "import", "rlm", "yhat", "yhat_boots", "self", "fit_statsmodels", "grid", "rlm", "elif", "self", "logx", "yhat", "yhat_boots", "self", "fit_logx", "grid", "else", "yhat", "yhat_boots", "self", "fit_fast", "grid", "compute", "the", "confidence", "interval", "at", "each", "grid", "point", "if", "ci", "is", "none", "err_bands", "none", "else", "err_bands", "utils", "ci", "yhat_boots", "ci", "axis", "0", "return", "grid", "yhat", "err_bands"], "doc_len": 157}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_fast", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_fast", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_fast(self, grid):\n        \"\"\"Low-level regression and prediction using linear algebra.\"\"\"\n        def reg_func(_x, _y):\n            return np.linalg.pinv(_x).dot(_y)\n\n        X, y = np.c_[np.ones(len(self.x)), self.x], self.y\n        grid = np.c_[np.ones(len(grid)), grid]\n        yhat = grid.dot(reg_func(X, y))\n        if self.ci is None:\n            return yhat, None\n\n        beta_boots = algo.bootstrap(X, y,\n                                    func=reg_func,\n                                    n_boot=self.n_boot,\n                                    units=self.units,\n                                    seed=self.seed).T\n        yhat_boots = grid.dot(beta_boots).T\n        return yhat, yhat_boots\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_fast", "self", "grid", "low", "level", "regression", "and", "prediction", "using", "linear", "algebra", "def", "reg_func", "_x", "_y", "return", "np", "linalg", "pinv", "_x", "dot", "_y", "x", "y", "np", "c_", "np", "ones", "len", "self", "x", "self", "x", "self", "y", "grid", "np", "c_", "np", "ones", "len", "grid", "grid", "yhat", "grid", "dot", "reg_func", "x", "y", "if", "self", "ci", "is", "none", "return", "yhat", "none", "beta_boots", "algo", "bootstrap", "x", "y", "func", "reg_func", "n_boot", "self", "n_boot", "units", "self", "units", "seed", "self", "seed", "t", "yhat_boots", "grid", "dot", "beta_boots", "t", "return", "yhat", "yhat_boots"], "doc_len": 87}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_poly", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_poly", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_poly(self, grid, order):\n        \"\"\"Regression using numpy polyfit for higher-order trends.\"\"\"\n        def reg_func(_x, _y):\n            return np.polyval(np.polyfit(_x, _y, order), grid)\n\n        x, y = self.x, self.y\n        yhat = reg_func(x, y)\n        if self.ci is None:\n            return yhat, None\n\n        yhat_boots = algo.bootstrap(x, y,\n                                    func=reg_func,\n                                    n_boot=self.n_boot,\n                                    units=self.units,\n                                    seed=self.seed)\n        return yhat, yhat_boots\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_poly", "self", "grid", "order", "regression", "using", "numpy", "polyfit", "for", "higher", "order", "trends", "def", "reg_func", "_x", "_y", "return", "np", "polyval", "np", "polyfit", "_x", "_y", "order", "grid", "x", "y", "self", "x", "self", "y", "yhat", "reg_func", "x", "y", "if", "self", "ci", "is", "none", "return", "yhat", "none", "yhat_boots", "algo", "bootstrap", "x", "y", "func", "reg_func", "n_boot", "self", "n_boot", "units", "self", "units", "seed", "self", "seed", "return", "yhat", "yhat_boots"], "doc_len": 67}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_statsmodels", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_statsmodels", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_statsmodels(self, grid, model, **kwargs):\n        \"\"\"More general regression function using statsmodels objects.\"\"\"\n        import statsmodels.genmod.generalized_linear_model as glm\n        X, y = np.c_[np.ones(len(self.x)), self.x], self.y\n        grid = np.c_[np.ones(len(grid)), grid]\n\n        def reg_func(_x, _y):\n            try:\n                yhat = model(_y, _x, **kwargs).fit().predict(grid)\n            except glm.PerfectSeparationError:\n                yhat = np.empty(len(grid))\n                yhat.fill(np.nan)\n            return yhat\n\n        yhat = reg_func(X, y)\n        if self.ci is None:\n            return yhat, None\n\n        yhat_boots = algo.bootstrap(X, y,\n                                    func=reg_func,\n                                    n_boot=self.n_boot,\n                                    units=self.units,\n                                    seed=self.seed)\n        return yhat, yhat_boots\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_statsmodels", "self", "grid", "model", "kwargs", "more", "general", "regression", "function", "using", "statsmodels", "objects", "import", "statsmodels", "genmod", "generalized_linear_model", "as", "glm", "x", "y", "np", "c_", "np", "ones", "len", "self", "x", "self", "x", "self", "y", "grid", "np", "c_", "np", "ones", "len", "grid", "grid", "def", "reg_func", "_x", "_y", "try", "yhat", "model", "_y", "_x", "kwargs", "fit", "predict", "grid", "except", "glm", "perfectseparationerror", "yhat", "np", "empty", "len", "grid", "yhat", "fill", "np", "nan", "return", "yhat", "yhat", "reg_func", "x", "y", "if", "self", "ci", "is", "none", "return", "yhat", "none", "yhat_boots", "algo", "bootstrap", "x", "y", "func", "reg_func", "n_boot", "self", "n_boot", "units", "self", "units", "seed", "self", "seed", "return", "yhat", "yhat_boots"], "doc_len": 102}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_lowess", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_lowess", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_lowess(self):\n        \"\"\"Fit a locally-weighted regression, which returns its own grid.\"\"\"\n        from statsmodels.nonparametric.smoothers_lowess import lowess\n        grid, yhat = lowess(self.y, self.x).T\n        return grid, yhat\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_lowess", "self", "fit", "a", "locally", "weighted", "regression", "which", "returns", "its", "own", "grid", "from", "statsmodels", "nonparametric", "smoothers_lowess", "import", "lowess", "grid", "yhat", "lowess", "self", "y", "self", "x", "t", "return", "grid", "yhat"], "doc_len": 34}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.fit_logx", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "fit_logx", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def fit_logx(self, grid):\n        \"\"\"Fit the model in log-space.\"\"\"\n        X, y = np.c_[np.ones(len(self.x)), self.x], self.y\n        grid = np.c_[np.ones(len(grid)), np.log(grid)]\n\n        def reg_func(_x, _y):\n            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]\n            return np.linalg.pinv(_x).dot(_y)\n\n        yhat = grid.dot(reg_func(X, y))\n        if self.ci is None:\n            return yhat, None\n\n        beta_boots = algo.bootstrap(X, y,\n                                    func=reg_func,\n                                    n_boot=self.n_boot,\n                                    units=self.units,\n                                    seed=self.seed).T\n        yhat_boots = grid.dot(beta_boots).T\n        return yhat, yhat_boots\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "fit_logx", "self", "grid", "fit", "the", "model", "in", "log", "space", "x", "y", "np", "c_", "np", "ones", "len", "self", "x", "self", "x", "self", "y", "grid", "np", "c_", "np", "ones", "len", "grid", "np", "log", "grid", "def", "reg_func", "_x", "_y", "_x", "np", "c_", "_x", "0", "np", "log", "_x", "1", "return", "np", "linalg", "pinv", "_x", "dot", "_y", "yhat", "grid", "dot", "reg_func", "x", "y", "if", "self", "ci", "is", "none", "return", "yhat", "none", "beta_boots", "algo", "bootstrap", "x", "y", "func", "reg_func", "n_boot", "self", "n_boot", "units", "self", "units", "seed", "self", "seed", "t", "yhat_boots", "grid", "dot", "beta_boots", "t", "return", "yhat", "yhat_boots"], "doc_len": 96}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.bin_predictor", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "bin_predictor", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def bin_predictor(self, bins):\n        \"\"\"Discretize a predictor by assigning value to closest bin.\"\"\"\n        x = np.asarray(self.x)\n        if np.isscalar(bins):\n            percentiles = np.linspace(0, 100, bins + 2)[1:-1]\n            bins = np.percentile(x, percentiles)\n        else:\n            bins = np.ravel(bins)\n\n        dist = np.abs(np.subtract.outer(x, bins))\n        x_binned = bins[np.argmin(dist, axis=1)].ravel()\n\n        return x_binned, bins\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "bin_predictor", "self", "bins", "discretize", "a", "predictor", "by", "assigning", "value", "to", "closest", "bin", "x", "np", "asarray", "self", "x", "if", "np", "isscalar", "bins", "percentiles", "np", "linspace", "0", "100", "bins", "2", "1", "1", "bins", "np", "percentile", "x", "percentiles", "else", "bins", "np", "ravel", "bins", "dist", "np", "abs", "np", "subtract", "outer", "x", "bins", "x_binned", "bins", "np", "argmin", "dist", "axis", "1", "ravel", "return", "x_binned", "bins"], "doc_len": 64}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.regress_out", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "regress_out", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def regress_out(self, a, b):\n        \"\"\"Regress b from a keeping a's original mean.\"\"\"\n        a_mean = a.mean()\n        a = a - a_mean\n        b = b - b.mean()\n        b = np.c_[b]\n        a_prime = a - b.dot(np.linalg.pinv(b).dot(a))\n        return np.asarray(a_prime + a_mean).reshape(a.shape)\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "regress_out", "self", "a", "b", "regress", "b", "from", "a", "keeping", "a", "s", "original", "mean", "a_mean", "a", "mean", "a", "a", "a_mean", "b", "b", "b", "mean", "b", "np", "c_", "b", "a_prime", "a", "b", "dot", "np", "linalg", "pinv", "b", "dot", "a", "return", "np", "asarray", "a_prime", "a_mean", "reshape", "a", "shape"], "doc_len": 50}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.plot", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "plot", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def plot(self, ax, scatter_kws, line_kws):\n        \"\"\"Draw the full plot.\"\"\"\n        # Insert the plot label into the correct set of keyword arguments\n        if self.scatter:\n            scatter_kws[\"label\"] = self.label\n        else:\n            line_kws[\"label\"] = self.label\n\n        # Use the current color cycle state as a default\n        if self.color is None:\n            lines, = ax.plot([], [])\n            color = lines.get_color()\n            lines.remove()\n        else:\n            color = self.color\n\n        # Ensure that color is hex to avoid matplotlib weirdness\n        color = mpl.colors.rgb2hex(mpl.colors.colorConverter.to_rgb(color))\n\n        # Let color in keyword arguments override overall plot color\n        scatter_kws.setdefault(\"color\", color)\n        line_kws.setdefault(\"color\", color)\n\n        # Draw the constituent plots\n        if self.scatter:\n            self.scatterplot(ax, scatter_kws)\n\n        if self.fit_reg:\n            self.lineplot(ax, line_kws)\n\n        # Label the axes\n        if hasattr(self.x, \"name\"):\n            ax.set_xlabel(self.x.name)\n        if hasattr(self.y, \"name\"):\n            ax.set_ylabel(self.y.name)\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "plot", "self", "ax", "scatter_kws", "line_kws", "draw", "the", "full", "plot", "insert", "the", "plot", "label", "into", "the", "correct", "set", "of", "keyword", "arguments", "if", "self", "scatter", "scatter_kws", "label", "self", "label", "else", "line_kws", "label", "self", "label", "use", "the", "current", "color", "cycle", "state", "as", "a", "default", "if", "self", "color", "is", "none", "lines", "ax", "plot", "color", "lines", "get_color", "lines", "remove", "else", "color", "self", "color", "ensure", "that", "color", "is", "hex", "to", "avoid", "matplotlib", "weirdness", "color", "mpl", "colors", "rgb2hex", "mpl", "colors", "colorconverter", "to_rgb", "color", "let", "color", "in", "keyword", "arguments", "override", "overall", "plot", "color", "scatter_kws", "setdefault", "color", "color", "line_kws", "setdefault", "color", "color", "draw", "the", "constituent", "plots", "if", "self", "scatter", "self", "scatterplot", "ax", "scatter_kws", "if", "self", "fit_reg", "self", "lineplot", "ax", "line_kws", "label", "the", "axes", "if", "hasattr", "self", "x", "name", "ax", "set_xlabel", "self", "x", "name", "if", "hasattr", "self", "y", "name", "ax", "set_ylabel", "self", "y", "name"], "doc_len": 139}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.scatterplot", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "scatterplot", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def scatterplot(self, ax, kws):\n        \"\"\"Draw the data.\"\"\"\n        # Treat the line-based markers specially, explicitly setting larger\n        # linewidth than is provided by the seaborn style defaults.\n        # This would ideally be handled better in matplotlib (i.e., distinguish\n        # between edgewidth for solid glyphs and linewidth for line glyphs\n        # but this should do for now.\n        line_markers = [\"1\", \"2\", \"3\", \"4\", \"+\", \"x\", \"|\", \"_\"]\n        if self.x_estimator is None:\n            if \"marker\" in kws and kws[\"marker\"] in line_markers:\n                lw = mpl.rcParams[\"lines.linewidth\"]\n            else:\n                lw = mpl.rcParams[\"lines.markeredgewidth\"]\n            kws.setdefault(\"linewidths\", lw)\n\n            if not hasattr(kws['color'], 'shape') or kws['color'].shape[1] < 4:\n                kws.setdefault(\"alpha\", .8)\n\n            x, y = self.scatter_data\n            ax.scatter(x, y, **kws)\n        else:\n            # TODO abstraction\n            ci_kws = {\"color\": kws[\"color\"]}\n            if \"alpha\" in kws:\n                ci_kws[\"alpha\"] = kws[\"alpha\"]\n            ci_kws[\"linewidth\"] = mpl.rcParams[\"lines.linewidth\"] * 1.75\n            kws.setdefault(\"s\", 50)\n\n            xs, ys, cis = self.estimate_data\n            if [ci for ci in cis if ci is not None]:\n                for x, ci in zip(xs, cis):\n                    ax.plot([x, x], ci, **ci_kws)\n            ax.scatter(xs, ys, **kws)\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "scatterplot", "self", "ax", "kws", "draw", "the", "data", "treat", "the", "line", "based", "markers", "specially", "explicitly", "setting", "larger", "linewidth", "than", "is", "provided", "by", "the", "seaborn", "style", "defaults", "this", "would", "ideally", "be", "handled", "better", "in", "matplotlib", "i", "e", "distinguish", "between", "edgewidth", "for", "solid", "glyphs", "and", "linewidth", "for", "line", "glyphs", "but", "this", "should", "do", "for", "now", "line_markers", "1", "2", "3", "4", "x", "_", "if", "self", "x_estimator", "is", "none", "if", "marker", "in", "kws", "and", "kws", "marker", "in", "line_markers", "lw", "mpl", "rcparams", "lines", "linewidth", "else", "lw", "mpl", "rcparams", "lines", "markeredgewidth", "kws", "setdefault", "linewidths", "lw", "if", "not", "hasattr", "kws", "color", "shape", "or", "kws", "color", "shape", "1", "4", "kws", "setdefault", "alpha", "8", "x", "y", "self", "scatter_data", "ax", "scatter", "x", "y", "kws", "else", "todo", "abstraction", "ci_kws", "color", "kws", "color", "if", "alpha", "in", "kws", "ci_kws", "alpha", "kws", "alpha", "ci_kws", "linewidth", "mpl", "rcparams", "lines", "linewidth", "1", "75", "kws", "setdefault", "s", "50", "xs", "ys", "cis", "self", "estimate_data", "if", "ci", "for", "ci", "in", "cis", "if", "ci", "is", "not", "none", "for", "x", "ci", "in", "zip", "xs", "cis", "ax", "plot", "x", "x", "ci", "ci_kws", "ax", "scatter", "xs", "ys", "kws"], "doc_len": 179}
{"doc_id": "seaborn/regression.py::_RegressionPlotter.lineplot", "file_path": "seaborn/regression.py", "class_name": "_RegressionPlotter", "func_name": "lineplot", "text": "文件路径: seaborn/regression.py, 类名: _RegressionPlotter\n    def lineplot(self, ax, kws):\n        \"\"\"Draw the model.\"\"\"\n        # Fit the regression model\n        grid, yhat, err_bands = self.fit_regression(ax)\n        edges = grid[0], grid[-1]\n\n        # Get set default aesthetics\n        fill_color = kws[\"color\"]\n        lw = kws.pop(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.5)\n        kws.setdefault(\"linewidth\", lw)\n\n        # Draw the regression line and confidence interval\n        line, = ax.plot(grid, yhat, **kws)\n        if not self.truncate:\n            line.sticky_edges.x[:] = edges  # Prevent mpl from adding margin\n        if err_bands is not None:\n            ax.fill_between(grid, *err_bands, facecolor=fill_color, alpha=.15)\n", "tokens": ["seaborn", "regression", "py", "_regressionplotter", "def", "lineplot", "self", "ax", "kws", "draw", "the", "model", "fit", "the", "regression", "model", "grid", "yhat", "err_bands", "self", "fit_regression", "ax", "edges", "grid", "0", "grid", "1", "get", "set", "default", "aesthetics", "fill_color", "kws", "color", "lw", "kws", "pop", "lw", "mpl", "rcparams", "lines", "linewidth", "1", "5", "kws", "setdefault", "linewidth", "lw", "draw", "the", "regression", "line", "and", "confidence", "interval", "line", "ax", "plot", "grid", "yhat", "kws", "if", "not", "self", "truncate", "line", "sticky_edges", "x", "edges", "prevent", "mpl", "from", "adding", "margin", "if", "err_bands", "is", "not", "none", "ax", "fill_between", "grid", "err_bands", "facecolor", "fill_color", "alpha", "15"], "doc_len": 87}
{"doc_id": "seaborn/regression.py::lmplot", "file_path": "seaborn/regression.py", "class_name": null, "func_name": "lmplot", "text": "文件路径: seaborn/regression.py\ndef lmplot(\n    data=None, *,\n    x=None, y=None, hue=None, col=None, row=None,\n    palette=None, col_wrap=None, height=5, aspect=1, markers=\"o\",\n    sharex=None, sharey=None, hue_order=None, col_order=None, row_order=None,\n    legend=True, legend_out=None, x_estimator=None, x_bins=None,\n    x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,\n    units=None, seed=None, order=1, logistic=False, lowess=False,\n    robust=False, logx=False, x_partial=None, y_partial=None,\n    truncate=True, x_jitter=None, y_jitter=None, scatter_kws=None,\n    line_kws=None, facet_kws=None,\n):\n\n    if facet_kws is None:\n        facet_kws = {}\n\n    def facet_kw_deprecation(key, val):\n        msg = (\n            f\"{key} is deprecated from the `lmplot` function signature. \"\n            \"Please update your code to pass it using `facet_kws`.\"\n        )\n        if val is not None:\n            warnings.warn(msg, UserWarning)\n            facet_kws[key] = val\n\n    facet_kw_deprecation(\"sharex\", sharex)\n    facet_kw_deprecation(\"sharey\", sharey)\n    facet_kw_deprecation(\"legend_out\", legend_out)\n\n    if data is None:\n        raise TypeError(\"Missing required keyword argument `data`.\")\n\n    # Reduce the dataframe to only needed columns\n    need_cols = [x, y, hue, col, row, units, x_partial, y_partial]\n    cols = np.unique([a for a in need_cols if a is not None]).tolist()\n    data = data[cols]\n\n    # Initialize the grid\n    facets = FacetGrid(\n        data, row=row, col=col, hue=hue,\n        palette=palette,\n        row_order=row_order, col_order=col_order, hue_order=hue_order,\n        height=height, aspect=aspect, col_wrap=col_wrap,\n        **facet_kws,\n    )\n\n    # Add the markers here as FacetGrid has figured out how many levels of the\n    # hue variable are needed and we don't want to duplicate that process\n    if facets.hue_names is None:\n        n_markers = 1\n    else:\n        n_markers = len(facets.hue_names)\n    if not isinstance(markers, list):\n        markers = [markers] * n_markers\n    if len(markers) != n_markers:\n        raise ValueError(\"markers must be a singleton or a list of markers \"\n                         \"for each level of the hue variable\")\n    facets.hue_kws = {\"marker\": markers}\n\n    def update_datalim(data, x, y, ax, **kws):\n        xys = data[[x, y]].to_numpy().astype(float)\n        ax.update_datalim(xys, updatey=False)\n        ax.autoscale_view(scaley=False)\n\n    facets.map_dataframe(update_datalim, x=x, y=y)\n\n    # Draw the regression plot on each facet\n    regplot_kws = dict(\n        x_estimator=x_estimator, x_bins=x_bins, x_ci=x_ci,\n        scatter=scatter, fit_reg=fit_reg, ci=ci, n_boot=n_boot, units=units,\n        seed=seed, order=order, logistic=logistic, lowess=lowess,\n        robust=robust, logx=logx, x_partial=x_partial, y_partial=y_partial,\n        truncate=truncate, x_jitter=x_jitter, y_jitter=y_jitter,\n        scatter_kws=scatter_kws, line_kws=line_kws,\n    )\n    facets.map_dataframe(regplot, x=x, y=y, **regplot_kws)\n    facets.set_axis_labels(x, y)\n\n    # Add a legend\n    if legend and (hue is not None) and (hue not in [col, row]):\n        facets.add_legend()\n    return facets\n", "tokens": ["seaborn", "regression", "py", "def", "lmplot", "data", "none", "x", "none", "y", "none", "hue", "none", "col", "none", "row", "none", "palette", "none", "col_wrap", "none", "height", "5", "aspect", "1", "markers", "o", "sharex", "none", "sharey", "none", "hue_order", "none", "col_order", "none", "row_order", "none", "legend", "true", "legend_out", "none", "x_estimator", "none", "x_bins", "none", "x_ci", "ci", "scatter", "true", "fit_reg", "true", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "order", "1", "logistic", "false", "lowess", "false", "robust", "false", "logx", "false", "x_partial", "none", "y_partial", "none", "truncate", "true", "x_jitter", "none", "y_jitter", "none", "scatter_kws", "none", "line_kws", "none", "facet_kws", "none", "if", "facet_kws", "is", "none", "facet_kws", "def", "facet_kw_deprecation", "key", "val", "msg", "f", "key", "is", "deprecated", "from", "the", "lmplot", "function", "signature", "please", "update", "your", "code", "to", "pass", "it", "using", "facet_kws", "if", "val", "is", "not", "none", "warnings", "warn", "msg", "userwarning", "facet_kws", "key", "val", "facet_kw_deprecation", "sharex", "sharex", "facet_kw_deprecation", "sharey", "sharey", "facet_kw_deprecation", "legend_out", "legend_out", "if", "data", "is", "none", "raise", "typeerror", "missing", "required", "keyword", "argument", "data", "reduce", "the", "dataframe", "to", "only", "needed", "columns", "need_cols", "x", "y", "hue", "col", "row", "units", "x_partial", "y_partial", "cols", "np", "unique", "a", "for", "a", "in", "need_cols", "if", "a", "is", "not", "none", "tolist", "data", "data", "cols", "initialize", "the", "grid", "facets", "facetgrid", "data", "row", "row", "col", "col", "hue", "hue", "palette", "palette", "row_order", "row_order", "col_order", "col_order", "hue_order", "hue_order", "height", "height", "aspect", "aspect", "col_wrap", "col_wrap", "facet_kws", "add", "the", "markers", "here", "as", "facetgrid", "has", "figured", "out", "how", "many", "levels", "of", "the", "hue", "variable", "are", "needed", "and", "we", "don", "t", "want", "to", "duplicate", "that", "process", "if", "facets", "hue_names", "is", "none", "n_markers", "1", "else", "n_markers", "len", "facets", "hue_names", "if", "not", "isinstance", "markers", "list", "markers", "markers", "n_markers", "if", "len", "markers", "n_markers", "raise", "valueerror", "markers", "must", "be", "a", "singleton", "or", "a", "list", "of", "markers", "for", "each", "level", "of", "the", "hue", "variable", "facets", "hue_kws", "marker", "markers", "def", "update_datalim", "data", "x", "y", "ax", "kws", "xys", "data", "x", "y", "to_numpy", "astype", "float", "ax", "update_datalim", "xys", "updatey", "false", "ax", "autoscale_view", "scaley", "false", "facets", "map_dataframe", "update_datalim", "x", "x", "y", "y", "draw", "the", "regression", "plot", "on", "each", "facet", "regplot_kws", "dict", "x_estimator", "x_estimator", "x_bins", "x_bins", "x_ci", "x_ci", "scatter", "scatter", "fit_reg", "fit_reg", "ci", "ci", "n_boot", "n_boot", "units", "units", "seed", "seed", "order", "order", "logistic", "logistic", "lowess", "lowess", "robust", "robust", "logx", "logx", "x_partial", "x_partial", "y_partial", "y_partial", "truncate", "truncate", "x_jitter", "x_jitter", "y_jitter", "y_jitter", "scatter_kws", "scatter_kws", "line_kws", "line_kws", "facets", "map_dataframe", "regplot", "x", "x", "y", "y", "regplot_kws", "facets", "set_axis_labels", "x", "y", "add", "a", "legend", "if", "legend", "and", "hue", "is", "not", "none", "and", "hue", "not", "in", "col", "row", "facets", "add_legend", "return", "facets"], "doc_len": 392}
{"doc_id": "seaborn/regression.py::regplot", "file_path": "seaborn/regression.py", "class_name": null, "func_name": "regplot", "text": "文件路径: seaborn/regression.py\ndef regplot(\n    data=None, *, x=None, y=None,\n    x_estimator=None, x_bins=None, x_ci=\"ci\",\n    scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,\n    seed=None, order=1, logistic=False, lowess=False, robust=False,\n    logx=False, x_partial=None, y_partial=None,\n    truncate=True, dropna=True, x_jitter=None, y_jitter=None,\n    label=None, color=None, marker=\"o\",\n    scatter_kws=None, line_kws=None, ax=None\n):\n\n    plotter = _RegressionPlotter(x, y, data, x_estimator, x_bins, x_ci,\n                                 scatter, fit_reg, ci, n_boot, units, seed,\n                                 order, logistic, lowess, robust, logx,\n                                 x_partial, y_partial, truncate, dropna,\n                                 x_jitter, y_jitter, color, label)\n\n    if ax is None:\n        ax = plt.gca()\n\n    scatter_kws = {} if scatter_kws is None else copy.copy(scatter_kws)\n    scatter_kws[\"marker\"] = marker\n    line_kws = {} if line_kws is None else copy.copy(line_kws)\n    plotter.plot(ax, scatter_kws, line_kws)\n    return ax\n", "tokens": ["seaborn", "regression", "py", "def", "regplot", "data", "none", "x", "none", "y", "none", "x_estimator", "none", "x_bins", "none", "x_ci", "ci", "scatter", "true", "fit_reg", "true", "ci", "95", "n_boot", "1000", "units", "none", "seed", "none", "order", "1", "logistic", "false", "lowess", "false", "robust", "false", "logx", "false", "x_partial", "none", "y_partial", "none", "truncate", "true", "dropna", "true", "x_jitter", "none", "y_jitter", "none", "label", "none", "color", "none", "marker", "o", "scatter_kws", "none", "line_kws", "none", "ax", "none", "plotter", "_regressionplotter", "x", "y", "data", "x_estimator", "x_bins", "x_ci", "scatter", "fit_reg", "ci", "n_boot", "units", "seed", "order", "logistic", "lowess", "robust", "logx", "x_partial", "y_partial", "truncate", "dropna", "x_jitter", "y_jitter", "color", "label", "if", "ax", "is", "none", "ax", "plt", "gca", "scatter_kws", "if", "scatter_kws", "is", "none", "else", "copy", "copy", "scatter_kws", "scatter_kws", "marker", "marker", "line_kws", "if", "line_kws", "is", "none", "else", "copy", "copy", "line_kws", "plotter", "plot", "ax", "scatter_kws", "line_kws", "return", "ax"], "doc_len": 125}
{"doc_id": "seaborn/regression.py::residplot", "file_path": "seaborn/regression.py", "class_name": null, "func_name": "residplot", "text": "文件路径: seaborn/regression.py\ndef residplot(\n    data=None, *, x=None, y=None,\n    x_partial=None, y_partial=None, lowess=False,\n    order=1, robust=False, dropna=True, label=None, color=None,\n    scatter_kws=None, line_kws=None, ax=None\n):\n    \"\"\"Plot the residuals of a linear regression.\n\n    This function will regress y on x (possibly as a robust or polynomial\n    regression) and then draw a scatterplot of the residuals. You can\n    optionally fit a lowess smoother to the residual plot, which can\n    help in determining if there is structure to the residuals.\n\n    Parameters\n    ----------\n    data : DataFrame, optional\n        DataFrame to use if `x` and `y` are column names.\n    x : vector or string\n        Data or column name in `data` for the predictor variable.\n    y : vector or string\n        Data or column name in `data` for the response variable.\n    {x, y}_partial : vectors or string(s) , optional\n        These variables are treated as confounding and are removed from\n        the `x` or `y` variables before plotting.\n    lowess : boolean, optional\n        Fit a lowess smoother to the residual scatterplot.\n    order : int, optional\n        Order of the polynomial to fit when calculating the residuals.\n    robust : boolean, optional\n        Fit a robust linear regression when calculating the residuals.\n    dropna : boolean, optional\n        If True, ignore observations with missing data when fitting and\n        plotting.\n    label : string, optional\n        Label that will be used in any plot legends.\n    color : matplotlib color, optional\n        Color to use for all elements of the plot.\n    {scatter, line}_kws : dictionaries, optional\n        Additional keyword arguments passed to scatter() and plot() for drawing\n        the components of the plot.\n    ax : matplotlib axis, optional\n        Plot into this axis, otherwise grab the current axis or make a new\n        one if not existing.\n\n    Returns\n    -------\n    ax: matplotlib axes\n        Axes with the regression plot.\n\n    See Also\n    --------\n    regplot : Plot a simple linear regression model.\n    jointplot : Draw a :func:`residplot` with univariate marginal distributions\n                (when used with ``kind=\"resid\"``).\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/residplot.rst\n\n    \"\"\"\n    plotter = _RegressionPlotter(x, y, data, ci=None,\n                                 order=order, robust=robust,\n                                 x_partial=x_partial, y_partial=y_partial,\n                                 dropna=dropna, color=color, label=label)\n\n    if ax is None:\n        ax = plt.gca()\n\n    # Calculate the residual from a linear regression\n    _, yhat, _ = plotter.fit_regression(grid=plotter.x)\n    plotter.y = plotter.y - yhat\n\n    # Set the regression option on the plotter\n    if lowess:\n        plotter.lowess = True\n    else:\n        plotter.fit_reg = False\n\n    # Plot a horizontal line at 0\n    ax.axhline(0, ls=\":\", c=\".2\")\n\n    # Draw the scatterplot\n    scatter_kws = {} if scatter_kws is None else scatter_kws.copy()\n    line_kws = {} if line_kws is None else line_kws.copy()\n    plotter.plot(ax, scatter_kws, line_kws)\n    return ax\n", "tokens": ["seaborn", "regression", "py", "def", "residplot", "data", "none", "x", "none", "y", "none", "x_partial", "none", "y_partial", "none", "lowess", "false", "order", "1", "robust", "false", "dropna", "true", "label", "none", "color", "none", "scatter_kws", "none", "line_kws", "none", "ax", "none", "plot", "the", "residuals", "of", "a", "linear", "regression", "this", "function", "will", "regress", "y", "on", "x", "possibly", "as", "a", "robust", "or", "polynomial", "regression", "and", "then", "draw", "a", "scatterplot", "of", "the", "residuals", "you", "can", "optionally", "fit", "a", "lowess", "smoother", "to", "the", "residual", "plot", "which", "can", "help", "in", "determining", "if", "there", "is", "structure", "to", "the", "residuals", "parameters", "data", "dataframe", "optional", "dataframe", "to", "use", "if", "x", "and", "y", "are", "column", "names", "x", "vector", "or", "string", "data", "or", "column", "name", "in", "data", "for", "the", "predictor", "variable", "y", "vector", "or", "string", "data", "or", "column", "name", "in", "data", "for", "the", "response", "variable", "x", "y", "_partial", "vectors", "or", "string", "s", "optional", "these", "variables", "are", "treated", "as", "confounding", "and", "are", "removed", "from", "the", "x", "or", "y", "variables", "before", "plotting", "lowess", "boolean", "optional", "fit", "a", "lowess", "smoother", "to", "the", "residual", "scatterplot", "order", "int", "optional", "order", "of", "the", "polynomial", "to", "fit", "when", "calculating", "the", "residuals", "robust", "boolean", "optional", "fit", "a", "robust", "linear", "regression", "when", "calculating", "the", "residuals", "dropna", "boolean", "optional", "if", "true", "ignore", "observations", "with", "missing", "data", "when", "fitting", "and", "plotting", "label", "string", "optional", "label", "that", "will", "be", "used", "in", "any", "plot", "legends", "color", "matplotlib", "color", "optional", "color", "to", "use", "for", "all", "elements", "of", "the", "plot", "scatter", "line", "_kws", "dictionaries", "optional", "additional", "keyword", "arguments", "passed", "to", "scatter", "and", "plot", "for", "drawing", "the", "components", "of", "the", "plot", "ax", "matplotlib", "axis", "optional", "plot", "into", "this", "axis", "otherwise", "grab", "the", "current", "axis", "or", "make", "a", "new", "one", "if", "not", "existing", "returns", "ax", "matplotlib", "axes", "axes", "with", "the", "regression", "plot", "see", "also", "regplot", "plot", "a", "simple", "linear", "regression", "model", "jointplot", "draw", "a", "func", "residplot", "with", "univariate", "marginal", "distributions", "when", "used", "with", "kind", "resid", "examples", "include", "docstrings", "residplot", "rst", "plotter", "_regressionplotter", "x", "y", "data", "ci", "none", "order", "order", "robust", "robust", "x_partial", "x_partial", "y_partial", "y_partial", "dropna", "dropna", "color", "color", "label", "label", "if", "ax", "is", "none", "ax", "plt", "gca", "calculate", "the", "residual", "from", "a", "linear", "regression", "_", "yhat", "_", "plotter", "fit_regression", "grid", "plotter", "x", "plotter", "y", "plotter", "y", "yhat", "set", "the", "regression", "option", "on", "the", "plotter", "if", "lowess", "plotter", "lowess", "true", "else", "plotter", "fit_reg", "false", "plot", "a", "horizontal", "line", "at", "0", "ax", "axhline", "0", "ls", "c", "2", "draw", "the", "scatterplot", "scatter_kws", "if", "scatter_kws", "is", "none", "else", "scatter_kws", "copy", "line_kws", "if", "line_kws", "is", "none", "else", "line_kws", "copy", "plotter", "plot", "ax", "scatter_kws", "line_kws", "return", "ax"], "doc_len": 407}
{"doc_id": "seaborn/relational.py::_RelationalPlotter.add_legend_data", "file_path": "seaborn/relational.py", "class_name": "_RelationalPlotter", "func_name": "add_legend_data", "text": "文件路径: seaborn/relational.py, 类名: _RelationalPlotter\n    def add_legend_data(self, ax):\n        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"\n        verbosity = self.legend\n        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:\n            err = \"`legend` must be 'auto', 'brief', 'full', or a boolean.\"\n            raise ValueError(err)\n        elif verbosity is True:\n            verbosity = \"auto\"\n\n        legend_kwargs = {}\n        keys = []\n\n        # Assign a legend title if there is only going to be one sub-legend,\n        # otherwise, subtitles will be inserted into the texts list with an\n        # invisible handle (which is a hack)\n        titles = {\n            title for title in\n            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])\n            if title is not None\n        }\n        if len(titles) == 1:\n            legend_title = titles.pop()\n        else:\n            legend_title = \"\"\n\n        title_kws = dict(\n            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"\n        )\n\n        def update(var_name, val_name, **kws):\n\n            key = var_name, val_name\n            if key in legend_kwargs:\n                legend_kwargs[key].update(**kws)\n            else:\n                keys.append(key)\n\n                legend_kwargs[key] = dict(**kws)\n\n        # Define the maximum number of ticks to use for \"brief\" legends\n        brief_ticks = 6\n\n        # -- Add a legend for hue semantics\n        brief_hue = self._hue_map.map_type == \"numeric\" and (\n            verbosity == \"brief\"\n            or (verbosity == \"auto\" and len(self._hue_map.levels) > brief_ticks)\n        )\n        if brief_hue:\n            if isinstance(self._hue_map.norm, mpl.colors.LogNorm):\n                locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n            else:\n                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n            limits = min(self._hue_map.levels), max(self._hue_map.levels)\n            hue_levels, hue_formatted_levels = locator_to_legend_entries(\n                locator, limits, self.plot_data[\"hue\"].infer_objects().dtype\n            )\n        elif self._hue_map.levels is None:\n            hue_levels = hue_formatted_levels = []\n        else:\n            hue_levels = hue_formatted_levels = self._hue_map.levels\n\n        # Add the hue semantic subtitle\n        if not legend_title and self.variables.get(\"hue\", None) is not None:\n            update((self.variables[\"hue\"], \"title\"),\n                   self.variables[\"hue\"], **title_kws)\n\n        # Add the hue semantic labels\n        for level, formatted_level in zip(hue_levels, hue_formatted_levels):\n            if level is not None:\n                color = self._hue_map(level)\n                update(self.variables[\"hue\"], formatted_level, color=color)\n\n        # -- Add a legend for size semantics\n        brief_size = self._size_map.map_type == \"numeric\" and (\n            verbosity == \"brief\"\n            or (verbosity == \"auto\" and len(self._size_map.levels) > brief_ticks)\n        )\n        if brief_size:\n            # Define how ticks will interpolate between the min/max data values\n            if isinstance(self._size_map.norm, mpl.colors.LogNorm):\n                locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n            else:\n                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n            # Define the min/max data values\n            limits = min(self._size_map.levels), max(self._size_map.levels)\n            size_levels, size_formatted_levels = locator_to_legend_entries(\n                locator, limits, self.plot_data[\"size\"].infer_objects().dtype\n            )\n        elif self._size_map.levels is None:\n            size_levels = size_formatted_levels = []\n        else:\n            size_levels = size_formatted_levels = self._size_map.levels\n\n        # Add the size semantic subtitle\n        if not legend_title and self.variables.get(\"size\", None) is not None:\n            update((self.variables[\"size\"], \"title\"),\n                   self.variables[\"size\"], **title_kws)\n\n        # Add the size semantic labels\n        for level, formatted_level in zip(size_levels, size_formatted_levels):\n            if level is not None:\n                size = self._size_map(level)\n                update(\n                    self.variables[\"size\"],\n                    formatted_level,\n                    linewidth=size,\n                    s=size,\n                )\n\n        # -- Add a legend for style semantics\n\n        # Add the style semantic title\n        if not legend_title and self.variables.get(\"style\", None) is not None:\n            update((self.variables[\"style\"], \"title\"),\n                   self.variables[\"style\"], **title_kws)\n\n        # Add the style semantic labels\n        if self._style_map.levels is not None:\n            for level in self._style_map.levels:\n                if level is not None:\n                    attrs = self._style_map(level)\n                    update(\n                        self.variables[\"style\"],\n                        level,\n                        marker=attrs.get(\"marker\", \"\"),\n                        dashes=attrs.get(\"dashes\", \"\"),\n                    )\n\n        func = getattr(ax, self._legend_func)\n\n        legend_data = {}\n        legend_order = []\n\n        for key in keys:\n\n            _, label = key\n            kws = legend_kwargs[key]\n            kws.setdefault(\"color\", \".2\")\n            use_kws = {}\n            for attr in self._legend_attributes + [\"visible\"]:\n                if attr in kws:\n                    use_kws[attr] = kws[attr]\n            artist = func([], [], label=label, **use_kws)\n            if self._legend_func == \"plot\":\n                artist = artist[0]\n            legend_data[key] = artist\n            legend_order.append(key)\n\n        self.legend_title = legend_title\n        self.legend_data = legend_data\n        self.legend_order = legend_order\n", "tokens": ["seaborn", "relational", "py", "_relationalplotter", "def", "add_legend_data", "self", "ax", "add", "labeled", "artists", "to", "represent", "the", "different", "plot", "semantics", "verbosity", "self", "legend", "if", "isinstance", "verbosity", "str", "and", "verbosity", "not", "in", "auto", "brief", "full", "err", "legend", "must", "be", "auto", "brief", "full", "or", "a", "boolean", "raise", "valueerror", "err", "elif", "verbosity", "is", "true", "verbosity", "auto", "legend_kwargs", "keys", "assign", "a", "legend", "title", "if", "there", "is", "only", "going", "to", "be", "one", "sub", "legend", "otherwise", "subtitles", "will", "be", "inserted", "into", "the", "texts", "list", "with", "an", "invisible", "handle", "which", "is", "a", "hack", "titles", "title", "for", "title", "in", "self", "variables", "get", "v", "none", "for", "v", "in", "hue", "size", "style", "if", "title", "is", "not", "none", "if", "len", "titles", "1", "legend_title", "titles", "pop", "else", "legend_title", "title_kws", "dict", "visible", "false", "color", "w", "s", "0", "linewidth", "0", "marker", "dashes", "def", "update", "var_name", "val_name", "kws", "key", "var_name", "val_name", "if", "key", "in", "legend_kwargs", "legend_kwargs", "key", "update", "kws", "else", "keys", "append", "key", "legend_kwargs", "key", "dict", "kws", "define", "the", "maximum", "number", "of", "ticks", "to", "use", "for", "brief", "legends", "brief_ticks", "6", "add", "a", "legend", "for", "hue", "semantics", "brief_hue", "self", "_hue_map", "map_type", "numeric", "and", "verbosity", "brief", "or", "verbosity", "auto", "and", "len", "self", "_hue_map", "levels", "brief_ticks", "if", "brief_hue", "if", "isinstance", "self", "_hue_map", "norm", "mpl", "colors", "lognorm", "locator", "mpl", "ticker", "loglocator", "numticks", "brief_ticks", "else", "locator", "mpl", "ticker", "maxnlocator", "nbins", "brief_ticks", "limits", "min", "self", "_hue_map", "levels", "max", "self", "_hue_map", "levels", "hue_levels", "hue_formatted_levels", "locator_to_legend_entries", "locator", "limits", "self", "plot_data", "hue", "infer_objects", "dtype", "elif", "self", "_hue_map", "levels", "is", "none", "hue_levels", "hue_formatted_levels", "else", "hue_levels", "hue_formatted_levels", "self", "_hue_map", "levels", "add", "the", "hue", "semantic", "subtitle", "if", "not", "legend_title", "and", "self", "variables", "get", "hue", "none", "is", "not", "none", "update", "self", "variables", "hue", "title", "self", "variables", "hue", "title_kws", "add", "the", "hue", "semantic", "labels", "for", "level", "formatted_level", "in", "zip", "hue_levels", "hue_formatted_levels", "if", "level", "is", "not", "none", "color", "self", "_hue_map", "level", "update", "self", "variables", "hue", "formatted_level", "color", "color", "add", "a", "legend", "for", "size", "semantics", "brief_size", "self", "_size_map", "map_type", "numeric", "and", "verbosity", "brief", "or", "verbosity", "auto", "and", "len", "self", "_size_map", "levels", "brief_ticks", "if", "brief_size", "define", "how", "ticks", "will", "interpolate", "between", "the", "min", "max", "data", "values", "if", "isinstance", "self", "_size_map", "norm", "mpl", "colors", "lognorm", "locator", "mpl", "ticker", "loglocator", "numticks", "brief_ticks", "else", "locator", "mpl", "ticker", "maxnlocator", "nbins", "brief_ticks", "define", "the", "min", "max", "data", "values", "limits", "min", "self", "_size_map", "levels", "max", "self", "_size_map", "levels", "size_levels", "size_formatted_levels", "locator_to_legend_entries", "locator", "limits", "self", "plot_data", "size", "infer_objects", "dtype", "elif", "self", "_size_map", "levels", "is", "none", "size_levels", "size_formatted_levels", "else", "size_levels", "size_formatted_levels", "self", "_size_map", "levels", "add", "the", "size", "semantic", "subtitle", "if", "not", "legend_title", "and", "self", "variables", "get", "size", "none", "is", "not", "none", "update", "self", "variables", "size", "title", "self", "variables", "size", "title_kws", "add", "the", "size", "semantic", "labels", "for", "level", "formatted_level", "in", "zip", "size_levels", "size_formatted_levels", "if", "level", "is", "not", "none", "size", "self", "_size_map", "level", "update", "self", "variables", "size", "formatted_level", "linewidth", "size", "s", "size", "add", "a", "legend", "for", "style", "semantics", "add", "the", "style", "semantic", "title", "if", "not", "legend_title", "and", "self", "variables", "get", "style", "none", "is", "not", "none", "update", "self", "variables", "style", "title", "self", "variables", "style", "title_kws", "add", "the", "style", "semantic", "labels", "if", "self", "_style_map", "levels", "is", "not", "none", "for", "level", "in", "self", "_style_map", "levels", "if", "level", "is", "not", "none", "attrs", "self", "_style_map", "level", "update", "self", "variables", "style", "level", "marker", "attrs", "get", "marker", "dashes", "attrs", "get", "dashes", "func", "getattr", "ax", "self", "_legend_func", "legend_data", "legend_order", "for", "key", "in", "keys", "_", "label", "key", "kws", "legend_kwargs", "key", "kws", "setdefault", "color", "2", "use_kws", "for", "attr", "in", "self", "_legend_attributes", "visible", "if", "attr", "in", "kws", "use_kws", "attr", "kws", "attr", "artist", "func", "label", "label", "use_kws", "if", "self", "_legend_func", "plot", "artist", "artist", "0", "legend_data", "key", "artist", "legend_order", "append", "key", "self", "legend_title", "legend_title", "self", "legend_data", "legend_data", "self", "legend_order", "legend_order"], "doc_len": 582}
{"doc_id": "seaborn/relational.py::_LinePlotter.__init__", "file_path": "seaborn/relational.py", "class_name": "_LinePlotter", "func_name": "__init__", "text": "文件路径: seaborn/relational.py, 类名: _LinePlotter\n    def __init__(\n        self, *,\n        data=None, variables={},\n        estimator=None, n_boot=None, seed=None, errorbar=None,\n        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None\n    ):\n\n        # TODO this is messy, we want the mapping to be agnostic about\n        # the kind of plot to draw, but for the time being we need to set\n        # this information so the SizeMapping can use it\n        self._default_size_range = (\n            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]\n        )\n\n        super().__init__(data=data, variables=variables)\n\n        self.estimator = estimator\n        self.errorbar = errorbar\n        self.n_boot = n_boot\n        self.seed = seed\n        self.sort = sort\n        self.orient = orient\n        self.err_style = err_style\n        self.err_kws = {} if err_kws is None else err_kws\n\n        self.legend = legend\n", "tokens": ["seaborn", "relational", "py", "_lineplotter", "def", "__init__", "self", "data", "none", "variables", "estimator", "none", "n_boot", "none", "seed", "none", "errorbar", "none", "sort", "true", "orient", "x", "err_style", "none", "err_kws", "none", "legend", "none", "todo", "this", "is", "messy", "we", "want", "the", "mapping", "to", "be", "agnostic", "about", "the", "kind", "of", "plot", "to", "draw", "but", "for", "the", "time", "being", "we", "need", "to", "set", "this", "information", "so", "the", "sizemapping", "can", "use", "it", "self", "_default_size_range", "np", "r_", "5", "2", "mpl", "rcparams", "lines", "linewidth", "super", "__init__", "data", "data", "variables", "variables", "self", "estimator", "estimator", "self", "errorbar", "errorbar", "self", "n_boot", "n_boot", "self", "seed", "seed", "self", "sort", "sort", "self", "orient", "orient", "self", "err_style", "err_style", "self", "err_kws", "if", "err_kws", "is", "none", "else", "err_kws", "self", "legend", "legend"], "doc_len": 111}
{"doc_id": "seaborn/relational.py::_LinePlotter.plot", "file_path": "seaborn/relational.py", "class_name": "_LinePlotter", "func_name": "plot", "text": "文件路径: seaborn/relational.py, 类名: _LinePlotter\n    def plot(self, ax, kws):\n        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"\n\n        # Draw a test plot, using the passed in kwargs. The goal here is to\n        # honor both (a) the current state of the plot cycler and (b) the\n        # specified kwargs on all the lines we will draw, overriding when\n        # relevant with the data semantics. Note that we won't cycle\n        # internally; in other words, if `hue` is not used, all elements will\n        # have the same color, but they will have the color that you would have\n        # gotten from the corresponding matplotlib function, and calling the\n        # function will advance the axes property cycle.\n\n        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))\n        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))\n\n        # Set default error kwargs\n        err_kws = self.err_kws.copy()\n        if self.err_style == \"band\":\n            err_kws.setdefault(\"alpha\", .2)\n        elif self.err_style == \"bars\":\n            pass\n        elif self.err_style is not None:\n            err = \"`err_style` must be 'band' or 'bars', not {}\"\n            raise ValueError(err.format(self.err_style))\n\n        # Initialize the aggregation object\n        agg = EstimateAggregator(\n            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n        )\n\n        # TODO abstract variable to aggregate over here-ish. Better name?\n        orient = self.orient\n        if orient not in {\"x\", \"y\"}:\n            err = f\"`orient` must be either 'x' or 'y', not {orient!r}.\"\n            raise ValueError(err)\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n\n        # TODO How to handle NA? We don't want NA to propagate through to the\n        # estimate/CI when some values are present, but we would also like\n        # matplotlib to show \"gaps\" in the line when all values are missing.\n        # This is straightforward absent aggregation, but complicated with it.\n        # If we want to use nas, we need to conditionalize dropna in iter_data.\n\n        # Loop over the semantic subsets and add to the plot\n        grouping_vars = \"hue\", \"size\", \"style\"\n        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):\n\n            if self.sort:\n                sort_vars = [\"units\", orient, other]\n                sort_cols = [var for var in sort_vars if var in self.variables]\n                sub_data = sub_data.sort_values(sort_cols)\n\n            if (\n                self.estimator is not None\n                and sub_data[orient].value_counts().max() > 1\n            ):\n                if \"units\" in self.variables:\n                    # TODO eventually relax this constraint\n                    err = \"estimator must be None when specifying units\"\n                    raise ValueError(err)\n                grouped = sub_data.groupby(orient, sort=self.sort)\n                # Could pass as_index=False instead of reset_index,\n                # but that fails on a corner case with older pandas.\n                sub_data = grouped.apply(agg, other).reset_index()\n            else:\n                sub_data[f\"{other}min\"] = np.nan\n                sub_data[f\"{other}max\"] = np.nan\n\n            # TODO this is pretty ad hoc ; see GH2409\n            for var in \"xy\":\n                if self._log_scaled(var):\n                    for col in sub_data.filter(regex=f\"^{var}\"):\n                        sub_data[col] = np.power(10, sub_data[col])\n\n            # --- Draw the main line(s)\n\n            if \"units\" in self.variables:   # XXX why not add to grouping variables?\n                lines = []\n                for _, unit_data in sub_data.groupby(\"units\"):\n                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))\n            else:\n                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)\n\n            for line in lines:\n\n                if \"hue\" in sub_vars:\n                    line.set_color(self._hue_map(sub_vars[\"hue\"]))\n\n                if \"size\" in sub_vars:\n                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))\n\n                if \"style\" in sub_vars:\n                    attributes = self._style_map(sub_vars[\"style\"])\n                    if \"dashes\" in attributes:\n                        line.set_dashes(attributes[\"dashes\"])\n                    if \"marker\" in attributes:\n                        line.set_marker(attributes[\"marker\"])\n\n            line_color = line.get_color()\n            line_alpha = line.get_alpha()\n            line_capstyle = line.get_solid_capstyle()\n\n            # --- Draw the confidence intervals\n\n            if self.estimator is not None and self.errorbar is not None:\n\n                # TODO handling of orientation will need to happen here\n\n                if self.err_style == \"band\":\n\n                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]\n                    func(\n                        sub_data[orient],\n                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],\n                        color=line_color, **err_kws\n                    )\n\n                elif self.err_style == \"bars\":\n\n                    error_param = {\n                        f\"{other}err\": (\n                            sub_data[other] - sub_data[f\"{other}min\"],\n                            sub_data[f\"{other}max\"] - sub_data[other],\n                        )\n                    }\n                    ebars = ax.errorbar(\n                        sub_data[\"x\"], sub_data[\"y\"], **error_param,\n                        linestyle=\"\", color=line_color, alpha=line_alpha,\n                        **err_kws\n                    )\n\n                    # Set the capstyle properly on the error bars\n                    for obj in ebars.get_children():\n                        if isinstance(obj, mpl.collections.LineCollection):\n                            obj.set_capstyle(line_capstyle)\n\n        # Finalize the axes details\n        self._add_axis_labels(ax)\n        if self.legend:\n            self.add_legend_data(ax)\n            handles, _ = ax.get_legend_handles_labels()\n            if handles:\n                legend = ax.legend(title=self.legend_title)\n                adjust_legend_subtitles(legend)\n", "tokens": ["seaborn", "relational", "py", "_lineplotter", "def", "plot", "self", "ax", "kws", "draw", "the", "plot", "onto", "an", "axes", "passing", "matplotlib", "kwargs", "draw", "a", "test", "plot", "using", "the", "passed", "in", "kwargs", "the", "goal", "here", "is", "to", "honor", "both", "a", "the", "current", "state", "of", "the", "plot", "cycler", "and", "b", "the", "specified", "kwargs", "on", "all", "the", "lines", "we", "will", "draw", "overriding", "when", "relevant", "with", "the", "data", "semantics", "note", "that", "we", "won", "t", "cycle", "internally", "in", "other", "words", "if", "hue", "is", "not", "used", "all", "elements", "will", "have", "the", "same", "color", "but", "they", "will", "have", "the", "color", "that", "you", "would", "have", "gotten", "from", "the", "corresponding", "matplotlib", "function", "and", "calling", "the", "function", "will", "advance", "the", "axes", "property", "cycle", "kws", "setdefault", "markeredgewidth", "kws", "pop", "mew", "75", "kws", "setdefault", "markeredgecolor", "kws", "pop", "mec", "w", "set", "default", "error", "kwargs", "err_kws", "self", "err_kws", "copy", "if", "self", "err_style", "band", "err_kws", "setdefault", "alpha", "2", "elif", "self", "err_style", "bars", "pass", "elif", "self", "err_style", "is", "not", "none", "err", "err_style", "must", "be", "band", "or", "bars", "not", "raise", "valueerror", "err", "format", "self", "err_style", "initialize", "the", "aggregation", "object", "agg", "estimateaggregator", "self", "estimator", "self", "errorbar", "n_boot", "self", "n_boot", "seed", "self", "seed", "todo", "abstract", "variable", "to", "aggregate", "over", "here", "ish", "better", "name", "orient", "self", "orient", "if", "orient", "not", "in", "x", "y", "err", "f", "orient", "must", "be", "either", "x", "or", "y", "not", "orient", "r", "raise", "valueerror", "err", "other", "x", "y", "y", "x", "orient", "todo", "how", "to", "handle", "na", "we", "don", "t", "want", "na", "to", "propagate", "through", "to", "the", "estimate", "ci", "when", "some", "values", "are", "present", "but", "we", "would", "also", "like", "matplotlib", "to", "show", "gaps", "in", "the", "line", "when", "all", "values", "are", "missing", "this", "is", "straightforward", "absent", "aggregation", "but", "complicated", "with", "it", "if", "we", "want", "to", "use", "nas", "we", "need", "to", "conditionalize", "dropna", "in", "iter_data", "loop", "over", "the", "semantic", "subsets", "and", "add", "to", "the", "plot", "grouping_vars", "hue", "size", "style", "for", "sub_vars", "sub_data", "in", "self", "iter_data", "grouping_vars", "from_comp_data", "true", "if", "self", "sort", "sort_vars", "units", "orient", "other", "sort_cols", "var", "for", "var", "in", "sort_vars", "if", "var", "in", "self", "variables", "sub_data", "sub_data", "sort_values", "sort_cols", "if", "self", "estimator", "is", "not", "none", "and", "sub_data", "orient", "value_counts", "max", "1", "if", "units", "in", "self", "variables", "todo", "eventually", "relax", "this", "constraint", "err", "estimator", "must", "be", "none", "when", "specifying", "units", "raise", "valueerror", "err", "grouped", "sub_data", "groupby", "orient", "sort", "self", "sort", "could", "pass", "as_index", "false", "instead", "of", "reset_index", "but", "that", "fails", "on", "a", "corner", "case", "with", "older", "pandas", "sub_data", "grouped", "apply", "agg", "other", "reset_index", "else", "sub_data", "f", "other", "min", "np", "nan", "sub_data", "f", "other", "max", "np", "nan", "todo", "this", "is", "pretty", "ad", "hoc", "see", "gh2409", "for", "var", "in", "xy", "if", "self", "_log_scaled", "var", "for", "col", "in", "sub_data", "filter", "regex", "f", "var", "sub_data", "col", "np", "power", "10", "sub_data", "col", "draw", "the", "main", "line", "s", "if", "units", "in", "self", "variables", "xxx", "why", "not", "add", "to", "grouping", "variables", "lines", "for", "_", "unit_data", "in", "sub_data", "groupby", "units", "lines", "extend", "ax", "plot", "unit_data", "x", "unit_data", "y", "kws", "else", "lines", "ax", "plot", "sub_data", "x", "sub_data", "y", "kws", "for", "line", "in", "lines", "if", "hue", "in", "sub_vars", "line", "set_color", "self", "_hue_map", "sub_vars", "hue", "if", "size", "in", "sub_vars", "line", "set_linewidth", "self", "_size_map", "sub_vars", "size", "if", "style", "in", "sub_vars", "attributes", "self", "_style_map", "sub_vars", "style", "if", "dashes", "in", "attributes", "line", "set_dashes", "attributes", "dashes", "if", "marker", "in", "attributes", "line", "set_marker", "attributes", "marker", "line_color", "line", "get_color", "line_alpha", "line", "get_alpha", "line_capstyle", "line", "get_solid_capstyle", "draw", "the", "confidence", "intervals", "if", "self", "estimator", "is", "not", "none", "and", "self", "errorbar", "is", "not", "none", "todo", "handling", "of", "orientation", "will", "need", "to", "happen", "here", "if", "self", "err_style", "band", "func", "x", "ax", "fill_between", "y", "ax", "fill_betweenx", "orient", "func", "sub_data", "orient", "sub_data", "f", "other", "min", "sub_data", "f", "other", "max", "color", "line_color", "err_kws", "elif", "self", "err_style", "bars", "error_param", "f", "other", "err", "sub_data", "other", "sub_data", "f", "other", "min", "sub_data", "f", "other", "max", "sub_data", "other", "ebars", "ax", "errorbar", "sub_data", "x", "sub_data", "y", "error_param", "linestyle", "color", "line_color", "alpha", "line_alpha", "err_kws", "set", "the", "capstyle", "properly", "on", "the", "error", "bars", "for", "obj", "in", "ebars", "get_children", "if", "isinstance", "obj", "mpl", "collections", "linecollection", "obj", "set_capstyle", "line_capstyle", "finalize", "the", "axes", "details", "self", "_add_axis_labels", "ax", "if", "self", "legend", "self", "add_legend_data", "ax", "handles", "_", "ax", "get_legend_handles_labels", "if", "handles", "legend", "ax", "legend", "title", "self", "legend_title", "adjust_legend_subtitles", "legend"], "doc_len": 668}
{"doc_id": "seaborn/relational.py::_ScatterPlotter.__init__", "file_path": "seaborn/relational.py", "class_name": "_ScatterPlotter", "func_name": "__init__", "text": "文件路径: seaborn/relational.py, 类名: _ScatterPlotter\n    def __init__(self, *, data=None, variables={}, legend=None):\n\n        # TODO this is messy, we want the mapping to be agnostic about\n        # the kind of plot to draw, but for the time being we need to set\n        # this information so the SizeMapping can use it\n        self._default_size_range = (\n            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])\n        )\n\n        super().__init__(data=data, variables=variables)\n\n        self.legend = legend\n", "tokens": ["seaborn", "relational", "py", "_scatterplotter", "def", "__init__", "self", "data", "none", "variables", "legend", "none", "todo", "this", "is", "messy", "we", "want", "the", "mapping", "to", "be", "agnostic", "about", "the", "kind", "of", "plot", "to", "draw", "but", "for", "the", "time", "being", "we", "need", "to", "set", "this", "information", "so", "the", "sizemapping", "can", "use", "it", "self", "_default_size_range", "np", "r_", "5", "2", "np", "square", "mpl", "rcparams", "lines", "markersize", "super", "__init__", "data", "data", "variables", "variables", "self", "legend", "legend"], "doc_len": 68}
{"doc_id": "seaborn/relational.py::_ScatterPlotter.plot", "file_path": "seaborn/relational.py", "class_name": "_ScatterPlotter", "func_name": "plot", "text": "文件路径: seaborn/relational.py, 类名: _ScatterPlotter\n    def plot(self, ax, kws):\n\n        # --- Determine the visual attributes of the plot\n\n        data = self.plot_data.dropna()\n        if data.empty:\n            return\n\n        # Define the vectors of x and y positions\n        empty = np.full(len(data), np.nan)\n        x = data.get(\"x\", empty)\n        y = data.get(\"y\", empty)\n\n        if \"style\" in self.variables:\n            # Use a representative marker so scatter sets the edgecolor\n            # properly for line art markers. We currently enforce either\n            # all or none line art so this works.\n            example_level = self._style_map.levels[0]\n            example_marker = self._style_map(example_level, \"marker\")\n            kws.setdefault(\"marker\", example_marker)\n\n        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"\n        # See https://github.com/matplotlib/matplotlib/issues/17849 for context\n        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))\n        if not isinstance(m, mpl.markers.MarkerStyle):\n            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here\n            m = mpl.markers.MarkerStyle(m)\n        if m.is_filled():\n            kws.setdefault(\"edgecolor\", \"w\")\n\n        # Draw the scatter plot\n        points = ax.scatter(x=x, y=y, **kws)\n\n        # Apply the mapping from semantic variables to artist attributes\n\n        if \"hue\" in self.variables:\n            points.set_facecolors(self._hue_map(data[\"hue\"]))\n\n        if \"size\" in self.variables:\n            points.set_sizes(self._size_map(data[\"size\"]))\n\n        if \"style\" in self.variables:\n            p = [self._style_map(val, \"path\") for val in data[\"style\"]]\n            points.set_paths(p)\n\n        # Apply dependent default attributes\n\n        if \"linewidth\" not in kws:\n            sizes = points.get_sizes()\n            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))\n\n        # Finalize the axes details\n        self._add_axis_labels(ax)\n        if self.legend:\n            self.add_legend_data(ax)\n            handles, _ = ax.get_legend_handles_labels()\n            if handles:\n                legend = ax.legend(title=self.legend_title)\n                adjust_legend_subtitles(legend)\n", "tokens": ["seaborn", "relational", "py", "_scatterplotter", "def", "plot", "self", "ax", "kws", "determine", "the", "visual", "attributes", "of", "the", "plot", "data", "self", "plot_data", "dropna", "if", "data", "empty", "return", "define", "the", "vectors", "of", "x", "and", "y", "positions", "empty", "np", "full", "len", "data", "np", "nan", "x", "data", "get", "x", "empty", "y", "data", "get", "y", "empty", "if", "style", "in", "self", "variables", "use", "a", "representative", "marker", "so", "scatter", "sets", "the", "edgecolor", "properly", "for", "line", "art", "markers", "we", "currently", "enforce", "either", "all", "or", "none", "line", "art", "so", "this", "works", "example_level", "self", "_style_map", "levels", "0", "example_marker", "self", "_style_map", "example_level", "marker", "kws", "setdefault", "marker", "example_marker", "conditionally", "set", "the", "marker", "edgecolor", "based", "on", "whether", "the", "marker", "is", "filled", "see", "https", "github", "com", "matplotlib", "matplotlib", "issues", "17849", "for", "context", "m", "kws", "get", "marker", "mpl", "rcparams", "get", "marker", "o", "if", "not", "isinstance", "m", "mpl", "markers", "markerstyle", "todo", "in", "more", "recent", "matplotlib", "which", "can", "pass", "a", "markerstyle", "here", "m", "mpl", "markers", "markerstyle", "m", "if", "m", "is_filled", "kws", "setdefault", "edgecolor", "w", "draw", "the", "scatter", "plot", "points", "ax", "scatter", "x", "x", "y", "y", "kws", "apply", "the", "mapping", "from", "semantic", "variables", "to", "artist", "attributes", "if", "hue", "in", "self", "variables", "points", "set_facecolors", "self", "_hue_map", "data", "hue", "if", "size", "in", "self", "variables", "points", "set_sizes", "self", "_size_map", "data", "size", "if", "style", "in", "self", "variables", "p", "self", "_style_map", "val", "path", "for", "val", "in", "data", "style", "points", "set_paths", "p", "apply", "dependent", "default", "attributes", "if", "linewidth", "not", "in", "kws", "sizes", "points", "get_sizes", "points", "set_linewidths", "08", "np", "sqrt", "np", "percentile", "sizes", "10", "finalize", "the", "axes", "details", "self", "_add_axis_labels", "ax", "if", "self", "legend", "self", "add_legend_data", "ax", "handles", "_", "ax", "get_legend_handles_labels", "if", "handles", "legend", "ax", "legend", "title", "self", "legend_title", "adjust_legend_subtitles", "legend"], "doc_len": 264}
{"doc_id": "seaborn/relational.py::lineplot", "file_path": "seaborn/relational.py", "class_name": null, "func_name": "lineplot", "text": "文件路径: seaborn/relational.py\ndef lineplot(\n    data=None, *,\n    x=None, y=None, hue=None, size=None, style=None, units=None,\n    palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None,\n    dashes=True, markers=None, style_order=None,\n    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n    orient=\"x\", sort=True, err_style=\"band\", err_kws=None,\n    legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs\n):\n\n    # Handle deprecation of ci parameter\n    errorbar = _deprecate_ci(errorbar, ci)\n\n    variables = _LinePlotter.get_semantics(locals())\n    p = _LinePlotter(\n        data=data, variables=variables,\n        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n        legend=legend,\n    )\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, dashes=dashes, order=style_order)\n\n    if ax is None:\n        ax = plt.gca()\n\n    if style is None and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n        kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n\n    if not p.has_xy_data:\n        return ax\n\n    p._attach(ax)\n\n    # Other functions have color as an explicit param,\n    # and we should probably do that here too\n    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n\n    p.plot(ax, kwargs)\n    return ax\n", "tokens": ["seaborn", "relational", "py", "def", "lineplot", "data", "none", "x", "none", "y", "none", "hue", "none", "size", "none", "style", "none", "units", "none", "palette", "none", "hue_order", "none", "hue_norm", "none", "sizes", "none", "size_order", "none", "size_norm", "none", "dashes", "true", "markers", "none", "style_order", "none", "estimator", "mean", "errorbar", "ci", "95", "n_boot", "1000", "seed", "none", "orient", "x", "sort", "true", "err_style", "band", "err_kws", "none", "legend", "auto", "ci", "deprecated", "ax", "none", "kwargs", "handle", "deprecation", "of", "ci", "parameter", "errorbar", "_deprecate_ci", "errorbar", "ci", "variables", "_lineplotter", "get_semantics", "locals", "p", "_lineplotter", "data", "data", "variables", "variables", "estimator", "estimator", "n_boot", "n_boot", "seed", "seed", "errorbar", "errorbar", "sort", "sort", "orient", "orient", "err_style", "err_style", "err_kws", "err_kws", "legend", "legend", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "p", "map_size", "sizes", "sizes", "order", "size_order", "norm", "size_norm", "p", "map_style", "markers", "markers", "dashes", "dashes", "order", "style_order", "if", "ax", "is", "none", "ax", "plt", "gca", "if", "style", "is", "none", "and", "not", "ls", "linestyle", "set", "kwargs", "xxx", "kwargs", "dashes", "if", "dashes", "is", "none", "or", "isinstance", "dashes", "bool", "else", "dashes", "if", "not", "p", "has_xy_data", "return", "ax", "p", "_attach", "ax", "other", "functions", "have", "color", "as", "an", "explicit", "param", "and", "we", "should", "probably", "do", "that", "here", "too", "color", "kwargs", "pop", "color", "kwargs", "pop", "c", "none", "kwargs", "color", "_default_color", "ax", "plot", "hue", "color", "kwargs", "p", "plot", "ax", "kwargs", "return", "ax"], "doc_len": 199}
{"doc_id": "seaborn/relational.py::scatterplot", "file_path": "seaborn/relational.py", "class_name": null, "func_name": "scatterplot", "text": "文件路径: seaborn/relational.py\ndef scatterplot(\n    data=None, *,\n    x=None, y=None, hue=None, size=None, style=None,\n    palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None,\n    markers=True, style_order=None, legend=\"auto\", ax=None,\n    **kwargs\n):\n\n    variables = _ScatterPlotter.get_semantics(locals())\n    p = _ScatterPlotter(data=data, variables=variables, legend=legend)\n\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, order=style_order)\n\n    if ax is None:\n        ax = plt.gca()\n\n    if not p.has_xy_data:\n        return ax\n\n    p._attach(ax)\n\n    # Other functions have color as an explicit param,\n    # and we should probably do that here too\n    color = kwargs.pop(\"color\", None)\n    kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)\n\n    p.plot(ax, kwargs)\n\n    return ax\n", "tokens": ["seaborn", "relational", "py", "def", "scatterplot", "data", "none", "x", "none", "y", "none", "hue", "none", "size", "none", "style", "none", "palette", "none", "hue_order", "none", "hue_norm", "none", "sizes", "none", "size_order", "none", "size_norm", "none", "markers", "true", "style_order", "none", "legend", "auto", "ax", "none", "kwargs", "variables", "_scatterplotter", "get_semantics", "locals", "p", "_scatterplotter", "data", "data", "variables", "variables", "legend", "legend", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "p", "map_size", "sizes", "sizes", "order", "size_order", "norm", "size_norm", "p", "map_style", "markers", "markers", "order", "style_order", "if", "ax", "is", "none", "ax", "plt", "gca", "if", "not", "p", "has_xy_data", "return", "ax", "p", "_attach", "ax", "other", "functions", "have", "color", "as", "an", "explicit", "param", "and", "we", "should", "probably", "do", "that", "here", "too", "color", "kwargs", "pop", "color", "none", "kwargs", "color", "_default_color", "ax", "scatter", "hue", "color", "kwargs", "p", "plot", "ax", "kwargs", "return", "ax"], "doc_len": 123}
{"doc_id": "seaborn/relational.py::relplot", "file_path": "seaborn/relational.py", "class_name": null, "func_name": "relplot", "text": "文件路径: seaborn/relational.py\ndef relplot(\n    data=None, *,\n    x=None, y=None, hue=None, size=None, style=None, units=None,\n    row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n    palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None,\n    markers=None, dashes=None, style_order=None,\n    legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,\n    **kwargs\n):\n\n    if kind == \"scatter\":\n\n        plotter = _ScatterPlotter\n        func = scatterplot\n        markers = True if markers is None else markers\n\n    elif kind == \"line\":\n\n        plotter = _LinePlotter\n        func = lineplot\n        dashes = True if dashes is None else dashes\n\n    else:\n        err = f\"Plot kind {kind} not recognized\"\n        raise ValueError(err)\n\n    # Check for attempt to plot onto specific axes and warn\n    if \"ax\" in kwargs:\n        msg = (\n            \"relplot is a figure-level function and does not accept \"\n            \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")\n        )\n        warnings.warn(msg, UserWarning)\n        kwargs.pop(\"ax\")\n\n    # Use the full dataset to map the semantics\n    p = plotter(\n        data=data,\n        variables=plotter.get_semantics(locals()),\n        legend=legend,\n    )\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, dashes=dashes, order=style_order)\n\n    # Extract the semantic mappings\n    if \"hue\" in p.variables:\n        palette = p._hue_map.lookup_table\n        hue_order = p._hue_map.levels\n        hue_norm = p._hue_map.norm\n    else:\n        palette = hue_order = hue_norm = None\n\n    if \"size\" in p.variables:\n        sizes = p._size_map.lookup_table\n        size_order = p._size_map.levels\n        size_norm = p._size_map.norm\n\n    if \"style\" in p.variables:\n        style_order = p._style_map.levels\n        if markers:\n            markers = {k: p._style_map(k, \"marker\") for k in style_order}\n        else:\n            markers = None\n        if dashes:\n            dashes = {k: p._style_map(k, \"dashes\") for k in style_order}\n        else:\n            dashes = None\n    else:\n        markers = dashes = style_order = None\n\n    # Now extract the data that would be used to draw a single plot\n    variables = p.variables\n    plot_data = p.plot_data\n    plot_semantics = p.semantics\n\n    # Define the common plotting parameters\n    plot_kws = dict(\n        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n        sizes=sizes, size_order=size_order, size_norm=size_norm,\n        markers=markers, dashes=dashes, style_order=style_order,\n        legend=False,\n    )\n    plot_kws.update(kwargs)\n    if kind == \"scatter\":\n        plot_kws.pop(\"dashes\")\n\n    # Add the grid semantics onto the plotter\n    grid_semantics = \"row\", \"col\"\n    p.semantics = plot_semantics + grid_semantics\n    p.assign_variables(\n        data=data,\n        variables=dict(\n            x=x, y=y,\n            hue=hue, size=size, style=style, units=units,\n            row=row, col=col,\n        ),\n    )\n\n    # Define the named variables for plotting on each facet\n    # Rename the variables with a leading underscore to avoid\n    # collisions with faceting variable names\n    plot_variables = {v: f\"_{v}\" for v in variables}\n    plot_kws.update(plot_variables)\n\n    # Pass the row/col variables to FacetGrid with their original\n    # names so that the axes titles render correctly\n    for var in [\"row\", \"col\"]:\n        # Handle faceting variables that lack name information\n        if var in p.variables and p.variables[var] is None:\n            p.variables[var] = f\"_{var}_\"\n    grid_kws = {v: p.variables.get(v) for v in grid_semantics}\n\n    # Rename the columns of the plot_data structure appropriately\n    new_cols = plot_variables.copy()\n    new_cols.update(grid_kws)\n    full_data = p.plot_data.rename(columns=new_cols)\n\n    # Set up the FacetGrid object\n    facet_kws = {} if facet_kws is None else facet_kws.copy()\n    g = FacetGrid(\n        data=full_data.dropna(axis=1, how=\"all\"),\n        **grid_kws,\n        col_wrap=col_wrap, row_order=row_order, col_order=col_order,\n        height=height, aspect=aspect, dropna=False,\n        **facet_kws\n    )\n\n    # Draw the plot\n    g.map_dataframe(func, **plot_kws)\n\n    # Label the axes, using the original variables\n    # Pass \"\" when the variable name is None to overwrite internal variables\n    g.set_axis_labels(variables.get(\"x\") or \"\", variables.get(\"y\") or \"\")\n\n    # Show the legend\n    if legend:\n        # Replace the original plot data so the legend uses\n        # numeric data with the correct type\n        p.plot_data = plot_data\n        p.add_legend_data(g.axes.flat[0])\n        if p.legend_data:\n            g.add_legend(legend_data=p.legend_data,\n                         label_order=p.legend_order,\n                         title=p.legend_title,\n                         adjust_subtitles=True)\n\n    # Rename the columns of the FacetGrid's `data` attribute\n    # to match the original column names\n    orig_cols = {\n        f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()\n    }\n    grid_data = g.data.rename(columns=orig_cols)\n    if data is not None and (x is not None or y is not None):\n        if not isinstance(data, pd.DataFrame):\n            data = pd.DataFrame(data)\n        g.data = pd.merge(\n            data,\n            grid_data[grid_data.columns.difference(data.columns)],\n            left_index=True,\n            right_index=True,\n        )\n    else:\n        g.data = grid_data\n\n    return g\n", "tokens": ["seaborn", "relational", "py", "def", "relplot", "data", "none", "x", "none", "y", "none", "hue", "none", "size", "none", "style", "none", "units", "none", "row", "none", "col", "none", "col_wrap", "none", "row_order", "none", "col_order", "none", "palette", "none", "hue_order", "none", "hue_norm", "none", "sizes", "none", "size_order", "none", "size_norm", "none", "markers", "none", "dashes", "none", "style_order", "none", "legend", "auto", "kind", "scatter", "height", "5", "aspect", "1", "facet_kws", "none", "kwargs", "if", "kind", "scatter", "plotter", "_scatterplotter", "func", "scatterplot", "markers", "true", "if", "markers", "is", "none", "else", "markers", "elif", "kind", "line", "plotter", "_lineplotter", "func", "lineplot", "dashes", "true", "if", "dashes", "is", "none", "else", "dashes", "else", "err", "f", "plot", "kind", "kind", "not", "recognized", "raise", "valueerror", "err", "check", "for", "attempt", "to", "plot", "onto", "specific", "axes", "and", "warn", "if", "ax", "in", "kwargs", "msg", "relplot", "is", "a", "figure", "level", "function", "and", "does", "not", "accept", "the", "ax", "parameter", "you", "may", "wish", "to", "try", "format", "kind", "plot", "warnings", "warn", "msg", "userwarning", "kwargs", "pop", "ax", "use", "the", "full", "dataset", "to", "map", "the", "semantics", "p", "plotter", "data", "data", "variables", "plotter", "get_semantics", "locals", "legend", "legend", "p", "map_hue", "palette", "palette", "order", "hue_order", "norm", "hue_norm", "p", "map_size", "sizes", "sizes", "order", "size_order", "norm", "size_norm", "p", "map_style", "markers", "markers", "dashes", "dashes", "order", "style_order", "extract", "the", "semantic", "mappings", "if", "hue", "in", "p", "variables", "palette", "p", "_hue_map", "lookup_table", "hue_order", "p", "_hue_map", "levels", "hue_norm", "p", "_hue_map", "norm", "else", "palette", "hue_order", "hue_norm", "none", "if", "size", "in", "p", "variables", "sizes", "p", "_size_map", "lookup_table", "size_order", "p", "_size_map", "levels", "size_norm", "p", "_size_map", "norm", "if", "style", "in", "p", "variables", "style_order", "p", "_style_map", "levels", "if", "markers", "markers", "k", "p", "_style_map", "k", "marker", "for", "k", "in", "style_order", "else", "markers", "none", "if", "dashes", "dashes", "k", "p", "_style_map", "k", "dashes", "for", "k", "in", "style_order", "else", "dashes", "none", "else", "markers", "dashes", "style_order", "none", "now", "extract", "the", "data", "that", "would", "be", "used", "to", "draw", "a", "single", "plot", "variables", "p", "variables", "plot_data", "p", "plot_data", "plot_semantics", "p", "semantics", "define", "the", "common", "plotting", "parameters", "plot_kws", "dict", "palette", "palette", "hue_order", "hue_order", "hue_norm", "hue_norm", "sizes", "sizes", "size_order", "size_order", "size_norm", "size_norm", "markers", "markers", "dashes", "dashes", "style_order", "style_order", "legend", "false", "plot_kws", "update", "kwargs", "if", "kind", "scatter", "plot_kws", "pop", "dashes", "add", "the", "grid", "semantics", "onto", "the", "plotter", "grid_semantics", "row", "col", "p", "semantics", "plot_semantics", "grid_semantics", "p", "assign_variables", "data", "data", "variables", "dict", "x", "x", "y", "y", "hue", "hue", "size", "size", "style", "style", "units", "units", "row", "row", "col", "col", "define", "the", "named", "variables", "for", "plotting", "on", "each", "facet", "rename", "the", "variables", "with", "a", "leading", "underscore", "to", "avoid", "collisions", "with", "faceting", "variable", "names", "plot_variables", "v", "f", "_", "v", "for", "v", "in", "variables", "plot_kws", "update", "plot_variables", "pass", "the", "row", "col", "variables", "to", "facetgrid", "with", "their", "original", "names", "so", "that", "the", "axes", "titles", "render", "correctly", "for", "var", "in", "row", "col", "handle", "faceting", "variables", "that", "lack", "name", "information", "if", "var", "in", "p", "variables", "and", "p", "variables", "var", "is", "none", "p", "variables", "var", "f", "_", "var", "_", "grid_kws", "v", "p", "variables", "get", "v", "for", "v", "in", "grid_semantics", "rename", "the", "columns", "of", "the", "plot_data", "structure", "appropriately", "new_cols", "plot_variables", "copy", "new_cols", "update", "grid_kws", "full_data", "p", "plot_data", "rename", "columns", "new_cols", "set", "up", "the", "facetgrid", "object", "facet_kws", "if", "facet_kws", "is", "none", "else", "facet_kws", "copy", "g", "facetgrid", "data", "full_data", "dropna", "axis", "1", "how", "all", "grid_kws", "col_wrap", "col_wrap", "row_order", "row_order", "col_order", "col_order", "height", "height", "aspect", "aspect", "dropna", "false", "facet_kws", "draw", "the", "plot", "g", "map_dataframe", "func", "plot_kws", "label", "the", "axes", "using", "the", "original", "variables", "pass", "when", "the", "variable", "name", "is", "none", "to", "overwrite", "internal", "variables", "g", "set_axis_labels", "variables", "get", "x", "or", "variables", "get", "y", "or", "show", "the", "legend", "if", "legend", "replace", "the", "original", "plot", "data", "so", "the", "legend", "uses", "numeric", "data", "with", "the", "correct", "type", "p", "plot_data", "plot_data", "p", "add_legend_data", "g", "axes", "flat", "0", "if", "p", "legend_data", "g", "add_legend", "legend_data", "p", "legend_data", "label_order", "p", "legend_order", "title", "p", "legend_title", "adjust_subtitles", "true", "rename", "the", "columns", "of", "the", "facetgrid", "s", "data", "attribute", "to", "match", "the", "original", "column", "names", "orig_cols", "f", "_", "k", "f", "_", "k", "_", "if", "v", "is", "none", "else", "v", "for", "k", "v", "in", "variables", "items", "grid_data", "g", "data", "rename", "columns", "orig_cols", "if", "data", "is", "not", "none", "and", "x", "is", "not", "none", "or", "y", "is", "not", "none", "if", "not", "isinstance", "data", "pd", "dataframe", "data", "pd", "dataframe", "data", "g", "data", "pd", "merge", "data", "grid_data", "grid_data", "columns", "difference", "data", "columns", "left_index", "true", "right_index", "true", "else", "g", "data", "grid_data", "return", "g"], "doc_len": 681}
{"doc_id": "seaborn/utils.py::ci_to_errsize", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "ci_to_errsize", "text": "文件路径: seaborn/utils.py\ndef ci_to_errsize(cis, heights):\n    \"\"\"Convert intervals to error arguments relative to plot heights.\n\n    Parameters\n    ----------\n    cis : 2 x n sequence\n        sequence of confidence interval limits\n    heights : n sequence\n        sequence of plot heights\n\n    Returns\n    -------\n    errsize : 2 x n array\n        sequence of error size relative to height values in correct\n        format as argument for plt.bar\n\n    \"\"\"\n    cis = np.atleast_2d(cis).reshape(2, -1)\n    heights = np.atleast_1d(heights)\n    errsize = []\n    for i, (low, high) in enumerate(np.transpose(cis)):\n        h = heights[i]\n        elow = h - low\n        ehigh = high - h\n        errsize.append([elow, ehigh])\n\n    errsize = np.asarray(errsize).T\n    return errsize\n", "tokens": ["seaborn", "utils", "py", "def", "ci_to_errsize", "cis", "heights", "convert", "intervals", "to", "error", "arguments", "relative", "to", "plot", "heights", "parameters", "cis", "2", "x", "n", "sequence", "sequence", "of", "confidence", "interval", "limits", "heights", "n", "sequence", "sequence", "of", "plot", "heights", "returns", "errsize", "2", "x", "n", "array", "sequence", "of", "error", "size", "relative", "to", "height", "values", "in", "correct", "format", "as", "argument", "for", "plt", "bar", "cis", "np", "atleast_2d", "cis", "reshape", "2", "1", "heights", "np", "atleast_1d", "heights", "errsize", "for", "i", "low", "high", "in", "enumerate", "np", "transpose", "cis", "h", "heights", "i", "elow", "h", "low", "ehigh", "high", "h", "errsize", "append", "elow", "ehigh", "errsize", "np", "asarray", "errsize", "t", "return", "errsize"], "doc_len": 97}
{"doc_id": "seaborn/utils.py::_normal_quantile_func", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_normal_quantile_func", "text": "文件路径: seaborn/utils.py\ndef _normal_quantile_func(q):\n    \"\"\"\n    Compute the quantile function of the standard normal distribution.\n\n    This wrapper exists because we are dropping scipy as a mandatory dependency\n    but statistics.NormalDist was added to the standard library in 3.8.\n\n    \"\"\"\n    try:\n        from statistics import NormalDist\n        qf = np.vectorize(NormalDist().inv_cdf)\n    except ImportError:\n        try:\n            from scipy.stats import norm\n            qf = norm.ppf\n        except ImportError:\n            msg = (\n                \"Standard normal quantile functions require either Python>=3.8 or scipy\"\n            )\n            raise RuntimeError(msg)\n    return qf(q)\n", "tokens": ["seaborn", "utils", "py", "def", "_normal_quantile_func", "q", "compute", "the", "quantile", "function", "of", "the", "standard", "normal", "distribution", "this", "wrapper", "exists", "because", "we", "are", "dropping", "scipy", "as", "a", "mandatory", "dependency", "but", "statistics", "normaldist", "was", "added", "to", "the", "standard", "library", "in", "3", "8", "try", "from", "statistics", "import", "normaldist", "qf", "np", "vectorize", "normaldist", "inv_cdf", "except", "importerror", "try", "from", "scipy", "stats", "import", "norm", "qf", "norm", "ppf", "except", "importerror", "msg", "standard", "normal", "quantile", "functions", "require", "either", "python", "3", "8", "or", "scipy", "raise", "runtimeerror", "msg", "return", "qf", "q"], "doc_len": 80}
{"doc_id": "seaborn/utils.py::_draw_figure", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_draw_figure", "text": "文件路径: seaborn/utils.py\ndef _draw_figure(fig):\n    \"\"\"Force draw of a matplotlib figure, accounting for back-compat.\"\"\"\n    # See https://github.com/matplotlib/matplotlib/issues/19197 for context\n    fig.canvas.draw()\n    if fig.stale:\n        try:\n            fig.draw(fig.canvas.get_renderer())\n        except AttributeError:\n            pass\n", "tokens": ["seaborn", "utils", "py", "def", "_draw_figure", "fig", "force", "draw", "of", "a", "matplotlib", "figure", "accounting", "for", "back", "compat", "see", "https", "github", "com", "matplotlib", "matplotlib", "issues", "19197", "for", "context", "fig", "canvas", "draw", "if", "fig", "stale", "try", "fig", "draw", "fig", "canvas", "get_renderer", "except", "attributeerror", "pass"], "doc_len": 41}
{"doc_id": "seaborn/utils.py::_default_color", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_default_color", "text": "文件路径: seaborn/utils.py\ndef _default_color(method, hue, color, kws):\n    \"\"\"If needed, get a default color by using the matplotlib property cycle.\"\"\"\n\n    if hue is not None:\n        # This warning is probably user-friendly, but it's currently triggered\n        # in a FacetGrid context and I don't want to mess with that logic right now\n        #  if color is not None:\n        #      msg = \"`color` is ignored when `hue` is assigned.\"\n        #      warnings.warn(msg)\n        return None\n\n    kws = kws.copy()\n    kws.pop(\"label\", None)\n\n    if color is not None:\n        return color\n\n    elif method.__name__ == \"plot\":\n\n        color = _normalize_kwargs(kws, mpl.lines.Line2D).get(\"color\")\n        scout, = method([], [], scalex=False, scaley=False, color=color)\n        color = scout.get_color()\n        scout.remove()\n\n    elif method.__name__ == \"scatter\":\n\n        # Matplotlib will raise if the size of x/y don't match s/c,\n        # and the latter might be in the kws dict\n        scout_size = max(\n            np.atleast_1d(kws.get(key, [])).shape[0]\n            for key in [\"s\", \"c\", \"fc\", \"facecolor\", \"facecolors\"]\n        )\n        scout_x = scout_y = np.full(scout_size, np.nan)\n\n        scout = method(scout_x, scout_y, **kws)\n        facecolors = scout.get_facecolors()\n\n        if not len(facecolors):\n            # Handle bug in matplotlib <= 3.2 (I think)\n            # This will limit the ability to use non color= kwargs to specify\n            # a color in versions of matplotlib with the bug, but trying to\n            # work out what the user wanted by re-implementing the broken logic\n            # of inspecting the kwargs is probably too brittle.\n            single_color = False\n        else:\n            single_color = np.unique(facecolors, axis=0).shape[0] == 1\n\n        # Allow the user to specify an array of colors through various kwargs\n        if \"c\" not in kws and single_color:\n            color = to_rgb(facecolors[0])\n\n        scout.remove()\n\n    elif method.__name__ == \"bar\":\n\n        # bar() needs masked, not empty data, to generate a patch\n        scout, = method([np.nan], [np.nan], **kws)\n        color = to_rgb(scout.get_facecolor())\n        scout.remove()\n\n    elif method.__name__ == \"fill_between\":\n\n        # There is a bug on matplotlib < 3.3 where fill_between with\n        # datetime units and empty data will set incorrect autoscale limits\n        # To workaround it, we'll always return the first color in the cycle.\n        # https://github.com/matplotlib/matplotlib/issues/17586\n        ax = method.__self__\n        datetime_axis = any([\n            isinstance(ax.xaxis.converter, mpl.dates.DateConverter),\n            isinstance(ax.yaxis.converter, mpl.dates.DateConverter),\n        ])\n        if Version(mpl.__version__) < Version(\"3.3\") and datetime_axis:\n            return \"C0\"\n\n        kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)\n\n        scout = method([], [], **kws)\n        facecolor = scout.get_facecolor()\n        color = to_rgb(facecolor[0])\n        scout.remove()\n\n    return color\n", "tokens": ["seaborn", "utils", "py", "def", "_default_color", "method", "hue", "color", "kws", "if", "needed", "get", "a", "default", "color", "by", "using", "the", "matplotlib", "property", "cycle", "if", "hue", "is", "not", "none", "this", "warning", "is", "probably", "user", "friendly", "but", "it", "s", "currently", "triggered", "in", "a", "facetgrid", "context", "and", "i", "don", "t", "want", "to", "mess", "with", "that", "logic", "right", "now", "if", "color", "is", "not", "none", "msg", "color", "is", "ignored", "when", "hue", "is", "assigned", "warnings", "warn", "msg", "return", "none", "kws", "kws", "copy", "kws", "pop", "label", "none", "if", "color", "is", "not", "none", "return", "color", "elif", "method", "__name__", "plot", "color", "_normalize_kwargs", "kws", "mpl", "lines", "line2d", "get", "color", "scout", "method", "scalex", "false", "scaley", "false", "color", "color", "color", "scout", "get_color", "scout", "remove", "elif", "method", "__name__", "scatter", "matplotlib", "will", "raise", "if", "the", "size", "of", "x", "y", "don", "t", "match", "s", "c", "and", "the", "latter", "might", "be", "in", "the", "kws", "dict", "scout_size", "max", "np", "atleast_1d", "kws", "get", "key", "shape", "0", "for", "key", "in", "s", "c", "fc", "facecolor", "facecolors", "scout_x", "scout_y", "np", "full", "scout_size", "np", "nan", "scout", "method", "scout_x", "scout_y", "kws", "facecolors", "scout", "get_facecolors", "if", "not", "len", "facecolors", "handle", "bug", "in", "matplotlib", "3", "2", "i", "think", "this", "will", "limit", "the", "ability", "to", "use", "non", "color", "kwargs", "to", "specify", "a", "color", "in", "versions", "of", "matplotlib", "with", "the", "bug", "but", "trying", "to", "work", "out", "what", "the", "user", "wanted", "by", "re", "implementing", "the", "broken", "logic", "of", "inspecting", "the", "kwargs", "is", "probably", "too", "brittle", "single_color", "false", "else", "single_color", "np", "unique", "facecolors", "axis", "0", "shape", "0", "1", "allow", "the", "user", "to", "specify", "an", "array", "of", "colors", "through", "various", "kwargs", "if", "c", "not", "in", "kws", "and", "single_color", "color", "to_rgb", "facecolors", "0", "scout", "remove", "elif", "method", "__name__", "bar", "bar", "needs", "masked", "not", "empty", "data", "to", "generate", "a", "patch", "scout", "method", "np", "nan", "np", "nan", "kws", "color", "to_rgb", "scout", "get_facecolor", "scout", "remove", "elif", "method", "__name__", "fill_between", "there", "is", "a", "bug", "on", "matplotlib", "3", "3", "where", "fill_between", "with", "datetime", "units", "and", "empty", "data", "will", "set", "incorrect", "autoscale", "limits", "to", "workaround", "it", "we", "ll", "always", "return", "the", "first", "color", "in", "the", "cycle", "https", "github", "com", "matplotlib", "matplotlib", "issues", "17586", "ax", "method", "__self__", "datetime_axis", "any", "isinstance", "ax", "xaxis", "converter", "mpl", "dates", "dateconverter", "isinstance", "ax", "yaxis", "converter", "mpl", "dates", "dateconverter", "if", "version", "mpl", "__version__", "version", "3", "3", "and", "datetime_axis", "return", "c0", "kws", "_normalize_kwargs", "kws", "mpl", "collections", "polycollection", "scout", "method", "kws", "facecolor", "scout", "get_facecolor", "color", "to_rgb", "facecolor", "0", "scout", "remove", "return", "color"], "doc_len": 384}
{"doc_id": "seaborn/utils.py::desaturate", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "desaturate", "text": "文件路径: seaborn/utils.py\ndef desaturate(color, prop):\n    \"\"\"Decrease the saturation channel of a color by some percent.\n\n    Parameters\n    ----------\n    color : matplotlib color\n        hex, rgb-tuple, or html color name\n    prop : float\n        saturation channel of color will be multiplied by this value\n\n    Returns\n    -------\n    new_color : rgb tuple\n        desaturated color code in RGB tuple representation\n\n    \"\"\"\n    # Check inputs\n    if not 0 <= prop <= 1:\n        raise ValueError(\"prop must be between 0 and 1\")\n\n    # Get rgb tuple rep\n    rgb = to_rgb(color)\n\n    # Convert to hls\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n\n    # Desaturate the saturation channel\n    s *= prop\n\n    # Convert back to rgb\n    new_color = colorsys.hls_to_rgb(h, l, s)\n\n    return new_color\n", "tokens": ["seaborn", "utils", "py", "def", "desaturate", "color", "prop", "decrease", "the", "saturation", "channel", "of", "a", "color", "by", "some", "percent", "parameters", "color", "matplotlib", "color", "hex", "rgb", "tuple", "or", "html", "color", "name", "prop", "float", "saturation", "channel", "of", "color", "will", "be", "multiplied", "by", "this", "value", "returns", "new_color", "rgb", "tuple", "desaturated", "color", "code", "in", "rgb", "tuple", "representation", "check", "inputs", "if", "not", "0", "prop", "1", "raise", "valueerror", "prop", "must", "be", "between", "0", "and", "1", "get", "rgb", "tuple", "rep", "rgb", "to_rgb", "color", "convert", "to", "hls", "h", "l", "s", "colorsys", "rgb_to_hls", "rgb", "desaturate", "the", "saturation", "channel", "s", "prop", "convert", "back", "to", "rgb", "new_color", "colorsys", "hls_to_rgb", "h", "l", "s", "return", "new_color"], "doc_len": 101}
{"doc_id": "seaborn/utils.py::saturate", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "saturate", "text": "文件路径: seaborn/utils.py\ndef saturate(color):\n    \"\"\"Return a fully saturated color with the same hue.\n\n    Parameters\n    ----------\n    color : matplotlib color\n        hex, rgb-tuple, or html color name\n\n    Returns\n    -------\n    new_color : rgb tuple\n        saturated color code in RGB tuple representation\n\n    \"\"\"\n    return set_hls_values(color, s=1)\n", "tokens": ["seaborn", "utils", "py", "def", "saturate", "color", "return", "a", "fully", "saturated", "color", "with", "the", "same", "hue", "parameters", "color", "matplotlib", "color", "hex", "rgb", "tuple", "or", "html", "color", "name", "returns", "new_color", "rgb", "tuple", "saturated", "color", "code", "in", "rgb", "tuple", "representation", "return", "set_hls_values", "color", "s", "1"], "doc_len": 42}
{"doc_id": "seaborn/utils.py::set_hls_values", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "set_hls_values", "text": "文件路径: seaborn/utils.py\ndef set_hls_values(color, h=None, l=None, s=None):  # noqa\n    \"\"\"Independently manipulate the h, l, or s channels of a color.\n\n    Parameters\n    ----------\n    color : matplotlib color\n        hex, rgb-tuple, or html color name\n    h, l, s : floats between 0 and 1, or None\n        new values for each channel in hls space\n\n    Returns\n    -------\n    new_color : rgb tuple\n        new color code in RGB tuple representation\n\n    \"\"\"\n    # Get an RGB tuple representation\n    rgb = to_rgb(color)\n    vals = list(colorsys.rgb_to_hls(*rgb))\n    for i, val in enumerate([h, l, s]):\n        if val is not None:\n            vals[i] = val\n\n    rgb = colorsys.hls_to_rgb(*vals)\n    return rgb\n", "tokens": ["seaborn", "utils", "py", "def", "set_hls_values", "color", "h", "none", "l", "none", "s", "none", "noqa", "independently", "manipulate", "the", "h", "l", "or", "s", "channels", "of", "a", "color", "parameters", "color", "matplotlib", "color", "hex", "rgb", "tuple", "or", "html", "color", "name", "h", "l", "s", "floats", "between", "0", "and", "1", "or", "none", "new", "values", "for", "each", "channel", "in", "hls", "space", "returns", "new_color", "rgb", "tuple", "new", "color", "code", "in", "rgb", "tuple", "representation", "get", "an", "rgb", "tuple", "representation", "rgb", "to_rgb", "color", "vals", "list", "colorsys", "rgb_to_hls", "rgb", "for", "i", "val", "in", "enumerate", "h", "l", "s", "if", "val", "is", "not", "none", "vals", "i", "val", "rgb", "colorsys", "hls_to_rgb", "vals", "return", "rgb"], "doc_len": 99}
{"doc_id": "seaborn/utils.py::axlabel", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "axlabel", "text": "文件路径: seaborn/utils.py\ndef axlabel(xlabel, ylabel, **kwargs):\n    \"\"\"Grab current axis and label it.\n\n    DEPRECATED: will be removed in a future version.\n\n    \"\"\"\n    msg = \"This function is deprecated and will be removed in a future version\"\n    warnings.warn(msg, FutureWarning)\n    ax = plt.gca()\n    ax.set_xlabel(xlabel, **kwargs)\n    ax.set_ylabel(ylabel, **kwargs)\n", "tokens": ["seaborn", "utils", "py", "def", "axlabel", "xlabel", "ylabel", "kwargs", "grab", "current", "axis", "and", "label", "it", "deprecated", "will", "be", "removed", "in", "a", "future", "version", "msg", "this", "function", "is", "deprecated", "and", "will", "be", "removed", "in", "a", "future", "version", "warnings", "warn", "msg", "futurewarning", "ax", "plt", "gca", "ax", "set_xlabel", "xlabel", "kwargs", "ax", "set_ylabel", "ylabel", "kwargs"], "doc_len": 50}
{"doc_id": "seaborn/utils.py::remove_na", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "remove_na", "text": "文件路径: seaborn/utils.py\ndef remove_na(vector):\n    \"\"\"Helper method for removing null values from data vectors.\n\n    Parameters\n    ----------\n    vector : vector object\n        Must implement boolean masking with [] subscript syntax.\n\n    Returns\n    -------\n    clean_clean : same type as ``vector``\n        Vector of data with null values removed. May be a copy or a view.\n\n    \"\"\"\n    return vector[pd.notnull(vector)]\n", "tokens": ["seaborn", "utils", "py", "def", "remove_na", "vector", "helper", "method", "for", "removing", "null", "values", "from", "data", "vectors", "parameters", "vector", "vector", "object", "must", "implement", "boolean", "masking", "with", "subscript", "syntax", "returns", "clean_clean", "same", "type", "as", "vector", "vector", "of", "data", "with", "null", "values", "removed", "may", "be", "a", "copy", "or", "a", "view", "return", "vector", "pd", "notnull", "vector"], "doc_len": 51}
{"doc_id": "seaborn/utils.py::get_color_cycle", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "get_color_cycle", "text": "文件路径: seaborn/utils.py\ndef get_color_cycle():\n    \"\"\"Return the list of colors in the current matplotlib color cycle\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    colors : list\n        List of matplotlib colors in the current cycle, or dark gray if\n        the current color cycle is empty.\n    \"\"\"\n    cycler = mpl.rcParams['axes.prop_cycle']\n    return cycler.by_key()['color'] if 'color' in cycler.keys else [\".15\"]\n", "tokens": ["seaborn", "utils", "py", "def", "get_color_cycle", "return", "the", "list", "of", "colors", "in", "the", "current", "matplotlib", "color", "cycle", "parameters", "none", "returns", "colors", "list", "list", "of", "matplotlib", "colors", "in", "the", "current", "cycle", "or", "dark", "gray", "if", "the", "current", "color", "cycle", "is", "empty", "cycler", "mpl", "rcparams", "axes", "prop_cycle", "return", "cycler", "by_key", "color", "if", "color", "in", "cycler", "keys", "else", "15"], "doc_len": 55}
{"doc_id": "seaborn/utils.py::despine", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "despine", "text": "文件路径: seaborn/utils.py\ndef despine(fig=None, ax=None, top=True, right=True, left=False,\n            bottom=False, offset=None, trim=False):\n    \"\"\"Remove the top and right spines from plot(s).\n\n    fig : matplotlib figure, optional\n        Figure to despine all axes of, defaults to the current figure.\n    ax : matplotlib axes, optional\n        Specific axes object to despine. Ignored if fig is provided.\n    top, right, left, bottom : boolean, optional\n        If True, remove that spine.\n    offset : int or dict, optional\n        Absolute distance, in points, spines should be moved away\n        from the axes (negative values move spines inward). A single value\n        applies to all spines; a dict can be used to set offset values per\n        side.\n    trim : bool, optional\n        If True, limit spines to the smallest and largest major tick\n        on each non-despined axis.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    # Get references to the axes we want\n    if fig is None and ax is None:\n        axes = plt.gcf().axes\n    elif fig is not None:\n        axes = fig.axes\n    elif ax is not None:\n        axes = [ax]\n\n    for ax_i in axes:\n        for side in [\"top\", \"right\", \"left\", \"bottom\"]:\n            # Toggle the spine objects\n            is_visible = not locals()[side]\n            ax_i.spines[side].set_visible(is_visible)\n            if offset is not None and is_visible:\n                try:\n                    val = offset.get(side, 0)\n                except AttributeError:\n                    val = offset\n                ax_i.spines[side].set_position(('outward', val))\n\n        # Potentially move the ticks\n        if left and not right:\n            maj_on = any(\n                t.tick1line.get_visible()\n                for t in ax_i.yaxis.majorTicks\n            )\n            min_on = any(\n                t.tick1line.get_visible()\n                for t in ax_i.yaxis.minorTicks\n            )\n            ax_i.yaxis.set_ticks_position(\"right\")\n            for t in ax_i.yaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.yaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n\n        if bottom and not top:\n            maj_on = any(\n                t.tick1line.get_visible()\n                for t in ax_i.xaxis.majorTicks\n            )\n            min_on = any(\n                t.tick1line.get_visible()\n                for t in ax_i.xaxis.minorTicks\n            )\n            ax_i.xaxis.set_ticks_position(\"top\")\n            for t in ax_i.xaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.xaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n\n        if trim:\n            # clip off the parts of the spines that extend past major ticks\n            xticks = np.asarray(ax_i.get_xticks())\n            if xticks.size:\n                firsttick = np.compress(xticks >= min(ax_i.get_xlim()),\n                                        xticks)[0]\n                lasttick = np.compress(xticks <= max(ax_i.get_xlim()),\n                                       xticks)[-1]\n                ax_i.spines['bottom'].set_bounds(firsttick, lasttick)\n                ax_i.spines['top'].set_bounds(firsttick, lasttick)\n                newticks = xticks.compress(xticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_xticks(newticks)\n\n            yticks = np.asarray(ax_i.get_yticks())\n            if yticks.size:\n                firsttick = np.compress(yticks >= min(ax_i.get_ylim()),\n                                        yticks)[0]\n                lasttick = np.compress(yticks <= max(ax_i.get_ylim()),\n                                       yticks)[-1]\n                ax_i.spines['left'].set_bounds(firsttick, lasttick)\n                ax_i.spines['right'].set_bounds(firsttick, lasttick)\n                newticks = yticks.compress(yticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_yticks(newticks)\n", "tokens": ["seaborn", "utils", "py", "def", "despine", "fig", "none", "ax", "none", "top", "true", "right", "true", "left", "false", "bottom", "false", "offset", "none", "trim", "false", "remove", "the", "top", "and", "right", "spines", "from", "plot", "s", "fig", "matplotlib", "figure", "optional", "figure", "to", "despine", "all", "axes", "of", "defaults", "to", "the", "current", "figure", "ax", "matplotlib", "axes", "optional", "specific", "axes", "object", "to", "despine", "ignored", "if", "fig", "is", "provided", "top", "right", "left", "bottom", "boolean", "optional", "if", "true", "remove", "that", "spine", "offset", "int", "or", "dict", "optional", "absolute", "distance", "in", "points", "spines", "should", "be", "moved", "away", "from", "the", "axes", "negative", "values", "move", "spines", "inward", "a", "single", "value", "applies", "to", "all", "spines", "a", "dict", "can", "be", "used", "to", "set", "offset", "values", "per", "side", "trim", "bool", "optional", "if", "true", "limit", "spines", "to", "the", "smallest", "and", "largest", "major", "tick", "on", "each", "non", "despined", "axis", "returns", "none", "get", "references", "to", "the", "axes", "we", "want", "if", "fig", "is", "none", "and", "ax", "is", "none", "axes", "plt", "gcf", "axes", "elif", "fig", "is", "not", "none", "axes", "fig", "axes", "elif", "ax", "is", "not", "none", "axes", "ax", "for", "ax_i", "in", "axes", "for", "side", "in", "top", "right", "left", "bottom", "toggle", "the", "spine", "objects", "is_visible", "not", "locals", "side", "ax_i", "spines", "side", "set_visible", "is_visible", "if", "offset", "is", "not", "none", "and", "is_visible", "try", "val", "offset", "get", "side", "0", "except", "attributeerror", "val", "offset", "ax_i", "spines", "side", "set_position", "outward", "val", "potentially", "move", "the", "ticks", "if", "left", "and", "not", "right", "maj_on", "any", "t", "tick1line", "get_visible", "for", "t", "in", "ax_i", "yaxis", "majorticks", "min_on", "any", "t", "tick1line", "get_visible", "for", "t", "in", "ax_i", "yaxis", "minorticks", "ax_i", "yaxis", "set_ticks_position", "right", "for", "t", "in", "ax_i", "yaxis", "majorticks", "t", "tick2line", "set_visible", "maj_on", "for", "t", "in", "ax_i", "yaxis", "minorticks", "t", "tick2line", "set_visible", "min_on", "if", "bottom", "and", "not", "top", "maj_on", "any", "t", "tick1line", "get_visible", "for", "t", "in", "ax_i", "xaxis", "majorticks", "min_on", "any", "t", "tick1line", "get_visible", "for", "t", "in", "ax_i", "xaxis", "minorticks", "ax_i", "xaxis", "set_ticks_position", "top", "for", "t", "in", "ax_i", "xaxis", "majorticks", "t", "tick2line", "set_visible", "maj_on", "for", "t", "in", "ax_i", "xaxis", "minorticks", "t", "tick2line", "set_visible", "min_on", "if", "trim", "clip", "off", "the", "parts", "of", "the", "spines", "that", "extend", "past", "major", "ticks", "xticks", "np", "asarray", "ax_i", "get_xticks", "if", "xticks", "size", "firsttick", "np", "compress", "xticks", "min", "ax_i", "get_xlim", "xticks", "0", "lasttick", "np", "compress", "xticks", "max", "ax_i", "get_xlim", "xticks", "1", "ax_i", "spines", "bottom", "set_bounds", "firsttick", "lasttick", "ax_i", "spines", "top", "set_bounds", "firsttick", "lasttick", "newticks", "xticks", "compress", "xticks", "lasttick", "newticks", "newticks", "compress", "newticks", "firsttick", "ax_i", "set_xticks", "newticks", "yticks", "np", "asarray", "ax_i", "get_yticks", "if", "yticks", "size", "firsttick", "np", "compress", "yticks", "min", "ax_i", "get_ylim", "yticks", "0", "lasttick", "np", "compress", "yticks", "max", "ax_i", "get_ylim", "yticks", "1", "ax_i", "spines", "left", "set_bounds", "firsttick", "lasttick", "ax_i", "spines", "right", "set_bounds", "firsttick", "lasttick", "newticks", "yticks", "compress", "yticks", "lasttick", "newticks", "newticks", "compress", "newticks", "firsttick", "ax_i", "set_yticks", "newticks"], "doc_len": 434}
{"doc_id": "seaborn/utils.py::move_legend", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "move_legend", "text": "文件路径: seaborn/utils.py\ndef move_legend(obj, loc, **kwargs):\n    \"\"\"\n    Recreate a plot's legend at a new location.\n\n    The name is a slight misnomer. Matplotlib legends do not expose public\n    control over their position parameters. So this function creates a new legend,\n    copying over the data from the original object, which is then removed.\n\n    Parameters\n    ----------\n    obj : the object with the plot\n        This argument can be either a seaborn or matplotlib object:\n\n        - :class:`seaborn.FacetGrid` or :class:`seaborn.PairGrid`\n        - :class:`matplotlib.axes.Axes` or :class:`matplotlib.figure.Figure`\n\n    loc : str or int\n        Location argument, as in :meth:`matplotlib.axes.Axes.legend`.\n\n    kwargs\n        Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.legend`.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/move_legend.rst\n\n    \"\"\"\n    # This is a somewhat hackish solution that will hopefully be obviated by\n    # upstream improvements to matplotlib legends that make them easier to\n    # modify after creation.\n\n    from seaborn.axisgrid import Grid  # Avoid circular import\n\n    # Locate the legend object and a method to recreate the legend\n    if isinstance(obj, Grid):\n        old_legend = obj.legend\n        legend_func = obj.figure.legend\n    elif isinstance(obj, mpl.axes.Axes):\n        old_legend = obj.legend_\n        legend_func = obj.legend\n    elif isinstance(obj, mpl.figure.Figure):\n        if obj.legends:\n            old_legend = obj.legends[-1]\n        else:\n            old_legend = None\n        legend_func = obj.legend\n    else:\n        err = \"`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.\"\n        raise TypeError(err)\n\n    if old_legend is None:\n        err = f\"{obj} has no legend attached.\"\n        raise ValueError(err)\n\n    # Extract the components of the legend we need to reuse\n    handles = old_legend.legendHandles\n    labels = [t.get_text() for t in old_legend.get_texts()]\n\n    # Extract legend properties that can be passed to the recreation method\n    # (Vexingly, these don't all round-trip)\n    legend_kws = inspect.signature(mpl.legend.Legend).parameters\n    props = {k: v for k, v in old_legend.properties().items() if k in legend_kws}\n\n    # Delegate default bbox_to_anchor rules to matplotlib\n    props.pop(\"bbox_to_anchor\")\n\n    # Try to propagate the existing title and font properties; respect new ones too\n    title = props.pop(\"title\")\n    if \"title\" in kwargs:\n        title.set_text(kwargs.pop(\"title\"))\n    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith(\"title_\")}\n    for key, val in title_kwargs.items():\n        title.set(**{key[6:]: val})\n        kwargs.pop(key)\n\n    # Try to respect the frame visibility\n    kwargs.setdefault(\"frameon\", old_legend.legendPatch.get_visible())\n\n    # Remove the old legend and create the new one\n    props.update(kwargs)\n    old_legend.remove()\n    new_legend = legend_func(handles, labels, loc=loc, **props)\n    new_legend.set_title(title.get_text(), title.get_fontproperties())\n\n    # Let the Grid object continue to track the correct legend object\n    if isinstance(obj, Grid):\n        obj._legend = new_legend\n", "tokens": ["seaborn", "utils", "py", "def", "move_legend", "obj", "loc", "kwargs", "recreate", "a", "plot", "s", "legend", "at", "a", "new", "location", "the", "name", "is", "a", "slight", "misnomer", "matplotlib", "legends", "do", "not", "expose", "public", "control", "over", "their", "position", "parameters", "so", "this", "function", "creates", "a", "new", "legend", "copying", "over", "the", "data", "from", "the", "original", "object", "which", "is", "then", "removed", "parameters", "obj", "the", "object", "with", "the", "plot", "this", "argument", "can", "be", "either", "a", "seaborn", "or", "matplotlib", "object", "class", "seaborn", "facetgrid", "or", "class", "seaborn", "pairgrid", "class", "matplotlib", "axes", "axes", "or", "class", "matplotlib", "figure", "figure", "loc", "str", "or", "int", "location", "argument", "as", "in", "meth", "matplotlib", "axes", "axes", "legend", "kwargs", "other", "keyword", "arguments", "are", "passed", "to", "meth", "matplotlib", "axes", "axes", "legend", "examples", "include", "docstrings", "move_legend", "rst", "this", "is", "a", "somewhat", "hackish", "solution", "that", "will", "hopefully", "be", "obviated", "by", "upstream", "improvements", "to", "matplotlib", "legends", "that", "make", "them", "easier", "to", "modify", "after", "creation", "from", "seaborn", "axisgrid", "import", "grid", "avoid", "circular", "import", "locate", "the", "legend", "object", "and", "a", "method", "to", "recreate", "the", "legend", "if", "isinstance", "obj", "grid", "old_legend", "obj", "legend", "legend_func", "obj", "figure", "legend", "elif", "isinstance", "obj", "mpl", "axes", "axes", "old_legend", "obj", "legend_", "legend_func", "obj", "legend", "elif", "isinstance", "obj", "mpl", "figure", "figure", "if", "obj", "legends", "old_legend", "obj", "legends", "1", "else", "old_legend", "none", "legend_func", "obj", "legend", "else", "err", "obj", "must", "be", "a", "seaborn", "grid", "or", "matplotlib", "axes", "or", "figure", "instance", "raise", "typeerror", "err", "if", "old_legend", "is", "none", "err", "f", "obj", "has", "no", "legend", "attached", "raise", "valueerror", "err", "extract", "the", "components", "of", "the", "legend", "we", "need", "to", "reuse", "handles", "old_legend", "legendhandles", "labels", "t", "get_text", "for", "t", "in", "old_legend", "get_texts", "extract", "legend", "properties", "that", "can", "be", "passed", "to", "the", "recreation", "method", "vexingly", "these", "don", "t", "all", "round", "trip", "legend_kws", "inspect", "signature", "mpl", "legend", "legend", "parameters", "props", "k", "v", "for", "k", "v", "in", "old_legend", "properties", "items", "if", "k", "in", "legend_kws", "delegate", "default", "bbox_to_anchor", "rules", "to", "matplotlib", "props", "pop", "bbox_to_anchor", "try", "to", "propagate", "the", "existing", "title", "and", "font", "properties", "respect", "new", "ones", "too", "title", "props", "pop", "title", "if", "title", "in", "kwargs", "title", "set_text", "kwargs", "pop", "title", "title_kwargs", "k", "v", "for", "k", "v", "in", "kwargs", "items", "if", "k", "startswith", "title_", "for", "key", "val", "in", "title_kwargs", "items", "title", "set", "key", "6", "val", "kwargs", "pop", "key", "try", "to", "respect", "the", "frame", "visibility", "kwargs", "setdefault", "frameon", "old_legend", "legendpatch", "get_visible", "remove", "the", "old", "legend", "and", "create", "the", "new", "one", "props", "update", "kwargs", "old_legend", "remove", "new_legend", "legend_func", "handles", "labels", "loc", "loc", "props", "new_legend", "set_title", "title", "get_text", "title", "get_fontproperties", "let", "the", "grid", "object", "continue", "to", "track", "the", "correct", "legend", "object", "if", "isinstance", "obj", "grid", "obj", "_legend", "new_legend"], "doc_len": 412}
{"doc_id": "seaborn/utils.py::_kde_support", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_kde_support", "text": "文件路径: seaborn/utils.py\ndef _kde_support(data, bw, gridsize, cut, clip):\n    \"\"\"Establish support for a kernel density estimate.\"\"\"\n    support_min = max(data.min() - bw * cut, clip[0])\n    support_max = min(data.max() + bw * cut, clip[1])\n    support = np.linspace(support_min, support_max, gridsize)\n\n    return support\n", "tokens": ["seaborn", "utils", "py", "def", "_kde_support", "data", "bw", "gridsize", "cut", "clip", "establish", "support", "for", "a", "kernel", "density", "estimate", "support_min", "max", "data", "min", "bw", "cut", "clip", "0", "support_max", "min", "data", "max", "bw", "cut", "clip", "1", "support", "np", "linspace", "support_min", "support_max", "gridsize", "return", "support"], "doc_len": 41}
{"doc_id": "seaborn/utils.py::ci", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "ci", "text": "文件路径: seaborn/utils.py\ndef ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return np.nanpercentile(a, p, axis)\n", "tokens": ["seaborn", "utils", "py", "def", "ci", "a", "which", "95", "axis", "none", "return", "a", "percentile", "range", "from", "an", "array", "of", "values", "p", "50", "which", "2", "50", "which", "2", "return", "np", "nanpercentile", "a", "p", "axis"], "doc_len": 32}
{"doc_id": "seaborn/utils.py::get_dataset_names", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "get_dataset_names", "text": "文件路径: seaborn/utils.py\ndef get_dataset_names():\n    \"\"\"Report available example datasets, useful for reporting issues.\n\n    Requires an internet connection.\n\n    \"\"\"\n    url = \"https://github.com/mwaskom/seaborn-data\"\n    with urlopen(url) as resp:\n        html = resp.read()\n\n    pat = r\"/mwaskom/seaborn-data/blob/master/(\\w*).csv\"\n    datasets = re.findall(pat, html.decode())\n    return datasets\n", "tokens": ["seaborn", "utils", "py", "def", "get_dataset_names", "report", "available", "example", "datasets", "useful", "for", "reporting", "issues", "requires", "an", "internet", "connection", "url", "https", "github", "com", "mwaskom", "seaborn", "data", "with", "urlopen", "url", "as", "resp", "html", "resp", "read", "pat", "r", "mwaskom", "seaborn", "data", "blob", "master", "w", "csv", "datasets", "re", "findall", "pat", "html", "decode", "return", "datasets"], "doc_len": 49}
{"doc_id": "seaborn/utils.py::get_data_home", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "get_data_home", "text": "文件路径: seaborn/utils.py\ndef get_data_home(data_home=None):\n    \"\"\"Return a path to the cache directory for example datasets.\n\n    This directory is used by :func:`load_dataset`.\n\n    If the ``data_home`` argument is not provided, it will use a directory\n    specified by the `SEABORN_DATA` environment variable (if it exists)\n    or otherwise default to an OS-appropriate user cache location.\n\n    \"\"\"\n    if data_home is None:\n        data_home = os.environ.get(\"SEABORN_DATA\", user_cache_dir(\"seaborn\"))\n    data_home = os.path.expanduser(data_home)\n    if not os.path.exists(data_home):\n        os.makedirs(data_home)\n    return data_home\n", "tokens": ["seaborn", "utils", "py", "def", "get_data_home", "data_home", "none", "return", "a", "path", "to", "the", "cache", "directory", "for", "example", "datasets", "this", "directory", "is", "used", "by", "func", "load_dataset", "if", "the", "data_home", "argument", "is", "not", "provided", "it", "will", "use", "a", "directory", "specified", "by", "the", "seaborn_data", "environment", "variable", "if", "it", "exists", "or", "otherwise", "default", "to", "an", "os", "appropriate", "user", "cache", "location", "if", "data_home", "is", "none", "data_home", "os", "environ", "get", "seaborn_data", "user_cache_dir", "seaborn", "data_home", "os", "path", "expanduser", "data_home", "if", "not", "os", "path", "exists", "data_home", "os", "makedirs", "data_home", "return", "data_home"], "doc_len": 82}
{"doc_id": "seaborn/utils.py::load_dataset", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "load_dataset", "text": "文件路径: seaborn/utils.py\ndef load_dataset(name, cache=True, data_home=None, **kws):\n    \"\"\"Load an example dataset from the online repository (requires internet).\n\n    This function provides quick access to a small number of example datasets\n    that are useful for documenting seaborn or generating reproducible examples\n    for bug reports. It is not necessary for normal usage.\n\n    Note that some of the datasets have a small amount of preprocessing applied\n    to define a proper ordering for categorical variables.\n\n    Use :func:`get_dataset_names` to see a list of available datasets.\n\n    Parameters\n    ----------\n    name : str\n        Name of the dataset (``{name}.csv`` on\n        https://github.com/mwaskom/seaborn-data).\n    cache : boolean, optional\n        If True, try to load from the local cache first, and save to the cache\n        if a download is required.\n    data_home : string, optional\n        The directory in which to cache data; see :func:`get_data_home`.\n    kws : keys and values, optional\n        Additional keyword arguments are passed to passed through to\n        :func:`pandas.read_csv`.\n\n    Returns\n    -------\n    df : :class:`pandas.DataFrame`\n        Tabular data, possibly with some preprocessing applied.\n\n    \"\"\"\n    # A common beginner mistake is to assume that one's personal data needs\n    # to be passed through this function to be usable with seaborn.\n    # Let's provide a more helpful error than you would otherwise get.\n    if isinstance(name, pd.DataFrame):\n        err = (\n            \"This function accepts only strings (the name of an example dataset). \"\n            \"You passed a pandas DataFrame. If you have your own dataset, \"\n            \"it is not necessary to use this function before plotting.\"\n        )\n        raise TypeError(err)\n\n    url = f\"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/{name}.csv\"\n\n    if cache:\n        cache_path = os.path.join(get_data_home(data_home), os.path.basename(url))\n        if not os.path.exists(cache_path):\n            if name not in get_dataset_names():\n                raise ValueError(f\"'{name}' is not one of the example datasets.\")\n            urlretrieve(url, cache_path)\n        full_path = cache_path\n    else:\n        full_path = url\n\n    df = pd.read_csv(full_path, **kws)\n\n    if df.iloc[-1].isnull().all():\n        df = df.iloc[:-1]\n\n    # Set some columns as a categorical type with ordered levels\n\n    if name == \"tips\":\n        df[\"day\"] = pd.Categorical(df[\"day\"], [\"Thur\", \"Fri\", \"Sat\", \"Sun\"])\n        df[\"sex\"] = pd.Categorical(df[\"sex\"], [\"Male\", \"Female\"])\n        df[\"time\"] = pd.Categorical(df[\"time\"], [\"Lunch\", \"Dinner\"])\n        df[\"smoker\"] = pd.Categorical(df[\"smoker\"], [\"Yes\", \"No\"])\n\n    elif name == \"flights\":\n        months = df[\"month\"].str[:3]\n        df[\"month\"] = pd.Categorical(months, months.unique())\n\n    elif name == \"exercise\":\n        df[\"time\"] = pd.Categorical(df[\"time\"], [\"1 min\", \"15 min\", \"30 min\"])\n        df[\"kind\"] = pd.Categorical(df[\"kind\"], [\"rest\", \"walking\", \"running\"])\n        df[\"diet\"] = pd.Categorical(df[\"diet\"], [\"no fat\", \"low fat\"])\n\n    elif name == \"titanic\":\n        df[\"class\"] = pd.Categorical(df[\"class\"], [\"First\", \"Second\", \"Third\"])\n        df[\"deck\"] = pd.Categorical(df[\"deck\"], list(\"ABCDEFG\"))\n\n    elif name == \"penguins\":\n        df[\"sex\"] = df[\"sex\"].str.title()\n\n    elif name == \"diamonds\":\n        df[\"color\"] = pd.Categorical(\n            df[\"color\"], [\"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"],\n        )\n        df[\"clarity\"] = pd.Categorical(\n            df[\"clarity\"], [\"IF\", \"VVS1\", \"VVS2\", \"VS1\", \"VS2\", \"SI1\", \"SI2\", \"I1\"],\n        )\n        df[\"cut\"] = pd.Categorical(\n            df[\"cut\"], [\"Ideal\", \"Premium\", \"Very Good\", \"Good\", \"Fair\"],\n        )\n\n    elif name == \"taxis\":\n        df[\"pickup\"] = pd.to_datetime(df[\"pickup\"])\n        df[\"dropoff\"] = pd.to_datetime(df[\"dropoff\"])\n\n    elif name == \"seaice\":\n        df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n\n    elif name == \"dowjones\":\n        df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n\n    return df\n", "tokens": ["seaborn", "utils", "py", "def", "load_dataset", "name", "cache", "true", "data_home", "none", "kws", "load", "an", "example", "dataset", "from", "the", "online", "repository", "requires", "internet", "this", "function", "provides", "quick", "access", "to", "a", "small", "number", "of", "example", "datasets", "that", "are", "useful", "for", "documenting", "seaborn", "or", "generating", "reproducible", "examples", "for", "bug", "reports", "it", "is", "not", "necessary", "for", "normal", "usage", "note", "that", "some", "of", "the", "datasets", "have", "a", "small", "amount", "of", "preprocessing", "applied", "to", "define", "a", "proper", "ordering", "for", "categorical", "variables", "use", "func", "get_dataset_names", "to", "see", "a", "list", "of", "available", "datasets", "parameters", "name", "str", "name", "of", "the", "dataset", "name", "csv", "on", "https", "github", "com", "mwaskom", "seaborn", "data", "cache", "boolean", "optional", "if", "true", "try", "to", "load", "from", "the", "local", "cache", "first", "and", "save", "to", "the", "cache", "if", "a", "download", "is", "required", "data_home", "string", "optional", "the", "directory", "in", "which", "to", "cache", "data", "see", "func", "get_data_home", "kws", "keys", "and", "values", "optional", "additional", "keyword", "arguments", "are", "passed", "to", "passed", "through", "to", "func", "pandas", "read_csv", "returns", "df", "class", "pandas", "dataframe", "tabular", "data", "possibly", "with", "some", "preprocessing", "applied", "a", "common", "beginner", "mistake", "is", "to", "assume", "that", "one", "s", "personal", "data", "needs", "to", "be", "passed", "through", "this", "function", "to", "be", "usable", "with", "seaborn", "let", "s", "provide", "a", "more", "helpful", "error", "than", "you", "would", "otherwise", "get", "if", "isinstance", "name", "pd", "dataframe", "err", "this", "function", "accepts", "only", "strings", "the", "name", "of", "an", "example", "dataset", "you", "passed", "a", "pandas", "dataframe", "if", "you", "have", "your", "own", "dataset", "it", "is", "not", "necessary", "to", "use", "this", "function", "before", "plotting", "raise", "typeerror", "err", "url", "f", "https", "raw", "githubusercontent", "com", "mwaskom", "seaborn", "data", "master", "name", "csv", "if", "cache", "cache_path", "os", "path", "join", "get_data_home", "data_home", "os", "path", "basename", "url", "if", "not", "os", "path", "exists", "cache_path", "if", "name", "not", "in", "get_dataset_names", "raise", "valueerror", "f", "name", "is", "not", "one", "of", "the", "example", "datasets", "urlretrieve", "url", "cache_path", "full_path", "cache_path", "else", "full_path", "url", "df", "pd", "read_csv", "full_path", "kws", "if", "df", "iloc", "1", "isnull", "all", "df", "df", "iloc", "1", "set", "some", "columns", "as", "a", "categorical", "type", "with", "ordered", "levels", "if", "name", "tips", "df", "day", "pd", "categorical", "df", "day", "thur", "fri", "sat", "sun", "df", "sex", "pd", "categorical", "df", "sex", "male", "female", "df", "time", "pd", "categorical", "df", "time", "lunch", "dinner", "df", "smoker", "pd", "categorical", "df", "smoker", "yes", "no", "elif", "name", "flights", "months", "df", "month", "str", "3", "df", "month", "pd", "categorical", "months", "months", "unique", "elif", "name", "exercise", "df", "time", "pd", "categorical", "df", "time", "1", "min", "15", "min", "30", "min", "df", "kind", "pd", "categorical", "df", "kind", "rest", "walking", "running", "df", "diet", "pd", "categorical", "df", "diet", "no", "fat", "low", "fat", "elif", "name", "titanic", "df", "class", "pd", "categorical", "df", "class", "first", "second", "third", "df", "deck", "pd", "categorical", "df", "deck", "list", "abcdefg", "elif", "name", "penguins", "df", "sex", "df", "sex", "str", "title", "elif", "name", "diamonds", "df", "color", "pd", "categorical", "df", "color", "d", "e", "f", "g", "h", "i", "j", "df", "clarity", "pd", "categorical", "df", "clarity", "if", "vvs1", "vvs2", "vs1", "vs2", "si1", "si2", "i1", "df", "cut", "pd", "categorical", "df", "cut", "ideal", "premium", "very", "good", "good", "fair", "elif", "name", "taxis", "df", "pickup", "pd", "to_datetime", "df", "pickup", "df", "dropoff", "pd", "to_datetime", "df", "dropoff", "elif", "name", "seaice", "df", "date", "pd", "to_datetime", "df", "date", "elif", "name", "dowjones", "df", "date", "pd", "to_datetime", "df", "date", "return", "df"], "doc_len": 513}
{"doc_id": "seaborn/utils.py::axis_ticklabels_overlap", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "axis_ticklabels_overlap", "text": "文件路径: seaborn/utils.py\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        # Issue on macos backend raises an error in the above code\n        return False\n", "tokens": ["seaborn", "utils", "py", "def", "axis_ticklabels_overlap", "labels", "return", "a", "boolean", "for", "whether", "the", "list", "of", "ticklabels", "have", "overlaps", "parameters", "labels", "list", "of", "matplotlib", "ticklabels", "returns", "overlap", "boolean", "true", "if", "any", "of", "the", "labels", "overlap", "if", "not", "labels", "return", "false", "try", "bboxes", "l", "get_window_extent", "for", "l", "in", "labels", "overlaps", "b", "count_overlaps", "bboxes", "for", "b", "in", "bboxes", "return", "max", "overlaps", "1", "except", "runtimeerror", "issue", "on", "macos", "backend", "raises", "an", "error", "in", "the", "above", "code", "return", "false"], "doc_len": 73}
{"doc_id": "seaborn/utils.py::axes_ticklabels_overlap", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "axes_ticklabels_overlap", "text": "文件路径: seaborn/utils.py\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Return booleans for whether the x and y ticklabels on an Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        True when the labels on that axis overlap.\n\n    \"\"\"\n    return (axis_ticklabels_overlap(ax.get_xticklabels()),\n            axis_ticklabels_overlap(ax.get_yticklabels()))\n", "tokens": ["seaborn", "utils", "py", "def", "axes_ticklabels_overlap", "ax", "return", "booleans", "for", "whether", "the", "x", "and", "y", "ticklabels", "on", "an", "axes", "overlap", "parameters", "ax", "matplotlib", "axes", "returns", "x_overlap", "y_overlap", "booleans", "true", "when", "the", "labels", "on", "that", "axis", "overlap", "return", "axis_ticklabels_overlap", "ax", "get_xticklabels", "axis_ticklabels_overlap", "ax", "get_yticklabels"], "doc_len": 42}
{"doc_id": "seaborn/utils.py::locator_to_legend_entries", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "locator_to_legend_entries", "text": "文件路径: seaborn/utils.py\ndef locator_to_legend_entries(locator, limits, dtype):\n    \"\"\"Return levels and formatted levels for brief numeric legends.\"\"\"\n    raw_levels = locator.tick_values(*limits).astype(dtype)\n\n    # The locator can return ticks outside the limits, clip them here\n    raw_levels = [l for l in raw_levels if l >= limits[0] and l <= limits[1]]\n\n    class dummy_axis:\n        def get_view_interval(self):\n            return limits\n\n    if isinstance(locator, mpl.ticker.LogLocator):\n        formatter = mpl.ticker.LogFormatter()\n    else:\n        formatter = mpl.ticker.ScalarFormatter()\n        # Avoid having an offset/scientific notation which we don't currently\n        # have any way of representing in the legend\n        formatter.set_useOffset(False)\n        formatter.set_scientific(False)\n    formatter.axis = dummy_axis()\n\n    # TODO: The following two lines should be replaced\n    # once pinned matplotlib>=3.1.0 with:\n    # formatted_levels = formatter.format_ticks(raw_levels)\n    formatter.set_locs(raw_levels)\n    formatted_levels = [formatter(x) for x in raw_levels]\n\n    return raw_levels, formatted_levels\n", "tokens": ["seaborn", "utils", "py", "def", "locator_to_legend_entries", "locator", "limits", "dtype", "return", "levels", "and", "formatted", "levels", "for", "brief", "numeric", "legends", "raw_levels", "locator", "tick_values", "limits", "astype", "dtype", "the", "locator", "can", "return", "ticks", "outside", "the", "limits", "clip", "them", "here", "raw_levels", "l", "for", "l", "in", "raw_levels", "if", "l", "limits", "0", "and", "l", "limits", "1", "class", "dummy_axis", "def", "get_view_interval", "self", "return", "limits", "if", "isinstance", "locator", "mpl", "ticker", "loglocator", "formatter", "mpl", "ticker", "logformatter", "else", "formatter", "mpl", "ticker", "scalarformatter", "avoid", "having", "an", "offset", "scientific", "notation", "which", "we", "don", "t", "currently", "have", "any", "way", "of", "representing", "in", "the", "legend", "formatter", "set_useoffset", "false", "formatter", "set_scientific", "false", "formatter", "axis", "dummy_axis", "todo", "the", "following", "two", "lines", "should", "be", "replaced", "once", "pinned", "matplotlib", "3", "1", "0", "with", "formatted_levels", "formatter", "format_ticks", "raw_levels", "formatter", "set_locs", "raw_levels", "formatted_levels", "formatter", "x", "for", "x", "in", "raw_levels", "return", "raw_levels", "formatted_levels"], "doc_len": 130}
{"doc_id": "seaborn/utils.py::relative_luminance", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "relative_luminance", "text": "文件路径: seaborn/utils.py\ndef relative_luminance(color):\n    \"\"\"Calculate the relative luminance of a color according to W3C standards\n\n    Parameters\n    ----------\n    color : matplotlib color or sequence of matplotlib colors\n        Hex code, rgb-tuple, or html color name.\n\n    Returns\n    -------\n    luminance : float(s) between 0 and 1\n\n    \"\"\"\n    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]\n    rgb = np.where(rgb <= .03928, rgb / 12.92, ((rgb + .055) / 1.055) ** 2.4)\n    lum = rgb.dot([.2126, .7152, .0722])\n    try:\n        return lum.item()\n    except ValueError:\n        return lum\n", "tokens": ["seaborn", "utils", "py", "def", "relative_luminance", "color", "calculate", "the", "relative", "luminance", "of", "a", "color", "according", "to", "w3c", "standards", "parameters", "color", "matplotlib", "color", "or", "sequence", "of", "matplotlib", "colors", "hex", "code", "rgb", "tuple", "or", "html", "color", "name", "returns", "luminance", "float", "s", "between", "0", "and", "1", "rgb", "mpl", "colors", "colorconverter", "to_rgba_array", "color", "3", "rgb", "np", "where", "rgb", "03928", "rgb", "12", "92", "rgb", "055", "1", "055", "2", "4", "lum", "rgb", "dot", "2126", "7152", "0722", "try", "return", "lum", "item", "except", "valueerror", "return", "lum"], "doc_len": 77}
{"doc_id": "seaborn/utils.py::to_utf8", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "to_utf8", "text": "文件路径: seaborn/utils.py\ndef to_utf8(obj):\n    \"\"\"Return a string representing a Python object.\n\n    Strings (i.e. type ``str``) are returned unchanged.\n\n    Byte strings (i.e. type ``bytes``) are returned as UTF-8-decoded strings.\n\n    For other objects, the method ``__str__()`` is called, and the result is\n    returned as a string.\n\n    Parameters\n    ----------\n    obj : object\n        Any Python object\n\n    Returns\n    -------\n    s : str\n        UTF-8-decoded string representation of ``obj``\n\n    \"\"\"\n    if isinstance(obj, str):\n        return obj\n    try:\n        return obj.decode(encoding=\"utf-8\")\n    except AttributeError:  # obj is not bytes-like\n        return str(obj)\n", "tokens": ["seaborn", "utils", "py", "def", "to_utf8", "obj", "return", "a", "string", "representing", "a", "python", "object", "strings", "i", "e", "type", "str", "are", "returned", "unchanged", "byte", "strings", "i", "e", "type", "bytes", "are", "returned", "as", "utf", "8", "decoded", "strings", "for", "other", "objects", "the", "method", "__str__", "is", "called", "and", "the", "result", "is", "returned", "as", "a", "string", "parameters", "obj", "object", "any", "python", "object", "returns", "s", "str", "utf", "8", "decoded", "string", "representation", "of", "obj", "if", "isinstance", "obj", "str", "return", "obj", "try", "return", "obj", "decode", "encoding", "utf", "8", "except", "attributeerror", "obj", "is", "not", "bytes", "like", "return", "str", "obj"], "doc_len": 89}
{"doc_id": "seaborn/utils.py::_normalize_kwargs", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_normalize_kwargs", "text": "文件路径: seaborn/utils.py\ndef _normalize_kwargs(kws, artist):\n    \"\"\"Wrapper for mpl.cbook.normalize_kwargs that supports <= 3.2.1.\"\"\"\n    _alias_map = {\n        'color': ['c'],\n        'linewidth': ['lw'],\n        'linestyle': ['ls'],\n        'facecolor': ['fc'],\n        'edgecolor': ['ec'],\n        'markerfacecolor': ['mfc'],\n        'markeredgecolor': ['mec'],\n        'markeredgewidth': ['mew'],\n        'markersize': ['ms']\n    }\n    try:\n        kws = normalize_kwargs(kws, artist)\n    except AttributeError:\n        kws = normalize_kwargs(kws, _alias_map)\n    return kws\n", "tokens": ["seaborn", "utils", "py", "def", "_normalize_kwargs", "kws", "artist", "wrapper", "for", "mpl", "cbook", "normalize_kwargs", "that", "supports", "3", "2", "1", "_alias_map", "color", "c", "linewidth", "lw", "linestyle", "ls", "facecolor", "fc", "edgecolor", "ec", "markerfacecolor", "mfc", "markeredgecolor", "mec", "markeredgewidth", "mew", "markersize", "ms", "try", "kws", "normalize_kwargs", "kws", "artist", "except", "attributeerror", "kws", "normalize_kwargs", "kws", "_alias_map", "return", "kws"], "doc_len": 49}
{"doc_id": "seaborn/utils.py::_check_argument", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_check_argument", "text": "文件路径: seaborn/utils.py\ndef _check_argument(param, options, value):\n    \"\"\"Raise if value for param is not in options.\"\"\"\n    if value not in options:\n        raise ValueError(\n            f\"`{param}` must be one of {options}, but {repr(value)} was passed.\"\n        )\n", "tokens": ["seaborn", "utils", "py", "def", "_check_argument", "param", "options", "value", "raise", "if", "value", "for", "param", "is", "not", "in", "options", "if", "value", "not", "in", "options", "raise", "valueerror", "f", "param", "must", "be", "one", "of", "options", "but", "repr", "value", "was", "passed"], "doc_len": 36}
{"doc_id": "seaborn/utils.py::_assign_default_kwargs", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_assign_default_kwargs", "text": "文件路径: seaborn/utils.py\ndef _assign_default_kwargs(kws, call_func, source_func):\n    \"\"\"Assign default kwargs for call_func using values from source_func.\"\"\"\n    # This exists so that axes-level functions and figure-level functions can\n    # both call a Plotter method while having the default kwargs be defined in\n    # the signature of the axes-level function.\n    # An alternative would be to have a decorator on the method that sets its\n    # defaults based on those defined in the axes-level function.\n    # Then the figure-level function would not need to worry about defaults.\n    # I am not sure which is better.\n    needed = inspect.signature(call_func).parameters\n    defaults = inspect.signature(source_func).parameters\n\n    for param in needed:\n        if param in defaults and param not in kws:\n            kws[param] = defaults[param].default\n\n    return kws\n", "tokens": ["seaborn", "utils", "py", "def", "_assign_default_kwargs", "kws", "call_func", "source_func", "assign", "default", "kwargs", "for", "call_func", "using", "values", "from", "source_func", "this", "exists", "so", "that", "axes", "level", "functions", "and", "figure", "level", "functions", "can", "both", "call", "a", "plotter", "method", "while", "having", "the", "default", "kwargs", "be", "defined", "in", "the", "signature", "of", "the", "axes", "level", "function", "an", "alternative", "would", "be", "to", "have", "a", "decorator", "on", "the", "method", "that", "sets", "its", "defaults", "based", "on", "those", "defined", "in", "the", "axes", "level", "function", "then", "the", "figure", "level", "function", "would", "not", "need", "to", "worry", "about", "defaults", "i", "am", "not", "sure", "which", "is", "better", "needed", "inspect", "signature", "call_func", "parameters", "defaults", "inspect", "signature", "source_func", "parameters", "for", "param", "in", "needed", "if", "param", "in", "defaults", "and", "param", "not", "in", "kws", "kws", "param", "defaults", "param", "default", "return", "kws"], "doc_len": 122}
{"doc_id": "seaborn/utils.py::adjust_legend_subtitles", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "adjust_legend_subtitles", "text": "文件路径: seaborn/utils.py\ndef adjust_legend_subtitles(legend):\n    \"\"\"\n    Make invisible-handle \"subtitles\" entries look more like titles.\n\n    Note: This function is not part of the public API and may be changed or removed.\n\n    \"\"\"\n    # Legend title not in rcParams until 3.0\n    font_size = plt.rcParams.get(\"legend.title_fontsize\", None)\n    hpackers = legend.findobj(mpl.offsetbox.VPacker)[0].get_children()\n    for hpack in hpackers:\n        draw_area, text_area = hpack.get_children()\n        handles = draw_area.get_children()\n        if not all(artist.get_visible() for artist in handles):\n            draw_area.set_width(0)\n            for text in text_area.get_children():\n                if font_size is not None:\n                    text.set_size(font_size)\n", "tokens": ["seaborn", "utils", "py", "def", "adjust_legend_subtitles", "legend", "make", "invisible", "handle", "subtitles", "entries", "look", "more", "like", "titles", "note", "this", "function", "is", "not", "part", "of", "the", "public", "api", "and", "may", "be", "changed", "or", "removed", "legend", "title", "not", "in", "rcparams", "until", "3", "0", "font_size", "plt", "rcparams", "get", "legend", "title_fontsize", "none", "hpackers", "legend", "findobj", "mpl", "offsetbox", "vpacker", "0", "get_children", "for", "hpack", "in", "hpackers", "draw_area", "text_area", "hpack", "get_children", "handles", "draw_area", "get_children", "if", "not", "all", "artist", "get_visible", "for", "artist", "in", "handles", "draw_area", "set_width", "0", "for", "text", "in", "text_area", "get_children", "if", "font_size", "is", "not", "none", "text", "set_size", "font_size"], "doc_len": 90}
{"doc_id": "seaborn/utils.py::_deprecate_ci", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_deprecate_ci", "text": "文件路径: seaborn/utils.py\ndef _deprecate_ci(errorbar, ci):\n    \"\"\"\n    Warn on usage of ci= and convert to appropriate errorbar= arg.\n\n    ci was deprecated when errorbar was added in 0.12. It should not be removed\n    completely for some time, but it can be moved out of function definitions\n    (and extracted from kwargs) after one cycle.\n\n    \"\"\"\n    if ci != \"deprecated\":\n        if ci is None:\n            errorbar = None\n        elif ci == \"sd\":\n            errorbar = \"sd\"\n        else:\n            errorbar = (\"ci\", ci)\n        msg = (\n            \"\\n\\nThe `ci` parameter is deprecated. \"\n            f\"Use `errorbar={repr(errorbar)}` for the same effect.\\n\"\n        )\n        warnings.warn(msg, FutureWarning, stacklevel=3)\n\n    return errorbar\n", "tokens": ["seaborn", "utils", "py", "def", "_deprecate_ci", "errorbar", "ci", "warn", "on", "usage", "of", "ci", "and", "convert", "to", "appropriate", "errorbar", "arg", "ci", "was", "deprecated", "when", "errorbar", "was", "added", "in", "0", "12", "it", "should", "not", "be", "removed", "completely", "for", "some", "time", "but", "it", "can", "be", "moved", "out", "of", "function", "definitions", "and", "extracted", "from", "kwargs", "after", "one", "cycle", "if", "ci", "deprecated", "if", "ci", "is", "none", "errorbar", "none", "elif", "ci", "sd", "errorbar", "sd", "else", "errorbar", "ci", "ci", "msg", "n", "nthe", "ci", "parameter", "is", "deprecated", "f", "use", "errorbar", "repr", "errorbar", "for", "the", "same", "effect", "n", "warnings", "warn", "msg", "futurewarning", "stacklevel", "3", "return", "errorbar"], "doc_len": 96}
{"doc_id": "seaborn/utils.py::_disable_autolayout", "file_path": "seaborn/utils.py", "class_name": null, "func_name": "_disable_autolayout", "text": "文件路径: seaborn/utils.py\ndef _disable_autolayout():\n    \"\"\"Context manager for preventing rc-controlled auto-layout behavior.\"\"\"\n    # This is a workaround for an issue in matplotlib, for details see\n    # https://github.com/mwaskom/seaborn/issues/2914\n    # The only affect of this rcParam is to set the default value for\n    # layout= in plt.figure, so we could just do that instead.\n    # But then we would need to own the complexity of the transition\n    # from tight_layout=True -> layout=\"tight\". This seems easier,\n    # but can be removed when (if) that is simpler on the matplotlib side,\n    # or if the layout algorithms are improved to handle figure legends.\n    orig_val = mpl.rcParams[\"figure.autolayout\"]\n    try:\n        mpl.rcParams[\"figure.autolayout\"] = False\n        yield\n    finally:\n        mpl.rcParams[\"figure.autolayout\"] = orig_val\n", "tokens": ["seaborn", "utils", "py", "def", "_disable_autolayout", "context", "manager", "for", "preventing", "rc", "controlled", "auto", "layout", "behavior", "this", "is", "a", "workaround", "for", "an", "issue", "in", "matplotlib", "for", "details", "see", "https", "github", "com", "mwaskom", "seaborn", "issues", "2914", "the", "only", "affect", "of", "this", "rcparam", "is", "to", "set", "the", "default", "value", "for", "layout", "in", "plt", "figure", "so", "we", "could", "just", "do", "that", "instead", "but", "then", "we", "would", "need", "to", "own", "the", "complexity", "of", "the", "transition", "from", "tight_layout", "true", "layout", "tight", "this", "seems", "easier", "but", "can", "be", "removed", "when", "if", "that", "is", "simpler", "on", "the", "matplotlib", "side", "or", "if", "the", "layout", "algorithms", "are", "improved", "to", "handle", "figure", "legends", "orig_val", "mpl", "rcparams", "figure", "autolayout", "try", "mpl", "rcparams", "figure", "autolayout", "false", "yield", "finally", "mpl", "rcparams", "figure", "autolayout", "orig_val"], "doc_len": 119}
{"doc_id": "seaborn/widgets.py::_init_mutable_colormap", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "_init_mutable_colormap", "text": "文件路径: seaborn/widgets.py\ndef _init_mutable_colormap():\n    \"\"\"Create a matplotlib colormap that will be updated by the widgets.\"\"\"\n    greys = color_palette(\"Greys\", 256)\n    cmap = LinearSegmentedColormap.from_list(\"interactive\", greys)\n    cmap._init()\n    cmap._set_extremes()\n    return cmap\n", "tokens": ["seaborn", "widgets", "py", "def", "_init_mutable_colormap", "create", "a", "matplotlib", "colormap", "that", "will", "be", "updated", "by", "the", "widgets", "greys", "color_palette", "greys", "256", "cmap", "linearsegmentedcolormap", "from_list", "interactive", "greys", "cmap", "_init", "cmap", "_set_extremes", "return", "cmap"], "doc_len": 31}
{"doc_id": "seaborn/widgets.py::_update_lut", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "_update_lut", "text": "文件路径: seaborn/widgets.py\ndef _update_lut(cmap, colors):\n    \"\"\"Change the LUT values in a matplotlib colormap in-place.\"\"\"\n    cmap._lut[:256] = colors\n    cmap._set_extremes()\n", "tokens": ["seaborn", "widgets", "py", "def", "_update_lut", "cmap", "colors", "change", "the", "lut", "values", "in", "a", "matplotlib", "colormap", "in", "place", "cmap", "_lut", "256", "colors", "cmap", "_set_extremes"], "doc_len": 23}
{"doc_id": "seaborn/widgets.py::_show_cmap", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "_show_cmap", "text": "文件路径: seaborn/widgets.py\ndef _show_cmap(cmap):\n    \"\"\"Show a continuous matplotlib colormap.\"\"\"\n    from .rcmod import axes_style  # Avoid circular import\n    with axes_style(\"white\"):\n        f, ax = plt.subplots(figsize=(8.25, .75))\n    ax.set(xticks=[], yticks=[])\n    x = np.linspace(0, 1, 256)[np.newaxis, :]\n    ax.pcolormesh(x, cmap=cmap)\n", "tokens": ["seaborn", "widgets", "py", "def", "_show_cmap", "cmap", "show", "a", "continuous", "matplotlib", "colormap", "from", "rcmod", "import", "axes_style", "avoid", "circular", "import", "with", "axes_style", "white", "f", "ax", "plt", "subplots", "figsize", "8", "25", "75", "ax", "set", "xticks", "yticks", "x", "np", "linspace", "0", "1", "256", "np", "newaxis", "ax", "pcolormesh", "x", "cmap", "cmap"], "doc_len": 46}
{"doc_id": "seaborn/widgets.py::choose_colorbrewer_palette", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "choose_colorbrewer_palette", "text": "文件路径: seaborn/widgets.py\ndef choose_colorbrewer_palette(data_type, as_cmap=False):\n    \"\"\"Select a palette from the ColorBrewer set.\n\n    These palettes are built into matplotlib and can be used by name in\n    many seaborn functions, or by passing the object returned by this function.\n\n    Parameters\n    ----------\n    data_type : {'sequential', 'diverging', 'qualitative'}\n        This describes the kind of data you want to visualize. See the seaborn\n        color palette docs for more information about how to choose this value.\n        Note that you can pass substrings (e.g. 'q' for 'qualitative.\n\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette from selected colors.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n\n    \"\"\"\n    if data_type.startswith(\"q\") and as_cmap:\n        raise ValueError(\"Qualitative palettes cannot be colormaps.\")\n\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if data_type.startswith(\"s\"):\n        opts = [\"Greys\", \"Reds\", \"Greens\", \"Blues\", \"Oranges\", \"Purples\",\n                \"BuGn\", \"BuPu\", \"GnBu\", \"OrRd\", \"PuBu\", \"PuRd\", \"RdPu\", \"YlGn\",\n                \"PuBuGn\", \"YlGnBu\", \"YlOrBr\", \"YlOrRd\"]\n        variants = [\"regular\", \"reverse\", \"dark\"]\n\n        @interact\n        def choose_sequential(name=opts, n=(2, 18),\n                              desat=FloatSlider(min=0, max=1, value=1),\n                              variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            elif variant == \"dark\":\n                name += \"_d\"\n\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"d\"):\n        opts = [\"RdBu\", \"RdGy\", \"PRGn\", \"PiYG\", \"BrBG\",\n                \"RdYlBu\", \"RdYlGn\", \"Spectral\"]\n        variants = [\"regular\", \"reverse\"]\n\n        @interact\n        def choose_diverging(name=opts, n=(2, 16),\n                             desat=FloatSlider(min=0, max=1, value=1),\n                             variant=variants):\n            if variant == \"reverse\":\n                name += \"_r\"\n            if as_cmap:\n                colors = color_palette(name, 256, desat)\n                _update_lut(cmap, np.c_[colors, np.ones(256)])\n                _show_cmap(cmap)\n            else:\n                pal[:] = color_palette(name, n, desat)\n                palplot(pal)\n\n    elif data_type.startswith(\"q\"):\n        opts = [\"Set1\", \"Set2\", \"Set3\", \"Paired\", \"Accent\",\n                \"Pastel1\", \"Pastel2\", \"Dark2\"]\n\n        @interact\n        def choose_qualitative(name=opts, n=(2, 16),\n                               desat=FloatSlider(min=0, max=1, value=1)):\n            pal[:] = color_palette(name, n, desat)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "tokens": ["seaborn", "widgets", "py", "def", "choose_colorbrewer_palette", "data_type", "as_cmap", "false", "select", "a", "palette", "from", "the", "colorbrewer", "set", "these", "palettes", "are", "built", "into", "matplotlib", "and", "can", "be", "used", "by", "name", "in", "many", "seaborn", "functions", "or", "by", "passing", "the", "object", "returned", "by", "this", "function", "parameters", "data_type", "sequential", "diverging", "qualitative", "this", "describes", "the", "kind", "of", "data", "you", "want", "to", "visualize", "see", "the", "seaborn", "color", "palette", "docs", "for", "more", "information", "about", "how", "to", "choose", "this", "value", "note", "that", "you", "can", "pass", "substrings", "e", "g", "q", "for", "qualitative", "as_cmap", "bool", "if", "true", "the", "return", "value", "is", "a", "matplotlib", "colormap", "rather", "than", "a", "list", "of", "discrete", "colors", "returns", "pal", "or", "cmap", "list", "of", "colors", "or", "matplotlib", "colormap", "object", "that", "can", "be", "passed", "to", "plotting", "functions", "see", "also", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "low", "values", "light_palette", "create", "a", "sequential", "palette", "with", "bright", "low", "values", "diverging_palette", "create", "a", "diverging", "palette", "from", "selected", "colors", "cubehelix_palette", "create", "a", "sequential", "palette", "or", "colormap", "using", "the", "cubehelix", "system", "if", "data_type", "startswith", "q", "and", "as_cmap", "raise", "valueerror", "qualitative", "palettes", "cannot", "be", "colormaps", "pal", "if", "as_cmap", "cmap", "_init_mutable_colormap", "if", "data_type", "startswith", "s", "opts", "greys", "reds", "greens", "blues", "oranges", "purples", "bugn", "bupu", "gnbu", "orrd", "pubu", "purd", "rdpu", "ylgn", "pubugn", "ylgnbu", "ylorbr", "ylorrd", "variants", "regular", "reverse", "dark", "interact", "def", "choose_sequential", "name", "opts", "n", "2", "18", "desat", "floatslider", "min", "0", "max", "1", "value", "1", "variant", "variants", "if", "variant", "reverse", "name", "_r", "elif", "variant", "dark", "name", "_d", "if", "as_cmap", "colors", "color_palette", "name", "256", "desat", "_update_lut", "cmap", "np", "c_", "colors", "np", "ones", "256", "_show_cmap", "cmap", "else", "pal", "color_palette", "name", "n", "desat", "palplot", "pal", "elif", "data_type", "startswith", "d", "opts", "rdbu", "rdgy", "prgn", "piyg", "brbg", "rdylbu", "rdylgn", "spectral", "variants", "regular", "reverse", "interact", "def", "choose_diverging", "name", "opts", "n", "2", "16", "desat", "floatslider", "min", "0", "max", "1", "value", "1", "variant", "variants", "if", "variant", "reverse", "name", "_r", "if", "as_cmap", "colors", "color_palette", "name", "256", "desat", "_update_lut", "cmap", "np", "c_", "colors", "np", "ones", "256", "_show_cmap", "cmap", "else", "pal", "color_palette", "name", "n", "desat", "palplot", "pal", "elif", "data_type", "startswith", "q", "opts", "set1", "set2", "set3", "paired", "accent", "pastel1", "pastel2", "dark2", "interact", "def", "choose_qualitative", "name", "opts", "n", "2", "16", "desat", "floatslider", "min", "0", "max", "1", "value", "1", "pal", "color_palette", "name", "n", "desat", "palplot", "pal", "if", "as_cmap", "return", "cmap", "return", "pal"], "doc_len": 360}
{"doc_id": "seaborn/widgets.py::choose_dark_palette", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "choose_dark_palette", "text": "文件路径: seaborn/widgets.py\ndef choose_dark_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a dark sequential palette.\n\n    This corresponds with the :func:`dark_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`dark_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_dark_palette_rgb(r=(0., 1.),\n                                    g=(0., 1.),\n                                    b=(0., 1.),\n                                    n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_dark_palette_hls(h=(0., 1.),\n                                    l=(0., 1.),  # noqa: E741\n                                    s=(0., 1.),\n                                    n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_dark_palette_husl(h=(0, 359),\n                                     s=(0, 99),\n                                     l=(0, 99),  # noqa: E741\n                                     n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = dark_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = dark_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "tokens": ["seaborn", "widgets", "py", "def", "choose_dark_palette", "input", "husl", "as_cmap", "false", "launch", "an", "interactive", "widget", "to", "create", "a", "dark", "sequential", "palette", "this", "corresponds", "with", "the", "func", "dark_palette", "function", "this", "kind", "of", "palette", "is", "good", "for", "data", "that", "range", "between", "relatively", "uninteresting", "low", "values", "and", "interesting", "high", "values", "requires", "ipython", "2", "and", "must", "be", "used", "in", "the", "notebook", "parameters", "input", "husl", "hls", "rgb", "color", "space", "for", "defining", "the", "seed", "value", "note", "that", "the", "default", "is", "different", "than", "the", "default", "input", "for", "func", "dark_palette", "as_cmap", "bool", "if", "true", "the", "return", "value", "is", "a", "matplotlib", "colormap", "rather", "than", "a", "list", "of", "discrete", "colors", "returns", "pal", "or", "cmap", "list", "of", "colors", "or", "matplotlib", "colormap", "object", "that", "can", "be", "passed", "to", "plotting", "functions", "see", "also", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "low", "values", "light_palette", "create", "a", "sequential", "palette", "with", "bright", "low", "values", "cubehelix_palette", "create", "a", "sequential", "palette", "or", "colormap", "using", "the", "cubehelix", "system", "pal", "if", "as_cmap", "cmap", "_init_mutable_colormap", "if", "input", "rgb", "interact", "def", "choose_dark_palette_rgb", "r", "0", "1", "g", "0", "1", "b", "0", "1", "n", "3", "17", "color", "r", "g", "b", "if", "as_cmap", "colors", "dark_palette", "color", "256", "input", "rgb", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "dark_palette", "color", "n", "input", "rgb", "palplot", "pal", "elif", "input", "hls", "interact", "def", "choose_dark_palette_hls", "h", "0", "1", "l", "0", "1", "noqa", "e741", "s", "0", "1", "n", "3", "17", "color", "h", "l", "s", "if", "as_cmap", "colors", "dark_palette", "color", "256", "input", "hls", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "dark_palette", "color", "n", "input", "hls", "palplot", "pal", "elif", "input", "husl", "interact", "def", "choose_dark_palette_husl", "h", "0", "359", "s", "0", "99", "l", "0", "99", "noqa", "e741", "n", "3", "17", "color", "h", "s", "l", "if", "as_cmap", "colors", "dark_palette", "color", "256", "input", "husl", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "dark_palette", "color", "n", "input", "husl", "palplot", "pal", "if", "as_cmap", "return", "cmap", "return", "pal"], "doc_len": 294}
{"doc_id": "seaborn/widgets.py::choose_light_palette", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "choose_light_palette", "text": "文件路径: seaborn/widgets.py\ndef choose_light_palette(input=\"husl\", as_cmap=False):\n    \"\"\"Launch an interactive widget to create a light sequential palette.\n\n    This corresponds with the :func:`light_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    input : {'husl', 'hls', 'rgb'}\n        Color space for defining the seed value. Note that the default is\n        different than the default input for :func:`light_palette`.\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    dark_palette : Create a sequential palette with dark low values.\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    if input == \"rgb\":\n        @interact\n        def choose_light_palette_rgb(r=(0., 1.),\n                                     g=(0., 1.),\n                                     b=(0., 1.),\n                                     n=(3, 17)):\n            color = r, g, b\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"rgb\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"rgb\")\n                palplot(pal)\n\n    elif input == \"hls\":\n        @interact\n        def choose_light_palette_hls(h=(0., 1.),\n                                     l=(0., 1.),  # noqa: E741\n                                     s=(0., 1.),\n                                     n=(3, 17)):\n            color = h, l, s\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"hls\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"hls\")\n                palplot(pal)\n\n    elif input == \"husl\":\n        @interact\n        def choose_light_palette_husl(h=(0, 359),\n                                      s=(0, 99),\n                                      l=(0, 99),  # noqa: E741\n                                      n=(3, 17)):\n            color = h, s, l\n            if as_cmap:\n                colors = light_palette(color, 256, input=\"husl\")\n                _update_lut(cmap, colors)\n                _show_cmap(cmap)\n            else:\n                pal[:] = light_palette(color, n, input=\"husl\")\n                palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "tokens": ["seaborn", "widgets", "py", "def", "choose_light_palette", "input", "husl", "as_cmap", "false", "launch", "an", "interactive", "widget", "to", "create", "a", "light", "sequential", "palette", "this", "corresponds", "with", "the", "func", "light_palette", "function", "this", "kind", "of", "palette", "is", "good", "for", "data", "that", "range", "between", "relatively", "uninteresting", "low", "values", "and", "interesting", "high", "values", "requires", "ipython", "2", "and", "must", "be", "used", "in", "the", "notebook", "parameters", "input", "husl", "hls", "rgb", "color", "space", "for", "defining", "the", "seed", "value", "note", "that", "the", "default", "is", "different", "than", "the", "default", "input", "for", "func", "light_palette", "as_cmap", "bool", "if", "true", "the", "return", "value", "is", "a", "matplotlib", "colormap", "rather", "than", "a", "list", "of", "discrete", "colors", "returns", "pal", "or", "cmap", "list", "of", "colors", "or", "matplotlib", "colormap", "object", "that", "can", "be", "passed", "to", "plotting", "functions", "see", "also", "light_palette", "create", "a", "sequential", "palette", "with", "bright", "low", "values", "dark_palette", "create", "a", "sequential", "palette", "with", "dark", "low", "values", "cubehelix_palette", "create", "a", "sequential", "palette", "or", "colormap", "using", "the", "cubehelix", "system", "pal", "if", "as_cmap", "cmap", "_init_mutable_colormap", "if", "input", "rgb", "interact", "def", "choose_light_palette_rgb", "r", "0", "1", "g", "0", "1", "b", "0", "1", "n", "3", "17", "color", "r", "g", "b", "if", "as_cmap", "colors", "light_palette", "color", "256", "input", "rgb", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "light_palette", "color", "n", "input", "rgb", "palplot", "pal", "elif", "input", "hls", "interact", "def", "choose_light_palette_hls", "h", "0", "1", "l", "0", "1", "noqa", "e741", "s", "0", "1", "n", "3", "17", "color", "h", "l", "s", "if", "as_cmap", "colors", "light_palette", "color", "256", "input", "hls", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "light_palette", "color", "n", "input", "hls", "palplot", "pal", "elif", "input", "husl", "interact", "def", "choose_light_palette_husl", "h", "0", "359", "s", "0", "99", "l", "0", "99", "noqa", "e741", "n", "3", "17", "color", "h", "s", "l", "if", "as_cmap", "colors", "light_palette", "color", "256", "input", "husl", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "light_palette", "color", "n", "input", "husl", "palplot", "pal", "if", "as_cmap", "return", "cmap", "return", "pal"], "doc_len": 294}
{"doc_id": "seaborn/widgets.py::choose_diverging_palette", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "choose_diverging_palette", "text": "文件路径: seaborn/widgets.py\ndef choose_diverging_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to choose a diverging color palette.\n\n    This corresponds with the :func:`diverging_palette` function. This kind\n    of palette is good for data that range between interesting low values\n    and interesting high values with a meaningful midpoint. (For example,\n    change scores relative to some baseline value).\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    diverging_palette : Create a diverging color palette or colormap.\n    choose_colorbrewer_palette : Interactively choose palettes from the\n                                 colorbrewer set, including diverging palettes.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_diverging_palette(\n        h_neg=IntSlider(min=0,\n                        max=359,\n                        value=220),\n        h_pos=IntSlider(min=0,\n                        max=359,\n                        value=10),\n        s=IntSlider(min=0, max=99, value=74),\n        l=IntSlider(min=0, max=99, value=50),  # noqa: E741\n        sep=IntSlider(min=1, max=50, value=10),\n        n=(2, 16),\n        center=[\"light\", \"dark\"]\n    ):\n        if as_cmap:\n            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)\n            _update_lut(cmap, colors)\n            _show_cmap(cmap)\n        else:\n            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "tokens": ["seaborn", "widgets", "py", "def", "choose_diverging_palette", "as_cmap", "false", "launch", "an", "interactive", "widget", "to", "choose", "a", "diverging", "color", "palette", "this", "corresponds", "with", "the", "func", "diverging_palette", "function", "this", "kind", "of", "palette", "is", "good", "for", "data", "that", "range", "between", "interesting", "low", "values", "and", "interesting", "high", "values", "with", "a", "meaningful", "midpoint", "for", "example", "change", "scores", "relative", "to", "some", "baseline", "value", "requires", "ipython", "2", "and", "must", "be", "used", "in", "the", "notebook", "parameters", "as_cmap", "bool", "if", "true", "the", "return", "value", "is", "a", "matplotlib", "colormap", "rather", "than", "a", "list", "of", "discrete", "colors", "returns", "pal", "or", "cmap", "list", "of", "colors", "or", "matplotlib", "colormap", "object", "that", "can", "be", "passed", "to", "plotting", "functions", "see", "also", "diverging_palette", "create", "a", "diverging", "color", "palette", "or", "colormap", "choose_colorbrewer_palette", "interactively", "choose", "palettes", "from", "the", "colorbrewer", "set", "including", "diverging", "palettes", "pal", "if", "as_cmap", "cmap", "_init_mutable_colormap", "interact", "def", "choose_diverging_palette", "h_neg", "intslider", "min", "0", "max", "359", "value", "220", "h_pos", "intslider", "min", "0", "max", "359", "value", "10", "s", "intslider", "min", "0", "max", "99", "value", "74", "l", "intslider", "min", "0", "max", "99", "value", "50", "noqa", "e741", "sep", "intslider", "min", "1", "max", "50", "value", "10", "n", "2", "16", "center", "light", "dark", "if", "as_cmap", "colors", "diverging_palette", "h_neg", "h_pos", "s", "l", "sep", "256", "center", "_update_lut", "cmap", "colors", "_show_cmap", "cmap", "else", "pal", "diverging_palette", "h_neg", "h_pos", "s", "l", "sep", "n", "center", "palplot", "pal", "if", "as_cmap", "return", "cmap", "return", "pal"], "doc_len": 213}
{"doc_id": "seaborn/widgets.py::choose_cubehelix_palette", "file_path": "seaborn/widgets.py", "class_name": null, "func_name": "choose_cubehelix_palette", "text": "文件路径: seaborn/widgets.py\ndef choose_cubehelix_palette(as_cmap=False):\n    \"\"\"Launch an interactive widget to create a sequential cubehelix palette.\n\n    This corresponds with the :func:`cubehelix_palette` function. This kind\n    of palette is good for data that range between relatively uninteresting\n    low values and interesting high values. The cubehelix system allows the\n    palette to have more hue variance across the range, which can be helpful\n    for distinguishing a wider range of values.\n\n    Requires IPython 2+ and must be used in the notebook.\n\n    Parameters\n    ----------\n    as_cmap : bool\n        If True, the return value is a matplotlib colormap rather than a\n        list of discrete colors.\n\n    Returns\n    -------\n    pal or cmap : list of colors or matplotlib colormap\n        Object that can be passed to plotting functions.\n\n    See Also\n    --------\n    cubehelix_palette : Create a sequential palette or colormap using the\n                        cubehelix system.\n\n    \"\"\"\n    pal = []\n    if as_cmap:\n        cmap = _init_mutable_colormap()\n\n    @interact\n    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),\n                         start=FloatSlider(min=0, max=3, value=0),\n                         rot=FloatSlider(min=-1, max=1, value=.4),\n                         gamma=FloatSlider(min=0, max=5, value=1),\n                         hue=FloatSlider(min=0, max=1, value=.8),\n                         light=FloatSlider(min=0, max=1, value=.85),\n                         dark=FloatSlider(min=0, max=1, value=.15),\n                         reverse=False):\n\n        if as_cmap:\n            colors = cubehelix_palette(256, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            _update_lut(cmap, np.c_[colors, np.ones(256)])\n            _show_cmap(cmap)\n        else:\n            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,\n                                       hue, light, dark, reverse)\n            palplot(pal)\n\n    if as_cmap:\n        return cmap\n    return pal\n", "tokens": ["seaborn", "widgets", "py", "def", "choose_cubehelix_palette", "as_cmap", "false", "launch", "an", "interactive", "widget", "to", "create", "a", "sequential", "cubehelix", "palette", "this", "corresponds", "with", "the", "func", "cubehelix_palette", "function", "this", "kind", "of", "palette", "is", "good", "for", "data", "that", "range", "between", "relatively", "uninteresting", "low", "values", "and", "interesting", "high", "values", "the", "cubehelix", "system", "allows", "the", "palette", "to", "have", "more", "hue", "variance", "across", "the", "range", "which", "can", "be", "helpful", "for", "distinguishing", "a", "wider", "range", "of", "values", "requires", "ipython", "2", "and", "must", "be", "used", "in", "the", "notebook", "parameters", "as_cmap", "bool", "if", "true", "the", "return", "value", "is", "a", "matplotlib", "colormap", "rather", "than", "a", "list", "of", "discrete", "colors", "returns", "pal", "or", "cmap", "list", "of", "colors", "or", "matplotlib", "colormap", "object", "that", "can", "be", "passed", "to", "plotting", "functions", "see", "also", "cubehelix_palette", "create", "a", "sequential", "palette", "or", "colormap", "using", "the", "cubehelix", "system", "pal", "if", "as_cmap", "cmap", "_init_mutable_colormap", "interact", "def", "choose_cubehelix", "n_colors", "intslider", "min", "2", "max", "16", "value", "9", "start", "floatslider", "min", "0", "max", "3", "value", "0", "rot", "floatslider", "min", "1", "max", "1", "value", "4", "gamma", "floatslider", "min", "0", "max", "5", "value", "1", "hue", "floatslider", "min", "0", "max", "1", "value", "8", "light", "floatslider", "min", "0", "max", "1", "value", "85", "dark", "floatslider", "min", "0", "max", "1", "value", "15", "reverse", "false", "if", "as_cmap", "colors", "cubehelix_palette", "256", "start", "rot", "gamma", "hue", "light", "dark", "reverse", "_update_lut", "cmap", "np", "c_", "colors", "np", "ones", "256", "_show_cmap", "cmap", "else", "pal", "cubehelix_palette", "n_colors", "start", "rot", "gamma", "hue", "light", "dark", "reverse", "palplot", "pal", "if", "as_cmap", "return", "cmap", "return", "pal"], "doc_len": 235}
{"doc_id": "seaborn/_compat.py::MarkerStyle", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "MarkerStyle", "text": "文件路径: seaborn/_compat.py\ndef MarkerStyle(marker=None, fillstyle=None):\n    \"\"\"\n    Allow MarkerStyle to accept a MarkerStyle object as parameter.\n\n    Supports matplotlib < 3.3.0\n    https://github.com/matplotlib/matplotlib/pull/16692\n\n    \"\"\"\n    if isinstance(marker, mpl.markers.MarkerStyle):\n        if fillstyle is None:\n            return marker\n        else:\n            marker = marker.get_marker()\n    return mpl.markers.MarkerStyle(marker, fillstyle)\n", "tokens": ["seaborn", "_compat", "py", "def", "markerstyle", "marker", "none", "fillstyle", "none", "allow", "markerstyle", "to", "accept", "a", "markerstyle", "object", "as", "parameter", "supports", "matplotlib", "3", "3", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "16692", "if", "isinstance", "marker", "mpl", "markers", "markerstyle", "if", "fillstyle", "is", "none", "return", "marker", "else", "marker", "marker", "get_marker", "return", "mpl", "markers", "markerstyle", "marker", "fillstyle"], "doc_len": 52}
{"doc_id": "seaborn/_compat.py::norm_from_scale", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "norm_from_scale", "text": "文件路径: seaborn/_compat.py\ndef norm_from_scale(scale, norm):\n    \"\"\"Produce a Normalize object given a Scale and min/max domain limits.\"\"\"\n    # This is an internal maplotlib function that simplifies things to access\n    # It is likely to become part of the matplotlib API at some point:\n    # https://github.com/matplotlib/matplotlib/issues/20329\n    if isinstance(norm, mpl.colors.Normalize):\n        return norm\n\n    if scale is None:\n        return None\n\n    if norm is None:\n        vmin = vmax = None\n    else:\n        vmin, vmax = norm  # TODO more helpful error if this fails?\n\n    class ScaledNorm(mpl.colors.Normalize):\n\n        def __call__(self, value, clip=None):\n            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py\n            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE\n            value, is_scalar = self.process_value(value)\n            self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            # ***** Seaborn changes start ****\n            t_value = self.transform(value).reshape(np.shape(value))\n            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])\n            # ***** Seaborn changes end *****\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n\n    new_norm = ScaledNorm(vmin, vmax)\n    new_norm.transform = scale.get_transform().transform\n\n    return new_norm\n", "tokens": ["seaborn", "_compat", "py", "def", "norm_from_scale", "scale", "norm", "produce", "a", "normalize", "object", "given", "a", "scale", "and", "min", "max", "domain", "limits", "this", "is", "an", "internal", "maplotlib", "function", "that", "simplifies", "things", "to", "access", "it", "is", "likely", "to", "become", "part", "of", "the", "matplotlib", "api", "at", "some", "point", "https", "github", "com", "matplotlib", "matplotlib", "issues", "20329", "if", "isinstance", "norm", "mpl", "colors", "normalize", "return", "norm", "if", "scale", "is", "none", "return", "none", "if", "norm", "is", "none", "vmin", "vmax", "none", "else", "vmin", "vmax", "norm", "todo", "more", "helpful", "error", "if", "this", "fails", "class", "scalednorm", "mpl", "colors", "normalize", "def", "__call__", "self", "value", "clip", "none", "from", "github", "com", "matplotlib", "matplotlib", "blob", "v3", "4", "2", "lib", "matplotlib", "colors", "py", "see", "github", "com", "matplotlib", "matplotlib", "tree", "v3", "4", "2", "license", "value", "is_scalar", "self", "process_value", "value", "self", "autoscale_none", "value", "if", "self", "vmin", "self", "vmax", "raise", "valueerror", "vmin", "must", "be", "less", "or", "equal", "to", "vmax", "if", "self", "vmin", "self", "vmax", "return", "np", "full_like", "value", "0", "if", "clip", "is", "none", "clip", "self", "clip", "if", "clip", "value", "np", "clip", "value", "self", "vmin", "self", "vmax", "seaborn", "changes", "start", "t_value", "self", "transform", "value", "reshape", "np", "shape", "value", "t_vmin", "t_vmax", "self", "transform", "self", "vmin", "self", "vmax", "seaborn", "changes", "end", "if", "not", "np", "isfinite", "t_vmin", "t_vmax", "all", "raise", "valueerror", "invalid", "vmin", "or", "vmax", "t_value", "t_vmin", "t_value", "t_vmax", "t_vmin", "t_value", "np", "ma", "masked_invalid", "t_value", "copy", "false", "return", "t_value", "0", "if", "is_scalar", "else", "t_value", "new_norm", "scalednorm", "vmin", "vmax", "new_norm", "transform", "scale", "get_transform", "transform", "return", "new_norm"], "doc_len": 231}
{"doc_id": "seaborn/_compat.py::scale_factory", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "scale_factory", "text": "文件路径: seaborn/_compat.py\ndef scale_factory(scale, axis, **kwargs):\n    \"\"\"\n    Backwards compatability for creation of independent scales.\n\n    Matplotlib scales require an Axis object for instantiation on < 3.4.\n    But the axis is not used, aside from extraction of the axis_name in LogScale.\n\n    \"\"\"\n    modify_transform = False\n    if Version(mpl.__version__) < Version(\"3.4\"):\n        if axis[0] in \"xy\":\n            modify_transform = True\n            axis = axis[0]\n            base = kwargs.pop(\"base\", None)\n            if base is not None:\n                kwargs[f\"base{axis}\"] = base\n            nonpos = kwargs.pop(\"nonpositive\", None)\n            if nonpos is not None:\n                kwargs[f\"nonpos{axis}\"] = nonpos\n\n    if isinstance(scale, str):\n        class Axis:\n            axis_name = axis\n        axis = Axis()\n\n    scale = mpl.scale.scale_factory(scale, axis, **kwargs)\n\n    if modify_transform:\n        transform = scale.get_transform()\n        transform.base = kwargs.get(\"base\", 10)\n        if kwargs.get(\"nonpositive\") == \"mask\":\n            # Setting a private attribute, but we only get here\n            # on an old matplotlib, so this won't break going forwards\n            transform._clip = False\n\n    return scale\n", "tokens": ["seaborn", "_compat", "py", "def", "scale_factory", "scale", "axis", "kwargs", "backwards", "compatability", "for", "creation", "of", "independent", "scales", "matplotlib", "scales", "require", "an", "axis", "object", "for", "instantiation", "on", "3", "4", "but", "the", "axis", "is", "not", "used", "aside", "from", "extraction", "of", "the", "axis_name", "in", "logscale", "modify_transform", "false", "if", "version", "mpl", "__version__", "version", "3", "4", "if", "axis", "0", "in", "xy", "modify_transform", "true", "axis", "axis", "0", "base", "kwargs", "pop", "base", "none", "if", "base", "is", "not", "none", "kwargs", "f", "base", "axis", "base", "nonpos", "kwargs", "pop", "nonpositive", "none", "if", "nonpos", "is", "not", "none", "kwargs", "f", "nonpos", "axis", "nonpos", "if", "isinstance", "scale", "str", "class", "axis", "axis_name", "axis", "axis", "axis", "scale", "mpl", "scale", "scale_factory", "scale", "axis", "kwargs", "if", "modify_transform", "transform", "scale", "get_transform", "transform", "base", "kwargs", "get", "base", "10", "if", "kwargs", "get", "nonpositive", "mask", "setting", "a", "private", "attribute", "but", "we", "only", "get", "here", "on", "an", "old", "matplotlib", "so", "this", "won", "t", "break", "going", "forwards", "transform", "_clip", "false", "return", "scale"], "doc_len": 147}
{"doc_id": "seaborn/_compat.py::set_scale_obj", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "set_scale_obj", "text": "文件路径: seaborn/_compat.py\ndef set_scale_obj(ax, axis, scale):\n    \"\"\"Handle backwards compatability with setting matplotlib scale.\"\"\"\n    if Version(mpl.__version__) < Version(\"3.4\"):\n        # The ability to pass a BaseScale instance to Axes.set_{}scale was added\n        # to matplotlib in version 3.4.0: GH: matplotlib/matplotlib/pull/19089\n        # Workaround: use the scale name, which is restrictive only if the user\n        # wants to define a custom scale; they'll need to update the registry too.\n        if scale.name is None:\n            # Hack to support our custom Formatter-less CatScale\n            return\n        method = getattr(ax, f\"set_{axis}scale\")\n        kws = {}\n        if scale.name == \"function\":\n            trans = scale.get_transform()\n            kws[\"functions\"] = (trans._forward, trans._inverse)\n        method(scale.name, **kws)\n        axis_obj = getattr(ax, f\"{axis}axis\")\n        scale.set_default_locators_and_formatters(axis_obj)\n    else:\n        ax.set(**{f\"{axis}scale\": scale})\n", "tokens": ["seaborn", "_compat", "py", "def", "set_scale_obj", "ax", "axis", "scale", "handle", "backwards", "compatability", "with", "setting", "matplotlib", "scale", "if", "version", "mpl", "__version__", "version", "3", "4", "the", "ability", "to", "pass", "a", "basescale", "instance", "to", "axes", "set_", "scale", "was", "added", "to", "matplotlib", "in", "version", "3", "4", "0", "gh", "matplotlib", "matplotlib", "pull", "19089", "workaround", "use", "the", "scale", "name", "which", "is", "restrictive", "only", "if", "the", "user", "wants", "to", "define", "a", "custom", "scale", "they", "ll", "need", "to", "update", "the", "registry", "too", "if", "scale", "name", "is", "none", "hack", "to", "support", "our", "custom", "formatter", "less", "catscale", "return", "method", "getattr", "ax", "f", "set_", "axis", "scale", "kws", "if", "scale", "name", "function", "trans", "scale", "get_transform", "kws", "functions", "trans", "_forward", "trans", "_inverse", "method", "scale", "name", "kws", "axis_obj", "getattr", "ax", "f", "axis", "axis", "scale", "set_default_locators_and_formatters", "axis_obj", "else", "ax", "set", "f", "axis", "scale", "scale"], "doc_len": 128}
{"doc_id": "seaborn/_compat.py::get_colormap", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "get_colormap", "text": "文件路径: seaborn/_compat.py\ndef get_colormap(name):\n    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"\n    try:\n        return mpl.colormaps[name]\n    except AttributeError:\n        return mpl.cm.get_cmap(name)\n", "tokens": ["seaborn", "_compat", "py", "def", "get_colormap", "name", "handle", "changes", "to", "matplotlib", "colormap", "interface", "in", "3", "6", "try", "return", "mpl", "colormaps", "name", "except", "attributeerror", "return", "mpl", "cm", "get_cmap", "name"], "doc_len": 27}
{"doc_id": "seaborn/_compat.py::register_colormap", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "register_colormap", "text": "文件路径: seaborn/_compat.py\ndef register_colormap(name, cmap):\n    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"\n    try:\n        if name not in mpl.colormaps:\n            mpl.colormaps.register(cmap, name=name)\n    except AttributeError:\n        mpl.cm.register_cmap(name, cmap)\n", "tokens": ["seaborn", "_compat", "py", "def", "register_colormap", "name", "cmap", "handle", "changes", "to", "matplotlib", "colormap", "interface", "in", "3", "6", "try", "if", "name", "not", "in", "mpl", "colormaps", "mpl", "colormaps", "register", "cmap", "name", "name", "except", "attributeerror", "mpl", "cm", "register_cmap", "name", "cmap"], "doc_len": 36}
{"doc_id": "seaborn/_compat.py::set_layout_engine", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "set_layout_engine", "text": "文件路径: seaborn/_compat.py\ndef set_layout_engine(fig, engine):\n    \"\"\"Handle changes to auto layout engine interface in 3.6\"\"\"\n    if hasattr(fig, \"set_layout_engine\"):\n        fig.set_layout_engine(engine)\n    else:\n        if engine == \"tight\":\n            fig.set_tight_layout(True)\n        elif engine == \"constrained\":\n            fig.set_constrained_layout(True)\n", "tokens": ["seaborn", "_compat", "py", "def", "set_layout_engine", "fig", "engine", "handle", "changes", "to", "auto", "layout", "engine", "interface", "in", "3", "6", "if", "hasattr", "fig", "set_layout_engine", "fig", "set_layout_engine", "engine", "else", "if", "engine", "tight", "fig", "set_tight_layout", "true", "elif", "engine", "constrained", "fig", "set_constrained_layout", "true"], "doc_len": 37}
{"doc_id": "seaborn/_compat.py::share_axis", "file_path": "seaborn/_compat.py", "class_name": null, "func_name": "share_axis", "text": "文件路径: seaborn/_compat.py\ndef share_axis(ax0, ax1, which):\n    \"\"\"Handle changes to post-hoc axis sharing.\"\"\"\n    if Version(mpl.__version__) < Version(\"3.5.0\"):\n        group = getattr(ax0, f\"get_shared_{which}_axes\")()\n        group.join(ax1, ax0)\n    else:\n        getattr(ax1, f\"share{which}\")(ax0)\n", "tokens": ["seaborn", "_compat", "py", "def", "share_axis", "ax0", "ax1", "which", "handle", "changes", "to", "post", "hoc", "axis", "sharing", "if", "version", "mpl", "__version__", "version", "3", "5", "0", "group", "getattr", "ax0", "f", "get_shared_", "which", "_axes", "group", "join", "ax1", "ax0", "else", "getattr", "ax1", "f", "share", "which", "ax0"], "doc_len": 41}
{"doc_id": "seaborn/_decorators.py::share_init_params_with_map", "file_path": "seaborn/_decorators.py", "class_name": null, "func_name": "share_init_params_with_map", "text": "文件路径: seaborn/_decorators.py\ndef share_init_params_with_map(cls):\n    \"\"\"Make cls.map a classmethod with same signature as cls.__init__.\"\"\"\n    map_sig = signature(cls.map)\n    init_sig = signature(cls.__init__)\n\n    new = [v for k, v in init_sig.parameters.items() if k != \"self\"]\n    new.insert(0, map_sig.parameters[\"cls\"])\n    cls.map.__signature__ = map_sig.replace(parameters=new)\n    cls.map.__doc__ = cls.__init__.__doc__\n\n    cls.map = classmethod(cls.map)\n\n    return cls\n", "tokens": ["seaborn", "_decorators", "py", "def", "share_init_params_with_map", "cls", "make", "cls", "map", "a", "classmethod", "with", "same", "signature", "as", "cls", "__init__", "map_sig", "signature", "cls", "map", "init_sig", "signature", "cls", "__init__", "new", "v", "for", "k", "v", "in", "init_sig", "parameters", "items", "if", "k", "self", "new", "insert", "0", "map_sig", "parameters", "cls", "cls", "map", "__signature__", "map_sig", "replace", "parameters", "new", "cls", "map", "__doc__", "cls", "__init__", "__doc__", "cls", "map", "classmethod", "cls", "map", "return", "cls"], "doc_len": 63}
{"doc_id": "seaborn/_docstrings.py::DocstringComponents.__init__", "file_path": "seaborn/_docstrings.py", "class_name": "DocstringComponents", "func_name": "__init__", "text": "文件路径: seaborn/_docstrings.py, 类名: DocstringComponents\n    def __init__(self, comp_dict, strip_whitespace=True):\n        \"\"\"Read entries from a dict, optionally stripping outer whitespace.\"\"\"\n        if strip_whitespace:\n            entries = {}\n            for key, val in comp_dict.items():\n                m = re.match(self.regexp, val)\n                if m is None:\n                    entries[key] = val\n                else:\n                    entries[key] = m.group(1)\n        else:\n            entries = comp_dict.copy()\n\n        self.entries = entries\n", "tokens": ["seaborn", "_docstrings", "py", "docstringcomponents", "def", "__init__", "self", "comp_dict", "strip_whitespace", "true", "read", "entries", "from", "a", "dict", "optionally", "stripping", "outer", "whitespace", "if", "strip_whitespace", "entries", "for", "key", "val", "in", "comp_dict", "items", "m", "re", "match", "self", "regexp", "val", "if", "m", "is", "none", "entries", "key", "val", "else", "entries", "key", "m", "group", "1", "else", "entries", "comp_dict", "copy", "self", "entries", "entries"], "doc_len": 54}
{"doc_id": "seaborn/_docstrings.py::DocstringComponents.__getattr__", "file_path": "seaborn/_docstrings.py", "class_name": "DocstringComponents", "func_name": "__getattr__", "text": "文件路径: seaborn/_docstrings.py, 类名: DocstringComponents\n    def __getattr__(self, attr):\n        \"\"\"Provide dot access to entries for clean raw docstrings.\"\"\"\n        if attr in self.entries:\n            return self.entries[attr]\n        else:\n            try:\n                return self.__getattribute__(attr)\n            except AttributeError as err:\n                # If Python is run with -OO, it will strip docstrings and our lookup\n                # from self.entries will fail. We check for __debug__, which is actually\n                # set to False by -O (it is True for normal execution).\n                # But we only want to see an error when building the docs;\n                # not something users should see, so this slight inconsistency is fine.\n                if __debug__:\n                    raise err\n                else:\n                    pass\n", "tokens": ["seaborn", "_docstrings", "py", "docstringcomponents", "def", "__getattr__", "self", "attr", "provide", "dot", "access", "to", "entries", "for", "clean", "raw", "docstrings", "if", "attr", "in", "self", "entries", "return", "self", "entries", "attr", "else", "try", "return", "self", "__getattribute__", "attr", "except", "attributeerror", "as", "err", "if", "python", "is", "run", "with", "oo", "it", "will", "strip", "docstrings", "and", "our", "lookup", "from", "self", "entries", "will", "fail", "we", "check", "for", "__debug__", "which", "is", "actually", "set", "to", "false", "by", "o", "it", "is", "true", "for", "normal", "execution", "but", "we", "only", "want", "to", "see", "an", "error", "when", "building", "the", "docs", "not", "something", "users", "should", "see", "so", "this", "slight", "inconsistency", "is", "fine", "if", "__debug__", "raise", "err", "else", "pass"], "doc_len": 101}
{"doc_id": "seaborn/_docstrings.py::DocstringComponents.from_nested_components", "file_path": "seaborn/_docstrings.py", "class_name": "DocstringComponents", "func_name": "from_nested_components", "text": "文件路径: seaborn/_docstrings.py, 类名: DocstringComponents\n    def from_nested_components(cls, **kwargs):\n        \"\"\"Add multiple sub-sets of components.\"\"\"\n        return cls(kwargs, strip_whitespace=False)\n", "tokens": ["seaborn", "_docstrings", "py", "docstringcomponents", "def", "from_nested_components", "cls", "kwargs", "add", "multiple", "sub", "sets", "of", "components", "return", "cls", "kwargs", "strip_whitespace", "false"], "doc_len": 19}
{"doc_id": "seaborn/_docstrings.py::DocstringComponents.from_function_params", "file_path": "seaborn/_docstrings.py", "class_name": "DocstringComponents", "func_name": "from_function_params", "text": "文件路径: seaborn/_docstrings.py, 类名: DocstringComponents\n    def from_function_params(cls, func):\n        \"\"\"Use the numpydoc parser to extract components from existing func.\"\"\"\n        params = NumpyDocString(pydoc.getdoc(func))[\"Parameters\"]\n        comp_dict = {}\n        for p in params:\n            name = p.name\n            type = p.type\n            desc = \"\\n    \".join(p.desc)\n            comp_dict[name] = f\"{name} : {type}\\n    {desc}\"\n\n        return cls(comp_dict)\n", "tokens": ["seaborn", "_docstrings", "py", "docstringcomponents", "def", "from_function_params", "cls", "func", "use", "the", "numpydoc", "parser", "to", "extract", "components", "from", "existing", "func", "params", "numpydocstring", "pydoc", "getdoc", "func", "parameters", "comp_dict", "for", "p", "in", "params", "name", "p", "name", "type", "p", "type", "desc", "n", "join", "p", "desc", "comp_dict", "name", "f", "name", "type", "n", "desc", "return", "cls", "comp_dict"], "doc_len": 50}
{"doc_id": "seaborn/_oldcore.py::SemanticMapping.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "SemanticMapping", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: SemanticMapping\n    def __init__(self, plotter):\n\n        # TODO Putting this here so we can continue to use a lot of the\n        # logic that's built into the library, but the idea of this class\n        # is to move towards semantic mappings that are agnostic about the\n        # kind of plot they're going to be used to draw.\n        # Fully achieving that is going to take some thinking.\n        self.plotter = plotter\n", "tokens": ["seaborn", "_oldcore", "py", "semanticmapping", "def", "__init__", "self", "plotter", "todo", "putting", "this", "here", "so", "we", "can", "continue", "to", "use", "a", "lot", "of", "the", "logic", "that", "s", "built", "into", "the", "library", "but", "the", "idea", "of", "this", "class", "is", "to", "move", "towards", "semantic", "mappings", "that", "are", "agnostic", "about", "the", "kind", "of", "plot", "they", "re", "going", "to", "be", "used", "to", "draw", "fully", "achieving", "that", "is", "going", "to", "take", "some", "thinking", "self", "plotter", "plotter"], "doc_len": 69}
{"doc_id": "seaborn/_oldcore.py::SemanticMapping.map", "file_path": "seaborn/_oldcore.py", "class_name": "SemanticMapping", "func_name": "map", "text": "文件路径: seaborn/_oldcore.py, 类名: SemanticMapping\n    def map(cls, plotter, *args, **kwargs):\n        # This method is assigned the __init__ docstring\n        method_name = f\"_{cls.__name__[:-7].lower()}_map\"\n        setattr(plotter, method_name, cls(plotter, *args, **kwargs))\n        return plotter\n", "tokens": ["seaborn", "_oldcore", "py", "semanticmapping", "def", "map", "cls", "plotter", "args", "kwargs", "this", "method", "is", "assigned", "the", "__init__", "docstring", "method_name", "f", "_", "cls", "__name__", "7", "lower", "_map", "setattr", "plotter", "method_name", "cls", "plotter", "args", "kwargs", "return", "plotter"], "doc_len": 34}
{"doc_id": "seaborn/_oldcore.py::SemanticMapping._check_list_length", "file_path": "seaborn/_oldcore.py", "class_name": "SemanticMapping", "func_name": "_check_list_length", "text": "文件路径: seaborn/_oldcore.py, 类名: SemanticMapping\n    def _check_list_length(self, levels, values, variable):\n        \"\"\"Input check when values are provided as a list.\"\"\"\n        # Copied from _core/properties; eventually will be replaced for that.\n        message = \"\"\n        if len(levels) > len(values):\n            message = \" \".join([\n                f\"\\nThe {variable} list has fewer values ({len(values)})\",\n                f\"than needed ({len(levels)}) and will cycle, which may\",\n                \"produce an uninterpretable plot.\"\n            ])\n            values = [x for _, x in zip(levels, itertools.cycle(values))]\n\n        elif len(values) > len(levels):\n            message = \" \".join([\n                f\"The {variable} list has more values ({len(values)})\",\n                f\"than needed ({len(levels)}), which may not be intended.\",\n            ])\n            values = values[:len(levels)]\n\n        if message:\n            warnings.warn(message, UserWarning, stacklevel=6)\n\n        return values\n", "tokens": ["seaborn", "_oldcore", "py", "semanticmapping", "def", "_check_list_length", "self", "levels", "values", "variable", "input", "check", "when", "values", "are", "provided", "as", "a", "list", "copied", "from", "_core", "properties", "eventually", "will", "be", "replaced", "for", "that", "message", "if", "len", "levels", "len", "values", "message", "join", "f", "nthe", "variable", "list", "has", "fewer", "values", "len", "values", "f", "than", "needed", "len", "levels", "and", "will", "cycle", "which", "may", "produce", "an", "uninterpretable", "plot", "values", "x", "for", "_", "x", "in", "zip", "levels", "itertools", "cycle", "values", "elif", "len", "values", "len", "levels", "message", "join", "f", "the", "variable", "list", "has", "more", "values", "len", "values", "f", "than", "needed", "len", "levels", "which", "may", "not", "be", "intended", "values", "values", "len", "levels", "if", "message", "warnings", "warn", "message", "userwarning", "stacklevel", "6", "return", "values"], "doc_len": 111}
{"doc_id": "seaborn/_oldcore.py::SemanticMapping._lookup_single", "file_path": "seaborn/_oldcore.py", "class_name": "SemanticMapping", "func_name": "_lookup_single", "text": "文件路径: seaborn/_oldcore.py, 类名: SemanticMapping\n    def _lookup_single(self, key):\n        \"\"\"Apply the mapping to a single data value.\"\"\"\n        return self.lookup_table[key]\n", "tokens": ["seaborn", "_oldcore", "py", "semanticmapping", "def", "_lookup_single", "self", "key", "apply", "the", "mapping", "to", "a", "single", "data", "value", "return", "self", "lookup_table", "key"], "doc_len": 20}
{"doc_id": "seaborn/_oldcore.py::SemanticMapping.__call__", "file_path": "seaborn/_oldcore.py", "class_name": "SemanticMapping", "func_name": "__call__", "text": "文件路径: seaborn/_oldcore.py, 类名: SemanticMapping\n    def __call__(self, key, *args, **kwargs):\n        \"\"\"Get the attribute(s) values for the data key.\"\"\"\n        if isinstance(key, (list, np.ndarray, pd.Series)):\n            return [self._lookup_single(k, *args, **kwargs) for k in key]\n        else:\n            return self._lookup_single(key, *args, **kwargs)\n", "tokens": ["seaborn", "_oldcore", "py", "semanticmapping", "def", "__call__", "self", "key", "args", "kwargs", "get", "the", "attribute", "s", "values", "for", "the", "data", "key", "if", "isinstance", "key", "list", "np", "ndarray", "pd", "series", "return", "self", "_lookup_single", "k", "args", "kwargs", "for", "k", "in", "key", "else", "return", "self", "_lookup_single", "key", "args", "kwargs"], "doc_len": 44}
{"doc_id": "seaborn/_oldcore.py::HueMapping.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "HueMapping", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: HueMapping\n    def __init__(\n        self, plotter, palette=None, order=None, norm=None,\n    ):\n        \"\"\"Map the levels of the `hue` variable to distinct colors.\n\n        Parameters\n        ----------\n        # TODO add generic parameters\n\n        \"\"\"\n        super().__init__(plotter)\n\n        data = plotter.plot_data.get(\"hue\", pd.Series(dtype=float))\n\n        if data.isna().all():\n            if palette is not None:\n                msg = \"Ignoring `palette` because no `hue` variable has been assigned.\"\n                warnings.warn(msg, stacklevel=4)\n        else:\n\n            map_type = self.infer_map_type(\n                palette, norm, plotter.input_format, plotter.var_types[\"hue\"]\n            )\n\n            # Our goal is to end up with a dictionary mapping every unique\n            # value in `data` to a color. We will also keep track of the\n            # metadata about this mapping we will need for, e.g., a legend\n\n            # --- Option 1: numeric mapping with a matplotlib colormap\n\n            if map_type == \"numeric\":\n\n                data = pd.to_numeric(data)\n                levels, lookup_table, norm, cmap = self.numeric_mapping(\n                    data, palette, norm,\n                )\n\n            # --- Option 2: categorical mapping using seaborn palette\n\n            elif map_type == \"categorical\":\n\n                cmap = norm = None\n                levels, lookup_table = self.categorical_mapping(\n                    data, palette, order,\n                )\n\n            # --- Option 3: datetime mapping\n\n            else:\n                # TODO this needs actual implementation\n                cmap = norm = None\n                levels, lookup_table = self.categorical_mapping(\n                    # Casting data to list to handle differences in the way\n                    # pandas and numpy represent datetime64 data\n                    list(data), palette, order,\n                )\n\n            self.map_type = map_type\n            self.lookup_table = lookup_table\n            self.palette = palette\n            self.levels = levels\n            self.norm = norm\n            self.cmap = cmap\n", "tokens": ["seaborn", "_oldcore", "py", "huemapping", "def", "__init__", "self", "plotter", "palette", "none", "order", "none", "norm", "none", "map", "the", "levels", "of", "the", "hue", "variable", "to", "distinct", "colors", "parameters", "todo", "add", "generic", "parameters", "super", "__init__", "plotter", "data", "plotter", "plot_data", "get", "hue", "pd", "series", "dtype", "float", "if", "data", "isna", "all", "if", "palette", "is", "not", "none", "msg", "ignoring", "palette", "because", "no", "hue", "variable", "has", "been", "assigned", "warnings", "warn", "msg", "stacklevel", "4", "else", "map_type", "self", "infer_map_type", "palette", "norm", "plotter", "input_format", "plotter", "var_types", "hue", "our", "goal", "is", "to", "end", "up", "with", "a", "dictionary", "mapping", "every", "unique", "value", "in", "data", "to", "a", "color", "we", "will", "also", "keep", "track", "of", "the", "metadata", "about", "this", "mapping", "we", "will", "need", "for", "e", "g", "a", "legend", "option", "1", "numeric", "mapping", "with", "a", "matplotlib", "colormap", "if", "map_type", "numeric", "data", "pd", "to_numeric", "data", "levels", "lookup_table", "norm", "cmap", "self", "numeric_mapping", "data", "palette", "norm", "option", "2", "categorical", "mapping", "using", "seaborn", "palette", "elif", "map_type", "categorical", "cmap", "norm", "none", "levels", "lookup_table", "self", "categorical_mapping", "data", "palette", "order", "option", "3", "datetime", "mapping", "else", "todo", "this", "needs", "actual", "implementation", "cmap", "norm", "none", "levels", "lookup_table", "self", "categorical_mapping", "casting", "data", "to", "list", "to", "handle", "differences", "in", "the", "way", "pandas", "and", "numpy", "represent", "datetime64", "data", "list", "data", "palette", "order", "self", "map_type", "map_type", "self", "lookup_table", "lookup_table", "self", "palette", "palette", "self", "levels", "levels", "self", "norm", "norm", "self", "cmap", "cmap"], "doc_len": 212}
{"doc_id": "seaborn/_oldcore.py::HueMapping._lookup_single", "file_path": "seaborn/_oldcore.py", "class_name": "HueMapping", "func_name": "_lookup_single", "text": "文件路径: seaborn/_oldcore.py, 类名: HueMapping\n    def _lookup_single(self, key):\n        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n        try:\n            # Use a value that's in the original data vector\n            value = self.lookup_table[key]\n        except KeyError:\n\n            if self.norm is None:\n                # Currently we only get here in scatterplot with hue_order,\n                # because scatterplot does not consider hue a grouping variable\n                # So unused hue levels are in the data, but not the lookup table\n                return (0, 0, 0, 0)\n\n            # Use the colormap to interpolate between existing datapoints\n            # (e.g. in the context of making a continuous legend)\n            try:\n                normed = self.norm(key)\n            except TypeError as err:\n                if np.isnan(key):\n                    value = (0, 0, 0, 0)\n                else:\n                    raise err\n            else:\n                if np.ma.is_masked(normed):\n                    normed = np.nan\n                value = self.cmap(normed)\n        return value\n", "tokens": ["seaborn", "_oldcore", "py", "huemapping", "def", "_lookup_single", "self", "key", "get", "the", "color", "for", "a", "single", "value", "using", "colormap", "to", "interpolate", "try", "use", "a", "value", "that", "s", "in", "the", "original", "data", "vector", "value", "self", "lookup_table", "key", "except", "keyerror", "if", "self", "norm", "is", "none", "currently", "we", "only", "get", "here", "in", "scatterplot", "with", "hue_order", "because", "scatterplot", "does", "not", "consider", "hue", "a", "grouping", "variable", "so", "unused", "hue", "levels", "are", "in", "the", "data", "but", "not", "the", "lookup", "table", "return", "0", "0", "0", "0", "use", "the", "colormap", "to", "interpolate", "between", "existing", "datapoints", "e", "g", "in", "the", "context", "of", "making", "a", "continuous", "legend", "try", "normed", "self", "norm", "key", "except", "typeerror", "as", "err", "if", "np", "isnan", "key", "value", "0", "0", "0", "0", "else", "raise", "err", "else", "if", "np", "ma", "is_masked", "normed", "normed", "np", "nan", "value", "self", "cmap", "normed", "return", "value"], "doc_len": 131}
{"doc_id": "seaborn/_oldcore.py::HueMapping.infer_map_type", "file_path": "seaborn/_oldcore.py", "class_name": "HueMapping", "func_name": "infer_map_type", "text": "文件路径: seaborn/_oldcore.py, 类名: HueMapping\n    def infer_map_type(self, palette, norm, input_format, var_type):\n        \"\"\"Determine how to implement the mapping.\"\"\"\n        if palette in QUAL_PALETTES:\n            map_type = \"categorical\"\n        elif norm is not None:\n            map_type = \"numeric\"\n        elif isinstance(palette, (dict, list)):\n            map_type = \"categorical\"\n        elif input_format == \"wide\":\n            map_type = \"categorical\"\n        else:\n            map_type = var_type\n\n        return map_type\n", "tokens": ["seaborn", "_oldcore", "py", "huemapping", "def", "infer_map_type", "self", "palette", "norm", "input_format", "var_type", "determine", "how", "to", "implement", "the", "mapping", "if", "palette", "in", "qual_palettes", "map_type", "categorical", "elif", "norm", "is", "not", "none", "map_type", "numeric", "elif", "isinstance", "palette", "dict", "list", "map_type", "categorical", "elif", "input_format", "wide", "map_type", "categorical", "else", "map_type", "var_type", "return", "map_type"], "doc_len": 47}
{"doc_id": "seaborn/_oldcore.py::HueMapping.categorical_mapping", "file_path": "seaborn/_oldcore.py", "class_name": "HueMapping", "func_name": "categorical_mapping", "text": "文件路径: seaborn/_oldcore.py, 类名: HueMapping\n    def categorical_mapping(self, data, palette, order):\n        \"\"\"Determine colors when the hue mapping is categorical.\"\"\"\n        # -- Identify the order and name of the levels\n\n        levels = categorical_order(data, order)\n        n_colors = len(levels)\n\n        # -- Identify the set of colors to use\n\n        if isinstance(palette, dict):\n\n            missing = set(levels) - set(palette)\n            if any(missing):\n                err = \"The palette dictionary is missing keys: {}\"\n                raise ValueError(err.format(missing))\n\n            lookup_table = palette\n\n        else:\n\n            if palette is None:\n                if n_colors <= len(get_color_cycle()):\n                    colors = color_palette(None, n_colors)\n                else:\n                    colors = color_palette(\"husl\", n_colors)\n            elif isinstance(palette, list):\n                colors = self._check_list_length(levels, palette, \"palette\")\n            else:\n                colors = color_palette(palette, n_colors)\n\n            lookup_table = dict(zip(levels, colors))\n\n        return levels, lookup_table\n", "tokens": ["seaborn", "_oldcore", "py", "huemapping", "def", "categorical_mapping", "self", "data", "palette", "order", "determine", "colors", "when", "the", "hue", "mapping", "is", "categorical", "identify", "the", "order", "and", "name", "of", "the", "levels", "levels", "categorical_order", "data", "order", "n_colors", "len", "levels", "identify", "the", "set", "of", "colors", "to", "use", "if", "isinstance", "palette", "dict", "missing", "set", "levels", "set", "palette", "if", "any", "missing", "err", "the", "palette", "dictionary", "is", "missing", "keys", "raise", "valueerror", "err", "format", "missing", "lookup_table", "palette", "else", "if", "palette", "is", "none", "if", "n_colors", "len", "get_color_cycle", "colors", "color_palette", "none", "n_colors", "else", "colors", "color_palette", "husl", "n_colors", "elif", "isinstance", "palette", "list", "colors", "self", "_check_list_length", "levels", "palette", "palette", "else", "colors", "color_palette", "palette", "n_colors", "lookup_table", "dict", "zip", "levels", "colors", "return", "levels", "lookup_table"], "doc_len": 107}
{"doc_id": "seaborn/_oldcore.py::HueMapping.numeric_mapping", "file_path": "seaborn/_oldcore.py", "class_name": "HueMapping", "func_name": "numeric_mapping", "text": "文件路径: seaborn/_oldcore.py, 类名: HueMapping\n    def numeric_mapping(self, data, palette, norm):\n        \"\"\"Determine colors when the hue variable is quantitative.\"\"\"\n        if isinstance(palette, dict):\n\n            # The presence of a norm object overrides a dictionary of hues\n            # in specifying a numeric mapping, so we need to process it here.\n            levels = list(sorted(palette))\n            colors = [palette[k] for k in sorted(palette)]\n            cmap = mpl.colors.ListedColormap(colors)\n            lookup_table = palette.copy()\n\n        else:\n\n            # The levels are the sorted unique values in the data\n            levels = list(np.sort(remove_na(data.unique())))\n\n            # --- Sort out the colormap to use from the palette argument\n\n            # Default numeric palette is our default cubehelix palette\n            # TODO do we want to do something complicated to ensure contrast?\n            palette = \"ch:\" if palette is None else palette\n\n            if isinstance(palette, mpl.colors.Colormap):\n                cmap = palette\n            else:\n                cmap = color_palette(palette, as_cmap=True)\n\n            # Now sort out the data normalization\n            if norm is None:\n                norm = mpl.colors.Normalize()\n            elif isinstance(norm, tuple):\n                norm = mpl.colors.Normalize(*norm)\n            elif not isinstance(norm, mpl.colors.Normalize):\n                err = \"``hue_norm`` must be None, tuple, or Normalize object.\"\n                raise ValueError(err)\n\n            if not norm.scaled():\n                norm(np.asarray(data.dropna()))\n\n            lookup_table = dict(zip(levels, cmap(norm(levels))))\n\n        return levels, lookup_table, norm, cmap\n", "tokens": ["seaborn", "_oldcore", "py", "huemapping", "def", "numeric_mapping", "self", "data", "palette", "norm", "determine", "colors", "when", "the", "hue", "variable", "is", "quantitative", "if", "isinstance", "palette", "dict", "the", "presence", "of", "a", "norm", "object", "overrides", "a", "dictionary", "of", "hues", "in", "specifying", "a", "numeric", "mapping", "so", "we", "need", "to", "process", "it", "here", "levels", "list", "sorted", "palette", "colors", "palette", "k", "for", "k", "in", "sorted", "palette", "cmap", "mpl", "colors", "listedcolormap", "colors", "lookup_table", "palette", "copy", "else", "the", "levels", "are", "the", "sorted", "unique", "values", "in", "the", "data", "levels", "list", "np", "sort", "remove_na", "data", "unique", "sort", "out", "the", "colormap", "to", "use", "from", "the", "palette", "argument", "default", "numeric", "palette", "is", "our", "default", "cubehelix", "palette", "todo", "do", "we", "want", "to", "do", "something", "complicated", "to", "ensure", "contrast", "palette", "ch", "if", "palette", "is", "none", "else", "palette", "if", "isinstance", "palette", "mpl", "colors", "colormap", "cmap", "palette", "else", "cmap", "color_palette", "palette", "as_cmap", "true", "now", "sort", "out", "the", "data", "normalization", "if", "norm", "is", "none", "norm", "mpl", "colors", "normalize", "elif", "isinstance", "norm", "tuple", "norm", "mpl", "colors", "normalize", "norm", "elif", "not", "isinstance", "norm", "mpl", "colors", "normalize", "err", "hue_norm", "must", "be", "none", "tuple", "or", "normalize", "object", "raise", "valueerror", "err", "if", "not", "norm", "scaled", "norm", "np", "asarray", "data", "dropna", "lookup_table", "dict", "zip", "levels", "cmap", "norm", "levels", "return", "levels", "lookup_table", "norm", "cmap"], "doc_len": 197}
{"doc_id": "seaborn/_oldcore.py::SizeMapping.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "SizeMapping", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: SizeMapping\n    def __init__(\n        self, plotter, sizes=None, order=None, norm=None,\n    ):\n        \"\"\"Map the levels of the `size` variable to distinct values.\n\n        Parameters\n        ----------\n        # TODO add generic parameters\n\n        \"\"\"\n        super().__init__(plotter)\n\n        data = plotter.plot_data.get(\"size\", pd.Series(dtype=float))\n\n        if data.notna().any():\n\n            map_type = self.infer_map_type(\n                norm, sizes, plotter.var_types[\"size\"]\n            )\n\n            # --- Option 1: numeric mapping\n\n            if map_type == \"numeric\":\n\n                levels, lookup_table, norm, size_range = self.numeric_mapping(\n                    data, sizes, norm,\n                )\n\n            # --- Option 2: categorical mapping\n\n            elif map_type == \"categorical\":\n\n                levels, lookup_table = self.categorical_mapping(\n                    data, sizes, order,\n                )\n                size_range = None\n\n            # --- Option 3: datetime mapping\n\n            # TODO this needs an actual implementation\n            else:\n\n                levels, lookup_table = self.categorical_mapping(\n                    # Casting data to list to handle differences in the way\n                    # pandas and numpy represent datetime64 data\n                    list(data), sizes, order,\n                )\n                size_range = None\n\n            self.map_type = map_type\n            self.levels = levels\n            self.norm = norm\n            self.sizes = sizes\n            self.size_range = size_range\n            self.lookup_table = lookup_table\n", "tokens": ["seaborn", "_oldcore", "py", "sizemapping", "def", "__init__", "self", "plotter", "sizes", "none", "order", "none", "norm", "none", "map", "the", "levels", "of", "the", "size", "variable", "to", "distinct", "values", "parameters", "todo", "add", "generic", "parameters", "super", "__init__", "plotter", "data", "plotter", "plot_data", "get", "size", "pd", "series", "dtype", "float", "if", "data", "notna", "any", "map_type", "self", "infer_map_type", "norm", "sizes", "plotter", "var_types", "size", "option", "1", "numeric", "mapping", "if", "map_type", "numeric", "levels", "lookup_table", "norm", "size_range", "self", "numeric_mapping", "data", "sizes", "norm", "option", "2", "categorical", "mapping", "elif", "map_type", "categorical", "levels", "lookup_table", "self", "categorical_mapping", "data", "sizes", "order", "size_range", "none", "option", "3", "datetime", "mapping", "todo", "this", "needs", "an", "actual", "implementation", "else", "levels", "lookup_table", "self", "categorical_mapping", "casting", "data", "to", "list", "to", "handle", "differences", "in", "the", "way", "pandas", "and", "numpy", "represent", "datetime64", "data", "list", "data", "sizes", "order", "size_range", "none", "self", "map_type", "map_type", "self", "levels", "levels", "self", "norm", "norm", "self", "sizes", "sizes", "self", "size_range", "size_range", "self", "lookup_table", "lookup_table"], "doc_len": 140}
{"doc_id": "seaborn/_oldcore.py::SizeMapping.infer_map_type", "file_path": "seaborn/_oldcore.py", "class_name": "SizeMapping", "func_name": "infer_map_type", "text": "文件路径: seaborn/_oldcore.py, 类名: SizeMapping\n    def infer_map_type(self, norm, sizes, var_type):\n\n        if norm is not None:\n            map_type = \"numeric\"\n        elif isinstance(sizes, (dict, list)):\n            map_type = \"categorical\"\n        else:\n            map_type = var_type\n\n        return map_type\n", "tokens": ["seaborn", "_oldcore", "py", "sizemapping", "def", "infer_map_type", "self", "norm", "sizes", "var_type", "if", "norm", "is", "not", "none", "map_type", "numeric", "elif", "isinstance", "sizes", "dict", "list", "map_type", "categorical", "else", "map_type", "var_type", "return", "map_type"], "doc_len": 29}
{"doc_id": "seaborn/_oldcore.py::SizeMapping._lookup_single", "file_path": "seaborn/_oldcore.py", "class_name": "SizeMapping", "func_name": "_lookup_single", "text": "文件路径: seaborn/_oldcore.py, 类名: SizeMapping\n    def _lookup_single(self, key):\n\n        try:\n            value = self.lookup_table[key]\n        except KeyError:\n            normed = self.norm(key)\n            if np.ma.is_masked(normed):\n                normed = np.nan\n            value = self.size_range[0] + normed * np.ptp(self.size_range)\n        return value\n", "tokens": ["seaborn", "_oldcore", "py", "sizemapping", "def", "_lookup_single", "self", "key", "try", "value", "self", "lookup_table", "key", "except", "keyerror", "normed", "self", "norm", "key", "if", "np", "ma", "is_masked", "normed", "normed", "np", "nan", "value", "self", "size_range", "0", "normed", "np", "ptp", "self", "size_range", "return", "value"], "doc_len": 38}
{"doc_id": "seaborn/_oldcore.py::SizeMapping.categorical_mapping", "file_path": "seaborn/_oldcore.py", "class_name": "SizeMapping", "func_name": "categorical_mapping", "text": "文件路径: seaborn/_oldcore.py, 类名: SizeMapping\n    def categorical_mapping(self, data, sizes, order):\n\n        levels = categorical_order(data, order)\n\n        if isinstance(sizes, dict):\n\n            # Dict inputs map existing data values to the size attribute\n            missing = set(levels) - set(sizes)\n            if any(missing):\n                err = f\"Missing sizes for the following levels: {missing}\"\n                raise ValueError(err)\n            lookup_table = sizes.copy()\n\n        elif isinstance(sizes, list):\n\n            # List inputs give size values in the same order as the levels\n            sizes = self._check_list_length(levels, sizes, \"sizes\")\n            lookup_table = dict(zip(levels, sizes))\n\n        else:\n\n            if isinstance(sizes, tuple):\n\n                # Tuple input sets the min, max size values\n                if len(sizes) != 2:\n                    err = \"A `sizes` tuple must have only 2 values\"\n                    raise ValueError(err)\n\n            elif sizes is not None:\n\n                err = f\"Value for `sizes` not understood: {sizes}\"\n                raise ValueError(err)\n\n            else:\n\n                # Otherwise, we need to get the min, max size values from\n                # the plotter object we are attached to.\n\n                # TODO this is going to cause us trouble later, because we\n                # want to restructure things so that the plotter is generic\n                # across the visual representation of the data. But at this\n                # point, we don't know the visual representation. Likely we\n                # want to change the logic of this Mapping so that it gives\n                # points on a normalized range that then gets un-normalized\n                # when we know what we're drawing. But given the way the\n                # package works now, this way is cleanest.\n                sizes = self.plotter._default_size_range\n\n            # For categorical sizes, use regularly-spaced linear steps\n            # between the minimum and maximum sizes. Then reverse the\n            # ramp so that the largest value is used for the first entry\n            # in size_order, etc. This is because \"ordered\" categories\n            # are often though to go in decreasing priority.\n            sizes = np.linspace(*sizes, len(levels))[::-1]\n            lookup_table = dict(zip(levels, sizes))\n\n        return levels, lookup_table\n", "tokens": ["seaborn", "_oldcore", "py", "sizemapping", "def", "categorical_mapping", "self", "data", "sizes", "order", "levels", "categorical_order", "data", "order", "if", "isinstance", "sizes", "dict", "dict", "inputs", "map", "existing", "data", "values", "to", "the", "size", "attribute", "missing", "set", "levels", "set", "sizes", "if", "any", "missing", "err", "f", "missing", "sizes", "for", "the", "following", "levels", "missing", "raise", "valueerror", "err", "lookup_table", "sizes", "copy", "elif", "isinstance", "sizes", "list", "list", "inputs", "give", "size", "values", "in", "the", "same", "order", "as", "the", "levels", "sizes", "self", "_check_list_length", "levels", "sizes", "sizes", "lookup_table", "dict", "zip", "levels", "sizes", "else", "if", "isinstance", "sizes", "tuple", "tuple", "input", "sets", "the", "min", "max", "size", "values", "if", "len", "sizes", "2", "err", "a", "sizes", "tuple", "must", "have", "only", "2", "values", "raise", "valueerror", "err", "elif", "sizes", "is", "not", "none", "err", "f", "value", "for", "sizes", "not", "understood", "sizes", "raise", "valueerror", "err", "else", "otherwise", "we", "need", "to", "get", "the", "min", "max", "size", "values", "from", "the", "plotter", "object", "we", "are", "attached", "to", "todo", "this", "is", "going", "to", "cause", "us", "trouble", "later", "because", "we", "want", "to", "restructure", "things", "so", "that", "the", "plotter", "is", "generic", "across", "the", "visual", "representation", "of", "the", "data", "but", "at", "this", "point", "we", "don", "t", "know", "the", "visual", "representation", "likely", "we", "want", "to", "change", "the", "logic", "of", "this", "mapping", "so", "that", "it", "gives", "points", "on", "a", "normalized", "range", "that", "then", "gets", "un", "normalized", "when", "we", "know", "what", "we", "re", "drawing", "but", "given", "the", "way", "the", "package", "works", "now", "this", "way", "is", "cleanest", "sizes", "self", "plotter", "_default_size_range", "for", "categorical", "sizes", "use", "regularly", "spaced", "linear", "steps", "between", "the", "minimum", "and", "maximum", "sizes", "then", "reverse", "the", "ramp", "so", "that", "the", "largest", "value", "is", "used", "for", "the", "first", "entry", "in", "size_order", "etc", "this", "is", "because", "ordered", "categories", "are", "often", "though", "to", "go", "in", "decreasing", "priority", "sizes", "np", "linspace", "sizes", "len", "levels", "1", "lookup_table", "dict", "zip", "levels", "sizes", "return", "levels", "lookup_table"], "doc_len": 288}
{"doc_id": "seaborn/_oldcore.py::SizeMapping.numeric_mapping", "file_path": "seaborn/_oldcore.py", "class_name": "SizeMapping", "func_name": "numeric_mapping", "text": "文件路径: seaborn/_oldcore.py, 类名: SizeMapping\n    def numeric_mapping(self, data, sizes, norm):\n\n        if isinstance(sizes, dict):\n            # The presence of a norm object overrides a dictionary of sizes\n            # in specifying a numeric mapping, so we need to process it\n            # dictionary here\n            levels = list(np.sort(list(sizes)))\n            size_values = sizes.values()\n            size_range = min(size_values), max(size_values)\n\n        else:\n\n            # The levels here will be the unique values in the data\n            levels = list(np.sort(remove_na(data.unique())))\n\n            if isinstance(sizes, tuple):\n\n                # For numeric inputs, the size can be parametrized by\n                # the minimum and maximum artist values to map to. The\n                # norm object that gets set up next specifies how to\n                # do the mapping.\n\n                if len(sizes) != 2:\n                    err = \"A `sizes` tuple must have only 2 values\"\n                    raise ValueError(err)\n\n                size_range = sizes\n\n            elif sizes is not None:\n\n                err = f\"Value for `sizes` not understood: {sizes}\"\n                raise ValueError(err)\n\n            else:\n\n                # When not provided, we get the size range from the plotter\n                # object we are attached to. See the note in the categorical\n                # method about how this is suboptimal for future development.\n                size_range = self.plotter._default_size_range\n\n        # Now that we know the minimum and maximum sizes that will get drawn,\n        # we need to map the data values that we have into that range. We will\n        # use a matplotlib Normalize class, which is typically used for numeric\n        # color mapping but works fine here too. It takes data values and maps\n        # them into a [0, 1] interval, potentially nonlinear-ly.\n\n        if norm is None:\n            # Default is a linear function between the min and max data values\n            norm = mpl.colors.Normalize()\n        elif isinstance(norm, tuple):\n            # It is also possible to give different limits in data space\n            norm = mpl.colors.Normalize(*norm)\n        elif not isinstance(norm, mpl.colors.Normalize):\n            err = f\"Value for size `norm` parameter not understood: {norm}\"\n            raise ValueError(err)\n        else:\n            # If provided with Normalize object, copy it so we can modify\n            norm = copy(norm)\n\n        # Set the mapping so all output values are in [0, 1]\n        norm.clip = True\n\n        # If the input range is not set, use the full range of the data\n        if not norm.scaled():\n            norm(levels)\n\n        # Map from data values to [0, 1] range\n        sizes_scaled = norm(levels)\n\n        # Now map from the scaled range into the artist units\n        if isinstance(sizes, dict):\n            lookup_table = sizes\n        else:\n            lo, hi = size_range\n            sizes = lo + sizes_scaled * (hi - lo)\n            lookup_table = dict(zip(levels, sizes))\n\n        return levels, lookup_table, norm, size_range\n", "tokens": ["seaborn", "_oldcore", "py", "sizemapping", "def", "numeric_mapping", "self", "data", "sizes", "norm", "if", "isinstance", "sizes", "dict", "the", "presence", "of", "a", "norm", "object", "overrides", "a", "dictionary", "of", "sizes", "in", "specifying", "a", "numeric", "mapping", "so", "we", "need", "to", "process", "it", "dictionary", "here", "levels", "list", "np", "sort", "list", "sizes", "size_values", "sizes", "values", "size_range", "min", "size_values", "max", "size_values", "else", "the", "levels", "here", "will", "be", "the", "unique", "values", "in", "the", "data", "levels", "list", "np", "sort", "remove_na", "data", "unique", "if", "isinstance", "sizes", "tuple", "for", "numeric", "inputs", "the", "size", "can", "be", "parametrized", "by", "the", "minimum", "and", "maximum", "artist", "values", "to", "map", "to", "the", "norm", "object", "that", "gets", "set", "up", "next", "specifies", "how", "to", "do", "the", "mapping", "if", "len", "sizes", "2", "err", "a", "sizes", "tuple", "must", "have", "only", "2", "values", "raise", "valueerror", "err", "size_range", "sizes", "elif", "sizes", "is", "not", "none", "err", "f", "value", "for", "sizes", "not", "understood", "sizes", "raise", "valueerror", "err", "else", "when", "not", "provided", "we", "get", "the", "size", "range", "from", "the", "plotter", "object", "we", "are", "attached", "to", "see", "the", "note", "in", "the", "categorical", "method", "about", "how", "this", "is", "suboptimal", "for", "future", "development", "size_range", "self", "plotter", "_default_size_range", "now", "that", "we", "know", "the", "minimum", "and", "maximum", "sizes", "that", "will", "get", "drawn", "we", "need", "to", "map", "the", "data", "values", "that", "we", "have", "into", "that", "range", "we", "will", "use", "a", "matplotlib", "normalize", "class", "which", "is", "typically", "used", "for", "numeric", "color", "mapping", "but", "works", "fine", "here", "too", "it", "takes", "data", "values", "and", "maps", "them", "into", "a", "0", "1", "interval", "potentially", "nonlinear", "ly", "if", "norm", "is", "none", "default", "is", "a", "linear", "function", "between", "the", "min", "and", "max", "data", "values", "norm", "mpl", "colors", "normalize", "elif", "isinstance", "norm", "tuple", "it", "is", "also", "possible", "to", "give", "different", "limits", "in", "data", "space", "norm", "mpl", "colors", "normalize", "norm", "elif", "not", "isinstance", "norm", "mpl", "colors", "normalize", "err", "f", "value", "for", "size", "norm", "parameter", "not", "understood", "norm", "raise", "valueerror", "err", "else", "if", "provided", "with", "normalize", "object", "copy", "it", "so", "we", "can", "modify", "norm", "copy", "norm", "set", "the", "mapping", "so", "all", "output", "values", "are", "in", "0", "1", "norm", "clip", "true", "if", "the", "input", "range", "is", "not", "set", "use", "the", "full", "range", "of", "the", "data", "if", "not", "norm", "scaled", "norm", "levels", "map", "from", "data", "values", "to", "0", "1", "range", "sizes_scaled", "norm", "levels", "now", "map", "from", "the", "scaled", "range", "into", "the", "artist", "units", "if", "isinstance", "sizes", "dict", "lookup_table", "sizes", "else", "lo", "hi", "size_range", "sizes", "lo", "sizes_scaled", "hi", "lo", "lookup_table", "dict", "zip", "levels", "sizes", "return", "levels", "lookup_table", "norm", "size_range"], "doc_len": 393}
{"doc_id": "seaborn/_oldcore.py::StyleMapping.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "StyleMapping", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: StyleMapping\n    def __init__(\n        self, plotter, markers=None, dashes=None, order=None,\n    ):\n        \"\"\"Map the levels of the `style` variable to distinct values.\n\n        Parameters\n        ----------\n        # TODO add generic parameters\n\n        \"\"\"\n        super().__init__(plotter)\n\n        data = plotter.plot_data.get(\"style\", pd.Series(dtype=float))\n\n        if data.notna().any():\n\n            # Cast to list to handle numpy/pandas datetime quirks\n            if variable_type(data) == \"datetime\":\n                data = list(data)\n\n            # Find ordered unique values\n            levels = categorical_order(data, order)\n\n            markers = self._map_attributes(\n                markers, levels, unique_markers(len(levels)), \"markers\",\n            )\n            dashes = self._map_attributes(\n                dashes, levels, unique_dashes(len(levels)), \"dashes\",\n            )\n\n            # Build the paths matplotlib will use to draw the markers\n            paths = {}\n            filled_markers = []\n            for k, m in markers.items():\n                if not isinstance(m, mpl.markers.MarkerStyle):\n                    m = mpl.markers.MarkerStyle(m)\n                paths[k] = m.get_path().transformed(m.get_transform())\n                filled_markers.append(m.is_filled())\n\n            # Mixture of filled and unfilled markers will show line art markers\n            # in the edge color, which defaults to white. This can be handled,\n            # but there would be additional complexity with specifying the\n            # weight of the line art markers without overwhelming the filled\n            # ones with the edges. So for now, we will disallow mixtures.\n            if any(filled_markers) and not all(filled_markers):\n                err = \"Filled and line art markers cannot be mixed\"\n                raise ValueError(err)\n\n            lookup_table = {}\n            for key in levels:\n                lookup_table[key] = {}\n                if markers:\n                    lookup_table[key][\"marker\"] = markers[key]\n                    lookup_table[key][\"path\"] = paths[key]\n                if dashes:\n                    lookup_table[key][\"dashes\"] = dashes[key]\n\n            self.levels = levels\n            self.lookup_table = lookup_table\n", "tokens": ["seaborn", "_oldcore", "py", "stylemapping", "def", "__init__", "self", "plotter", "markers", "none", "dashes", "none", "order", "none", "map", "the", "levels", "of", "the", "style", "variable", "to", "distinct", "values", "parameters", "todo", "add", "generic", "parameters", "super", "__init__", "plotter", "data", "plotter", "plot_data", "get", "style", "pd", "series", "dtype", "float", "if", "data", "notna", "any", "cast", "to", "list", "to", "handle", "numpy", "pandas", "datetime", "quirks", "if", "variable_type", "data", "datetime", "data", "list", "data", "find", "ordered", "unique", "values", "levels", "categorical_order", "data", "order", "markers", "self", "_map_attributes", "markers", "levels", "unique_markers", "len", "levels", "markers", "dashes", "self", "_map_attributes", "dashes", "levels", "unique_dashes", "len", "levels", "dashes", "build", "the", "paths", "matplotlib", "will", "use", "to", "draw", "the", "markers", "paths", "filled_markers", "for", "k", "m", "in", "markers", "items", "if", "not", "isinstance", "m", "mpl", "markers", "markerstyle", "m", "mpl", "markers", "markerstyle", "m", "paths", "k", "m", "get_path", "transformed", "m", "get_transform", "filled_markers", "append", "m", "is_filled", "mixture", "of", "filled", "and", "unfilled", "markers", "will", "show", "line", "art", "markers", "in", "the", "edge", "color", "which", "defaults", "to", "white", "this", "can", "be", "handled", "but", "there", "would", "be", "additional", "complexity", "with", "specifying", "the", "weight", "of", "the", "line", "art", "markers", "without", "overwhelming", "the", "filled", "ones", "with", "the", "edges", "so", "for", "now", "we", "will", "disallow", "mixtures", "if", "any", "filled_markers", "and", "not", "all", "filled_markers", "err", "filled", "and", "line", "art", "markers", "cannot", "be", "mixed", "raise", "valueerror", "err", "lookup_table", "for", "key", "in", "levels", "lookup_table", "key", "if", "markers", "lookup_table", "key", "marker", "markers", "key", "lookup_table", "key", "path", "paths", "key", "if", "dashes", "lookup_table", "key", "dashes", "dashes", "key", "self", "levels", "levels", "self", "lookup_table", "lookup_table"], "doc_len": 232}
{"doc_id": "seaborn/_oldcore.py::StyleMapping._lookup_single", "file_path": "seaborn/_oldcore.py", "class_name": "StyleMapping", "func_name": "_lookup_single", "text": "文件路径: seaborn/_oldcore.py, 类名: StyleMapping\n    def _lookup_single(self, key, attr=None):\n        \"\"\"Get attribute(s) for a given data point.\"\"\"\n        if attr is None:\n            value = self.lookup_table[key]\n        else:\n            value = self.lookup_table[key][attr]\n        return value\n", "tokens": ["seaborn", "_oldcore", "py", "stylemapping", "def", "_lookup_single", "self", "key", "attr", "none", "get", "attribute", "s", "for", "a", "given", "data", "point", "if", "attr", "is", "none", "value", "self", "lookup_table", "key", "else", "value", "self", "lookup_table", "key", "attr", "return", "value"], "doc_len": 34}
{"doc_id": "seaborn/_oldcore.py::StyleMapping._map_attributes", "file_path": "seaborn/_oldcore.py", "class_name": "StyleMapping", "func_name": "_map_attributes", "text": "文件路径: seaborn/_oldcore.py, 类名: StyleMapping\n    def _map_attributes(self, arg, levels, defaults, attr):\n        \"\"\"Handle the specification for a given style attribute.\"\"\"\n        if arg is True:\n            lookup_table = dict(zip(levels, defaults))\n        elif isinstance(arg, dict):\n            missing = set(levels) - set(arg)\n            if missing:\n                err = f\"These `{attr}` levels are missing values: {missing}\"\n                raise ValueError(err)\n            lookup_table = arg\n        elif isinstance(arg, Sequence):\n            arg = self._check_list_length(levels, arg, attr)\n            lookup_table = dict(zip(levels, arg))\n        elif arg:\n            err = f\"This `{attr}` argument was not understood: {arg}\"\n            raise ValueError(err)\n        else:\n            lookup_table = {}\n\n        return lookup_table\n", "tokens": ["seaborn", "_oldcore", "py", "stylemapping", "def", "_map_attributes", "self", "arg", "levels", "defaults", "attr", "handle", "the", "specification", "for", "a", "given", "style", "attribute", "if", "arg", "is", "true", "lookup_table", "dict", "zip", "levels", "defaults", "elif", "isinstance", "arg", "dict", "missing", "set", "levels", "set", "arg", "if", "missing", "err", "f", "these", "attr", "levels", "are", "missing", "values", "missing", "raise", "valueerror", "err", "lookup_table", "arg", "elif", "isinstance", "arg", "sequence", "arg", "self", "_check_list_length", "levels", "arg", "attr", "lookup_table", "dict", "zip", "levels", "arg", "elif", "arg", "err", "f", "this", "attr", "argument", "was", "not", "understood", "arg", "raise", "valueerror", "err", "else", "lookup_table", "return", "lookup_table"], "doc_len": 86}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def __init__(self, data=None, variables={}):\n\n        self._var_levels = {}\n        # var_ordered is relevant only for categorical axis variables, and may\n        # be better handled by an internal axis information object that tracks\n        # such information and is set up by the scale_* methods. The analogous\n        # information for numeric axes would be information about log scales.\n        self._var_ordered = {\"x\": False, \"y\": False}  # alt., used DefaultDict\n        self.assign_variables(data, variables)\n\n        for var, cls in self._semantic_mappings.items():\n\n            # Create the mapping function\n            map_func = partial(cls.map, plotter=self)\n            setattr(self, f\"map_{var}\", map_func)\n\n            # Call the mapping function to initialize with default values\n            getattr(self, f\"map_{var}\")()\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "__init__", "self", "data", "none", "variables", "self", "_var_levels", "var_ordered", "is", "relevant", "only", "for", "categorical", "axis", "variables", "and", "may", "be", "better", "handled", "by", "an", "internal", "axis", "information", "object", "that", "tracks", "such", "information", "and", "is", "set", "up", "by", "the", "scale_", "methods", "the", "analogous", "information", "for", "numeric", "axes", "would", "be", "information", "about", "log", "scales", "self", "_var_ordered", "x", "false", "y", "false", "alt", "used", "defaultdict", "self", "assign_variables", "data", "variables", "for", "var", "cls", "in", "self", "_semantic_mappings", "items", "create", "the", "mapping", "function", "map_func", "partial", "cls", "map", "plotter", "self", "setattr", "self", "f", "map_", "var", "map_func", "call", "the", "mapping", "function", "to", "initialize", "with", "default", "values", "getattr", "self", "f", "map_", "var"], "doc_len": 105}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.get_semantics", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "get_semantics", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def get_semantics(cls, kwargs, semantics=None):\n        \"\"\"Subset a dictionary arguments with known semantic variables.\"\"\"\n        # TODO this should be get_variables since we have included x and y\n        if semantics is None:\n            semantics = cls.semantics\n        variables = {}\n        for key, val in kwargs.items():\n            if key in semantics and val is not None:\n                variables[key] = val\n        return variables\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "get_semantics", "cls", "kwargs", "semantics", "none", "subset", "a", "dictionary", "arguments", "with", "known", "semantic", "variables", "todo", "this", "should", "be", "get_variables", "since", "we", "have", "included", "x", "and", "y", "if", "semantics", "is", "none", "semantics", "cls", "semantics", "variables", "for", "key", "val", "in", "kwargs", "items", "if", "key", "in", "semantics", "and", "val", "is", "not", "none", "variables", "key", "val", "return", "variables"], "doc_len": 58}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.has_xy_data", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "has_xy_data", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def has_xy_data(self):\n        \"\"\"Return True at least one of x or y is defined.\"\"\"\n        return bool({\"x\", \"y\"} & set(self.variables))\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "has_xy_data", "self", "return", "true", "at", "least", "one", "of", "x", "or", "y", "is", "defined", "return", "bool", "x", "y", "set", "self", "variables"], "doc_len": 25}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.var_levels", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "var_levels", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def var_levels(self):\n        \"\"\"Property interface to ordered list of variables levels.\n\n        Each time it's accessed, it updates the var_levels dictionary with the\n        list of levels in the current semantic mappers. But it also allows the\n        dictionary to persist, so it can be used to set levels by a key. This is\n        used to track the list of col/row levels using an attached FacetGrid\n        object, but it's kind of messy and ideally fixed by improving the\n        faceting logic so it interfaces better with the modern approach to\n        tracking plot variables.\n\n        \"\"\"\n        for var in self.variables:\n            try:\n                map_obj = getattr(self, f\"_{var}_map\")\n                self._var_levels[var] = map_obj.levels\n            except AttributeError:\n                pass\n        return self._var_levels\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "var_levels", "self", "property", "interface", "to", "ordered", "list", "of", "variables", "levels", "each", "time", "it", "s", "accessed", "it", "updates", "the", "var_levels", "dictionary", "with", "the", "list", "of", "levels", "in", "the", "current", "semantic", "mappers", "but", "it", "also", "allows", "the", "dictionary", "to", "persist", "so", "it", "can", "be", "used", "to", "set", "levels", "by", "a", "key", "this", "is", "used", "to", "track", "the", "list", "of", "col", "row", "levels", "using", "an", "attached", "facetgrid", "object", "but", "it", "s", "kind", "of", "messy", "and", "ideally", "fixed", "by", "improving", "the", "faceting", "logic", "so", "it", "interfaces", "better", "with", "the", "modern", "approach", "to", "tracking", "plot", "variables", "for", "var", "in", "self", "variables", "try", "map_obj", "getattr", "self", "f", "_", "var", "_map", "self", "_var_levels", "var", "map_obj", "levels", "except", "attributeerror", "pass", "return", "self", "_var_levels"], "doc_len": 120}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.assign_variables", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "assign_variables", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def assign_variables(self, data=None, variables={}):\n        \"\"\"Define plot variables, optionally using lookup from `data`.\"\"\"\n        x = variables.get(\"x\", None)\n        y = variables.get(\"y\", None)\n\n        if x is None and y is None:\n            self.input_format = \"wide\"\n            plot_data, variables = self._assign_variables_wideform(\n                data, **variables,\n            )\n        else:\n            self.input_format = \"long\"\n            plot_data, variables = self._assign_variables_longform(\n                data, **variables,\n            )\n\n        self.plot_data = plot_data\n        self.variables = variables\n        self.var_types = {\n            v: variable_type(\n                plot_data[v],\n                boolean_type=\"numeric\" if v in \"xy\" else \"categorical\"\n            )\n            for v in variables\n        }\n\n        return self\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "assign_variables", "self", "data", "none", "variables", "define", "plot", "variables", "optionally", "using", "lookup", "from", "data", "x", "variables", "get", "x", "none", "y", "variables", "get", "y", "none", "if", "x", "is", "none", "and", "y", "is", "none", "self", "input_format", "wide", "plot_data", "variables", "self", "_assign_variables_wideform", "data", "variables", "else", "self", "input_format", "long", "plot_data", "variables", "self", "_assign_variables_longform", "data", "variables", "self", "plot_data", "plot_data", "self", "variables", "variables", "self", "var_types", "v", "variable_type", "plot_data", "v", "boolean_type", "numeric", "if", "v", "in", "xy", "else", "categorical", "for", "v", "in", "variables", "return", "self"], "doc_len": 81}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._assign_variables_wideform", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_assign_variables_wideform", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _assign_variables_wideform(self, data=None, **kwargs):\n        \"\"\"Define plot variables given wide-form data.\n\n        Parameters\n        ----------\n        data : flat vector or collection of vectors\n            Data can be a vector or mapping that is coerceable to a Series\n            or a sequence- or mapping-based collection of such vectors, or a\n            rectangular numpy array, or a Pandas DataFrame.\n        kwargs : variable -> data mappings\n            Behavior with keyword arguments is currently undefined.\n\n        Returns\n        -------\n        plot_data : :class:`pandas.DataFrame`\n            Long-form data object mapping seaborn variables (x, y, hue, ...)\n            to data vectors.\n        variables : dict\n            Keys are defined seaborn variables; values are names inferred from\n            the inputs (or None when no name can be determined).\n\n        \"\"\"\n        # Raise if semantic or other variables are assigned in wide-form mode\n        assigned = [k for k, v in kwargs.items() if v is not None]\n        if any(assigned):\n            s = \"s\" if len(assigned) > 1 else \"\"\n            err = f\"The following variable{s} cannot be assigned with wide-form data: \"\n            err += \", \".join(f\"`{v}`\" for v in assigned)\n            raise ValueError(err)\n\n        # Determine if the data object actually has any data in it\n        empty = data is None or not len(data)\n\n        # Then, determine if we have \"flat\" data (a single vector)\n        if isinstance(data, dict):\n            values = data.values()\n        else:\n            values = np.atleast_1d(np.asarray(data, dtype=object))\n        flat = not any(\n            isinstance(v, Iterable) and not isinstance(v, (str, bytes))\n            for v in values\n        )\n\n        if empty:\n\n            # Make an object with the structure of plot_data, but empty\n            plot_data = pd.DataFrame()\n            variables = {}\n\n        elif flat:\n\n            # Handle flat data by converting to pandas Series and using the\n            # index and/or values to define x and/or y\n            # (Could be accomplished with a more general to_series() interface)\n            flat_data = pd.Series(data).copy()\n            names = {\n                \"@values\": flat_data.name,\n                \"@index\": flat_data.index.name\n            }\n\n            plot_data = {}\n            variables = {}\n\n            for var in [\"x\", \"y\"]:\n                if var in self.flat_structure:\n                    attr = self.flat_structure[var]\n                    plot_data[var] = getattr(flat_data, attr[1:])\n                    variables[var] = names[self.flat_structure[var]]\n\n            plot_data = pd.DataFrame(plot_data)\n\n        else:\n\n            # Otherwise assume we have some collection of vectors.\n\n            # Handle Python sequences such that entries end up in the columns,\n            # not in the rows, of the intermediate wide DataFrame.\n            # One way to accomplish this is to convert to a dict of Series.\n            if isinstance(data, Sequence):\n                data_dict = {}\n                for i, var in enumerate(data):\n                    key = getattr(var, \"name\", i)\n                    # TODO is there a safer/more generic way to ensure Series?\n                    # sort of like np.asarray, but for pandas?\n                    data_dict[key] = pd.Series(var)\n\n                data = data_dict\n\n            # Pandas requires that dict values either be Series objects\n            # or all have the same length, but we want to allow \"ragged\" inputs\n            if isinstance(data, Mapping):\n                data = {key: pd.Series(val) for key, val in data.items()}\n\n            # Otherwise, delegate to the pandas DataFrame constructor\n            # This is where we'd prefer to use a general interface that says\n            # \"give me this data as a pandas DataFrame\", so we can accept\n            # DataFrame objects from other libraries\n            wide_data = pd.DataFrame(data, copy=True)\n\n            # At this point we should reduce the dataframe to numeric cols\n            numeric_cols = [\n                k for k, v in wide_data.items() if variable_type(v) == \"numeric\"\n            ]\n            wide_data = wide_data[numeric_cols]\n\n            # Now melt the data to long form\n            melt_kws = {\"var_name\": \"@columns\", \"value_name\": \"@values\"}\n            use_index = \"@index\" in self.wide_structure.values()\n            if use_index:\n                melt_kws[\"id_vars\"] = \"@index\"\n                try:\n                    orig_categories = wide_data.columns.categories\n                    orig_ordered = wide_data.columns.ordered\n                    wide_data.columns = wide_data.columns.add_categories(\"@index\")\n                except AttributeError:\n                    category_columns = False\n                else:\n                    category_columns = True\n                wide_data[\"@index\"] = wide_data.index.to_series()\n\n            plot_data = wide_data.melt(**melt_kws)\n\n            if use_index and category_columns:\n                plot_data[\"@columns\"] = pd.Categorical(plot_data[\"@columns\"],\n                                                       orig_categories,\n                                                       orig_ordered)\n\n            # Assign names corresponding to plot semantics\n            for var, attr in self.wide_structure.items():\n                plot_data[var] = plot_data[attr]\n\n            # Define the variable names\n            variables = {}\n            for var, attr in self.wide_structure.items():\n                obj = getattr(wide_data, attr[1:])\n                variables[var] = getattr(obj, \"name\", None)\n\n            # Remove redundant columns from plot_data\n            plot_data = plot_data[list(variables)]\n\n        return plot_data, variables\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_assign_variables_wideform", "self", "data", "none", "kwargs", "define", "plot", "variables", "given", "wide", "form", "data", "parameters", "data", "flat", "vector", "or", "collection", "of", "vectors", "data", "can", "be", "a", "vector", "or", "mapping", "that", "is", "coerceable", "to", "a", "series", "or", "a", "sequence", "or", "mapping", "based", "collection", "of", "such", "vectors", "or", "a", "rectangular", "numpy", "array", "or", "a", "pandas", "dataframe", "kwargs", "variable", "data", "mappings", "behavior", "with", "keyword", "arguments", "is", "currently", "undefined", "returns", "plot_data", "class", "pandas", "dataframe", "long", "form", "data", "object", "mapping", "seaborn", "variables", "x", "y", "hue", "to", "data", "vectors", "variables", "dict", "keys", "are", "defined", "seaborn", "variables", "values", "are", "names", "inferred", "from", "the", "inputs", "or", "none", "when", "no", "name", "can", "be", "determined", "raise", "if", "semantic", "or", "other", "variables", "are", "assigned", "in", "wide", "form", "mode", "assigned", "k", "for", "k", "v", "in", "kwargs", "items", "if", "v", "is", "not", "none", "if", "any", "assigned", "s", "s", "if", "len", "assigned", "1", "else", "err", "f", "the", "following", "variable", "s", "cannot", "be", "assigned", "with", "wide", "form", "data", "err", "join", "f", "v", "for", "v", "in", "assigned", "raise", "valueerror", "err", "determine", "if", "the", "data", "object", "actually", "has", "any", "data", "in", "it", "empty", "data", "is", "none", "or", "not", "len", "data", "then", "determine", "if", "we", "have", "flat", "data", "a", "single", "vector", "if", "isinstance", "data", "dict", "values", "data", "values", "else", "values", "np", "atleast_1d", "np", "asarray", "data", "dtype", "object", "flat", "not", "any", "isinstance", "v", "iterable", "and", "not", "isinstance", "v", "str", "bytes", "for", "v", "in", "values", "if", "empty", "make", "an", "object", "with", "the", "structure", "of", "plot_data", "but", "empty", "plot_data", "pd", "dataframe", "variables", "elif", "flat", "handle", "flat", "data", "by", "converting", "to", "pandas", "series", "and", "using", "the", "index", "and", "or", "values", "to", "define", "x", "and", "or", "y", "could", "be", "accomplished", "with", "a", "more", "general", "to_series", "interface", "flat_data", "pd", "series", "data", "copy", "names", "values", "flat_data", "name", "index", "flat_data", "index", "name", "plot_data", "variables", "for", "var", "in", "x", "y", "if", "var", "in", "self", "flat_structure", "attr", "self", "flat_structure", "var", "plot_data", "var", "getattr", "flat_data", "attr", "1", "variables", "var", "names", "self", "flat_structure", "var", "plot_data", "pd", "dataframe", "plot_data", "else", "otherwise", "assume", "we", "have", "some", "collection", "of", "vectors", "handle", "python", "sequences", "such", "that", "entries", "end", "up", "in", "the", "columns", "not", "in", "the", "rows", "of", "the", "intermediate", "wide", "dataframe", "one", "way", "to", "accomplish", "this", "is", "to", "convert", "to", "a", "dict", "of", "series", "if", "isinstance", "data", "sequence", "data_dict", "for", "i", "var", "in", "enumerate", "data", "key", "getattr", "var", "name", "i", "todo", "is", "there", "a", "safer", "more", "generic", "way", "to", "ensure", "series", "sort", "of", "like", "np", "asarray", "but", "for", "pandas", "data_dict", "key", "pd", "series", "var", "data", "data_dict", "pandas", "requires", "that", "dict", "values", "either", "be", "series", "objects", "or", "all", "have", "the", "same", "length", "but", "we", "want", "to", "allow", "ragged", "inputs", "if", "isinstance", "data", "mapping", "data", "key", "pd", "series", "val", "for", "key", "val", "in", "data", "items", "otherwise", "delegate", "to", "the", "pandas", "dataframe", "constructor", "this", "is", "where", "we", "d", "prefer", "to", "use", "a", "general", "interface", "that", "says", "give", "me", "this", "data", "as", "a", "pandas", "dataframe", "so", "we", "can", "accept", "dataframe", "objects", "from", "other", "libraries", "wide_data", "pd", "dataframe", "data", "copy", "true", "at", "this", "point", "we", "should", "reduce", "the", "dataframe", "to", "numeric", "cols", "numeric_cols", "k", "for", "k", "v", "in", "wide_data", "items", "if", "variable_type", "v", "numeric", "wide_data", "wide_data", "numeric_cols", "now", "melt", "the", "data", "to", "long", "form", "melt_kws", "var_name", "columns", "value_name", "values", "use_index", "index", "in", "self", "wide_structure", "values", "if", "use_index", "melt_kws", "id_vars", "index", "try", "orig_categories", "wide_data", "columns", "categories", "orig_ordered", "wide_data", "columns", "ordered", "wide_data", "columns", "wide_data", "columns", "add_categories", "index", "except", "attributeerror", "category_columns", "false", "else", "category_columns", "true", "wide_data", "index", "wide_data", "index", "to_series", "plot_data", "wide_data", "melt", "melt_kws", "if", "use_index", "and", "category_columns", "plot_data", "columns", "pd", "categorical", "plot_data", "columns", "orig_categories", "orig_ordered", "assign", "names", "corresponding", "to", "plot", "semantics", "for", "var", "attr", "in", "self", "wide_structure", "items", "plot_data", "var", "plot_data", "attr", "define", "the", "variable", "names", "variables", "for", "var", "attr", "in", "self", "wide_structure", "items", "obj", "getattr", "wide_data", "attr", "1", "variables", "var", "getattr", "obj", "name", "none", "remove", "redundant", "columns", "from", "plot_data", "plot_data", "plot_data", "list", "variables", "return", "plot_data", "variables"], "doc_len": 629}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._assign_variables_longform", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_assign_variables_longform", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _assign_variables_longform(self, data=None, **kwargs):\n        \"\"\"Define plot variables given long-form data and/or vector inputs.\n\n        Parameters\n        ----------\n        data : dict-like collection of vectors\n            Input data where variable names map to vector values.\n        kwargs : variable -> data mappings\n            Keys are seaborn variables (x, y, hue, ...) and values are vectors\n            in any format that can construct a :class:`pandas.DataFrame` or\n            names of columns or index levels in ``data``.\n\n        Returns\n        -------\n        plot_data : :class:`pandas.DataFrame`\n            Long-form data object mapping seaborn variables (x, y, hue, ...)\n            to data vectors.\n        variables : dict\n            Keys are defined seaborn variables; values are names inferred from\n            the inputs (or None when no name can be determined).\n\n        Raises\n        ------\n        ValueError\n            When variables are strings that don't appear in ``data``.\n\n        \"\"\"\n        plot_data = {}\n        variables = {}\n\n        # Data is optional; all variables can be defined as vectors\n        if data is None:\n            data = {}\n\n        # TODO should we try a data.to_dict() or similar here to more\n        # generally accept objects with that interface?\n        # Note that dict(df) also works for pandas, and gives us what we\n        # want, whereas DataFrame.to_dict() gives a nested dict instead of\n        # a dict of series.\n\n        # Variables can also be extracted from the index attribute\n        # TODO is this the most general way to enable it?\n        # There is no index.to_dict on multiindex, unfortunately\n        try:\n            index = data.index.to_frame()\n        except AttributeError:\n            index = {}\n\n        # The caller will determine the order of variables in plot_data\n        for key, val in kwargs.items():\n\n            # First try to treat the argument as a key for the data collection.\n            # But be flexible about what can be used as a key.\n            # Usually it will be a string, but allow numbers or tuples too when\n            # taking from the main data object. Only allow strings to reference\n            # fields in the index, because otherwise there is too much ambiguity.\n            try:\n                val_as_data_key = (\n                    val in data\n                    or (isinstance(val, (str, bytes)) and val in index)\n                )\n            except (KeyError, TypeError):\n                val_as_data_key = False\n\n            if val_as_data_key:\n\n                # We know that __getitem__ will work\n\n                if val in data:\n                    plot_data[key] = data[val]\n                elif val in index:\n                    plot_data[key] = index[val]\n                variables[key] = val\n\n            elif isinstance(val, (str, bytes)):\n\n                # This looks like a column name but we don't know what it means!\n\n                err = f\"Could not interpret value `{val}` for parameter `{key}`\"\n                raise ValueError(err)\n\n            else:\n\n                # Otherwise, assume the value is itself data\n\n                # Raise when data object is present and a vector can't matched\n                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):\n                    if np.ndim(val) and len(data) != len(val):\n                        val_cls = val.__class__.__name__\n                        err = (\n                            f\"Length of {val_cls} vectors must match length of `data`\"\n                            f\" when both are used, but `data` has length {len(data)}\"\n                            f\" and the vector passed to `{key}` has length {len(val)}.\"\n                        )\n                        raise ValueError(err)\n\n                plot_data[key] = val\n\n                # Try to infer the name of the variable\n                variables[key] = getattr(val, \"name\", None)\n\n        # Construct a tidy plot DataFrame. This will convert a number of\n        # types automatically, aligning on index in case of pandas objects\n        plot_data = pd.DataFrame(plot_data)\n\n        # Reduce the variables dictionary to fields with valid data\n        variables = {\n            var: name\n            for var, name in variables.items()\n            if plot_data[var].notnull().any()\n        }\n\n        return plot_data, variables\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_assign_variables_longform", "self", "data", "none", "kwargs", "define", "plot", "variables", "given", "long", "form", "data", "and", "or", "vector", "inputs", "parameters", "data", "dict", "like", "collection", "of", "vectors", "input", "data", "where", "variable", "names", "map", "to", "vector", "values", "kwargs", "variable", "data", "mappings", "keys", "are", "seaborn", "variables", "x", "y", "hue", "and", "values", "are", "vectors", "in", "any", "format", "that", "can", "construct", "a", "class", "pandas", "dataframe", "or", "names", "of", "columns", "or", "index", "levels", "in", "data", "returns", "plot_data", "class", "pandas", "dataframe", "long", "form", "data", "object", "mapping", "seaborn", "variables", "x", "y", "hue", "to", "data", "vectors", "variables", "dict", "keys", "are", "defined", "seaborn", "variables", "values", "are", "names", "inferred", "from", "the", "inputs", "or", "none", "when", "no", "name", "can", "be", "determined", "raises", "valueerror", "when", "variables", "are", "strings", "that", "don", "t", "appear", "in", "data", "plot_data", "variables", "data", "is", "optional", "all", "variables", "can", "be", "defined", "as", "vectors", "if", "data", "is", "none", "data", "todo", "should", "we", "try", "a", "data", "to_dict", "or", "similar", "here", "to", "more", "generally", "accept", "objects", "with", "that", "interface", "note", "that", "dict", "df", "also", "works", "for", "pandas", "and", "gives", "us", "what", "we", "want", "whereas", "dataframe", "to_dict", "gives", "a", "nested", "dict", "instead", "of", "a", "dict", "of", "series", "variables", "can", "also", "be", "extracted", "from", "the", "index", "attribute", "todo", "is", "this", "the", "most", "general", "way", "to", "enable", "it", "there", "is", "no", "index", "to_dict", "on", "multiindex", "unfortunately", "try", "index", "data", "index", "to_frame", "except", "attributeerror", "index", "the", "caller", "will", "determine", "the", "order", "of", "variables", "in", "plot_data", "for", "key", "val", "in", "kwargs", "items", "first", "try", "to", "treat", "the", "argument", "as", "a", "key", "for", "the", "data", "collection", "but", "be", "flexible", "about", "what", "can", "be", "used", "as", "a", "key", "usually", "it", "will", "be", "a", "string", "but", "allow", "numbers", "or", "tuples", "too", "when", "taking", "from", "the", "main", "data", "object", "only", "allow", "strings", "to", "reference", "fields", "in", "the", "index", "because", "otherwise", "there", "is", "too", "much", "ambiguity", "try", "val_as_data_key", "val", "in", "data", "or", "isinstance", "val", "str", "bytes", "and", "val", "in", "index", "except", "keyerror", "typeerror", "val_as_data_key", "false", "if", "val_as_data_key", "we", "know", "that", "__getitem__", "will", "work", "if", "val", "in", "data", "plot_data", "key", "data", "val", "elif", "val", "in", "index", "plot_data", "key", "index", "val", "variables", "key", "val", "elif", "isinstance", "val", "str", "bytes", "this", "looks", "like", "a", "column", "name", "but", "we", "don", "t", "know", "what", "it", "means", "err", "f", "could", "not", "interpret", "value", "val", "for", "parameter", "key", "raise", "valueerror", "err", "else", "otherwise", "assume", "the", "value", "is", "itself", "data", "raise", "when", "data", "object", "is", "present", "and", "a", "vector", "can", "t", "matched", "if", "isinstance", "data", "pd", "dataframe", "and", "not", "isinstance", "val", "pd", "series", "if", "np", "ndim", "val", "and", "len", "data", "len", "val", "val_cls", "val", "__class__", "__name__", "err", "f", "length", "of", "val_cls", "vectors", "must", "match", "length", "of", "data", "f", "when", "both", "are", "used", "but", "data", "has", "length", "len", "data", "f", "and", "the", "vector", "passed", "to", "key", "has", "length", "len", "val", "raise", "valueerror", "err", "plot_data", "key", "val", "try", "to", "infer", "the", "name", "of", "the", "variable", "variables", "key", "getattr", "val", "name", "none", "construct", "a", "tidy", "plot", "dataframe", "this", "will", "convert", "a", "number", "of", "types", "automatically", "aligning", "on", "index", "in", "case", "of", "pandas", "objects", "plot_data", "pd", "dataframe", "plot_data", "reduce", "the", "variables", "dictionary", "to", "fields", "with", "valid", "data", "variables", "var", "name", "for", "var", "name", "in", "variables", "items", "if", "plot_data", "var", "notnull", "any", "return", "plot_data", "variables"], "doc_len": 521}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.iter_data", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "iter_data", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def iter_data(\n        self, grouping_vars=None, *,\n        reverse=False, from_comp_data=False,\n        by_facet=True, allow_empty=False, dropna=True,\n    ):\n        \"\"\"Generator for getting subsets of data defined by semantic variables.\n\n        Also injects \"col\" and \"row\" into grouping semantics.\n\n        Parameters\n        ----------\n        grouping_vars : string or list of strings\n            Semantic variables that define the subsets of data.\n        reverse : bool\n            If True, reverse the order of iteration.\n        from_comp_data : bool\n            If True, use self.comp_data rather than self.plot_data\n        by_facet : bool\n            If True, add faceting variables to the set of grouping variables.\n        allow_empty : bool\n            If True, yield an empty dataframe when no observations exist for\n            combinations of grouping variables.\n        dropna : bool\n            If True, remove rows with missing data.\n\n        Yields\n        ------\n        sub_vars : dict\n            Keys are semantic names, values are the level of that semantic.\n        sub_data : :class:`pandas.DataFrame`\n            Subset of ``plot_data`` for this combination of semantic values.\n\n        \"\"\"\n        # TODO should this default to using all (non x/y?) semantics?\n        # or define grouping vars somewhere?\n        if grouping_vars is None:\n            grouping_vars = []\n        elif isinstance(grouping_vars, str):\n            grouping_vars = [grouping_vars]\n        elif isinstance(grouping_vars, tuple):\n            grouping_vars = list(grouping_vars)\n\n        # Always insert faceting variables\n        if by_facet:\n            facet_vars = {\"col\", \"row\"}\n            grouping_vars.extend(\n                facet_vars & set(self.variables) - set(grouping_vars)\n            )\n\n        # Reduce to the semantics used in this plot\n        grouping_vars = [\n            var for var in grouping_vars if var in self.variables\n        ]\n\n        if from_comp_data:\n            data = self.comp_data\n        else:\n            data = self.plot_data\n\n        if dropna:\n            data = data.dropna()\n\n        levels = self.var_levels.copy()\n        if from_comp_data:\n            for axis in {\"x\", \"y\"} & set(grouping_vars):\n                if self.var_types[axis] == \"categorical\":\n                    if self._var_ordered[axis]:\n                        # If the axis is ordered, then the axes in a possible\n                        # facet grid are by definition \"shared\", or there is a\n                        # single axis with a unique cat -> idx mapping.\n                        # So we can just take the first converter object.\n                        converter = self.converters[axis].iloc[0]\n                        levels[axis] = converter.convert_units(levels[axis])\n                    else:\n                        # Otherwise, the mappings may not be unique, but we can\n                        # use the unique set of index values in comp_data.\n                        levels[axis] = np.sort(data[axis].unique())\n                elif self.var_types[axis] == \"datetime\":\n                    levels[axis] = mpl.dates.date2num(levels[axis])\n                elif self.var_types[axis] == \"numeric\" and self._log_scaled(axis):\n                    levels[axis] = np.log10(levels[axis])\n\n        if grouping_vars:\n\n            grouped_data = data.groupby(\n                grouping_vars, sort=False, as_index=False\n            )\n\n            grouping_keys = []\n            for var in grouping_vars:\n                grouping_keys.append(levels.get(var, []))\n\n            iter_keys = itertools.product(*grouping_keys)\n            if reverse:\n                iter_keys = reversed(list(iter_keys))\n\n            for key in iter_keys:\n\n                # Pandas fails with singleton tuple inputs\n                pd_key = key[0] if len(key) == 1 else key\n\n                try:\n                    data_subset = grouped_data.get_group(pd_key)\n                except KeyError:\n                    # XXX we are adding this to allow backwards compatibility\n                    # with the empty artists that old categorical plots would\n                    # add (before 0.12), which we may decide to break, in which\n                    # case this option could be removed\n                    data_subset = data.loc[[]]\n\n                if data_subset.empty and not allow_empty:\n                    continue\n\n                sub_vars = dict(zip(grouping_vars, key))\n\n                yield sub_vars, data_subset.copy()\n\n        else:\n\n            yield {}, data.copy()\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "iter_data", "self", "grouping_vars", "none", "reverse", "false", "from_comp_data", "false", "by_facet", "true", "allow_empty", "false", "dropna", "true", "generator", "for", "getting", "subsets", "of", "data", "defined", "by", "semantic", "variables", "also", "injects", "col", "and", "row", "into", "grouping", "semantics", "parameters", "grouping_vars", "string", "or", "list", "of", "strings", "semantic", "variables", "that", "define", "the", "subsets", "of", "data", "reverse", "bool", "if", "true", "reverse", "the", "order", "of", "iteration", "from_comp_data", "bool", "if", "true", "use", "self", "comp_data", "rather", "than", "self", "plot_data", "by_facet", "bool", "if", "true", "add", "faceting", "variables", "to", "the", "set", "of", "grouping", "variables", "allow_empty", "bool", "if", "true", "yield", "an", "empty", "dataframe", "when", "no", "observations", "exist", "for", "combinations", "of", "grouping", "variables", "dropna", "bool", "if", "true", "remove", "rows", "with", "missing", "data", "yields", "sub_vars", "dict", "keys", "are", "semantic", "names", "values", "are", "the", "level", "of", "that", "semantic", "sub_data", "class", "pandas", "dataframe", "subset", "of", "plot_data", "for", "this", "combination", "of", "semantic", "values", "todo", "should", "this", "default", "to", "using", "all", "non", "x", "y", "semantics", "or", "define", "grouping", "vars", "somewhere", "if", "grouping_vars", "is", "none", "grouping_vars", "elif", "isinstance", "grouping_vars", "str", "grouping_vars", "grouping_vars", "elif", "isinstance", "grouping_vars", "tuple", "grouping_vars", "list", "grouping_vars", "always", "insert", "faceting", "variables", "if", "by_facet", "facet_vars", "col", "row", "grouping_vars", "extend", "facet_vars", "set", "self", "variables", "set", "grouping_vars", "reduce", "to", "the", "semantics", "used", "in", "this", "plot", "grouping_vars", "var", "for", "var", "in", "grouping_vars", "if", "var", "in", "self", "variables", "if", "from_comp_data", "data", "self", "comp_data", "else", "data", "self", "plot_data", "if", "dropna", "data", "data", "dropna", "levels", "self", "var_levels", "copy", "if", "from_comp_data", "for", "axis", "in", "x", "y", "set", "grouping_vars", "if", "self", "var_types", "axis", "categorical", "if", "self", "_var_ordered", "axis", "if", "the", "axis", "is", "ordered", "then", "the", "axes", "in", "a", "possible", "facet", "grid", "are", "by", "definition", "shared", "or", "there", "is", "a", "single", "axis", "with", "a", "unique", "cat", "idx", "mapping", "so", "we", "can", "just", "take", "the", "first", "converter", "object", "converter", "self", "converters", "axis", "iloc", "0", "levels", "axis", "converter", "convert_units", "levels", "axis", "else", "otherwise", "the", "mappings", "may", "not", "be", "unique", "but", "we", "can", "use", "the", "unique", "set", "of", "index", "values", "in", "comp_data", "levels", "axis", "np", "sort", "data", "axis", "unique", "elif", "self", "var_types", "axis", "datetime", "levels", "axis", "mpl", "dates", "date2num", "levels", "axis", "elif", "self", "var_types", "axis", "numeric", "and", "self", "_log_scaled", "axis", "levels", "axis", "np", "log10", "levels", "axis", "if", "grouping_vars", "grouped_data", "data", "groupby", "grouping_vars", "sort", "false", "as_index", "false", "grouping_keys", "for", "var", "in", "grouping_vars", "grouping_keys", "append", "levels", "get", "var", "iter_keys", "itertools", "product", "grouping_keys", "if", "reverse", "iter_keys", "reversed", "list", "iter_keys", "for", "key", "in", "iter_keys", "pandas", "fails", "with", "singleton", "tuple", "inputs", "pd_key", "key", "0", "if", "len", "key", "1", "else", "key", "try", "data_subset", "grouped_data", "get_group", "pd_key", "except", "keyerror", "xxx", "we", "are", "adding", "this", "to", "allow", "backwards", "compatibility", "with", "the", "empty", "artists", "that", "old", "categorical", "plots", "would", "add", "before", "0", "12", "which", "we", "may", "decide", "to", "break", "in", "which", "case", "this", "option", "could", "be", "removed", "data_subset", "data", "loc", "if", "data_subset", "empty", "and", "not", "allow_empty", "continue", "sub_vars", "dict", "zip", "grouping_vars", "key", "yield", "sub_vars", "data_subset", "copy", "else", "yield", "data", "copy"], "doc_len": 463}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.comp_data", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "comp_data", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def comp_data(self):\n        \"\"\"Dataframe with numeric x and y, after unit conversion and log scaling.\"\"\"\n        if not hasattr(self, \"ax\"):\n            # Probably a good idea, but will need a bunch of tests updated\n            # Most of these tests should just use the external interface\n            # Then this can be re-enabled.\n            # raise AttributeError(\"No Axes attached to plotter\")\n            return self.plot_data\n\n        if not hasattr(self, \"_comp_data\"):\n\n            comp_data = (\n                self.plot_data\n                .copy(deep=False)\n                .drop([\"x\", \"y\"], axis=1, errors=\"ignore\")\n            )\n\n            for var in \"yx\":\n                if var not in self.variables:\n                    continue\n\n                parts = []\n                grouped = self.plot_data[var].groupby(self.converters[var], sort=False)\n                for converter, orig in grouped:\n                    with pd.option_context('mode.use_inf_as_na', True):\n                        orig = orig.dropna()\n                        if var in self.var_levels:\n                            # TODO this should happen in some centralized location\n                            # it is similar to GH2419, but more complicated because\n                            # supporting `order` in categorical plots is tricky\n                            orig = orig[orig.isin(self.var_levels[var])]\n                    comp = pd.to_numeric(converter.convert_units(orig))\n                    if converter.get_scale() == \"log\":\n                        comp = np.log10(comp)\n                    parts.append(pd.Series(comp, orig.index, name=orig.name))\n                if parts:\n                    comp_col = pd.concat(parts)\n                else:\n                    comp_col = pd.Series(dtype=float, name=var)\n                comp_data.insert(0, var, comp_col)\n\n            self._comp_data = comp_data\n\n        return self._comp_data\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "comp_data", "self", "dataframe", "with", "numeric", "x", "and", "y", "after", "unit", "conversion", "and", "log", "scaling", "if", "not", "hasattr", "self", "ax", "probably", "a", "good", "idea", "but", "will", "need", "a", "bunch", "of", "tests", "updated", "most", "of", "these", "tests", "should", "just", "use", "the", "external", "interface", "then", "this", "can", "be", "re", "enabled", "raise", "attributeerror", "no", "axes", "attached", "to", "plotter", "return", "self", "plot_data", "if", "not", "hasattr", "self", "_comp_data", "comp_data", "self", "plot_data", "copy", "deep", "false", "drop", "x", "y", "axis", "1", "errors", "ignore", "for", "var", "in", "yx", "if", "var", "not", "in", "self", "variables", "continue", "parts", "grouped", "self", "plot_data", "var", "groupby", "self", "converters", "var", "sort", "false", "for", "converter", "orig", "in", "grouped", "with", "pd", "option_context", "mode", "use_inf_as_na", "true", "orig", "orig", "dropna", "if", "var", "in", "self", "var_levels", "todo", "this", "should", "happen", "in", "some", "centralized", "location", "it", "is", "similar", "to", "gh2419", "but", "more", "complicated", "because", "supporting", "order", "in", "categorical", "plots", "is", "tricky", "orig", "orig", "orig", "isin", "self", "var_levels", "var", "comp", "pd", "to_numeric", "converter", "convert_units", "orig", "if", "converter", "get_scale", "log", "comp", "np", "log10", "comp", "parts", "append", "pd", "series", "comp", "orig", "index", "name", "orig", "name", "if", "parts", "comp_col", "pd", "concat", "parts", "else", "comp_col", "pd", "series", "dtype", "float", "name", "var", "comp_data", "insert", "0", "var", "comp_col", "self", "_comp_data", "comp_data", "return", "self", "_comp_data"], "doc_len": 201}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._get_axes", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_get_axes", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _get_axes(self, sub_vars):\n        \"\"\"Return an Axes object based on existence of row/col variables.\"\"\"\n        row = sub_vars.get(\"row\", None)\n        col = sub_vars.get(\"col\", None)\n        if row is not None and col is not None:\n            return self.facets.axes_dict[(row, col)]\n        elif row is not None:\n            return self.facets.axes_dict[row]\n        elif col is not None:\n            return self.facets.axes_dict[col]\n        elif self.ax is None:\n            return self.facets.ax\n        else:\n            return self.ax\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_get_axes", "self", "sub_vars", "return", "an", "axes", "object", "based", "on", "existence", "of", "row", "col", "variables", "row", "sub_vars", "get", "row", "none", "col", "sub_vars", "get", "col", "none", "if", "row", "is", "not", "none", "and", "col", "is", "not", "none", "return", "self", "facets", "axes_dict", "row", "col", "elif", "row", "is", "not", "none", "return", "self", "facets", "axes_dict", "row", "elif", "col", "is", "not", "none", "return", "self", "facets", "axes_dict", "col", "elif", "self", "ax", "is", "none", "return", "self", "facets", "ax", "else", "return", "self", "ax"], "doc_len": 78}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._attach", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_attach", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _attach(\n        self,\n        obj,\n        allowed_types=None,\n        log_scale=None,\n    ):\n        \"\"\"Associate the plotter with an Axes manager and initialize its units.\n\n        Parameters\n        ----------\n        obj : :class:`matplotlib.axes.Axes` or :class:'FacetGrid`\n            Structural object that we will eventually plot onto.\n        allowed_types : str or list of str\n            If provided, raise when either the x or y variable does not have\n            one of the declared seaborn types.\n        log_scale : bool, number, or pair of bools or numbers\n            If not False, set the axes to use log scaling, with the given\n            base or defaulting to 10. If a tuple, interpreted as separate\n            arguments for the x and y axes.\n\n        \"\"\"\n        from .axisgrid import FacetGrid\n        if isinstance(obj, FacetGrid):\n            self.ax = None\n            self.facets = obj\n            ax_list = obj.axes.flatten()\n            if obj.col_names is not None:\n                self.var_levels[\"col\"] = obj.col_names\n            if obj.row_names is not None:\n                self.var_levels[\"row\"] = obj.row_names\n        else:\n            self.ax = obj\n            self.facets = None\n            ax_list = [obj]\n\n        # Identify which \"axis\" variables we have defined\n        axis_variables = set(\"xy\").intersection(self.variables)\n\n        # -- Verify the types of our x and y variables here.\n        # This doesn't really make complete sense being here here, but it's a fine\n        # place for it, given  the current system.\n        # (Note that for some plots, there might be more complicated restrictions)\n        # e.g. the categorical plots have their own check that as specific to the\n        # non-categorical axis.\n        if allowed_types is None:\n            allowed_types = [\"numeric\", \"datetime\", \"categorical\"]\n        elif isinstance(allowed_types, str):\n            allowed_types = [allowed_types]\n\n        for var in axis_variables:\n            var_type = self.var_types[var]\n            if var_type not in allowed_types:\n                err = (\n                    f\"The {var} variable is {var_type}, but one of \"\n                    f\"{allowed_types} is required\"\n                )\n                raise TypeError(err)\n\n        # -- Get axis objects for each row in plot_data for type conversions and scaling\n\n        facet_dim = {\"x\": \"col\", \"y\": \"row\"}\n\n        self.converters = {}\n        for var in axis_variables:\n            other_var = {\"x\": \"y\", \"y\": \"x\"}[var]\n\n            converter = pd.Series(index=self.plot_data.index, name=var, dtype=object)\n            share_state = getattr(self.facets, f\"_share{var}\", True)\n\n            # Simplest cases are that we have a single axes, all axes are shared,\n            # or sharing is only on the orthogonal facet dimension. In these cases,\n            # all datapoints get converted the same way, so use the first axis\n            if share_state is True or share_state == facet_dim[other_var]:\n                converter.loc[:] = getattr(ax_list[0], f\"{var}axis\")\n\n            else:\n\n                # Next simplest case is when no axes are shared, and we can\n                # use the axis objects within each facet\n                if share_state is False:\n                    for axes_vars, axes_data in self.iter_data():\n                        ax = self._get_axes(axes_vars)\n                        converter.loc[axes_data.index] = getattr(ax, f\"{var}axis\")\n\n                # In the more complicated case, the axes are shared within each\n                # \"file\" of the facetgrid. In that case, we need to subset the data\n                # for that file and assign it the first axis in the slice of the grid\n                else:\n\n                    names = getattr(self.facets, f\"{share_state}_names\")\n                    for i, level in enumerate(names):\n                        idx = (i, 0) if share_state == \"row\" else (0, i)\n                        axis = getattr(self.facets.axes[idx], f\"{var}axis\")\n                        converter.loc[self.plot_data[share_state] == level] = axis\n\n            # Store the converter vector, which we use elsewhere (e.g comp_data)\n            self.converters[var] = converter\n\n            # Now actually update the matplotlib objects to do the conversion we want\n            grouped = self.plot_data[var].groupby(self.converters[var], sort=False)\n            for converter, seed_data in grouped:\n                if self.var_types[var] == \"categorical\":\n                    if self._var_ordered[var]:\n                        order = self.var_levels[var]\n                    else:\n                        order = None\n                    seed_data = categorical_order(seed_data, order)\n                converter.update_units(seed_data)\n\n        # -- Set numerical axis scales\n\n        # First unpack the log_scale argument\n        if log_scale is None:\n            scalex = scaley = False\n        else:\n            # Allow single value or x, y tuple\n            try:\n                scalex, scaley = log_scale\n            except TypeError:\n                scalex = log_scale if \"x\" in self.variables else False\n                scaley = log_scale if \"y\" in self.variables else False\n\n        # Now use it\n        for axis, scale in zip(\"xy\", (scalex, scaley)):\n            if scale:\n                for ax in ax_list:\n                    set_scale = getattr(ax, f\"set_{axis}scale\")\n                    if scale is True:\n                        set_scale(\"log\")\n                    else:\n                        if Version(mpl.__version__) >= Version(\"3.3\"):\n                            set_scale(\"log\", base=scale)\n                        else:\n                            set_scale(\"log\", **{f\"base{axis}\": scale})\n\n        # For categorical y, we want the \"first\" level to be at the top of the axis\n        if self.var_types.get(\"y\", None) == \"categorical\":\n            for ax in ax_list:\n                try:\n                    ax.yaxis.set_inverted(True)\n                except AttributeError:  # mpl < 3.1\n                    if not ax.yaxis_inverted():\n                        ax.invert_yaxis()\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_attach", "self", "obj", "allowed_types", "none", "log_scale", "none", "associate", "the", "plotter", "with", "an", "axes", "manager", "and", "initialize", "its", "units", "parameters", "obj", "class", "matplotlib", "axes", "axes", "or", "class", "facetgrid", "structural", "object", "that", "we", "will", "eventually", "plot", "onto", "allowed_types", "str", "or", "list", "of", "str", "if", "provided", "raise", "when", "either", "the", "x", "or", "y", "variable", "does", "not", "have", "one", "of", "the", "declared", "seaborn", "types", "log_scale", "bool", "number", "or", "pair", "of", "bools", "or", "numbers", "if", "not", "false", "set", "the", "axes", "to", "use", "log", "scaling", "with", "the", "given", "base", "or", "defaulting", "to", "10", "if", "a", "tuple", "interpreted", "as", "separate", "arguments", "for", "the", "x", "and", "y", "axes", "from", "axisgrid", "import", "facetgrid", "if", "isinstance", "obj", "facetgrid", "self", "ax", "none", "self", "facets", "obj", "ax_list", "obj", "axes", "flatten", "if", "obj", "col_names", "is", "not", "none", "self", "var_levels", "col", "obj", "col_names", "if", "obj", "row_names", "is", "not", "none", "self", "var_levels", "row", "obj", "row_names", "else", "self", "ax", "obj", "self", "facets", "none", "ax_list", "obj", "identify", "which", "axis", "variables", "we", "have", "defined", "axis_variables", "set", "xy", "intersection", "self", "variables", "verify", "the", "types", "of", "our", "x", "and", "y", "variables", "here", "this", "doesn", "t", "really", "make", "complete", "sense", "being", "here", "here", "but", "it", "s", "a", "fine", "place", "for", "it", "given", "the", "current", "system", "note", "that", "for", "some", "plots", "there", "might", "be", "more", "complicated", "restrictions", "e", "g", "the", "categorical", "plots", "have", "their", "own", "check", "that", "as", "specific", "to", "the", "non", "categorical", "axis", "if", "allowed_types", "is", "none", "allowed_types", "numeric", "datetime", "categorical", "elif", "isinstance", "allowed_types", "str", "allowed_types", "allowed_types", "for", "var", "in", "axis_variables", "var_type", "self", "var_types", "var", "if", "var_type", "not", "in", "allowed_types", "err", "f", "the", "var", "variable", "is", "var_type", "but", "one", "of", "f", "allowed_types", "is", "required", "raise", "typeerror", "err", "get", "axis", "objects", "for", "each", "row", "in", "plot_data", "for", "type", "conversions", "and", "scaling", "facet_dim", "x", "col", "y", "row", "self", "converters", "for", "var", "in", "axis_variables", "other_var", "x", "y", "y", "x", "var", "converter", "pd", "series", "index", "self", "plot_data", "index", "name", "var", "dtype", "object", "share_state", "getattr", "self", "facets", "f", "_share", "var", "true", "simplest", "cases", "are", "that", "we", "have", "a", "single", "axes", "all", "axes", "are", "shared", "or", "sharing", "is", "only", "on", "the", "orthogonal", "facet", "dimension", "in", "these", "cases", "all", "datapoints", "get", "converted", "the", "same", "way", "so", "use", "the", "first", "axis", "if", "share_state", "is", "true", "or", "share_state", "facet_dim", "other_var", "converter", "loc", "getattr", "ax_list", "0", "f", "var", "axis", "else", "next", "simplest", "case", "is", "when", "no", "axes", "are", "shared", "and", "we", "can", "use", "the", "axis", "objects", "within", "each", "facet", "if", "share_state", "is", "false", "for", "axes_vars", "axes_data", "in", "self", "iter_data", "ax", "self", "_get_axes", "axes_vars", "converter", "loc", "axes_data", "index", "getattr", "ax", "f", "var", "axis", "in", "the", "more", "complicated", "case", "the", "axes", "are", "shared", "within", "each", "file", "of", "the", "facetgrid", "in", "that", "case", "we", "need", "to", "subset", "the", "data", "for", "that", "file", "and", "assign", "it", "the", "first", "axis", "in", "the", "slice", "of", "the", "grid", "else", "names", "getattr", "self", "facets", "f", "share_state", "_names", "for", "i", "level", "in", "enumerate", "names", "idx", "i", "0", "if", "share_state", "row", "else", "0", "i", "axis", "getattr", "self", "facets", "axes", "idx", "f", "var", "axis", "converter", "loc", "self", "plot_data", "share_state", "level", "axis", "store", "the", "converter", "vector", "which", "we", "use", "elsewhere", "e", "g", "comp_data", "self", "converters", "var", "converter", "now", "actually", "update", "the", "matplotlib", "objects", "to", "do", "the", "conversion", "we", "want", "grouped", "self", "plot_data", "var", "groupby", "self", "converters", "var", "sort", "false", "for", "converter", "seed_data", "in", "grouped", "if", "self", "var_types", "var", "categorical", "if", "self", "_var_ordered", "var", "order", "self", "var_levels", "var", "else", "order", "none", "seed_data", "categorical_order", "seed_data", "order", "converter", "update_units", "seed_data", "set", "numerical", "axis", "scales", "first", "unpack", "the", "log_scale", "argument", "if", "log_scale", "is", "none", "scalex", "scaley", "false", "else", "allow", "single", "value", "or", "x", "y", "tuple", "try", "scalex", "scaley", "log_scale", "except", "typeerror", "scalex", "log_scale", "if", "x", "in", "self", "variables", "else", "false", "scaley", "log_scale", "if", "y", "in", "self", "variables", "else", "false", "now", "use", "it", "for", "axis", "scale", "in", "zip", "xy", "scalex", "scaley", "if", "scale", "for", "ax", "in", "ax_list", "set_scale", "getattr", "ax", "f", "set_", "axis", "scale", "if", "scale", "is", "true", "set_scale", "log", "else", "if", "version", "mpl", "__version__", "version", "3", "3", "set_scale", "log", "base", "scale", "else", "set_scale", "log", "f", "base", "axis", "scale", "for", "categorical", "y", "we", "want", "the", "first", "level", "to", "be", "at", "the", "top", "of", "the", "axis", "if", "self", "var_types", "get", "y", "none", "categorical", "for", "ax", "in", "ax_list", "try", "ax", "yaxis", "set_inverted", "true", "except", "attributeerror", "mpl", "3", "1", "if", "not", "ax", "yaxis_inverted", "ax", "invert_yaxis"], "doc_len": 699}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._log_scaled", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_log_scaled", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _log_scaled(self, axis):\n        \"\"\"Return True if specified axis is log scaled on all attached axes.\"\"\"\n        if not hasattr(self, \"ax\"):\n            return False\n\n        if self.ax is None:\n            axes_list = self.facets.axes.flatten()\n        else:\n            axes_list = [self.ax]\n\n        log_scaled = []\n        for ax in axes_list:\n            data_axis = getattr(ax, f\"{axis}axis\")\n            log_scaled.append(data_axis.get_scale() == \"log\")\n\n        if any(log_scaled) and not all(log_scaled):\n            raise RuntimeError(\"Axis scaling is not consistent\")\n\n        return any(log_scaled)\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_log_scaled", "self", "axis", "return", "true", "if", "specified", "axis", "is", "log", "scaled", "on", "all", "attached", "axes", "if", "not", "hasattr", "self", "ax", "return", "false", "if", "self", "ax", "is", "none", "axes_list", "self", "facets", "axes", "flatten", "else", "axes_list", "self", "ax", "log_scaled", "for", "ax", "in", "axes_list", "data_axis", "getattr", "ax", "f", "axis", "axis", "log_scaled", "append", "data_axis", "get_scale", "log", "if", "any", "log_scaled", "and", "not", "all", "log_scaled", "raise", "runtimeerror", "axis", "scaling", "is", "not", "consistent", "return", "any", "log_scaled"], "doc_len": 74}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter._add_axis_labels", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "_add_axis_labels", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def _add_axis_labels(self, ax, default_x=\"\", default_y=\"\"):\n        \"\"\"Add axis labels if not present, set visibility to match ticklabels.\"\"\"\n        # TODO ax could default to None and use attached axes if present\n        # but what to do about the case of facets? Currently using FacetGrid's\n        # set_axis_labels method, which doesn't add labels to the interior even\n        # when the axes are not shared. Maybe that makes sense?\n        if not ax.get_xlabel():\n            x_visible = any(t.get_visible() for t in ax.get_xticklabels())\n            ax.set_xlabel(self.variables.get(\"x\", default_x), visible=x_visible)\n        if not ax.get_ylabel():\n            y_visible = any(t.get_visible() for t in ax.get_yticklabels())\n            ax.set_ylabel(self.variables.get(\"y\", default_y), visible=y_visible)\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "_add_axis_labels", "self", "ax", "default_x", "default_y", "add", "axis", "labels", "if", "not", "present", "set", "visibility", "to", "match", "ticklabels", "todo", "ax", "could", "default", "to", "none", "and", "use", "attached", "axes", "if", "present", "but", "what", "to", "do", "about", "the", "case", "of", "facets", "currently", "using", "facetgrid", "s", "set_axis_labels", "method", "which", "doesn", "t", "add", "labels", "to", "the", "interior", "even", "when", "the", "axes", "are", "not", "shared", "maybe", "that", "makes", "sense", "if", "not", "ax", "get_xlabel", "x_visible", "any", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "ax", "set_xlabel", "self", "variables", "get", "x", "default_x", "visible", "x_visible", "if", "not", "ax", "get_ylabel", "y_visible", "any", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "ax", "set_ylabel", "self", "variables", "get", "y", "default_y", "visible", "y_visible"], "doc_len": 111}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.scale_native", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "scale_native", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def scale_native(self, axis, *args, **kwargs):\n\n        # Default, defer to matplotlib\n\n        raise NotImplementedError\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "scale_native", "self", "axis", "args", "kwargs", "default", "defer", "to", "matplotlib", "raise", "notimplementederror"], "doc_len": 16}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.scale_numeric", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "scale_numeric", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def scale_numeric(self, axis, *args, **kwargs):\n\n        # Feels needed to completeness, what should it do?\n        # Perhaps handle log scaling? Set the ticker/formatter/limits?\n\n        raise NotImplementedError\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "scale_numeric", "self", "axis", "args", "kwargs", "feels", "needed", "to", "completeness", "what", "should", "it", "do", "perhaps", "handle", "log", "scaling", "set", "the", "ticker", "formatter", "limits", "raise", "notimplementederror"], "doc_len": 29}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.scale_datetime", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "scale_datetime", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def scale_datetime(self, axis, *args, **kwargs):\n\n        # Use pd.to_datetime to convert strings or numbers to datetime objects\n        # Note, use day-resolution for numeric->datetime to match matplotlib\n\n        raise NotImplementedError\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "scale_datetime", "self", "axis", "args", "kwargs", "use", "pd", "to_datetime", "to", "convert", "strings", "or", "numbers", "to", "datetime", "objects", "note", "use", "day", "resolution", "for", "numeric", "datetime", "to", "match", "matplotlib", "raise", "notimplementederror"], "doc_len": 33}
{"doc_id": "seaborn/_oldcore.py::VectorPlotter.scale_categorical", "file_path": "seaborn/_oldcore.py", "class_name": "VectorPlotter", "func_name": "scale_categorical", "text": "文件路径: seaborn/_oldcore.py, 类名: VectorPlotter\n    def scale_categorical(self, axis, order=None, formatter=None):\n        \"\"\"\n        Enforce categorical (fixed-scale) rules for the data on given axis.\n\n        Parameters\n        ----------\n        axis : \"x\" or \"y\"\n            Axis of the plot to operate on.\n        order : list\n            Order that unique values should appear in.\n        formatter : callable\n            Function mapping values to a string representation.\n\n        Returns\n        -------\n        self\n\n        \"\"\"\n        # This method both modifies the internal representation of the data\n        # (converting it to string) and sets some attributes on self. It might be\n        # a good idea to have a separate object attached to self that contains the\n        # information in those attributes (i.e. whether to enforce variable order\n        # across facets, the order to use) similar to the SemanticMapping objects\n        # we have for semantic variables. That object could also hold the converter\n        # objects that get used, if we can decouple those from an existing axis\n        # (cf. https://github.com/matplotlib/matplotlib/issues/19229).\n        # There are some interactions with faceting information that would need\n        # to be thought through, since the converts to use depend on facets.\n        # If we go that route, these methods could become \"borrowed\" methods similar\n        # to what happens with the alternate semantic mapper constructors, although\n        # that approach is kind of fussy and confusing.\n\n        # TODO this method could also set the grid state? Since we like to have no\n        # grid on the categorical axis by default. Again, a case where we'll need to\n        # store information until we use it, so best to have a way to collect the\n        # attributes that this method sets.\n\n        # TODO if we are going to set visual properties of the axes with these methods,\n        # then we could do the steps currently in CategoricalPlotter._adjust_cat_axis\n\n        # TODO another, and distinct idea, is to expose a cut= param here\n\n        _check_argument(\"axis\", [\"x\", \"y\"], axis)\n\n        # Categorical plots can be \"univariate\" in which case they get an anonymous\n        # category label on the opposite axis.\n        if axis not in self.variables:\n            self.variables[axis] = None\n            self.var_types[axis] = \"categorical\"\n            self.plot_data[axis] = \"\"\n\n        # If the \"categorical\" variable has a numeric type, sort the rows so that\n        # the default result from categorical_order has those values sorted after\n        # they have been coerced to strings. The reason for this is so that later\n        # we can get facet-wise orders that are correct.\n        # XXX Should this also sort datetimes?\n        # It feels more consistent, but technically will be a default change\n        # If so, should also change categorical_order to behave that way\n        if self.var_types[axis] == \"numeric\":\n            self.plot_data = self.plot_data.sort_values(axis, kind=\"mergesort\")\n\n        # Now get a reference to the categorical data vector\n        cat_data = self.plot_data[axis]\n\n        # Get the initial categorical order, which we do before string\n        # conversion to respect the original types of the order list.\n        # Track whether the order is given explicitly so that we can know\n        # whether or not to use the order constructed here downstream\n        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"\n        order = pd.Index(categorical_order(cat_data, order))\n\n        # Then convert data to strings. This is because in matplotlib,\n        # \"categorical\" data really mean \"string\" data, so doing this artists\n        # will be drawn on the categorical axis with a fixed scale.\n        # TODO implement formatter here; check that it returns strings?\n        if formatter is not None:\n            cat_data = cat_data.map(formatter)\n            order = order.map(formatter)\n        else:\n            cat_data = cat_data.astype(str)\n            order = order.astype(str)\n\n        # Update the levels list with the type-converted order variable\n        self.var_levels[axis] = order\n\n        # Now ensure that seaborn will use categorical rules internally\n        self.var_types[axis] = \"categorical\"\n\n        # Put the string-typed categorical vector back into the plot_data structure\n        self.plot_data[axis] = cat_data\n\n        return self\n", "tokens": ["seaborn", "_oldcore", "py", "vectorplotter", "def", "scale_categorical", "self", "axis", "order", "none", "formatter", "none", "enforce", "categorical", "fixed", "scale", "rules", "for", "the", "data", "on", "given", "axis", "parameters", "axis", "x", "or", "y", "axis", "of", "the", "plot", "to", "operate", "on", "order", "list", "order", "that", "unique", "values", "should", "appear", "in", "formatter", "callable", "function", "mapping", "values", "to", "a", "string", "representation", "returns", "self", "this", "method", "both", "modifies", "the", "internal", "representation", "of", "the", "data", "converting", "it", "to", "string", "and", "sets", "some", "attributes", "on", "self", "it", "might", "be", "a", "good", "idea", "to", "have", "a", "separate", "object", "attached", "to", "self", "that", "contains", "the", "information", "in", "those", "attributes", "i", "e", "whether", "to", "enforce", "variable", "order", "across", "facets", "the", "order", "to", "use", "similar", "to", "the", "semanticmapping", "objects", "we", "have", "for", "semantic", "variables", "that", "object", "could", "also", "hold", "the", "converter", "objects", "that", "get", "used", "if", "we", "can", "decouple", "those", "from", "an", "existing", "axis", "cf", "https", "github", "com", "matplotlib", "matplotlib", "issues", "19229", "there", "are", "some", "interactions", "with", "faceting", "information", "that", "would", "need", "to", "be", "thought", "through", "since", "the", "converts", "to", "use", "depend", "on", "facets", "if", "we", "go", "that", "route", "these", "methods", "could", "become", "borrowed", "methods", "similar", "to", "what", "happens", "with", "the", "alternate", "semantic", "mapper", "constructors", "although", "that", "approach", "is", "kind", "of", "fussy", "and", "confusing", "todo", "this", "method", "could", "also", "set", "the", "grid", "state", "since", "we", "like", "to", "have", "no", "grid", "on", "the", "categorical", "axis", "by", "default", "again", "a", "case", "where", "we", "ll", "need", "to", "store", "information", "until", "we", "use", "it", "so", "best", "to", "have", "a", "way", "to", "collect", "the", "attributes", "that", "this", "method", "sets", "todo", "if", "we", "are", "going", "to", "set", "visual", "properties", "of", "the", "axes", "with", "these", "methods", "then", "we", "could", "do", "the", "steps", "currently", "in", "categoricalplotter", "_adjust_cat_axis", "todo", "another", "and", "distinct", "idea", "is", "to", "expose", "a", "cut", "param", "here", "_check_argument", "axis", "x", "y", "axis", "categorical", "plots", "can", "be", "univariate", "in", "which", "case", "they", "get", "an", "anonymous", "category", "label", "on", "the", "opposite", "axis", "if", "axis", "not", "in", "self", "variables", "self", "variables", "axis", "none", "self", "var_types", "axis", "categorical", "self", "plot_data", "axis", "if", "the", "categorical", "variable", "has", "a", "numeric", "type", "sort", "the", "rows", "so", "that", "the", "default", "result", "from", "categorical_order", "has", "those", "values", "sorted", "after", "they", "have", "been", "coerced", "to", "strings", "the", "reason", "for", "this", "is", "so", "that", "later", "we", "can", "get", "facet", "wise", "orders", "that", "are", "correct", "xxx", "should", "this", "also", "sort", "datetimes", "it", "feels", "more", "consistent", "but", "technically", "will", "be", "a", "default", "change", "if", "so", "should", "also", "change", "categorical_order", "to", "behave", "that", "way", "if", "self", "var_types", "axis", "numeric", "self", "plot_data", "self", "plot_data", "sort_values", "axis", "kind", "mergesort", "now", "get", "a", "reference", "to", "the", "categorical", "data", "vector", "cat_data", "self", "plot_data", "axis", "get", "the", "initial", "categorical", "order", "which", "we", "do", "before", "string", "conversion", "to", "respect", "the", "original", "types", "of", "the", "order", "list", "track", "whether", "the", "order", "is", "given", "explicitly", "so", "that", "we", "can", "know", "whether", "or", "not", "to", "use", "the", "order", "constructed", "here", "downstream", "self", "_var_ordered", "axis", "order", "is", "not", "none", "or", "cat_data", "dtype", "name", "category", "order", "pd", "index", "categorical_order", "cat_data", "order", "then", "convert", "data", "to", "strings", "this", "is", "because", "in", "matplotlib", "categorical", "data", "really", "mean", "string", "data", "so", "doing", "this", "artists", "will", "be", "drawn", "on", "the", "categorical", "axis", "with", "a", "fixed", "scale", "todo", "implement", "formatter", "here", "check", "that", "it", "returns", "strings", "if", "formatter", "is", "not", "none", "cat_data", "cat_data", "map", "formatter", "order", "order", "map", "formatter", "else", "cat_data", "cat_data", "astype", "str", "order", "order", "astype", "str", "update", "the", "levels", "list", "with", "the", "type", "converted", "order", "variable", "self", "var_levels", "axis", "order", "now", "ensure", "that", "seaborn", "will", "use", "categorical", "rules", "internally", "self", "var_types", "axis", "categorical", "put", "the", "string", "typed", "categorical", "vector", "back", "into", "the", "plot_data", "structure", "self", "plot_data", "axis", "cat_data", "return", "self"], "doc_len": 591}
{"doc_id": "seaborn/_oldcore.py::VariableType.__init__", "file_path": "seaborn/_oldcore.py", "class_name": "VariableType", "func_name": "__init__", "text": "文件路径: seaborn/_oldcore.py, 类名: VariableType\n    def __init__(self, data):\n        assert data in self.allowed, data\n        super().__init__(data)\n", "tokens": ["seaborn", "_oldcore", "py", "variabletype", "def", "__init__", "self", "data", "assert", "data", "in", "self", "allowed", "data", "super", "__init__", "data"], "doc_len": 17}
{"doc_id": "seaborn/_oldcore.py::VariableType.__eq__", "file_path": "seaborn/_oldcore.py", "class_name": "VariableType", "func_name": "__eq__", "text": "文件路径: seaborn/_oldcore.py, 类名: VariableType\n    def __eq__(self, other):\n        assert other in self.allowed, other\n        return self.data == other\n", "tokens": ["seaborn", "_oldcore", "py", "variabletype", "def", "__eq__", "self", "other", "assert", "other", "in", "self", "allowed", "other", "return", "self", "data", "other"], "doc_len": 18}
{"doc_id": "seaborn/_oldcore.py::variable_type", "file_path": "seaborn/_oldcore.py", "class_name": null, "func_name": "variable_type", "text": "文件路径: seaborn/_oldcore.py\ndef variable_type(vector, boolean_type=\"numeric\"):\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in two ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric' or 'categorical'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n\n    # If a categorical dtype is set, infer categorical\n    if pd.api.types.is_categorical_dtype(vector):\n        return VariableType(\"categorical\")\n\n    # Special-case all-na data, which is always \"numeric\"\n    if pd.isna(vector).all():\n        return VariableType(\"numeric\")\n\n    # Special-case binary/boolean data, allow caller to determine\n    # This triggers a numpy warning when vector has strings/objects\n    # https://github.com/numpy/numpy/issues/6784\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore', category=(FutureWarning, DeprecationWarning)\n        )\n        if np.isin(vector, [0, 1, np.nan]).all():\n            return VariableType(boolean_type)\n\n    # Defer to positive pandas tests\n    if pd.api.types.is_numeric_dtype(vector):\n        return VariableType(\"numeric\")\n\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VariableType(\"datetime\")\n\n    # --- If we get to here, we need to check the entries\n\n    # Check for a collection where everything is a number\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n\n    if all_numeric(vector):\n        return VariableType(\"numeric\")\n\n    # Check for a collection where everything is a datetime\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n\n    if all_datetime(vector):\n        return VariableType(\"datetime\")\n\n    # Otherwise, our final fallback is to consider things categorical\n\n    return VariableType(\"categorical\")\n", "tokens": ["seaborn", "_oldcore", "py", "def", "variable_type", "vector", "boolean_type", "numeric", "determine", "whether", "a", "vector", "contains", "numeric", "categorical", "or", "datetime", "data", "this", "function", "differs", "from", "the", "pandas", "typing", "api", "in", "two", "ways", "python", "sequences", "or", "object", "typed", "pydata", "objects", "are", "considered", "numeric", "if", "all", "of", "their", "entries", "are", "numeric", "string", "or", "mixed", "type", "data", "are", "considered", "categorical", "even", "if", "not", "explicitly", "represented", "as", "a", "class", "pandas", "api", "types", "categoricaldtype", "parameters", "vector", "func", "pandas", "series", "func", "numpy", "ndarray", "or", "python", "sequence", "input", "data", "to", "test", "boolean_type", "numeric", "or", "categorical", "type", "to", "use", "for", "vectors", "containing", "only", "0s", "and", "1s", "and", "nas", "returns", "var_type", "numeric", "categorical", "or", "datetime", "name", "identifying", "the", "type", "of", "data", "in", "the", "vector", "if", "a", "categorical", "dtype", "is", "set", "infer", "categorical", "if", "pd", "api", "types", "is_categorical_dtype", "vector", "return", "variabletype", "categorical", "special", "case", "all", "na", "data", "which", "is", "always", "numeric", "if", "pd", "isna", "vector", "all", "return", "variabletype", "numeric", "special", "case", "binary", "boolean", "data", "allow", "caller", "to", "determine", "this", "triggers", "a", "numpy", "warning", "when", "vector", "has", "strings", "objects", "https", "github", "com", "numpy", "numpy", "issues", "6784", "because", "we", "reduce", "with", "all", "we", "are", "agnostic", "about", "whether", "the", "comparison", "returns", "a", "scalar", "or", "vector", "so", "we", "will", "ignore", "the", "warning", "it", "triggers", "a", "separate", "deprecationwarning", "when", "the", "vector", "has", "datetimes", "https", "github", "com", "numpy", "numpy", "issues", "13548", "this", "is", "considered", "a", "bug", "by", "numpy", "and", "will", "likely", "go", "away", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "action", "ignore", "category", "futurewarning", "deprecationwarning", "if", "np", "isin", "vector", "0", "1", "np", "nan", "all", "return", "variabletype", "boolean_type", "defer", "to", "positive", "pandas", "tests", "if", "pd", "api", "types", "is_numeric_dtype", "vector", "return", "variabletype", "numeric", "if", "pd", "api", "types", "is_datetime64_dtype", "vector", "return", "variabletype", "datetime", "if", "we", "get", "to", "here", "we", "need", "to", "check", "the", "entries", "check", "for", "a", "collection", "where", "everything", "is", "a", "number", "def", "all_numeric", "x", "for", "x_i", "in", "x", "if", "not", "isinstance", "x_i", "number", "return", "false", "return", "true", "if", "all_numeric", "vector", "return", "variabletype", "numeric", "check", "for", "a", "collection", "where", "everything", "is", "a", "datetime", "def", "all_datetime", "x", "for", "x_i", "in", "x", "if", "not", "isinstance", "x_i", "datetime", "np", "datetime64", "return", "false", "return", "true", "if", "all_datetime", "vector", "return", "variabletype", "datetime", "otherwise", "our", "final", "fallback", "is", "to", "consider", "things", "categorical", "return", "variabletype", "categorical"], "doc_len": 356}
{"doc_id": "seaborn/_oldcore.py::infer_orient", "file_path": "seaborn/_oldcore.py", "class_name": null, "func_name": "infer_orient", "text": "文件路径: seaborn/_oldcore.py\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    \"\"\"Determine how the plot should be oriented based on the data.\n\n    For historical reasons, the convention is to call a plot \"horizontally\"\n    or \"vertically\" oriented based on the axis representing its dependent\n    variable. Practically, this is used when determining the axis for\n    numerical aggregation.\n\n    Parameters\n    ----------\n    x, y : Vector data or None\n        Positional data vectors for the plot.\n    orient : string or None\n        Specified orientation, which must start with \"v\" or \"h\" if not None.\n    require_numeric : bool\n        If set, raise when the implied dependent variable is not numeric.\n\n    Returns\n    -------\n    orient : \"v\" or \"h\"\n\n    Raises\n    ------\n    ValueError: When `orient` is not None and does not start with \"h\" or \"v\"\n    TypeError: When dependent variable is not numeric, with `require_numeric`\n\n    \"\"\"\n\n    x_type = None if x is None else variable_type(x)\n    y_type = None if y is None else variable_type(y)\n\n    nonnumeric_dv_error = \"{} orientation requires numeric `{}` variable.\"\n    single_var_warning = \"{} orientation ignored with only `{}` specified.\"\n\n    if x is None:\n        if str(orient).startswith(\"h\"):\n            warnings.warn(single_var_warning.format(\"Horizontal\", \"y\"))\n        if require_numeric and y_type != \"numeric\":\n            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))\n        return \"v\"\n\n    elif y is None:\n        if str(orient).startswith(\"v\"):\n            warnings.warn(single_var_warning.format(\"Vertical\", \"x\"))\n        if require_numeric and x_type != \"numeric\":\n            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))\n        return \"h\"\n\n    elif str(orient).startswith(\"v\"):\n        if require_numeric and y_type != \"numeric\":\n            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))\n        return \"v\"\n\n    elif str(orient).startswith(\"h\"):\n        if require_numeric and x_type != \"numeric\":\n            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))\n        return \"h\"\n\n    elif orient is not None:\n        err = (\n            \"`orient` must start with 'v' or 'h' or be None, \"\n            f\"but `{repr(orient)}` was passed.\"\n        )\n        raise ValueError(err)\n\n    elif x_type != \"categorical\" and y_type == \"categorical\":\n        return \"h\"\n\n    elif x_type != \"numeric\" and y_type == \"numeric\":\n        return \"v\"\n\n    elif x_type == \"numeric\" and y_type != \"numeric\":\n        return \"h\"\n\n    elif require_numeric and \"numeric\" not in (x_type, y_type):\n        err = \"Neither the `x` nor `y` variable appears to be numeric.\"\n        raise TypeError(err)\n\n    else:\n        return \"v\"\n", "tokens": ["seaborn", "_oldcore", "py", "def", "infer_orient", "x", "none", "y", "none", "orient", "none", "require_numeric", "true", "determine", "how", "the", "plot", "should", "be", "oriented", "based", "on", "the", "data", "for", "historical", "reasons", "the", "convention", "is", "to", "call", "a", "plot", "horizontally", "or", "vertically", "oriented", "based", "on", "the", "axis", "representing", "its", "dependent", "variable", "practically", "this", "is", "used", "when", "determining", "the", "axis", "for", "numerical", "aggregation", "parameters", "x", "y", "vector", "data", "or", "none", "positional", "data", "vectors", "for", "the", "plot", "orient", "string", "or", "none", "specified", "orientation", "which", "must", "start", "with", "v", "or", "h", "if", "not", "none", "require_numeric", "bool", "if", "set", "raise", "when", "the", "implied", "dependent", "variable", "is", "not", "numeric", "returns", "orient", "v", "or", "h", "raises", "valueerror", "when", "orient", "is", "not", "none", "and", "does", "not", "start", "with", "h", "or", "v", "typeerror", "when", "dependent", "variable", "is", "not", "numeric", "with", "require_numeric", "x_type", "none", "if", "x", "is", "none", "else", "variable_type", "x", "y_type", "none", "if", "y", "is", "none", "else", "variable_type", "y", "nonnumeric_dv_error", "orientation", "requires", "numeric", "variable", "single_var_warning", "orientation", "ignored", "with", "only", "specified", "if", "x", "is", "none", "if", "str", "orient", "startswith", "h", "warnings", "warn", "single_var_warning", "format", "horizontal", "y", "if", "require_numeric", "and", "y_type", "numeric", "raise", "typeerror", "nonnumeric_dv_error", "format", "vertical", "y", "return", "v", "elif", "y", "is", "none", "if", "str", "orient", "startswith", "v", "warnings", "warn", "single_var_warning", "format", "vertical", "x", "if", "require_numeric", "and", "x_type", "numeric", "raise", "typeerror", "nonnumeric_dv_error", "format", "horizontal", "x", "return", "h", "elif", "str", "orient", "startswith", "v", "if", "require_numeric", "and", "y_type", "numeric", "raise", "typeerror", "nonnumeric_dv_error", "format", "vertical", "y", "return", "v", "elif", "str", "orient", "startswith", "h", "if", "require_numeric", "and", "x_type", "numeric", "raise", "typeerror", "nonnumeric_dv_error", "format", "horizontal", "x", "return", "h", "elif", "orient", "is", "not", "none", "err", "orient", "must", "start", "with", "v", "or", "h", "or", "be", "none", "f", "but", "repr", "orient", "was", "passed", "raise", "valueerror", "err", "elif", "x_type", "categorical", "and", "y_type", "categorical", "return", "h", "elif", "x_type", "numeric", "and", "y_type", "numeric", "return", "v", "elif", "x_type", "numeric", "and", "y_type", "numeric", "return", "h", "elif", "require_numeric", "and", "numeric", "not", "in", "x_type", "y_type", "err", "neither", "the", "x", "nor", "y", "variable", "appears", "to", "be", "numeric", "raise", "typeerror", "err", "else", "return", "v"], "doc_len": 323}
{"doc_id": "seaborn/_oldcore.py::unique_dashes", "file_path": "seaborn/_oldcore.py", "class_name": null, "func_name": "unique_dashes", "text": "文件路径: seaborn/_oldcore.py\ndef unique_dashes(n):\n    \"\"\"Build an arbitrarily long list of unique dash styles for lines.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique dash specs to generate.\n\n    Returns\n    -------\n    dashes : list of strings or tuples\n        Valid arguments for the ``dashes`` parameter on\n        :class:`matplotlib.lines.Line2D`. The first spec is a solid\n        line (``\"\"``), the remainder are sequences of long and short\n        dashes.\n\n    \"\"\"\n    # Start with dash specs that are well distinguishable\n    dashes = [\n        \"\",\n        (4, 1.5),\n        (1, 1),\n        (3, 1.25, 1.5, 1.25),\n        (5, 1, 1, 1),\n    ]\n\n    # Now programmatically build as many as we need\n    p = 3\n    while len(dashes) < n:\n\n        # Take combinations of long and short dashes\n        a = itertools.combinations_with_replacement([3, 1.25], p)\n        b = itertools.combinations_with_replacement([4, 1], p)\n\n        # Interleave the combinations, reversing one of the streams\n        segment_list = itertools.chain(*zip(\n            list(a)[1:-1][::-1],\n            list(b)[1:-1]\n        ))\n\n        # Now insert the gaps\n        for segments in segment_list:\n            gap = min(segments)\n            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))\n            dashes.append(spec)\n\n        p += 1\n\n    return dashes[:n]\n", "tokens": ["seaborn", "_oldcore", "py", "def", "unique_dashes", "n", "build", "an", "arbitrarily", "long", "list", "of", "unique", "dash", "styles", "for", "lines", "parameters", "n", "int", "number", "of", "unique", "dash", "specs", "to", "generate", "returns", "dashes", "list", "of", "strings", "or", "tuples", "valid", "arguments", "for", "the", "dashes", "parameter", "on", "class", "matplotlib", "lines", "line2d", "the", "first", "spec", "is", "a", "solid", "line", "the", "remainder", "are", "sequences", "of", "long", "and", "short", "dashes", "start", "with", "dash", "specs", "that", "are", "well", "distinguishable", "dashes", "4", "1", "5", "1", "1", "3", "1", "25", "1", "5", "1", "25", "5", "1", "1", "1", "now", "programmatically", "build", "as", "many", "as", "we", "need", "p", "3", "while", "len", "dashes", "n", "take", "combinations", "of", "long", "and", "short", "dashes", "a", "itertools", "combinations_with_replacement", "3", "1", "25", "p", "b", "itertools", "combinations_with_replacement", "4", "1", "p", "interleave", "the", "combinations", "reversing", "one", "of", "the", "streams", "segment_list", "itertools", "chain", "zip", "list", "a", "1", "1", "1", "list", "b", "1", "1", "now", "insert", "the", "gaps", "for", "segments", "in", "segment_list", "gap", "min", "segments", "spec", "tuple", "itertools", "chain", "seg", "gap", "for", "seg", "in", "segments", "dashes", "append", "spec", "p", "1", "return", "dashes", "n"], "doc_len": 170}
{"doc_id": "seaborn/_oldcore.py::unique_markers", "file_path": "seaborn/_oldcore.py", "class_name": null, "func_name": "unique_markers", "text": "文件路径: seaborn/_oldcore.py\ndef unique_markers(n):\n    \"\"\"Build an arbitrarily long list of unique marker styles for points.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique marker specs to generate.\n\n    Returns\n    -------\n    markers : list of string or tuples\n        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.\n        All markers will be filled.\n\n    \"\"\"\n    # Start with marker specs that are well distinguishable\n    markers = [\n        \"o\",\n        \"X\",\n        (4, 0, 45),\n        \"P\",\n        (4, 0, 0),\n        (4, 1, 0),\n        \"^\",\n        (4, 1, 45),\n        \"v\",\n    ]\n\n    # Now generate more from regular polygons of increasing order\n    s = 5\n    while len(markers) < n:\n        a = 360 / (s + 1) / 2\n        markers.extend([\n            (s + 1, 1, a),\n            (s + 1, 0, a),\n            (s, 1, 0),\n            (s, 0, 0),\n        ])\n        s += 1\n\n    # Convert to MarkerStyle object, using only exactly what we need\n    # markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]\n\n    return markers[:n]\n", "tokens": ["seaborn", "_oldcore", "py", "def", "unique_markers", "n", "build", "an", "arbitrarily", "long", "list", "of", "unique", "marker", "styles", "for", "points", "parameters", "n", "int", "number", "of", "unique", "marker", "specs", "to", "generate", "returns", "markers", "list", "of", "string", "or", "tuples", "values", "for", "defining", "class", "matplotlib", "markers", "markerstyle", "objects", "all", "markers", "will", "be", "filled", "start", "with", "marker", "specs", "that", "are", "well", "distinguishable", "markers", "o", "x", "4", "0", "45", "p", "4", "0", "0", "4", "1", "0", "4", "1", "45", "v", "now", "generate", "more", "from", "regular", "polygons", "of", "increasing", "order", "s", "5", "while", "len", "markers", "n", "a", "360", "s", "1", "2", "markers", "extend", "s", "1", "1", "a", "s", "1", "0", "a", "s", "1", "0", "s", "0", "0", "s", "1", "convert", "to", "markerstyle", "object", "using", "only", "exactly", "what", "we", "need", "markers", "mpl", "markers", "markerstyle", "m", "for", "m", "in", "markers", "n", "return", "markers", "n"], "doc_len": 133}
{"doc_id": "seaborn/_oldcore.py::categorical_order", "file_path": "seaborn/_oldcore.py", "class_name": null, "func_name": "categorical_order", "text": "文件路径: seaborn/_oldcore.py\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values.\n\n    Determine an ordered list of levels in ``values``.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the ``values`` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        if hasattr(vector, \"categories\"):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n\n                try:\n                    order = vector.unique()\n                except AttributeError:\n                    order = pd.unique(vector)\n\n                if variable_type(vector) == \"numeric\":\n                    order = np.sort(order)\n\n        order = filter(pd.notnull, order)\n    return list(order)\n", "tokens": ["seaborn", "_oldcore", "py", "def", "categorical_order", "vector", "order", "none", "return", "a", "list", "of", "unique", "data", "values", "determine", "an", "ordered", "list", "of", "levels", "in", "values", "parameters", "vector", "list", "array", "categorical", "or", "series", "vector", "of", "categorical", "values", "order", "list", "like", "optional", "desired", "order", "of", "category", "levels", "to", "override", "the", "order", "determined", "from", "the", "values", "object", "returns", "order", "list", "ordered", "list", "of", "category", "levels", "not", "including", "null", "values", "if", "order", "is", "none", "if", "hasattr", "vector", "categories", "order", "vector", "categories", "else", "try", "order", "vector", "cat", "categories", "except", "typeerror", "attributeerror", "try", "order", "vector", "unique", "except", "attributeerror", "order", "pd", "unique", "vector", "if", "variable_type", "vector", "numeric", "order", "np", "sort", "order", "order", "filter", "pd", "notnull", "order", "return", "list", "order"], "doc_len": 110}
{"doc_id": "seaborn/_statistics.py::KDE.__init__", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "__init__", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def __init__(\n        self, *,\n        bw_method=None,\n        bw_adjust=1,\n        gridsize=200,\n        cut=3,\n        clip=None,\n        cumulative=False,\n    ):\n        \"\"\"Initialize the estimator with its parameters.\n\n        Parameters\n        ----------\n        bw_method : string, scalar, or callable, optional\n            Method for determining the smoothing bandwidth to use; passed to\n            :class:`scipy.stats.gaussian_kde`.\n        bw_adjust : number, optional\n            Factor that multiplicatively scales the value chosen using\n            ``bw_method``. Increasing will make the curve smoother. See Notes.\n        gridsize : int, optional\n            Number of points on each dimension of the evaluation grid.\n        cut : number, optional\n            Factor, multiplied by the smoothing bandwidth, that determines how\n            far the evaluation grid extends past the extreme datapoints. When\n            set to 0, truncate the curve at the data limits.\n        clip : pair of numbers or None, or a pair of such pairs\n            Do not evaluate the density outside of these limits.\n        cumulative : bool, optional\n            If True, estimate a cumulative distribution function. Requires scipy.\n\n        \"\"\"\n        if clip is None:\n            clip = None, None\n\n        self.bw_method = bw_method\n        self.bw_adjust = bw_adjust\n        self.gridsize = gridsize\n        self.cut = cut\n        self.clip = clip\n        self.cumulative = cumulative\n\n        if cumulative and _no_scipy:\n            raise RuntimeError(\"Cumulative KDE evaluation requires scipy\")\n\n        self.support = None\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "__init__", "self", "bw_method", "none", "bw_adjust", "1", "gridsize", "200", "cut", "3", "clip", "none", "cumulative", "false", "initialize", "the", "estimator", "with", "its", "parameters", "parameters", "bw_method", "string", "scalar", "or", "callable", "optional", "method", "for", "determining", "the", "smoothing", "bandwidth", "to", "use", "passed", "to", "class", "scipy", "stats", "gaussian_kde", "bw_adjust", "number", "optional", "factor", "that", "multiplicatively", "scales", "the", "value", "chosen", "using", "bw_method", "increasing", "will", "make", "the", "curve", "smoother", "see", "notes", "gridsize", "int", "optional", "number", "of", "points", "on", "each", "dimension", "of", "the", "evaluation", "grid", "cut", "number", "optional", "factor", "multiplied", "by", "the", "smoothing", "bandwidth", "that", "determines", "how", "far", "the", "evaluation", "grid", "extends", "past", "the", "extreme", "datapoints", "when", "set", "to", "0", "truncate", "the", "curve", "at", "the", "data", "limits", "clip", "pair", "of", "numbers", "or", "none", "or", "a", "pair", "of", "such", "pairs", "do", "not", "evaluate", "the", "density", "outside", "of", "these", "limits", "cumulative", "bool", "optional", "if", "true", "estimate", "a", "cumulative", "distribution", "function", "requires", "scipy", "if", "clip", "is", "none", "clip", "none", "none", "self", "bw_method", "bw_method", "self", "bw_adjust", "bw_adjust", "self", "gridsize", "gridsize", "self", "cut", "cut", "self", "clip", "clip", "self", "cumulative", "cumulative", "if", "cumulative", "and", "_no_scipy", "raise", "runtimeerror", "cumulative", "kde", "evaluation", "requires", "scipy", "self", "support", "none"], "doc_len": 183}
{"doc_id": "seaborn/_statistics.py::KDE._define_support_grid", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_define_support_grid", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _define_support_grid(self, x, bw, cut, clip, gridsize):\n        \"\"\"Create the grid of evaluation points depending for vector x.\"\"\"\n        clip_lo = -np.inf if clip[0] is None else clip[0]\n        clip_hi = +np.inf if clip[1] is None else clip[1]\n        gridmin = max(x.min() - bw * cut, clip_lo)\n        gridmax = min(x.max() + bw * cut, clip_hi)\n        return np.linspace(gridmin, gridmax, gridsize)\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_define_support_grid", "self", "x", "bw", "cut", "clip", "gridsize", "create", "the", "grid", "of", "evaluation", "points", "depending", "for", "vector", "x", "clip_lo", "np", "inf", "if", "clip", "0", "is", "none", "else", "clip", "0", "clip_hi", "np", "inf", "if", "clip", "1", "is", "none", "else", "clip", "1", "gridmin", "max", "x", "min", "bw", "cut", "clip_lo", "gridmax", "min", "x", "max", "bw", "cut", "clip_hi", "return", "np", "linspace", "gridmin", "gridmax", "gridsize"], "doc_len": 64}
{"doc_id": "seaborn/_statistics.py::KDE._define_support_univariate", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_define_support_univariate", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _define_support_univariate(self, x, weights):\n        \"\"\"Create a 1D grid of evaluation points.\"\"\"\n        kde = self._fit(x, weights)\n        bw = np.sqrt(kde.covariance.squeeze())\n        grid = self._define_support_grid(\n            x, bw, self.cut, self.clip, self.gridsize\n        )\n        return grid\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_define_support_univariate", "self", "x", "weights", "create", "a", "1d", "grid", "of", "evaluation", "points", "kde", "self", "_fit", "x", "weights", "bw", "np", "sqrt", "kde", "covariance", "squeeze", "grid", "self", "_define_support_grid", "x", "bw", "self", "cut", "self", "clip", "self", "gridsize", "return", "grid"], "doc_len": 40}
{"doc_id": "seaborn/_statistics.py::KDE._define_support_bivariate", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_define_support_bivariate", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _define_support_bivariate(self, x1, x2, weights):\n        \"\"\"Create a 2D grid of evaluation points.\"\"\"\n        clip = self.clip\n        if clip[0] is None or np.isscalar(clip[0]):\n            clip = (clip, clip)\n\n        kde = self._fit([x1, x2], weights)\n        bw = np.sqrt(np.diag(kde.covariance).squeeze())\n\n        grid1 = self._define_support_grid(\n            x1, bw[0], self.cut, clip[0], self.gridsize\n        )\n        grid2 = self._define_support_grid(\n            x2, bw[1], self.cut, clip[1], self.gridsize\n        )\n\n        return grid1, grid2\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_define_support_bivariate", "self", "x1", "x2", "weights", "create", "a", "2d", "grid", "of", "evaluation", "points", "clip", "self", "clip", "if", "clip", "0", "is", "none", "or", "np", "isscalar", "clip", "0", "clip", "clip", "clip", "kde", "self", "_fit", "x1", "x2", "weights", "bw", "np", "sqrt", "np", "diag", "kde", "covariance", "squeeze", "grid1", "self", "_define_support_grid", "x1", "bw", "0", "self", "cut", "clip", "0", "self", "gridsize", "grid2", "self", "_define_support_grid", "x2", "bw", "1", "self", "cut", "clip", "1", "self", "gridsize", "return", "grid1", "grid2"], "doc_len": 74}
{"doc_id": "seaborn/_statistics.py::KDE.define_support", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "define_support", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def define_support(self, x1, x2=None, weights=None, cache=True):\n        \"\"\"Create the evaluation grid for a given data set.\"\"\"\n        if x2 is None:\n            support = self._define_support_univariate(x1, weights)\n        else:\n            support = self._define_support_bivariate(x1, x2, weights)\n\n        if cache:\n            self.support = support\n\n        return support\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "define_support", "self", "x1", "x2", "none", "weights", "none", "cache", "true", "create", "the", "evaluation", "grid", "for", "a", "given", "data", "set", "if", "x2", "is", "none", "support", "self", "_define_support_univariate", "x1", "weights", "else", "support", "self", "_define_support_bivariate", "x1", "x2", "weights", "if", "cache", "self", "support", "support", "return", "support"], "doc_len": 46}
{"doc_id": "seaborn/_statistics.py::KDE._fit", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_fit", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _fit(self, fit_data, weights=None):\n        \"\"\"Fit the scipy kde while adding bw_adjust logic and version check.\"\"\"\n        fit_kws = {\"bw_method\": self.bw_method}\n        if weights is not None:\n            fit_kws[\"weights\"] = weights\n\n        kde = gaussian_kde(fit_data, **fit_kws)\n        kde.set_bandwidth(kde.factor * self.bw_adjust)\n\n        return kde\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_fit", "self", "fit_data", "weights", "none", "fit", "the", "scipy", "kde", "while", "adding", "bw_adjust", "logic", "and", "version", "check", "fit_kws", "bw_method", "self", "bw_method", "if", "weights", "is", "not", "none", "fit_kws", "weights", "weights", "kde", "gaussian_kde", "fit_data", "fit_kws", "kde", "set_bandwidth", "kde", "factor", "self", "bw_adjust", "return", "kde"], "doc_len": 45}
{"doc_id": "seaborn/_statistics.py::KDE._eval_univariate", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_eval_univariate", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _eval_univariate(self, x, weights=None):\n        \"\"\"Fit and evaluate a univariate on univariate data.\"\"\"\n        support = self.support\n        if support is None:\n            support = self.define_support(x, cache=False)\n\n        kde = self._fit(x, weights)\n\n        if self.cumulative:\n            s_0 = support[0]\n            density = np.array([\n                kde.integrate_box_1d(s_0, s_i) for s_i in support\n            ])\n        else:\n            density = kde(support)\n\n        return density, support\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_eval_univariate", "self", "x", "weights", "none", "fit", "and", "evaluate", "a", "univariate", "on", "univariate", "data", "support", "self", "support", "if", "support", "is", "none", "support", "self", "define_support", "x", "cache", "false", "kde", "self", "_fit", "x", "weights", "if", "self", "cumulative", "s_0", "support", "0", "density", "np", "array", "kde", "integrate_box_1d", "s_0", "s_i", "for", "s_i", "in", "support", "else", "density", "kde", "support", "return", "density", "support"], "doc_len": 60}
{"doc_id": "seaborn/_statistics.py::KDE._eval_bivariate", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "_eval_bivariate", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def _eval_bivariate(self, x1, x2, weights=None):\n        \"\"\"Fit and evaluate a univariate on bivariate data.\"\"\"\n        support = self.support\n        if support is None:\n            support = self.define_support(x1, x2, cache=False)\n\n        kde = self._fit([x1, x2], weights)\n\n        if self.cumulative:\n\n            grid1, grid2 = support\n            density = np.zeros((grid1.size, grid2.size))\n            p0 = grid1.min(), grid2.min()\n            for i, xi in enumerate(grid1):\n                for j, xj in enumerate(grid2):\n                    density[i, j] = kde.integrate_box(p0, (xi, xj))\n\n        else:\n\n            xx1, xx2 = np.meshgrid(*support)\n            density = kde([xx1.ravel(), xx2.ravel()]).reshape(xx1.shape)\n\n        return density, support\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "_eval_bivariate", "self", "x1", "x2", "weights", "none", "fit", "and", "evaluate", "a", "univariate", "on", "bivariate", "data", "support", "self", "support", "if", "support", "is", "none", "support", "self", "define_support", "x1", "x2", "cache", "false", "kde", "self", "_fit", "x1", "x2", "weights", "if", "self", "cumulative", "grid1", "grid2", "support", "density", "np", "zeros", "grid1", "size", "grid2", "size", "p0", "grid1", "min", "grid2", "min", "for", "i", "xi", "in", "enumerate", "grid1", "for", "j", "xj", "in", "enumerate", "grid2", "density", "i", "j", "kde", "integrate_box", "p0", "xi", "xj", "else", "xx1", "xx2", "np", "meshgrid", "support", "density", "kde", "xx1", "ravel", "xx2", "ravel", "reshape", "xx1", "shape", "return", "density", "support"], "doc_len": 95}
{"doc_id": "seaborn/_statistics.py::KDE.__call__", "file_path": "seaborn/_statistics.py", "class_name": "KDE", "func_name": "__call__", "text": "文件路径: seaborn/_statistics.py, 类名: KDE\n    def __call__(self, x1, x2=None, weights=None):\n        \"\"\"Fit and evaluate on univariate or bivariate data.\"\"\"\n        if x2 is None:\n            return self._eval_univariate(x1, weights)\n        else:\n            return self._eval_bivariate(x1, x2, weights)\n", "tokens": ["seaborn", "_statistics", "py", "kde", "def", "__call__", "self", "x1", "x2", "none", "weights", "none", "fit", "and", "evaluate", "on", "univariate", "or", "bivariate", "data", "if", "x2", "is", "none", "return", "self", "_eval_univariate", "x1", "weights", "else", "return", "self", "_eval_bivariate", "x1", "x2", "weights"], "doc_len": 36}
{"doc_id": "seaborn/_statistics.py::Histogram.__init__", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "__init__", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def __init__(\n        self,\n        stat=\"count\",\n        bins=\"auto\",\n        binwidth=None,\n        binrange=None,\n        discrete=False,\n        cumulative=False,\n    ):\n        \"\"\"Initialize the estimator with its parameters.\n\n        Parameters\n        ----------\n        stat : str\n            Aggregate statistic to compute in each bin.\n\n            - `count`: show the number of observations in each bin\n            - `frequency`: show the number of observations divided by the bin width\n            - `probability` or `proportion`: normalize such that bar heights sum to 1\n            - `percent`: normalize such that bar heights sum to 100\n            - `density`: normalize such that the total area of the histogram equals 1\n\n        bins : str, number, vector, or a pair of such values\n            Generic bin parameter that can be the name of a reference rule,\n            the number of bins, or the breaks of the bins.\n            Passed to :func:`numpy.histogram_bin_edges`.\n        binwidth : number or pair of numbers\n            Width of each bin, overrides ``bins`` but can be used with\n            ``binrange``.\n        binrange : pair of numbers or a pair of pairs\n            Lowest and highest value for bin edges; can be used either\n            with ``bins`` or ``binwidth``. Defaults to data extremes.\n        discrete : bool or pair of bools\n            If True, set ``binwidth`` and ``binrange`` such that bin\n            edges cover integer values in the dataset.\n        cumulative : bool\n            If True, return the cumulative statistic.\n\n        \"\"\"\n        stat_choices = [\n            \"count\", \"frequency\", \"density\", \"probability\", \"proportion\", \"percent\",\n        ]\n        _check_argument(\"stat\", stat_choices, stat)\n\n        self.stat = stat\n        self.bins = bins\n        self.binwidth = binwidth\n        self.binrange = binrange\n        self.discrete = discrete\n        self.cumulative = cumulative\n\n        self.bin_kws = None\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "__init__", "self", "stat", "count", "bins", "auto", "binwidth", "none", "binrange", "none", "discrete", "false", "cumulative", "false", "initialize", "the", "estimator", "with", "its", "parameters", "parameters", "stat", "str", "aggregate", "statistic", "to", "compute", "in", "each", "bin", "count", "show", "the", "number", "of", "observations", "in", "each", "bin", "frequency", "show", "the", "number", "of", "observations", "divided", "by", "the", "bin", "width", "probability", "or", "proportion", "normalize", "such", "that", "bar", "heights", "sum", "to", "1", "percent", "normalize", "such", "that", "bar", "heights", "sum", "to", "100", "density", "normalize", "such", "that", "the", "total", "area", "of", "the", "histogram", "equals", "1", "bins", "str", "number", "vector", "or", "a", "pair", "of", "such", "values", "generic", "bin", "parameter", "that", "can", "be", "the", "name", "of", "a", "reference", "rule", "the", "number", "of", "bins", "or", "the", "breaks", "of", "the", "bins", "passed", "to", "func", "numpy", "histogram_bin_edges", "binwidth", "number", "or", "pair", "of", "numbers", "width", "of", "each", "bin", "overrides", "bins", "but", "can", "be", "used", "with", "binrange", "binrange", "pair", "of", "numbers", "or", "a", "pair", "of", "pairs", "lowest", "and", "highest", "value", "for", "bin", "edges", "can", "be", "used", "either", "with", "bins", "or", "binwidth", "defaults", "to", "data", "extremes", "discrete", "bool", "or", "pair", "of", "bools", "if", "true", "set", "binwidth", "and", "binrange", "such", "that", "bin", "edges", "cover", "integer", "values", "in", "the", "dataset", "cumulative", "bool", "if", "true", "return", "the", "cumulative", "statistic", "stat_choices", "count", "frequency", "density", "probability", "proportion", "percent", "_check_argument", "stat", "stat_choices", "stat", "self", "stat", "stat", "self", "bins", "bins", "self", "binwidth", "binwidth", "self", "binrange", "binrange", "self", "discrete", "discrete", "self", "cumulative", "cumulative", "self", "bin_kws", "none"], "doc_len": 232}
{"doc_id": "seaborn/_statistics.py::Histogram._define_bin_edges", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "_define_bin_edges", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):\n        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"\n        if binrange is None:\n            start, stop = x.min(), x.max()\n        else:\n            start, stop = binrange\n\n        if discrete:\n            bin_edges = np.arange(start - .5, stop + 1.5)\n        elif binwidth is not None:\n            step = binwidth\n            bin_edges = np.arange(start, stop + step, step)\n            # Handle roundoff error (maybe there is a less clumsy way?)\n            if bin_edges.max() < stop or len(bin_edges) < 2:\n                bin_edges = np.append(bin_edges, bin_edges.max() + step)\n        else:\n            bin_edges = np.histogram_bin_edges(\n                x, bins, binrange, weights,\n            )\n        return bin_edges\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "_define_bin_edges", "self", "x", "weights", "bins", "binwidth", "binrange", "discrete", "inner", "function", "that", "takes", "bin", "parameters", "as", "arguments", "if", "binrange", "is", "none", "start", "stop", "x", "min", "x", "max", "else", "start", "stop", "binrange", "if", "discrete", "bin_edges", "np", "arange", "start", "5", "stop", "1", "5", "elif", "binwidth", "is", "not", "none", "step", "binwidth", "bin_edges", "np", "arange", "start", "stop", "step", "step", "handle", "roundoff", "error", "maybe", "there", "is", "a", "less", "clumsy", "way", "if", "bin_edges", "max", "stop", "or", "len", "bin_edges", "2", "bin_edges", "np", "append", "bin_edges", "bin_edges", "max", "step", "else", "bin_edges", "np", "histogram_bin_edges", "x", "bins", "binrange", "weights", "return", "bin_edges"], "doc_len": 94}
{"doc_id": "seaborn/_statistics.py::Histogram.define_bin_params", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "define_bin_params", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def define_bin_params(self, x1, x2=None, weights=None, cache=True):\n        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"\n        if x2 is None:\n\n            bin_edges = self._define_bin_edges(\n                x1, weights, self.bins, self.binwidth, self.binrange, self.discrete,\n            )\n\n            if isinstance(self.bins, (str, Number)):\n                n_bins = len(bin_edges) - 1\n                bin_range = bin_edges.min(), bin_edges.max()\n                bin_kws = dict(bins=n_bins, range=bin_range)\n            else:\n                bin_kws = dict(bins=bin_edges)\n\n        else:\n\n            bin_edges = []\n            for i, x in enumerate([x1, x2]):\n\n                # Resolve out whether bin parameters are shared\n                # or specific to each variable\n\n                bins = self.bins\n                if not bins or isinstance(bins, (str, Number)):\n                    pass\n                elif isinstance(bins[i], str):\n                    bins = bins[i]\n                elif len(bins) == 2:\n                    bins = bins[i]\n\n                binwidth = self.binwidth\n                if binwidth is None:\n                    pass\n                elif not isinstance(binwidth, Number):\n                    binwidth = binwidth[i]\n\n                binrange = self.binrange\n                if binrange is None:\n                    pass\n                elif not isinstance(binrange[0], Number):\n                    binrange = binrange[i]\n\n                discrete = self.discrete\n                if not isinstance(discrete, bool):\n                    discrete = discrete[i]\n\n                # Define the bins for this variable\n\n                bin_edges.append(self._define_bin_edges(\n                    x, weights, bins, binwidth, binrange, discrete,\n                ))\n\n            bin_kws = dict(bins=tuple(bin_edges))\n\n        if cache:\n            self.bin_kws = bin_kws\n\n        return bin_kws\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "define_bin_params", "self", "x1", "x2", "none", "weights", "none", "cache", "true", "given", "data", "return", "numpy", "histogram", "parameters", "to", "define", "bins", "if", "x2", "is", "none", "bin_edges", "self", "_define_bin_edges", "x1", "weights", "self", "bins", "self", "binwidth", "self", "binrange", "self", "discrete", "if", "isinstance", "self", "bins", "str", "number", "n_bins", "len", "bin_edges", "1", "bin_range", "bin_edges", "min", "bin_edges", "max", "bin_kws", "dict", "bins", "n_bins", "range", "bin_range", "else", "bin_kws", "dict", "bins", "bin_edges", "else", "bin_edges", "for", "i", "x", "in", "enumerate", "x1", "x2", "resolve", "out", "whether", "bin", "parameters", "are", "shared", "or", "specific", "to", "each", "variable", "bins", "self", "bins", "if", "not", "bins", "or", "isinstance", "bins", "str", "number", "pass", "elif", "isinstance", "bins", "i", "str", "bins", "bins", "i", "elif", "len", "bins", "2", "bins", "bins", "i", "binwidth", "self", "binwidth", "if", "binwidth", "is", "none", "pass", "elif", "not", "isinstance", "binwidth", "number", "binwidth", "binwidth", "i", "binrange", "self", "binrange", "if", "binrange", "is", "none", "pass", "elif", "not", "isinstance", "binrange", "0", "number", "binrange", "binrange", "i", "discrete", "self", "discrete", "if", "not", "isinstance", "discrete", "bool", "discrete", "discrete", "i", "define", "the", "bins", "for", "this", "variable", "bin_edges", "append", "self", "_define_bin_edges", "x", "weights", "bins", "binwidth", "binrange", "discrete", "bin_kws", "dict", "bins", "tuple", "bin_edges", "if", "cache", "self", "bin_kws", "bin_kws", "return", "bin_kws"], "doc_len": 186}
{"doc_id": "seaborn/_statistics.py::Histogram._eval_bivariate", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "_eval_bivariate", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def _eval_bivariate(self, x1, x2, weights):\n        \"\"\"Inner function for histogram of two variables.\"\"\"\n        bin_kws = self.bin_kws\n        if bin_kws is None:\n            bin_kws = self.define_bin_params(x1, x2, cache=False)\n\n        density = self.stat == \"density\"\n\n        hist, *bin_edges = np.histogram2d(\n            x1, x2, **bin_kws, weights=weights, density=density\n        )\n\n        area = np.outer(\n            np.diff(bin_edges[0]),\n            np.diff(bin_edges[1]),\n        )\n\n        if self.stat == \"probability\" or self.stat == \"proportion\":\n            hist = hist.astype(float) / hist.sum()\n        elif self.stat == \"percent\":\n            hist = hist.astype(float) / hist.sum() * 100\n        elif self.stat == \"frequency\":\n            hist = hist.astype(float) / area\n\n        if self.cumulative:\n            if self.stat in [\"density\", \"frequency\"]:\n                hist = (hist * area).cumsum(axis=0).cumsum(axis=1)\n            else:\n                hist = hist.cumsum(axis=0).cumsum(axis=1)\n\n        return hist, bin_edges\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "_eval_bivariate", "self", "x1", "x2", "weights", "inner", "function", "for", "histogram", "of", "two", "variables", "bin_kws", "self", "bin_kws", "if", "bin_kws", "is", "none", "bin_kws", "self", "define_bin_params", "x1", "x2", "cache", "false", "density", "self", "stat", "density", "hist", "bin_edges", "np", "histogram2d", "x1", "x2", "bin_kws", "weights", "weights", "density", "density", "area", "np", "outer", "np", "diff", "bin_edges", "0", "np", "diff", "bin_edges", "1", "if", "self", "stat", "probability", "or", "self", "stat", "proportion", "hist", "hist", "astype", "float", "hist", "sum", "elif", "self", "stat", "percent", "hist", "hist", "astype", "float", "hist", "sum", "100", "elif", "self", "stat", "frequency", "hist", "hist", "astype", "float", "area", "if", "self", "cumulative", "if", "self", "stat", "in", "density", "frequency", "hist", "hist", "area", "cumsum", "axis", "0", "cumsum", "axis", "1", "else", "hist", "hist", "cumsum", "axis", "0", "cumsum", "axis", "1", "return", "hist", "bin_edges"], "doc_len": 121}
{"doc_id": "seaborn/_statistics.py::Histogram._eval_univariate", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "_eval_univariate", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def _eval_univariate(self, x, weights):\n        \"\"\"Inner function for histogram of one variable.\"\"\"\n        bin_kws = self.bin_kws\n        if bin_kws is None:\n            bin_kws = self.define_bin_params(x, weights=weights, cache=False)\n\n        density = self.stat == \"density\"\n        hist, bin_edges = np.histogram(\n            x, **bin_kws, weights=weights, density=density,\n        )\n\n        if self.stat == \"probability\" or self.stat == \"proportion\":\n            hist = hist.astype(float) / hist.sum()\n        elif self.stat == \"percent\":\n            hist = hist.astype(float) / hist.sum() * 100\n        elif self.stat == \"frequency\":\n            hist = hist.astype(float) / np.diff(bin_edges)\n\n        if self.cumulative:\n            if self.stat in [\"density\", \"frequency\"]:\n                hist = (hist * np.diff(bin_edges)).cumsum()\n            else:\n                hist = hist.cumsum()\n\n        return hist, bin_edges\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "_eval_univariate", "self", "x", "weights", "inner", "function", "for", "histogram", "of", "one", "variable", "bin_kws", "self", "bin_kws", "if", "bin_kws", "is", "none", "bin_kws", "self", "define_bin_params", "x", "weights", "weights", "cache", "false", "density", "self", "stat", "density", "hist", "bin_edges", "np", "histogram", "x", "bin_kws", "weights", "weights", "density", "density", "if", "self", "stat", "probability", "or", "self", "stat", "proportion", "hist", "hist", "astype", "float", "hist", "sum", "elif", "self", "stat", "percent", "hist", "hist", "astype", "float", "hist", "sum", "100", "elif", "self", "stat", "frequency", "hist", "hist", "astype", "float", "np", "diff", "bin_edges", "if", "self", "cumulative", "if", "self", "stat", "in", "density", "frequency", "hist", "hist", "np", "diff", "bin_edges", "cumsum", "else", "hist", "hist", "cumsum", "return", "hist", "bin_edges"], "doc_len": 103}
{"doc_id": "seaborn/_statistics.py::Histogram.__call__", "file_path": "seaborn/_statistics.py", "class_name": "Histogram", "func_name": "__call__", "text": "文件路径: seaborn/_statistics.py, 类名: Histogram\n    def __call__(self, x1, x2=None, weights=None):\n        \"\"\"Count the occurrences in each bin, maybe normalize.\"\"\"\n        if x2 is None:\n            return self._eval_univariate(x1, weights)\n        else:\n            return self._eval_bivariate(x1, x2, weights)\n", "tokens": ["seaborn", "_statistics", "py", "histogram", "def", "__call__", "self", "x1", "x2", "none", "weights", "none", "count", "the", "occurrences", "in", "each", "bin", "maybe", "normalize", "if", "x2", "is", "none", "return", "self", "_eval_univariate", "x1", "weights", "else", "return", "self", "_eval_bivariate", "x1", "x2", "weights"], "doc_len": 36}
{"doc_id": "seaborn/_statistics.py::ECDF.__init__", "file_path": "seaborn/_statistics.py", "class_name": "ECDF", "func_name": "__init__", "text": "文件路径: seaborn/_statistics.py, 类名: ECDF\n    def __init__(self, stat=\"proportion\", complementary=False):\n        \"\"\"Initialize the class with its parameters\n\n        Parameters\n        ----------\n        stat : {{\"proportion\", \"count\"}}\n            Distribution statistic to compute.\n        complementary : bool\n            If True, use the complementary CDF (1 - CDF)\n\n        \"\"\"\n        _check_argument(\"stat\", [\"count\", \"proportion\"], stat)\n        self.stat = stat\n        self.complementary = complementary\n", "tokens": ["seaborn", "_statistics", "py", "ecdf", "def", "__init__", "self", "stat", "proportion", "complementary", "false", "initialize", "the", "class", "with", "its", "parameters", "parameters", "stat", "proportion", "count", "distribution", "statistic", "to", "compute", "complementary", "bool", "if", "true", "use", "the", "complementary", "cdf", "1", "cdf", "_check_argument", "stat", "count", "proportion", "stat", "self", "stat", "stat", "self", "complementary", "complementary"], "doc_len": 46}
{"doc_id": "seaborn/_statistics.py::ECDF._eval_bivariate", "file_path": "seaborn/_statistics.py", "class_name": "ECDF", "func_name": "_eval_bivariate", "text": "文件路径: seaborn/_statistics.py, 类名: ECDF\n    def _eval_bivariate(self, x1, x2, weights):\n        \"\"\"Inner function for ECDF of two variables.\"\"\"\n        raise NotImplementedError(\"Bivariate ECDF is not implemented\")\n", "tokens": ["seaborn", "_statistics", "py", "ecdf", "def", "_eval_bivariate", "self", "x1", "x2", "weights", "inner", "function", "for", "ecdf", "of", "two", "variables", "raise", "notimplementederror", "bivariate", "ecdf", "is", "not", "implemented"], "doc_len": 24}
{"doc_id": "seaborn/_statistics.py::ECDF._eval_univariate", "file_path": "seaborn/_statistics.py", "class_name": "ECDF", "func_name": "_eval_univariate", "text": "文件路径: seaborn/_statistics.py, 类名: ECDF\n    def _eval_univariate(self, x, weights):\n        \"\"\"Inner function for ECDF of one variable.\"\"\"\n        sorter = x.argsort()\n        x = x[sorter]\n        weights = weights[sorter]\n        y = weights.cumsum()\n\n        if self.stat == \"proportion\":\n            y = y / y.max()\n\n        x = np.r_[-np.inf, x]\n        y = np.r_[0, y]\n\n        if self.complementary:\n            y = y.max() - y\n\n        return y, x\n", "tokens": ["seaborn", "_statistics", "py", "ecdf", "def", "_eval_univariate", "self", "x", "weights", "inner", "function", "for", "ecdf", "of", "one", "variable", "sorter", "x", "argsort", "x", "x", "sorter", "weights", "weights", "sorter", "y", "weights", "cumsum", "if", "self", "stat", "proportion", "y", "y", "y", "max", "x", "np", "r_", "np", "inf", "x", "y", "np", "r_", "0", "y", "if", "self", "complementary", "y", "y", "max", "y", "return", "y", "x"], "doc_len": 57}
{"doc_id": "seaborn/_statistics.py::ECDF.__call__", "file_path": "seaborn/_statistics.py", "class_name": "ECDF", "func_name": "__call__", "text": "文件路径: seaborn/_statistics.py, 类名: ECDF\n    def __call__(self, x1, x2=None, weights=None):\n        \"\"\"Return proportion or count of observations below each sorted datapoint.\"\"\"\n        x1 = np.asarray(x1)\n        if weights is None:\n            weights = np.ones_like(x1)\n        else:\n            weights = np.asarray(weights)\n\n        if x2 is None:\n            return self._eval_univariate(x1, weights)\n        else:\n            return self._eval_bivariate(x1, x2, weights)\n", "tokens": ["seaborn", "_statistics", "py", "ecdf", "def", "__call__", "self", "x1", "x2", "none", "weights", "none", "return", "proportion", "or", "count", "of", "observations", "below", "each", "sorted", "datapoint", "x1", "np", "asarray", "x1", "if", "weights", "is", "none", "weights", "np", "ones_like", "x1", "else", "weights", "np", "asarray", "weights", "if", "x2", "is", "none", "return", "self", "_eval_univariate", "x1", "weights", "else", "return", "self", "_eval_bivariate", "x1", "x2", "weights"], "doc_len": 55}
{"doc_id": "seaborn/_statistics.py::EstimateAggregator.__init__", "file_path": "seaborn/_statistics.py", "class_name": "EstimateAggregator", "func_name": "__init__", "text": "文件路径: seaborn/_statistics.py, 类名: EstimateAggregator\n    def __init__(self, estimator, errorbar=None, **boot_kws):\n        \"\"\"\n        Data aggregator that produces an estimate and error bar interval.\n\n        Parameters\n        ----------\n        estimator : callable or string\n            Function (or method name) that maps a vector to a scalar.\n        errorbar : string, (string, number) tuple, or callable\n            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple\n            with a method name and a level parameter, or a function that maps from a\n            vector to a (min, max) interval.\n        boot_kws\n            Additional keywords are passed to bootstrap when error_method is \"ci\".\n\n        \"\"\"\n        self.estimator = estimator\n\n        method, level = _validate_errorbar_arg(errorbar)\n        self.error_method = method\n        self.error_level = level\n\n        self.boot_kws = boot_kws\n", "tokens": ["seaborn", "_statistics", "py", "estimateaggregator", "def", "__init__", "self", "estimator", "errorbar", "none", "boot_kws", "data", "aggregator", "that", "produces", "an", "estimate", "and", "error", "bar", "interval", "parameters", "estimator", "callable", "or", "string", "function", "or", "method", "name", "that", "maps", "a", "vector", "to", "a", "scalar", "errorbar", "string", "string", "number", "tuple", "or", "callable", "name", "of", "errorbar", "method", "either", "ci", "pi", "se", "or", "sd", "or", "a", "tuple", "with", "a", "method", "name", "and", "a", "level", "parameter", "or", "a", "function", "that", "maps", "from", "a", "vector", "to", "a", "min", "max", "interval", "boot_kws", "additional", "keywords", "are", "passed", "to", "bootstrap", "when", "error_method", "is", "ci", "self", "estimator", "estimator", "method", "level", "_validate_errorbar_arg", "errorbar", "self", "error_method", "method", "self", "error_level", "level", "self", "boot_kws", "boot_kws"], "doc_len": 105}
{"doc_id": "seaborn/_statistics.py::EstimateAggregator.__call__", "file_path": "seaborn/_statistics.py", "class_name": "EstimateAggregator", "func_name": "__call__", "text": "文件路径: seaborn/_statistics.py, 类名: EstimateAggregator\n    def __call__(self, data, var):\n        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"\n        vals = data[var]\n        if callable(self.estimator):\n            # You would think we could pass to vals.agg, and yet:\n            # https://github.com/mwaskom/seaborn/issues/2943\n            estimate = self.estimator(vals)\n        else:\n            estimate = vals.agg(self.estimator)\n\n        # Options that produce no error bars\n        if self.error_method is None:\n            err_min = err_max = np.nan\n        elif len(data) <= 1:\n            err_min = err_max = np.nan\n\n        # Generic errorbars from user-supplied function\n        elif callable(self.error_method):\n            err_min, err_max = self.error_method(vals)\n\n        # Parametric options\n        elif self.error_method == \"sd\":\n            half_interval = vals.std() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n        elif self.error_method == \"se\":\n            half_interval = vals.sem() * self.error_level\n            err_min, err_max = estimate - half_interval, estimate + half_interval\n\n        # Nonparametric options\n        elif self.error_method == \"pi\":\n            err_min, err_max = _percentile_interval(vals, self.error_level)\n        elif self.error_method == \"ci\":\n            units = data.get(\"units\", None)\n            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)\n            err_min, err_max = _percentile_interval(boots, self.error_level)\n\n        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})\n", "tokens": ["seaborn", "_statistics", "py", "estimateaggregator", "def", "__call__", "self", "data", "var", "aggregate", "over", "var", "column", "of", "data", "with", "estimate", "and", "error", "interval", "vals", "data", "var", "if", "callable", "self", "estimator", "you", "would", "think", "we", "could", "pass", "to", "vals", "agg", "and", "yet", "https", "github", "com", "mwaskom", "seaborn", "issues", "2943", "estimate", "self", "estimator", "vals", "else", "estimate", "vals", "agg", "self", "estimator", "options", "that", "produce", "no", "error", "bars", "if", "self", "error_method", "is", "none", "err_min", "err_max", "np", "nan", "elif", "len", "data", "1", "err_min", "err_max", "np", "nan", "generic", "errorbars", "from", "user", "supplied", "function", "elif", "callable", "self", "error_method", "err_min", "err_max", "self", "error_method", "vals", "parametric", "options", "elif", "self", "error_method", "sd", "half_interval", "vals", "std", "self", "error_level", "err_min", "err_max", "estimate", "half_interval", "estimate", "half_interval", "elif", "self", "error_method", "se", "half_interval", "vals", "sem", "self", "error_level", "err_min", "err_max", "estimate", "half_interval", "estimate", "half_interval", "nonparametric", "options", "elif", "self", "error_method", "pi", "err_min", "err_max", "_percentile_interval", "vals", "self", "error_level", "elif", "self", "error_method", "ci", "units", "data", "get", "units", "none", "boots", "bootstrap", "vals", "units", "units", "func", "self", "estimator", "self", "boot_kws", "err_min", "err_max", "_percentile_interval", "boots", "self", "error_level", "return", "pd", "series", "var", "estimate", "f", "var", "min", "err_min", "f", "var", "max", "err_max"], "doc_len": 175}
{"doc_id": "seaborn/_statistics.py::_percentile_interval", "file_path": "seaborn/_statistics.py", "class_name": null, "func_name": "_percentile_interval", "text": "文件路径: seaborn/_statistics.py\ndef _percentile_interval(data, width):\n    \"\"\"Return a percentile interval from data of a given width.\"\"\"\n    edge = (100 - width) / 2\n    percentiles = edge, 100 - edge\n    return np.nanpercentile(data, percentiles)\n", "tokens": ["seaborn", "_statistics", "py", "def", "_percentile_interval", "data", "width", "return", "a", "percentile", "interval", "from", "data", "of", "a", "given", "width", "edge", "100", "width", "2", "percentiles", "edge", "100", "edge", "return", "np", "nanpercentile", "data", "percentiles"], "doc_len": 30}
{"doc_id": "seaborn/_statistics.py::_validate_errorbar_arg", "file_path": "seaborn/_statistics.py", "class_name": null, "func_name": "_validate_errorbar_arg", "text": "文件路径: seaborn/_statistics.py\ndef _validate_errorbar_arg(arg):\n    \"\"\"Check type and value of errorbar argument and assign default level.\"\"\"\n    DEFAULT_LEVELS = {\n        \"ci\": 95,\n        \"pi\": 95,\n        \"se\": 1,\n        \"sd\": 1,\n    }\n\n    usage = \"`errorbar` must be a callable, string, or (string, number) tuple\"\n\n    if arg is None:\n        return None, None\n    elif callable(arg):\n        return arg, None\n    elif isinstance(arg, str):\n        method = arg\n        level = DEFAULT_LEVELS.get(method, None)\n    else:\n        try:\n            method, level = arg\n        except (ValueError, TypeError) as err:\n            raise err.__class__(usage) from err\n\n    _check_argument(\"errorbar\", list(DEFAULT_LEVELS), method)\n    if level is not None and not isinstance(level, Number):\n        raise TypeError(usage)\n\n    return method, level\n", "tokens": ["seaborn", "_statistics", "py", "def", "_validate_errorbar_arg", "arg", "check", "type", "and", "value", "of", "errorbar", "argument", "and", "assign", "default", "level", "default_levels", "ci", "95", "pi", "95", "se", "1", "sd", "1", "usage", "errorbar", "must", "be", "a", "callable", "string", "or", "string", "number", "tuple", "if", "arg", "is", "none", "return", "none", "none", "elif", "callable", "arg", "return", "arg", "none", "elif", "isinstance", "arg", "str", "method", "arg", "level", "default_levels", "get", "method", "none", "else", "try", "method", "level", "arg", "except", "valueerror", "typeerror", "as", "err", "raise", "err", "__class__", "usage", "from", "err", "_check_argument", "errorbar", "list", "default_levels", "method", "if", "level", "is", "not", "none", "and", "not", "isinstance", "level", "number", "raise", "typeerror", "usage", "return", "method", "level"], "doc_len": 98}
{"doc_id": "seaborn/_testing.py::assert_artists_equal", "file_path": "seaborn/_testing.py", "class_name": null, "func_name": "assert_artists_equal", "text": "文件路径: seaborn/_testing.py\ndef assert_artists_equal(list1, list2):\n\n    assert len(list1) == len(list2)\n    for a1, a2 in zip(list1, list2):\n        assert a1.__class__ == a2.__class__\n        prop1 = a1.properties()\n        prop2 = a2.properties()\n        for key in USE_PROPS:\n            if key not in prop1:\n                continue\n            v1 = prop1[key]\n            v2 = prop2[key]\n            if key == \"paths\":\n                for p1, p2 in zip(v1, v2):\n                    assert_array_equal(p1.vertices, p2.vertices)\n                    assert_array_equal(p1.codes, p2.codes)\n            elif key == \"color\":\n                v1 = mpl.colors.to_rgba(v1)\n                v2 = mpl.colors.to_rgba(v2)\n                assert v1 == v2\n            elif isinstance(v1, np.ndarray):\n                assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n", "tokens": ["seaborn", "_testing", "py", "def", "assert_artists_equal", "list1", "list2", "assert", "len", "list1", "len", "list2", "for", "a1", "a2", "in", "zip", "list1", "list2", "assert", "a1", "__class__", "a2", "__class__", "prop1", "a1", "properties", "prop2", "a2", "properties", "for", "key", "in", "use_props", "if", "key", "not", "in", "prop1", "continue", "v1", "prop1", "key", "v2", "prop2", "key", "if", "key", "paths", "for", "p1", "p2", "in", "zip", "v1", "v2", "assert_array_equal", "p1", "vertices", "p2", "vertices", "assert_array_equal", "p1", "codes", "p2", "codes", "elif", "key", "color", "v1", "mpl", "colors", "to_rgba", "v1", "v2", "mpl", "colors", "to_rgba", "v2", "assert", "v1", "v2", "elif", "isinstance", "v1", "np", "ndarray", "assert_array_equal", "v1", "v2", "else", "assert", "v1", "v2"], "doc_len": 94}
{"doc_id": "seaborn/_testing.py::assert_legends_equal", "file_path": "seaborn/_testing.py", "class_name": null, "func_name": "assert_legends_equal", "text": "文件路径: seaborn/_testing.py\ndef assert_legends_equal(leg1, leg2):\n\n    assert leg1.get_title().get_text() == leg2.get_title().get_text()\n    for t1, t2 in zip(leg1.get_texts(), leg2.get_texts()):\n        assert t1.get_text() == t2.get_text()\n\n    assert_artists_equal(\n        leg1.get_patches(), leg2.get_patches(),\n    )\n    assert_artists_equal(\n        leg1.get_lines(), leg2.get_lines(),\n    )\n", "tokens": ["seaborn", "_testing", "py", "def", "assert_legends_equal", "leg1", "leg2", "assert", "leg1", "get_title", "get_text", "leg2", "get_title", "get_text", "for", "t1", "t2", "in", "zip", "leg1", "get_texts", "leg2", "get_texts", "assert", "t1", "get_text", "t2", "get_text", "assert_artists_equal", "leg1", "get_patches", "leg2", "get_patches", "assert_artists_equal", "leg1", "get_lines", "leg2", "get_lines"], "doc_len": 38}
{"doc_id": "seaborn/_testing.py::assert_plots_equal", "file_path": "seaborn/_testing.py", "class_name": null, "func_name": "assert_plots_equal", "text": "文件路径: seaborn/_testing.py\ndef assert_plots_equal(ax1, ax2, labels=True):\n\n    assert_artists_equal(ax1.patches, ax2.patches)\n    assert_artists_equal(ax1.lines, ax2.lines)\n    assert_artists_equal(ax1.collections, ax2.collections)\n\n    if labels:\n        assert ax1.get_xlabel() == ax2.get_xlabel()\n        assert ax1.get_ylabel() == ax2.get_ylabel()\n", "tokens": ["seaborn", "_testing", "py", "def", "assert_plots_equal", "ax1", "ax2", "labels", "true", "assert_artists_equal", "ax1", "patches", "ax2", "patches", "assert_artists_equal", "ax1", "lines", "ax2", "lines", "assert_artists_equal", "ax1", "collections", "ax2", "collections", "if", "labels", "assert", "ax1", "get_xlabel", "ax2", "get_xlabel", "assert", "ax1", "get_ylabel", "ax2", "get_ylabel"], "doc_len": 36}
{"doc_id": "seaborn/_testing.py::assert_colors_equal", "file_path": "seaborn/_testing.py", "class_name": null, "func_name": "assert_colors_equal", "text": "文件路径: seaborn/_testing.py\ndef assert_colors_equal(a, b, check_alpha=True):\n\n    def handle_array(x):\n\n        if isinstance(x, np.ndarray):\n            if x.ndim > 1:\n                x = np.unique(x, axis=0).squeeze()\n            if x.ndim > 1:\n                raise ValueError(\"Color arrays must be 1 dimensional\")\n        return x\n\n    a = handle_array(a)\n    b = handle_array(b)\n\n    f = to_rgba if check_alpha else to_rgb\n    assert f(a) == f(b)\n", "tokens": ["seaborn", "_testing", "py", "def", "assert_colors_equal", "a", "b", "check_alpha", "true", "def", "handle_array", "x", "if", "isinstance", "x", "np", "ndarray", "if", "x", "ndim", "1", "x", "np", "unique", "x", "axis", "0", "squeeze", "if", "x", "ndim", "1", "raise", "valueerror", "color", "arrays", "must", "be", "1", "dimensional", "return", "x", "a", "handle_array", "a", "b", "handle_array", "b", "f", "to_rgba", "if", "check_alpha", "else", "to_rgb", "assert", "f", "a", "f", "b"], "doc_len": 59}
{"doc_id": "seaborn/external/appdirs.py::user_cache_dir", "file_path": "seaborn/external/appdirs.py", "class_name": null, "func_name": "user_cache_dir", "text": "文件路径: seaborn/external/appdirs.py\ndef user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):\n    r\"\"\"Return full path to the user-specific cache dir for this application.\n\n        \"appname\" is the name of application.\n            If None, just the system directory is returned.\n        \"appauthor\" (only used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname. You may\n            pass False to disable it.\n        \"version\" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be \"<major>.<minor>\".\n            Only applied when appname is present.\n        \"opinion\" (boolean) can be False to disable the appending of\n            \"Cache\" to the base app data dir for Windows. See\n            discussion below.\n\n    Typical user cache directories are:\n        Mac OS X:   ~/Library/Caches/<AppName>\n        Unix:       ~/.cache/<AppName> (XDG default)\n        Win XP:     C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\<AppAuthor>\\<AppName>\\Cache\n        Vista:      C:\\Users\\<username>\\AppData\\Local\\<AppAuthor>\\<AppName>\\Cache\n\n    On Windows the only suggestion in the MSDN docs is that local settings go in\n    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming\n    app data dir (the default returned by `user_data_dir` above). Apps typically\n    put cache data somewhere *under* the given dir here. Some examples:\n        ...\\Mozilla\\Firefox\\Profiles\\<ProfileName>\\Cache\n        ...\\Acme\\SuperApp\\Cache\\1.0\n    OPINION: This function appends \"Cache\" to the `CSIDL_LOCAL_APPDATA` value.\n    This can be disabled with the `opinion=False` option.\n    \"\"\"\n    if system == \"win32\":\n        if appauthor is None:\n            appauthor = appname\n        path = os.path.normpath(_get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        if appname:\n            if appauthor is not False:\n                path = os.path.join(path, appauthor, appname)\n            else:\n                path = os.path.join(path, appname)\n            if opinion:\n                path = os.path.join(path, \"Cache\")\n    elif system == 'darwin':\n        path = os.path.expanduser('~/Library/Caches')\n        if appname:\n            path = os.path.join(path, appname)\n    else:\n        path = os.getenv('XDG_CACHE_HOME', os.path.expanduser('~/.cache'))\n        if appname:\n            path = os.path.join(path, appname)\n    if appname and version:\n        path = os.path.join(path, version)\n    return path\n", "tokens": ["seaborn", "external", "appdirs", "py", "def", "user_cache_dir", "appname", "none", "appauthor", "none", "version", "none", "opinion", "true", "r", "return", "full", "path", "to", "the", "user", "specific", "cache", "dir", "for", "this", "application", "appname", "is", "the", "name", "of", "application", "if", "none", "just", "the", "system", "directory", "is", "returned", "appauthor", "only", "used", "on", "windows", "is", "the", "name", "of", "the", "appauthor", "or", "distributing", "body", "for", "this", "application", "typically", "it", "is", "the", "owning", "company", "name", "this", "falls", "back", "to", "appname", "you", "may", "pass", "false", "to", "disable", "it", "version", "is", "an", "optional", "version", "path", "element", "to", "append", "to", "the", "path", "you", "might", "want", "to", "use", "this", "if", "you", "want", "multiple", "versions", "of", "your", "app", "to", "be", "able", "to", "run", "independently", "if", "used", "this", "would", "typically", "be", "major", "minor", "only", "applied", "when", "appname", "is", "present", "opinion", "boolean", "can", "be", "false", "to", "disable", "the", "appending", "of", "cache", "to", "the", "base", "app", "data", "dir", "for", "windows", "see", "discussion", "below", "typical", "user", "cache", "directories", "are", "mac", "os", "x", "library", "caches", "appname", "unix", "cache", "appname", "xdg", "default", "win", "xp", "c", "documents", "and", "settings", "username", "local", "settings", "application", "data", "appauthor", "appname", "cache", "vista", "c", "users", "username", "appdata", "local", "appauthor", "appname", "cache", "on", "windows", "the", "only", "suggestion", "in", "the", "msdn", "docs", "is", "that", "local", "settings", "go", "in", "the", "csidl_local_appdata", "directory", "this", "is", "identical", "to", "the", "non", "roaming", "app", "data", "dir", "the", "default", "returned", "by", "user_data_dir", "above", "apps", "typically", "put", "cache", "data", "somewhere", "under", "the", "given", "dir", "here", "some", "examples", "mozilla", "firefox", "profiles", "profilename", "cache", "acme", "superapp", "cache", "1", "0", "opinion", "this", "function", "appends", "cache", "to", "the", "csidl_local_appdata", "value", "this", "can", "be", "disabled", "with", "the", "opinion", "false", "option", "if", "system", "win32", "if", "appauthor", "is", "none", "appauthor", "appname", "path", "os", "path", "normpath", "_get_win_folder", "csidl_local_appdata", "if", "appname", "if", "appauthor", "is", "not", "false", "path", "os", "path", "join", "path", "appauthor", "appname", "else", "path", "os", "path", "join", "path", "appname", "if", "opinion", "path", "os", "path", "join", "path", "cache", "elif", "system", "darwin", "path", "os", "path", "expanduser", "library", "caches", "if", "appname", "path", "os", "path", "join", "path", "appname", "else", "path", "os", "getenv", "xdg_cache_home", "os", "path", "expanduser", "cache", "if", "appname", "path", "os", "path", "join", "path", "appname", "if", "appname", "and", "version", "path", "os", "path", "join", "path", "version", "return", "path"], "doc_len": 349}
{"doc_id": "seaborn/external/appdirs.py::_get_win_folder_from_registry", "file_path": "seaborn/external/appdirs.py", "class_name": null, "func_name": "_get_win_folder_from_registry", "text": "文件路径: seaborn/external/appdirs.py\ndef _get_win_folder_from_registry(csidl_name):\n    \"\"\"This is a fallback technique at best. I'm not sure if using the\n    registry for this guarantees us the correct answer for all CSIDL_*\n    names.\n    \"\"\"\n    import winreg as _winreg\n\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n    }[csidl_name]\n\n    key = _winreg.OpenKey(\n        _winreg.HKEY_CURRENT_USER,\n        r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\"\n    )\n    dir, type = _winreg.QueryValueEx(key, shell_folder_name)\n    return dir\n", "tokens": ["seaborn", "external", "appdirs", "py", "def", "_get_win_folder_from_registry", "csidl_name", "this", "is", "a", "fallback", "technique", "at", "best", "i", "m", "not", "sure", "if", "using", "the", "registry", "for", "this", "guarantees", "us", "the", "correct", "answer", "for", "all", "csidl_", "names", "import", "winreg", "as", "_winreg", "shell_folder_name", "csidl_appdata", "appdata", "csidl_common_appdata", "common", "appdata", "csidl_local_appdata", "local", "appdata", "csidl_name", "key", "_winreg", "openkey", "_winreg", "hkey_current_user", "r", "software", "microsoft", "windows", "currentversion", "explorer", "shell", "folders", "dir", "type", "_winreg", "queryvalueex", "key", "shell_folder_name", "return", "dir"], "doc_len": 68}
{"doc_id": "seaborn/external/appdirs.py::_get_win_folder_with_pywin32", "file_path": "seaborn/external/appdirs.py", "class_name": null, "func_name": "_get_win_folder_with_pywin32", "text": "文件路径: seaborn/external/appdirs.py\ndef _get_win_folder_with_pywin32(csidl_name):\n    from win32com.shell import shellcon, shell\n    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)\n    # Try to make this a unicode path because SHGetFolderPath does\n    # not return unicode strings when there is unicode data in the\n    # path.\n    try:\n        dir = unicode(dir)\n\n        # Downgrade to short path name if have highbit chars. See\n        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n        has_high_char = False\n        for c in dir:\n            if ord(c) > 255:\n                has_high_char = True\n                break\n        if has_high_char:\n            try:\n                import win32api\n                dir = win32api.GetShortPathName(dir)\n            except ImportError:\n                pass\n    except UnicodeError:\n        pass\n    return dir\n", "tokens": ["seaborn", "external", "appdirs", "py", "def", "_get_win_folder_with_pywin32", "csidl_name", "from", "win32com", "shell", "import", "shellcon", "shell", "dir", "shell", "shgetfolderpath", "0", "getattr", "shellcon", "csidl_name", "0", "0", "try", "to", "make", "this", "a", "unicode", "path", "because", "shgetfolderpath", "does", "not", "return", "unicode", "strings", "when", "there", "is", "unicode", "data", "in", "the", "path", "try", "dir", "unicode", "dir", "downgrade", "to", "short", "path", "name", "if", "have", "highbit", "chars", "see", "http", "bugs", "activestate", "com", "show_bug", "cgi", "id", "85099", "has_high_char", "false", "for", "c", "in", "dir", "if", "ord", "c", "255", "has_high_char", "true", "break", "if", "has_high_char", "try", "import", "win32api", "dir", "win32api", "getshortpathname", "dir", "except", "importerror", "pass", "except", "unicodeerror", "pass", "return", "dir"], "doc_len": 96}
{"doc_id": "seaborn/external/appdirs.py::_get_win_folder_with_ctypes", "file_path": "seaborn/external/appdirs.py", "class_name": null, "func_name": "_get_win_folder_with_ctypes", "text": "文件路径: seaborn/external/appdirs.py\ndef _get_win_folder_with_ctypes(csidl_name):\n    import ctypes\n\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n    }[csidl_name]\n\n    buf = ctypes.create_unicode_buffer(1024)\n    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if have highbit chars. See\n    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n    has_high_char = False\n    for c in buf:\n        if ord(c) > 255:\n            has_high_char = True\n            break\n    if has_high_char:\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    return buf.value\n", "tokens": ["seaborn", "external", "appdirs", "py", "def", "_get_win_folder_with_ctypes", "csidl_name", "import", "ctypes", "csidl_const", "csidl_appdata", "26", "csidl_common_appdata", "35", "csidl_local_appdata", "28", "csidl_name", "buf", "ctypes", "create_unicode_buffer", "1024", "ctypes", "windll", "shell32", "shgetfolderpathw", "none", "csidl_const", "none", "0", "buf", "downgrade", "to", "short", "path", "name", "if", "have", "highbit", "chars", "see", "http", "bugs", "activestate", "com", "show_bug", "cgi", "id", "85099", "has_high_char", "false", "for", "c", "in", "buf", "if", "ord", "c", "255", "has_high_char", "true", "break", "if", "has_high_char", "buf2", "ctypes", "create_unicode_buffer", "1024", "if", "ctypes", "windll", "kernel32", "getshortpathnamew", "buf", "value", "buf2", "1024", "buf", "buf2", "return", "buf", "value"], "doc_len": 81}
{"doc_id": "seaborn/external/appdirs.py::_get_win_folder_with_jna", "file_path": "seaborn/external/appdirs.py", "class_name": null, "func_name": "_get_win_folder_with_jna", "text": "文件路径: seaborn/external/appdirs.py\ndef _get_win_folder_with_jna(csidl_name):\n    import array\n    from com.sun import jna\n    from com.sun.jna.platform import win32\n\n    buf_size = win32.WinDef.MAX_PATH * 2\n    buf = array.zeros('c', buf_size)\n    shell = win32.Shell32.INSTANCE\n    shell.SHGetFolderPath(None, getattr(win32.ShlObj, csidl_name), None, win32.ShlObj.SHGFP_TYPE_CURRENT, buf)\n    dir = jna.Native.toString(buf.tostring()).rstrip(\"\\0\")\n\n    # Downgrade to short path name if have highbit chars. See\n    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n    has_high_char = False\n    for c in dir:\n        if ord(c) > 255:\n            has_high_char = True\n            break\n    if has_high_char:\n        buf = array.zeros('c', buf_size)\n        kernel = win32.Kernel32.INSTANCE\n        if kernel.GetShortPathName(dir, buf, buf_size):\n            dir = jna.Native.toString(buf.tostring()).rstrip(\"\\0\")\n\n    return dir\n", "tokens": ["seaborn", "external", "appdirs", "py", "def", "_get_win_folder_with_jna", "csidl_name", "import", "array", "from", "com", "sun", "import", "jna", "from", "com", "sun", "jna", "platform", "import", "win32", "buf_size", "win32", "windef", "max_path", "2", "buf", "array", "zeros", "c", "buf_size", "shell", "win32", "shell32", "instance", "shell", "shgetfolderpath", "none", "getattr", "win32", "shlobj", "csidl_name", "none", "win32", "shlobj", "shgfp_type_current", "buf", "dir", "jna", "native", "tostring", "buf", "tostring", "rstrip", "0", "downgrade", "to", "short", "path", "name", "if", "have", "highbit", "chars", "see", "http", "bugs", "activestate", "com", "show_bug", "cgi", "id", "85099", "has_high_char", "false", "for", "c", "in", "dir", "if", "ord", "c", "255", "has_high_char", "true", "break", "if", "has_high_char", "buf", "array", "zeros", "c", "buf_size", "kernel", "win32", "kernel32", "instance", "if", "kernel", "getshortpathname", "dir", "buf", "buf_size", "dir", "jna", "native", "tostring", "buf", "tostring", "rstrip", "0", "return", "dir"], "doc_len": 113}
{"doc_id": "seaborn/external/docscrape.py::strip_blank_lines", "file_path": "seaborn/external/docscrape.py", "class_name": null, "func_name": "strip_blank_lines", "text": "文件路径: seaborn/external/docscrape.py\ndef strip_blank_lines(l):\n    \"Remove leading and trailing blank lines from a list of lines\"\n    while l and not l[0].strip():\n        del l[0]\n    while l and not l[-1].strip():\n        del l[-1]\n    return l\n", "tokens": ["seaborn", "external", "docscrape", "py", "def", "strip_blank_lines", "l", "remove", "leading", "and", "trailing", "blank", "lines", "from", "a", "list", "of", "lines", "while", "l", "and", "not", "l", "0", "strip", "del", "l", "0", "while", "l", "and", "not", "l", "1", "strip", "del", "l", "1", "return", "l"], "doc_len": 40}
{"doc_id": "seaborn/external/docscrape.py::Reader.__init__", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "__init__", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def __init__(self, data):\n        \"\"\"\n        Parameters\n        ----------\n        data : str\n           String with lines separated by '\\n'.\n\n        \"\"\"\n        if isinstance(data, list):\n            self._str = data\n        else:\n            self._str = data.split('\\n')  # store string as list of lines\n\n        self.reset()\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "__init__", "self", "data", "parameters", "data", "str", "string", "with", "lines", "separated", "by", "n", "if", "isinstance", "data", "list", "self", "_str", "data", "else", "self", "_str", "data", "split", "n", "store", "string", "as", "list", "of", "lines", "self", "reset"], "doc_len": 39}
{"doc_id": "seaborn/external/docscrape.py::Reader.__getitem__", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "__getitem__", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def __getitem__(self, n):\n        return self._str[n]\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "__getitem__", "self", "n", "return", "self", "_str", "n"], "doc_len": 13}
{"doc_id": "seaborn/external/docscrape.py::Reader.reset", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "reset", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def reset(self):\n        self._l = 0  # current line nr\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "reset", "self", "self", "_l", "0", "current", "line", "nr"], "doc_len": 14}
{"doc_id": "seaborn/external/docscrape.py::Reader.read", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "read", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def read(self):\n        if not self.eof():\n            out = self[self._l]\n            self._l += 1\n            return out\n        else:\n            return ''\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "read", "self", "if", "not", "self", "eof", "out", "self", "self", "_l", "self", "_l", "1", "return", "out", "else", "return"], "doc_len": 23}
{"doc_id": "seaborn/external/docscrape.py::Reader.seek_next_non_empty_line", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "seek_next_non_empty_line", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def seek_next_non_empty_line(self):\n        for l in self[self._l:]:\n            if l.strip():\n                break\n            else:\n                self._l += 1\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "seek_next_non_empty_line", "self", "for", "l", "in", "self", "self", "_l", "if", "l", "strip", "break", "else", "self", "_l", "1"], "doc_len": 22}
{"doc_id": "seaborn/external/docscrape.py::Reader.eof", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "eof", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def eof(self):\n        return self._l >= len(self._str)\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "eof", "self", "return", "self", "_l", "len", "self", "_str"], "doc_len": 14}
{"doc_id": "seaborn/external/docscrape.py::Reader.read_to_condition", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "read_to_condition", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def read_to_condition(self, condition_func):\n        start = self._l\n        for line in self[start:]:\n            if condition_func(line):\n                return self[start:self._l]\n            self._l += 1\n            if self.eof():\n                return self[start:self._l+1]\n        return []\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "read_to_condition", "self", "condition_func", "start", "self", "_l", "for", "line", "in", "self", "start", "if", "condition_func", "line", "return", "self", "start", "self", "_l", "self", "_l", "1", "if", "self", "eof", "return", "self", "start", "self", "_l", "1", "return"], "doc_len": 38}
{"doc_id": "seaborn/external/docscrape.py::Reader.read_to_next_empty_line", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "read_to_next_empty_line", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def read_to_next_empty_line(self):\n        self.seek_next_non_empty_line()\n\n        def is_empty(line):\n            return not line.strip()\n\n        return self.read_to_condition(is_empty)\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "read_to_next_empty_line", "self", "self", "seek_next_non_empty_line", "def", "is_empty", "line", "return", "not", "line", "strip", "return", "self", "read_to_condition", "is_empty"], "doc_len": 21}
{"doc_id": "seaborn/external/docscrape.py::Reader.read_to_next_unindented_line", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "read_to_next_unindented_line", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def read_to_next_unindented_line(self):\n        def is_unindented(line):\n            return (line.strip() and (len(line.lstrip()) == len(line)))\n        return self.read_to_condition(is_unindented)\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "read_to_next_unindented_line", "self", "def", "is_unindented", "line", "return", "line", "strip", "and", "len", "line", "lstrip", "len", "line", "return", "self", "read_to_condition", "is_unindented"], "doc_len": 24}
{"doc_id": "seaborn/external/docscrape.py::Reader.peek", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "peek", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def peek(self, n=0):\n        if self._l + n < len(self._str):\n            return self[self._l + n]\n        else:\n            return ''\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "peek", "self", "n", "0", "if", "self", "_l", "n", "len", "self", "_str", "return", "self", "self", "_l", "n", "else", "return"], "doc_len": 24}
{"doc_id": "seaborn/external/docscrape.py::Reader.is_empty", "file_path": "seaborn/external/docscrape.py", "class_name": "Reader", "func_name": "is_empty", "text": "文件路径: seaborn/external/docscrape.py, 类名: Reader\n    def is_empty(self):\n        return not ''.join(self._str).strip()\n", "tokens": ["seaborn", "external", "docscrape", "py", "reader", "def", "is_empty", "self", "return", "not", "join", "self", "_str", "strip"], "doc_len": 14}
{"doc_id": "seaborn/external/docscrape.py::ParseError.__str__", "file_path": "seaborn/external/docscrape.py", "class_name": "ParseError", "func_name": "__str__", "text": "文件路径: seaborn/external/docscrape.py, 类名: ParseError\n    def __str__(self):\n        message = self.args[0]\n        if hasattr(self, 'docstring'):\n            message = f\"{message} in {self.docstring!r}\"\n        return message\n", "tokens": ["seaborn", "external", "docscrape", "py", "parseerror", "def", "__str__", "self", "message", "self", "args", "0", "if", "hasattr", "self", "docstring", "message", "f", "message", "in", "self", "docstring", "r", "return", "message"], "doc_len": 25}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__init__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__init__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __init__(self, docstring, config={}):\n        orig_docstring = docstring\n        docstring = textwrap.dedent(docstring).split('\\n')\n\n        self._doc = Reader(docstring)\n        self._parsed_data = copy.deepcopy(self.sections)\n\n        try:\n            self._parse()\n        except ParseError as e:\n            e.docstring = orig_docstring\n            raise\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__init__", "self", "docstring", "config", "orig_docstring", "docstring", "docstring", "textwrap", "dedent", "docstring", "split", "n", "self", "_doc", "reader", "docstring", "self", "_parsed_data", "copy", "deepcopy", "self", "sections", "try", "self", "_parse", "except", "parseerror", "as", "e", "e", "docstring", "orig_docstring", "raise"], "doc_len": 39}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__getitem__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__getitem__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __getitem__(self, key):\n        return self._parsed_data[key]\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__getitem__", "self", "key", "return", "self", "_parsed_data", "key"], "doc_len": 13}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__setitem__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__setitem__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __setitem__(self, key, val):\n        if key not in self._parsed_data:\n            self._error_location(f\"Unknown section {key}\", error=False)\n        else:\n            self._parsed_data[key] = val\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__setitem__", "self", "key", "val", "if", "key", "not", "in", "self", "_parsed_data", "self", "_error_location", "f", "unknown", "section", "key", "error", "false", "else", "self", "_parsed_data", "key", "val"], "doc_len": 29}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__iter__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__iter__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __iter__(self):\n        return iter(self._parsed_data)\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__iter__", "self", "return", "iter", "self", "_parsed_data"], "doc_len": 12}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__len__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__len__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __len__(self):\n        return len(self._parsed_data)\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__len__", "self", "return", "len", "self", "_parsed_data"], "doc_len": 12}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._is_at_section", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_is_at_section", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _is_at_section(self):\n        self._doc.seek_next_non_empty_line()\n\n        if self._doc.eof():\n            return False\n\n        l1 = self._doc.peek().strip()  # e.g. Parameters\n\n        if l1.startswith('.. index::'):\n            return True\n\n        l2 = self._doc.peek(1).strip()  # ---------- or ==========\n        return l2.startswith('-'*len(l1)) or l2.startswith('='*len(l1))\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_is_at_section", "self", "self", "_doc", "seek_next_non_empty_line", "if", "self", "_doc", "eof", "return", "false", "l1", "self", "_doc", "peek", "strip", "e", "g", "parameters", "if", "l1", "startswith", "index", "return", "true", "l2", "self", "_doc", "peek", "1", "strip", "or", "return", "l2", "startswith", "len", "l1", "or", "l2", "startswith", "len", "l1"], "doc_len": 48}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._strip", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_strip", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _strip(self, doc):\n        i = 0\n        j = 0\n        for i, line in enumerate(doc):\n            if line.strip():\n                break\n\n        for j, line in enumerate(doc[::-1]):\n            if line.strip():\n                break\n\n        return doc[i:len(doc)-j]\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_strip", "self", "doc", "i", "0", "j", "0", "for", "i", "line", "in", "enumerate", "doc", "if", "line", "strip", "break", "for", "j", "line", "in", "enumerate", "doc", "1", "if", "line", "strip", "break", "return", "doc", "i", "len", "doc", "j"], "doc_len": 40}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._read_to_next_section", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_read_to_next_section", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _read_to_next_section(self):\n        section = self._doc.read_to_next_empty_line()\n\n        while not self._is_at_section() and not self._doc.eof():\n            if not self._doc.peek(-1).strip():  # previous line was empty\n                section += ['']\n\n            section += self._doc.read_to_next_empty_line()\n\n        return section\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_read_to_next_section", "self", "section", "self", "_doc", "read_to_next_empty_line", "while", "not", "self", "_is_at_section", "and", "not", "self", "_doc", "eof", "if", "not", "self", "_doc", "peek", "1", "strip", "previous", "line", "was", "empty", "section", "section", "self", "_doc", "read_to_next_empty_line", "return", "section"], "doc_len": 39}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._read_sections", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_read_sections", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _read_sections(self):\n        while not self._doc.eof():\n            data = self._read_to_next_section()\n            name = data[0].strip()\n\n            if name.startswith('..'):  # index section\n                yield name, data[1:]\n            elif len(data) < 2:\n                yield StopIteration\n            else:\n                yield name, self._strip(data[2:])\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_read_sections", "self", "while", "not", "self", "_doc", "eof", "data", "self", "_read_to_next_section", "name", "data", "0", "strip", "if", "name", "startswith", "index", "section", "yield", "name", "data", "1", "elif", "len", "data", "2", "yield", "stopiteration", "else", "yield", "name", "self", "_strip", "data", "2"], "doc_len": 42}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._parse_param_list", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_parse_param_list", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _parse_param_list(self, content, single_element_is_type=False):\n        r = Reader(content)\n        params = []\n        while not r.eof():\n            header = r.read().strip()\n            if ' : ' in header:\n                arg_name, arg_type = header.split(' : ')[:2]\n            else:\n                if single_element_is_type:\n                    arg_name, arg_type = '', header\n                else:\n                    arg_name, arg_type = header, ''\n\n            desc = r.read_to_next_unindented_line()\n            desc = dedent_lines(desc)\n            desc = strip_blank_lines(desc)\n\n            params.append(Parameter(arg_name, arg_type, desc))\n\n        return params\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_parse_param_list", "self", "content", "single_element_is_type", "false", "r", "reader", "content", "params", "while", "not", "r", "eof", "header", "r", "read", "strip", "if", "in", "header", "arg_name", "arg_type", "header", "split", "2", "else", "if", "single_element_is_type", "arg_name", "arg_type", "header", "else", "arg_name", "arg_type", "header", "desc", "r", "read_to_next_unindented_line", "desc", "dedent_lines", "desc", "desc", "strip_blank_lines", "desc", "params", "append", "parameter", "arg_name", "arg_type", "desc", "return", "params"], "doc_len": 58}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._parse_see_also", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_parse_see_also", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _parse_see_also(self, content):\n        \"\"\"\n        func_name : Descriptive text\n            continued text\n        another_func_name : Descriptive text\n        func_name1, func_name2, :meth:`func_name`, func_name3\n\n        \"\"\"\n\n        items = []\n\n        def parse_item_name(text):\n            \"\"\"Match ':role:`name`' or 'name'.\"\"\"\n            m = self._func_rgx.match(text)\n            if not m:\n                raise ParseError(f\"{text} is not a item name\")\n            role = m.group('role')\n            name = m.group('name') if role else m.group('name2')\n            return name, role, m.end()\n\n        rest = []\n        for line in content:\n            if not line.strip():\n                continue\n\n            line_match = self._line_rgx.match(line)\n            description = None\n            if line_match:\n                description = line_match.group('desc')\n                if line_match.group('trailing') and description:\n                    self._error_location(\n                        'Unexpected comma or period after function list at index %d of '\n                        'line \"%s\"' % (line_match.end('trailing'), line),\n                        error=False)\n            if not description and line.startswith(' '):\n                rest.append(line.strip())\n            elif line_match:\n                funcs = []\n                text = line_match.group('allfuncs')\n                while True:\n                    if not text.strip():\n                        break\n                    name, role, match_end = parse_item_name(text)\n                    funcs.append((name, role))\n                    text = text[match_end:].strip()\n                    if text and text[0] == ',':\n                        text = text[1:].strip()\n                rest = list(filter(None, [description]))\n                items.append((funcs, rest))\n            else:\n                raise ParseError(f\"{line} is not a item name\")\n        return items\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_parse_see_also", "self", "content", "func_name", "descriptive", "text", "continued", "text", "another_func_name", "descriptive", "text", "func_name1", "func_name2", "meth", "func_name", "func_name3", "items", "def", "parse_item_name", "text", "match", "role", "name", "or", "name", "m", "self", "_func_rgx", "match", "text", "if", "not", "m", "raise", "parseerror", "f", "text", "is", "not", "a", "item", "name", "role", "m", "group", "role", "name", "m", "group", "name", "if", "role", "else", "m", "group", "name2", "return", "name", "role", "m", "end", "rest", "for", "line", "in", "content", "if", "not", "line", "strip", "continue", "line_match", "self", "_line_rgx", "match", "line", "description", "none", "if", "line_match", "description", "line_match", "group", "desc", "if", "line_match", "group", "trailing", "and", "description", "self", "_error_location", "unexpected", "comma", "or", "period", "after", "function", "list", "at", "index", "d", "of", "line", "s", "line_match", "end", "trailing", "line", "error", "false", "if", "not", "description", "and", "line", "startswith", "rest", "append", "line", "strip", "elif", "line_match", "funcs", "text", "line_match", "group", "allfuncs", "while", "true", "if", "not", "text", "strip", "break", "name", "role", "match_end", "parse_item_name", "text", "funcs", "append", "name", "role", "text", "text", "match_end", "strip", "if", "text", "and", "text", "0", "text", "text", "1", "strip", "rest", "list", "filter", "none", "description", "items", "append", "funcs", "rest", "else", "raise", "parseerror", "f", "line", "is", "not", "a", "item", "name", "return", "items"], "doc_len": 184}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._parse_index", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_parse_index", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _parse_index(self, section, content):\n        \"\"\"\n        .. index: default\n           :refguide: something, else, and more\n\n        \"\"\"\n        def strip_each_in(lst):\n            return [s.strip() for s in lst]\n\n        out = {}\n        section = section.split('::')\n        if len(section) > 1:\n            out['default'] = strip_each_in(section[1].split(','))[0]\n        for line in content:\n            line = line.split(':')\n            if len(line) > 2:\n                out[line[1]] = strip_each_in(line[2].split(','))\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_parse_index", "self", "section", "content", "index", "default", "refguide", "something", "else", "and", "more", "def", "strip_each_in", "lst", "return", "s", "strip", "for", "s", "in", "lst", "out", "section", "section", "split", "if", "len", "section", "1", "out", "default", "strip_each_in", "section", "1", "split", "0", "for", "line", "in", "content", "line", "line", "split", "if", "len", "line", "2", "out", "line", "1", "strip_each_in", "line", "2", "split", "return", "out"], "doc_len": 62}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._parse_summary", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_parse_summary", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _parse_summary(self):\n        \"\"\"Grab signature (if given) and summary\"\"\"\n        if self._is_at_section():\n            return\n\n        # If several signatures present, take the last one\n        while True:\n            summary = self._doc.read_to_next_empty_line()\n            summary_str = \" \".join([s.strip() for s in summary]).strip()\n            compiled = re.compile(r'^([\\w., ]+=)?\\s*[\\w\\.]+\\(.*\\)$')\n            if compiled.match(summary_str):\n                self['Signature'] = summary_str\n                if not self._is_at_section():\n                    continue\n            break\n\n        if summary is not None:\n            self['Summary'] = summary\n\n        if not self._is_at_section():\n            self['Extended Summary'] = self._read_to_next_section()\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_parse_summary", "self", "grab", "signature", "if", "given", "and", "summary", "if", "self", "_is_at_section", "return", "if", "several", "signatures", "present", "take", "the", "last", "one", "while", "true", "summary", "self", "_doc", "read_to_next_empty_line", "summary_str", "join", "s", "strip", "for", "s", "in", "summary", "strip", "compiled", "re", "compile", "r", "w", "s", "w", "if", "compiled", "match", "summary_str", "self", "signature", "summary_str", "if", "not", "self", "_is_at_section", "continue", "break", "if", "summary", "is", "not", "none", "self", "summary", "summary", "if", "not", "self", "_is_at_section", "self", "extended", "summary", "self", "_read_to_next_section"], "doc_len": 78}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._parse", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_parse", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _parse(self):\n        self._doc.reset()\n        self._parse_summary()\n\n        sections = list(self._read_sections())\n        section_names = {section for section, content in sections}\n\n        has_returns = 'Returns' in section_names\n        has_yields = 'Yields' in section_names\n        # We could do more tests, but we are not. Arbitrarily.\n        if has_returns and has_yields:\n            msg = 'Docstring contains both a Returns and Yields section.'\n            raise ValueError(msg)\n        if not has_yields and 'Receives' in section_names:\n            msg = 'Docstring contains a Receives section but not Yields.'\n            raise ValueError(msg)\n\n        for (section, content) in sections:\n            if not section.startswith('..'):\n                section = (s.capitalize() for s in section.split(' '))\n                section = ' '.join(section)\n                if self.get(section):\n                    self._error_location(f\"The section {section} appears twice\")\n\n            if section in ('Parameters', 'Other Parameters', 'Attributes',\n                           'Methods'):\n                self[section] = self._parse_param_list(content)\n            elif section in ('Returns', 'Yields', 'Raises', 'Warns', 'Receives'):\n                self[section] = self._parse_param_list(\n                    content, single_element_is_type=True)\n            elif section.startswith('.. index::'):\n                self['index'] = self._parse_index(section, content)\n            elif section == 'See Also':\n                self['See Also'] = self._parse_see_also(content)\n            else:\n                self[section] = content\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_parse", "self", "self", "_doc", "reset", "self", "_parse_summary", "sections", "list", "self", "_read_sections", "section_names", "section", "for", "section", "content", "in", "sections", "has_returns", "returns", "in", "section_names", "has_yields", "yields", "in", "section_names", "we", "could", "do", "more", "tests", "but", "we", "are", "not", "arbitrarily", "if", "has_returns", "and", "has_yields", "msg", "docstring", "contains", "both", "a", "returns", "and", "yields", "section", "raise", "valueerror", "msg", "if", "not", "has_yields", "and", "receives", "in", "section_names", "msg", "docstring", "contains", "a", "receives", "section", "but", "not", "yields", "raise", "valueerror", "msg", "for", "section", "content", "in", "sections", "if", "not", "section", "startswith", "section", "s", "capitalize", "for", "s", "in", "section", "split", "section", "join", "section", "if", "self", "get", "section", "self", "_error_location", "f", "the", "section", "section", "appears", "twice", "if", "section", "in", "parameters", "other", "parameters", "attributes", "methods", "self", "section", "self", "_parse_param_list", "content", "elif", "section", "in", "returns", "yields", "raises", "warns", "receives", "self", "section", "self", "_parse_param_list", "content", "single_element_is_type", "true", "elif", "section", "startswith", "index", "self", "index", "self", "_parse_index", "section", "content", "elif", "section", "see", "also", "self", "see", "also", "self", "_parse_see_also", "content", "else", "self", "section", "content"], "doc_len": 161}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._error_location", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_error_location", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _error_location(self, msg, error=True):\n        if hasattr(self, '_obj'):\n            # we know where the docs came from:\n            try:\n                filename = inspect.getsourcefile(self._obj)\n            except TypeError:\n                filename = None\n            msg = msg + f\" in the docstring of {self._obj} in {filename}.\"\n        if error:\n            raise ValueError(msg)\n        else:\n            warn(msg)\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_error_location", "self", "msg", "error", "true", "if", "hasattr", "self", "_obj", "we", "know", "where", "the", "docs", "came", "from", "try", "filename", "inspect", "getsourcefile", "self", "_obj", "except", "typeerror", "filename", "none", "msg", "msg", "f", "in", "the", "docstring", "of", "self", "_obj", "in", "filename", "if", "error", "raise", "valueerror", "msg", "else", "warn", "msg"], "doc_len": 51}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_header", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_header", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_header(self, name, symbol='-'):\n        return [name, len(name)*symbol]\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_header", "self", "name", "symbol", "return", "name", "len", "name", "symbol"], "doc_len": 15}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_indent", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_indent", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_indent(self, doc, indent=4):\n        out = []\n        for line in doc:\n            out += [' '*indent + line]\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_indent", "self", "doc", "indent", "4", "out", "for", "line", "in", "doc", "out", "indent", "line", "return", "out"], "doc_len": 21}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_signature", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_signature", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_signature(self):\n        if self['Signature']:\n            return [self['Signature'].replace('*', r'\\*')] + ['']\n        else:\n            return ['']\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_signature", "self", "if", "self", "signature", "return", "self", "signature", "replace", "r", "else", "return"], "doc_len": 18}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_summary", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_summary", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_summary(self):\n        if self['Summary']:\n            return self['Summary'] + ['']\n        else:\n            return []\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_summary", "self", "if", "self", "summary", "return", "self", "summary", "else", "return"], "doc_len": 16}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_extended_summary", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_extended_summary", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_extended_summary(self):\n        if self['Extended Summary']:\n            return self['Extended Summary'] + ['']\n        else:\n            return []\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_extended_summary", "self", "if", "self", "extended", "summary", "return", "self", "extended", "summary", "else", "return"], "doc_len": 18}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_param_list", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_param_list", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_param_list(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            for param in self[name]:\n                parts = []\n                if param.name:\n                    parts.append(param.name)\n                if param.type:\n                    parts.append(param.type)\n                out += [' : '.join(parts)]\n                if param.desc and ''.join(param.desc).strip():\n                    out += self._str_indent(param.desc)\n            out += ['']\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_param_list", "self", "name", "out", "if", "self", "name", "out", "self", "_str_header", "name", "for", "param", "in", "self", "name", "parts", "if", "param", "name", "parts", "append", "param", "name", "if", "param", "type", "parts", "append", "param", "type", "out", "join", "parts", "if", "param", "desc", "and", "join", "param", "desc", "strip", "out", "self", "_str_indent", "param", "desc", "out", "return", "out"], "doc_len": 56}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_section", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_section", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_section(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            out += self[name]\n            out += ['']\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_section", "self", "name", "out", "if", "self", "name", "out", "self", "_str_header", "name", "out", "self", "name", "out", "return", "out"], "doc_len": 23}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_see_also", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_see_also", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_see_also(self, func_role):\n        if not self['See Also']:\n            return []\n        out = []\n        out += self._str_header(\"See Also\")\n        out += ['']\n        last_had_desc = True\n        for funcs, desc in self['See Also']:\n            assert isinstance(funcs, list)\n            links = []\n            for func, role in funcs:\n                if role:\n                    link = f':{role}:`{func}`'\n                elif func_role:\n                    link = f':{func_role}:`{func}`'\n                else:\n                    link = f\"`{func}`_\"\n                links.append(link)\n            link = ', '.join(links)\n            out += [link]\n            if desc:\n                out += self._str_indent([' '.join(desc)])\n                last_had_desc = True\n            else:\n                last_had_desc = False\n                out += self._str_indent([self.empty_description])\n\n        if last_had_desc:\n            out += ['']\n        out += ['']\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_see_also", "self", "func_role", "if", "not", "self", "see", "also", "return", "out", "out", "self", "_str_header", "see", "also", "out", "last_had_desc", "true", "for", "funcs", "desc", "in", "self", "see", "also", "assert", "isinstance", "funcs", "list", "links", "for", "func", "role", "in", "funcs", "if", "role", "link", "f", "role", "func", "elif", "func_role", "link", "f", "func_role", "func", "else", "link", "f", "func", "_", "links", "append", "link", "link", "join", "links", "out", "link", "if", "desc", "out", "self", "_str_indent", "join", "desc", "last_had_desc", "true", "else", "last_had_desc", "false", "out", "self", "_str_indent", "self", "empty_description", "if", "last_had_desc", "out", "out", "return", "out"], "doc_len": 89}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString._str_index", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "_str_index", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def _str_index(self):\n        idx = self['index']\n        out = []\n        output_index = False\n        default_index = idx.get('default', '')\n        if default_index:\n            output_index = True\n        out += [f'.. index:: {default_index}']\n        for section, references in idx.items():\n            if section == 'default':\n                continue\n            output_index = True\n            out += [f\"   :{section}: {', '.join(references)}\"]\n        if output_index:\n            return out\n        else:\n            return ''\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "_str_index", "self", "idx", "self", "index", "out", "output_index", "false", "default_index", "idx", "get", "default", "if", "default_index", "output_index", "true", "out", "f", "index", "default_index", "for", "section", "references", "in", "idx", "items", "if", "section", "default", "continue", "output_index", "true", "out", "f", "section", "join", "references", "if", "output_index", "return", "out", "else", "return"], "doc_len": 49}
{"doc_id": "seaborn/external/docscrape.py::NumpyDocString.__str__", "file_path": "seaborn/external/docscrape.py", "class_name": "NumpyDocString", "func_name": "__str__", "text": "文件路径: seaborn/external/docscrape.py, 类名: NumpyDocString\n    def __str__(self, func_role=''):\n        out = []\n        out += self._str_signature()\n        out += self._str_summary()\n        out += self._str_extended_summary()\n        for param_list in ('Parameters', 'Returns', 'Yields', 'Receives',\n                           'Other Parameters', 'Raises', 'Warns'):\n            out += self._str_param_list(param_list)\n        out += self._str_section('Warnings')\n        out += self._str_see_also(func_role)\n        for s in ('Notes', 'References', 'Examples'):\n            out += self._str_section(s)\n        for param_list in ('Attributes', 'Methods'):\n            out += self._str_param_list(param_list)\n        out += self._str_index()\n        return '\\n'.join(out)\n", "tokens": ["seaborn", "external", "docscrape", "py", "numpydocstring", "def", "__str__", "self", "func_role", "out", "out", "self", "_str_signature", "out", "self", "_str_summary", "out", "self", "_str_extended_summary", "for", "param_list", "in", "parameters", "returns", "yields", "receives", "other", "parameters", "raises", "warns", "out", "self", "_str_param_list", "param_list", "out", "self", "_str_section", "warnings", "out", "self", "_str_see_also", "func_role", "for", "s", "in", "notes", "references", "examples", "out", "self", "_str_section", "s", "for", "param_list", "in", "attributes", "methods", "out", "self", "_str_param_list", "param_list", "out", "self", "_str_index", "return", "n", "join", "out"], "doc_len": 68}
{"doc_id": "seaborn/external/docscrape.py::indent", "file_path": "seaborn/external/docscrape.py", "class_name": null, "func_name": "indent", "text": "文件路径: seaborn/external/docscrape.py\ndef indent(str, indent=4):\n    indent_str = ' '*indent\n    if str is None:\n        return indent_str\n    lines = str.split('\\n')\n    return '\\n'.join(indent_str + l for l in lines)\n", "tokens": ["seaborn", "external", "docscrape", "py", "def", "indent", "str", "indent", "4", "indent_str", "indent", "if", "str", "is", "none", "return", "indent_str", "lines", "str", "split", "n", "return", "n", "join", "indent_str", "l", "for", "l", "in", "lines"], "doc_len": 30}
{"doc_id": "seaborn/external/docscrape.py::dedent_lines", "file_path": "seaborn/external/docscrape.py", "class_name": null, "func_name": "dedent_lines", "text": "文件路径: seaborn/external/docscrape.py\ndef dedent_lines(lines):\n    \"\"\"Deindent a list of lines maximally\"\"\"\n    return textwrap.dedent(\"\\n\".join(lines)).split(\"\\n\")\n", "tokens": ["seaborn", "external", "docscrape", "py", "def", "dedent_lines", "lines", "deindent", "a", "list", "of", "lines", "maximally", "return", "textwrap", "dedent", "n", "join", "lines", "split", "n"], "doc_len": 21}
{"doc_id": "seaborn/external/docscrape.py::header", "file_path": "seaborn/external/docscrape.py", "class_name": null, "func_name": "header", "text": "文件路径: seaborn/external/docscrape.py\ndef header(text, style='-'):\n    return text + '\\n' + style*len(text) + '\\n'\n", "tokens": ["seaborn", "external", "docscrape", "py", "def", "header", "text", "style", "return", "text", "n", "style", "len", "text", "n"], "doc_len": 15}
{"doc_id": "seaborn/external/docscrape.py::FunctionDoc.__init__", "file_path": "seaborn/external/docscrape.py", "class_name": "FunctionDoc", "func_name": "__init__", "text": "文件路径: seaborn/external/docscrape.py, 类名: FunctionDoc\n    def __init__(self, func, role='func', doc=None, config={}):\n        self._f = func\n        self._role = role  # e.g. \"func\" or \"meth\"\n\n        if doc is None:\n            if func is None:\n                raise ValueError(\"No function or docstring given\")\n            doc = inspect.getdoc(func) or ''\n        NumpyDocString.__init__(self, doc, config)\n\n        if not self['Signature'] and func is not None:\n            func, func_name = self.get_func()\n            try:\n                try:\n                    signature = str(inspect.signature(func))\n                except (AttributeError, ValueError):\n                    # try to read signature, backward compat for older Python\n                    if sys.version_info[0] >= 3:\n                        argspec = inspect.getfullargspec(func)\n                    else:\n                        argspec = inspect.getargspec(func)\n                    signature = inspect.formatargspec(*argspec)\n                signature = f'{func_name}{signature}'\n            except TypeError:\n                signature = f'{func_name}()'\n            self['Signature'] = signature\n", "tokens": ["seaborn", "external", "docscrape", "py", "functiondoc", "def", "__init__", "self", "func", "role", "func", "doc", "none", "config", "self", "_f", "func", "self", "_role", "role", "e", "g", "func", "or", "meth", "if", "doc", "is", "none", "if", "func", "is", "none", "raise", "valueerror", "no", "function", "or", "docstring", "given", "doc", "inspect", "getdoc", "func", "or", "numpydocstring", "__init__", "self", "doc", "config", "if", "not", "self", "signature", "and", "func", "is", "not", "none", "func", "func_name", "self", "get_func", "try", "try", "signature", "str", "inspect", "signature", "func", "except", "attributeerror", "valueerror", "try", "to", "read", "signature", "backward", "compat", "for", "older", "python", "if", "sys", "version_info", "0", "3", "argspec", "inspect", "getfullargspec", "func", "else", "argspec", "inspect", "getargspec", "func", "signature", "inspect", "formatargspec", "argspec", "signature", "f", "func_name", "signature", "except", "typeerror", "signature", "f", "func_name", "self", "signature", "signature"], "doc_len": 112}
{"doc_id": "seaborn/external/docscrape.py::FunctionDoc.get_func", "file_path": "seaborn/external/docscrape.py", "class_name": "FunctionDoc", "func_name": "get_func", "text": "文件路径: seaborn/external/docscrape.py, 类名: FunctionDoc\n    def get_func(self):\n        func_name = getattr(self._f, '__name__', self.__class__.__name__)\n        if inspect.isclass(self._f):\n            func = getattr(self._f, '__call__', self._f.__init__)\n        else:\n            func = self._f\n        return func, func_name\n", "tokens": ["seaborn", "external", "docscrape", "py", "functiondoc", "def", "get_func", "self", "func_name", "getattr", "self", "_f", "__name__", "self", "__class__", "__name__", "if", "inspect", "isclass", "self", "_f", "func", "getattr", "self", "_f", "__call__", "self", "_f", "__init__", "else", "func", "self", "_f", "return", "func", "func_name"], "doc_len": 36}
{"doc_id": "seaborn/external/docscrape.py::FunctionDoc.__str__", "file_path": "seaborn/external/docscrape.py", "class_name": "FunctionDoc", "func_name": "__str__", "text": "文件路径: seaborn/external/docscrape.py, 类名: FunctionDoc\n    def __str__(self):\n        out = ''\n\n        func, func_name = self.get_func()\n\n        roles = {'func': 'function',\n                 'meth': 'method'}\n\n        if self._role:\n            if self._role not in roles:\n                print(f\"Warning: invalid role {self._role}\")\n            out += f\".. {roles.get(self._role, '')}:: {func_name}\\n    \\n\\n\"\n\n        out += super().__str__(func_role=self._role)\n        return out\n", "tokens": ["seaborn", "external", "docscrape", "py", "functiondoc", "def", "__str__", "self", "out", "func", "func_name", "self", "get_func", "roles", "func", "function", "meth", "method", "if", "self", "_role", "if", "self", "_role", "not", "in", "roles", "print", "f", "warning", "invalid", "role", "self", "_role", "out", "f", "roles", "get", "self", "_role", "func_name", "n", "n", "n", "out", "super", "__str__", "func_role", "self", "_role", "return", "out"], "doc_len": 52}
{"doc_id": "seaborn/external/docscrape.py::ClassDoc.__init__", "file_path": "seaborn/external/docscrape.py", "class_name": "ClassDoc", "func_name": "__init__", "text": "文件路径: seaborn/external/docscrape.py, 类名: ClassDoc\n    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\n                 config={}):\n        if not inspect.isclass(cls) and cls is not None:\n            raise ValueError(f\"Expected a class or None, but got {cls!r}\")\n        self._cls = cls\n\n        if 'sphinx' in sys.modules:\n            from sphinx.ext.autodoc import ALL\n        else:\n            ALL = object()\n\n        self.show_inherited_members = config.get(\n                    'show_inherited_class_members', True)\n\n        if modulename and not modulename.endswith('.'):\n            modulename += '.'\n        self._mod = modulename\n\n        if doc is None:\n            if cls is None:\n                raise ValueError(\"No class or documentation string given\")\n            doc = pydoc.getdoc(cls)\n\n        NumpyDocString.__init__(self, doc)\n\n        _members = config.get('members', [])\n        if _members is ALL:\n            _members = None\n        _exclude = config.get('exclude-members', [])\n\n        if config.get('show_class_members', True) and _exclude is not ALL:\n            def splitlines_x(s):\n                if not s:\n                    return []\n                else:\n                    return s.splitlines()\n            for field, items in [('Methods', self.methods),\n                                 ('Attributes', self.properties)]:\n                if not self[field]:\n                    doc_list = []\n                    for name in sorted(items):\n                        if (name in _exclude or\n                                (_members and name not in _members)):\n                            continue\n                        try:\n                            doc_item = pydoc.getdoc(getattr(self._cls, name))\n                            doc_list.append(\n                                Parameter(name, '', splitlines_x(doc_item)))\n                        except AttributeError:\n                            pass  # method doesn't exist\n                    self[field] = doc_list\n", "tokens": ["seaborn", "external", "docscrape", "py", "classdoc", "def", "__init__", "self", "cls", "doc", "none", "modulename", "func_doc", "functiondoc", "config", "if", "not", "inspect", "isclass", "cls", "and", "cls", "is", "not", "none", "raise", "valueerror", "f", "expected", "a", "class", "or", "none", "but", "got", "cls", "r", "self", "_cls", "cls", "if", "sphinx", "in", "sys", "modules", "from", "sphinx", "ext", "autodoc", "import", "all", "else", "all", "object", "self", "show_inherited_members", "config", "get", "show_inherited_class_members", "true", "if", "modulename", "and", "not", "modulename", "endswith", "modulename", "self", "_mod", "modulename", "if", "doc", "is", "none", "if", "cls", "is", "none", "raise", "valueerror", "no", "class", "or", "documentation", "string", "given", "doc", "pydoc", "getdoc", "cls", "numpydocstring", "__init__", "self", "doc", "_members", "config", "get", "members", "if", "_members", "is", "all", "_members", "none", "_exclude", "config", "get", "exclude", "members", "if", "config", "get", "show_class_members", "true", "and", "_exclude", "is", "not", "all", "def", "splitlines_x", "s", "if", "not", "s", "return", "else", "return", "s", "splitlines", "for", "field", "items", "in", "methods", "self", "methods", "attributes", "self", "properties", "if", "not", "self", "field", "doc_list", "for", "name", "in", "sorted", "items", "if", "name", "in", "_exclude", "or", "_members", "and", "name", "not", "in", "_members", "continue", "try", "doc_item", "pydoc", "getdoc", "getattr", "self", "_cls", "name", "doc_list", "append", "parameter", "name", "splitlines_x", "doc_item", "except", "attributeerror", "pass", "method", "doesn", "t", "exist", "self", "field", "doc_list"], "doc_len": 186}
{"doc_id": "seaborn/external/docscrape.py::ClassDoc.methods", "file_path": "seaborn/external/docscrape.py", "class_name": "ClassDoc", "func_name": "methods", "text": "文件路径: seaborn/external/docscrape.py, 类名: ClassDoc\n    def methods(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if ((not name.startswith('_')\n                     or name in self.extra_public_methods)\n                    and isinstance(func, Callable)\n                    and self._is_show_member(name))]\n", "tokens": ["seaborn", "external", "docscrape", "py", "classdoc", "def", "methods", "self", "if", "self", "_cls", "is", "none", "return", "return", "name", "for", "name", "func", "in", "inspect", "getmembers", "self", "_cls", "if", "not", "name", "startswith", "_", "or", "name", "in", "self", "extra_public_methods", "and", "isinstance", "func", "callable", "and", "self", "_is_show_member", "name"], "doc_len": 42}
{"doc_id": "seaborn/external/docscrape.py::ClassDoc.properties", "file_path": "seaborn/external/docscrape.py", "class_name": "ClassDoc", "func_name": "properties", "text": "文件路径: seaborn/external/docscrape.py, 类名: ClassDoc\n    def properties(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if (not name.startswith('_') and\n                    (func is None or isinstance(func, property) or\n                     inspect.isdatadescriptor(func))\n                    and self._is_show_member(name))]\n", "tokens": ["seaborn", "external", "docscrape", "py", "classdoc", "def", "properties", "self", "if", "self", "_cls", "is", "none", "return", "return", "name", "for", "name", "func", "in", "inspect", "getmembers", "self", "_cls", "if", "not", "name", "startswith", "_", "and", "func", "is", "none", "or", "isinstance", "func", "property", "or", "inspect", "isdatadescriptor", "func", "and", "self", "_is_show_member", "name"], "doc_len": 45}
{"doc_id": "seaborn/external/docscrape.py::ClassDoc._is_show_member", "file_path": "seaborn/external/docscrape.py", "class_name": "ClassDoc", "func_name": "_is_show_member", "text": "文件路径: seaborn/external/docscrape.py, 类名: ClassDoc\n    def _is_show_member(self, name):\n        if self.show_inherited_members:\n            return True  # show all class members\n        if name not in self._cls.__dict__:\n            return False  # class member is inherited, we do not show it\n        return True\n", "tokens": ["seaborn", "external", "docscrape", "py", "classdoc", "def", "_is_show_member", "self", "name", "if", "self", "show_inherited_members", "return", "true", "show", "all", "class", "members", "if", "name", "not", "in", "self", "_cls", "__dict__", "return", "false", "class", "member", "is", "inherited", "we", "do", "not", "show", "it", "return", "true"], "doc_len": 38}
{"doc_id": "seaborn/external/husl.py::husl_to_rgb", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "husl_to_rgb", "text": "文件路径: seaborn/external/husl.py\ndef husl_to_rgb(h, s, l):\n    return lch_to_rgb(*husl_to_lch([h, s, l]))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "husl_to_rgb", "h", "s", "l", "return", "lch_to_rgb", "husl_to_lch", "h", "s", "l"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::husl_to_hex", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "husl_to_hex", "text": "文件路径: seaborn/external/husl.py\ndef husl_to_hex(h, s, l):\n    return rgb_to_hex(husl_to_rgb(h, s, l))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "husl_to_hex", "h", "s", "l", "return", "rgb_to_hex", "husl_to_rgb", "h", "s", "l"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::rgb_to_husl", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_to_husl", "text": "文件路径: seaborn/external/husl.py\ndef rgb_to_husl(r, g, b):\n    return lch_to_husl(rgb_to_lch(r, g, b))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_to_husl", "r", "g", "b", "return", "lch_to_husl", "rgb_to_lch", "r", "g", "b"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::hex_to_husl", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "hex_to_husl", "text": "文件路径: seaborn/external/husl.py\ndef hex_to_husl(hex):\n    return rgb_to_husl(*hex_to_rgb(hex))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "hex_to_husl", "hex", "return", "rgb_to_husl", "hex_to_rgb", "hex"], "doc_len": 11}
{"doc_id": "seaborn/external/husl.py::huslp_to_rgb", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "huslp_to_rgb", "text": "文件路径: seaborn/external/husl.py\ndef huslp_to_rgb(h, s, l):\n    return lch_to_rgb(*huslp_to_lch([h, s, l]))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "huslp_to_rgb", "h", "s", "l", "return", "lch_to_rgb", "huslp_to_lch", "h", "s", "l"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::huslp_to_hex", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "huslp_to_hex", "text": "文件路径: seaborn/external/husl.py\ndef huslp_to_hex(h, s, l):\n    return rgb_to_hex(huslp_to_rgb(h, s, l))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "huslp_to_hex", "h", "s", "l", "return", "rgb_to_hex", "huslp_to_rgb", "h", "s", "l"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::rgb_to_huslp", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_to_huslp", "text": "文件路径: seaborn/external/husl.py\ndef rgb_to_huslp(r, g, b):\n    return lch_to_huslp(rgb_to_lch(r, g, b))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_to_huslp", "r", "g", "b", "return", "lch_to_huslp", "rgb_to_lch", "r", "g", "b"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::hex_to_huslp", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "hex_to_huslp", "text": "文件路径: seaborn/external/husl.py\ndef hex_to_huslp(hex):\n    return rgb_to_huslp(*hex_to_rgb(hex))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "hex_to_huslp", "hex", "return", "rgb_to_huslp", "hex_to_rgb", "hex"], "doc_len": 11}
{"doc_id": "seaborn/external/husl.py::lch_to_rgb", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "lch_to_rgb", "text": "文件路径: seaborn/external/husl.py\ndef lch_to_rgb(l, c, h):\n    return xyz_to_rgb(luv_to_xyz(lch_to_luv([l, c, h])))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "lch_to_rgb", "l", "c", "h", "return", "xyz_to_rgb", "luv_to_xyz", "lch_to_luv", "l", "c", "h"], "doc_len": 16}
{"doc_id": "seaborn/external/husl.py::rgb_to_lch", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_to_lch", "text": "文件路径: seaborn/external/husl.py\ndef rgb_to_lch(r, g, b):\n    return luv_to_lch(xyz_to_luv(rgb_to_xyz([r, g, b])))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_to_lch", "r", "g", "b", "return", "luv_to_lch", "xyz_to_luv", "rgb_to_xyz", "r", "g", "b"], "doc_len": 16}
{"doc_id": "seaborn/external/husl.py::max_chroma", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "max_chroma", "text": "文件路径: seaborn/external/husl.py\ndef max_chroma(L, H):\n    hrad = math.radians(H)\n    sinH = (math.sin(hrad))\n    cosH = (math.cos(hrad))\n    sub1 = (math.pow(L + 16, 3.0) / 1560896.0)\n    sub2 = sub1 if sub1 > 0.008856 else (L / 903.3)\n    result = float(\"inf\")\n    for row in m:\n        m1 = row[0]\n        m2 = row[1]\n        m3 = row[2]\n        top = ((0.99915 * m1 + 1.05122 * m2 + 1.14460 * m3) * sub2)\n        rbottom = (0.86330 * m3 - 0.17266 * m2)\n        lbottom = (0.12949 * m3 - 0.38848 * m1)\n        bottom = (rbottom * sinH + lbottom * cosH) * sub2\n\n        for t in (0.0, 1.0):\n            C = (L * (top - 1.05122 * t) / (bottom + 0.17266 * sinH * t))\n            if C > 0.0 and C < result:\n                result = C\n    return result\n", "tokens": ["seaborn", "external", "husl", "py", "def", "max_chroma", "l", "h", "hrad", "math", "radians", "h", "sinh", "math", "sin", "hrad", "cosh", "math", "cos", "hrad", "sub1", "math", "pow", "l", "16", "3", "0", "1560896", "0", "sub2", "sub1", "if", "sub1", "0", "008856", "else", "l", "903", "3", "result", "float", "inf", "for", "row", "in", "m", "m1", "row", "0", "m2", "row", "1", "m3", "row", "2", "top", "0", "99915", "m1", "1", "05122", "m2", "1", "14460", "m3", "sub2", "rbottom", "0", "86330", "m3", "0", "17266", "m2", "lbottom", "0", "12949", "m3", "0", "38848", "m1", "bottom", "rbottom", "sinh", "lbottom", "cosh", "sub2", "for", "t", "in", "0", "0", "1", "0", "c", "l", "top", "1", "05122", "t", "bottom", "0", "17266", "sinh", "t", "if", "c", "0", "0", "and", "c", "result", "result", "c", "return", "result"], "doc_len": 115}
{"doc_id": "seaborn/external/husl.py::_hrad_extremum", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "_hrad_extremum", "text": "文件路径: seaborn/external/husl.py\ndef _hrad_extremum(L):\n    lhs = (math.pow(L, 3.0) + 48.0 * math.pow(L, 2.0) + 768.0 * L + 4096.0) / 1560896.0\n    rhs = 1107.0 / 125000.0\n    sub = lhs if lhs > rhs else 10.0 * L / 9033.0\n    chroma = float(\"inf\")\n    result = None\n    for row in m:\n        for limit in (0.0, 1.0):\n            [m1, m2, m3] = row\n            top = -3015466475.0 * m3 * sub + 603093295.0 * m2 * sub - 603093295.0 * limit\n            bottom = 1356959916.0 * m1 * sub - 452319972.0 * m3 * sub\n            hrad = math.atan2(top, bottom)\n            # This is a math hack to deal with tan quadrants, I'm too lazy to figure\n            # out how to do this properly\n            if limit == 0.0:\n                hrad += math.pi\n            test = max_chroma(L, math.degrees(hrad))\n            if test < chroma:\n                chroma = test\n                result = hrad\n    return result\n", "tokens": ["seaborn", "external", "husl", "py", "def", "_hrad_extremum", "l", "lhs", "math", "pow", "l", "3", "0", "48", "0", "math", "pow", "l", "2", "0", "768", "0", "l", "4096", "0", "1560896", "0", "rhs", "1107", "0", "125000", "0", "sub", "lhs", "if", "lhs", "rhs", "else", "10", "0", "l", "9033", "0", "chroma", "float", "inf", "result", "none", "for", "row", "in", "m", "for", "limit", "in", "0", "0", "1", "0", "m1", "m2", "m3", "row", "top", "3015466475", "0", "m3", "sub", "603093295", "0", "m2", "sub", "603093295", "0", "limit", "bottom", "1356959916", "0", "m1", "sub", "452319972", "0", "m3", "sub", "hrad", "math", "atan2", "top", "bottom", "this", "is", "a", "math", "hack", "to", "deal", "with", "tan", "quadrants", "i", "m", "too", "lazy", "to", "figure", "out", "how", "to", "do", "this", "properly", "if", "limit", "0", "0", "hrad", "math", "pi", "test", "max_chroma", "l", "math", "degrees", "hrad", "if", "test", "chroma", "chroma", "test", "result", "hrad", "return", "result"], "doc_len": 133}
{"doc_id": "seaborn/external/husl.py::max_chroma_pastel", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "max_chroma_pastel", "text": "文件路径: seaborn/external/husl.py\ndef max_chroma_pastel(L):\n    H = math.degrees(_hrad_extremum(L))\n    return max_chroma(L, H)\n", "tokens": ["seaborn", "external", "husl", "py", "def", "max_chroma_pastel", "l", "h", "math", "degrees", "_hrad_extremum", "l", "return", "max_chroma", "l", "h"], "doc_len": 16}
{"doc_id": "seaborn/external/husl.py::dot_product", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "dot_product", "text": "文件路径: seaborn/external/husl.py\ndef dot_product(a, b):\n    return sum(map(operator.mul, a, b))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "dot_product", "a", "b", "return", "sum", "map", "operator", "mul", "a", "b"], "doc_len": 15}
{"doc_id": "seaborn/external/husl.py::f", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "f", "text": "文件路径: seaborn/external/husl.py\ndef f(t):\n    if t > lab_e:\n        return (math.pow(t, 1.0 / 3.0))\n    else:\n        return (7.787 * t + 16.0 / 116.0)\n", "tokens": ["seaborn", "external", "husl", "py", "def", "f", "t", "if", "t", "lab_e", "return", "math", "pow", "t", "1", "0", "3", "0", "else", "return", "7", "787", "t", "16", "0", "116", "0"], "doc_len": 27}
{"doc_id": "seaborn/external/husl.py::f_inv", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "f_inv", "text": "文件路径: seaborn/external/husl.py\ndef f_inv(t):\n    if math.pow(t, 3.0) > lab_e:\n        return (math.pow(t, 3.0))\n    else:\n        return (116.0 * t - 16.0) / lab_k\n", "tokens": ["seaborn", "external", "husl", "py", "def", "f_inv", "t", "if", "math", "pow", "t", "3", "0", "lab_e", "return", "math", "pow", "t", "3", "0", "else", "return", "116", "0", "t", "16", "0", "lab_k"], "doc_len": 28}
{"doc_id": "seaborn/external/husl.py::from_linear", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "from_linear", "text": "文件路径: seaborn/external/husl.py\ndef from_linear(c):\n    if c <= 0.0031308:\n        return 12.92 * c\n    else:\n        return (1.055 * math.pow(c, 1.0 / 2.4) - 0.055)\n", "tokens": ["seaborn", "external", "husl", "py", "def", "from_linear", "c", "if", "c", "0", "0031308", "return", "12", "92", "c", "else", "return", "1", "055", "math", "pow", "c", "1", "0", "2", "4", "0", "055"], "doc_len": 28}
{"doc_id": "seaborn/external/husl.py::to_linear", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "to_linear", "text": "文件路径: seaborn/external/husl.py\ndef to_linear(c):\n    a = 0.055\n\n    if c > 0.04045:\n        return (math.pow((c + a) / (1.0 + a), 2.4))\n    else:\n        return (c / 12.92)\n", "tokens": ["seaborn", "external", "husl", "py", "def", "to_linear", "c", "a", "0", "055", "if", "c", "0", "04045", "return", "math", "pow", "c", "a", "1", "0", "a", "2", "4", "else", "return", "c", "12", "92"], "doc_len": 29}
{"doc_id": "seaborn/external/husl.py::rgb_prepare", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_prepare", "text": "文件路径: seaborn/external/husl.py\ndef rgb_prepare(triple):\n    ret = []\n    for ch in triple:\n        ch = round(ch, 3)\n\n        if ch < -0.0001 or ch > 1.0001:\n            raise Exception(f\"Illegal RGB value {ch:f}\")\n\n        if ch < 0:\n            ch = 0\n        if ch > 1:\n            ch = 1\n\n        # Fix for Python 3 which by default rounds 4.5 down to 4.0\n        # instead of Python 2 which is rounded to 5.0 which caused\n        # a couple off by one errors in the tests. Tests now all pass\n        # in Python 2 and Python 3\n        ret.append(int(round(ch * 255 + 0.001, 0)))\n\n    return ret\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_prepare", "triple", "ret", "for", "ch", "in", "triple", "ch", "round", "ch", "3", "if", "ch", "0", "0001", "or", "ch", "1", "0001", "raise", "exception", "f", "illegal", "rgb", "value", "ch", "f", "if", "ch", "0", "ch", "0", "if", "ch", "1", "ch", "1", "fix", "for", "python", "3", "which", "by", "default", "rounds", "4", "5", "down", "to", "4", "0", "instead", "of", "python", "2", "which", "is", "rounded", "to", "5", "0", "which", "caused", "a", "couple", "off", "by", "one", "errors", "in", "the", "tests", "tests", "now", "all", "pass", "in", "python", "2", "and", "python", "3", "ret", "append", "int", "round", "ch", "255", "0", "001", "0", "return", "ret"], "doc_len": 98}
{"doc_id": "seaborn/external/husl.py::hex_to_rgb", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "hex_to_rgb", "text": "文件路径: seaborn/external/husl.py\ndef hex_to_rgb(hex):\n    if hex.startswith('#'):\n        hex = hex[1:]\n    r = int(hex[0:2], 16) / 255.0\n    g = int(hex[2:4], 16) / 255.0\n    b = int(hex[4:6], 16) / 255.0\n    return [r, g, b]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "hex_to_rgb", "hex", "if", "hex", "startswith", "hex", "hex", "1", "r", "int", "hex", "0", "2", "16", "255", "0", "g", "int", "hex", "2", "4", "16", "255", "0", "b", "int", "hex", "4", "6", "16", "255", "0", "return", "r", "g", "b"], "doc_len": 41}
{"doc_id": "seaborn/external/husl.py::rgb_to_hex", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_to_hex", "text": "文件路径: seaborn/external/husl.py\ndef rgb_to_hex(triple):\n    [r, g, b] = triple\n    return '#%02x%02x%02x' % tuple(rgb_prepare([r, g, b]))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_to_hex", "triple", "r", "g", "b", "triple", "return", "02x", "02x", "02x", "tuple", "rgb_prepare", "r", "g", "b"], "doc_len": 20}
{"doc_id": "seaborn/external/husl.py::xyz_to_rgb", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "xyz_to_rgb", "text": "文件路径: seaborn/external/husl.py\ndef xyz_to_rgb(triple):\n    xyz = map(lambda row: dot_product(row, triple), m)\n    return list(map(from_linear, xyz))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "xyz_to_rgb", "triple", "xyz", "map", "lambda", "row", "dot_product", "row", "triple", "m", "return", "list", "map", "from_linear", "xyz"], "doc_len": 20}
{"doc_id": "seaborn/external/husl.py::rgb_to_xyz", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "rgb_to_xyz", "text": "文件路径: seaborn/external/husl.py\ndef rgb_to_xyz(triple):\n    rgbl = list(map(to_linear, triple))\n    return list(map(lambda row: dot_product(row, rgbl), m_inv))\n", "tokens": ["seaborn", "external", "husl", "py", "def", "rgb_to_xyz", "triple", "rgbl", "list", "map", "to_linear", "triple", "return", "list", "map", "lambda", "row", "dot_product", "row", "rgbl", "m_inv"], "doc_len": 21}
{"doc_id": "seaborn/external/husl.py::xyz_to_luv", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "xyz_to_luv", "text": "文件路径: seaborn/external/husl.py\ndef xyz_to_luv(triple):\n    X, Y, Z = triple\n\n    if X == Y == Z == 0.0:\n        return [0.0, 0.0, 0.0]\n\n    varU = (4.0 * X) / (X + (15.0 * Y) + (3.0 * Z))\n    varV = (9.0 * Y) / (X + (15.0 * Y) + (3.0 * Z))\n    L = 116.0 * f(Y / refY) - 16.0\n\n    # Black will create a divide-by-zero error\n    if L == 0.0:\n        return [0.0, 0.0, 0.0]\n\n    U = 13.0 * L * (varU - refU)\n    V = 13.0 * L * (varV - refV)\n\n    return [L, U, V]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "xyz_to_luv", "triple", "x", "y", "z", "triple", "if", "x", "y", "z", "0", "0", "return", "0", "0", "0", "0", "0", "0", "varu", "4", "0", "x", "x", "15", "0", "y", "3", "0", "z", "varv", "9", "0", "y", "x", "15", "0", "y", "3", "0", "z", "l", "116", "0", "f", "y", "refy", "16", "0", "black", "will", "create", "a", "divide", "by", "zero", "error", "if", "l", "0", "0", "return", "0", "0", "0", "0", "0", "0", "u", "13", "0", "l", "varu", "refu", "v", "13", "0", "l", "varv", "refv", "return", "l", "u", "v"], "doc_len": 89}
{"doc_id": "seaborn/external/husl.py::luv_to_xyz", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "luv_to_xyz", "text": "文件路径: seaborn/external/husl.py\ndef luv_to_xyz(triple):\n    L, U, V = triple\n\n    if L == 0:\n        return [0.0, 0.0, 0.0]\n\n    varY = f_inv((L + 16.0) / 116.0)\n    varU = U / (13.0 * L) + refU\n    varV = V / (13.0 * L) + refV\n    Y = varY * refY\n    X = 0.0 - (9.0 * Y * varU) / ((varU - 4.0) * varV - varU * varV)\n    Z = (9.0 * Y - (15.0 * varV * Y) - (varV * X)) / (3.0 * varV)\n\n    return [X, Y, Z]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "luv_to_xyz", "triple", "l", "u", "v", "triple", "if", "l", "0", "return", "0", "0", "0", "0", "0", "0", "vary", "f_inv", "l", "16", "0", "116", "0", "varu", "u", "13", "0", "l", "refu", "varv", "v", "13", "0", "l", "refv", "y", "vary", "refy", "x", "0", "0", "9", "0", "y", "varu", "varu", "4", "0", "varv", "varu", "varv", "z", "9", "0", "y", "15", "0", "varv", "y", "varv", "x", "3", "0", "varv", "return", "x", "y", "z"], "doc_len": 73}
{"doc_id": "seaborn/external/husl.py::luv_to_lch", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "luv_to_lch", "text": "文件路径: seaborn/external/husl.py\ndef luv_to_lch(triple):\n    L, U, V = triple\n\n    C = (math.pow(math.pow(U, 2) + math.pow(V, 2), (1.0 / 2.0)))\n    hrad = (math.atan2(V, U))\n    H = math.degrees(hrad)\n    if H < 0.0:\n        H = 360.0 + H\n\n    return [L, C, H]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "luv_to_lch", "triple", "l", "u", "v", "triple", "c", "math", "pow", "math", "pow", "u", "2", "math", "pow", "v", "2", "1", "0", "2", "0", "hrad", "math", "atan2", "v", "u", "h", "math", "degrees", "hrad", "if", "h", "0", "0", "h", "360", "0", "h", "return", "l", "c", "h"], "doc_len": 47}
{"doc_id": "seaborn/external/husl.py::lch_to_luv", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "lch_to_luv", "text": "文件路径: seaborn/external/husl.py\ndef lch_to_luv(triple):\n    L, C, H = triple\n\n    Hrad = math.radians(H)\n    U = (math.cos(Hrad) * C)\n    V = (math.sin(Hrad) * C)\n\n    return [L, U, V]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "lch_to_luv", "triple", "l", "c", "h", "triple", "hrad", "math", "radians", "h", "u", "math", "cos", "hrad", "c", "v", "math", "sin", "hrad", "c", "return", "l", "u", "v"], "doc_len": 29}
{"doc_id": "seaborn/external/husl.py::husl_to_lch", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "husl_to_lch", "text": "文件路径: seaborn/external/husl.py\ndef husl_to_lch(triple):\n    H, S, L = triple\n\n    if L > 99.9999999:\n        return [100, 0.0, H]\n    if L < 0.00000001:\n        return [0.0, 0.0, H]\n\n    mx = max_chroma(L, H)\n    C = mx / 100.0 * S\n\n    return [L, C, H]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "husl_to_lch", "triple", "h", "s", "l", "triple", "if", "l", "99", "9999999", "return", "100", "0", "0", "h", "if", "l", "0", "00000001", "return", "0", "0", "0", "0", "h", "mx", "max_chroma", "l", "h", "c", "mx", "100", "0", "s", "return", "l", "c", "h"], "doc_len": 43}
{"doc_id": "seaborn/external/husl.py::lch_to_husl", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "lch_to_husl", "text": "文件路径: seaborn/external/husl.py\ndef lch_to_husl(triple):\n    L, C, H = triple\n\n    if L > 99.9999999:\n        return [H, 0.0, 100.0]\n    if L < 0.00000001:\n        return [H, 0.0, 0.0]\n\n    mx = max_chroma(L, H)\n    S = C / mx * 100.0\n\n    return [H, S, L]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "lch_to_husl", "triple", "l", "c", "h", "triple", "if", "l", "99", "9999999", "return", "h", "0", "0", "100", "0", "if", "l", "0", "00000001", "return", "h", "0", "0", "0", "0", "mx", "max_chroma", "l", "h", "s", "c", "mx", "100", "0", "return", "h", "s", "l"], "doc_len": 44}
{"doc_id": "seaborn/external/husl.py::huslp_to_lch", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "huslp_to_lch", "text": "文件路径: seaborn/external/husl.py\ndef huslp_to_lch(triple):\n    H, S, L = triple\n\n    if L > 99.9999999:\n        return [100, 0.0, H]\n    if L < 0.00000001:\n        return [0.0, 0.0, H]\n\n    mx = max_chroma_pastel(L)\n    C = mx / 100.0 * S\n\n    return [L, C, H]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "huslp_to_lch", "triple", "h", "s", "l", "triple", "if", "l", "99", "9999999", "return", "100", "0", "0", "h", "if", "l", "0", "00000001", "return", "0", "0", "0", "0", "h", "mx", "max_chroma_pastel", "l", "c", "mx", "100", "0", "s", "return", "l", "c", "h"], "doc_len": 42}
{"doc_id": "seaborn/external/husl.py::lch_to_huslp", "file_path": "seaborn/external/husl.py", "class_name": null, "func_name": "lch_to_huslp", "text": "文件路径: seaborn/external/husl.py\ndef lch_to_huslp(triple):\n    L, C, H = triple\n\n    if L > 99.9999999:\n        return [H, 0.0, 100.0]\n    if L < 0.00000001:\n        return [H, 0.0, 0.0]\n\n    mx = max_chroma_pastel(L)\n    S = C / mx * 100.0\n\n    return [H, S, L]\n", "tokens": ["seaborn", "external", "husl", "py", "def", "lch_to_huslp", "triple", "l", "c", "h", "triple", "if", "l", "99", "9999999", "return", "h", "0", "0", "100", "0", "if", "l", "0", "00000001", "return", "h", "0", "0", "0", "0", "mx", "max_chroma_pastel", "l", "s", "c", "mx", "100", "0", "return", "h", "s", "l"], "doc_len": 43}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.__init__", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "__init__", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def __init__(self, dataset, bw_method=None, weights=None):\n        self.dataset = atleast_2d(asarray(dataset))\n        if not self.dataset.size > 1:\n            raise ValueError(\"`dataset` input should have multiple elements.\")\n\n        self.d, self.n = self.dataset.shape\n\n        if weights is not None:\n            self._weights = atleast_1d(weights).astype(float)\n            self._weights /= sum(self._weights)\n            if self.weights.ndim != 1:\n                raise ValueError(\"`weights` input should be one-dimensional.\")\n            if len(self._weights) != self.n:\n                raise ValueError(\"`weights` input should be of length n\")\n            self._neff = 1/sum(self._weights**2)\n\n        self.set_bandwidth(bw_method=bw_method)\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "__init__", "self", "dataset", "bw_method", "none", "weights", "none", "self", "dataset", "atleast_2d", "asarray", "dataset", "if", "not", "self", "dataset", "size", "1", "raise", "valueerror", "dataset", "input", "should", "have", "multiple", "elements", "self", "d", "self", "n", "self", "dataset", "shape", "if", "weights", "is", "not", "none", "self", "_weights", "atleast_1d", "weights", "astype", "float", "self", "_weights", "sum", "self", "_weights", "if", "self", "weights", "ndim", "1", "raise", "valueerror", "weights", "input", "should", "be", "one", "dimensional", "if", "len", "self", "_weights", "self", "n", "raise", "valueerror", "weights", "input", "should", "be", "of", "length", "n", "self", "_neff", "1", "sum", "self", "_weights", "2", "self", "set_bandwidth", "bw_method", "bw_method"], "doc_len": 94}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.evaluate", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "evaluate", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def evaluate(self, points):\n        \"\"\"Evaluate the estimated pdf on a set of points.\n\n        Parameters\n        ----------\n        points : (# of dimensions, # of points)-array\n            Alternatively, a (# of dimensions,) vector can be passed in and\n            treated as a single point.\n\n        Returns\n        -------\n        values : (# of points,)-array\n            The values at each point.\n\n        Raises\n        ------\n        ValueError : if the dimensionality of the input points is different than\n                     the dimensionality of the KDE.\n\n        \"\"\"\n        points = atleast_2d(asarray(points))\n\n        d, m = points.shape\n        if d != self.d:\n            if d == 1 and m == self.d:\n                # points was passed in as a row vector\n                points = reshape(points, (self.d, 1))\n                m = 1\n            else:\n                msg = f\"points have dimension {d}, dataset has dimension {self.d}\"\n                raise ValueError(msg)\n\n        output_dtype = np.common_type(self.covariance, points)\n        result = zeros((m,), dtype=output_dtype)\n\n        whitening = linalg.cholesky(self.inv_cov)\n        scaled_dataset = dot(whitening, self.dataset)\n        scaled_points = dot(whitening, points)\n\n        if m >= self.n:\n            # there are more points than data, so loop over data\n            for i in range(self.n):\n                diff = scaled_dataset[:, i, newaxis] - scaled_points\n                energy = sum(diff * diff, axis=0) / 2.0\n                result += self.weights[i]*exp(-energy)\n        else:\n            # loop over points\n            for i in range(m):\n                diff = scaled_dataset - scaled_points[:, i, newaxis]\n                energy = sum(diff * diff, axis=0) / 2.0\n                result[i] = sum(exp(-energy)*self.weights, axis=0)\n\n        result = result / self._norm_factor\n\n        return result\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "evaluate", "self", "points", "evaluate", "the", "estimated", "pdf", "on", "a", "set", "of", "points", "parameters", "points", "of", "dimensions", "of", "points", "array", "alternatively", "a", "of", "dimensions", "vector", "can", "be", "passed", "in", "and", "treated", "as", "a", "single", "point", "returns", "values", "of", "points", "array", "the", "values", "at", "each", "point", "raises", "valueerror", "if", "the", "dimensionality", "of", "the", "input", "points", "is", "different", "than", "the", "dimensionality", "of", "the", "kde", "points", "atleast_2d", "asarray", "points", "d", "m", "points", "shape", "if", "d", "self", "d", "if", "d", "1", "and", "m", "self", "d", "points", "was", "passed", "in", "as", "a", "row", "vector", "points", "reshape", "points", "self", "d", "1", "m", "1", "else", "msg", "f", "points", "have", "dimension", "d", "dataset", "has", "dimension", "self", "d", "raise", "valueerror", "msg", "output_dtype", "np", "common_type", "self", "covariance", "points", "result", "zeros", "m", "dtype", "output_dtype", "whitening", "linalg", "cholesky", "self", "inv_cov", "scaled_dataset", "dot", "whitening", "self", "dataset", "scaled_points", "dot", "whitening", "points", "if", "m", "self", "n", "there", "are", "more", "points", "than", "data", "so", "loop", "over", "data", "for", "i", "in", "range", "self", "n", "diff", "scaled_dataset", "i", "newaxis", "scaled_points", "energy", "sum", "diff", "diff", "axis", "0", "2", "0", "result", "self", "weights", "i", "exp", "energy", "else", "loop", "over", "points", "for", "i", "in", "range", "m", "diff", "scaled_dataset", "scaled_points", "i", "newaxis", "energy", "sum", "diff", "diff", "axis", "0", "2", "0", "result", "i", "sum", "exp", "energy", "self", "weights", "axis", "0", "result", "result", "self", "_norm_factor", "return", "result"], "doc_len": 218}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.scotts_factor", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "scotts_factor", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def scotts_factor(self):\n        \"\"\"Compute Scott's factor.\n\n        Returns\n        -------\n        s : float\n            Scott's factor.\n        \"\"\"\n        return power(self.neff, -1./(self.d+4))\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "scotts_factor", "self", "compute", "scott", "s", "factor", "returns", "s", "float", "scott", "s", "factor", "return", "power", "self", "neff", "1", "self", "d", "4"], "doc_len": 26}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.silverman_factor", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "silverman_factor", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def silverman_factor(self):\n        \"\"\"Compute the Silverman factor.\n\n        Returns\n        -------\n        s : float\n            The silverman factor.\n        \"\"\"\n        return power(self.neff*(self.d+2.0)/4.0, -1./(self.d+4))\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "silverman_factor", "self", "compute", "the", "silverman", "factor", "returns", "s", "float", "the", "silverman", "factor", "return", "power", "self", "neff", "self", "d", "2", "0", "4", "0", "1", "self", "d", "4"], "doc_len": 32}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.set_bandwidth", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "set_bandwidth", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def set_bandwidth(self, bw_method=None):\n        \"\"\"Compute the estimator bandwidth with given method.\n\n        The new bandwidth calculated after a call to `set_bandwidth` is used\n        for subsequent evaluations of the estimated density.\n\n        Parameters\n        ----------\n        bw_method : str, scalar or callable, optional\n            The method used to calculate the estimator bandwidth.  This can be\n            'scott', 'silverman', a scalar constant or a callable.  If a\n            scalar, this will be used directly as `kde.factor`.  If a callable,\n            it should take a `gaussian_kde` instance as only parameter and\n            return a scalar.  If None (default), nothing happens; the current\n            `kde.covariance_factor` method is kept.\n\n        Notes\n        -----\n        .. versionadded:: 0.11\n\n        \"\"\"\n        if bw_method is None:\n            pass\n        elif bw_method == 'scott':\n            self.covariance_factor = self.scotts_factor\n        elif bw_method == 'silverman':\n            self.covariance_factor = self.silverman_factor\n        elif np.isscalar(bw_method) and not isinstance(bw_method, str):\n            self._bw_method = 'use constant'\n            self.covariance_factor = lambda: bw_method\n        elif callable(bw_method):\n            self._bw_method = bw_method\n            self.covariance_factor = lambda: self._bw_method(self)\n        else:\n            msg = \"`bw_method` should be 'scott', 'silverman', a scalar \" \\\n                  \"or a callable.\"\n            raise ValueError(msg)\n\n        self._compute_covariance()\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "set_bandwidth", "self", "bw_method", "none", "compute", "the", "estimator", "bandwidth", "with", "given", "method", "the", "new", "bandwidth", "calculated", "after", "a", "call", "to", "set_bandwidth", "is", "used", "for", "subsequent", "evaluations", "of", "the", "estimated", "density", "parameters", "bw_method", "str", "scalar", "or", "callable", "optional", "the", "method", "used", "to", "calculate", "the", "estimator", "bandwidth", "this", "can", "be", "scott", "silverman", "a", "scalar", "constant", "or", "a", "callable", "if", "a", "scalar", "this", "will", "be", "used", "directly", "as", "kde", "factor", "if", "a", "callable", "it", "should", "take", "a", "gaussian_kde", "instance", "as", "only", "parameter", "and", "return", "a", "scalar", "if", "none", "default", "nothing", "happens", "the", "current", "kde", "covariance_factor", "method", "is", "kept", "notes", "versionadded", "0", "11", "if", "bw_method", "is", "none", "pass", "elif", "bw_method", "scott", "self", "covariance_factor", "self", "scotts_factor", "elif", "bw_method", "silverman", "self", "covariance_factor", "self", "silverman_factor", "elif", "np", "isscalar", "bw_method", "and", "not", "isinstance", "bw_method", "str", "self", "_bw_method", "use", "constant", "self", "covariance_factor", "lambda", "bw_method", "elif", "callable", "bw_method", "self", "_bw_method", "bw_method", "self", "covariance_factor", "lambda", "self", "_bw_method", "self", "else", "msg", "bw_method", "should", "be", "scott", "silverman", "a", "scalar", "or", "a", "callable", "raise", "valueerror", "msg", "self", "_compute_covariance"], "doc_len": 169}
{"doc_id": "seaborn/external/kde.py::gaussian_kde._compute_covariance", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "_compute_covariance", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def _compute_covariance(self):\n        \"\"\"Computes the covariance matrix for each Gaussian kernel using\n        covariance_factor().\n        \"\"\"\n        self.factor = self.covariance_factor()\n        # Cache covariance and inverse covariance of the data\n        if not hasattr(self, '_data_inv_cov'):\n            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,\n                                               bias=False,\n                                               aweights=self.weights))\n            self._data_inv_cov = linalg.inv(self._data_covariance)\n\n        self.covariance = self._data_covariance * self.factor**2\n        self.inv_cov = self._data_inv_cov / self.factor**2\n        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance))\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "_compute_covariance", "self", "computes", "the", "covariance", "matrix", "for", "each", "gaussian", "kernel", "using", "covariance_factor", "self", "factor", "self", "covariance_factor", "cache", "covariance", "and", "inverse", "covariance", "of", "the", "data", "if", "not", "hasattr", "self", "_data_inv_cov", "self", "_data_covariance", "atleast_2d", "cov", "self", "dataset", "rowvar", "1", "bias", "false", "aweights", "self", "weights", "self", "_data_inv_cov", "linalg", "inv", "self", "_data_covariance", "self", "covariance", "self", "_data_covariance", "self", "factor", "2", "self", "inv_cov", "self", "_data_inv_cov", "self", "factor", "2", "self", "_norm_factor", "sqrt", "linalg", "det", "2", "pi", "self", "covariance"], "doc_len": 77}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.pdf", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "pdf", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def pdf(self, x):\n        \"\"\"\n        Evaluate the estimated pdf on a provided set of points.\n\n        Notes\n        -----\n        This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate``\n        docstring for more details.\n\n        \"\"\"\n        return self.evaluate(x)\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "pdf", "self", "x", "evaluate", "the", "estimated", "pdf", "on", "a", "provided", "set", "of", "points", "notes", "this", "is", "an", "alias", "for", "gaussian_kde", "evaluate", "see", "the", "evaluate", "docstring", "for", "more", "details", "return", "self", "evaluate", "x"], "doc_len": 38}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.weights", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "weights", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def weights(self):\n        try:\n            return self._weights\n        except AttributeError:\n            self._weights = ones(self.n)/self.n\n            return self._weights\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "weights", "self", "try", "return", "self", "_weights", "except", "attributeerror", "self", "_weights", "ones", "self", "n", "self", "n", "return", "self", "_weights"], "doc_len": 24}
{"doc_id": "seaborn/external/kde.py::gaussian_kde.neff", "file_path": "seaborn/external/kde.py", "class_name": "gaussian_kde", "func_name": "neff", "text": "文件路径: seaborn/external/kde.py, 类名: gaussian_kde\n    def neff(self):\n        try:\n            return self._neff\n        except AttributeError:\n            self._neff = 1/sum(self.weights**2)\n            return self._neff\n", "tokens": ["seaborn", "external", "kde", "py", "gaussian_kde", "def", "neff", "self", "try", "return", "self", "_neff", "except", "attributeerror", "self", "_neff", "1", "sum", "self", "weights", "2", "return", "self", "_neff"], "doc_len": 24}
{"doc_id": "seaborn/external/version.py::InfinityType.__repr__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__repr__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __repr__(self) -> str:\n        return \"Infinity\"\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__repr__", "self", "str", "return", "infinity"], "doc_len": 11}
{"doc_id": "seaborn/external/version.py::InfinityType.__hash__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__hash__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __hash__(self) -> int:\n        return hash(repr(self))\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__hash__", "self", "int", "return", "hash", "repr", "self"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::InfinityType.__lt__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__lt__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __lt__(self, other: object) -> bool:\n        return False\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__lt__", "self", "other", "object", "bool", "return", "false"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::InfinityType.__le__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__le__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __le__(self, other: object) -> bool:\n        return False\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__le__", "self", "other", "object", "bool", "return", "false"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::InfinityType.__eq__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__eq__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__eq__", "self", "other", "object", "bool", "return", "isinstance", "other", "self", "__class__"], "doc_len": 16}
{"doc_id": "seaborn/external/version.py::InfinityType.__ne__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__ne__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __ne__(self, other: object) -> bool:\n        return not isinstance(other, self.__class__)\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__ne__", "self", "other", "object", "bool", "return", "not", "isinstance", "other", "self", "__class__"], "doc_len": 17}
{"doc_id": "seaborn/external/version.py::InfinityType.__gt__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__gt__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __gt__(self, other: object) -> bool:\n        return True\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__gt__", "self", "other", "object", "bool", "return", "true"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::InfinityType.__ge__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__ge__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __ge__(self, other: object) -> bool:\n        return True\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__ge__", "self", "other", "object", "bool", "return", "true"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::InfinityType.__neg__", "file_path": "seaborn/external/version.py", "class_name": "InfinityType", "func_name": "__neg__", "text": "文件路径: seaborn/external/version.py, 类名: InfinityType\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n", "tokens": ["seaborn", "external", "version", "py", "infinitytype", "def", "__neg__", "self", "object", "negativeinfinitytype", "return", "negativeinfinity"], "doc_len": 12}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__repr__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__repr__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__repr__", "self", "str", "return", "infinity"], "doc_len": 11}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__hash__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__hash__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __hash__(self) -> int:\n        return hash(repr(self))\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__hash__", "self", "int", "return", "hash", "repr", "self"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__lt__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__lt__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __lt__(self, other: object) -> bool:\n        return True\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__lt__", "self", "other", "object", "bool", "return", "true"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__le__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__le__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __le__(self, other: object) -> bool:\n        return True\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__le__", "self", "other", "object", "bool", "return", "true"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__eq__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__eq__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__eq__", "self", "other", "object", "bool", "return", "isinstance", "other", "self", "__class__"], "doc_len": 16}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__ne__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__ne__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __ne__(self, other: object) -> bool:\n        return not isinstance(other, self.__class__)\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__ne__", "self", "other", "object", "bool", "return", "not", "isinstance", "other", "self", "__class__"], "doc_len": 17}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__gt__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__gt__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __gt__(self, other: object) -> bool:\n        return False\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__gt__", "self", "other", "object", "bool", "return", "false"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__ge__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__ge__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __ge__(self, other: object) -> bool:\n        return False\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__ge__", "self", "other", "object", "bool", "return", "false"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::NegativeInfinityType.__neg__", "file_path": "seaborn/external/version.py", "class_name": "NegativeInfinityType", "func_name": "__neg__", "text": "文件路径: seaborn/external/version.py, 类名: NegativeInfinityType\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n", "tokens": ["seaborn", "external", "version", "py", "negativeinfinitytype", "def", "__neg__", "self", "object", "infinitytype", "return", "infinity"], "doc_len": 12}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__hash__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__hash__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __hash__(self) -> int:\n        return hash(self._key)\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__hash__", "self", "int", "return", "hash", "self", "_key"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__lt__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__lt__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__lt__", "self", "other", "_baseversion", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__le__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__le__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __le__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__le__", "self", "other", "_baseversion", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__eq__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__eq__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__eq__", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__ge__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__ge__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __ge__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__ge__", "self", "other", "_baseversion", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__gt__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__gt__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __gt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__gt__", "self", "other", "_baseversion", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::_BaseVersion.__ne__", "file_path": "seaborn/external/version.py", "class_name": "_BaseVersion", "func_name": "__ne__", "text": "文件路径: seaborn/external/version.py, 类名: _BaseVersion\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n", "tokens": ["seaborn", "external", "version", "py", "_baseversion", "def", "__ne__", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "_baseversion", "return", "notimplemented", "return", "self", "_key", "other", "_key"], "doc_len": 23}
{"doc_id": "seaborn/external/version.py::Version.__init__", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "__init__", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def __init__(self, version: str) -> None:\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "__init__", "self", "version", "str", "none", "validate", "the", "version", "and", "parse", "it", "into", "pieces", "match", "self", "_regex", "search", "version", "if", "not", "match", "raise", "invalidversion", "f", "invalid", "version", "version", "store", "the", "parsed", "out", "pieces", "of", "the", "version", "self", "_version", "_version", "epoch", "int", "match", "group", "epoch", "if", "match", "group", "epoch", "else", "0", "release", "tuple", "int", "i", "for", "i", "in", "match", "group", "release", "split", "pre", "_parse_letter_version", "match", "group", "pre_l", "match", "group", "pre_n", "post", "_parse_letter_version", "match", "group", "post_l", "match", "group", "post_n1", "or", "match", "group", "post_n2", "dev", "_parse_letter_version", "match", "group", "dev_l", "match", "group", "dev_n", "local", "_parse_local_version", "match", "group", "local", "generate", "a", "key", "which", "will", "be", "used", "for", "sorting", "self", "_key", "_cmpkey", "self", "_version", "epoch", "self", "_version", "release", "self", "_version", "pre", "self", "_version", "post", "self", "_version", "dev", "self", "_version", "local"], "doc_len": 129}
{"doc_id": "seaborn/external/version.py::Version.__repr__", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "__repr__", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def __repr__(self) -> str:\n        return f\"<Version('{self}')>\"\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "__repr__", "self", "str", "return", "f", "version", "self"], "doc_len": 13}
{"doc_id": "seaborn/external/version.py::Version.__str__", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "__str__", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def __str__(self) -> str:\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "__str__", "self", "str", "parts", "epoch", "if", "self", "epoch", "0", "parts", "append", "f", "self", "epoch", "release", "segment", "parts", "append", "join", "str", "x", "for", "x", "in", "self", "release", "pre", "release", "if", "self", "pre", "is", "not", "none", "parts", "append", "join", "str", "x", "for", "x", "in", "self", "pre", "post", "release", "if", "self", "post", "is", "not", "none", "parts", "append", "f", "post", "self", "post", "development", "release", "if", "self", "dev", "is", "not", "none", "parts", "append", "f", "dev", "self", "dev", "local", "version", "segment", "if", "self", "local", "is", "not", "none", "parts", "append", "f", "self", "local", "return", "join", "parts"], "doc_len": 95}
{"doc_id": "seaborn/external/version.py::Version.epoch", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "epoch", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def epoch(self) -> int:\n        _epoch: int = self._version.epoch\n        return _epoch\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "epoch", "self", "int", "_epoch", "int", "self", "_version", "epoch", "return", "_epoch"], "doc_len": 16}
{"doc_id": "seaborn/external/version.py::Version.release", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "release", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def release(self) -> Tuple[int, ...]:\n        _release: Tuple[int, ...] = self._version.release\n        return _release\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "release", "self", "tuple", "int", "_release", "tuple", "int", "self", "_version", "release", "return", "_release"], "doc_len": 18}
{"doc_id": "seaborn/external/version.py::Version.pre", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "pre", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def pre(self) -> Optional[Tuple[str, int]]:\n        _pre: Optional[Tuple[str, int]] = self._version.pre\n        return _pre\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "pre", "self", "optional", "tuple", "str", "int", "_pre", "optional", "tuple", "str", "int", "self", "_version", "pre", "return", "_pre"], "doc_len": 22}
{"doc_id": "seaborn/external/version.py::Version.post", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "post", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def post(self) -> Optional[int]:\n        return self._version.post[1] if self._version.post else None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "post", "self", "optional", "int", "return", "self", "_version", "post", "1", "if", "self", "_version", "post", "else", "none"], "doc_len": 21}
{"doc_id": "seaborn/external/version.py::Version.dev", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "dev", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def dev(self) -> Optional[int]:\n        return self._version.dev[1] if self._version.dev else None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "dev", "self", "optional", "int", "return", "self", "_version", "dev", "1", "if", "self", "_version", "dev", "else", "none"], "doc_len": 21}
{"doc_id": "seaborn/external/version.py::Version.local", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "local", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def local(self) -> Optional[str]:\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "local", "self", "optional", "str", "if", "self", "_version", "local", "return", "join", "str", "x", "for", "x", "in", "self", "_version", "local", "else", "return", "none"], "doc_len": 27}
{"doc_id": "seaborn/external/version.py::Version.public", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "public", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def public(self) -> str:\n        return str(self).split(\"+\", 1)[0]\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "public", "self", "str", "return", "str", "self", "split", "1", "0"], "doc_len": 15}
{"doc_id": "seaborn/external/version.py::Version.base_version", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "base_version", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def base_version(self) -> str:\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "base_version", "self", "str", "parts", "epoch", "if", "self", "epoch", "0", "parts", "append", "f", "self", "epoch", "release", "segment", "parts", "append", "join", "str", "x", "for", "x", "in", "self", "release", "return", "join", "parts"], "doc_len": 35}
{"doc_id": "seaborn/external/version.py::Version.is_prerelease", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "is_prerelease", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def is_prerelease(self) -> bool:\n        return self.dev is not None or self.pre is not None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "is_prerelease", "self", "bool", "return", "self", "dev", "is", "not", "none", "or", "self", "pre", "is", "not", "none"], "doc_len": 21}
{"doc_id": "seaborn/external/version.py::Version.is_postrelease", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "is_postrelease", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def is_postrelease(self) -> bool:\n        return self.post is not None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "is_postrelease", "self", "bool", "return", "self", "post", "is", "not", "none"], "doc_len": 15}
{"doc_id": "seaborn/external/version.py::Version.is_devrelease", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "is_devrelease", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def is_devrelease(self) -> bool:\n        return self.dev is not None\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "is_devrelease", "self", "bool", "return", "self", "dev", "is", "not", "none"], "doc_len": 15}
{"doc_id": "seaborn/external/version.py::Version.major", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "major", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def major(self) -> int:\n        return self.release[0] if len(self.release) >= 1 else 0\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "major", "self", "int", "return", "self", "release", "0", "if", "len", "self", "release", "1", "else", "0"], "doc_len": 20}
{"doc_id": "seaborn/external/version.py::Version.minor", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "minor", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def minor(self) -> int:\n        return self.release[1] if len(self.release) >= 2 else 0\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "minor", "self", "int", "return", "self", "release", "1", "if", "len", "self", "release", "2", "else", "0"], "doc_len": 20}
{"doc_id": "seaborn/external/version.py::Version.micro", "file_path": "seaborn/external/version.py", "class_name": "Version", "func_name": "micro", "text": "文件路径: seaborn/external/version.py, 类名: Version\n    def micro(self) -> int:\n        return self.release[2] if len(self.release) >= 3 else 0\n", "tokens": ["seaborn", "external", "version", "py", "version", "def", "micro", "self", "int", "return", "self", "release", "2", "if", "len", "self", "release", "3", "else", "0"], "doc_len": 20}
{"doc_id": "seaborn/external/version.py::_parse_letter_version", "file_path": "seaborn/external/version.py", "class_name": null, "func_name": "_parse_letter_version", "text": "文件路径: seaborn/external/version.py\ndef _parse_letter_version(\n    letter: str, number: Union[str, bytes, SupportsInt]\n) -> Optional[Tuple[str, int]]:\n\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n", "tokens": ["seaborn", "external", "version", "py", "def", "_parse_letter_version", "letter", "str", "number", "union", "str", "bytes", "supportsint", "optional", "tuple", "str", "int", "if", "letter", "we", "consider", "there", "to", "be", "an", "implicit", "0", "in", "a", "pre", "release", "if", "there", "is", "not", "a", "numeral", "associated", "with", "it", "if", "number", "is", "none", "number", "0", "we", "normalize", "any", "letters", "to", "their", "lower", "case", "form", "letter", "letter", "lower", "we", "consider", "some", "words", "to", "be", "alternate", "spellings", "of", "other", "words", "and", "in", "those", "cases", "we", "want", "to", "normalize", "the", "spellings", "to", "our", "preferred", "spelling", "if", "letter", "alpha", "letter", "a", "elif", "letter", "beta", "letter", "b", "elif", "letter", "in", "c", "pre", "preview", "letter", "rc", "elif", "letter", "in", "rev", "r", "letter", "post", "return", "letter", "int", "number", "if", "not", "letter", "and", "number", "we", "assume", "if", "we", "are", "given", "a", "number", "but", "we", "are", "not", "given", "a", "letter", "then", "this", "is", "using", "the", "implicit", "post", "release", "syntax", "e", "g", "1", "0", "1", "letter", "post", "return", "letter", "int", "number", "return", "none"], "doc_len": 154}
{"doc_id": "seaborn/external/version.py::_parse_local_version", "file_path": "seaborn/external/version.py", "class_name": null, "func_name": "_parse_local_version", "text": "文件路径: seaborn/external/version.py\ndef _parse_local_version(local: str) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n", "tokens": ["seaborn", "external", "version", "py", "def", "_parse_local_version", "local", "str", "optional", "localtype", "takes", "a", "string", "like", "abc", "1", "twelve", "and", "turns", "it", "into", "abc", "1", "twelve", "if", "local", "is", "not", "none", "return", "tuple", "part", "lower", "if", "not", "part", "isdigit", "else", "int", "part", "for", "part", "in", "_local_version_separators", "split", "local", "return", "none"], "doc_len": 48}
{"doc_id": "seaborn/external/version.py::_cmpkey", "file_path": "seaborn/external/version.py", "class_name": null, "func_name": "_cmpkey", "text": "文件路径: seaborn/external/version.py\ndef _cmpkey(\n    epoch: int,\n    release: Tuple[int, ...],\n    pre: Optional[Tuple[str, int]],\n    post: Optional[Tuple[str, int]],\n    dev: Optional[Tuple[str, int]],\n    local: Optional[Tuple[SubLocalType]],\n) -> CmpKey:\n\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: PrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: PrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: PrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: LocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n", "tokens": ["seaborn", "external", "version", "py", "def", "_cmpkey", "epoch", "int", "release", "tuple", "int", "pre", "optional", "tuple", "str", "int", "post", "optional", "tuple", "str", "int", "dev", "optional", "tuple", "str", "int", "local", "optional", "tuple", "sublocaltype", "cmpkey", "when", "we", "compare", "a", "release", "version", "we", "want", "to", "compare", "it", "with", "all", "of", "the", "trailing", "zeros", "removed", "so", "we", "ll", "use", "a", "reverse", "the", "list", "drop", "all", "the", "now", "leading", "zeros", "until", "we", "come", "to", "something", "non", "zero", "then", "take", "the", "rest", "re", "reverse", "it", "back", "into", "the", "correct", "order", "and", "make", "it", "a", "tuple", "and", "use", "that", "for", "our", "sorting", "key", "_release", "tuple", "reversed", "list", "itertools", "dropwhile", "lambda", "x", "x", "0", "reversed", "release", "we", "need", "to", "trick", "the", "sorting", "algorithm", "to", "put", "1", "0", "dev0", "before", "1", "0a0", "we", "ll", "do", "this", "by", "abusing", "the", "pre", "segment", "but", "we", "_only_", "want", "to", "do", "this", "if", "there", "is", "not", "a", "pre", "or", "a", "post", "segment", "if", "we", "have", "one", "of", "those", "then", "the", "normal", "sorting", "rules", "will", "handle", "this", "case", "correctly", "if", "pre", "is", "none", "and", "post", "is", "none", "and", "dev", "is", "not", "none", "_pre", "prepostdevtype", "negativeinfinity", "versions", "without", "a", "pre", "release", "except", "as", "noted", "above", "should", "sort", "after", "those", "with", "one", "elif", "pre", "is", "none", "_pre", "infinity", "else", "_pre", "pre", "versions", "without", "a", "post", "segment", "should", "sort", "before", "those", "with", "one", "if", "post", "is", "none", "_post", "prepostdevtype", "negativeinfinity", "else", "_post", "post", "versions", "without", "a", "development", "segment", "should", "sort", "after", "those", "with", "one", "if", "dev", "is", "none", "_dev", "prepostdevtype", "infinity", "else", "_dev", "dev", "if", "local", "is", "none", "versions", "without", "a", "local", "segment", "should", "sort", "before", "those", "with", "one", "_local", "localtype", "negativeinfinity", "else", "versions", "with", "a", "local", "segment", "need", "that", "segment", "parsed", "to", "implement", "the", "sorting", "rules", "in", "pep440", "alpha", "numeric", "segments", "sort", "before", "numeric", "segments", "alpha", "numeric", "segments", "sort", "lexicographically", "numeric", "segments", "sort", "numerically", "shorter", "versions", "sort", "before", "longer", "versions", "when", "the", "prefixes", "match", "exactly", "_local", "tuple", "i", "if", "isinstance", "i", "int", "else", "negativeinfinity", "i", "for", "i", "in", "local", "return", "epoch", "_release", "_pre", "_post", "_dev", "_local"], "doc_len": 328}
{"doc_id": "seaborn/_core/data.py::PlotData.__init__", "file_path": "seaborn/_core/data.py", "class_name": "PlotData", "func_name": "__init__", "text": "文件路径: seaborn/_core/data.py, 类名: PlotData\n    def __init__(\n        self,\n        data: DataSource,\n        variables: dict[str, VariableSpec],\n    ):\n\n        frame, names, ids = self._assign_variables(data, variables)\n\n        self.frame = frame\n        self.names = names\n        self.ids = ids\n\n        self.frames = {}  # TODO this is a hack, remove\n\n        self.source_data = data\n        self.source_vars = variables\n", "tokens": ["seaborn", "_core", "data", "py", "plotdata", "def", "__init__", "self", "data", "datasource", "variables", "dict", "str", "variablespec", "frame", "names", "ids", "self", "_assign_variables", "data", "variables", "self", "frame", "frame", "self", "names", "names", "self", "ids", "ids", "self", "frames", "todo", "this", "is", "a", "hack", "remove", "self", "source_data", "data", "self", "source_vars", "variables"], "doc_len": 44}
{"doc_id": "seaborn/_core/data.py::PlotData.__contains__", "file_path": "seaborn/_core/data.py", "class_name": "PlotData", "func_name": "__contains__", "text": "文件路径: seaborn/_core/data.py, 类名: PlotData\n    def __contains__(self, key: str) -> bool:\n        \"\"\"Boolean check on whether a variable is defined in this dataset.\"\"\"\n        if self.frame is None:\n            return any(key in df for df in self.frames.values())\n        return key in self.frame\n", "tokens": ["seaborn", "_core", "data", "py", "plotdata", "def", "__contains__", "self", "key", "str", "bool", "boolean", "check", "on", "whether", "a", "variable", "is", "defined", "in", "this", "dataset", "if", "self", "frame", "is", "none", "return", "any", "key", "in", "df", "for", "df", "in", "self", "frames", "values", "return", "key", "in", "self", "frame"], "doc_len": 43}
{"doc_id": "seaborn/_core/data.py::PlotData.join", "file_path": "seaborn/_core/data.py", "class_name": "PlotData", "func_name": "join", "text": "文件路径: seaborn/_core/data.py, 类名: PlotData\n    def join(\n        self,\n        data: DataSource,\n        variables: dict[str, VariableSpec] | None,\n    ) -> PlotData:\n        \"\"\"Add, replace, or drop variables and return as a new dataset.\"\"\"\n        # Inherit the original source of the upsteam data by default\n        if data is None:\n            data = self.source_data\n\n        # TODO allow `data` to be a function (that is called on the source data?)\n\n        if not variables:\n            variables = self.source_vars\n\n        # Passing var=None implies that we do not want that variable in this layer\n        disinherit = [k for k, v in variables.items() if v is None]\n\n        # Create a new dataset with just the info passed here\n        new = PlotData(data, variables)\n\n        # -- Update the inherited DataSource with this new information\n\n        drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]\n        parts = [self.frame.drop(columns=drop_cols), new.frame]\n\n        # Because we are combining distinct columns, this is perhaps more\n        # naturally thought of as a \"merge\"/\"join\". But using concat because\n        # some simple testing suggests that it is marginally faster.\n        frame = pd.concat(parts, axis=1, sort=False, copy=False)\n\n        names = {k: v for k, v in self.names.items() if k not in disinherit}\n        names.update(new.names)\n\n        ids = {k: v for k, v in self.ids.items() if k not in disinherit}\n        ids.update(new.ids)\n\n        new.frame = frame\n        new.names = names\n        new.ids = ids\n\n        # Multiple chained operations should always inherit from the original object\n        new.source_data = self.source_data\n        new.source_vars = self.source_vars\n\n        return new\n", "tokens": ["seaborn", "_core", "data", "py", "plotdata", "def", "join", "self", "data", "datasource", "variables", "dict", "str", "variablespec", "none", "plotdata", "add", "replace", "or", "drop", "variables", "and", "return", "as", "a", "new", "dataset", "inherit", "the", "original", "source", "of", "the", "upsteam", "data", "by", "default", "if", "data", "is", "none", "data", "self", "source_data", "todo", "allow", "data", "to", "be", "a", "function", "that", "is", "called", "on", "the", "source", "data", "if", "not", "variables", "variables", "self", "source_vars", "passing", "var", "none", "implies", "that", "we", "do", "not", "want", "that", "variable", "in", "this", "layer", "disinherit", "k", "for", "k", "v", "in", "variables", "items", "if", "v", "is", "none", "create", "a", "new", "dataset", "with", "just", "the", "info", "passed", "here", "new", "plotdata", "data", "variables", "update", "the", "inherited", "datasource", "with", "this", "new", "information", "drop_cols", "k", "for", "k", "in", "self", "frame", "if", "k", "in", "new", "frame", "or", "k", "in", "disinherit", "parts", "self", "frame", "drop", "columns", "drop_cols", "new", "frame", "because", "we", "are", "combining", "distinct", "columns", "this", "is", "perhaps", "more", "naturally", "thought", "of", "as", "a", "merge", "join", "but", "using", "concat", "because", "some", "simple", "testing", "suggests", "that", "it", "is", "marginally", "faster", "frame", "pd", "concat", "parts", "axis", "1", "sort", "false", "copy", "false", "names", "k", "v", "for", "k", "v", "in", "self", "names", "items", "if", "k", "not", "in", "disinherit", "names", "update", "new", "names", "ids", "k", "v", "for", "k", "v", "in", "self", "ids", "items", "if", "k", "not", "in", "disinherit", "ids", "update", "new", "ids", "new", "frame", "frame", "new", "names", "names", "new", "ids", "ids", "multiple", "chained", "operations", "should", "always", "inherit", "from", "the", "original", "object", "new", "source_data", "self", "source_data", "new", "source_vars", "self", "source_vars", "return", "new"], "doc_len": 243}
{"doc_id": "seaborn/_core/data.py::PlotData._assign_variables", "file_path": "seaborn/_core/data.py", "class_name": "PlotData", "func_name": "_assign_variables", "text": "文件路径: seaborn/_core/data.py, 类名: PlotData\n    def _assign_variables(\n        self,\n        data: DataSource,\n        variables: dict[str, VariableSpec],\n    ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:\n        \"\"\"\n        Assign values for plot variables given long-form data and/or vector inputs.\n\n        Parameters\n        ----------\n        data\n            Input data where variable names map to vector values.\n        variables\n            Keys are names of plot variables (x, y, ...) each value is one of:\n\n            - name of a column (or index level, or dictionary entry) in `data`\n            - vector in any format that can construct a :class:`pandas.DataFrame`\n\n        Returns\n        -------\n        frame\n            Table mapping seaborn variables (x, y, color, ...) to data vectors.\n        names\n            Keys are defined seaborn variables; values are names inferred from\n            the inputs (or None when no name can be determined).\n        ids\n            Like the `names` dict, but `None` values are replaced by the `id()`\n            of the data object that defined the variable.\n\n        Raises\n        ------\n        ValueError\n            When variables are strings that don't appear in `data`, or when they are\n            non-indexed vector datatypes that have a different length from `data`.\n\n        \"\"\"\n        source_data: Mapping | DataFrame\n        frame: DataFrame\n        names: dict[str, str | None]\n        ids: dict[str, str | int]\n\n        plot_data = {}\n        names = {}\n        ids = {}\n\n        given_data = data is not None\n        if data is not None:\n            source_data = data\n        else:\n            # Data is optional; all variables can be defined as vectors\n            # But simplify downstream code by always having a usable source data object\n            source_data = {}\n\n        # TODO Generally interested in accepting a generic DataFrame interface\n        # Track https://data-apis.org/ for development\n\n        # Variables can also be extracted from the index of a DataFrame\n        if isinstance(source_data, pd.DataFrame):\n            index = source_data.index.to_frame().to_dict(\"series\")\n        else:\n            index = {}\n\n        for key, val in variables.items():\n\n            # Simply ignore variables with no specification\n            if val is None:\n                continue\n\n            # Try to treat the argument as a key for the data collection.\n            # But be flexible about what can be used as a key.\n            # Usually it will be a string, but allow other hashables when\n            # taking from the main data object. Allow only strings to reference\n            # fields in the index, because otherwise there is too much ambiguity.\n\n            # TODO this will be rendered unnecessary by the following pandas fix:\n            # https://github.com/pandas-dev/pandas/pull/41283\n            try:\n                hash(val)\n                val_is_hashable = True\n            except TypeError:\n                val_is_hashable = False\n\n            val_as_data_key = (\n                # See https://github.com/pandas-dev/pandas/pull/41283\n                # (isinstance(val, abc.Hashable) and val in source_data)\n                (val_is_hashable and val in source_data)\n                or (isinstance(val, str) and val in index)\n            )\n\n            if val_as_data_key:\n                val = cast(ColumnName, val)\n                if val in source_data:\n                    plot_data[key] = source_data[val]\n                elif val in index:\n                    plot_data[key] = index[val]\n                names[key] = ids[key] = str(val)\n\n            elif isinstance(val, str):\n\n                # This looks like a column name but, lookup failed.\n\n                err = f\"Could not interpret value `{val}` for `{key}`. \"\n                if not given_data:\n                    err += \"Value is a string, but `data` was not passed.\"\n                else:\n                    err += \"An entry with this name does not appear in `data`.\"\n                raise ValueError(err)\n\n            else:\n\n                # Otherwise, assume the value somehow represents data\n\n                # Ignore empty data structures\n                if isinstance(val, Sized) and len(val) == 0:\n                    continue\n\n                # If vector has no index, it must match length of data table\n                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):\n                    if isinstance(val, Sized) and len(data) != len(val):\n                        val_cls = val.__class__.__name__\n                        err = (\n                            f\"Length of {val_cls} vectors must match length of `data`\"\n                            f\" when both are used, but `data` has length {len(data)}\"\n                            f\" and the vector passed to `{key}` has length {len(val)}.\"\n                        )\n                        raise ValueError(err)\n\n                plot_data[key] = val\n\n                # Try to infer the original name using pandas-like metadata\n                if hasattr(val, \"name\"):\n                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424\n                else:\n                    names[key] = None\n                    ids[key] = id(val)\n\n        # Construct a tidy plot DataFrame. This will convert a number of\n        # types automatically, aligning on index in case of pandas objects\n        # TODO Note: this fails when variable specs *only* have scalars!\n        frame = pd.DataFrame(plot_data)\n\n        return frame, names, ids\n", "tokens": ["seaborn", "_core", "data", "py", "plotdata", "def", "_assign_variables", "self", "data", "datasource", "variables", "dict", "str", "variablespec", "tuple", "dataframe", "dict", "str", "str", "none", "dict", "str", "str", "int", "assign", "values", "for", "plot", "variables", "given", "long", "form", "data", "and", "or", "vector", "inputs", "parameters", "data", "input", "data", "where", "variable", "names", "map", "to", "vector", "values", "variables", "keys", "are", "names", "of", "plot", "variables", "x", "y", "each", "value", "is", "one", "of", "name", "of", "a", "column", "or", "index", "level", "or", "dictionary", "entry", "in", "data", "vector", "in", "any", "format", "that", "can", "construct", "a", "class", "pandas", "dataframe", "returns", "frame", "table", "mapping", "seaborn", "variables", "x", "y", "color", "to", "data", "vectors", "names", "keys", "are", "defined", "seaborn", "variables", "values", "are", "names", "inferred", "from", "the", "inputs", "or", "none", "when", "no", "name", "can", "be", "determined", "ids", "like", "the", "names", "dict", "but", "none", "values", "are", "replaced", "by", "the", "id", "of", "the", "data", "object", "that", "defined", "the", "variable", "raises", "valueerror", "when", "variables", "are", "strings", "that", "don", "t", "appear", "in", "data", "or", "when", "they", "are", "non", "indexed", "vector", "datatypes", "that", "have", "a", "different", "length", "from", "data", "source_data", "mapping", "dataframe", "frame", "dataframe", "names", "dict", "str", "str", "none", "ids", "dict", "str", "str", "int", "plot_data", "names", "ids", "given_data", "data", "is", "not", "none", "if", "data", "is", "not", "none", "source_data", "data", "else", "data", "is", "optional", "all", "variables", "can", "be", "defined", "as", "vectors", "but", "simplify", "downstream", "code", "by", "always", "having", "a", "usable", "source", "data", "object", "source_data", "todo", "generally", "interested", "in", "accepting", "a", "generic", "dataframe", "interface", "track", "https", "data", "apis", "org", "for", "development", "variables", "can", "also", "be", "extracted", "from", "the", "index", "of", "a", "dataframe", "if", "isinstance", "source_data", "pd", "dataframe", "index", "source_data", "index", "to_frame", "to_dict", "series", "else", "index", "for", "key", "val", "in", "variables", "items", "simply", "ignore", "variables", "with", "no", "specification", "if", "val", "is", "none", "continue", "try", "to", "treat", "the", "argument", "as", "a", "key", "for", "the", "data", "collection", "but", "be", "flexible", "about", "what", "can", "be", "used", "as", "a", "key", "usually", "it", "will", "be", "a", "string", "but", "allow", "other", "hashables", "when", "taking", "from", "the", "main", "data", "object", "allow", "only", "strings", "to", "reference", "fields", "in", "the", "index", "because", "otherwise", "there", "is", "too", "much", "ambiguity", "todo", "this", "will", "be", "rendered", "unnecessary", "by", "the", "following", "pandas", "fix", "https", "github", "com", "pandas", "dev", "pandas", "pull", "41283", "try", "hash", "val", "val_is_hashable", "true", "except", "typeerror", "val_is_hashable", "false", "val_as_data_key", "see", "https", "github", "com", "pandas", "dev", "pandas", "pull", "41283", "isinstance", "val", "abc", "hashable", "and", "val", "in", "source_data", "val_is_hashable", "and", "val", "in", "source_data", "or", "isinstance", "val", "str", "and", "val", "in", "index", "if", "val_as_data_key", "val", "cast", "columnname", "val", "if", "val", "in", "source_data", "plot_data", "key", "source_data", "val", "elif", "val", "in", "index", "plot_data", "key", "index", "val", "names", "key", "ids", "key", "str", "val", "elif", "isinstance", "val", "str", "this", "looks", "like", "a", "column", "name", "but", "lookup", "failed", "err", "f", "could", "not", "interpret", "value", "val", "for", "key", "if", "not", "given_data", "err", "value", "is", "a", "string", "but", "data", "was", "not", "passed", "else", "err", "an", "entry", "with", "this", "name", "does", "not", "appear", "in", "data", "raise", "valueerror", "err", "else", "otherwise", "assume", "the", "value", "somehow", "represents", "data", "ignore", "empty", "data", "structures", "if", "isinstance", "val", "sized", "and", "len", "val", "0", "continue", "if", "vector", "has", "no", "index", "it", "must", "match", "length", "of", "data", "table", "if", "isinstance", "data", "pd", "dataframe", "and", "not", "isinstance", "val", "pd", "series", "if", "isinstance", "val", "sized", "and", "len", "data", "len", "val", "val_cls", "val", "__class__", "__name__", "err", "f", "length", "of", "val_cls", "vectors", "must", "match", "length", "of", "data", "f", "when", "both", "are", "used", "but", "data", "has", "length", "len", "data", "f", "and", "the", "vector", "passed", "to", "key", "has", "length", "len", "val", "raise", "valueerror", "err", "plot_data", "key", "val", "try", "to", "infer", "the", "original", "name", "using", "pandas", "like", "metadata", "if", "hasattr", "val", "name", "names", "key", "ids", "key", "str", "val", "name", "type", "ignore", "mypy", "1424", "else", "names", "key", "none", "ids", "key", "id", "val", "construct", "a", "tidy", "plot", "dataframe", "this", "will", "convert", "a", "number", "of", "types", "automatically", "aligning", "on", "index", "in", "case", "of", "pandas", "objects", "todo", "note", "this", "fails", "when", "variable", "specs", "only", "have", "scalars", "frame", "pd", "dataframe", "plot_data", "return", "frame", "names", "ids"], "doc_len": 638}
{"doc_id": "seaborn/_core/exceptions.py::PlotSpecError._during", "file_path": "seaborn/_core/exceptions.py", "class_name": "PlotSpecError", "func_name": "_during", "text": "文件路径: seaborn/_core/exceptions.py, 类名: PlotSpecError\n    def _during(cls, step: str, var: str = \"\") -> PlotSpecError:\n        \"\"\"\n        Initialize the class to report the failure of a specific operation.\n        \"\"\"\n        message = []\n        if var:\n            message.append(f\"{step} failed for the `{var}` variable.\")\n        else:\n            message.append(f\"{step} failed.\")\n        message.append(\"See the traceback above for more information.\")\n        return cls(\" \".join(message))\n", "tokens": ["seaborn", "_core", "exceptions", "py", "plotspecerror", "def", "_during", "cls", "step", "str", "var", "str", "plotspecerror", "initialize", "the", "class", "to", "report", "the", "failure", "of", "a", "specific", "operation", "message", "if", "var", "message", "append", "f", "step", "failed", "for", "the", "var", "variable", "else", "message", "append", "f", "step", "failed", "message", "append", "see", "the", "traceback", "above", "for", "more", "information", "return", "cls", "join", "message"], "doc_len": 55}
{"doc_id": "seaborn/_core/groupby.py::GroupBy.__init__", "file_path": "seaborn/_core/groupby.py", "class_name": "GroupBy", "func_name": "__init__", "text": "文件路径: seaborn/_core/groupby.py, 类名: GroupBy\n    def __init__(self, order: list[str] | dict[str, list | None]):\n        \"\"\"\n        Initialize the GroupBy from grouping variables and optional level orders.\n\n        Parameters\n        ----------\n        order\n            List of variable names or dict mapping names to desired level orders.\n            Level order values can be None to use default ordering rules. The\n            variables can include names that are not expected to appear in the\n            data; these will be dropped before the groups are defined.\n\n        \"\"\"\n        if not order:\n            raise ValueError(\"GroupBy requires at least one grouping variable\")\n\n        if isinstance(order, list):\n            order = {k: None for k in order}\n        self.order = order\n", "tokens": ["seaborn", "_core", "groupby", "py", "groupby", "def", "__init__", "self", "order", "list", "str", "dict", "str", "list", "none", "initialize", "the", "groupby", "from", "grouping", "variables", "and", "optional", "level", "orders", "parameters", "order", "list", "of", "variable", "names", "or", "dict", "mapping", "names", "to", "desired", "level", "orders", "level", "order", "values", "can", "be", "none", "to", "use", "default", "ordering", "rules", "the", "variables", "can", "include", "names", "that", "are", "not", "expected", "to", "appear", "in", "the", "data", "these", "will", "be", "dropped", "before", "the", "groups", "are", "defined", "if", "not", "order", "raise", "valueerror", "groupby", "requires", "at", "least", "one", "grouping", "variable", "if", "isinstance", "order", "list", "order", "k", "none", "for", "k", "in", "order", "self", "order", "order"], "doc_len": 99}
{"doc_id": "seaborn/_core/groupby.py::GroupBy._get_groups", "file_path": "seaborn/_core/groupby.py", "class_name": "GroupBy", "func_name": "_get_groups", "text": "文件路径: seaborn/_core/groupby.py, 类名: GroupBy\n    def _get_groups(\n        self, data: DataFrame\n    ) -> tuple[str | list[str], Index | MultiIndex]:\n        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"\n        levels = {}\n        for var, order in self.order.items():\n            if var in data:\n                if order is None:\n                    order = categorical_order(data[var])\n                levels[var] = order\n\n        grouper: str | list[str]\n        groups: Index | MultiIndex\n        if not levels:\n            grouper = []\n            groups = pd.Index([])\n        elif len(levels) > 1:\n            grouper = list(levels)\n            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)\n        else:\n            grouper, = list(levels)\n            groups = pd.Index(levels[grouper], name=grouper)\n        return grouper, groups\n", "tokens": ["seaborn", "_core", "groupby", "py", "groupby", "def", "_get_groups", "self", "data", "dataframe", "tuple", "str", "list", "str", "index", "multiindex", "return", "index", "with", "cartesian", "product", "of", "ordered", "grouping", "variable", "levels", "levels", "for", "var", "order", "in", "self", "order", "items", "if", "var", "in", "data", "if", "order", "is", "none", "order", "categorical_order", "data", "var", "levels", "var", "order", "grouper", "str", "list", "str", "groups", "index", "multiindex", "if", "not", "levels", "grouper", "groups", "pd", "index", "elif", "len", "levels", "1", "grouper", "list", "levels", "groups", "pd", "multiindex", "from_product", "levels", "values", "names", "grouper", "else", "grouper", "list", "levels", "groups", "pd", "index", "levels", "grouper", "name", "grouper", "return", "grouper", "groups"], "doc_len": 92}
{"doc_id": "seaborn/_core/groupby.py::GroupBy._reorder_columns", "file_path": "seaborn/_core/groupby.py", "class_name": "GroupBy", "func_name": "_reorder_columns", "text": "文件路径: seaborn/_core/groupby.py, 类名: GroupBy\n    def _reorder_columns(self, res, data):\n        \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"\n        cols = [c for c in data if c in res]\n        cols += [c for c in res if c not in data]\n        return res.reindex(columns=pd.Index(cols))\n", "tokens": ["seaborn", "_core", "groupby", "py", "groupby", "def", "_reorder_columns", "self", "res", "data", "reorder", "result", "columns", "to", "match", "original", "order", "with", "new", "columns", "appended", "cols", "c", "for", "c", "in", "data", "if", "c", "in", "res", "cols", "c", "for", "c", "in", "res", "if", "c", "not", "in", "data", "return", "res", "reindex", "columns", "pd", "index", "cols"], "doc_len": 49}
{"doc_id": "seaborn/_core/groupby.py::GroupBy.agg", "file_path": "seaborn/_core/groupby.py", "class_name": "GroupBy", "func_name": "agg", "text": "文件路径: seaborn/_core/groupby.py, 类名: GroupBy\n    def agg(self, data: DataFrame, *args, **kwargs) -> DataFrame:\n        \"\"\"\n        Reduce each group to a single row in the output.\n\n        The output will have a row for each unique combination of the grouping\n        variable levels with null values for the aggregated variable(s) where\n        those combinations do not appear in the dataset.\n\n        \"\"\"\n        grouper, groups = self._get_groups(data)\n\n        if not grouper:\n            # We will need to see whether there are valid usecases that end up here\n            raise ValueError(\"No grouping variables are present in dataframe\")\n\n        res = (\n            data\n            .groupby(grouper, sort=False, observed=True)\n            .agg(*args, **kwargs)\n            .reindex(groups)\n            .reset_index()\n            .pipe(self._reorder_columns, data)\n        )\n\n        return res\n", "tokens": ["seaborn", "_core", "groupby", "py", "groupby", "def", "agg", "self", "data", "dataframe", "args", "kwargs", "dataframe", "reduce", "each", "group", "to", "a", "single", "row", "in", "the", "output", "the", "output", "will", "have", "a", "row", "for", "each", "unique", "combination", "of", "the", "grouping", "variable", "levels", "with", "null", "values", "for", "the", "aggregated", "variable", "s", "where", "those", "combinations", "do", "not", "appear", "in", "the", "dataset", "grouper", "groups", "self", "_get_groups", "data", "if", "not", "grouper", "we", "will", "need", "to", "see", "whether", "there", "are", "valid", "usecases", "that", "end", "up", "here", "raise", "valueerror", "no", "grouping", "variables", "are", "present", "in", "dataframe", "res", "data", "groupby", "grouper", "sort", "false", "observed", "true", "agg", "args", "kwargs", "reindex", "groups", "reset_index", "pipe", "self", "_reorder_columns", "data", "return", "res"], "doc_len": 106}
{"doc_id": "seaborn/_core/groupby.py::GroupBy.apply", "file_path": "seaborn/_core/groupby.py", "class_name": "GroupBy", "func_name": "apply", "text": "文件路径: seaborn/_core/groupby.py, 类名: GroupBy\n    def apply(\n        self, data: DataFrame, func: Callable[..., DataFrame],\n        *args, **kwargs,\n    ) -> DataFrame:\n        \"\"\"Apply a DataFrame -> DataFrame mapping to each group.\"\"\"\n        grouper, groups = self._get_groups(data)\n\n        if not grouper:\n            return self._reorder_columns(func(data, *args, **kwargs), data)\n\n        parts = {}\n        for key, part_df in data.groupby(grouper, sort=False):\n            parts[key] = func(part_df, *args, **kwargs)\n        stack = []\n        for key in groups:\n            if key in parts:\n                if isinstance(grouper, list):\n                    # Implies that we had a MultiIndex so key is iterable\n                    group_ids = dict(zip(grouper, cast(Iterable, key)))\n                else:\n                    group_ids = {grouper: key}\n                stack.append(parts[key].assign(**group_ids))\n\n        res = pd.concat(stack, ignore_index=True)\n        return self._reorder_columns(res, data)\n", "tokens": ["seaborn", "_core", "groupby", "py", "groupby", "def", "apply", "self", "data", "dataframe", "func", "callable", "dataframe", "args", "kwargs", "dataframe", "apply", "a", "dataframe", "dataframe", "mapping", "to", "each", "group", "grouper", "groups", "self", "_get_groups", "data", "if", "not", "grouper", "return", "self", "_reorder_columns", "func", "data", "args", "kwargs", "data", "parts", "for", "key", "part_df", "in", "data", "groupby", "grouper", "sort", "false", "parts", "key", "func", "part_df", "args", "kwargs", "stack", "for", "key", "in", "groups", "if", "key", "in", "parts", "if", "isinstance", "grouper", "list", "implies", "that", "we", "had", "a", "multiindex", "so", "key", "is", "iterable", "group_ids", "dict", "zip", "grouper", "cast", "iterable", "key", "else", "group_ids", "grouper", "key", "stack", "append", "parts", "key", "assign", "group_ids", "res", "pd", "concat", "stack", "ignore_index", "true", "return", "self", "_reorder_columns", "res", "data"], "doc_len": 107}
{"doc_id": "seaborn/_core/moves.py::Move.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Move", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Move\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n        raise NotImplementedError\n", "tokens": ["seaborn", "_core", "moves", "py", "move", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "raise", "notimplementederror"], "doc_len": 21}
{"doc_id": "seaborn/_core/moves.py::Jitter.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Jitter", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Jitter\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        data = data.copy()\n        rng = np.random.default_rng(self.seed)\n\n        def jitter(data, col, scale):\n            noise = rng.uniform(-.5, +.5, len(data))\n            offsets = noise * scale\n            return data[col] + offsets\n\n        if self.width is default:\n            width = 0.0 if self.x or self.y else 0.2\n        else:\n            width = cast(float, self.width)\n\n        if self.width:\n            data[orient] = jitter(data, orient, width * data[\"width\"])\n        if self.x:\n            data[\"x\"] = jitter(data, \"x\", self.x)\n        if self.y:\n            data[\"y\"] = jitter(data, \"y\", self.y)\n\n        return data\n", "tokens": ["seaborn", "_core", "moves", "py", "jitter", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "data", "data", "copy", "rng", "np", "random", "default_rng", "self", "seed", "def", "jitter", "data", "col", "scale", "noise", "rng", "uniform", "5", "5", "len", "data", "offsets", "noise", "scale", "return", "data", "col", "offsets", "if", "self", "width", "is", "default", "width", "0", "0", "if", "self", "x", "or", "self", "y", "else", "0", "2", "else", "width", "cast", "float", "self", "width", "if", "self", "width", "data", "orient", "jitter", "data", "orient", "width", "data", "width", "if", "self", "x", "data", "x", "jitter", "data", "x", "self", "x", "if", "self", "y", "data", "y", "jitter", "data", "y", "self", "y", "return", "data"], "doc_len": 103}
{"doc_id": "seaborn/_core/moves.py::Dodge.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Dodge", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Dodge\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        grouping_vars = [v for v in groupby.order if v in data]\n        groups = groupby.agg(data, {\"width\": \"max\"})\n        if self.empty == \"fill\":\n            groups = groups.dropna()\n\n        def groupby_pos(s):\n            grouper = [groups[v] for v in [orient, \"col\", \"row\"] if v in data]\n            return s.groupby(grouper, sort=False, observed=True)\n\n        def scale_widths(w):\n            # TODO what value to fill missing widths??? Hard problem...\n            # TODO short circuit this if outer widths has no variance?\n            empty = 0 if self.empty == \"fill\" else w.mean()\n            filled = w.fillna(empty)\n            scale = filled.max()\n            norm = filled.sum()\n            if self.empty == \"keep\":\n                w = filled\n            return w / norm * scale\n\n        def widths_to_offsets(w):\n            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2\n\n        new_widths = groupby_pos(groups[\"width\"]).transform(scale_widths)\n        offsets = groupby_pos(new_widths).transform(widths_to_offsets)\n\n        if self.gap:\n            new_widths *= 1 - self.gap\n\n        groups[\"_dodged\"] = groups[orient] + offsets\n        groups[\"width\"] = new_widths\n\n        out = (\n            data\n            .drop(\"width\", axis=1)\n            .merge(groups, on=grouping_vars, how=\"left\")\n            .drop(orient, axis=1)\n            .rename(columns={\"_dodged\": orient})\n        )\n\n        return out\n", "tokens": ["seaborn", "_core", "moves", "py", "dodge", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "grouping_vars", "v", "for", "v", "in", "groupby", "order", "if", "v", "in", "data", "groups", "groupby", "agg", "data", "width", "max", "if", "self", "empty", "fill", "groups", "groups", "dropna", "def", "groupby_pos", "s", "grouper", "groups", "v", "for", "v", "in", "orient", "col", "row", "if", "v", "in", "data", "return", "s", "groupby", "grouper", "sort", "false", "observed", "true", "def", "scale_widths", "w", "todo", "what", "value", "to", "fill", "missing", "widths", "hard", "problem", "todo", "short", "circuit", "this", "if", "outer", "widths", "has", "no", "variance", "empty", "0", "if", "self", "empty", "fill", "else", "w", "mean", "filled", "w", "fillna", "empty", "scale", "filled", "max", "norm", "filled", "sum", "if", "self", "empty", "keep", "w", "filled", "return", "w", "norm", "scale", "def", "widths_to_offsets", "w", "return", "w", "shift", "1", "fillna", "0", "cumsum", "w", "w", "sum", "2", "new_widths", "groupby_pos", "groups", "width", "transform", "scale_widths", "offsets", "groupby_pos", "new_widths", "transform", "widths_to_offsets", "if", "self", "gap", "new_widths", "1", "self", "gap", "groups", "_dodged", "groups", "orient", "offsets", "groups", "width", "new_widths", "out", "data", "drop", "width", "axis", "1", "merge", "groups", "on", "grouping_vars", "how", "left", "drop", "orient", "axis", "1", "rename", "columns", "_dodged", "orient", "return", "out"], "doc_len": 180}
{"doc_id": "seaborn/_core/moves.py::Stack._stack", "file_path": "seaborn/_core/moves.py", "class_name": "Stack", "func_name": "_stack", "text": "文件路径: seaborn/_core/moves.py, 类名: Stack\n    def _stack(self, df, orient):\n\n        # TODO should stack do something with ymin/ymax style marks?\n        # Should there be an upstream conversion to baseline/height parameterization?\n\n        if df[\"baseline\"].nunique() > 1:\n            err = \"Stack move cannot be used when baselines are already heterogeneous\"\n            raise RuntimeError(err)\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        stacked_lengths = (df[other] - df[\"baseline\"]).dropna().cumsum()\n        offsets = stacked_lengths.shift(1).fillna(0)\n\n        df[other] = stacked_lengths\n        df[\"baseline\"] = df[\"baseline\"] + offsets\n\n        return df\n", "tokens": ["seaborn", "_core", "moves", "py", "stack", "def", "_stack", "self", "df", "orient", "todo", "should", "stack", "do", "something", "with", "ymin", "ymax", "style", "marks", "should", "there", "be", "an", "upstream", "conversion", "to", "baseline", "height", "parameterization", "if", "df", "baseline", "nunique", "1", "err", "stack", "move", "cannot", "be", "used", "when", "baselines", "are", "already", "heterogeneous", "raise", "runtimeerror", "err", "other", "x", "y", "y", "x", "orient", "stacked_lengths", "df", "other", "df", "baseline", "dropna", "cumsum", "offsets", "stacked_lengths", "shift", "1", "fillna", "0", "df", "other", "stacked_lengths", "df", "baseline", "df", "baseline", "offsets", "return", "df"], "doc_len": 78}
{"doc_id": "seaborn/_core/moves.py::Stack.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Stack", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Stack\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        # TODO where to ensure that other semantic variables are sorted properly?\n        # TODO why are we not using the passed in groupby here?\n        groupers = [\"col\", \"row\", orient]\n        return GroupBy(groupers).apply(data, self._stack, orient)\n", "tokens": ["seaborn", "_core", "moves", "py", "stack", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "todo", "where", "to", "ensure", "that", "other", "semantic", "variables", "are", "sorted", "properly", "todo", "why", "are", "we", "not", "using", "the", "passed", "in", "groupby", "here", "groupers", "col", "row", "orient", "return", "groupby", "groupers", "apply", "data", "self", "_stack", "orient"], "doc_len": 53}
{"doc_id": "seaborn/_core/moves.py::Shift.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Shift", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Shift\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        data = data.copy(deep=False)\n        data[\"x\"] = data[\"x\"] + self.x\n        data[\"y\"] = data[\"y\"] + self.y\n        return data\n", "tokens": ["seaborn", "_core", "moves", "py", "shift", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "data", "data", "copy", "deep", "false", "data", "x", "data", "x", "self", "x", "data", "y", "data", "y", "self", "y", "return", "data"], "doc_len": 38}
{"doc_id": "seaborn/_core/moves.py::Norm._norm", "file_path": "seaborn/_core/moves.py", "class_name": "Norm", "func_name": "_norm", "text": "文件路径: seaborn/_core/moves.py, 类名: Norm\n    def _norm(self, df, var):\n\n        if self.where is None:\n            denom_data = df[var]\n        else:\n            denom_data = df.query(self.where)[var]\n        df[var] = df[var] / denom_data.agg(self.func)\n\n        if self.percent:\n            df[var] = df[var] * 100\n\n        return df\n", "tokens": ["seaborn", "_core", "moves", "py", "norm", "def", "_norm", "self", "df", "var", "if", "self", "where", "is", "none", "denom_data", "df", "var", "else", "denom_data", "df", "query", "self", "where", "var", "df", "var", "df", "var", "denom_data", "agg", "self", "func", "if", "self", "percent", "df", "var", "df", "var", "100", "return", "df"], "doc_len": 43}
{"doc_id": "seaborn/_core/moves.py::Norm.__call__", "file_path": "seaborn/_core/moves.py", "class_name": "Norm", "func_name": "__call__", "text": "文件路径: seaborn/_core/moves.py, 类名: Norm\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        return groupby.apply(data, self._norm, other)\n", "tokens": ["seaborn", "_core", "moves", "py", "norm", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "other", "x", "y", "y", "x", "orient", "return", "groupby", "apply", "data", "self", "_norm", "other"], "doc_len": 32}
{"doc_id": "seaborn/_core/plot.py::theme_context", "file_path": "seaborn/_core/plot.py", "class_name": null, "func_name": "theme_context", "text": "文件路径: seaborn/_core/plot.py\ndef theme_context(params: dict[str, Any]) -> Generator:\n    \"\"\"Temporarily modify specifc matplotlib rcParams.\"\"\"\n    orig_params = {k: mpl.rcParams[k] for k in params}\n    color_codes = \"bgrmyck\"\n    nice_colors = [*color_palette(\"deep6\"), (.15, .15, .15)]\n    orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]\n    # TODO how to allow this to reflect the color cycle when relevant?\n    try:\n        mpl.rcParams.update(params)\n        for (code, color) in zip(color_codes, nice_colors):\n            mpl.colors.colorConverter.colors[code] = color\n            mpl.colors.colorConverter.cache[code] = color\n        yield\n    finally:\n        mpl.rcParams.update(orig_params)\n        for (code, color) in zip(color_codes, orig_colors):\n            mpl.colors.colorConverter.colors[code] = color\n            mpl.colors.colorConverter.cache[code] = color\n", "tokens": ["seaborn", "_core", "plot", "py", "def", "theme_context", "params", "dict", "str", "any", "generator", "temporarily", "modify", "specifc", "matplotlib", "rcparams", "orig_params", "k", "mpl", "rcparams", "k", "for", "k", "in", "params", "color_codes", "bgrmyck", "nice_colors", "color_palette", "deep6", "15", "15", "15", "orig_colors", "mpl", "colors", "colorconverter", "colors", "x", "for", "x", "in", "color_codes", "todo", "how", "to", "allow", "this", "to", "reflect", "the", "color", "cycle", "when", "relevant", "try", "mpl", "rcparams", "update", "params", "for", "code", "color", "in", "zip", "color_codes", "nice_colors", "mpl", "colors", "colorconverter", "colors", "code", "color", "mpl", "colors", "colorconverter", "cache", "code", "color", "yield", "finally", "mpl", "rcparams", "update", "orig_params", "for", "code", "color", "in", "zip", "color_codes", "orig_colors", "mpl", "colors", "colorconverter", "colors", "code", "color", "mpl", "colors", "colorconverter", "cache", "code", "color"], "doc_len": 104}
{"doc_id": "seaborn/_core/plot.py::build_plot_signature", "file_path": "seaborn/_core/plot.py", "class_name": null, "func_name": "build_plot_signature", "text": "文件路径: seaborn/_core/plot.py\ndef build_plot_signature(cls):\n    \"\"\"\n    Decorator function for giving Plot a useful signature.\n\n    Currently this mostly saves us some duplicated typing, but we would\n    like eventually to have a way of registering new semantic properties,\n    at which point dynamic signature generation would become more important.\n\n    \"\"\"\n    sig = inspect.signature(cls)\n    params = [\n        inspect.Parameter(\"args\", inspect.Parameter.VAR_POSITIONAL),\n        inspect.Parameter(\"data\", inspect.Parameter.KEYWORD_ONLY, default=None)\n    ]\n    params.extend([\n        inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)\n        for name in PROPERTIES\n    ])\n    new_sig = sig.replace(parameters=params)\n    cls.__signature__ = new_sig\n\n    known_properties = textwrap.fill(\n        \", \".join([f\"|{p}|\" for p in PROPERTIES]),\n        width=78, subsequent_indent=\" \" * 8,\n    )\n\n    if cls.__doc__ is not None:  # support python -OO mode\n        cls.__doc__ = cls.__doc__.format(known_properties=known_properties)\n\n    return cls\n", "tokens": ["seaborn", "_core", "plot", "py", "def", "build_plot_signature", "cls", "decorator", "function", "for", "giving", "plot", "a", "useful", "signature", "currently", "this", "mostly", "saves", "us", "some", "duplicated", "typing", "but", "we", "would", "like", "eventually", "to", "have", "a", "way", "of", "registering", "new", "semantic", "properties", "at", "which", "point", "dynamic", "signature", "generation", "would", "become", "more", "important", "sig", "inspect", "signature", "cls", "params", "inspect", "parameter", "args", "inspect", "parameter", "var_positional", "inspect", "parameter", "data", "inspect", "parameter", "keyword_only", "default", "none", "params", "extend", "inspect", "parameter", "name", "inspect", "parameter", "keyword_only", "default", "none", "for", "name", "in", "properties", "new_sig", "sig", "replace", "parameters", "params", "cls", "__signature__", "new_sig", "known_properties", "textwrap", "fill", "join", "f", "p", "for", "p", "in", "properties", "width", "78", "subsequent_indent", "8", "if", "cls", "__doc__", "is", "not", "none", "support", "python", "oo", "mode", "cls", "__doc__", "cls", "__doc__", "format", "known_properties", "known_properties", "return", "cls"], "doc_len": 121}
{"doc_id": "seaborn/_core/plot.py::Plot.__init__", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "__init__", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def __init__(\n        self,\n        *args: DataSource | VariableSpec,\n        data: DataSource = None,\n        **variables: VariableSpec,\n    ):\n\n        if args:\n            data, variables = self._resolve_positionals(args, data, variables)\n\n        unknown = [x for x in variables if x not in PROPERTIES]\n        if unknown:\n            err = f\"Plot() got unexpected keyword argument(s): {', '.join(unknown)}\"\n            raise TypeError(err)\n\n        self._data = PlotData(data, variables)\n\n        self._layers = []\n\n        self._scales = {}\n        self._shares = {}\n        self._limits = {}\n        self._labels = {}\n        self._theme = {}\n\n        self._facet_spec = {}\n        self._pair_spec = {}\n\n        self._figure_spec = {}\n        self._subplot_spec = {}\n        self._layout_spec = {}\n\n        self._target = None\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "__init__", "self", "args", "datasource", "variablespec", "data", "datasource", "none", "variables", "variablespec", "if", "args", "data", "variables", "self", "_resolve_positionals", "args", "data", "variables", "unknown", "x", "for", "x", "in", "variables", "if", "x", "not", "in", "properties", "if", "unknown", "err", "f", "plot", "got", "unexpected", "keyword", "argument", "s", "join", "unknown", "raise", "typeerror", "err", "self", "_data", "plotdata", "data", "variables", "self", "_layers", "self", "_scales", "self", "_shares", "self", "_limits", "self", "_labels", "self", "_theme", "self", "_facet_spec", "self", "_pair_spec", "self", "_figure_spec", "self", "_subplot_spec", "self", "_layout_spec", "self", "_target", "none"], "doc_len": 81}
{"doc_id": "seaborn/_core/plot.py::Plot._resolve_positionals", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_resolve_positionals", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _resolve_positionals(\n        self,\n        args: tuple[DataSource | VariableSpec, ...],\n        data: DataSource,\n        variables: dict[str, VariableSpec],\n    ) -> tuple[DataSource, dict[str, VariableSpec]]:\n        \"\"\"Handle positional arguments, which may contain data / x / y.\"\"\"\n        if len(args) > 3:\n            err = \"Plot() accepts no more than 3 positional arguments (data, x, y).\"\n            raise TypeError(err)\n\n        # TODO need some clearer way to differentiate data / vector here\n        # (There might be an abstract DataFrame class to use here?)\n        if isinstance(args[0], (abc.Mapping, pd.DataFrame)):\n            if data is not None:\n                raise TypeError(\"`data` given by both name and position.\")\n            data, args = args[0], args[1:]\n\n        if len(args) == 2:\n            x, y = args\n        elif len(args) == 1:\n            x, y = *args, None\n        else:\n            x = y = None\n\n        for name, var in zip(\"yx\", (y, x)):\n            if var is not None:\n                if name in variables:\n                    raise TypeError(f\"`{name}` given by both name and position.\")\n                # Keep coordinates at the front of the variables dict\n                # Cast type because we know this isn't a DataSource at this point\n                variables = {name: cast(VariableSpec, var), **variables}\n\n        return data, variables\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_resolve_positionals", "self", "args", "tuple", "datasource", "variablespec", "data", "datasource", "variables", "dict", "str", "variablespec", "tuple", "datasource", "dict", "str", "variablespec", "handle", "positional", "arguments", "which", "may", "contain", "data", "x", "y", "if", "len", "args", "3", "err", "plot", "accepts", "no", "more", "than", "3", "positional", "arguments", "data", "x", "y", "raise", "typeerror", "err", "todo", "need", "some", "clearer", "way", "to", "differentiate", "data", "vector", "here", "there", "might", "be", "an", "abstract", "dataframe", "class", "to", "use", "here", "if", "isinstance", "args", "0", "abc", "mapping", "pd", "dataframe", "if", "data", "is", "not", "none", "raise", "typeerror", "data", "given", "by", "both", "name", "and", "position", "data", "args", "args", "0", "args", "1", "if", "len", "args", "2", "x", "y", "args", "elif", "len", "args", "1", "x", "y", "args", "none", "else", "x", "y", "none", "for", "name", "var", "in", "zip", "yx", "y", "x", "if", "var", "is", "not", "none", "if", "name", "in", "variables", "raise", "typeerror", "f", "name", "given", "by", "both", "name", "and", "position", "keep", "coordinates", "at", "the", "front", "of", "the", "variables", "dict", "cast", "type", "because", "we", "know", "this", "isn", "t", "a", "datasource", "at", "this", "point", "variables", "name", "cast", "variablespec", "var", "variables", "return", "data", "variables"], "doc_len": 176}
{"doc_id": "seaborn/_core/plot.py::Plot.__add__", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "__add__", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def __add__(self, other):\n\n        if isinstance(other, Mark) or isinstance(other, Stat):\n            raise TypeError(\"Sorry, this isn't ggplot! Perhaps try Plot.add?\")\n\n        other_type = other.__class__.__name__\n        raise TypeError(f\"Unsupported operand type(s) for +: 'Plot' and '{other_type}\")\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "__add__", "self", "other", "if", "isinstance", "other", "mark", "or", "isinstance", "other", "stat", "raise", "typeerror", "sorry", "this", "isn", "t", "ggplot", "perhaps", "try", "plot", "add", "other_type", "other", "__class__", "__name__", "raise", "typeerror", "f", "unsupported", "operand", "type", "s", "for", "plot", "and", "other_type"], "doc_len": 43}
{"doc_id": "seaborn/_core/plot.py::Plot._repr_png_", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_repr_png_", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:\n\n        return self.plot()._repr_png_()\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_repr_png_", "self", "tuple", "bytes", "dict", "str", "float", "return", "self", "plot", "_repr_png_"], "doc_len": 17}
{"doc_id": "seaborn/_core/plot.py::Plot._clone", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_clone", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _clone(self) -> Plot:\n        \"\"\"Generate a new object with the same information as the current spec.\"\"\"\n        new = Plot()\n\n        # TODO any way to enforce that data does not get mutated?\n        new._data = self._data\n\n        new._layers.extend(self._layers)\n\n        new._scales.update(self._scales)\n        new._shares.update(self._shares)\n        new._limits.update(self._limits)\n        new._labels.update(self._labels)\n        new._theme.update(self._theme)\n\n        new._facet_spec.update(self._facet_spec)\n        new._pair_spec.update(self._pair_spec)\n\n        new._figure_spec.update(self._figure_spec)\n        new._subplot_spec.update(self._subplot_spec)\n        new._layout_spec.update(self._layout_spec)\n\n        new._target = self._target\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_clone", "self", "plot", "generate", "a", "new", "object", "with", "the", "same", "information", "as", "the", "current", "spec", "new", "plot", "todo", "any", "way", "to", "enforce", "that", "data", "does", "not", "get", "mutated", "new", "_data", "self", "_data", "new", "_layers", "extend", "self", "_layers", "new", "_scales", "update", "self", "_scales", "new", "_shares", "update", "self", "_shares", "new", "_limits", "update", "self", "_limits", "new", "_labels", "update", "self", "_labels", "new", "_theme", "update", "self", "_theme", "new", "_facet_spec", "update", "self", "_facet_spec", "new", "_pair_spec", "update", "self", "_pair_spec", "new", "_figure_spec", "update", "self", "_figure_spec", "new", "_subplot_spec", "update", "self", "_subplot_spec", "new", "_layout_spec", "update", "self", "_layout_spec", "new", "_target", "self", "_target", "return", "new"], "doc_len": 99}
{"doc_id": "seaborn/_core/plot.py::Plot._theme_with_defaults", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_theme_with_defaults", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _theme_with_defaults(self) -> dict[str, Any]:\n\n        style_groups = [\n            \"axes\", \"figure\", \"font\", \"grid\", \"hatch\", \"legend\", \"lines\",\n            \"mathtext\", \"markers\", \"patch\", \"savefig\", \"scatter\",\n            \"xaxis\", \"xtick\", \"yaxis\", \"ytick\",\n        ]\n        base = {\n            k: mpl.rcParamsDefault[k] for k in mpl.rcParams\n            if any(k.startswith(p) for p in style_groups)\n        }\n        theme = {\n            **base,\n            **axes_style(\"darkgrid\"),\n            **plotting_context(\"notebook\"),\n            \"axes.prop_cycle\": cycler(\"color\", color_palette(\"deep\")),\n        }\n        theme.update(self._theme)\n        return theme\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_theme_with_defaults", "self", "dict", "str", "any", "style_groups", "axes", "figure", "font", "grid", "hatch", "legend", "lines", "mathtext", "markers", "patch", "savefig", "scatter", "xaxis", "xtick", "yaxis", "ytick", "base", "k", "mpl", "rcparamsdefault", "k", "for", "k", "in", "mpl", "rcparams", "if", "any", "k", "startswith", "p", "for", "p", "in", "style_groups", "theme", "base", "axes_style", "darkgrid", "plotting_context", "notebook", "axes", "prop_cycle", "cycler", "color", "color_palette", "deep", "theme", "update", "self", "_theme", "return", "theme"], "doc_len": 65}
{"doc_id": "seaborn/_core/plot.py::Plot._variables", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_variables", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _variables(self) -> list[str]:\n\n        variables = (\n            list(self._data.frame)\n            + list(self._pair_spec.get(\"variables\", []))\n            + list(self._facet_spec.get(\"variables\", []))\n        )\n        for layer in self._layers:\n            variables.extend(v for v in layer[\"vars\"] if v not in variables)\n\n        # Coerce to str in return to appease mypy; we know these will only\n        # ever be strings but I don't think we can type a DataFrame that way yet\n        return [str(v) for v in variables]\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_variables", "self", "list", "str", "variables", "list", "self", "_data", "frame", "list", "self", "_pair_spec", "get", "variables", "list", "self", "_facet_spec", "get", "variables", "for", "layer", "in", "self", "_layers", "variables", "extend", "v", "for", "v", "in", "layer", "vars", "if", "v", "not", "in", "variables", "coerce", "to", "str", "in", "return", "to", "appease", "mypy", "we", "know", "these", "will", "only", "ever", "be", "strings", "but", "i", "don", "t", "think", "we", "can", "type", "a", "dataframe", "that", "way", "yet", "return", "str", "v", "for", "v", "in", "variables"], "doc_len": 79}
{"doc_id": "seaborn/_core/plot.py::Plot.on", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "on", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def on(self, target: Axes | SubFigure | Figure) -> Plot:\n        \"\"\"\n        Provide existing Matplotlib figure or axes for drawing the plot.\n\n        When using this method, you will also need to explicitly call a method that\n        triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you\n        want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`\n        first to compile the plot without rendering it.\n\n        Parameters\n        ----------\n        target : Axes, SubFigure, or Figure\n            Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add\n            artists without otherwise modifying the figure. Otherwise, subplots will be\n            created within the space of the given :class:`matplotlib.figure.Figure` or\n            :class:`matplotlib.figure.SubFigure`.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.on.rst\n\n        \"\"\"\n        accepted_types: tuple  # Allow tuple of various length\n        if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4\n            accepted_types = (\n                mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure\n            )\n            accepted_types_str = (\n                f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"\n            )\n        else:\n            accepted_types = mpl.axes.Axes, mpl.figure.Figure\n            accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"\n\n        if not isinstance(target, accepted_types):\n            err = (\n                f\"The `Plot.on` target must be an instance of {accepted_types_str}. \"\n                f\"You passed an instance of {target.__class__} instead.\"\n            )\n            raise TypeError(err)\n\n        new = self._clone()\n        new._target = target\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "on", "self", "target", "axes", "subfigure", "figure", "plot", "provide", "existing", "matplotlib", "figure", "or", "axes", "for", "drawing", "the", "plot", "when", "using", "this", "method", "you", "will", "also", "need", "to", "explicitly", "call", "a", "method", "that", "triggers", "compilation", "such", "as", "meth", "plot", "show", "or", "meth", "plot", "save", "if", "you", "want", "to", "postprocess", "using", "matplotlib", "you", "d", "need", "to", "call", "meth", "plot", "plot", "first", "to", "compile", "the", "plot", "without", "rendering", "it", "parameters", "target", "axes", "subfigure", "or", "figure", "matplotlib", "object", "to", "use", "passing", "class", "matplotlib", "axes", "axes", "will", "add", "artists", "without", "otherwise", "modifying", "the", "figure", "otherwise", "subplots", "will", "be", "created", "within", "the", "space", "of", "the", "given", "class", "matplotlib", "figure", "figure", "or", "class", "matplotlib", "figure", "subfigure", "examples", "include", "docstrings", "objects", "plot", "on", "rst", "accepted_types", "tuple", "allow", "tuple", "of", "various", "length", "if", "hasattr", "mpl", "figure", "subfigure", "added", "in", "mpl", "3", "4", "accepted_types", "mpl", "axes", "axes", "mpl", "figure", "subfigure", "mpl", "figure", "figure", "accepted_types_str", "f", "mpl", "axes", "axes", "mpl", "figure", "subfigure", "or", "mpl", "figure", "figure", "else", "accepted_types", "mpl", "axes", "axes", "mpl", "figure", "figure", "accepted_types_str", "f", "mpl", "axes", "axes", "or", "mpl", "figure", "figure", "if", "not", "isinstance", "target", "accepted_types", "err", "f", "the", "plot", "on", "target", "must", "be", "an", "instance", "of", "accepted_types_str", "f", "you", "passed", "an", "instance", "of", "target", "__class__", "instead", "raise", "typeerror", "err", "new", "self", "_clone", "new", "_target", "target", "return", "new"], "doc_len": 214}
{"doc_id": "seaborn/_core/plot.py::Plot.add", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "add", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def add(\n        self,\n        mark: Mark,\n        *transforms: Stat | Mark,\n        orient: str | None = None,\n        legend: bool = True,\n        data: DataSource = None,\n        **variables: VariableSpec,\n    ) -> Plot:\n        \"\"\"\n        Specify a layer of the visualization in terms of mark and data transform(s).\n\n        This is the main method for specifying how the data should be visualized.\n        It can be called multiple times with different arguments to define\n        a plot with multiple layers.\n\n        Parameters\n        ----------\n        mark : :class:`Mark`\n            The visual representation of the data to use in this layer.\n        transforms : :class:`Stat` or :class:`Move`\n            Objects representing transforms to be applied before plotting the data.\n            Currently, at most one :class:`Stat` can be used, and it\n            must be passed first. This constraint will be relaxed in the future.\n        orient : \"x\", \"y\", \"v\", or \"h\"\n            The orientation of the mark, which also affects how transforms are computed.\n            Typically corresponds to the axis that defines groups for aggregation.\n            The \"v\" (vertical) and \"h\" (horizontal) options are synonyms for \"x\" / \"y\",\n            but may be more intuitive with some marks. When not provided, an\n            orientation will be inferred from characteristics of the data and scales.\n        legend : bool\n            Option to suppress the mark/mappings for this layer from the legend.\n        data : DataFrame or dict\n            Data source to override the global source provided in the constructor.\n        variables : data vectors or identifiers\n            Additional layer-specific variables, including variables that will be\n            passed directly to the transforms without scaling.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.add.rst\n\n        \"\"\"\n        if not isinstance(mark, Mark):\n            msg = f\"mark must be a Mark instance, not {type(mark)!r}.\"\n            raise TypeError(msg)\n\n        # TODO This API for transforms was a late decision, and previously Plot.add\n        # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.\n        # It will take some work to refactor the internals so that Stat and Move are\n        # treated identically, and until then well need to \"unpack\" the transforms\n        # here and enforce limitations on the order / types.\n\n        stat: Optional[Stat]\n        move: Optional[List[Move]]\n        error = False\n        if not transforms:\n            stat, move = None, None\n        elif isinstance(transforms[0], Stat):\n            stat = transforms[0]\n            move = [m for m in transforms[1:] if isinstance(m, Move)]\n            error = len(move) != len(transforms) - 1\n        else:\n            stat = None\n            move = [m for m in transforms if isinstance(m, Move)]\n            error = len(move) != len(transforms)\n\n        if error:\n            msg = \" \".join([\n                \"Transforms must have at most one Stat type (in the first position),\",\n                \"and all others must be a Move type. Given transform type(s):\",\n                \", \".join(str(type(t).__name__) for t in transforms) + \".\"\n            ])\n            raise TypeError(msg)\n\n        new = self._clone()\n        new._layers.append({\n            \"mark\": mark,\n            \"stat\": stat,\n            \"move\": move,\n            # TODO it doesn't work to supply scalars to variables, but it should\n            \"vars\": variables,\n            \"source\": data,\n            \"legend\": legend,\n            \"orient\": {\"v\": \"x\", \"h\": \"y\"}.get(orient, orient),  # type: ignore\n        })\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "add", "self", "mark", "mark", "transforms", "stat", "mark", "orient", "str", "none", "none", "legend", "bool", "true", "data", "datasource", "none", "variables", "variablespec", "plot", "specify", "a", "layer", "of", "the", "visualization", "in", "terms", "of", "mark", "and", "data", "transform", "s", "this", "is", "the", "main", "method", "for", "specifying", "how", "the", "data", "should", "be", "visualized", "it", "can", "be", "called", "multiple", "times", "with", "different", "arguments", "to", "define", "a", "plot", "with", "multiple", "layers", "parameters", "mark", "class", "mark", "the", "visual", "representation", "of", "the", "data", "to", "use", "in", "this", "layer", "transforms", "class", "stat", "or", "class", "move", "objects", "representing", "transforms", "to", "be", "applied", "before", "plotting", "the", "data", "currently", "at", "most", "one", "class", "stat", "can", "be", "used", "and", "it", "must", "be", "passed", "first", "this", "constraint", "will", "be", "relaxed", "in", "the", "future", "orient", "x", "y", "v", "or", "h", "the", "orientation", "of", "the", "mark", "which", "also", "affects", "how", "transforms", "are", "computed", "typically", "corresponds", "to", "the", "axis", "that", "defines", "groups", "for", "aggregation", "the", "v", "vertical", "and", "h", "horizontal", "options", "are", "synonyms", "for", "x", "y", "but", "may", "be", "more", "intuitive", "with", "some", "marks", "when", "not", "provided", "an", "orientation", "will", "be", "inferred", "from", "characteristics", "of", "the", "data", "and", "scales", "legend", "bool", "option", "to", "suppress", "the", "mark", "mappings", "for", "this", "layer", "from", "the", "legend", "data", "dataframe", "or", "dict", "data", "source", "to", "override", "the", "global", "source", "provided", "in", "the", "constructor", "variables", "data", "vectors", "or", "identifiers", "additional", "layer", "specific", "variables", "including", "variables", "that", "will", "be", "passed", "directly", "to", "the", "transforms", "without", "scaling", "examples", "include", "docstrings", "objects", "plot", "add", "rst", "if", "not", "isinstance", "mark", "mark", "msg", "f", "mark", "must", "be", "a", "mark", "instance", "not", "type", "mark", "r", "raise", "typeerror", "msg", "todo", "this", "api", "for", "transforms", "was", "a", "late", "decision", "and", "previously", "plot", "add", "accepted", "0", "or", "1", "stat", "instances", "and", "0", "1", "or", "a", "list", "of", "move", "instances", "it", "will", "take", "some", "work", "to", "refactor", "the", "internals", "so", "that", "stat", "and", "move", "are", "treated", "identically", "and", "until", "then", "well", "need", "to", "unpack", "the", "transforms", "here", "and", "enforce", "limitations", "on", "the", "order", "types", "stat", "optional", "stat", "move", "optional", "list", "move", "error", "false", "if", "not", "transforms", "stat", "move", "none", "none", "elif", "isinstance", "transforms", "0", "stat", "stat", "transforms", "0", "move", "m", "for", "m", "in", "transforms", "1", "if", "isinstance", "m", "move", "error", "len", "move", "len", "transforms", "1", "else", "stat", "none", "move", "m", "for", "m", "in", "transforms", "if", "isinstance", "m", "move", "error", "len", "move", "len", "transforms", "if", "error", "msg", "join", "transforms", "must", "have", "at", "most", "one", "stat", "type", "in", "the", "first", "position", "and", "all", "others", "must", "be", "a", "move", "type", "given", "transform", "type", "s", "join", "str", "type", "t", "__name__", "for", "t", "in", "transforms", "raise", "typeerror", "msg", "new", "self", "_clone", "new", "_layers", "append", "mark", "mark", "stat", "stat", "move", "move", "todo", "it", "doesn", "t", "work", "to", "supply", "scalars", "to", "variables", "but", "it", "should", "vars", "variables", "source", "data", "legend", "legend", "orient", "v", "x", "h", "y", "get", "orient", "orient", "type", "ignore", "return", "new"], "doc_len": 467}
{"doc_id": "seaborn/_core/plot.py::Plot.pair", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "pair", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def pair(\n        self,\n        x: VariableSpecList = None,\n        y: VariableSpecList = None,\n        wrap: int | None = None,\n        cross: bool = True,\n    ) -> Plot:\n        \"\"\"\n        Produce subplots by pairing multiple `x` and/or `y` variables.\n\n        Parameters\n        ----------\n        x, y : sequence(s) of data vectors or identifiers\n            Variables that will define the grid of subplots.\n        wrap : int\n            When using only `x` or `y`, \"wrap\" subplots across a two-dimensional grid\n            with this many columns (when using `x`) or rows (when using `y`).\n        cross : bool\n            When False, zip the `x` and `y` lists such that the first subplot gets the\n            first pair, the second gets the second pair, etc. Otherwise, create a\n            two-dimensional grid from the cartesian product of the lists.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.pair.rst\n\n        \"\"\"\n        # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows\n        # This may also be possible by setting `wrap=1`, but is that too unobvious?\n        # TODO PairGrid features not currently implemented: diagonals, corner\n\n        pair_spec: PairSpec = {}\n\n        axes = {\"x\": [] if x is None else x, \"y\": [] if y is None else y}\n        for axis, arg in axes.items():\n            if isinstance(arg, (str, int)):\n                err = f\"You must pass a sequence of variable keys to `{axis}`\"\n                raise TypeError(err)\n\n        pair_spec[\"variables\"] = {}\n        pair_spec[\"structure\"] = {}\n\n        for axis in \"xy\":\n            keys = []\n            for i, col in enumerate(axes[axis]):\n                key = f\"{axis}{i}\"\n                keys.append(key)\n                pair_spec[\"variables\"][key] = col\n\n            if keys:\n                pair_spec[\"structure\"][axis] = keys\n\n        if not cross and len(axes[\"x\"]) != len(axes[\"y\"]):\n            err = \"Lengths of the `x` and `y` lists must match with cross=False\"\n            raise ValueError(err)\n\n        pair_spec[\"cross\"] = cross\n        pair_spec[\"wrap\"] = wrap\n\n        new = self._clone()\n        new._pair_spec.update(pair_spec)\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "pair", "self", "x", "variablespeclist", "none", "y", "variablespeclist", "none", "wrap", "int", "none", "none", "cross", "bool", "true", "plot", "produce", "subplots", "by", "pairing", "multiple", "x", "and", "or", "y", "variables", "parameters", "x", "y", "sequence", "s", "of", "data", "vectors", "or", "identifiers", "variables", "that", "will", "define", "the", "grid", "of", "subplots", "wrap", "int", "when", "using", "only", "x", "or", "y", "wrap", "subplots", "across", "a", "two", "dimensional", "grid", "with", "this", "many", "columns", "when", "using", "x", "or", "rows", "when", "using", "y", "cross", "bool", "when", "false", "zip", "the", "x", "and", "y", "lists", "such", "that", "the", "first", "subplot", "gets", "the", "first", "pair", "the", "second", "gets", "the", "second", "pair", "etc", "otherwise", "create", "a", "two", "dimensional", "grid", "from", "the", "cartesian", "product", "of", "the", "lists", "examples", "include", "docstrings", "objects", "plot", "pair", "rst", "todo", "add", "transpose", "arg", "which", "would", "then", "draw", "pair", "y", "across", "rows", "this", "may", "also", "be", "possible", "by", "setting", "wrap", "1", "but", "is", "that", "too", "unobvious", "todo", "pairgrid", "features", "not", "currently", "implemented", "diagonals", "corner", "pair_spec", "pairspec", "axes", "x", "if", "x", "is", "none", "else", "x", "y", "if", "y", "is", "none", "else", "y", "for", "axis", "arg", "in", "axes", "items", "if", "isinstance", "arg", "str", "int", "err", "f", "you", "must", "pass", "a", "sequence", "of", "variable", "keys", "to", "axis", "raise", "typeerror", "err", "pair_spec", "variables", "pair_spec", "structure", "for", "axis", "in", "xy", "keys", "for", "i", "col", "in", "enumerate", "axes", "axis", "key", "f", "axis", "i", "keys", "append", "key", "pair_spec", "variables", "key", "col", "if", "keys", "pair_spec", "structure", "axis", "keys", "if", "not", "cross", "and", "len", "axes", "x", "len", "axes", "y", "err", "lengths", "of", "the", "x", "and", "y", "lists", "must", "match", "with", "cross", "false", "raise", "valueerror", "err", "pair_spec", "cross", "cross", "pair_spec", "wrap", "wrap", "new", "self", "_clone", "new", "_pair_spec", "update", "pair_spec", "return", "new"], "doc_len": 274}
{"doc_id": "seaborn/_core/plot.py::Plot.facet", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "facet", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def facet(\n        self,\n        col: VariableSpec = None,\n        row: VariableSpec = None,\n        order: OrderSpec | dict[str, OrderSpec] = None,\n        wrap: int | None = None,\n    ) -> Plot:\n        \"\"\"\n        Produce subplots with conditional subsets of the data.\n\n        Parameters\n        ----------\n        col, row : data vectors or identifiers\n            Variables used to define subsets along the columns and/or rows of the grid.\n            Can be references to the global data source passed in the constructor.\n        order : list of strings, or dict with dimensional keys\n            Define the order of the faceting variables.\n        wrap : int\n            When using only `col` or `row`, wrap subplots across a two-dimensional\n            grid with this many subplots on the faceting dimension.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.facet.rst\n\n        \"\"\"\n        variables: dict[str, VariableSpec] = {}\n        if col is not None:\n            variables[\"col\"] = col\n        if row is not None:\n            variables[\"row\"] = row\n\n        structure = {}\n        if isinstance(order, dict):\n            for dim in [\"col\", \"row\"]:\n                dim_order = order.get(dim)\n                if dim_order is not None:\n                    structure[dim] = list(dim_order)\n        elif order is not None:\n            if col is not None and row is not None:\n                err = \" \".join([\n                    \"When faceting on both col= and row=, passing `order` as a list\"\n                    \"is ambiguous. Use a dict with 'col' and/or 'row' keys instead.\"\n                ])\n                raise RuntimeError(err)\n            elif col is not None:\n                structure[\"col\"] = list(order)\n            elif row is not None:\n                structure[\"row\"] = list(order)\n\n        spec: FacetSpec = {\n            \"variables\": variables,\n            \"structure\": structure,\n            \"wrap\": wrap,\n        }\n\n        new = self._clone()\n        new._facet_spec.update(spec)\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "facet", "self", "col", "variablespec", "none", "row", "variablespec", "none", "order", "orderspec", "dict", "str", "orderspec", "none", "wrap", "int", "none", "none", "plot", "produce", "subplots", "with", "conditional", "subsets", "of", "the", "data", "parameters", "col", "row", "data", "vectors", "or", "identifiers", "variables", "used", "to", "define", "subsets", "along", "the", "columns", "and", "or", "rows", "of", "the", "grid", "can", "be", "references", "to", "the", "global", "data", "source", "passed", "in", "the", "constructor", "order", "list", "of", "strings", "or", "dict", "with", "dimensional", "keys", "define", "the", "order", "of", "the", "faceting", "variables", "wrap", "int", "when", "using", "only", "col", "or", "row", "wrap", "subplots", "across", "a", "two", "dimensional", "grid", "with", "this", "many", "subplots", "on", "the", "faceting", "dimension", "examples", "include", "docstrings", "objects", "plot", "facet", "rst", "variables", "dict", "str", "variablespec", "if", "col", "is", "not", "none", "variables", "col", "col", "if", "row", "is", "not", "none", "variables", "row", "row", "structure", "if", "isinstance", "order", "dict", "for", "dim", "in", "col", "row", "dim_order", "order", "get", "dim", "if", "dim_order", "is", "not", "none", "structure", "dim", "list", "dim_order", "elif", "order", "is", "not", "none", "if", "col", "is", "not", "none", "and", "row", "is", "not", "none", "err", "join", "when", "faceting", "on", "both", "col", "and", "row", "passing", "order", "as", "a", "list", "is", "ambiguous", "use", "a", "dict", "with", "col", "and", "or", "row", "keys", "instead", "raise", "runtimeerror", "err", "elif", "col", "is", "not", "none", "structure", "col", "list", "order", "elif", "row", "is", "not", "none", "structure", "row", "list", "order", "spec", "facetspec", "variables", "variables", "structure", "structure", "wrap", "wrap", "new", "self", "_clone", "new", "_facet_spec", "update", "spec", "return", "new"], "doc_len": 234}
{"doc_id": "seaborn/_core/plot.py::Plot.scale", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "scale", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def scale(self, **scales: Scale) -> Plot:\n        \"\"\"\n        Specify mappings from data units to visual properties.\n\n        Keywords correspond to variables defined in the plot, including coordinate\n        variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).\n\n        A number of \"magic\" arguments are accepted, including:\n            - The name of a transform (e.g., `\"log\"`, `\"sqrt\"`)\n            - The name of a palette (e.g., `\"viridis\"`, `\"muted\"`)\n            - A tuple of values, defining the output range (e.g. `(1, 5)`)\n            - A dict, implying a :class:`Nominal` scale (e.g. `{\"a\": .2, \"b\": .5}`)\n            - A list of values, implying a :class:`Nominal` scale (e.g. `[\"b\", \"r\"]`)\n\n        For more explicit control, pass a scale spec object such as :class:`Continuous`\n        or :class:`Nominal`. Or pass `None` to use an \"identity\" scale, which treats\n        data values as literally encoding visual properties.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.scale.rst\n\n        \"\"\"\n        new = self._clone()\n        new._scales.update(scales)\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "scale", "self", "scales", "scale", "plot", "specify", "mappings", "from", "data", "units", "to", "visual", "properties", "keywords", "correspond", "to", "variables", "defined", "in", "the", "plot", "including", "coordinate", "variables", "x", "y", "and", "semantic", "variables", "color", "pointsize", "etc", "a", "number", "of", "magic", "arguments", "are", "accepted", "including", "the", "name", "of", "a", "transform", "e", "g", "log", "sqrt", "the", "name", "of", "a", "palette", "e", "g", "viridis", "muted", "a", "tuple", "of", "values", "defining", "the", "output", "range", "e", "g", "1", "5", "a", "dict", "implying", "a", "class", "nominal", "scale", "e", "g", "a", "2", "b", "5", "a", "list", "of", "values", "implying", "a", "class", "nominal", "scale", "e", "g", "b", "r", "for", "more", "explicit", "control", "pass", "a", "scale", "spec", "object", "such", "as", "class", "continuous", "or", "class", "nominal", "or", "pass", "none", "to", "use", "an", "identity", "scale", "which", "treats", "data", "values", "as", "literally", "encoding", "visual", "properties", "examples", "include", "docstrings", "objects", "plot", "scale", "rst", "new", "self", "_clone", "new", "_scales", "update", "scales", "return", "new"], "doc_len": 151}
{"doc_id": "seaborn/_core/plot.py::Plot.share", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "share", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def share(self, **shares: bool | str) -> Plot:\n        \"\"\"\n        Control sharing of axis limits and ticks across subplots.\n\n        Keywords correspond to variables defined in the plot, and values can be\n        boolean (to share across all subplots), or one of \"row\" or \"col\" (to share\n        more selectively across one dimension of a grid).\n\n        Behavior for non-coordinate variables is currently undefined.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.share.rst\n\n        \"\"\"\n        new = self._clone()\n        new._shares.update(shares)\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "share", "self", "shares", "bool", "str", "plot", "control", "sharing", "of", "axis", "limits", "and", "ticks", "across", "subplots", "keywords", "correspond", "to", "variables", "defined", "in", "the", "plot", "and", "values", "can", "be", "boolean", "to", "share", "across", "all", "subplots", "or", "one", "of", "row", "or", "col", "to", "share", "more", "selectively", "across", "one", "dimension", "of", "a", "grid", "behavior", "for", "non", "coordinate", "variables", "is", "currently", "undefined", "examples", "include", "docstrings", "objects", "plot", "share", "rst", "new", "self", "_clone", "new", "_shares", "update", "shares", "return", "new"], "doc_len": 79}
{"doc_id": "seaborn/_core/plot.py::Plot.limit", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "limit", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def limit(self, **limits: tuple[Any, Any]) -> Plot:\n        \"\"\"\n        Control the range of visible data.\n\n        Keywords correspond to variables defined in the plot, and values are a\n        `(min, max)` tuple (where either can be `None` to leave unset).\n\n        Limits apply only to the axis; data outside the visible range are\n        still used for any stat transforms and added to the plot.\n\n        Behavior for non-coordinate variables is currently undefined.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.limit.rst\n\n        \"\"\"\n        new = self._clone()\n        new._limits.update(limits)\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "limit", "self", "limits", "tuple", "any", "any", "plot", "control", "the", "range", "of", "visible", "data", "keywords", "correspond", "to", "variables", "defined", "in", "the", "plot", "and", "values", "are", "a", "min", "max", "tuple", "where", "either", "can", "be", "none", "to", "leave", "unset", "limits", "apply", "only", "to", "the", "axis", "data", "outside", "the", "visible", "range", "are", "still", "used", "for", "any", "stat", "transforms", "and", "added", "to", "the", "plot", "behavior", "for", "non", "coordinate", "variables", "is", "currently", "undefined", "examples", "include", "docstrings", "objects", "plot", "limit", "rst", "new", "self", "_clone", "new", "_limits", "update", "limits", "return", "new"], "doc_len": 89}
{"doc_id": "seaborn/_core/plot.py::Plot.label", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "label", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:\n        \"\"\"\n        Control the labels and titles for axes, legends, and subplots.\n\n        Additional keywords correspond to variables defined in the plot.\n        Values can be one of the following types:\n\n        - string (used literally; pass \"\" to clear the default label)\n        - function (called on the default label)\n\n        For coordinate variables, the value sets the axis label.\n        For semantic variables, the value sets the legend title.\n        For faceting variables, `title=` modifies the subplot-specific label,\n        while `col=` and/or `row=` add a label for the faceting variable.\n        When using a single subplot, `title=` sets its title.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.label.rst\n\n\n        \"\"\"\n        new = self._clone()\n        if title is not None:\n            new._labels[\"title\"] = title\n        new._labels.update(variables)\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "label", "self", "title", "none", "variables", "str", "callable", "str", "str", "plot", "control", "the", "labels", "and", "titles", "for", "axes", "legends", "and", "subplots", "additional", "keywords", "correspond", "to", "variables", "defined", "in", "the", "plot", "values", "can", "be", "one", "of", "the", "following", "types", "string", "used", "literally", "pass", "to", "clear", "the", "default", "label", "function", "called", "on", "the", "default", "label", "for", "coordinate", "variables", "the", "value", "sets", "the", "axis", "label", "for", "semantic", "variables", "the", "value", "sets", "the", "legend", "title", "for", "faceting", "variables", "title", "modifies", "the", "subplot", "specific", "label", "while", "col", "and", "or", "row", "add", "a", "label", "for", "the", "faceting", "variable", "when", "using", "a", "single", "subplot", "title", "sets", "its", "title", "examples", "include", "docstrings", "objects", "plot", "label", "rst", "new", "self", "_clone", "if", "title", "is", "not", "none", "new", "_labels", "title", "title", "new", "_labels", "update", "variables", "return", "new"], "doc_len": 131}
{"doc_id": "seaborn/_core/plot.py::Plot.layout", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "layout", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def layout(\n        self,\n        *,\n        size: tuple[float, float] | Default = default,\n        engine: str | None | Default = default,\n    ) -> Plot:\n        \"\"\"\n        Control the figure size and layout.\n\n        .. note::\n\n            Default figure sizes and the API for specifying the figure size are subject\n            to change in future \"experimental\" releases of the objects API. The default\n            layout engine may also change.\n\n        Parameters\n        ----------\n        size : (width, height)\n            Size of the resulting figure, in inches. Size is inclusive of legend when\n            using pyplot, but not otherwise.\n        engine : {{\"tight\", \"constrained\", None}}\n            Name of method for automatically adjusting the layout to remove overlap.\n            The default depends on whether :meth:`Plot.on` is used.\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.layout.rst\n\n        \"\"\"\n        # TODO add an \"auto\" mode for figsize that roughly scales with the rcParams\n        # figsize (so that works), but expands to prevent subplots from being squished\n        # Also should we have height=, aspect=, exclusive with figsize? Or working\n        # with figsize when only one is defined?\n\n        new = self._clone()\n\n        if size is not default:\n            new._figure_spec[\"figsize\"] = size\n        if engine is not default:\n            new._layout_spec[\"engine\"] = engine\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "layout", "self", "size", "tuple", "float", "float", "default", "default", "engine", "str", "none", "default", "default", "plot", "control", "the", "figure", "size", "and", "layout", "note", "default", "figure", "sizes", "and", "the", "api", "for", "specifying", "the", "figure", "size", "are", "subject", "to", "change", "in", "future", "experimental", "releases", "of", "the", "objects", "api", "the", "default", "layout", "engine", "may", "also", "change", "parameters", "size", "width", "height", "size", "of", "the", "resulting", "figure", "in", "inches", "size", "is", "inclusive", "of", "legend", "when", "using", "pyplot", "but", "not", "otherwise", "engine", "tight", "constrained", "none", "name", "of", "method", "for", "automatically", "adjusting", "the", "layout", "to", "remove", "overlap", "the", "default", "depends", "on", "whether", "meth", "plot", "on", "is", "used", "examples", "include", "docstrings", "objects", "plot", "layout", "rst", "todo", "add", "an", "auto", "mode", "for", "figsize", "that", "roughly", "scales", "with", "the", "rcparams", "figsize", "so", "that", "works", "but", "expands", "to", "prevent", "subplots", "from", "being", "squished", "also", "should", "we", "have", "height", "aspect", "exclusive", "with", "figsize", "or", "working", "with", "figsize", "when", "only", "one", "is", "defined", "new", "self", "_clone", "if", "size", "is", "not", "default", "new", "_figure_spec", "figsize", "size", "if", "engine", "is", "not", "default", "new", "_layout_spec", "engine", "engine", "return", "new"], "doc_len": 177}
{"doc_id": "seaborn/_core/plot.py::Plot.theme", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "theme", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def theme(self, *args: dict[str, Any]) -> Plot:\n        \"\"\"\n        Control the default appearance of elements in the plot.\n\n        .. note::\n\n            The API for customizing plot appearance is not yet finalized.\n            Currently, the only valid argument is a dict of matplotlib rc parameters.\n            (This dict must be passed as a positional argument.)\n\n            It is likely that this method will be enhanced in future releases.\n\n        Matplotlib rc parameters are documented on the following page:\n        https://matplotlib.org/stable/tutorials/introductory/customizing.html\n\n        Examples\n        --------\n        .. include:: ../docstrings/objects.Plot.theme.rst\n\n        \"\"\"\n        new = self._clone()\n\n        # We can skip this whole block on Python 3.8+ with positional-only syntax\n        nargs = len(args)\n        if nargs != 1:\n            err = f\"theme() takes 1 positional argument, but {nargs} were given\"\n            raise TypeError(err)\n\n        rc = args[0]\n        new._theme.update(rc)\n\n        return new\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "theme", "self", "args", "dict", "str", "any", "plot", "control", "the", "default", "appearance", "of", "elements", "in", "the", "plot", "note", "the", "api", "for", "customizing", "plot", "appearance", "is", "not", "yet", "finalized", "currently", "the", "only", "valid", "argument", "is", "a", "dict", "of", "matplotlib", "rc", "parameters", "this", "dict", "must", "be", "passed", "as", "a", "positional", "argument", "it", "is", "likely", "that", "this", "method", "will", "be", "enhanced", "in", "future", "releases", "matplotlib", "rc", "parameters", "are", "documented", "on", "the", "following", "page", "https", "matplotlib", "org", "stable", "tutorials", "introductory", "customizing", "html", "examples", "include", "docstrings", "objects", "plot", "theme", "rst", "new", "self", "_clone", "we", "can", "skip", "this", "whole", "block", "on", "python", "3", "8", "with", "positional", "only", "syntax", "nargs", "len", "args", "if", "nargs", "1", "err", "f", "theme", "takes", "1", "positional", "argument", "but", "nargs", "were", "given", "raise", "typeerror", "err", "rc", "args", "0", "new", "_theme", "update", "rc", "return", "new"], "doc_len": 136}
{"doc_id": "seaborn/_core/plot.py::Plot.save", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "save", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def save(self, loc, **kwargs) -> Plot:\n        \"\"\"\n        Compile the plot and write it to a buffer or file on disk.\n\n        Parameters\n        ----------\n        loc : str, path, or buffer\n            Location on disk to save the figure, or a buffer to write into.\n        kwargs\n            Other keyword arguments are passed through to\n            :meth:`matplotlib.figure.Figure.savefig`.\n\n        \"\"\"\n        # TODO expose important keyword arguments in our signature?\n        with theme_context(self._theme_with_defaults()):\n            self._plot().save(loc, **kwargs)\n        return self\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "save", "self", "loc", "kwargs", "plot", "compile", "the", "plot", "and", "write", "it", "to", "a", "buffer", "or", "file", "on", "disk", "parameters", "loc", "str", "path", "or", "buffer", "location", "on", "disk", "to", "save", "the", "figure", "or", "a", "buffer", "to", "write", "into", "kwargs", "other", "keyword", "arguments", "are", "passed", "through", "to", "meth", "matplotlib", "figure", "figure", "savefig", "todo", "expose", "important", "keyword", "arguments", "in", "our", "signature", "with", "theme_context", "self", "_theme_with_defaults", "self", "_plot", "save", "loc", "kwargs", "return", "self"], "doc_len": 75}
{"doc_id": "seaborn/_core/plot.py::Plot.show", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "show", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def show(self, **kwargs) -> None:\n        \"\"\"\n        Compile the plot and display it by hooking into pyplot.\n\n        Calling this method is not necessary to render a plot in notebook context,\n        but it may be in other environments (e.g., in a terminal). After compiling the\n        plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).\n\n        Unlike other :class:`Plot` methods, there is no return value. This should be\n        the last method you call when specifying a plot.\n\n        \"\"\"\n        # TODO make pyplot configurable at the class level, and when not using,\n        # import IPython.display and call on self to populate cell output?\n\n        # Keep an eye on whether matplotlib implements \"attaching\" an existing\n        # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024\n\n        self.plot(pyplot=True).show(**kwargs)\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "show", "self", "kwargs", "none", "compile", "the", "plot", "and", "display", "it", "by", "hooking", "into", "pyplot", "calling", "this", "method", "is", "not", "necessary", "to", "render", "a", "plot", "in", "notebook", "context", "but", "it", "may", "be", "in", "other", "environments", "e", "g", "in", "a", "terminal", "after", "compiling", "the", "plot", "it", "calls", "func", "matplotlib", "pyplot", "show", "passing", "any", "keyword", "parameters", "unlike", "other", "class", "plot", "methods", "there", "is", "no", "return", "value", "this", "should", "be", "the", "last", "method", "you", "call", "when", "specifying", "a", "plot", "todo", "make", "pyplot", "configurable", "at", "the", "class", "level", "and", "when", "not", "using", "import", "ipython", "display", "and", "call", "on", "self", "to", "populate", "cell", "output", "keep", "an", "eye", "on", "whether", "matplotlib", "implements", "attaching", "an", "existing", "figure", "to", "pyplot", "https", "github", "com", "matplotlib", "matplotlib", "pull", "14024", "self", "plot", "pyplot", "true", "show", "kwargs"], "doc_len": 130}
{"doc_id": "seaborn/_core/plot.py::Plot.plot", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "plot", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def plot(self, pyplot: bool = False) -> Plotter:\n        \"\"\"\n        Compile the plot spec and return the Plotter object.\n        \"\"\"\n        with theme_context(self._theme_with_defaults()):\n            return self._plot(pyplot)\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "plot", "self", "pyplot", "bool", "false", "plotter", "compile", "the", "plot", "spec", "and", "return", "the", "plotter", "object", "with", "theme_context", "self", "_theme_with_defaults", "return", "self", "_plot", "pyplot"], "doc_len": 29}
{"doc_id": "seaborn/_core/plot.py::Plot._plot", "file_path": "seaborn/_core/plot.py", "class_name": "Plot", "func_name": "_plot", "text": "文件路径: seaborn/_core/plot.py, 类名: Plot\n    def _plot(self, pyplot: bool = False) -> Plotter:\n\n        # TODO if we have _target object, pyplot should be determined by whether it\n        # is hooked into the pyplot state machine (how do we check?)\n\n        plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())\n\n        # Process the variable assignments and initialize the figure\n        common, layers = plotter._extract_data(self)\n        plotter._setup_figure(self, common, layers)\n\n        # Process the scale spec for coordinate variables and transform their data\n        coord_vars = [v for v in self._variables if re.match(r\"^x|y\", v)]\n        plotter._setup_scales(self, common, layers, coord_vars)\n\n        # Apply statistical transform(s)\n        plotter._compute_stats(self, layers)\n\n        # Process scale spec for semantic variables and coordinates computed by stat\n        plotter._setup_scales(self, common, layers)\n\n        # TODO Remove these after updating other methods\n        # ---- Maybe have debug= param that attaches these when True?\n        plotter._data = common\n        plotter._layers = layers\n\n        # Process the data for each layer and add matplotlib artists\n        for layer in layers:\n            plotter._plot_layer(self, layer)\n\n        # Add various figure decorations\n        plotter._make_legend(self)\n        plotter._finalize_figure(self)\n\n        return plotter\n", "tokens": ["seaborn", "_core", "plot", "py", "plot", "def", "_plot", "self", "pyplot", "bool", "false", "plotter", "todo", "if", "we", "have", "_target", "object", "pyplot", "should", "be", "determined", "by", "whether", "it", "is", "hooked", "into", "the", "pyplot", "state", "machine", "how", "do", "we", "check", "plotter", "plotter", "pyplot", "pyplot", "theme", "self", "_theme_with_defaults", "process", "the", "variable", "assignments", "and", "initialize", "the", "figure", "common", "layers", "plotter", "_extract_data", "self", "plotter", "_setup_figure", "self", "common", "layers", "process", "the", "scale", "spec", "for", "coordinate", "variables", "and", "transform", "their", "data", "coord_vars", "v", "for", "v", "in", "self", "_variables", "if", "re", "match", "r", "x", "y", "v", "plotter", "_setup_scales", "self", "common", "layers", "coord_vars", "apply", "statistical", "transform", "s", "plotter", "_compute_stats", "self", "layers", "process", "scale", "spec", "for", "semantic", "variables", "and", "coordinates", "computed", "by", "stat", "plotter", "_setup_scales", "self", "common", "layers", "todo", "remove", "these", "after", "updating", "other", "methods", "maybe", "have", "debug", "param", "that", "attaches", "these", "when", "true", "plotter", "_data", "common", "plotter", "_layers", "layers", "process", "the", "data", "for", "each", "layer", "and", "add", "matplotlib", "artists", "for", "layer", "in", "layers", "plotter", "_plot_layer", "self", "layer", "add", "various", "figure", "decorations", "plotter", "_make_legend", "self", "plotter", "_finalize_figure", "self", "return", "plotter"], "doc_len": 168}
{"doc_id": "seaborn/_core/plot.py::Plotter.__init__", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "__init__", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def __init__(self, pyplot: bool, theme: dict[str, Any]):\n\n        self._pyplot = pyplot\n        self._theme = theme\n        self._legend_contents: list[tuple[\n            tuple[str, str | int], list[Artist], list[str],\n        ]] = []\n        self._scales: dict[str, Scale] = {}\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "__init__", "self", "pyplot", "bool", "theme", "dict", "str", "any", "self", "_pyplot", "pyplot", "self", "_theme", "theme", "self", "_legend_contents", "list", "tuple", "tuple", "str", "str", "int", "list", "artist", "list", "str", "self", "_scales", "dict", "str", "scale"], "doc_len": 37}
{"doc_id": "seaborn/_core/plot.py::Plotter.save", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "save", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def save(self, loc, **kwargs) -> Plotter:  # TODO type args\n        kwargs.setdefault(\"dpi\", 96)\n        try:\n            loc = os.path.expanduser(loc)\n        except TypeError:\n            # loc may be a buffer in which case that would not work\n            pass\n        self._figure.savefig(loc, **kwargs)\n        return self\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "save", "self", "loc", "kwargs", "plotter", "todo", "type", "args", "kwargs", "setdefault", "dpi", "96", "try", "loc", "os", "path", "expanduser", "loc", "except", "typeerror", "loc", "may", "be", "a", "buffer", "in", "which", "case", "that", "would", "not", "work", "pass", "self", "_figure", "savefig", "loc", "kwargs", "return", "self"], "doc_len": 46}
{"doc_id": "seaborn/_core/plot.py::Plotter.show", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "show", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def show(self, **kwargs) -> None:\n        \"\"\"\n        Display the plot by hooking into pyplot.\n\n        This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.\n\n        \"\"\"\n        # TODO if we did not create the Plotter with pyplot, is it possible to do this?\n        # If not we should clearly raise.\n        import matplotlib.pyplot as plt\n        with theme_context(self._theme):\n            plt.show(**kwargs)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "show", "self", "kwargs", "none", "display", "the", "plot", "by", "hooking", "into", "pyplot", "this", "method", "calls", "func", "matplotlib", "pyplot", "show", "with", "any", "keyword", "parameters", "todo", "if", "we", "did", "not", "create", "the", "plotter", "with", "pyplot", "is", "it", "possible", "to", "do", "this", "if", "not", "we", "should", "clearly", "raise", "import", "matplotlib", "pyplot", "as", "plt", "with", "theme_context", "self", "_theme", "plt", "show", "kwargs"], "doc_len": 62}
{"doc_id": "seaborn/_core/plot.py::Plotter._repr_png_", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_repr_png_", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:\n\n        # TODO better to do this through a Jupyter hook? e.g.\n        # ipy = IPython.core.formatters.get_ipython()\n        # fmt = ipy.display_formatter.formatters[\"text/html\"]\n        # fmt.for_type(Plot, ...)\n        # Would like to have a svg option too, not sure how to make that flexible\n\n        # TODO use matplotlib backend directly instead of going through savefig?\n\n        # TODO perhaps have self.show() flip a switch to disable this, so that\n        # user does not end up with two versions of the figure in the output\n\n        # TODO use bbox_inches=\"tight\" like the inline backend?\n        # pro: better results,  con: (sometimes) confusing results\n        # Better solution would be to default (with option to change)\n        # to using constrained/tight layout.\n\n        # TODO need to decide what the right default behavior here is:\n        # - Use dpi=72 to match default InlineBackend figure size?\n        # - Accept a generic \"scaling\" somewhere and scale DPI from that,\n        #   either with 1x -> 72 or 1x -> 96 and the default scaling be .75?\n        # - Listen to rcParams? InlineBackend behavior makes that so complicated :(\n        # - Do we ever want to *not* use retina mode at this point?\n\n        from PIL import Image\n\n        dpi = 96\n        buffer = io.BytesIO()\n\n        with theme_context(self._theme):\n            self._figure.savefig(buffer, dpi=dpi * 2, format=\"png\", bbox_inches=\"tight\")\n        data = buffer.getvalue()\n\n        scaling = .85 / 2\n        w, h = Image.open(buffer).size\n        metadata = {\"width\": w * scaling, \"height\": h * scaling}\n        return data, metadata\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_repr_png_", "self", "tuple", "bytes", "dict", "str", "float", "todo", "better", "to", "do", "this", "through", "a", "jupyter", "hook", "e", "g", "ipy", "ipython", "core", "formatters", "get_ipython", "fmt", "ipy", "display_formatter", "formatters", "text", "html", "fmt", "for_type", "plot", "would", "like", "to", "have", "a", "svg", "option", "too", "not", "sure", "how", "to", "make", "that", "flexible", "todo", "use", "matplotlib", "backend", "directly", "instead", "of", "going", "through", "savefig", "todo", "perhaps", "have", "self", "show", "flip", "a", "switch", "to", "disable", "this", "so", "that", "user", "does", "not", "end", "up", "with", "two", "versions", "of", "the", "figure", "in", "the", "output", "todo", "use", "bbox_inches", "tight", "like", "the", "inline", "backend", "pro", "better", "results", "con", "sometimes", "confusing", "results", "better", "solution", "would", "be", "to", "default", "with", "option", "to", "change", "to", "using", "constrained", "tight", "layout", "todo", "need", "to", "decide", "what", "the", "right", "default", "behavior", "here", "is", "use", "dpi", "72", "to", "match", "default", "inlinebackend", "figure", "size", "accept", "a", "generic", "scaling", "somewhere", "and", "scale", "dpi", "from", "that", "either", "with", "1x", "72", "or", "1x", "96", "and", "the", "default", "scaling", "be", "75", "listen", "to", "rcparams", "inlinebackend", "behavior", "makes", "that", "so", "complicated", "do", "we", "ever", "want", "to", "not", "use", "retina", "mode", "at", "this", "point", "from", "pil", "import", "image", "dpi", "96", "buffer", "io", "bytesio", "with", "theme_context", "self", "_theme", "self", "_figure", "savefig", "buffer", "dpi", "dpi", "2", "format", "png", "bbox_inches", "tight", "data", "buffer", "getvalue", "scaling", "85", "2", "w", "h", "image", "open", "buffer", "size", "metadata", "width", "w", "scaling", "height", "h", "scaling", "return", "data", "metadata"], "doc_len": 230}
{"doc_id": "seaborn/_core/plot.py::Plotter._extract_data", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_extract_data", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:\n\n        common_data = (\n            p._data\n            .join(None, p._facet_spec.get(\"variables\"))\n            .join(None, p._pair_spec.get(\"variables\"))\n        )\n\n        layers: list[Layer] = []\n        for layer in p._layers:\n            spec = layer.copy()\n            spec[\"data\"] = common_data.join(layer.get(\"source\"), layer.get(\"vars\"))\n            layers.append(spec)\n\n        return common_data, layers\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_extract_data", "self", "p", "plot", "tuple", "plotdata", "list", "layer", "common_data", "p", "_data", "join", "none", "p", "_facet_spec", "get", "variables", "join", "none", "p", "_pair_spec", "get", "variables", "layers", "list", "layer", "for", "layer", "in", "p", "_layers", "spec", "layer", "copy", "spec", "data", "common_data", "join", "layer", "get", "source", "layer", "get", "vars", "layers", "append", "spec", "return", "common_data", "layers"], "doc_len": 56}
{"doc_id": "seaborn/_core/plot.py::Plotter._resolve_label", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_resolve_label", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:\n\n        label: str\n        if var in p._labels:\n            manual_label = p._labels[var]\n            if callable(manual_label) and auto_label is not None:\n                label = manual_label(auto_label)\n            else:\n                label = cast(str, manual_label)\n        elif auto_label is None:\n            label = \"\"\n        else:\n            label = auto_label\n        return label\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_resolve_label", "self", "p", "plot", "var", "str", "auto_label", "str", "none", "str", "label", "str", "if", "var", "in", "p", "_labels", "manual_label", "p", "_labels", "var", "if", "callable", "manual_label", "and", "auto_label", "is", "not", "none", "label", "manual_label", "auto_label", "else", "label", "cast", "str", "manual_label", "elif", "auto_label", "is", "none", "label", "else", "label", "auto_label", "return", "label"], "doc_len": 53}
{"doc_id": "seaborn/_core/plot.py::Plotter._setup_figure", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_setup_figure", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:\n\n        # --- Parsing the faceting/pairing parameterization to specify figure grid\n\n        subplot_spec = p._subplot_spec.copy()\n        facet_spec = p._facet_spec.copy()\n        pair_spec = p._pair_spec.copy()\n\n        for axis in \"xy\":\n            if axis in p._shares:\n                subplot_spec[f\"share{axis}\"] = p._shares[axis]\n\n        for dim in [\"col\", \"row\"]:\n            if dim in common.frame and dim not in facet_spec[\"structure\"]:\n                order = categorical_order(common.frame[dim])\n                facet_spec[\"structure\"][dim] = order\n\n        self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)\n\n        # --- Figure initialization\n        self._figure = subplots.init_figure(\n            pair_spec, self._pyplot, p._figure_spec, p._target,\n        )\n\n        # --- Figure annotation\n        for sub in subplots:\n            ax = sub[\"ax\"]\n            for axis in \"xy\":\n                axis_key = sub[axis]\n\n                # ~~ Axis labels\n\n                # TODO Should we make it possible to use only one x/y label for\n                # all rows/columns in a faceted plot? Maybe using sub{axis}label,\n                # although the alignments of the labels from that method leaves\n                # something to be desired (in terms of how it defines 'centered').\n                names = [\n                    common.names.get(axis_key),\n                    *(layer[\"data\"].names.get(axis_key) for layer in layers)\n                ]\n                auto_label = next((name for name in names if name is not None), None)\n                label = self._resolve_label(p, axis_key, auto_label)\n                ax.set(**{f\"{axis}label\": label})\n\n                # ~~ Decoration visibility\n\n                # TODO there should be some override (in Plot.layout?) so that\n                # axis / tick labels can be shown on interior shared axes if desired\n\n                axis_obj = getattr(ax, f\"{axis}axis\")\n                visible_side = {\"x\": \"bottom\", \"y\": \"left\"}.get(axis)\n                show_axis_label = (\n                    sub[visible_side]\n                    or not p._pair_spec.get(\"cross\", True)\n                    or (\n                        axis in p._pair_spec.get(\"structure\", {})\n                        and bool(p._pair_spec.get(\"wrap\"))\n                    )\n                )\n                axis_obj.get_label().set_visible(show_axis_label)\n\n                show_tick_labels = (\n                    show_axis_label\n                    or subplot_spec.get(f\"share{axis}\") not in (\n                        True, \"all\", {\"x\": \"col\", \"y\": \"row\"}[axis]\n                    )\n                )\n                for group in (\"major\", \"minor\"):\n                    for t in getattr(axis_obj, f\"get_{group}ticklabels\")():\n                        t.set_visible(show_tick_labels)\n\n            # TODO we want right-side titles for row facets in most cases?\n            # Let's have what we currently call \"margin titles\" but properly using the\n            # ax.set_title interface (see my gist)\n            title_parts = []\n            for dim in [\"col\", \"row\"]:\n                if sub[dim] is not None:\n                    val = self._resolve_label(p, \"title\", f\"{sub[dim]}\")\n                    if dim in p._labels:\n                        key = self._resolve_label(p, dim, common.names.get(dim))\n                        val = f\"{key} {val}\"\n                    title_parts.append(val)\n\n            has_col = sub[\"col\"] is not None\n            has_row = sub[\"row\"] is not None\n            show_title = (\n                has_col and has_row\n                or (has_col or has_row) and p._facet_spec.get(\"wrap\")\n                or (has_col and sub[\"top\"])\n                # TODO or has_row and sub[\"right\"] and <right titles>\n                or has_row  # TODO and not <right titles>\n            )\n            if title_parts:\n                title = \" | \".join(title_parts)\n                title_text = ax.set_title(title)\n                title_text.set_visible(show_title)\n            elif not (has_col or has_row):\n                title = self._resolve_label(p, \"title\", None)\n                title_text = ax.set_title(title)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_setup_figure", "self", "p", "plot", "common", "plotdata", "layers", "list", "layer", "none", "parsing", "the", "faceting", "pairing", "parameterization", "to", "specify", "figure", "grid", "subplot_spec", "p", "_subplot_spec", "copy", "facet_spec", "p", "_facet_spec", "copy", "pair_spec", "p", "_pair_spec", "copy", "for", "axis", "in", "xy", "if", "axis", "in", "p", "_shares", "subplot_spec", "f", "share", "axis", "p", "_shares", "axis", "for", "dim", "in", "col", "row", "if", "dim", "in", "common", "frame", "and", "dim", "not", "in", "facet_spec", "structure", "order", "categorical_order", "common", "frame", "dim", "facet_spec", "structure", "dim", "order", "self", "_subplots", "subplots", "subplots", "subplot_spec", "facet_spec", "pair_spec", "figure", "initialization", "self", "_figure", "subplots", "init_figure", "pair_spec", "self", "_pyplot", "p", "_figure_spec", "p", "_target", "figure", "annotation", "for", "sub", "in", "subplots", "ax", "sub", "ax", "for", "axis", "in", "xy", "axis_key", "sub", "axis", "axis", "labels", "todo", "should", "we", "make", "it", "possible", "to", "use", "only", "one", "x", "y", "label", "for", "all", "rows", "columns", "in", "a", "faceted", "plot", "maybe", "using", "sub", "axis", "label", "although", "the", "alignments", "of", "the", "labels", "from", "that", "method", "leaves", "something", "to", "be", "desired", "in", "terms", "of", "how", "it", "defines", "centered", "names", "common", "names", "get", "axis_key", "layer", "data", "names", "get", "axis_key", "for", "layer", "in", "layers", "auto_label", "next", "name", "for", "name", "in", "names", "if", "name", "is", "not", "none", "none", "label", "self", "_resolve_label", "p", "axis_key", "auto_label", "ax", "set", "f", "axis", "label", "label", "decoration", "visibility", "todo", "there", "should", "be", "some", "override", "in", "plot", "layout", "so", "that", "axis", "tick", "labels", "can", "be", "shown", "on", "interior", "shared", "axes", "if", "desired", "axis_obj", "getattr", "ax", "f", "axis", "axis", "visible_side", "x", "bottom", "y", "left", "get", "axis", "show_axis_label", "sub", "visible_side", "or", "not", "p", "_pair_spec", "get", "cross", "true", "or", "axis", "in", "p", "_pair_spec", "get", "structure", "and", "bool", "p", "_pair_spec", "get", "wrap", "axis_obj", "get_label", "set_visible", "show_axis_label", "show_tick_labels", "show_axis_label", "or", "subplot_spec", "get", "f", "share", "axis", "not", "in", "true", "all", "x", "col", "y", "row", "axis", "for", "group", "in", "major", "minor", "for", "t", "in", "getattr", "axis_obj", "f", "get_", "group", "ticklabels", "t", "set_visible", "show_tick_labels", "todo", "we", "want", "right", "side", "titles", "for", "row", "facets", "in", "most", "cases", "let", "s", "have", "what", "we", "currently", "call", "margin", "titles", "but", "properly", "using", "the", "ax", "set_title", "interface", "see", "my", "gist", "title_parts", "for", "dim", "in", "col", "row", "if", "sub", "dim", "is", "not", "none", "val", "self", "_resolve_label", "p", "title", "f", "sub", "dim", "if", "dim", "in", "p", "_labels", "key", "self", "_resolve_label", "p", "dim", "common", "names", "get", "dim", "val", "f", "key", "val", "title_parts", "append", "val", "has_col", "sub", "col", "is", "not", "none", "has_row", "sub", "row", "is", "not", "none", "show_title", "has_col", "and", "has_row", "or", "has_col", "or", "has_row", "and", "p", "_facet_spec", "get", "wrap", "or", "has_col", "and", "sub", "top", "todo", "or", "has_row", "and", "sub", "right", "and", "right", "titles", "or", "has_row", "todo", "and", "not", "right", "titles", "if", "title_parts", "title", "join", "title_parts", "title_text", "ax", "set_title", "title", "title_text", "set_visible", "show_title", "elif", "not", "has_col", "or", "has_row", "title", "self", "_resolve_label", "p", "title", "none", "title_text", "ax", "set_title", "title"], "doc_len": 446}
{"doc_id": "seaborn/_core/plot.py::Plotter._compute_stats", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_compute_stats", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:\n\n        grouping_vars = [v for v in PROPERTIES if v not in \"xy\"]\n        grouping_vars += [\"col\", \"row\", \"group\"]\n\n        pair_vars = spec._pair_spec.get(\"structure\", {})\n\n        for layer in layers:\n\n            data = layer[\"data\"]\n            mark = layer[\"mark\"]\n            stat = layer[\"stat\"]\n\n            if stat is None:\n                continue\n\n            iter_axes = itertools.product(*[\n                pair_vars.get(axis, [axis]) for axis in \"xy\"\n            ])\n\n            old = data.frame\n\n            if pair_vars:\n                data.frames = {}\n                data.frame = data.frame.iloc[:0]  # TODO to simplify typing\n\n            for coord_vars in iter_axes:\n\n                pairings = \"xy\", coord_vars\n\n                df = old.copy()\n                scales = self._scales.copy()\n\n                for axis, var in zip(*pairings):\n                    if axis != var:\n                        df = df.rename(columns={var: axis})\n                        drop_cols = [x for x in df if re.match(rf\"{axis}\\d+\", str(x))]\n                        df = df.drop(drop_cols, axis=1)\n                        scales[axis] = scales[var]\n\n                orient = layer[\"orient\"] or mark._infer_orient(scales)\n\n                if stat.group_by_orient:\n                    grouper = [orient, *grouping_vars]\n                else:\n                    grouper = grouping_vars\n                groupby = GroupBy(grouper)\n                res = stat(df, groupby, orient, scales)\n\n                if pair_vars:\n                    data.frames[coord_vars] = res\n                else:\n                    data.frame = res\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_compute_stats", "self", "spec", "plot", "layers", "list", "layer", "none", "grouping_vars", "v", "for", "v", "in", "properties", "if", "v", "not", "in", "xy", "grouping_vars", "col", "row", "group", "pair_vars", "spec", "_pair_spec", "get", "structure", "for", "layer", "in", "layers", "data", "layer", "data", "mark", "layer", "mark", "stat", "layer", "stat", "if", "stat", "is", "none", "continue", "iter_axes", "itertools", "product", "pair_vars", "get", "axis", "axis", "for", "axis", "in", "xy", "old", "data", "frame", "if", "pair_vars", "data", "frames", "data", "frame", "data", "frame", "iloc", "0", "todo", "to", "simplify", "typing", "for", "coord_vars", "in", "iter_axes", "pairings", "xy", "coord_vars", "df", "old", "copy", "scales", "self", "_scales", "copy", "for", "axis", "var", "in", "zip", "pairings", "if", "axis", "var", "df", "df", "rename", "columns", "var", "axis", "drop_cols", "x", "for", "x", "in", "df", "if", "re", "match", "rf", "axis", "d", "str", "x", "df", "df", "drop", "drop_cols", "axis", "1", "scales", "axis", "scales", "var", "orient", "layer", "orient", "or", "mark", "_infer_orient", "scales", "if", "stat", "group_by_orient", "grouper", "orient", "grouping_vars", "else", "grouper", "grouping_vars", "groupby", "groupby", "grouper", "res", "stat", "df", "groupby", "orient", "scales", "if", "pair_vars", "data", "frames", "coord_vars", "res", "else", "data", "frame", "res"], "doc_len": 168}
{"doc_id": "seaborn/_core/plot.py::Plotter._get_scale", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_get_scale", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _get_scale(\n        self, spec: Plot, var: str, prop: Property, values: Series\n    ) -> Scale:\n\n        if var in spec._scales:\n            arg = spec._scales[var]\n            if arg is None or isinstance(arg, Scale):\n                scale = arg\n            else:\n                scale = prop.infer_scale(arg, values)\n        else:\n            scale = prop.default_scale(values)\n\n        return scale\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_get_scale", "self", "spec", "plot", "var", "str", "prop", "property", "values", "series", "scale", "if", "var", "in", "spec", "_scales", "arg", "spec", "_scales", "var", "if", "arg", "is", "none", "or", "isinstance", "arg", "scale", "scale", "arg", "else", "scale", "prop", "infer_scale", "arg", "values", "else", "scale", "prop", "default_scale", "values", "return", "scale"], "doc_len": 49}
{"doc_id": "seaborn/_core/plot.py::Plotter._get_subplot_data", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_get_subplot_data", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _get_subplot_data(self, df, var, view, share_state):\n\n        if share_state in [True, \"all\"]:\n            # The all-shared case is easiest, every subplot sees all the data\n            seed_values = df[var]\n        else:\n            # Otherwise, we need to setup separate scales for different subplots\n            if share_state in [False, \"none\"]:\n                # Fully independent axes are also easy: use each subplot's data\n                idx = self._get_subplot_index(df, view)\n            elif share_state in df:\n                # Sharing within row/col is more complicated\n                use_rows = df[share_state] == view[share_state]\n                idx = df.index[use_rows]\n            else:\n                # This configuration doesn't make much sense, but it's fine\n                idx = df.index\n\n            seed_values = df.loc[idx, var]\n\n        return seed_values\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_get_subplot_data", "self", "df", "var", "view", "share_state", "if", "share_state", "in", "true", "all", "the", "all", "shared", "case", "is", "easiest", "every", "subplot", "sees", "all", "the", "data", "seed_values", "df", "var", "else", "otherwise", "we", "need", "to", "setup", "separate", "scales", "for", "different", "subplots", "if", "share_state", "in", "false", "none", "fully", "independent", "axes", "are", "also", "easy", "use", "each", "subplot", "s", "data", "idx", "self", "_get_subplot_index", "df", "view", "elif", "share_state", "in", "df", "sharing", "within", "row", "col", "is", "more", "complicated", "use_rows", "df", "share_state", "view", "share_state", "idx", "df", "index", "use_rows", "else", "this", "configuration", "doesn", "t", "make", "much", "sense", "but", "it", "s", "fine", "idx", "df", "index", "seed_values", "df", "loc", "idx", "var", "return", "seed_values"], "doc_len": 106}
{"doc_id": "seaborn/_core/plot.py::Plotter._setup_scales", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_setup_scales", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _setup_scales(\n        self, p: Plot,\n        common: PlotData,\n        layers: list[Layer],\n        variables: list[str] | None = None,\n    ) -> None:\n\n        if variables is None:\n            # Add variables that have data but not a scale, which happens\n            # because this method can be called multiple time, to handle\n            # variables added during the Stat transform.\n            variables = []\n            for layer in layers:\n                variables.extend(layer[\"data\"].frame.columns)\n                for df in layer[\"data\"].frames.values():\n                    variables.extend(str(v) for v in df if v not in variables)\n            variables = [v for v in variables if v not in self._scales]\n\n        for var in variables:\n\n            # Determine whether this is a coordinate variable\n            # (i.e., x/y, paired x/y, or derivative such as xmax)\n            m = re.match(r\"^(?P<coord>(?P<axis>x|y)\\d*).*\", var)\n            if m is None:\n                coord = axis = None\n            else:\n                coord = m[\"coord\"]\n                axis = m[\"axis\"]\n\n            # Get keys that handle things like x0, xmax, properly where relevant\n            prop_key = var if axis is None else axis\n            scale_key = var if coord is None else coord\n\n            if prop_key not in PROPERTIES:\n                continue\n\n            # Concatenate layers, using only the relevant coordinate and faceting vars,\n            # This is unnecessarily wasteful, as layer data will often be redundant.\n            # But figuring out the minimal amount we need is more complicated.\n            cols = [var, \"col\", \"row\"]\n            parts = [common.frame.filter(cols)]\n            for layer in layers:\n                parts.append(layer[\"data\"].frame.filter(cols))\n                for df in layer[\"data\"].frames.values():\n                    parts.append(df.filter(cols))\n            var_df = pd.concat(parts, ignore_index=True)\n\n            prop = PROPERTIES[prop_key]\n            scale = self._get_scale(p, scale_key, prop, var_df[var])\n\n            if scale_key not in p._variables:\n                # TODO this implies that the variable was added by the stat\n                # It allows downstream orientation inference to work properly.\n                # But it feels rather hacky, so ideally revisit.\n                scale._priority = 0  # type: ignore\n\n            if axis is None:\n                # We could think about having a broader concept of (un)shared properties\n                # In general, not something you want to do (different scales in facets)\n                # But could make sense e.g. with paired plots. Build later.\n                share_state = None\n                subplots = []\n            else:\n                share_state = self._subplots.subplot_spec[f\"share{axis}\"]\n                subplots = [view for view in self._subplots if view[axis] == coord]\n\n            # Shared categorical axes are broken on matplotlib<3.4.0.\n            # https://github.com/matplotlib/matplotlib/pull/18308\n            # This only affects us when sharing *paired* axes. This is a novel/niche\n            # behavior, so we will raise rather than hack together a workaround.\n            if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):\n                paired_axis = axis in p._pair_spec.get(\"structure\", {})\n                cat_scale = isinstance(scale, Nominal)\n                ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]\n                shared_axes = share_state not in [False, \"none\", ok_dim]\n                if paired_axis and cat_scale and shared_axes:\n                    err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"\n                    raise RuntimeError(err)\n\n            if scale is None:\n                self._scales[var] = Scale._identity()\n            else:\n                try:\n                    self._scales[var] = scale._setup(var_df[var], prop)\n                except Exception as err:\n                    raise PlotSpecError._during(\"Scale setup\", var) from err\n\n            if axis is None or (var != coord and coord in p._variables):\n                # Everything below here applies only to coordinate variables\n                continue\n\n            # Set up an empty series to receive the transformed values.\n            # We need this to handle piecemeal transforms of categories -> floats.\n            transformed_data = []\n            for layer in layers:\n                index = layer[\"data\"].frame.index\n                empty_series = pd.Series(dtype=float, index=index, name=var)\n                transformed_data.append(empty_series)\n\n            for view in subplots:\n\n                axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")\n                seed_values = self._get_subplot_data(var_df, var, view, share_state)\n                view_scale = scale._setup(seed_values, prop, axis=axis_obj)\n                set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)\n\n                for layer, new_series in zip(layers, transformed_data):\n                    layer_df = layer[\"data\"].frame\n                    if var not in layer_df:\n                        continue\n\n                    idx = self._get_subplot_index(layer_df, view)\n                    try:\n                        new_series.loc[idx] = view_scale(layer_df.loc[idx, var])\n                    except Exception as err:\n                        spec_error = PlotSpecError._during(\"Scaling operation\", var)\n                        raise spec_error from err\n\n            # Now the transformed data series are complete, set update the layer data\n            for layer, new_series in zip(layers, transformed_data):\n                layer_df = layer[\"data\"].frame\n                if var in layer_df:\n                    layer_df[var] = new_series\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_setup_scales", "self", "p", "plot", "common", "plotdata", "layers", "list", "layer", "variables", "list", "str", "none", "none", "none", "if", "variables", "is", "none", "add", "variables", "that", "have", "data", "but", "not", "a", "scale", "which", "happens", "because", "this", "method", "can", "be", "called", "multiple", "time", "to", "handle", "variables", "added", "during", "the", "stat", "transform", "variables", "for", "layer", "in", "layers", "variables", "extend", "layer", "data", "frame", "columns", "for", "df", "in", "layer", "data", "frames", "values", "variables", "extend", "str", "v", "for", "v", "in", "df", "if", "v", "not", "in", "variables", "variables", "v", "for", "v", "in", "variables", "if", "v", "not", "in", "self", "_scales", "for", "var", "in", "variables", "determine", "whether", "this", "is", "a", "coordinate", "variable", "i", "e", "x", "y", "paired", "x", "y", "or", "derivative", "such", "as", "xmax", "m", "re", "match", "r", "p", "coord", "p", "axis", "x", "y", "d", "var", "if", "m", "is", "none", "coord", "axis", "none", "else", "coord", "m", "coord", "axis", "m", "axis", "get", "keys", "that", "handle", "things", "like", "x0", "xmax", "properly", "where", "relevant", "prop_key", "var", "if", "axis", "is", "none", "else", "axis", "scale_key", "var", "if", "coord", "is", "none", "else", "coord", "if", "prop_key", "not", "in", "properties", "continue", "concatenate", "layers", "using", "only", "the", "relevant", "coordinate", "and", "faceting", "vars", "this", "is", "unnecessarily", "wasteful", "as", "layer", "data", "will", "often", "be", "redundant", "but", "figuring", "out", "the", "minimal", "amount", "we", "need", "is", "more", "complicated", "cols", "var", "col", "row", "parts", "common", "frame", "filter", "cols", "for", "layer", "in", "layers", "parts", "append", "layer", "data", "frame", "filter", "cols", "for", "df", "in", "layer", "data", "frames", "values", "parts", "append", "df", "filter", "cols", "var_df", "pd", "concat", "parts", "ignore_index", "true", "prop", "properties", "prop_key", "scale", "self", "_get_scale", "p", "scale_key", "prop", "var_df", "var", "if", "scale_key", "not", "in", "p", "_variables", "todo", "this", "implies", "that", "the", "variable", "was", "added", "by", "the", "stat", "it", "allows", "downstream", "orientation", "inference", "to", "work", "properly", "but", "it", "feels", "rather", "hacky", "so", "ideally", "revisit", "scale", "_priority", "0", "type", "ignore", "if", "axis", "is", "none", "we", "could", "think", "about", "having", "a", "broader", "concept", "of", "un", "shared", "properties", "in", "general", "not", "something", "you", "want", "to", "do", "different", "scales", "in", "facets", "but", "could", "make", "sense", "e", "g", "with", "paired", "plots", "build", "later", "share_state", "none", "subplots", "else", "share_state", "self", "_subplots", "subplot_spec", "f", "share", "axis", "subplots", "view", "for", "view", "in", "self", "_subplots", "if", "view", "axis", "coord", "shared", "categorical", "axes", "are", "broken", "on", "matplotlib", "3", "4", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "18308", "this", "only", "affects", "us", "when", "sharing", "paired", "axes", "this", "is", "a", "novel", "niche", "behavior", "so", "we", "will", "raise", "rather", "than", "hack", "together", "a", "workaround", "if", "axis", "is", "not", "none", "and", "version", "mpl", "__version__", "version", "3", "4", "0", "paired_axis", "axis", "in", "p", "_pair_spec", "get", "structure", "cat_scale", "isinstance", "scale", "nominal", "ok_dim", "x", "col", "y", "row", "axis", "shared_axes", "share_state", "not", "in", "false", "none", "ok_dim", "if", "paired_axis", "and", "cat_scale", "and", "shared_axes", "err", "sharing", "paired", "categorical", "axes", "requires", "matplotlib", "3", "4", "0", "raise", "runtimeerror", "err", "if", "scale", "is", "none", "self", "_scales", "var", "scale", "_identity", "else", "try", "self", "_scales", "var", "scale", "_setup", "var_df", "var", "prop", "except", "exception", "as", "err", "raise", "plotspecerror", "_during", "scale", "setup", "var", "from", "err", "if", "axis", "is", "none", "or", "var", "coord", "and", "coord", "in", "p", "_variables", "everything", "below", "here", "applies", "only", "to", "coordinate", "variables", "continue", "set", "up", "an", "empty", "series", "to", "receive", "the", "transformed", "values", "we", "need", "this", "to", "handle", "piecemeal", "transforms", "of", "categories", "floats", "transformed_data", "for", "layer", "in", "layers", "index", "layer", "data", "frame", "index", "empty_series", "pd", "series", "dtype", "float", "index", "index", "name", "var", "transformed_data", "append", "empty_series", "for", "view", "in", "subplots", "axis_obj", "getattr", "view", "ax", "f", "axis", "axis", "seed_values", "self", "_get_subplot_data", "var_df", "var", "view", "share_state", "view_scale", "scale", "_setup", "seed_values", "prop", "axis", "axis_obj", "set_scale_obj", "view", "ax", "axis", "view_scale", "_matplotlib_scale", "for", "layer", "new_series", "in", "zip", "layers", "transformed_data", "layer_df", "layer", "data", "frame", "if", "var", "not", "in", "layer_df", "continue", "idx", "self", "_get_subplot_index", "layer_df", "view", "try", "new_series", "loc", "idx", "view_scale", "layer_df", "loc", "idx", "var", "except", "exception", "as", "err", "spec_error", "plotspecerror", "_during", "scaling", "operation", "var", "raise", "spec_error", "from", "err", "now", "the", "transformed", "data", "series", "are", "complete", "set", "update", "the", "layer", "data", "for", "layer", "new_series", "in", "zip", "layers", "transformed_data", "layer_df", "layer", "data", "frame", "if", "var", "in", "layer_df", "layer_df", "var", "new_series"], "doc_len": 654}
{"doc_id": "seaborn/_core/plot.py::Plotter._plot_layer", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_plot_layer", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _plot_layer(self, p: Plot, layer: Layer) -> None:\n\n        data = layer[\"data\"]\n        mark = layer[\"mark\"]\n        move = layer[\"move\"]\n\n        default_grouping_vars = [\"col\", \"row\", \"group\"]  # TODO where best to define?\n        grouping_properties = [v for v in PROPERTIES if v[0] not in \"xy\"]\n\n        pair_variables = p._pair_spec.get(\"structure\", {})\n\n        for subplots, df, scales in self._generate_pairings(data, pair_variables):\n\n            orient = layer[\"orient\"] or mark._infer_orient(scales)\n\n            def get_order(var):\n                # Ignore order for x/y: they have been scaled to numeric indices,\n                # so any original order is no longer valid. Default ordering rules\n                # sorted unique numbers will correctly reconstruct intended order\n                # TODO This is tricky, make sure we add some tests for this\n                if var not in \"xy\" and var in scales:\n                    return getattr(scales[var], \"order\", None)\n\n            if orient in df:\n                width = pd.Series(index=df.index, dtype=float)\n                for view in subplots:\n                    view_idx = self._get_subplot_data(\n                        df, orient, view, p._shares.get(orient)\n                    ).index\n                    view_df = df.loc[view_idx]\n                    if \"width\" in mark._mappable_props:\n                        view_width = mark._resolve(view_df, \"width\", None)\n                    elif \"width\" in df:\n                        view_width = view_df[\"width\"]\n                    else:\n                        view_width = 0.8  # TODO what default?\n                    spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])\n                    width.loc[view_idx] = view_width * spacing\n                df[\"width\"] = width\n\n            if \"baseline\" in mark._mappable_props:\n                # TODO what marks should have this?\n                # If we can set baseline with, e.g., Bar(), then the\n                # \"other\" (e.g. y for x oriented bars) parameterization\n                # is somewhat ambiguous.\n                baseline = mark._resolve(df, \"baseline\", None)\n            else:\n                # TODO unlike width, we might not want to add baseline to data\n                # if the mark doesn't use it. Practically, there is a concern about\n                # Mark abstraction like Area / Ribbon\n                baseline = 0 if \"baseline\" not in df else df[\"baseline\"]\n            df[\"baseline\"] = baseline\n\n            if move is not None:\n                moves = move if isinstance(move, list) else [move]\n                for move_step in moves:\n                    move_by = getattr(move_step, \"by\", None)\n                    if move_by is None:\n                        move_by = grouping_properties\n                    move_groupers = [*move_by, *default_grouping_vars]\n                    if move_step.group_by_orient:\n                        move_groupers.insert(0, orient)\n                    order = {var: get_order(var) for var in move_groupers}\n                    groupby = GroupBy(order)\n                    df = move_step(df, groupby, orient, scales)\n\n            df = self._unscale_coords(subplots, df, orient)\n\n            grouping_vars = mark._grouping_props + default_grouping_vars\n            split_generator = self._setup_split_generator(grouping_vars, df, subplots)\n\n            mark._plot(split_generator, scales, orient)\n\n        # TODO is this the right place for this?\n        for view in self._subplots:\n            view[\"ax\"].autoscale_view()\n\n        if layer[\"legend\"]:\n            self._update_legend_contents(p, mark, data, scales)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_plot_layer", "self", "p", "plot", "layer", "layer", "none", "data", "layer", "data", "mark", "layer", "mark", "move", "layer", "move", "default_grouping_vars", "col", "row", "group", "todo", "where", "best", "to", "define", "grouping_properties", "v", "for", "v", "in", "properties", "if", "v", "0", "not", "in", "xy", "pair_variables", "p", "_pair_spec", "get", "structure", "for", "subplots", "df", "scales", "in", "self", "_generate_pairings", "data", "pair_variables", "orient", "layer", "orient", "or", "mark", "_infer_orient", "scales", "def", "get_order", "var", "ignore", "order", "for", "x", "y", "they", "have", "been", "scaled", "to", "numeric", "indices", "so", "any", "original", "order", "is", "no", "longer", "valid", "default", "ordering", "rules", "sorted", "unique", "numbers", "will", "correctly", "reconstruct", "intended", "order", "todo", "this", "is", "tricky", "make", "sure", "we", "add", "some", "tests", "for", "this", "if", "var", "not", "in", "xy", "and", "var", "in", "scales", "return", "getattr", "scales", "var", "order", "none", "if", "orient", "in", "df", "width", "pd", "series", "index", "df", "index", "dtype", "float", "for", "view", "in", "subplots", "view_idx", "self", "_get_subplot_data", "df", "orient", "view", "p", "_shares", "get", "orient", "index", "view_df", "df", "loc", "view_idx", "if", "width", "in", "mark", "_mappable_props", "view_width", "mark", "_resolve", "view_df", "width", "none", "elif", "width", "in", "df", "view_width", "view_df", "width", "else", "view_width", "0", "8", "todo", "what", "default", "spacing", "scales", "orient", "_spacing", "view_df", "loc", "view_idx", "orient", "width", "loc", "view_idx", "view_width", "spacing", "df", "width", "width", "if", "baseline", "in", "mark", "_mappable_props", "todo", "what", "marks", "should", "have", "this", "if", "we", "can", "set", "baseline", "with", "e", "g", "bar", "then", "the", "other", "e", "g", "y", "for", "x", "oriented", "bars", "parameterization", "is", "somewhat", "ambiguous", "baseline", "mark", "_resolve", "df", "baseline", "none", "else", "todo", "unlike", "width", "we", "might", "not", "want", "to", "add", "baseline", "to", "data", "if", "the", "mark", "doesn", "t", "use", "it", "practically", "there", "is", "a", "concern", "about", "mark", "abstraction", "like", "area", "ribbon", "baseline", "0", "if", "baseline", "not", "in", "df", "else", "df", "baseline", "df", "baseline", "baseline", "if", "move", "is", "not", "none", "moves", "move", "if", "isinstance", "move", "list", "else", "move", "for", "move_step", "in", "moves", "move_by", "getattr", "move_step", "by", "none", "if", "move_by", "is", "none", "move_by", "grouping_properties", "move_groupers", "move_by", "default_grouping_vars", "if", "move_step", "group_by_orient", "move_groupers", "insert", "0", "orient", "order", "var", "get_order", "var", "for", "var", "in", "move_groupers", "groupby", "groupby", "order", "df", "move_step", "df", "groupby", "orient", "scales", "df", "self", "_unscale_coords", "subplots", "df", "orient", "grouping_vars", "mark", "_grouping_props", "default_grouping_vars", "split_generator", "self", "_setup_split_generator", "grouping_vars", "df", "subplots", "mark", "_plot", "split_generator", "scales", "orient", "todo", "is", "this", "the", "right", "place", "for", "this", "for", "view", "in", "self", "_subplots", "view", "ax", "autoscale_view", "if", "layer", "legend", "self", "_update_legend_contents", "p", "mark", "data", "scales"], "doc_len": 382}
{"doc_id": "seaborn/_core/plot.py::Plotter._unscale_coords", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_unscale_coords", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _unscale_coords(\n        self, subplots: list[dict], df: DataFrame, orient: str,\n    ) -> DataFrame:\n        # TODO do we still have numbers in the variable name at this point?\n        coord_cols = [c for c in df if re.match(r\"^[xy]\\D*$\", str(c))]\n        drop_cols = [*coord_cols, \"width\"] if \"width\" in df else coord_cols\n        out_df = (\n            df\n            .drop(drop_cols, axis=1)\n            .reindex(df.columns, axis=1)  # So unscaled columns retain their place\n            .copy(deep=False)\n        )\n\n        for view in subplots:\n            view_df = self._filter_subplot_data(df, view)\n            axes_df = view_df[coord_cols]\n            for var, values in axes_df.items():\n\n                axis = getattr(view[\"ax\"], f\"{str(var)[0]}axis\")\n                # TODO see https://github.com/matplotlib/matplotlib/issues/22713\n                transform = axis.get_transform().inverted().transform\n                inverted = transform(values)\n                out_df.loc[values.index, str(var)] = inverted\n\n                if var == orient and \"width\" in view_df:\n                    width = view_df[\"width\"]\n                    out_df.loc[values.index, \"width\"] = (\n                        transform(values + width / 2) - transform(values - width / 2)\n                    )\n\n        return out_df\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_unscale_coords", "self", "subplots", "list", "dict", "df", "dataframe", "orient", "str", "dataframe", "todo", "do", "we", "still", "have", "numbers", "in", "the", "variable", "name", "at", "this", "point", "coord_cols", "c", "for", "c", "in", "df", "if", "re", "match", "r", "xy", "d", "str", "c", "drop_cols", "coord_cols", "width", "if", "width", "in", "df", "else", "coord_cols", "out_df", "df", "drop", "drop_cols", "axis", "1", "reindex", "df", "columns", "axis", "1", "so", "unscaled", "columns", "retain", "their", "place", "copy", "deep", "false", "for", "view", "in", "subplots", "view_df", "self", "_filter_subplot_data", "df", "view", "axes_df", "view_df", "coord_cols", "for", "var", "values", "in", "axes_df", "items", "axis", "getattr", "view", "ax", "f", "str", "var", "0", "axis", "todo", "see", "https", "github", "com", "matplotlib", "matplotlib", "issues", "22713", "transform", "axis", "get_transform", "inverted", "transform", "inverted", "transform", "values", "out_df", "loc", "values", "index", "str", "var", "inverted", "if", "var", "orient", "and", "width", "in", "view_df", "width", "view_df", "width", "out_df", "loc", "values", "index", "width", "transform", "values", "width", "2", "transform", "values", "width", "2", "return", "out_df"], "doc_len": 148}
{"doc_id": "seaborn/_core/plot.py::Plotter._generate_pairings", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_generate_pairings", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _generate_pairings(\n        self, data: PlotData, pair_variables: dict,\n    ) -> Generator[\n        tuple[list[dict], DataFrame, dict[str, Scale]], None, None\n    ]:\n        # TODO retype return with subplot_spec or similar\n\n        iter_axes = itertools.product(*[\n            pair_variables.get(axis, [axis]) for axis in \"xy\"\n        ])\n\n        for x, y in iter_axes:\n\n            subplots = []\n            for view in self._subplots:\n                if (view[\"x\"] == x) and (view[\"y\"] == y):\n                    subplots.append(view)\n\n            if data.frame.empty and data.frames:\n                out_df = data.frames[(x, y)].copy()\n            elif not pair_variables:\n                out_df = data.frame.copy()\n            else:\n                if data.frame.empty and data.frames:\n                    out_df = data.frames[(x, y)].copy()\n                else:\n                    out_df = data.frame.copy()\n\n            scales = self._scales.copy()\n            if x in out_df:\n                scales[\"x\"] = self._scales[x]\n            if y in out_df:\n                scales[\"y\"] = self._scales[y]\n\n            for axis, var in zip(\"xy\", (x, y)):\n                if axis != var:\n                    out_df = out_df.rename(columns={var: axis})\n                    cols = [col for col in out_df if re.match(rf\"{axis}\\d+\", str(col))]\n                    out_df = out_df.drop(cols, axis=1)\n\n            yield subplots, out_df, scales\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_generate_pairings", "self", "data", "plotdata", "pair_variables", "dict", "generator", "tuple", "list", "dict", "dataframe", "dict", "str", "scale", "none", "none", "todo", "retype", "return", "with", "subplot_spec", "or", "similar", "iter_axes", "itertools", "product", "pair_variables", "get", "axis", "axis", "for", "axis", "in", "xy", "for", "x", "y", "in", "iter_axes", "subplots", "for", "view", "in", "self", "_subplots", "if", "view", "x", "x", "and", "view", "y", "y", "subplots", "append", "view", "if", "data", "frame", "empty", "and", "data", "frames", "out_df", "data", "frames", "x", "y", "copy", "elif", "not", "pair_variables", "out_df", "data", "frame", "copy", "else", "if", "data", "frame", "empty", "and", "data", "frames", "out_df", "data", "frames", "x", "y", "copy", "else", "out_df", "data", "frame", "copy", "scales", "self", "_scales", "copy", "if", "x", "in", "out_df", "scales", "x", "self", "_scales", "x", "if", "y", "in", "out_df", "scales", "y", "self", "_scales", "y", "for", "axis", "var", "in", "zip", "xy", "x", "y", "if", "axis", "var", "out_df", "out_df", "rename", "columns", "var", "axis", "cols", "col", "for", "col", "in", "out_df", "if", "re", "match", "rf", "axis", "d", "str", "col", "out_df", "out_df", "drop", "cols", "axis", "1", "yield", "subplots", "out_df", "scales"], "doc_len": 164}
{"doc_id": "seaborn/_core/plot.py::Plotter._get_subplot_index", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_get_subplot_index", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:\n\n        dims = df.columns.intersection([\"col\", \"row\"])\n        if dims.empty:\n            return df.index\n\n        keep_rows = pd.Series(True, df.index, dtype=bool)\n        for dim in dims:\n            keep_rows &= df[dim] == subplot[dim]\n        return df.index[keep_rows]\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_get_subplot_index", "self", "df", "dataframe", "subplot", "dict", "index", "dims", "df", "columns", "intersection", "col", "row", "if", "dims", "empty", "return", "df", "index", "keep_rows", "pd", "series", "true", "df", "index", "dtype", "bool", "for", "dim", "in", "dims", "keep_rows", "df", "dim", "subplot", "dim", "return", "df", "index", "keep_rows"], "doc_len": 46}
{"doc_id": "seaborn/_core/plot.py::Plotter._filter_subplot_data", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_filter_subplot_data", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:\n        # TODO note redundancies with preceding function ... needs refactoring\n        dims = df.columns.intersection([\"col\", \"row\"])\n        if dims.empty:\n            return df\n\n        keep_rows = pd.Series(True, df.index, dtype=bool)\n        for dim in dims:\n            keep_rows &= df[dim] == subplot[dim]\n        return df[keep_rows]\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_filter_subplot_data", "self", "df", "dataframe", "subplot", "dict", "dataframe", "todo", "note", "redundancies", "with", "preceding", "function", "needs", "refactoring", "dims", "df", "columns", "intersection", "col", "row", "if", "dims", "empty", "return", "df", "keep_rows", "pd", "series", "true", "df", "index", "dtype", "bool", "for", "dim", "in", "dims", "keep_rows", "df", "dim", "subplot", "dim", "return", "df", "keep_rows"], "doc_len": 52}
{"doc_id": "seaborn/_core/plot.py::Plotter._setup_split_generator", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_setup_split_generator", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _setup_split_generator(\n        self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],\n    ) -> Callable[[], Generator]:\n\n        grouping_keys = []\n        grouping_vars = [\n            v for v in grouping_vars if v in df and v not in [\"col\", \"row\"]\n        ]\n        for var in grouping_vars:\n            order = getattr(self._scales[var], \"order\", None)\n            if order is None:\n                order = categorical_order(df[var])\n            grouping_keys.append(order)\n\n        def split_generator(keep_na=False) -> Generator:\n\n            for view in subplots:\n\n                axes_df = self._filter_subplot_data(df, view)\n\n                with pd.option_context(\"mode.use_inf_as_na\", True):\n                    if keep_na:\n                        # The simpler thing to do would be x.dropna().reindex(x.index).\n                        # But that doesn't work with the way that the subset iteration\n                        # is written below, which assumes data for grouping vars.\n                        # Matplotlib (usually?) masks nan data, so this should \"work\".\n                        # Downstream code can also drop these rows, at some speed cost.\n                        present = axes_df.notna().all(axis=1)\n                        nulled = {}\n                        for axis in \"xy\":\n                            if axis in axes_df:\n                                nulled[axis] = axes_df[axis].where(present)\n                        axes_df = axes_df.assign(**nulled)\n                    else:\n                        axes_df = axes_df.dropna()\n\n                subplot_keys = {}\n                for dim in [\"col\", \"row\"]:\n                    if view[dim] is not None:\n                        subplot_keys[dim] = view[dim]\n\n                if not grouping_vars or not any(grouping_keys):\n                    if not axes_df.empty:\n                        yield subplot_keys, axes_df.copy(), view[\"ax\"]\n                    continue\n\n                grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)\n\n                for key in itertools.product(*grouping_keys):\n\n                    # Pandas fails with singleton tuple inputs\n                    pd_key = key[0] if len(key) == 1 else key\n\n                    try:\n                        df_subset = grouped_df.get_group(pd_key)\n                    except KeyError:\n                        # TODO (from initial work on categorical plots refactor)\n                        # We are adding this to allow backwards compatability\n                        # with the empty artists that old categorical plots would\n                        # add (before 0.12), which we may decide to break, in which\n                        # case this option could be removed\n                        df_subset = axes_df.loc[[]]\n\n                    if df_subset.empty:\n                        continue\n\n                    sub_vars = dict(zip(grouping_vars, key))\n                    sub_vars.update(subplot_keys)\n\n                    # TODO need copy(deep=...) policy (here, above, anywhere else?)\n                    yield sub_vars, df_subset.copy(), view[\"ax\"]\n\n        return split_generator\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_setup_split_generator", "self", "grouping_vars", "list", "str", "df", "dataframe", "subplots", "list", "dict", "str", "any", "callable", "generator", "grouping_keys", "grouping_vars", "v", "for", "v", "in", "grouping_vars", "if", "v", "in", "df", "and", "v", "not", "in", "col", "row", "for", "var", "in", "grouping_vars", "order", "getattr", "self", "_scales", "var", "order", "none", "if", "order", "is", "none", "order", "categorical_order", "df", "var", "grouping_keys", "append", "order", "def", "split_generator", "keep_na", "false", "generator", "for", "view", "in", "subplots", "axes_df", "self", "_filter_subplot_data", "df", "view", "with", "pd", "option_context", "mode", "use_inf_as_na", "true", "if", "keep_na", "the", "simpler", "thing", "to", "do", "would", "be", "x", "dropna", "reindex", "x", "index", "but", "that", "doesn", "t", "work", "with", "the", "way", "that", "the", "subset", "iteration", "is", "written", "below", "which", "assumes", "data", "for", "grouping", "vars", "matplotlib", "usually", "masks", "nan", "data", "so", "this", "should", "work", "downstream", "code", "can", "also", "drop", "these", "rows", "at", "some", "speed", "cost", "present", "axes_df", "notna", "all", "axis", "1", "nulled", "for", "axis", "in", "xy", "if", "axis", "in", "axes_df", "nulled", "axis", "axes_df", "axis", "where", "present", "axes_df", "axes_df", "assign", "nulled", "else", "axes_df", "axes_df", "dropna", "subplot_keys", "for", "dim", "in", "col", "row", "if", "view", "dim", "is", "not", "none", "subplot_keys", "dim", "view", "dim", "if", "not", "grouping_vars", "or", "not", "any", "grouping_keys", "if", "not", "axes_df", "empty", "yield", "subplot_keys", "axes_df", "copy", "view", "ax", "continue", "grouped_df", "axes_df", "groupby", "grouping_vars", "sort", "false", "as_index", "false", "for", "key", "in", "itertools", "product", "grouping_keys", "pandas", "fails", "with", "singleton", "tuple", "inputs", "pd_key", "key", "0", "if", "len", "key", "1", "else", "key", "try", "df_subset", "grouped_df", "get_group", "pd_key", "except", "keyerror", "todo", "from", "initial", "work", "on", "categorical", "plots", "refactor", "we", "are", "adding", "this", "to", "allow", "backwards", "compatability", "with", "the", "empty", "artists", "that", "old", "categorical", "plots", "would", "add", "before", "0", "12", "which", "we", "may", "decide", "to", "break", "in", "which", "case", "this", "option", "could", "be", "removed", "df_subset", "axes_df", "loc", "if", "df_subset", "empty", "continue", "sub_vars", "dict", "zip", "grouping_vars", "key", "sub_vars", "update", "subplot_keys", "todo", "need", "copy", "deep", "policy", "here", "above", "anywhere", "else", "yield", "sub_vars", "df_subset", "copy", "view", "ax", "return", "split_generator"], "doc_len": 308}
{"doc_id": "seaborn/_core/plot.py::Plotter._update_legend_contents", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_update_legend_contents", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _update_legend_contents(\n        self,\n        p: Plot,\n        mark: Mark,\n        data: PlotData,\n        scales: dict[str, Scale],\n    ) -> None:\n        \"\"\"Add legend artists / labels for one layer in the plot.\"\"\"\n        if data.frame.empty and data.frames:\n            legend_vars: list[str] = []\n            for frame in data.frames.values():\n                frame_vars = frame.columns.intersection(list(scales))\n                legend_vars.extend(v for v in frame_vars if v not in legend_vars)\n        else:\n            legend_vars = list(data.frame.columns.intersection(list(scales)))\n\n        # First pass: Identify the values that will be shown for each variable\n        schema: list[tuple[\n            tuple[str, str | int], list[str], tuple[list, list[str]]\n        ]] = []\n        schema = []\n        for var in legend_vars:\n            var_legend = scales[var]._legend\n            if var_legend is not None:\n                values, labels = var_legend\n                for (_, part_id), part_vars, _ in schema:\n                    if data.ids[var] == part_id:\n                        # Allow multiple plot semantics to represent same data variable\n                        part_vars.append(var)\n                        break\n                else:\n                    title = self._resolve_label(p, var, data.names[var])\n                    entry = (title, data.ids[var]), [var], (values, labels)\n                    schema.append(entry)\n\n        # Second pass, generate an artist corresponding to each value\n        contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []\n        for key, variables, (values, labels) in schema:\n            artists = []\n            for val in values:\n                artist = mark._legend_artist(variables, val, scales)\n                if artist is not None:\n                    artists.append(artist)\n            if artists:\n                contents.append((key, artists, labels))\n\n        self._legend_contents.extend(contents)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_update_legend_contents", "self", "p", "plot", "mark", "mark", "data", "plotdata", "scales", "dict", "str", "scale", "none", "add", "legend", "artists", "labels", "for", "one", "layer", "in", "the", "plot", "if", "data", "frame", "empty", "and", "data", "frames", "legend_vars", "list", "str", "for", "frame", "in", "data", "frames", "values", "frame_vars", "frame", "columns", "intersection", "list", "scales", "legend_vars", "extend", "v", "for", "v", "in", "frame_vars", "if", "v", "not", "in", "legend_vars", "else", "legend_vars", "list", "data", "frame", "columns", "intersection", "list", "scales", "first", "pass", "identify", "the", "values", "that", "will", "be", "shown", "for", "each", "variable", "schema", "list", "tuple", "tuple", "str", "str", "int", "list", "str", "tuple", "list", "list", "str", "schema", "for", "var", "in", "legend_vars", "var_legend", "scales", "var", "_legend", "if", "var_legend", "is", "not", "none", "values", "labels", "var_legend", "for", "_", "part_id", "part_vars", "_", "in", "schema", "if", "data", "ids", "var", "part_id", "allow", "multiple", "plot", "semantics", "to", "represent", "same", "data", "variable", "part_vars", "append", "var", "break", "else", "title", "self", "_resolve_label", "p", "var", "data", "names", "var", "entry", "title", "data", "ids", "var", "var", "values", "labels", "schema", "append", "entry", "second", "pass", "generate", "an", "artist", "corresponding", "to", "each", "value", "contents", "list", "tuple", "tuple", "str", "str", "int", "any", "list", "str", "for", "key", "variables", "values", "labels", "in", "schema", "artists", "for", "val", "in", "values", "artist", "mark", "_legend_artist", "variables", "val", "scales", "if", "artist", "is", "not", "none", "artists", "append", "artist", "if", "artists", "contents", "append", "key", "artists", "labels", "self", "_legend_contents", "extend", "contents"], "doc_len": 215}
{"doc_id": "seaborn/_core/plot.py::Plotter._make_legend", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_make_legend", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _make_legend(self, p: Plot) -> None:\n        \"\"\"Create the legend artist(s) and add onto the figure.\"\"\"\n        # Combine artists representing same information across layers\n        # Input list has an entry for each distinct variable in each layer\n        # Output dict has an entry for each distinct variable\n        merged_contents: dict[\n            tuple[str, str | int], tuple[list[Artist], list[str]],\n        ] = {}\n        for key, new_artists, labels in self._legend_contents:\n            # Key is (name, id); we need the id to resolve variable uniqueness,\n            # but will need the name in the next step to title the legend\n            if key in merged_contents:\n                # Copy so inplace updates don't propagate back to legend_contents\n                existing_artists = merged_contents[key][0]\n                for i, artist in enumerate(existing_artists):\n                    # Matplotlib accepts a tuple of artists and will overlay them\n                    if isinstance(artist, tuple):\n                        artist += new_artists[i],\n                    else:\n                        existing_artists[i] = artist, new_artists[i]\n            else:\n                merged_contents[key] = new_artists.copy(), labels\n\n        # TODO explain\n        loc = \"center right\" if self._pyplot else \"center left\"\n\n        base_legend = None\n        for (name, _), (handles, labels) in merged_contents.items():\n\n            legend = mpl.legend.Legend(\n                self._figure,\n                handles,\n                labels,\n                title=name,\n                loc=loc,\n                bbox_to_anchor=(.98, .55),\n            )\n\n            if base_legend:\n                # Matplotlib has no public API for this so it is a bit of a hack.\n                # Ideally we'd define our own legend class with more flexibility,\n                # but that is a lot of work!\n                base_legend_box = base_legend.get_children()[0]\n                this_legend_box = legend.get_children()[0]\n                base_legend_box.get_children().extend(this_legend_box.get_children())\n            else:\n                base_legend = legend\n                self._figure.legends.append(legend)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_make_legend", "self", "p", "plot", "none", "create", "the", "legend", "artist", "s", "and", "add", "onto", "the", "figure", "combine", "artists", "representing", "same", "information", "across", "layers", "input", "list", "has", "an", "entry", "for", "each", "distinct", "variable", "in", "each", "layer", "output", "dict", "has", "an", "entry", "for", "each", "distinct", "variable", "merged_contents", "dict", "tuple", "str", "str", "int", "tuple", "list", "artist", "list", "str", "for", "key", "new_artists", "labels", "in", "self", "_legend_contents", "key", "is", "name", "id", "we", "need", "the", "id", "to", "resolve", "variable", "uniqueness", "but", "will", "need", "the", "name", "in", "the", "next", "step", "to", "title", "the", "legend", "if", "key", "in", "merged_contents", "copy", "so", "inplace", "updates", "don", "t", "propagate", "back", "to", "legend_contents", "existing_artists", "merged_contents", "key", "0", "for", "i", "artist", "in", "enumerate", "existing_artists", "matplotlib", "accepts", "a", "tuple", "of", "artists", "and", "will", "overlay", "them", "if", "isinstance", "artist", "tuple", "artist", "new_artists", "i", "else", "existing_artists", "i", "artist", "new_artists", "i", "else", "merged_contents", "key", "new_artists", "copy", "labels", "todo", "explain", "loc", "center", "right", "if", "self", "_pyplot", "else", "center", "left", "base_legend", "none", "for", "name", "_", "handles", "labels", "in", "merged_contents", "items", "legend", "mpl", "legend", "legend", "self", "_figure", "handles", "labels", "title", "name", "loc", "loc", "bbox_to_anchor", "98", "55", "if", "base_legend", "matplotlib", "has", "no", "public", "api", "for", "this", "so", "it", "is", "a", "bit", "of", "a", "hack", "ideally", "we", "d", "define", "our", "own", "legend", "class", "with", "more", "flexibility", "but", "that", "is", "a", "lot", "of", "work", "base_legend_box", "base_legend", "get_children", "0", "this_legend_box", "legend", "get_children", "0", "base_legend_box", "get_children", "extend", "this_legend_box", "get_children", "else", "base_legend", "legend", "self", "_figure", "legends", "append", "legend"], "doc_len": 237}
{"doc_id": "seaborn/_core/plot.py::Plotter._finalize_figure", "file_path": "seaborn/_core/plot.py", "class_name": "Plotter", "func_name": "_finalize_figure", "text": "文件路径: seaborn/_core/plot.py, 类名: Plotter\n    def _finalize_figure(self, p: Plot) -> None:\n\n        for sub in self._subplots:\n            ax = sub[\"ax\"]\n            for axis in \"xy\":\n                axis_key = sub[axis]\n                axis_obj = getattr(ax, f\"{axis}axis\")\n\n                # Axis limits\n                if axis_key in p._limits:\n                    convert_units = getattr(ax, f\"{axis}axis\").convert_units\n                    a, b = p._limits[axis_key]\n                    lo = a if a is None else convert_units(a)\n                    hi = b if b is None else convert_units(b)\n                    if isinstance(a, str):\n                        lo = cast(float, lo) - 0.5\n                    if isinstance(b, str):\n                        hi = cast(float, hi) + 0.5\n                    ax.set(**{f\"{axis}lim\": (lo, hi)})\n\n                # Nominal scale special-casing\n                if isinstance(self._scales.get(axis_key), Nominal):\n                    axis_obj.grid(False, which=\"both\")\n                    if axis_key not in p._limits:\n                        nticks = len(axis_obj.get_major_ticks())\n                        lo, hi = -.5, nticks - .5\n                        if axis == \"y\":\n                            lo, hi = hi, lo\n                        set_lim = getattr(ax, f\"set_{axis}lim\")\n                        set_lim(lo, hi, auto=None)\n\n        engine_default = None if p._target is not None else \"tight\"\n        layout_engine = p._layout_spec.get(\"engine\", engine_default)\n        set_layout_engine(self._figure, layout_engine)\n", "tokens": ["seaborn", "_core", "plot", "py", "plotter", "def", "_finalize_figure", "self", "p", "plot", "none", "for", "sub", "in", "self", "_subplots", "ax", "sub", "ax", "for", "axis", "in", "xy", "axis_key", "sub", "axis", "axis_obj", "getattr", "ax", "f", "axis", "axis", "axis", "limits", "if", "axis_key", "in", "p", "_limits", "convert_units", "getattr", "ax", "f", "axis", "axis", "convert_units", "a", "b", "p", "_limits", "axis_key", "lo", "a", "if", "a", "is", "none", "else", "convert_units", "a", "hi", "b", "if", "b", "is", "none", "else", "convert_units", "b", "if", "isinstance", "a", "str", "lo", "cast", "float", "lo", "0", "5", "if", "isinstance", "b", "str", "hi", "cast", "float", "hi", "0", "5", "ax", "set", "f", "axis", "lim", "lo", "hi", "nominal", "scale", "special", "casing", "if", "isinstance", "self", "_scales", "get", "axis_key", "nominal", "axis_obj", "grid", "false", "which", "both", "if", "axis_key", "not", "in", "p", "_limits", "nticks", "len", "axis_obj", "get_major_ticks", "lo", "hi", "5", "nticks", "5", "if", "axis", "y", "lo", "hi", "hi", "lo", "set_lim", "getattr", "ax", "f", "set_", "axis", "lim", "set_lim", "lo", "hi", "auto", "none", "engine_default", "none", "if", "p", "_target", "is", "not", "none", "else", "tight", "layout_engine", "p", "_layout_spec", "get", "engine", "engine_default", "set_layout_engine", "self", "_figure", "layout_engine"], "doc_len": 166}
{"doc_id": "seaborn/_core/properties.py::Property.__init__", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "__init__", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def __init__(self, variable: str | None = None):\n        \"\"\"Initialize the property with the name of the corresponding plot variable.\"\"\"\n        if not variable:\n            variable = self.__class__.__name__.lower()\n        self.variable = variable\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "__init__", "self", "variable", "str", "none", "none", "initialize", "the", "property", "with", "the", "name", "of", "the", "corresponding", "plot", "variable", "if", "not", "variable", "variable", "self", "__class__", "__name__", "lower", "self", "variable", "variable"], "doc_len": 34}
{"doc_id": "seaborn/_core/properties.py::Property.default_scale", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "default_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def default_scale(self, data: Series) -> Scale:\n        \"\"\"Given data, initialize appropriate scale class.\"\"\"\n        # TODO allow variable_type to be \"boolean\" if that's a scale?\n        # TODO how will this handle data with units that can be treated as numeric\n        # if passed through a registered matplotlib converter?\n        var_type = variable_type(data, boolean_type=\"numeric\")\n        if var_type == \"numeric\":\n            return Continuous()\n        elif var_type == \"datetime\":\n            return Temporal()\n        # TODO others\n        # time-based (TimeStamp, TimeDelta, Period)\n        # boolean scale?\n        else:\n            return Nominal()\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "default_scale", "self", "data", "series", "scale", "given", "data", "initialize", "appropriate", "scale", "class", "todo", "allow", "variable_type", "to", "be", "boolean", "if", "that", "s", "a", "scale", "todo", "how", "will", "this", "handle", "data", "with", "units", "that", "can", "be", "treated", "as", "numeric", "if", "passed", "through", "a", "registered", "matplotlib", "converter", "var_type", "variable_type", "data", "boolean_type", "numeric", "if", "var_type", "numeric", "return", "continuous", "elif", "var_type", "datetime", "return", "temporal", "todo", "others", "time", "based", "timestamp", "timedelta", "period", "boolean", "scale", "else", "return", "nominal"], "doc_len": 76}
{"doc_id": "seaborn/_core/properties.py::Property.infer_scale", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "infer_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def infer_scale(self, arg: Any, data: Series) -> Scale:\n        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"\n        # TODO put these somewhere external for validation\n        # TODO putting this here won't pick it up if subclasses define infer_scale\n        # (e.g. color). How best to handle that? One option is to call super after\n        # handling property-specific possibilities (e.g. for color check that the\n        # arg is not a valid palette name) but that could get tricky.\n        trans_args = [\"log\", \"symlog\", \"logit\", \"pow\", \"sqrt\"]\n        if isinstance(arg, str):\n            if any(arg.startswith(k) for k in trans_args):\n                # TODO validate numeric type? That should happen centrally somewhere\n                return Continuous(trans=arg)\n            else:\n                msg = f\"Unknown magic arg for {self.variable} scale: '{arg}'.\"\n                raise ValueError(msg)\n        else:\n            arg_type = type(arg).__name__\n            msg = f\"Magic arg for {self.variable} scale must be str, not {arg_type}.\"\n            raise TypeError(msg)\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "infer_scale", "self", "arg", "any", "data", "series", "scale", "given", "data", "and", "a", "scaling", "argument", "initialize", "appropriate", "scale", "class", "todo", "put", "these", "somewhere", "external", "for", "validation", "todo", "putting", "this", "here", "won", "t", "pick", "it", "up", "if", "subclasses", "define", "infer_scale", "e", "g", "color", "how", "best", "to", "handle", "that", "one", "option", "is", "to", "call", "super", "after", "handling", "property", "specific", "possibilities", "e", "g", "for", "color", "check", "that", "the", "arg", "is", "not", "a", "valid", "palette", "name", "but", "that", "could", "get", "tricky", "trans_args", "log", "symlog", "logit", "pow", "sqrt", "if", "isinstance", "arg", "str", "if", "any", "arg", "startswith", "k", "for", "k", "in", "trans_args", "todo", "validate", "numeric", "type", "that", "should", "happen", "centrally", "somewhere", "return", "continuous", "trans", "arg", "else", "msg", "f", "unknown", "magic", "arg", "for", "self", "variable", "scale", "arg", "raise", "valueerror", "msg", "else", "arg_type", "type", "arg", "__name__", "msg", "f", "magic", "arg", "for", "self", "variable", "scale", "must", "be", "str", "not", "arg_type", "raise", "typeerror", "msg"], "doc_len": 148}
{"doc_id": "seaborn/_core/properties.py::Property.get_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "get_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def get_mapping(\n        self, scale: Scale, data: Series\n    ) -> Callable[[ArrayLike], ArrayLike]:\n        \"\"\"Return a function that maps from data domain to property range.\"\"\"\n        def identity(x):\n            return x\n        return identity\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "get_mapping", "self", "scale", "scale", "data", "series", "callable", "arraylike", "arraylike", "return", "a", "function", "that", "maps", "from", "data", "domain", "to", "property", "range", "def", "identity", "x", "return", "x", "return", "identity"], "doc_len": 33}
{"doc_id": "seaborn/_core/properties.py::Property.standardize", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "standardize", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def standardize(self, val: Any) -> Any:\n        \"\"\"Coerce flexible property value to standardized representation.\"\"\"\n        return val\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "standardize", "self", "val", "any", "any", "coerce", "flexible", "property", "value", "to", "standardized", "representation", "return", "val"], "doc_len": 20}
{"doc_id": "seaborn/_core/properties.py::Property._check_dict_entries", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "_check_dict_entries", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def _check_dict_entries(self, levels: list, values: dict) -> None:\n        \"\"\"Input check when values are provided as a dictionary.\"\"\"\n        missing = set(levels) - set(values)\n        if missing:\n            formatted = \", \".join(map(repr, sorted(missing, key=str)))\n            err = f\"No entry in {self.variable} dictionary for {formatted}\"\n            raise ValueError(err)\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "_check_dict_entries", "self", "levels", "list", "values", "dict", "none", "input", "check", "when", "values", "are", "provided", "as", "a", "dictionary", "missing", "set", "levels", "set", "values", "if", "missing", "formatted", "join", "map", "repr", "sorted", "missing", "key", "str", "err", "f", "no", "entry", "in", "self", "variable", "dictionary", "for", "formatted", "raise", "valueerror", "err"], "doc_len": 50}
{"doc_id": "seaborn/_core/properties.py::Property._check_list_length", "file_path": "seaborn/_core/properties.py", "class_name": "Property", "func_name": "_check_list_length", "text": "文件路径: seaborn/_core/properties.py, 类名: Property\n    def _check_list_length(self, levels: list, values: list) -> list:\n        \"\"\"Input check when values are provided as a list.\"\"\"\n        message = \"\"\n        if len(levels) > len(values):\n            message = \" \".join([\n                f\"\\nThe {self.variable} list has fewer values ({len(values)})\",\n                f\"than needed ({len(levels)}) and will cycle, which may\",\n                \"produce an uninterpretable plot.\"\n            ])\n            values = [x for _, x in zip(levels, itertools.cycle(values))]\n\n        elif len(values) > len(levels):\n            message = \" \".join([\n                f\"The {self.variable} list has more values ({len(values)})\",\n                f\"than needed ({len(levels)}), which may not be intended.\",\n            ])\n            values = values[:len(levels)]\n\n        # TODO look into custom PlotSpecWarning with better formatting\n        if message:\n            warnings.warn(message, UserWarning)\n\n        return values\n", "tokens": ["seaborn", "_core", "properties", "py", "property", "def", "_check_list_length", "self", "levels", "list", "values", "list", "list", "input", "check", "when", "values", "are", "provided", "as", "a", "list", "message", "if", "len", "levels", "len", "values", "message", "join", "f", "nthe", "self", "variable", "list", "has", "fewer", "values", "len", "values", "f", "than", "needed", "len", "levels", "and", "will", "cycle", "which", "may", "produce", "an", "uninterpretable", "plot", "values", "x", "for", "_", "x", "in", "zip", "levels", "itertools", "cycle", "values", "elif", "len", "values", "len", "levels", "message", "join", "f", "the", "self", "variable", "list", "has", "more", "values", "len", "values", "f", "than", "needed", "len", "levels", "which", "may", "not", "be", "intended", "values", "values", "len", "levels", "todo", "look", "into", "custom", "plotspecwarning", "with", "better", "formatting", "if", "message", "warnings", "warn", "message", "userwarning", "return", "values"], "doc_len": 112}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty.default_range", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "default_range", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def default_range(self) -> tuple[float, float]:\n        \"\"\"Min and max values used by default for semantic mapping.\"\"\"\n        return self._default_range\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "default_range", "self", "tuple", "float", "float", "min", "and", "max", "values", "used", "by", "default", "for", "semantic", "mapping", "return", "self", "_default_range"], "doc_len": 24}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty._forward", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "_forward", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def _forward(self, values: ArrayLike) -> ArrayLike:\n        \"\"\"Transform applied to native values before linear mapping into interval.\"\"\"\n        return values\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "_forward", "self", "values", "arraylike", "arraylike", "transform", "applied", "to", "native", "values", "before", "linear", "mapping", "into", "interval", "return", "values"], "doc_len": 23}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty._inverse", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "_inverse", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def _inverse(self, values: ArrayLike) -> ArrayLike:\n        \"\"\"Transform applied to results of mapping that returns to native values.\"\"\"\n        return values\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "_inverse", "self", "values", "arraylike", "arraylike", "transform", "applied", "to", "results", "of", "mapping", "that", "returns", "to", "native", "values", "return", "values"], "doc_len": 24}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty.infer_scale", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "infer_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def infer_scale(self, arg: Any, data: Series) -> Scale:\n        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"\n\n        # TODO infer continuous based on log/sqrt etc?\n\n        if isinstance(arg, (list, dict)):\n            return Nominal(arg)\n        elif variable_type(data) == \"categorical\":\n            return Nominal(arg)\n        elif variable_type(data) == \"datetime\":\n            return Temporal(arg)\n        # TODO other variable types\n        else:\n            return Continuous(arg)\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "infer_scale", "self", "arg", "any", "data", "series", "scale", "given", "data", "and", "a", "scaling", "argument", "initialize", "appropriate", "scale", "class", "todo", "infer", "continuous", "based", "on", "log", "sqrt", "etc", "if", "isinstance", "arg", "list", "dict", "return", "nominal", "arg", "elif", "variable_type", "data", "categorical", "return", "nominal", "arg", "elif", "variable_type", "data", "datetime", "return", "temporal", "arg", "todo", "other", "variable", "types", "else", "return", "continuous", "arg"], "doc_len": 61}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty.get_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "get_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def get_mapping(\n        self, scale: Scale, data: ArrayLike\n    ) -> Callable[[ArrayLike], ArrayLike]:\n        \"\"\"Return a function that maps from data domain to property range.\"\"\"\n        if isinstance(scale, Nominal):\n            return self._get_categorical_mapping(scale, data)\n\n        if scale.values is None:\n            vmin, vmax = self._forward(self.default_range)\n        elif isinstance(scale.values, tuple) and len(scale.values) == 2:\n            vmin, vmax = self._forward(scale.values)\n        else:\n            if isinstance(scale.values, tuple):\n                actual = f\"{len(scale.values)}-tuple\"\n            else:\n                actual = str(type(scale.values))\n            scale_class = scale.__class__.__name__\n            err = \" \".join([\n                f\"Values for {self.variable} variables with {scale_class} scale\",\n                f\"must be 2-tuple; not {actual}.\",\n            ])\n            raise TypeError(err)\n\n        def mapping(x):\n            return self._inverse(np.multiply(x, vmax - vmin) + vmin)\n\n        return mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "get_mapping", "self", "scale", "scale", "data", "arraylike", "callable", "arraylike", "arraylike", "return", "a", "function", "that", "maps", "from", "data", "domain", "to", "property", "range", "if", "isinstance", "scale", "nominal", "return", "self", "_get_categorical_mapping", "scale", "data", "if", "scale", "values", "is", "none", "vmin", "vmax", "self", "_forward", "self", "default_range", "elif", "isinstance", "scale", "values", "tuple", "and", "len", "scale", "values", "2", "vmin", "vmax", "self", "_forward", "scale", "values", "else", "if", "isinstance", "scale", "values", "tuple", "actual", "f", "len", "scale", "values", "tuple", "else", "actual", "str", "type", "scale", "values", "scale_class", "scale", "__class__", "__name__", "err", "join", "f", "values", "for", "self", "variable", "variables", "with", "scale_class", "scale", "f", "must", "be", "2", "tuple", "not", "actual", "raise", "typeerror", "err", "def", "mapping", "x", "return", "self", "_inverse", "np", "multiply", "x", "vmax", "vmin", "vmin", "return", "mapping"], "doc_len": 119}
{"doc_id": "seaborn/_core/properties.py::IntervalProperty._get_categorical_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "IntervalProperty", "func_name": "_get_categorical_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: IntervalProperty\n    def _get_categorical_mapping(\n        self, scale: Nominal, data: ArrayLike\n    ) -> Callable[[ArrayLike], ArrayLike]:\n        \"\"\"Identify evenly-spaced values using interval or explicit mapping.\"\"\"\n        levels = categorical_order(data, scale.order)\n\n        if isinstance(scale.values, dict):\n            self._check_dict_entries(levels, scale.values)\n            values = [scale.values[x] for x in levels]\n        elif isinstance(scale.values, list):\n            values = self._check_list_length(levels, scale.values)\n        else:\n            if scale.values is None:\n                vmin, vmax = self.default_range\n            elif isinstance(scale.values, tuple):\n                vmin, vmax = scale.values\n            else:\n                scale_class = scale.__class__.__name__\n                err = \" \".join([\n                    f\"Values for {self.variable} variables with {scale_class} scale\",\n                    f\"must be a dict, list or tuple; not {type(scale.values)}\",\n                ])\n                raise TypeError(err)\n\n            vmin, vmax = self._forward([vmin, vmax])\n            values = self._inverse(np.linspace(vmax, vmin, len(levels)))\n\n        def mapping(x):\n            ixs = np.asarray(x, np.intp)\n            out = np.full(len(x), np.nan)\n            use = np.isfinite(x)\n            out[use] = np.take(values, ixs[use])\n            return out\n\n        return mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "intervalproperty", "def", "_get_categorical_mapping", "self", "scale", "nominal", "data", "arraylike", "callable", "arraylike", "arraylike", "identify", "evenly", "spaced", "values", "using", "interval", "or", "explicit", "mapping", "levels", "categorical_order", "data", "scale", "order", "if", "isinstance", "scale", "values", "dict", "self", "_check_dict_entries", "levels", "scale", "values", "values", "scale", "values", "x", "for", "x", "in", "levels", "elif", "isinstance", "scale", "values", "list", "values", "self", "_check_list_length", "levels", "scale", "values", "else", "if", "scale", "values", "is", "none", "vmin", "vmax", "self", "default_range", "elif", "isinstance", "scale", "values", "tuple", "vmin", "vmax", "scale", "values", "else", "scale_class", "scale", "__class__", "__name__", "err", "join", "f", "values", "for", "self", "variable", "variables", "with", "scale_class", "scale", "f", "must", "be", "a", "dict", "list", "or", "tuple", "not", "type", "scale", "values", "raise", "typeerror", "err", "vmin", "vmax", "self", "_forward", "vmin", "vmax", "values", "self", "_inverse", "np", "linspace", "vmax", "vmin", "len", "levels", "def", "mapping", "x", "ixs", "np", "asarray", "x", "np", "intp", "out", "np", "full", "len", "x", "np", "nan", "use", "np", "isfinite", "x", "out", "use", "np", "take", "values", "ixs", "use", "return", "out", "return", "mapping"], "doc_len": 154}
{"doc_id": "seaborn/_core/properties.py::PointSize._forward", "file_path": "seaborn/_core/properties.py", "class_name": "PointSize", "func_name": "_forward", "text": "文件路径: seaborn/_core/properties.py, 类名: PointSize\n    def _forward(self, values):\n        \"\"\"Square native values to implement linear scaling of point area.\"\"\"\n        return np.square(values)\n", "tokens": ["seaborn", "_core", "properties", "py", "pointsize", "def", "_forward", "self", "values", "square", "native", "values", "to", "implement", "linear", "scaling", "of", "point", "area", "return", "np", "square", "values"], "doc_len": 23}
{"doc_id": "seaborn/_core/properties.py::PointSize._inverse", "file_path": "seaborn/_core/properties.py", "class_name": "PointSize", "func_name": "_inverse", "text": "文件路径: seaborn/_core/properties.py, 类名: PointSize\n    def _inverse(self, values):\n        \"\"\"Invert areal values back to point diameter.\"\"\"\n        return np.sqrt(values)\n", "tokens": ["seaborn", "_core", "properties", "py", "pointsize", "def", "_inverse", "self", "values", "invert", "areal", "values", "back", "to", "point", "diameter", "return", "np", "sqrt", "values"], "doc_len": 20}
{"doc_id": "seaborn/_core/properties.py::LineWidth.default_range", "file_path": "seaborn/_core/properties.py", "class_name": "LineWidth", "func_name": "default_range", "text": "文件路径: seaborn/_core/properties.py, 类名: LineWidth\n    def default_range(self) -> tuple[float, float]:\n        \"\"\"Min and max values used by default for semantic mapping.\"\"\"\n        base = mpl.rcParams[\"lines.linewidth\"]\n        return base * .5, base * 2\n", "tokens": ["seaborn", "_core", "properties", "py", "linewidth", "def", "default_range", "self", "tuple", "float", "float", "min", "and", "max", "values", "used", "by", "default", "for", "semantic", "mapping", "base", "mpl", "rcparams", "lines", "linewidth", "return", "base", "5", "base", "2"], "doc_len": 31}
{"doc_id": "seaborn/_core/properties.py::EdgeWidth.default_range", "file_path": "seaborn/_core/properties.py", "class_name": "EdgeWidth", "func_name": "default_range", "text": "文件路径: seaborn/_core/properties.py, 类名: EdgeWidth\n    def default_range(self) -> tuple[float, float]:\n        \"\"\"Min and max values used by default for semantic mapping.\"\"\"\n        base = mpl.rcParams[\"patch.linewidth\"]\n        return base * .5, base * 2\n", "tokens": ["seaborn", "_core", "properties", "py", "edgewidth", "def", "default_range", "self", "tuple", "float", "float", "min", "and", "max", "values", "used", "by", "default", "for", "semantic", "mapping", "base", "mpl", "rcparams", "patch", "linewidth", "return", "base", "5", "base", "2"], "doc_len": 31}
{"doc_id": "seaborn/_core/properties.py::FontSize.default_range", "file_path": "seaborn/_core/properties.py", "class_name": "FontSize", "func_name": "default_range", "text": "文件路径: seaborn/_core/properties.py, 类名: FontSize\n    def default_range(self) -> tuple[float, float]:\n        \"\"\"Min and max values used by default for semantic mapping.\"\"\"\n        base = mpl.rcParams[\"font.size\"]\n        return base * .5, base * 2\n", "tokens": ["seaborn", "_core", "properties", "py", "fontsize", "def", "default_range", "self", "tuple", "float", "float", "min", "and", "max", "values", "used", "by", "default", "for", "semantic", "mapping", "base", "mpl", "rcparams", "font", "size", "return", "base", "5", "base", "2"], "doc_len": 31}
{"doc_id": "seaborn/_core/properties.py::ObjectProperty._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "ObjectProperty", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: ObjectProperty\n    def _default_values(self, n: int) -> list:\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "properties", "py", "objectproperty", "def", "_default_values", "self", "n", "int", "list", "raise", "notimplementederror"], "doc_len": 13}
{"doc_id": "seaborn/_core/properties.py::ObjectProperty.default_scale", "file_path": "seaborn/_core/properties.py", "class_name": "ObjectProperty", "func_name": "default_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: ObjectProperty\n    def default_scale(self, data: Series) -> Nominal:\n        return Nominal()\n", "tokens": ["seaborn", "_core", "properties", "py", "objectproperty", "def", "default_scale", "self", "data", "series", "nominal", "return", "nominal"], "doc_len": 13}
{"doc_id": "seaborn/_core/properties.py::ObjectProperty.infer_scale", "file_path": "seaborn/_core/properties.py", "class_name": "ObjectProperty", "func_name": "infer_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: ObjectProperty\n    def infer_scale(self, arg: Any, data: Series) -> Nominal:\n        return Nominal(arg)\n", "tokens": ["seaborn", "_core", "properties", "py", "objectproperty", "def", "infer_scale", "self", "arg", "any", "data", "series", "nominal", "return", "nominal", "arg"], "doc_len": 16}
{"doc_id": "seaborn/_core/properties.py::ObjectProperty.get_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "ObjectProperty", "func_name": "get_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: ObjectProperty\n    def get_mapping(\n        self, scale: Scale, data: Series,\n    ) -> Callable[[ArrayLike], list]:\n        \"\"\"Define mapping as lookup into list of object values.\"\"\"\n        order = getattr(scale, \"order\", None)\n        levels = categorical_order(data, order)\n        n = len(levels)\n\n        if isinstance(scale.values, dict):\n            self._check_dict_entries(levels, scale.values)\n            values = [scale.values[x] for x in levels]\n        elif isinstance(scale.values, list):\n            values = self._check_list_length(levels, scale.values)\n        elif scale.values is None:\n            values = self._default_values(n)\n        else:\n            msg = \" \".join([\n                f\"Scale values for a {self.variable} variable must be provided\",\n                f\"in a dict or list; not {type(scale.values)}.\"\n            ])\n            raise TypeError(msg)\n\n        values = [self.standardize(x) for x in values]\n\n        def mapping(x):\n            ixs = np.asarray(x, np.intp)\n            return [\n                values[ix] if np.isfinite(x_i) else self.null_value\n                for x_i, ix in zip(x, ixs)\n            ]\n\n        return mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "objectproperty", "def", "get_mapping", "self", "scale", "scale", "data", "series", "callable", "arraylike", "list", "define", "mapping", "as", "lookup", "into", "list", "of", "object", "values", "order", "getattr", "scale", "order", "none", "levels", "categorical_order", "data", "order", "n", "len", "levels", "if", "isinstance", "scale", "values", "dict", "self", "_check_dict_entries", "levels", "scale", "values", "values", "scale", "values", "x", "for", "x", "in", "levels", "elif", "isinstance", "scale", "values", "list", "values", "self", "_check_list_length", "levels", "scale", "values", "elif", "scale", "values", "is", "none", "values", "self", "_default_values", "n", "else", "msg", "join", "f", "scale", "values", "for", "a", "self", "variable", "variable", "must", "be", "provided", "f", "in", "a", "dict", "or", "list", "not", "type", "scale", "values", "raise", "typeerror", "msg", "values", "self", "standardize", "x", "for", "x", "in", "values", "def", "mapping", "x", "ixs", "np", "asarray", "x", "np", "intp", "return", "values", "ix", "if", "np", "isfinite", "x_i", "else", "self", "null_value", "for", "x_i", "ix", "in", "zip", "x", "ixs", "return", "mapping"], "doc_len": 137}
{"doc_id": "seaborn/_core/properties.py::Marker.standardize", "file_path": "seaborn/_core/properties.py", "class_name": "Marker", "func_name": "standardize", "text": "文件路径: seaborn/_core/properties.py, 类名: Marker\n    def standardize(self, val: MarkerPattern) -> MarkerStyle:\n        return MarkerStyle(val)\n", "tokens": ["seaborn", "_core", "properties", "py", "marker", "def", "standardize", "self", "val", "markerpattern", "markerstyle", "return", "markerstyle", "val"], "doc_len": 14}
{"doc_id": "seaborn/_core/properties.py::Marker._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "Marker", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: Marker\n    def _default_values(self, n: int) -> list[MarkerStyle]:\n        \"\"\"Build an arbitrarily long list of unique marker styles.\n\n        Parameters\n        ----------\n        n : int\n            Number of unique marker specs to generate.\n\n        Returns\n        -------\n        markers : list of string or tuples\n            Values for defining :class:`matplotlib.markers.MarkerStyle` objects.\n            All markers will be filled.\n\n        \"\"\"\n        # Start with marker specs that are well distinguishable\n        markers = [\n            \"o\", \"X\", (4, 0, 45), \"P\", (4, 0, 0), (4, 1, 0), \"^\", (4, 1, 45), \"v\",\n        ]\n\n        # Now generate more from regular polygons of increasing order\n        s = 5\n        while len(markers) < n:\n            a = 360 / (s + 1) / 2\n            markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])\n            s += 1\n\n        markers = [MarkerStyle(m) for m in markers[:n]]\n\n        return markers\n", "tokens": ["seaborn", "_core", "properties", "py", "marker", "def", "_default_values", "self", "n", "int", "list", "markerstyle", "build", "an", "arbitrarily", "long", "list", "of", "unique", "marker", "styles", "parameters", "n", "int", "number", "of", "unique", "marker", "specs", "to", "generate", "returns", "markers", "list", "of", "string", "or", "tuples", "values", "for", "defining", "class", "matplotlib", "markers", "markerstyle", "objects", "all", "markers", "will", "be", "filled", "start", "with", "marker", "specs", "that", "are", "well", "distinguishable", "markers", "o", "x", "4", "0", "45", "p", "4", "0", "0", "4", "1", "0", "4", "1", "45", "v", "now", "generate", "more", "from", "regular", "polygons", "of", "increasing", "order", "s", "5", "while", "len", "markers", "n", "a", "360", "s", "1", "2", "markers", "extend", "s", "1", "1", "a", "s", "1", "0", "a", "s", "1", "0", "s", "0", "0", "s", "1", "markers", "markerstyle", "m", "for", "m", "in", "markers", "n", "return", "markers"], "doc_len": 124}
{"doc_id": "seaborn/_core/properties.py::LineStyle.standardize", "file_path": "seaborn/_core/properties.py", "class_name": "LineStyle", "func_name": "standardize", "text": "文件路径: seaborn/_core/properties.py, 类名: LineStyle\n    def standardize(self, val: str | DashPattern) -> DashPatternWithOffset:\n        return self._get_dash_pattern(val)\n", "tokens": ["seaborn", "_core", "properties", "py", "linestyle", "def", "standardize", "self", "val", "str", "dashpattern", "dashpatternwithoffset", "return", "self", "_get_dash_pattern", "val"], "doc_len": 16}
{"doc_id": "seaborn/_core/properties.py::LineStyle._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "LineStyle", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: LineStyle\n    def _default_values(self, n: int) -> list[DashPatternWithOffset]:\n        \"\"\"Build an arbitrarily long list of unique dash styles for lines.\n\n        Parameters\n        ----------\n        n : int\n            Number of unique dash specs to generate.\n\n        Returns\n        -------\n        dashes : list of strings or tuples\n            Valid arguments for the ``dashes`` parameter on\n            :class:`matplotlib.lines.Line2D`. The first spec is a solid\n            line (``\"\"``), the remainder are sequences of long and short\n            dashes.\n\n        \"\"\"\n        # Start with dash specs that are well distinguishable\n        dashes: list[str | DashPattern] = [\n            \"-\", (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1),\n        ]\n\n        # Now programmatically build as many as we need\n        p = 3\n        while len(dashes) < n:\n\n            # Take combinations of long and short dashes\n            a = itertools.combinations_with_replacement([3, 1.25], p)\n            b = itertools.combinations_with_replacement([4, 1], p)\n\n            # Interleave the combinations, reversing one of the streams\n            segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1]))\n\n            # Now insert the gaps\n            for segments in segment_list:\n                gap = min(segments)\n                spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))\n                dashes.append(spec)\n\n            p += 1\n\n        return [self._get_dash_pattern(x) for x in dashes]\n", "tokens": ["seaborn", "_core", "properties", "py", "linestyle", "def", "_default_values", "self", "n", "int", "list", "dashpatternwithoffset", "build", "an", "arbitrarily", "long", "list", "of", "unique", "dash", "styles", "for", "lines", "parameters", "n", "int", "number", "of", "unique", "dash", "specs", "to", "generate", "returns", "dashes", "list", "of", "strings", "or", "tuples", "valid", "arguments", "for", "the", "dashes", "parameter", "on", "class", "matplotlib", "lines", "line2d", "the", "first", "spec", "is", "a", "solid", "line", "the", "remainder", "are", "sequences", "of", "long", "and", "short", "dashes", "start", "with", "dash", "specs", "that", "are", "well", "distinguishable", "dashes", "list", "str", "dashpattern", "4", "1", "5", "1", "1", "3", "1", "25", "1", "5", "1", "25", "5", "1", "1", "1", "now", "programmatically", "build", "as", "many", "as", "we", "need", "p", "3", "while", "len", "dashes", "n", "take", "combinations", "of", "long", "and", "short", "dashes", "a", "itertools", "combinations_with_replacement", "3", "1", "25", "p", "b", "itertools", "combinations_with_replacement", "4", "1", "p", "interleave", "the", "combinations", "reversing", "one", "of", "the", "streams", "segment_list", "itertools", "chain", "zip", "list", "a", "1", "1", "1", "list", "b", "1", "1", "now", "insert", "the", "gaps", "for", "segments", "in", "segment_list", "gap", "min", "segments", "spec", "tuple", "itertools", "chain", "seg", "gap", "for", "seg", "in", "segments", "dashes", "append", "spec", "p", "1", "return", "self", "_get_dash_pattern", "x", "for", "x", "in", "dashes"], "doc_len": 184}
{"doc_id": "seaborn/_core/properties.py::LineStyle._get_dash_pattern", "file_path": "seaborn/_core/properties.py", "class_name": "LineStyle", "func_name": "_get_dash_pattern", "text": "文件路径: seaborn/_core/properties.py, 类名: LineStyle\n    def _get_dash_pattern(style: str | DashPattern) -> DashPatternWithOffset:\n        \"\"\"Convert linestyle arguments to dash pattern with offset.\"\"\"\n        # Copied and modified from Matplotlib 3.4\n        # go from short hand -> full strings\n        ls_mapper = {\"-\": \"solid\", \"--\": \"dashed\", \"-.\": \"dashdot\", \":\": \"dotted\"}\n        if isinstance(style, str):\n            style = ls_mapper.get(style, style)\n            # un-dashed styles\n            if style in [\"solid\", \"none\", \"None\"]:\n                offset = 0\n                dashes = None\n            # dashed styles\n            elif style in [\"dashed\", \"dashdot\", \"dotted\"]:\n                offset = 0\n                dashes = tuple(mpl.rcParams[f\"lines.{style}_pattern\"])\n            else:\n                options = [*ls_mapper.values(), *ls_mapper.keys()]\n                msg = f\"Linestyle string must be one of {options}, not {repr(style)}.\"\n                raise ValueError(msg)\n\n        elif isinstance(style, tuple):\n            if len(style) > 1 and isinstance(style[1], tuple):\n                offset, dashes = style\n            elif len(style) > 1 and style[1] is None:\n                offset, dashes = style\n            else:\n                offset = 0\n                dashes = style\n        else:\n            val_type = type(style).__name__\n            msg = f\"Linestyle must be str or tuple, not {val_type}.\"\n            raise TypeError(msg)\n\n        # Normalize offset to be positive and shorter than the dash cycle\n        if dashes is not None:\n            try:\n                dsum = sum(dashes)\n            except TypeError as err:\n                msg = f\"Invalid dash pattern: {dashes}\"\n                raise TypeError(msg) from err\n            if dsum:\n                offset %= dsum\n\n        return offset, dashes\n", "tokens": ["seaborn", "_core", "properties", "py", "linestyle", "def", "_get_dash_pattern", "style", "str", "dashpattern", "dashpatternwithoffset", "convert", "linestyle", "arguments", "to", "dash", "pattern", "with", "offset", "copied", "and", "modified", "from", "matplotlib", "3", "4", "go", "from", "short", "hand", "full", "strings", "ls_mapper", "solid", "dashed", "dashdot", "dotted", "if", "isinstance", "style", "str", "style", "ls_mapper", "get", "style", "style", "un", "dashed", "styles", "if", "style", "in", "solid", "none", "none", "offset", "0", "dashes", "none", "dashed", "styles", "elif", "style", "in", "dashed", "dashdot", "dotted", "offset", "0", "dashes", "tuple", "mpl", "rcparams", "f", "lines", "style", "_pattern", "else", "options", "ls_mapper", "values", "ls_mapper", "keys", "msg", "f", "linestyle", "string", "must", "be", "one", "of", "options", "not", "repr", "style", "raise", "valueerror", "msg", "elif", "isinstance", "style", "tuple", "if", "len", "style", "1", "and", "isinstance", "style", "1", "tuple", "offset", "dashes", "style", "elif", "len", "style", "1", "and", "style", "1", "is", "none", "offset", "dashes", "style", "else", "offset", "0", "dashes", "style", "else", "val_type", "type", "style", "__name__", "msg", "f", "linestyle", "must", "be", "str", "or", "tuple", "not", "val_type", "raise", "typeerror", "msg", "normalize", "offset", "to", "be", "positive", "and", "shorter", "than", "the", "dash", "cycle", "if", "dashes", "is", "not", "none", "try", "dsum", "sum", "dashes", "except", "typeerror", "as", "err", "msg", "f", "invalid", "dash", "pattern", "dashes", "raise", "typeerror", "msg", "from", "err", "if", "dsum", "offset", "dsum", "return", "offset", "dashes"], "doc_len": 191}
{"doc_id": "seaborn/_core/properties.py::HorizontalAlignment._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "HorizontalAlignment", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: HorizontalAlignment\n    def _default_values(self, n: int) -> list:\n        vals = itertools.cycle([\"left\", \"right\"])\n        return [next(vals) for _ in range(n)]\n", "tokens": ["seaborn", "_core", "properties", "py", "horizontalalignment", "def", "_default_values", "self", "n", "int", "list", "vals", "itertools", "cycle", "left", "right", "return", "next", "vals", "for", "_", "in", "range", "n"], "doc_len": 24}
{"doc_id": "seaborn/_core/properties.py::VerticalAlignment._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "VerticalAlignment", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: VerticalAlignment\n    def _default_values(self, n: int) -> list:\n        vals = itertools.cycle([\"top\", \"bottom\"])\n        return [next(vals) for _ in range(n)]\n", "tokens": ["seaborn", "_core", "properties", "py", "verticalalignment", "def", "_default_values", "self", "n", "int", "list", "vals", "itertools", "cycle", "top", "bottom", "return", "next", "vals", "for", "_", "in", "range", "n"], "doc_len": 24}
{"doc_id": "seaborn/_core/properties.py::Color.standardize", "file_path": "seaborn/_core/properties.py", "class_name": "Color", "func_name": "standardize", "text": "文件路径: seaborn/_core/properties.py, 类名: Color\n    def standardize(self, val: ColorSpec) -> RGBTuple | RGBATuple:\n        # Return color with alpha channel only if the input spec has it\n        # This is so that RGBA colors can override the Alpha property\n        if to_rgba(val) != to_rgba(val, 1):\n            return to_rgba(val)\n        else:\n            return to_rgb(val)\n", "tokens": ["seaborn", "_core", "properties", "py", "color", "def", "standardize", "self", "val", "colorspec", "rgbtuple", "rgbatuple", "return", "color", "with", "alpha", "channel", "only", "if", "the", "input", "spec", "has", "it", "this", "is", "so", "that", "rgba", "colors", "can", "override", "the", "alpha", "property", "if", "to_rgba", "val", "to_rgba", "val", "1", "return", "to_rgba", "val", "else", "return", "to_rgb", "val"], "doc_len": 48}
{"doc_id": "seaborn/_core/properties.py::Color._standardize_color_sequence", "file_path": "seaborn/_core/properties.py", "class_name": "Color", "func_name": "_standardize_color_sequence", "text": "文件路径: seaborn/_core/properties.py, 类名: Color\n    def _standardize_color_sequence(self, colors: ArrayLike) -> ArrayLike:\n        \"\"\"Convert color sequence to RGB(A) array, preserving but not adding alpha.\"\"\"\n        def has_alpha(x):\n            return to_rgba(x) != to_rgba(x, 1)\n\n        if isinstance(colors, np.ndarray):\n            needs_alpha = colors.shape[1] == 4\n        else:\n            needs_alpha = any(has_alpha(x) for x in colors)\n\n        if needs_alpha:\n            return to_rgba_array(colors)\n        else:\n            return to_rgba_array(colors)[:, :3]\n", "tokens": ["seaborn", "_core", "properties", "py", "color", "def", "_standardize_color_sequence", "self", "colors", "arraylike", "arraylike", "convert", "color", "sequence", "to", "rgb", "a", "array", "preserving", "but", "not", "adding", "alpha", "def", "has_alpha", "x", "return", "to_rgba", "x", "to_rgba", "x", "1", "if", "isinstance", "colors", "np", "ndarray", "needs_alpha", "colors", "shape", "1", "4", "else", "needs_alpha", "any", "has_alpha", "x", "for", "x", "in", "colors", "if", "needs_alpha", "return", "to_rgba_array", "colors", "else", "return", "to_rgba_array", "colors", "3"], "doc_len": 61}
{"doc_id": "seaborn/_core/properties.py::Color.infer_scale", "file_path": "seaborn/_core/properties.py", "class_name": "Color", "func_name": "infer_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: Color\n    def infer_scale(self, arg: Any, data: Series) -> Scale:\n        # TODO when inferring Continuous without data, verify type\n\n        # TODO need to rethink the variable type system\n        # (e.g. boolean, ordered categories as Ordinal, etc)..\n        var_type = variable_type(data, boolean_type=\"categorical\")\n\n        if isinstance(arg, (dict, list)):\n            return Nominal(arg)\n\n        if isinstance(arg, tuple):\n            if var_type == \"categorical\":\n                # TODO It seems reasonable to allow a gradient mapping for nominal\n                # scale but it also feels \"technically\" wrong. Should this infer\n                # Ordinal with categorical data and, if so, verify orderedness?\n                return Nominal(arg)\n            return Continuous(arg)\n\n        if callable(arg):\n            return Continuous(arg)\n\n        # TODO Do we accept str like \"log\", \"pow\", etc. for semantics?\n\n        # TODO what about\n        # - Temporal? (i.e. datetime)\n        # - Boolean?\n\n        if not isinstance(arg, str):\n            msg = \" \".join([\n                f\"A single scale argument for {self.variable} variables must be\",\n                f\"a string, dict, tuple, list, or callable, not {type(arg)}.\"\n            ])\n            raise TypeError(msg)\n\n        if arg in QUAL_PALETTES:\n            return Nominal(arg)\n        elif var_type == \"numeric\":\n            return Continuous(arg)\n        # TODO implement scales for date variables and any others.\n        else:\n            return Nominal(arg)\n", "tokens": ["seaborn", "_core", "properties", "py", "color", "def", "infer_scale", "self", "arg", "any", "data", "series", "scale", "todo", "when", "inferring", "continuous", "without", "data", "verify", "type", "todo", "need", "to", "rethink", "the", "variable", "type", "system", "e", "g", "boolean", "ordered", "categories", "as", "ordinal", "etc", "var_type", "variable_type", "data", "boolean_type", "categorical", "if", "isinstance", "arg", "dict", "list", "return", "nominal", "arg", "if", "isinstance", "arg", "tuple", "if", "var_type", "categorical", "todo", "it", "seems", "reasonable", "to", "allow", "a", "gradient", "mapping", "for", "nominal", "scale", "but", "it", "also", "feels", "technically", "wrong", "should", "this", "infer", "ordinal", "with", "categorical", "data", "and", "if", "so", "verify", "orderedness", "return", "nominal", "arg", "return", "continuous", "arg", "if", "callable", "arg", "return", "continuous", "arg", "todo", "do", "we", "accept", "str", "like", "log", "pow", "etc", "for", "semantics", "todo", "what", "about", "temporal", "i", "e", "datetime", "boolean", "if", "not", "isinstance", "arg", "str", "msg", "join", "f", "a", "single", "scale", "argument", "for", "self", "variable", "variables", "must", "be", "f", "a", "string", "dict", "tuple", "list", "or", "callable", "not", "type", "arg", "raise", "typeerror", "msg", "if", "arg", "in", "qual_palettes", "return", "nominal", "arg", "elif", "var_type", "numeric", "return", "continuous", "arg", "todo", "implement", "scales", "for", "date", "variables", "and", "any", "others", "else", "return", "nominal", "arg"], "doc_len": 176}
{"doc_id": "seaborn/_core/properties.py::Color._get_categorical_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "Color", "func_name": "_get_categorical_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: Color\n    def _get_categorical_mapping(self, scale, data):\n        \"\"\"Define mapping as lookup in list of discrete color values.\"\"\"\n        levels = categorical_order(data, scale.order)\n        n = len(levels)\n        values = scale.values\n\n        if isinstance(values, dict):\n            self._check_dict_entries(levels, values)\n            # TODO where to ensure that dict values have consistent representation?\n            colors = [values[x] for x in levels]\n        elif isinstance(values, list):\n            colors = self._check_list_length(levels, scale.values)\n        elif isinstance(values, tuple):\n            colors = blend_palette(values, n)\n        elif isinstance(values, str):\n            colors = color_palette(values, n)\n        elif values is None:\n            if n <= len(get_color_cycle()):\n                # Use current (global) default palette\n                colors = color_palette(n_colors=n)\n            else:\n                colors = color_palette(\"husl\", n)\n        else:\n            scale_class = scale.__class__.__name__\n            msg = \" \".join([\n                f\"Scale values for {self.variable} with a {scale_class} mapping\",\n                f\"must be string, list, tuple, or dict; not {type(scale.values)}.\"\n            ])\n            raise TypeError(msg)\n\n        # If color specified here has alpha channel, it will override alpha property\n        colors = self._standardize_color_sequence(colors)\n\n        def mapping(x):\n            ixs = np.asarray(x, np.intp)\n            use = np.isfinite(x)\n            out = np.full((len(ixs), colors.shape[1]), np.nan)\n            out[use] = np.take(colors, ixs[use], axis=0)\n            return out\n\n        return mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "color", "def", "_get_categorical_mapping", "self", "scale", "data", "define", "mapping", "as", "lookup", "in", "list", "of", "discrete", "color", "values", "levels", "categorical_order", "data", "scale", "order", "n", "len", "levels", "values", "scale", "values", "if", "isinstance", "values", "dict", "self", "_check_dict_entries", "levels", "values", "todo", "where", "to", "ensure", "that", "dict", "values", "have", "consistent", "representation", "colors", "values", "x", "for", "x", "in", "levels", "elif", "isinstance", "values", "list", "colors", "self", "_check_list_length", "levels", "scale", "values", "elif", "isinstance", "values", "tuple", "colors", "blend_palette", "values", "n", "elif", "isinstance", "values", "str", "colors", "color_palette", "values", "n", "elif", "values", "is", "none", "if", "n", "len", "get_color_cycle", "use", "current", "global", "default", "palette", "colors", "color_palette", "n_colors", "n", "else", "colors", "color_palette", "husl", "n", "else", "scale_class", "scale", "__class__", "__name__", "msg", "join", "f", "scale", "values", "for", "self", "variable", "with", "a", "scale_class", "mapping", "f", "must", "be", "string", "list", "tuple", "or", "dict", "not", "type", "scale", "values", "raise", "typeerror", "msg", "if", "color", "specified", "here", "has", "alpha", "channel", "it", "will", "override", "alpha", "property", "colors", "self", "_standardize_color_sequence", "colors", "def", "mapping", "x", "ixs", "np", "asarray", "x", "np", "intp", "use", "np", "isfinite", "x", "out", "np", "full", "len", "ixs", "colors", "shape", "1", "np", "nan", "out", "use", "np", "take", "colors", "ixs", "use", "axis", "0", "return", "out", "return", "mapping"], "doc_len": 188}
{"doc_id": "seaborn/_core/properties.py::Color.get_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "Color", "func_name": "get_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: Color\n    def get_mapping(\n        self, scale: Scale, data: Series\n    ) -> Callable[[ArrayLike], ArrayLike]:\n        \"\"\"Return a function that maps from data domain to color values.\"\"\"\n        # TODO what is best way to do this conditional?\n        # Should it be class-based or should classes have behavioral attributes?\n        if isinstance(scale, Nominal):\n            return self._get_categorical_mapping(scale, data)\n\n        if scale.values is None:\n            # TODO Rethink best default continuous color gradient\n            mapping = color_palette(\"ch:\", as_cmap=True)\n        elif isinstance(scale.values, tuple):\n            # TODO blend_palette will strip alpha, but we should support\n            # interpolation on all four channels\n            mapping = blend_palette(scale.values, as_cmap=True)\n        elif isinstance(scale.values, str):\n            # TODO for matplotlib colormaps this will clip extremes, which is\n            # different from what using the named colormap directly would do\n            # This may or may not be desireable.\n            mapping = color_palette(scale.values, as_cmap=True)\n        elif callable(scale.values):\n            mapping = scale.values\n        else:\n            scale_class = scale.__class__.__name__\n            msg = \" \".join([\n                f\"Scale values for {self.variable} with a {scale_class} mapping\",\n                f\"must be string, tuple, or callable; not {type(scale.values)}.\"\n            ])\n            raise TypeError(msg)\n\n        def _mapping(x):\n            # Remove alpha channel so it does not override alpha property downstream\n            # TODO this will need to be more flexible to support RGBA tuples (see above)\n            invalid = ~np.isfinite(x)\n            out = mapping(x)[:, :3]\n            out[invalid] = np.nan\n            return out\n\n        return _mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "color", "def", "get_mapping", "self", "scale", "scale", "data", "series", "callable", "arraylike", "arraylike", "return", "a", "function", "that", "maps", "from", "data", "domain", "to", "color", "values", "todo", "what", "is", "best", "way", "to", "do", "this", "conditional", "should", "it", "be", "class", "based", "or", "should", "classes", "have", "behavioral", "attributes", "if", "isinstance", "scale", "nominal", "return", "self", "_get_categorical_mapping", "scale", "data", "if", "scale", "values", "is", "none", "todo", "rethink", "best", "default", "continuous", "color", "gradient", "mapping", "color_palette", "ch", "as_cmap", "true", "elif", "isinstance", "scale", "values", "tuple", "todo", "blend_palette", "will", "strip", "alpha", "but", "we", "should", "support", "interpolation", "on", "all", "four", "channels", "mapping", "blend_palette", "scale", "values", "as_cmap", "true", "elif", "isinstance", "scale", "values", "str", "todo", "for", "matplotlib", "colormaps", "this", "will", "clip", "extremes", "which", "is", "different", "from", "what", "using", "the", "named", "colormap", "directly", "would", "do", "this", "may", "or", "may", "not", "be", "desireable", "mapping", "color_palette", "scale", "values", "as_cmap", "true", "elif", "callable", "scale", "values", "mapping", "scale", "values", "else", "scale_class", "scale", "__class__", "__name__", "msg", "join", "f", "scale", "values", "for", "self", "variable", "with", "a", "scale_class", "mapping", "f", "must", "be", "string", "tuple", "or", "callable", "not", "type", "scale", "values", "raise", "typeerror", "msg", "def", "_mapping", "x", "remove", "alpha", "channel", "so", "it", "does", "not", "override", "alpha", "property", "downstream", "todo", "this", "will", "need", "to", "be", "more", "flexible", "to", "support", "rgba", "tuples", "see", "above", "invalid", "np", "isfinite", "x", "out", "mapping", "x", "3", "out", "invalid", "np", "nan", "return", "out", "return", "_mapping"], "doc_len": 217}
{"doc_id": "seaborn/_core/properties.py::Fill.standardize", "file_path": "seaborn/_core/properties.py", "class_name": "Fill", "func_name": "standardize", "text": "文件路径: seaborn/_core/properties.py, 类名: Fill\n    def standardize(self, val: Any) -> bool:\n        return bool(val)\n", "tokens": ["seaborn", "_core", "properties", "py", "fill", "def", "standardize", "self", "val", "any", "bool", "return", "bool", "val"], "doc_len": 14}
{"doc_id": "seaborn/_core/properties.py::Fill._default_values", "file_path": "seaborn/_core/properties.py", "class_name": "Fill", "func_name": "_default_values", "text": "文件路径: seaborn/_core/properties.py, 类名: Fill\n    def _default_values(self, n: int) -> list:\n        \"\"\"Return a list of n values, alternating True and False.\"\"\"\n        if n > 2:\n            msg = \" \".join([\n                f\"The variable assigned to {self.variable} has more than two levels,\",\n                f\"so {self.variable} values will cycle and may be uninterpretable\",\n            ])\n            # TODO fire in a \"nice\" way (see above)\n            warnings.warn(msg, UserWarning)\n        return [x for x, _ in zip(itertools.cycle([True, False]), range(n))]\n", "tokens": ["seaborn", "_core", "properties", "py", "fill", "def", "_default_values", "self", "n", "int", "list", "return", "a", "list", "of", "n", "values", "alternating", "true", "and", "false", "if", "n", "2", "msg", "join", "f", "the", "variable", "assigned", "to", "self", "variable", "has", "more", "than", "two", "levels", "f", "so", "self", "variable", "values", "will", "cycle", "and", "may", "be", "uninterpretable", "todo", "fire", "in", "a", "nice", "way", "see", "above", "warnings", "warn", "msg", "userwarning", "return", "x", "for", "x", "_", "in", "zip", "itertools", "cycle", "true", "false", "range", "n"], "doc_len": 74}
{"doc_id": "seaborn/_core/properties.py::Fill.default_scale", "file_path": "seaborn/_core/properties.py", "class_name": "Fill", "func_name": "default_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: Fill\n    def default_scale(self, data: Series) -> Nominal:\n        \"\"\"Given data, initialize appropriate scale class.\"\"\"\n        return Nominal()\n", "tokens": ["seaborn", "_core", "properties", "py", "fill", "def", "default_scale", "self", "data", "series", "nominal", "given", "data", "initialize", "appropriate", "scale", "class", "return", "nominal"], "doc_len": 19}
{"doc_id": "seaborn/_core/properties.py::Fill.infer_scale", "file_path": "seaborn/_core/properties.py", "class_name": "Fill", "func_name": "infer_scale", "text": "文件路径: seaborn/_core/properties.py, 类名: Fill\n    def infer_scale(self, arg: Any, data: Series) -> Scale:\n        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"\n        # TODO infer Boolean where possible?\n        return Nominal(arg)\n", "tokens": ["seaborn", "_core", "properties", "py", "fill", "def", "infer_scale", "self", "arg", "any", "data", "series", "scale", "given", "data", "and", "a", "scaling", "argument", "initialize", "appropriate", "scale", "class", "todo", "infer", "boolean", "where", "possible", "return", "nominal", "arg"], "doc_len": 31}
{"doc_id": "seaborn/_core/properties.py::Fill.get_mapping", "file_path": "seaborn/_core/properties.py", "class_name": "Fill", "func_name": "get_mapping", "text": "文件路径: seaborn/_core/properties.py, 类名: Fill\n    def get_mapping(\n        self, scale: Scale, data: Series\n    ) -> Callable[[ArrayLike], ArrayLike]:\n        \"\"\"Return a function that maps each data value to True or False.\"\"\"\n        # TODO categorical_order is going to return [False, True] for booleans,\n        # and [0, 1] for binary, but the default values order is [True, False].\n        # We should special case this to handle it properly, or change\n        # categorical_order to not \"sort\" booleans. Note that we need to sync with\n        # what's going to happen upstream in the scale, so we can't just do it here.\n        order = getattr(scale, \"order\", None)\n        levels = categorical_order(data, order)\n\n        if isinstance(scale.values, list):\n            values = [bool(x) for x in scale.values]\n        elif isinstance(scale.values, dict):\n            values = [bool(scale.values[x]) for x in levels]\n        elif scale.values is None:\n            values = self._default_values(len(levels))\n        else:\n            msg = \" \".join([\n                f\"Scale values for {self.variable} must be passed in\",\n                f\"a list or dict; not {type(scale.values)}.\"\n            ])\n            raise TypeError(msg)\n\n        def mapping(x):\n            ixs = np.asarray(x, np.intp)\n            return [\n                values[ix] if np.isfinite(x_i) else False\n                for x_i, ix in zip(x, ixs)\n            ]\n\n        return mapping\n", "tokens": ["seaborn", "_core", "properties", "py", "fill", "def", "get_mapping", "self", "scale", "scale", "data", "series", "callable", "arraylike", "arraylike", "return", "a", "function", "that", "maps", "each", "data", "value", "to", "true", "or", "false", "todo", "categorical_order", "is", "going", "to", "return", "false", "true", "for", "booleans", "and", "0", "1", "for", "binary", "but", "the", "default", "values", "order", "is", "true", "false", "we", "should", "special", "case", "this", "to", "handle", "it", "properly", "or", "change", "categorical_order", "to", "not", "sort", "booleans", "note", "that", "we", "need", "to", "sync", "with", "what", "s", "going", "to", "happen", "upstream", "in", "the", "scale", "so", "we", "can", "t", "just", "do", "it", "here", "order", "getattr", "scale", "order", "none", "levels", "categorical_order", "data", "order", "if", "isinstance", "scale", "values", "list", "values", "bool", "x", "for", "x", "in", "scale", "values", "elif", "isinstance", "scale", "values", "dict", "values", "bool", "scale", "values", "x", "for", "x", "in", "levels", "elif", "scale", "values", "is", "none", "values", "self", "_default_values", "len", "levels", "else", "msg", "join", "f", "scale", "values", "for", "self", "variable", "must", "be", "passed", "in", "f", "a", "list", "or", "dict", "not", "type", "scale", "values", "raise", "typeerror", "msg", "def", "mapping", "x", "ixs", "np", "asarray", "x", "np", "intp", "return", "values", "ix", "if", "np", "isfinite", "x_i", "else", "false", "for", "x_i", "ix", "in", "zip", "x", "ixs", "return", "mapping"], "doc_len": 188}
{"doc_id": "seaborn/_core/rules.py::VarType.__init__", "file_path": "seaborn/_core/rules.py", "class_name": "VarType", "func_name": "__init__", "text": "文件路径: seaborn/_core/rules.py, 类名: VarType\n    def __init__(self, data):\n        assert data in self.allowed, data\n        super().__init__(data)\n", "tokens": ["seaborn", "_core", "rules", "py", "vartype", "def", "__init__", "self", "data", "assert", "data", "in", "self", "allowed", "data", "super", "__init__", "data"], "doc_len": 18}
{"doc_id": "seaborn/_core/rules.py::VarType.__eq__", "file_path": "seaborn/_core/rules.py", "class_name": "VarType", "func_name": "__eq__", "text": "文件路径: seaborn/_core/rules.py, 类名: VarType\n    def __eq__(self, other):\n        assert other in self.allowed, other\n        return self.data == other\n", "tokens": ["seaborn", "_core", "rules", "py", "vartype", "def", "__eq__", "self", "other", "assert", "other", "in", "self", "allowed", "other", "return", "self", "data", "other"], "doc_len": 19}
{"doc_id": "seaborn/_core/rules.py::variable_type", "file_path": "seaborn/_core/rules.py", "class_name": null, "func_name": "variable_type", "text": "文件路径: seaborn/_core/rules.py\ndef variable_type(\n    vector: Series,\n    boolean_type: Literal[\"numeric\", \"categorical\"] = \"numeric\",\n) -> VarType:\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in two ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric' or 'categorical'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n\n    # If a categorical dtype is set, infer categorical\n    if pd.api.types.is_categorical_dtype(vector):\n        return VarType(\"categorical\")\n\n    # Special-case all-na data, which is always \"numeric\"\n    if pd.isna(vector).all():\n        return VarType(\"numeric\")\n\n    # Special-case binary/boolean data, allow caller to determine\n    # This triggers a numpy warning when vector has strings/objects\n    # https://github.com/numpy/numpy/issues/6784\n    # Because we reduce with .all(), we are agnostic about whether the\n    # comparison returns a scalar or vector, so we will ignore the warning.\n    # It triggers a separate DeprecationWarning when the vector has datetimes:\n    # https://github.com/numpy/numpy/issues/13548\n    # This is considered a bug by numpy and will likely go away.\n    with warnings.catch_warnings():\n        warnings.simplefilter(\n            action='ignore',\n            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?\n        )\n        if np.isin(vector, [0, 1, np.nan]).all():\n            return VarType(boolean_type)\n\n    # Defer to positive pandas tests\n    if pd.api.types.is_numeric_dtype(vector):\n        return VarType(\"numeric\")\n\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VarType(\"datetime\")\n\n    # --- If we get to here, we need to check the entries\n\n    # Check for a collection where everything is a number\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n\n    if all_numeric(vector):\n        return VarType(\"numeric\")\n\n    # Check for a collection where everything is a datetime\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n\n    if all_datetime(vector):\n        return VarType(\"datetime\")\n\n    # Otherwise, our final fallback is to consider things categorical\n\n    return VarType(\"categorical\")\n", "tokens": ["seaborn", "_core", "rules", "py", "def", "variable_type", "vector", "series", "boolean_type", "literal", "numeric", "categorical", "numeric", "vartype", "determine", "whether", "a", "vector", "contains", "numeric", "categorical", "or", "datetime", "data", "this", "function", "differs", "from", "the", "pandas", "typing", "api", "in", "two", "ways", "python", "sequences", "or", "object", "typed", "pydata", "objects", "are", "considered", "numeric", "if", "all", "of", "their", "entries", "are", "numeric", "string", "or", "mixed", "type", "data", "are", "considered", "categorical", "even", "if", "not", "explicitly", "represented", "as", "a", "class", "pandas", "api", "types", "categoricaldtype", "parameters", "vector", "func", "pandas", "series", "func", "numpy", "ndarray", "or", "python", "sequence", "input", "data", "to", "test", "boolean_type", "numeric", "or", "categorical", "type", "to", "use", "for", "vectors", "containing", "only", "0s", "and", "1s", "and", "nas", "returns", "var_type", "numeric", "categorical", "or", "datetime", "name", "identifying", "the", "type", "of", "data", "in", "the", "vector", "if", "a", "categorical", "dtype", "is", "set", "infer", "categorical", "if", "pd", "api", "types", "is_categorical_dtype", "vector", "return", "vartype", "categorical", "special", "case", "all", "na", "data", "which", "is", "always", "numeric", "if", "pd", "isna", "vector", "all", "return", "vartype", "numeric", "special", "case", "binary", "boolean", "data", "allow", "caller", "to", "determine", "this", "triggers", "a", "numpy", "warning", "when", "vector", "has", "strings", "objects", "https", "github", "com", "numpy", "numpy", "issues", "6784", "because", "we", "reduce", "with", "all", "we", "are", "agnostic", "about", "whether", "the", "comparison", "returns", "a", "scalar", "or", "vector", "so", "we", "will", "ignore", "the", "warning", "it", "triggers", "a", "separate", "deprecationwarning", "when", "the", "vector", "has", "datetimes", "https", "github", "com", "numpy", "numpy", "issues", "13548", "this", "is", "considered", "a", "bug", "by", "numpy", "and", "will", "likely", "go", "away", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "action", "ignore", "category", "futurewarning", "deprecationwarning", "type", "ignore", "mypy", "bug", "if", "np", "isin", "vector", "0", "1", "np", "nan", "all", "return", "vartype", "boolean_type", "defer", "to", "positive", "pandas", "tests", "if", "pd", "api", "types", "is_numeric_dtype", "vector", "return", "vartype", "numeric", "if", "pd", "api", "types", "is_datetime64_dtype", "vector", "return", "vartype", "datetime", "if", "we", "get", "to", "here", "we", "need", "to", "check", "the", "entries", "check", "for", "a", "collection", "where", "everything", "is", "a", "number", "def", "all_numeric", "x", "for", "x_i", "in", "x", "if", "not", "isinstance", "x_i", "number", "return", "false", "return", "true", "if", "all_numeric", "vector", "return", "vartype", "numeric", "check", "for", "a", "collection", "where", "everything", "is", "a", "datetime", "def", "all_datetime", "x", "for", "x_i", "in", "x", "if", "not", "isinstance", "x_i", "datetime", "np", "datetime64", "return", "false", "return", "true", "if", "all_datetime", "vector", "return", "vartype", "datetime", "otherwise", "our", "final", "fallback", "is", "to", "consider", "things", "categorical", "return", "vartype", "categorical"], "doc_len": 366}
{"doc_id": "seaborn/_core/rules.py::categorical_order", "file_path": "seaborn/_core/rules.py", "class_name": null, "func_name": "categorical_order", "text": "文件路径: seaborn/_core/rules.py\ndef categorical_order(vector: Series, order: list | None = None) -> list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        return order\n\n    if vector.dtype.name == \"category\":\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(pd.Series(order)) == \"numeric\":\n            order.sort()\n\n    return order\n", "tokens": ["seaborn", "_core", "rules", "py", "def", "categorical_order", "vector", "series", "order", "list", "none", "none", "list", "return", "a", "list", "of", "unique", "data", "values", "using", "seaborn", "s", "ordering", "rules", "parameters", "vector", "series", "vector", "of", "categorical", "values", "order", "list", "desired", "order", "of", "category", "levels", "to", "override", "the", "order", "determined", "from", "the", "data", "object", "returns", "order", "list", "ordered", "list", "of", "category", "levels", "not", "including", "null", "values", "if", "order", "is", "not", "none", "return", "order", "if", "vector", "dtype", "name", "category", "order", "list", "vector", "cat", "categories", "else", "order", "list", "filter", "pd", "notnull", "vector", "unique", "if", "variable_type", "pd", "series", "order", "numeric", "order", "sort", "return", "order"], "doc_len": 95}
{"doc_id": "seaborn/_core/scales.py::Scale.__post_init__", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "__post_init__", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def __post_init__(self):\n\n        self._tick_params = None\n        self._label_params = None\n        self._legend = None\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "__post_init__", "self", "self", "_tick_params", "none", "self", "_label_params", "none", "self", "_legend", "none"], "doc_len": 17}
{"doc_id": "seaborn/_core/scales.py::Scale.tick", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "tick", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def tick(self):\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "tick", "self", "raise", "notimplementederror"], "doc_len": 10}
{"doc_id": "seaborn/_core/scales.py::Scale.label", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "label", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def label(self):\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "label", "self", "raise", "notimplementederror"], "doc_len": 10}
{"doc_id": "seaborn/_core/scales.py::Scale._get_locators", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_get_locators", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _get_locators(self):\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_get_locators", "self", "raise", "notimplementederror"], "doc_len": 10}
{"doc_id": "seaborn/_core/scales.py::Scale._get_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_get_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _get_formatter(self, locator: Locator | None = None):\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_get_formatter", "self", "locator", "locator", "none", "none", "raise", "notimplementederror"], "doc_len": 14}
{"doc_id": "seaborn/_core/scales.py::Scale._get_scale", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_get_scale", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _get_scale(self, name: str, forward: Callable, inverse: Callable):\n\n        major_locator, minor_locator = self._get_locators(**self._tick_params)\n        major_formatter = self._get_formatter(major_locator, **self._label_params)\n\n        class InternalScale(mpl.scale.FuncScale):\n            def set_default_locators_and_formatters(self, axis):\n                axis.set_major_locator(major_locator)\n                if minor_locator is not None:\n                    axis.set_minor_locator(minor_locator)\n                axis.set_major_formatter(major_formatter)\n\n        return InternalScale(name, (forward, inverse))\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_get_scale", "self", "name", "str", "forward", "callable", "inverse", "callable", "major_locator", "minor_locator", "self", "_get_locators", "self", "_tick_params", "major_formatter", "self", "_get_formatter", "major_locator", "self", "_label_params", "class", "internalscale", "mpl", "scale", "funcscale", "def", "set_default_locators_and_formatters", "self", "axis", "axis", "set_major_locator", "major_locator", "if", "minor_locator", "is", "not", "none", "axis", "set_minor_locator", "minor_locator", "axis", "set_major_formatter", "major_formatter", "return", "internalscale", "name", "forward", "inverse"], "doc_len": 54}
{"doc_id": "seaborn/_core/scales.py::Scale._spacing", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_spacing", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _spacing(self, x: Series) -> float:\n        space = self._spacer(x)\n        if np.isnan(space):\n            # This happens when there is no variance in the orient coordinate data\n            # Not exactly clear what the right default is, but 1 seems reasonable?\n            return 1\n        return space\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_spacing", "self", "x", "series", "float", "space", "self", "_spacer", "x", "if", "np", "isnan", "space", "this", "happens", "when", "there", "is", "no", "variance", "in", "the", "orient", "coordinate", "data", "not", "exactly", "clear", "what", "the", "right", "default", "is", "but", "1", "seems", "reasonable", "return", "1", "return", "space"], "doc_len": 47}
{"doc_id": "seaborn/_core/scales.py::Scale._setup", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_setup", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _setup(\n        self, data: Series, prop: Property, axis: Axis | None = None,\n    ) -> Scale:\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_setup", "self", "data", "series", "prop", "property", "axis", "axis", "none", "none", "scale", "raise", "notimplementederror"], "doc_len": 19}
{"doc_id": "seaborn/_core/scales.py::Scale.__call__", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "__call__", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def __call__(self, data: Series) -> ArrayLike:\n\n        trans_data: Series | NDArray | list\n\n        # TODO sometimes we need to handle scalars (e.g. for Line)\n        # but what is the best way to do that?\n        scalar_data = np.isscalar(data)\n        if scalar_data:\n            trans_data = np.array([data])\n        else:\n            trans_data = data\n\n        for func in self._pipeline:\n            if func is not None:\n                trans_data = func(trans_data)\n\n        if scalar_data:\n            return trans_data[0]\n        else:\n            return trans_data\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "__call__", "self", "data", "series", "arraylike", "trans_data", "series", "ndarray", "list", "todo", "sometimes", "we", "need", "to", "handle", "scalars", "e", "g", "for", "line", "but", "what", "is", "the", "best", "way", "to", "do", "that", "scalar_data", "np", "isscalar", "data", "if", "scalar_data", "trans_data", "np", "array", "data", "else", "trans_data", "data", "for", "func", "in", "self", "_pipeline", "if", "func", "is", "not", "none", "trans_data", "func", "trans_data", "if", "scalar_data", "return", "trans_data", "0", "else", "return", "trans_data"], "doc_len": 69}
{"doc_id": "seaborn/_core/scales.py::Scale._identity", "file_path": "seaborn/_core/scales.py", "class_name": "Scale", "func_name": "_identity", "text": "文件路径: seaborn/_core/scales.py, 类名: Scale\n    def _identity():\n\n        class Identity(Scale):\n            _pipeline = []\n            _spacer = None\n            _legend = None\n            _matplotlib_scale = None\n\n        return Identity()\n", "tokens": ["seaborn", "_core", "scales", "py", "scale", "def", "_identity", "class", "identity", "scale", "_pipeline", "_spacer", "none", "_legend", "none", "_matplotlib_scale", "none", "return", "identity"], "doc_len": 19}
{"doc_id": "seaborn/_core/scales.py::Nominal._setup", "file_path": "seaborn/_core/scales.py", "class_name": "Nominal", "func_name": "_setup", "text": "文件路径: seaborn/_core/scales.py, 类名: Nominal\n    def _setup(\n        self, data: Series, prop: Property, axis: Axis | None = None,\n    ) -> Scale:\n\n        new = copy(self)\n        if new._tick_params is None:\n            new = new.tick()\n        if new._label_params is None:\n            new = new.label()\n\n        # TODO flexibility over format() which isn't great for numbers / dates\n        stringify = np.vectorize(format, otypes=[\"object\"])\n\n        units_seed = categorical_order(data, new.order)\n\n        # TODO move to Nominal._get_scale?\n        # TODO this needs some more complicated rethinking about how to pass\n        # a unit dictionary down to these methods, along with how much we want\n        # to invest in their API. What is it useful for tick() to do here?\n        # (Ordinal may be different if we draw that contrast).\n        # Any customization we do to allow, e.g., label wrapping will probably\n        # require defining our own Formatter subclass.\n        # We could also potentially implement auto-wrapping in an Axis subclass\n        # (see Axis.draw ... it already is computing the bboxes).\n        # major_locator, minor_locator = new._get_locators(**new._tick_params)\n        # major_formatter = new._get_formatter(major_locator, **new._label_params)\n\n        class CatScale(mpl.scale.LinearScale):\n            name = None  # To work around mpl<3.4 compat issues\n\n            def set_default_locators_and_formatters(self, axis):\n                ...\n                # axis.set_major_locator(major_locator)\n                # if minor_locator is not None:\n                #     axis.set_minor_locator(minor_locator)\n                # axis.set_major_formatter(major_formatter)\n\n        mpl_scale = CatScale(data.name)\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n\n            # TODO Currently just used in non-Coordinate contexts, but should\n            # we use this to (A) set the padding we want for categorial plots\n            # and (B) allow the values parameter for a Coordinate to set xlim/ylim\n            axis.set_view_interval(0, len(units_seed) - 1)\n\n        new._matplotlib_scale = mpl_scale\n\n        # TODO array cast necessary to handle float/int mixture, which we need\n        # to solve in a more systematic way probably\n        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)\n        axis.update_units(stringify(np.array(units_seed)))\n\n        # TODO define this more centrally\n        def convert_units(x):\n            # TODO only do this with explicit order?\n            # (But also category dtype?)\n            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)\n            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)\n            # keep = x.isin(units_seed)\n            keep = np.array([x_ in units_seed for x_ in x], bool)\n            out = np.full(len(x), np.nan)\n            out[keep] = axis.convert_units(stringify(x[keep]))\n            return out\n\n        new._pipeline = [\n            convert_units,\n            prop.get_mapping(new, data),\n            # TODO how to handle color representation consistency?\n        ]\n\n        def spacer(x):\n            return 1\n\n        new._spacer = spacer\n\n        if prop.legend:\n            new._legend = units_seed, list(stringify(units_seed))\n\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "nominal", "def", "_setup", "self", "data", "series", "prop", "property", "axis", "axis", "none", "none", "scale", "new", "copy", "self", "if", "new", "_tick_params", "is", "none", "new", "new", "tick", "if", "new", "_label_params", "is", "none", "new", "new", "label", "todo", "flexibility", "over", "format", "which", "isn", "t", "great", "for", "numbers", "dates", "stringify", "np", "vectorize", "format", "otypes", "object", "units_seed", "categorical_order", "data", "new", "order", "todo", "move", "to", "nominal", "_get_scale", "todo", "this", "needs", "some", "more", "complicated", "rethinking", "about", "how", "to", "pass", "a", "unit", "dictionary", "down", "to", "these", "methods", "along", "with", "how", "much", "we", "want", "to", "invest", "in", "their", "api", "what", "is", "it", "useful", "for", "tick", "to", "do", "here", "ordinal", "may", "be", "different", "if", "we", "draw", "that", "contrast", "any", "customization", "we", "do", "to", "allow", "e", "g", "label", "wrapping", "will", "probably", "require", "defining", "our", "own", "formatter", "subclass", "we", "could", "also", "potentially", "implement", "auto", "wrapping", "in", "an", "axis", "subclass", "see", "axis", "draw", "it", "already", "is", "computing", "the", "bboxes", "major_locator", "minor_locator", "new", "_get_locators", "new", "_tick_params", "major_formatter", "new", "_get_formatter", "major_locator", "new", "_label_params", "class", "catscale", "mpl", "scale", "linearscale", "name", "none", "to", "work", "around", "mpl", "3", "4", "compat", "issues", "def", "set_default_locators_and_formatters", "self", "axis", "axis", "set_major_locator", "major_locator", "if", "minor_locator", "is", "not", "none", "axis", "set_minor_locator", "minor_locator", "axis", "set_major_formatter", "major_formatter", "mpl_scale", "catscale", "data", "name", "if", "axis", "is", "none", "axis", "pseudoaxis", "mpl_scale", "todo", "currently", "just", "used", "in", "non", "coordinate", "contexts", "but", "should", "we", "use", "this", "to", "a", "set", "the", "padding", "we", "want", "for", "categorial", "plots", "and", "b", "allow", "the", "values", "parameter", "for", "a", "coordinate", "to", "set", "xlim", "ylim", "axis", "set_view_interval", "0", "len", "units_seed", "1", "new", "_matplotlib_scale", "mpl_scale", "todo", "array", "cast", "necessary", "to", "handle", "float", "int", "mixture", "which", "we", "need", "to", "solve", "in", "a", "more", "systematic", "way", "probably", "i", "e", "if", "we", "have", "1", "2", "5", "do", "we", "want", "1", "0", "2", "5", "unclear", "axis", "update_units", "stringify", "np", "array", "units_seed", "todo", "define", "this", "more", "centrally", "def", "convert_units", "x", "todo", "only", "do", "this", "with", "explicit", "order", "but", "also", "category", "dtype", "todo", "isin", "fails", "when", "units_seed", "mixes", "numbers", "and", "strings", "numpy", "error", "but", "np", "isin", "also", "does", "not", "seem", "any", "faster", "maybe", "not", "broadcasting", "in", "c", "keep", "x", "isin", "units_seed", "keep", "np", "array", "x_", "in", "units_seed", "for", "x_", "in", "x", "bool", "out", "np", "full", "len", "x", "np", "nan", "out", "keep", "axis", "convert_units", "stringify", "x", "keep", "return", "out", "new", "_pipeline", "convert_units", "prop", "get_mapping", "new", "data", "todo", "how", "to", "handle", "color", "representation", "consistency", "def", "spacer", "x", "return", "1", "new", "_spacer", "spacer", "if", "prop", "legend", "new", "_legend", "units_seed", "list", "stringify", "units_seed", "return", "new"], "doc_len": 399}
{"doc_id": "seaborn/_core/scales.py::Nominal.tick", "file_path": "seaborn/_core/scales.py", "class_name": "Nominal", "func_name": "tick", "text": "文件路径: seaborn/_core/scales.py, 类名: Nominal\n    def tick(self, locator: Locator | None = None):\n        \"\"\"\n        Configure the selection of ticks for the scale's axis or legend.\n\n        .. note::\n            This API is under construction and will be enhanced over time.\n            At the moment, it is probably not very useful.\n\n        Parameters\n        ----------\n        locator : :class:`matplotlib.ticker.Locator` subclass\n            Pre-configured matplotlib locator; other parameters will not be used.\n\n        Returns\n        -------\n        Copy of self with new tick configuration.\n\n        \"\"\"\n        new = copy(self)\n        new._tick_params = {\n            \"locator\": locator,\n        }\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "nominal", "def", "tick", "self", "locator", "locator", "none", "none", "configure", "the", "selection", "of", "ticks", "for", "the", "scale", "s", "axis", "or", "legend", "note", "this", "api", "is", "under", "construction", "and", "will", "be", "enhanced", "over", "time", "at", "the", "moment", "it", "is", "probably", "not", "very", "useful", "parameters", "locator", "class", "matplotlib", "ticker", "locator", "subclass", "pre", "configured", "matplotlib", "locator", "other", "parameters", "will", "not", "be", "used", "returns", "copy", "of", "self", "with", "new", "tick", "configuration", "new", "copy", "self", "new", "_tick_params", "locator", "locator", "return", "new"], "doc_len": 79}
{"doc_id": "seaborn/_core/scales.py::Nominal.label", "file_path": "seaborn/_core/scales.py", "class_name": "Nominal", "func_name": "label", "text": "文件路径: seaborn/_core/scales.py, 类名: Nominal\n    def label(self, formatter: Formatter | None = None):\n        \"\"\"\n        Configure the selection of labels for the scale's axis or legend.\n\n        .. note::\n            This API is under construction and will be enhanced over time.\n            At the moment, it is probably not very useful.\n\n        Parameters\n        ----------\n        formatter : :class:`matplotlib.ticker.Formatter` subclass\n            Pre-configured matplotlib formatter; other parameters will not be used.\n\n        Returns\n        -------\n        scale\n            Copy of self with new tick configuration.\n\n        \"\"\"\n        new = copy(self)\n        new._label_params = {\n            \"formatter\": formatter,\n        }\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "nominal", "def", "label", "self", "formatter", "formatter", "none", "none", "configure", "the", "selection", "of", "labels", "for", "the", "scale", "s", "axis", "or", "legend", "note", "this", "api", "is", "under", "construction", "and", "will", "be", "enhanced", "over", "time", "at", "the", "moment", "it", "is", "probably", "not", "very", "useful", "parameters", "formatter", "class", "matplotlib", "ticker", "formatter", "subclass", "pre", "configured", "matplotlib", "formatter", "other", "parameters", "will", "not", "be", "used", "returns", "scale", "copy", "of", "self", "with", "new", "tick", "configuration", "new", "copy", "self", "new", "_label_params", "formatter", "formatter", "return", "new"], "doc_len": 80}
{"doc_id": "seaborn/_core/scales.py::Nominal._get_locators", "file_path": "seaborn/_core/scales.py", "class_name": "Nominal", "func_name": "_get_locators", "text": "文件路径: seaborn/_core/scales.py, 类名: Nominal\n    def _get_locators(self, locator):\n\n        if locator is not None:\n            return locator, None\n\n        locator = mpl.category.StrCategoryLocator({})\n\n        return locator, None\n", "tokens": ["seaborn", "_core", "scales", "py", "nominal", "def", "_get_locators", "self", "locator", "if", "locator", "is", "not", "none", "return", "locator", "none", "locator", "mpl", "category", "strcategorylocator", "return", "locator", "none"], "doc_len": 24}
{"doc_id": "seaborn/_core/scales.py::Nominal._get_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "Nominal", "func_name": "_get_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: Nominal\n    def _get_formatter(self, locator, formatter):\n\n        if formatter is not None:\n            return formatter\n\n        formatter = mpl.category.StrCategoryFormatter({})\n\n        return formatter\n", "tokens": ["seaborn", "_core", "scales", "py", "nominal", "def", "_get_formatter", "self", "locator", "formatter", "if", "formatter", "is", "not", "none", "return", "formatter", "formatter", "mpl", "category", "strcategoryformatter", "return", "formatter"], "doc_len": 23}
{"doc_id": "seaborn/_core/scales.py::ContinuousBase._setup", "file_path": "seaborn/_core/scales.py", "class_name": "ContinuousBase", "func_name": "_setup", "text": "文件路径: seaborn/_core/scales.py, 类名: ContinuousBase\n    def _setup(\n        self, data: Series, prop: Property, axis: Axis | None = None,\n    ) -> Scale:\n\n        new = copy(self)\n        if new._tick_params is None:\n            new = new.tick()\n        if new._label_params is None:\n            new = new.label()\n\n        forward, inverse = new._get_transform()\n\n        mpl_scale = new._get_scale(str(data.name), forward, inverse)\n\n        if axis is None:\n            axis = PseudoAxis(mpl_scale)\n            axis.update_units(data)\n\n        mpl_scale.set_default_locators_and_formatters(axis)\n        new._matplotlib_scale = mpl_scale\n\n        normalize: Optional[Callable[[ArrayLike], ArrayLike]]\n        if prop.normed:\n            if new.norm is None:\n                vmin, vmax = data.min(), data.max()\n            else:\n                vmin, vmax = new.norm\n            vmin, vmax = axis.convert_units((vmin, vmax))\n            a = forward(vmin)\n            b = forward(vmax) - forward(vmin)\n\n            def normalize(x):\n                return (x - a) / b\n\n        else:\n            normalize = vmin = vmax = None\n\n        new._pipeline = [\n            axis.convert_units,\n            forward,\n            normalize,\n            prop.get_mapping(new, data)\n        ]\n\n        def spacer(x):\n            x = x.dropna().unique()\n            if len(x) < 2:\n                return np.nan\n            return np.min(np.diff(np.sort(x)))\n        new._spacer = spacer\n\n        # TODO How to allow disabling of legend for all uses of property?\n        # Could add a Scale parameter, or perhaps Scale.suppress()?\n        # Are there other useful parameters that would be in Scale.legend()\n        # besides allowing Scale.legend(False)?\n        if prop.legend:\n            axis.set_view_interval(vmin, vmax)\n            locs = axis.major.locator()\n            locs = locs[(vmin <= locs) & (locs <= vmax)]\n            # Avoid having an offset / scientific notation in a legend\n            # as we don't represent that anywhere so it ends up incorrect.\n            # This could become an option (e.g. Continuous.label(offset=True))\n            # in which case we would need to figure out how to show it.\n            if hasattr(axis.major.formatter, \"set_useOffset\"):\n                axis.major.formatter.set_useOffset(False)\n            if hasattr(axis.major.formatter, \"set_scientific\"):\n                axis.major.formatter.set_scientific(False)\n            labels = axis.major.formatter.format_ticks(locs)\n            new._legend = list(locs), list(labels)\n\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "continuousbase", "def", "_setup", "self", "data", "series", "prop", "property", "axis", "axis", "none", "none", "scale", "new", "copy", "self", "if", "new", "_tick_params", "is", "none", "new", "new", "tick", "if", "new", "_label_params", "is", "none", "new", "new", "label", "forward", "inverse", "new", "_get_transform", "mpl_scale", "new", "_get_scale", "str", "data", "name", "forward", "inverse", "if", "axis", "is", "none", "axis", "pseudoaxis", "mpl_scale", "axis", "update_units", "data", "mpl_scale", "set_default_locators_and_formatters", "axis", "new", "_matplotlib_scale", "mpl_scale", "normalize", "optional", "callable", "arraylike", "arraylike", "if", "prop", "normed", "if", "new", "norm", "is", "none", "vmin", "vmax", "data", "min", "data", "max", "else", "vmin", "vmax", "new", "norm", "vmin", "vmax", "axis", "convert_units", "vmin", "vmax", "a", "forward", "vmin", "b", "forward", "vmax", "forward", "vmin", "def", "normalize", "x", "return", "x", "a", "b", "else", "normalize", "vmin", "vmax", "none", "new", "_pipeline", "axis", "convert_units", "forward", "normalize", "prop", "get_mapping", "new", "data", "def", "spacer", "x", "x", "x", "dropna", "unique", "if", "len", "x", "2", "return", "np", "nan", "return", "np", "min", "np", "diff", "np", "sort", "x", "new", "_spacer", "spacer", "todo", "how", "to", "allow", "disabling", "of", "legend", "for", "all", "uses", "of", "property", "could", "add", "a", "scale", "parameter", "or", "perhaps", "scale", "suppress", "are", "there", "other", "useful", "parameters", "that", "would", "be", "in", "scale", "legend", "besides", "allowing", "scale", "legend", "false", "if", "prop", "legend", "axis", "set_view_interval", "vmin", "vmax", "locs", "axis", "major", "locator", "locs", "locs", "vmin", "locs", "locs", "vmax", "avoid", "having", "an", "offset", "scientific", "notation", "in", "a", "legend", "as", "we", "don", "t", "represent", "that", "anywhere", "so", "it", "ends", "up", "incorrect", "this", "could", "become", "an", "option", "e", "g", "continuous", "label", "offset", "true", "in", "which", "case", "we", "would", "need", "to", "figure", "out", "how", "to", "show", "it", "if", "hasattr", "axis", "major", "formatter", "set_useoffset", "axis", "major", "formatter", "set_useoffset", "false", "if", "hasattr", "axis", "major", "formatter", "set_scientific", "axis", "major", "formatter", "set_scientific", "false", "labels", "axis", "major", "formatter", "format_ticks", "locs", "new", "_legend", "list", "locs", "list", "labels", "return", "new"], "doc_len": 284}
{"doc_id": "seaborn/_core/scales.py::ContinuousBase._get_transform", "file_path": "seaborn/_core/scales.py", "class_name": "ContinuousBase", "func_name": "_get_transform", "text": "文件路径: seaborn/_core/scales.py, 类名: ContinuousBase\n    def _get_transform(self):\n\n        arg = self.trans\n\n        def get_param(method, default):\n            if arg == method:\n                return default\n            return float(arg[len(method):])\n\n        if arg is None:\n            return _make_identity_transforms()\n        elif isinstance(arg, tuple):\n            return arg\n        elif isinstance(arg, str):\n            if arg == \"ln\":\n                return _make_log_transforms()\n            elif arg == \"logit\":\n                base = get_param(\"logit\", 10)\n                return _make_logit_transforms(base)\n            elif arg.startswith(\"log\"):\n                base = get_param(\"log\", 10)\n                return _make_log_transforms(base)\n            elif arg.startswith(\"symlog\"):\n                c = get_param(\"symlog\", 1)\n                return _make_symlog_transforms(c)\n            elif arg.startswith(\"pow\"):\n                exp = get_param(\"pow\", 2)\n                return _make_power_transforms(exp)\n            elif arg == \"sqrt\":\n                return _make_sqrt_transforms()\n            else:\n                raise ValueError(f\"Unknown value provided for trans: {arg!r}\")\n", "tokens": ["seaborn", "_core", "scales", "py", "continuousbase", "def", "_get_transform", "self", "arg", "self", "trans", "def", "get_param", "method", "default", "if", "arg", "method", "return", "default", "return", "float", "arg", "len", "method", "if", "arg", "is", "none", "return", "_make_identity_transforms", "elif", "isinstance", "arg", "tuple", "return", "arg", "elif", "isinstance", "arg", "str", "if", "arg", "ln", "return", "_make_log_transforms", "elif", "arg", "logit", "base", "get_param", "logit", "10", "return", "_make_logit_transforms", "base", "elif", "arg", "startswith", "log", "base", "get_param", "log", "10", "return", "_make_log_transforms", "base", "elif", "arg", "startswith", "symlog", "c", "get_param", "symlog", "1", "return", "_make_symlog_transforms", "c", "elif", "arg", "startswith", "pow", "exp", "get_param", "pow", "2", "return", "_make_power_transforms", "exp", "elif", "arg", "sqrt", "return", "_make_sqrt_transforms", "else", "raise", "valueerror", "f", "unknown", "value", "provided", "for", "trans", "arg", "r"], "doc_len": 105}
{"doc_id": "seaborn/_core/scales.py::Continuous.tick", "file_path": "seaborn/_core/scales.py", "class_name": "Continuous", "func_name": "tick", "text": "文件路径: seaborn/_core/scales.py, 类名: Continuous\n    def tick(\n        self,\n        locator: Locator | None = None, *,\n        at: Sequence[float] | None = None,\n        upto: int | None = None,\n        count: int | None = None,\n        every: float | None = None,\n        between: tuple[float, float] | None = None,\n        minor: int | None = None,\n    ) -> Continuous:\n        \"\"\"\n        Configure the selection of ticks for the scale's axis or legend.\n\n        Parameters\n        ----------\n        locator : :class:`matplotlib.ticker.Locator` subclass\n            Pre-configured matplotlib locator; other parameters will not be used.\n        at : sequence of floats\n            Place ticks at these specific locations (in data units).\n        upto : int\n            Choose \"nice\" locations for ticks, but do not exceed this number.\n        count : int\n            Choose exactly this number of ticks, bounded by `between` or axis limits.\n        every : float\n            Choose locations at this interval of separation (in data units).\n        between : pair of floats\n            Bound upper / lower ticks when using `every` or `count`.\n        minor : int\n            Number of unlabeled ticks to draw between labeled \"major\" ticks.\n\n        Returns\n        -------\n        scale\n            Copy of self with new tick configuration.\n\n        \"\"\"\n        # Input checks\n        if locator is not None and not isinstance(locator, Locator):\n            raise TypeError(\n                f\"Tick locator must be an instance of {Locator!r}, \"\n                f\"not {type(locator)!r}.\"\n            )\n        log_base, symlog_thresh = self._parse_for_log_params(self.trans)\n        if log_base or symlog_thresh:\n            if count is not None and between is None:\n                raise RuntimeError(\"`count` requires `between` with log transform.\")\n            if every is not None:\n                raise RuntimeError(\"`every` not supported with log transform.\")\n\n        new = copy(self)\n        new._tick_params = {\n            \"locator\": locator,\n            \"at\": at,\n            \"upto\": upto,\n            \"count\": count,\n            \"every\": every,\n            \"between\": between,\n            \"minor\": minor,\n        }\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "continuous", "def", "tick", "self", "locator", "locator", "none", "none", "at", "sequence", "float", "none", "none", "upto", "int", "none", "none", "count", "int", "none", "none", "every", "float", "none", "none", "between", "tuple", "float", "float", "none", "none", "minor", "int", "none", "none", "continuous", "configure", "the", "selection", "of", "ticks", "for", "the", "scale", "s", "axis", "or", "legend", "parameters", "locator", "class", "matplotlib", "ticker", "locator", "subclass", "pre", "configured", "matplotlib", "locator", "other", "parameters", "will", "not", "be", "used", "at", "sequence", "of", "floats", "place", "ticks", "at", "these", "specific", "locations", "in", "data", "units", "upto", "int", "choose", "nice", "locations", "for", "ticks", "but", "do", "not", "exceed", "this", "number", "count", "int", "choose", "exactly", "this", "number", "of", "ticks", "bounded", "by", "between", "or", "axis", "limits", "every", "float", "choose", "locations", "at", "this", "interval", "of", "separation", "in", "data", "units", "between", "pair", "of", "floats", "bound", "upper", "lower", "ticks", "when", "using", "every", "or", "count", "minor", "int", "number", "of", "unlabeled", "ticks", "to", "draw", "between", "labeled", "major", "ticks", "returns", "scale", "copy", "of", "self", "with", "new", "tick", "configuration", "input", "checks", "if", "locator", "is", "not", "none", "and", "not", "isinstance", "locator", "locator", "raise", "typeerror", "f", "tick", "locator", "must", "be", "an", "instance", "of", "locator", "r", "f", "not", "type", "locator", "r", "log_base", "symlog_thresh", "self", "_parse_for_log_params", "self", "trans", "if", "log_base", "or", "symlog_thresh", "if", "count", "is", "not", "none", "and", "between", "is", "none", "raise", "runtimeerror", "count", "requires", "between", "with", "log", "transform", "if", "every", "is", "not", "none", "raise", "runtimeerror", "every", "not", "supported", "with", "log", "transform", "new", "copy", "self", "new", "_tick_params", "locator", "locator", "at", "at", "upto", "upto", "count", "count", "every", "every", "between", "between", "minor", "minor", "return", "new"], "doc_len": 245}
{"doc_id": "seaborn/_core/scales.py::Continuous.label", "file_path": "seaborn/_core/scales.py", "class_name": "Continuous", "func_name": "label", "text": "文件路径: seaborn/_core/scales.py, 类名: Continuous\n    def label(\n        self,\n        formatter: Formatter | None = None, *,\n        like: str | Callable | None = None,\n        base: int | None | Default = default,\n        unit: str | None = None,\n    ) -> Continuous:\n        \"\"\"\n        Configure the appearance of tick labels for the scale's axis or legend.\n\n        Parameters\n        ----------\n        formatter : :class:`matplotlib.ticker.Formatter` subclass\n            Pre-configured formatter to use; other parameters will be ignored.\n        like : str or callable\n            Either a format pattern (e.g., `\".2f\"`), a format string with fields named\n            `x` and/or `pos` (e.g., `\"${x:.2f}\"`), or a callable that consumes a number\n            and returns a string.\n        base : number\n            Use log formatter (with scientific notation) having this value as the base.\n            Set to `None` to override the default formatter with a log transform.\n        unit : str or (str, str) tuple\n            Use  SI prefixes with these units (e.g., with `unit=\"g\"`, a tick value\n            of 5000 will appear as `5 kg`). When a tuple, the first element gives the\n            separator between the number and unit.\n\n        Returns\n        -------\n        scale\n            Copy of self with new label configuration.\n\n        \"\"\"\n        # Input checks\n        if formatter is not None and not isinstance(formatter, Formatter):\n            raise TypeError(\n                f\"Label formatter must be an instance of {Formatter!r}, \"\n                f\"not {type(formatter)!r}\"\n            )\n        if like is not None and not (isinstance(like, str) or callable(like)):\n            msg = f\"`like` must be a string or callable, not {type(like).__name__}.\"\n            raise TypeError(msg)\n\n        new = copy(self)\n        new._label_params = {\n            \"formatter\": formatter,\n            \"like\": like,\n            \"base\": base,\n            \"unit\": unit,\n        }\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "continuous", "def", "label", "self", "formatter", "formatter", "none", "none", "like", "str", "callable", "none", "none", "base", "int", "none", "default", "default", "unit", "str", "none", "none", "continuous", "configure", "the", "appearance", "of", "tick", "labels", "for", "the", "scale", "s", "axis", "or", "legend", "parameters", "formatter", "class", "matplotlib", "ticker", "formatter", "subclass", "pre", "configured", "formatter", "to", "use", "other", "parameters", "will", "be", "ignored", "like", "str", "or", "callable", "either", "a", "format", "pattern", "e", "g", "2f", "a", "format", "string", "with", "fields", "named", "x", "and", "or", "pos", "e", "g", "x", "2f", "or", "a", "callable", "that", "consumes", "a", "number", "and", "returns", "a", "string", "base", "number", "use", "log", "formatter", "with", "scientific", "notation", "having", "this", "value", "as", "the", "base", "set", "to", "none", "to", "override", "the", "default", "formatter", "with", "a", "log", "transform", "unit", "str", "or", "str", "str", "tuple", "use", "si", "prefixes", "with", "these", "units", "e", "g", "with", "unit", "g", "a", "tick", "value", "of", "5000", "will", "appear", "as", "5", "kg", "when", "a", "tuple", "the", "first", "element", "gives", "the", "separator", "between", "the", "number", "and", "unit", "returns", "scale", "copy", "of", "self", "with", "new", "label", "configuration", "input", "checks", "if", "formatter", "is", "not", "none", "and", "not", "isinstance", "formatter", "formatter", "raise", "typeerror", "f", "label", "formatter", "must", "be", "an", "instance", "of", "formatter", "r", "f", "not", "type", "formatter", "r", "if", "like", "is", "not", "none", "and", "not", "isinstance", "like", "str", "or", "callable", "like", "msg", "f", "like", "must", "be", "a", "string", "or", "callable", "not", "type", "like", "__name__", "raise", "typeerror", "msg", "new", "copy", "self", "new", "_label_params", "formatter", "formatter", "like", "like", "base", "base", "unit", "unit", "return", "new"], "doc_len": 242}
{"doc_id": "seaborn/_core/scales.py::Continuous._parse_for_log_params", "file_path": "seaborn/_core/scales.py", "class_name": "Continuous", "func_name": "_parse_for_log_params", "text": "文件路径: seaborn/_core/scales.py, 类名: Continuous\n    def _parse_for_log_params(\n        self, trans: str | TransFuncs | None\n    ) -> tuple[float | None, float | None]:\n\n        log_base = symlog_thresh = None\n        if isinstance(trans, str):\n            m = re.match(r\"^log(\\d*)\", trans)\n            if m is not None:\n                log_base = float(m[1] or 10)\n            m = re.match(r\"symlog(\\d*)\", trans)\n            if m is not None:\n                symlog_thresh = float(m[1] or 1)\n        return log_base, symlog_thresh\n", "tokens": ["seaborn", "_core", "scales", "py", "continuous", "def", "_parse_for_log_params", "self", "trans", "str", "transfuncs", "none", "tuple", "float", "none", "float", "none", "log_base", "symlog_thresh", "none", "if", "isinstance", "trans", "str", "m", "re", "match", "r", "log", "d", "trans", "if", "m", "is", "not", "none", "log_base", "float", "m", "1", "or", "10", "m", "re", "match", "r", "symlog", "d", "trans", "if", "m", "is", "not", "none", "symlog_thresh", "float", "m", "1", "or", "1", "return", "log_base", "symlog_thresh"], "doc_len": 63}
{"doc_id": "seaborn/_core/scales.py::Continuous._get_locators", "file_path": "seaborn/_core/scales.py", "class_name": "Continuous", "func_name": "_get_locators", "text": "文件路径: seaborn/_core/scales.py, 类名: Continuous\n    def _get_locators(self, locator, at, upto, count, every, between, minor):\n\n        log_base, symlog_thresh = self._parse_for_log_params(self.trans)\n\n        if locator is not None:\n            major_locator = locator\n\n        elif upto is not None:\n            if log_base:\n                major_locator = LogLocator(base=log_base, numticks=upto)\n            else:\n                major_locator = MaxNLocator(upto, steps=[1, 1.5, 2, 2.5, 3, 5, 10])\n\n        elif count is not None:\n            if between is None:\n                # This is rarely useful (unless you are setting limits)\n                major_locator = LinearLocator(count)\n            else:\n                if log_base or symlog_thresh:\n                    forward, inverse = self._get_transform()\n                    lo, hi = forward(between)\n                    ticks = inverse(np.linspace(lo, hi, num=count))\n                else:\n                    ticks = np.linspace(*between, num=count)\n                major_locator = FixedLocator(ticks)\n\n        elif every is not None:\n            if between is None:\n                major_locator = MultipleLocator(every)\n            else:\n                lo, hi = between\n                ticks = np.arange(lo, hi + every, every)\n                major_locator = FixedLocator(ticks)\n\n        elif at is not None:\n            major_locator = FixedLocator(at)\n\n        else:\n            if log_base:\n                major_locator = LogLocator(log_base)\n            elif symlog_thresh:\n                major_locator = SymmetricalLogLocator(linthresh=symlog_thresh, base=10)\n            else:\n                major_locator = AutoLocator()\n\n        if minor is None:\n            minor_locator = LogLocator(log_base, subs=None) if log_base else None\n        else:\n            if log_base:\n                subs = np.linspace(0, log_base, minor + 2)[1:-1]\n                minor_locator = LogLocator(log_base, subs=subs)\n            else:\n                minor_locator = AutoMinorLocator(minor + 1)\n\n        return major_locator, minor_locator\n", "tokens": ["seaborn", "_core", "scales", "py", "continuous", "def", "_get_locators", "self", "locator", "at", "upto", "count", "every", "between", "minor", "log_base", "symlog_thresh", "self", "_parse_for_log_params", "self", "trans", "if", "locator", "is", "not", "none", "major_locator", "locator", "elif", "upto", "is", "not", "none", "if", "log_base", "major_locator", "loglocator", "base", "log_base", "numticks", "upto", "else", "major_locator", "maxnlocator", "upto", "steps", "1", "1", "5", "2", "2", "5", "3", "5", "10", "elif", "count", "is", "not", "none", "if", "between", "is", "none", "this", "is", "rarely", "useful", "unless", "you", "are", "setting", "limits", "major_locator", "linearlocator", "count", "else", "if", "log_base", "or", "symlog_thresh", "forward", "inverse", "self", "_get_transform", "lo", "hi", "forward", "between", "ticks", "inverse", "np", "linspace", "lo", "hi", "num", "count", "else", "ticks", "np", "linspace", "between", "num", "count", "major_locator", "fixedlocator", "ticks", "elif", "every", "is", "not", "none", "if", "between", "is", "none", "major_locator", "multiplelocator", "every", "else", "lo", "hi", "between", "ticks", "np", "arange", "lo", "hi", "every", "every", "major_locator", "fixedlocator", "ticks", "elif", "at", "is", "not", "none", "major_locator", "fixedlocator", "at", "else", "if", "log_base", "major_locator", "loglocator", "log_base", "elif", "symlog_thresh", "major_locator", "symmetricalloglocator", "linthresh", "symlog_thresh", "base", "10", "else", "major_locator", "autolocator", "if", "minor", "is", "none", "minor_locator", "loglocator", "log_base", "subs", "none", "if", "log_base", "else", "none", "else", "if", "log_base", "subs", "np", "linspace", "0", "log_base", "minor", "2", "1", "1", "minor_locator", "loglocator", "log_base", "subs", "subs", "else", "minor_locator", "autominorlocator", "minor", "1", "return", "major_locator", "minor_locator"], "doc_len": 196}
{"doc_id": "seaborn/_core/scales.py::Continuous._get_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "Continuous", "func_name": "_get_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: Continuous\n    def _get_formatter(self, locator, formatter, like, base, unit):\n\n        log_base, symlog_thresh = self._parse_for_log_params(self.trans)\n        if base is default:\n            if symlog_thresh:\n                log_base = 10\n            base = log_base\n\n        if formatter is not None:\n            return formatter\n\n        if like is not None:\n            if isinstance(like, str):\n                if \"{x\" in like or \"{pos\" in like:\n                    fmt = like\n                else:\n                    fmt = f\"{{x:{like}}}\"\n                formatter = StrMethodFormatter(fmt)\n            else:\n                formatter = FuncFormatter(like)\n\n        elif base is not None:\n            # We could add other log options if necessary\n            formatter = LogFormatterSciNotation(base)\n\n        elif unit is not None:\n            if isinstance(unit, tuple):\n                sep, unit = unit\n            elif not unit:\n                sep = \"\"\n            else:\n                sep = \" \"\n            formatter = EngFormatter(unit, sep=sep)\n\n        else:\n            formatter = ScalarFormatter()\n\n        return formatter\n", "tokens": ["seaborn", "_core", "scales", "py", "continuous", "def", "_get_formatter", "self", "locator", "formatter", "like", "base", "unit", "log_base", "symlog_thresh", "self", "_parse_for_log_params", "self", "trans", "if", "base", "is", "default", "if", "symlog_thresh", "log_base", "10", "base", "log_base", "if", "formatter", "is", "not", "none", "return", "formatter", "if", "like", "is", "not", "none", "if", "isinstance", "like", "str", "if", "x", "in", "like", "or", "pos", "in", "like", "fmt", "like", "else", "fmt", "f", "x", "like", "formatter", "strmethodformatter", "fmt", "else", "formatter", "funcformatter", "like", "elif", "base", "is", "not", "none", "we", "could", "add", "other", "log", "options", "if", "necessary", "formatter", "logformatterscinotation", "base", "elif", "unit", "is", "not", "none", "if", "isinstance", "unit", "tuple", "sep", "unit", "unit", "elif", "not", "unit", "sep", "else", "sep", "formatter", "engformatter", "unit", "sep", "sep", "else", "formatter", "scalarformatter", "return", "formatter"], "doc_len": 111}
{"doc_id": "seaborn/_core/scales.py::Temporal.tick", "file_path": "seaborn/_core/scales.py", "class_name": "Temporal", "func_name": "tick", "text": "文件路径: seaborn/_core/scales.py, 类名: Temporal\n    def tick(\n        self, locator: Locator | None = None, *,\n        upto: int | None = None,\n    ) -> Temporal:\n        \"\"\"\n        Configure the selection of ticks for the scale's axis or legend.\n\n        .. note::\n            This API is under construction and will be enhanced over time.\n\n        Parameters\n        ----------\n        locator : :class:`matplotlib.ticker.Locator` subclass\n            Pre-configured matplotlib locator; other parameters will not be used.\n        upto : int\n            Choose \"nice\" locations for ticks, but do not exceed this number.\n\n        Returns\n        -------\n        scale\n            Copy of self with new tick configuration.\n\n        \"\"\"\n        if locator is not None and not isinstance(locator, Locator):\n            err = (\n                f\"Tick locator must be an instance of {Locator!r}, \"\n                f\"not {type(locator)!r}.\"\n            )\n            raise TypeError(err)\n\n        new = copy(self)\n        new._tick_params = {\"locator\": locator, \"upto\": upto}\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "temporal", "def", "tick", "self", "locator", "locator", "none", "none", "upto", "int", "none", "none", "temporal", "configure", "the", "selection", "of", "ticks", "for", "the", "scale", "s", "axis", "or", "legend", "note", "this", "api", "is", "under", "construction", "and", "will", "be", "enhanced", "over", "time", "parameters", "locator", "class", "matplotlib", "ticker", "locator", "subclass", "pre", "configured", "matplotlib", "locator", "other", "parameters", "will", "not", "be", "used", "upto", "int", "choose", "nice", "locations", "for", "ticks", "but", "do", "not", "exceed", "this", "number", "returns", "scale", "copy", "of", "self", "with", "new", "tick", "configuration", "if", "locator", "is", "not", "none", "and", "not", "isinstance", "locator", "locator", "err", "f", "tick", "locator", "must", "be", "an", "instance", "of", "locator", "r", "f", "not", "type", "locator", "r", "raise", "typeerror", "err", "new", "copy", "self", "new", "_tick_params", "locator", "locator", "upto", "upto", "return", "new"], "doc_len": 120}
{"doc_id": "seaborn/_core/scales.py::Temporal.label", "file_path": "seaborn/_core/scales.py", "class_name": "Temporal", "func_name": "label", "text": "文件路径: seaborn/_core/scales.py, 类名: Temporal\n    def label(\n        self,\n        formatter: Formatter | None = None, *,\n        concise: bool = False,\n    ) -> Temporal:\n        \"\"\"\n        Configure the appearance of tick labels for the scale's axis or legend.\n\n        .. note::\n            This API is under construction and will be enhanced over time.\n\n        Parameters\n        ----------\n        formatter : :class:`matplotlib.ticker.Formatter` subclass\n            Pre-configured formatter to use; other parameters will be ignored.\n        concise : bool\n            If True, use :class:`matplotlib.dates.ConciseDateFormatter` to make\n            the tick labels as compact as possible.\n\n        Returns\n        -------\n        scale\n            Copy of self with new label configuration.\n\n        \"\"\"\n        new = copy(self)\n        new._label_params = {\"formatter\": formatter, \"concise\": concise}\n        return new\n", "tokens": ["seaborn", "_core", "scales", "py", "temporal", "def", "label", "self", "formatter", "formatter", "none", "none", "concise", "bool", "false", "temporal", "configure", "the", "appearance", "of", "tick", "labels", "for", "the", "scale", "s", "axis", "or", "legend", "note", "this", "api", "is", "under", "construction", "and", "will", "be", "enhanced", "over", "time", "parameters", "formatter", "class", "matplotlib", "ticker", "formatter", "subclass", "pre", "configured", "formatter", "to", "use", "other", "parameters", "will", "be", "ignored", "concise", "bool", "if", "true", "use", "class", "matplotlib", "dates", "concisedateformatter", "to", "make", "the", "tick", "labels", "as", "compact", "as", "possible", "returns", "scale", "copy", "of", "self", "with", "new", "label", "configuration", "new", "copy", "self", "new", "_label_params", "formatter", "formatter", "concise", "concise", "return", "new"], "doc_len": 96}
{"doc_id": "seaborn/_core/scales.py::Temporal._get_locators", "file_path": "seaborn/_core/scales.py", "class_name": "Temporal", "func_name": "_get_locators", "text": "文件路径: seaborn/_core/scales.py, 类名: Temporal\n    def _get_locators(self, locator, upto):\n\n        if locator is not None:\n            major_locator = locator\n        elif upto is not None:\n            major_locator = AutoDateLocator(minticks=2, maxticks=upto)\n\n        else:\n            major_locator = AutoDateLocator(minticks=2, maxticks=6)\n        minor_locator = None\n\n        return major_locator, minor_locator\n", "tokens": ["seaborn", "_core", "scales", "py", "temporal", "def", "_get_locators", "self", "locator", "upto", "if", "locator", "is", "not", "none", "major_locator", "locator", "elif", "upto", "is", "not", "none", "major_locator", "autodatelocator", "minticks", "2", "maxticks", "upto", "else", "major_locator", "autodatelocator", "minticks", "2", "maxticks", "6", "minor_locator", "none", "return", "major_locator", "minor_locator"], "doc_len": 40}
{"doc_id": "seaborn/_core/scales.py::Temporal._get_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "Temporal", "func_name": "_get_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: Temporal\n    def _get_formatter(self, locator, formatter, concise):\n\n        if formatter is not None:\n            return formatter\n\n        if concise:\n            # TODO ideally we would have concise coordinate ticks,\n            # but full semantic ticks. Is that possible?\n            formatter = ConciseDateFormatter(locator)\n        else:\n            formatter = AutoDateFormatter(locator)\n\n        return formatter\n", "tokens": ["seaborn", "_core", "scales", "py", "temporal", "def", "_get_formatter", "self", "locator", "formatter", "concise", "if", "formatter", "is", "not", "none", "return", "formatter", "if", "concise", "todo", "ideally", "we", "would", "have", "concise", "coordinate", "ticks", "but", "full", "semantic", "ticks", "is", "that", "possible", "formatter", "concisedateformatter", "locator", "else", "formatter", "autodateformatter", "locator", "return", "formatter"], "doc_len": 44}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.__init__", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "__init__", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def __init__(self, scale):\n\n        self.converter = None\n        self.units = None\n        self.scale = scale\n        self.major = mpl.axis.Ticker()\n        self.minor = mpl.axis.Ticker()\n\n        # It appears that this needs to be initialized this way on matplotlib 3.1,\n        # but not later versions. It is unclear whether there are any issues with it.\n        self._data_interval = None, None\n\n        scale.set_default_locators_and_formatters(self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "__init__", "self", "scale", "self", "converter", "none", "self", "units", "none", "self", "scale", "scale", "self", "major", "mpl", "axis", "ticker", "self", "minor", "mpl", "axis", "ticker", "it", "appears", "that", "this", "needs", "to", "be", "initialized", "this", "way", "on", "matplotlib", "3", "1", "but", "not", "later", "versions", "it", "is", "unclear", "whether", "there", "are", "any", "issues", "with", "it", "self", "_data_interval", "none", "none", "scale", "set_default_locators_and_formatters", "self"], "doc_len": 63}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_view_interval", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_view_interval", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_view_interval(self, vmin, vmax):\n        self._view_interval = vmin, vmax\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_view_interval", "self", "vmin", "vmax", "self", "_view_interval", "vmin", "vmax"], "doc_len": 14}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.get_view_interval", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "get_view_interval", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def get_view_interval(self):\n        return self._view_interval\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "get_view_interval", "self", "return", "self", "_view_interval"], "doc_len": 11}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_data_interval", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_data_interval", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_data_interval(self, vmin, vmax):\n        self._data_interval = vmin, vmax\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_data_interval", "self", "vmin", "vmax", "self", "_data_interval", "vmin", "vmax"], "doc_len": 14}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.get_data_interval", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "get_data_interval", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def get_data_interval(self):\n        return self._data_interval\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "get_data_interval", "self", "return", "self", "_data_interval"], "doc_len": 11}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.get_tick_space", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "get_tick_space", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def get_tick_space(self):\n        # TODO how to do this in a configurable / auto way?\n        # Would be cool to have legend density adapt to figure size, etc.\n        return 5\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "get_tick_space", "self", "todo", "how", "to", "do", "this", "in", "a", "configurable", "auto", "way", "would", "be", "cool", "to", "have", "legend", "density", "adapt", "to", "figure", "size", "etc", "return", "5"], "doc_len": 32}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_major_locator", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_major_locator", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_major_locator(self, locator):\n        self.major.locator = locator\n        locator.set_axis(self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_major_locator", "self", "locator", "self", "major", "locator", "locator", "locator", "set_axis", "self"], "doc_len": 16}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_major_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_major_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_major_formatter(self, formatter):\n        self.major.formatter = formatter\n        formatter.set_axis(self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_major_formatter", "self", "formatter", "self", "major", "formatter", "formatter", "formatter", "set_axis", "self"], "doc_len": 16}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_minor_locator", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_minor_locator", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_minor_locator(self, locator):\n        self.minor.locator = locator\n        locator.set_axis(self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_minor_locator", "self", "locator", "self", "minor", "locator", "locator", "locator", "set_axis", "self"], "doc_len": 16}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_minor_formatter", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_minor_formatter", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_minor_formatter(self, formatter):\n        self.minor.formatter = formatter\n        formatter.set_axis(self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_minor_formatter", "self", "formatter", "self", "minor", "formatter", "formatter", "formatter", "set_axis", "self"], "doc_len": 16}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.set_units", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "set_units", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def set_units(self, units):\n        self.units = units\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "set_units", "self", "units", "self", "units", "units"], "doc_len": 12}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.update_units", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "update_units", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def update_units(self, x):\n        \"\"\"Pass units to the internal converter, potentially updating its mapping.\"\"\"\n        self.converter = mpl.units.registry.get_converter(x)\n        if self.converter is not None:\n            self.converter.default_units(x, self)\n\n            info = self.converter.axisinfo(self.units, self)\n\n            if info is None:\n                return\n            if info.majloc is not None:\n                self.set_major_locator(info.majloc)\n            if info.majfmt is not None:\n                self.set_major_formatter(info.majfmt)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "update_units", "self", "x", "pass", "units", "to", "the", "internal", "converter", "potentially", "updating", "its", "mapping", "self", "converter", "mpl", "units", "registry", "get_converter", "x", "if", "self", "converter", "is", "not", "none", "self", "converter", "default_units", "x", "self", "info", "self", "converter", "axisinfo", "self", "units", "self", "if", "info", "is", "none", "return", "if", "info", "majloc", "is", "not", "none", "self", "set_major_locator", "info", "majloc", "if", "info", "majfmt", "is", "not", "none", "self", "set_major_formatter", "info", "majfmt"], "doc_len": 69}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.convert_units", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "convert_units", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def convert_units(self, x):\n        \"\"\"Return a numeric representation of the input data.\"\"\"\n        if np.issubdtype(np.asarray(x).dtype, np.number):\n            return x\n        elif self.converter is None:\n            return x\n        return self.converter.convert(x, self.units, self)\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "convert_units", "self", "x", "return", "a", "numeric", "representation", "of", "the", "input", "data", "if", "np", "issubdtype", "np", "asarray", "x", "dtype", "np", "number", "return", "x", "elif", "self", "converter", "is", "none", "return", "x", "return", "self", "converter", "convert", "x", "self", "units", "self"], "doc_len": 43}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.get_scale", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "get_scale", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def get_scale(self):\n        # Note that matplotlib actually returns a string here!\n        # (e.g., with a log scale, axis.get_scale() returns \"log\")\n        # Currently we just hit it with minor ticks where it checks for\n        # scale == \"log\". I'm not sure how you'd actually use log-scale\n        # minor \"ticks\" in a legend context, so this is fine....\n        return self.scale\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "get_scale", "self", "note", "that", "matplotlib", "actually", "returns", "a", "string", "here", "e", "g", "with", "a", "log", "scale", "axis", "get_scale", "returns", "log", "currently", "we", "just", "hit", "it", "with", "minor", "ticks", "where", "it", "checks", "for", "scale", "log", "i", "m", "not", "sure", "how", "you", "d", "actually", "use", "log", "scale", "minor", "ticks", "in", "a", "legend", "context", "so", "this", "is", "fine", "return", "self", "scale"], "doc_len": 64}
{"doc_id": "seaborn/_core/scales.py::PseudoAxis.get_majorticklocs", "file_path": "seaborn/_core/scales.py", "class_name": "PseudoAxis", "func_name": "get_majorticklocs", "text": "文件路径: seaborn/_core/scales.py, 类名: PseudoAxis\n    def get_majorticklocs(self):\n        return self.major.locator()\n", "tokens": ["seaborn", "_core", "scales", "py", "pseudoaxis", "def", "get_majorticklocs", "self", "return", "self", "major", "locator"], "doc_len": 12}
{"doc_id": "seaborn/_core/scales.py::_make_identity_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_identity_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_identity_transforms() -> TransFuncs:\n\n    def identity(x):\n        return x\n\n    return identity, identity\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_identity_transforms", "transfuncs", "def", "identity", "x", "return", "x", "return", "identity", "identity"], "doc_len": 15}
{"doc_id": "seaborn/_core/scales.py::_make_logit_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_logit_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_logit_transforms(base: float | None = None) -> TransFuncs:\n\n    log, exp = _make_log_transforms(base)\n\n    def logit(x):\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return log(x) - log(1 - x)\n\n    def expit(x):\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return exp(x) / (1 + exp(x))\n\n    return logit, expit\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_logit_transforms", "base", "float", "none", "none", "transfuncs", "log", "exp", "_make_log_transforms", "base", "def", "logit", "x", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "log", "x", "log", "1", "x", "def", "expit", "x", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "exp", "x", "1", "exp", "x", "return", "logit", "expit"], "doc_len": 50}
{"doc_id": "seaborn/_core/scales.py::_make_log_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_log_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_log_transforms(base: float | None = None) -> TransFuncs:\n\n    fs: TransFuncs\n    if base is None:\n        fs = np.log, np.exp\n    elif base == 2:\n        fs = np.log2, partial(np.power, 2)\n    elif base == 10:\n        fs = np.log10, partial(np.power, 10)\n    else:\n        def forward(x):\n            return np.log(x) / np.log(base)\n        fs = forward, partial(np.power, base)\n\n    def log(x: ArrayLike) -> ArrayLike:\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return fs[0](x)\n\n    def exp(x: ArrayLike) -> ArrayLike:\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return fs[1](x)\n\n    return log, exp\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_log_transforms", "base", "float", "none", "none", "transfuncs", "fs", "transfuncs", "if", "base", "is", "none", "fs", "np", "log", "np", "exp", "elif", "base", "2", "fs", "np", "log2", "partial", "np", "power", "2", "elif", "base", "10", "fs", "np", "log10", "partial", "np", "power", "10", "else", "def", "forward", "x", "return", "np", "log", "x", "np", "log", "base", "fs", "forward", "partial", "np", "power", "base", "def", "log", "x", "arraylike", "arraylike", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "fs", "0", "x", "def", "exp", "x", "arraylike", "arraylike", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "fs", "1", "x", "return", "log", "exp"], "doc_len": 94}
{"doc_id": "seaborn/_core/scales.py::_make_symlog_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_symlog_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_symlog_transforms(c: float = 1, base: float = 10) -> TransFuncs:\n\n    # From https://iopscience.iop.org/article/10.1088/0957-0233/24/2/027001\n\n    # Note: currently not using base because we only get\n    # one parameter from the string, and are using c (this is consistent with d3)\n\n    log, exp = _make_log_transforms(base)\n\n    def symlog(x):\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return np.sign(x) * log(1 + np.abs(np.divide(x, c)))\n\n    def symexp(x):\n        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n            return np.sign(x) * c * (exp(np.abs(x)) - 1)\n\n    return symlog, symexp\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_symlog_transforms", "c", "float", "1", "base", "float", "10", "transfuncs", "from", "https", "iopscience", "iop", "org", "article", "10", "1088", "0957", "0233", "24", "2", "027001", "note", "currently", "not", "using", "base", "because", "we", "only", "get", "one", "parameter", "from", "the", "string", "and", "are", "using", "c", "this", "is", "consistent", "with", "d3", "log", "exp", "_make_log_transforms", "base", "def", "symlog", "x", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "np", "sign", "x", "log", "1", "np", "abs", "np", "divide", "x", "c", "def", "symexp", "x", "with", "np", "errstate", "invalid", "ignore", "divide", "ignore", "return", "np", "sign", "x", "c", "exp", "np", "abs", "x", "1", "return", "symlog", "symexp"], "doc_len": 98}
{"doc_id": "seaborn/_core/scales.py::_make_sqrt_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_sqrt_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_sqrt_transforms() -> TransFuncs:\n\n    def sqrt(x):\n        return np.sign(x) * np.sqrt(np.abs(x))\n\n    def square(x):\n        return np.sign(x) * np.square(x)\n\n    return sqrt, square\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_sqrt_transforms", "transfuncs", "def", "sqrt", "x", "return", "np", "sign", "x", "np", "sqrt", "np", "abs", "x", "def", "square", "x", "return", "np", "sign", "x", "np", "square", "x", "return", "sqrt", "square"], "doc_len": 32}
{"doc_id": "seaborn/_core/scales.py::_make_power_transforms", "file_path": "seaborn/_core/scales.py", "class_name": null, "func_name": "_make_power_transforms", "text": "文件路径: seaborn/_core/scales.py\ndef _make_power_transforms(exp: float) -> TransFuncs:\n\n    def forward(x):\n        return np.sign(x) * np.power(np.abs(x), exp)\n\n    def inverse(x):\n        return np.sign(x) * np.power(np.abs(x), 1 / exp)\n\n    return forward, inverse\n", "tokens": ["seaborn", "_core", "scales", "py", "def", "_make_power_transforms", "exp", "float", "transfuncs", "def", "forward", "x", "return", "np", "sign", "x", "np", "power", "np", "abs", "x", "exp", "def", "inverse", "x", "return", "np", "sign", "x", "np", "power", "np", "abs", "x", "1", "exp", "return", "forward", "inverse"], "doc_len": 39}
{"doc_id": "seaborn/_core/subplots.py::Subplots.__init__", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "__init__", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def __init__(\n        self,\n        subplot_spec: dict,  # TODO define as TypedDict\n        facet_spec: FacetSpec,\n        pair_spec: PairSpec,\n    ):\n\n        self.subplot_spec = subplot_spec\n\n        self._check_dimension_uniqueness(facet_spec, pair_spec)\n        self._determine_grid_dimensions(facet_spec, pair_spec)\n        self._handle_wrapping(facet_spec, pair_spec)\n        self._determine_axis_sharing(pair_spec)\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "__init__", "self", "subplot_spec", "dict", "todo", "define", "as", "typeddict", "facet_spec", "facetspec", "pair_spec", "pairspec", "self", "subplot_spec", "subplot_spec", "self", "_check_dimension_uniqueness", "facet_spec", "pair_spec", "self", "_determine_grid_dimensions", "facet_spec", "pair_spec", "self", "_handle_wrapping", "facet_spec", "pair_spec", "self", "_determine_axis_sharing", "pair_spec"], "doc_len": 36}
{"doc_id": "seaborn/_core/subplots.py::Subplots._check_dimension_uniqueness", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "_check_dimension_uniqueness", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def _check_dimension_uniqueness(\n        self, facet_spec: FacetSpec, pair_spec: PairSpec\n    ) -> None:\n        \"\"\"Reject specs that pair and facet on (or wrap to) same figure dimension.\"\"\"\n        err = None\n\n        facet_vars = facet_spec.get(\"variables\", {})\n\n        if facet_spec.get(\"wrap\") and {\"col\", \"row\"} <= set(facet_vars):\n            err = \"Cannot wrap facets when specifying both `col` and `row`.\"\n        elif (\n            pair_spec.get(\"wrap\")\n            and pair_spec.get(\"cross\", True)\n            and len(pair_spec.get(\"structure\", {}).get(\"x\", [])) > 1\n            and len(pair_spec.get(\"structure\", {}).get(\"y\", [])) > 1\n        ):\n            err = \"Cannot wrap subplots when pairing on both `x` and `y`.\"\n\n        collisions = {\"x\": [\"columns\", \"rows\"], \"y\": [\"rows\", \"columns\"]}\n        for pair_axis, (multi_dim, wrap_dim) in collisions.items():\n            if pair_axis not in pair_spec.get(\"structure\", {}):\n                continue\n            elif multi_dim[:3] in facet_vars:\n                err = f\"Cannot facet the {multi_dim} while pairing on `{pair_axis}``.\"\n            elif wrap_dim[:3] in facet_vars and facet_spec.get(\"wrap\"):\n                err = f\"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``.\"\n            elif wrap_dim[:3] in facet_vars and pair_spec.get(\"wrap\"):\n                err = f\"Cannot wrap the {multi_dim} while faceting the {wrap_dim}.\"\n\n        if err is not None:\n            raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "_check_dimension_uniqueness", "self", "facet_spec", "facetspec", "pair_spec", "pairspec", "none", "reject", "specs", "that", "pair", "and", "facet", "on", "or", "wrap", "to", "same", "figure", "dimension", "err", "none", "facet_vars", "facet_spec", "get", "variables", "if", "facet_spec", "get", "wrap", "and", "col", "row", "set", "facet_vars", "err", "cannot", "wrap", "facets", "when", "specifying", "both", "col", "and", "row", "elif", "pair_spec", "get", "wrap", "and", "pair_spec", "get", "cross", "true", "and", "len", "pair_spec", "get", "structure", "get", "x", "1", "and", "len", "pair_spec", "get", "structure", "get", "y", "1", "err", "cannot", "wrap", "subplots", "when", "pairing", "on", "both", "x", "and", "y", "collisions", "x", "columns", "rows", "y", "rows", "columns", "for", "pair_axis", "multi_dim", "wrap_dim", "in", "collisions", "items", "if", "pair_axis", "not", "in", "pair_spec", "get", "structure", "continue", "elif", "multi_dim", "3", "in", "facet_vars", "err", "f", "cannot", "facet", "the", "multi_dim", "while", "pairing", "on", "pair_axis", "elif", "wrap_dim", "3", "in", "facet_vars", "and", "facet_spec", "get", "wrap", "err", "f", "cannot", "wrap", "the", "wrap_dim", "while", "pairing", "on", "pair_axis", "elif", "wrap_dim", "3", "in", "facet_vars", "and", "pair_spec", "get", "wrap", "err", "f", "cannot", "wrap", "the", "multi_dim", "while", "faceting", "the", "wrap_dim", "if", "err", "is", "not", "none", "raise", "runtimeerror", "err", "todo", "what", "err", "class", "define", "plotspecerror"], "doc_len": 176}
{"doc_id": "seaborn/_core/subplots.py::Subplots._determine_grid_dimensions", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "_determine_grid_dimensions", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def _determine_grid_dimensions(\n        self, facet_spec: FacetSpec, pair_spec: PairSpec\n    ) -> None:\n        \"\"\"Parse faceting and pairing information to define figure structure.\"\"\"\n        self.grid_dimensions: dict[str, list] = {}\n        for dim, axis in zip([\"col\", \"row\"], [\"x\", \"y\"]):\n\n            facet_vars = facet_spec.get(\"variables\", {})\n            if dim in facet_vars:\n                self.grid_dimensions[dim] = facet_spec[\"structure\"][dim]\n            elif axis in pair_spec.get(\"structure\", {}):\n                self.grid_dimensions[dim] = [\n                    None for _ in pair_spec.get(\"structure\", {})[axis]\n                ]\n            else:\n                self.grid_dimensions[dim] = [None]\n\n            self.subplot_spec[f\"n{dim}s\"] = len(self.grid_dimensions[dim])\n\n        if not pair_spec.get(\"cross\", True):\n            self.subplot_spec[\"nrows\"] = 1\n\n        self.n_subplots = self.subplot_spec[\"ncols\"] * self.subplot_spec[\"nrows\"]\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "_determine_grid_dimensions", "self", "facet_spec", "facetspec", "pair_spec", "pairspec", "none", "parse", "faceting", "and", "pairing", "information", "to", "define", "figure", "structure", "self", "grid_dimensions", "dict", "str", "list", "for", "dim", "axis", "in", "zip", "col", "row", "x", "y", "facet_vars", "facet_spec", "get", "variables", "if", "dim", "in", "facet_vars", "self", "grid_dimensions", "dim", "facet_spec", "structure", "dim", "elif", "axis", "in", "pair_spec", "get", "structure", "self", "grid_dimensions", "dim", "none", "for", "_", "in", "pair_spec", "get", "structure", "axis", "else", "self", "grid_dimensions", "dim", "none", "self", "subplot_spec", "f", "n", "dim", "s", "len", "self", "grid_dimensions", "dim", "if", "not", "pair_spec", "get", "cross", "true", "self", "subplot_spec", "nrows", "1", "self", "n_subplots", "self", "subplot_spec", "ncols", "self", "subplot_spec", "nrows"], "doc_len": 100}
{"doc_id": "seaborn/_core/subplots.py::Subplots._handle_wrapping", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "_handle_wrapping", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def _handle_wrapping(\n        self, facet_spec: FacetSpec, pair_spec: PairSpec\n    ) -> None:\n        \"\"\"Update figure structure parameters based on facet/pair wrapping.\"\"\"\n        self.wrap = wrap = facet_spec.get(\"wrap\") or pair_spec.get(\"wrap\")\n        if not wrap:\n            return\n\n        wrap_dim = \"row\" if self.subplot_spec[\"nrows\"] > 1 else \"col\"\n        flow_dim = {\"row\": \"col\", \"col\": \"row\"}[wrap_dim]\n        n_subplots = self.subplot_spec[f\"n{wrap_dim}s\"]\n        flow = int(np.ceil(n_subplots / wrap))\n\n        if wrap < self.subplot_spec[f\"n{wrap_dim}s\"]:\n            self.subplot_spec[f\"n{wrap_dim}s\"] = wrap\n        self.subplot_spec[f\"n{flow_dim}s\"] = flow\n        self.n_subplots = n_subplots\n        self.wrap_dim = wrap_dim\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "_handle_wrapping", "self", "facet_spec", "facetspec", "pair_spec", "pairspec", "none", "update", "figure", "structure", "parameters", "based", "on", "facet", "pair", "wrapping", "self", "wrap", "wrap", "facet_spec", "get", "wrap", "or", "pair_spec", "get", "wrap", "if", "not", "wrap", "return", "wrap_dim", "row", "if", "self", "subplot_spec", "nrows", "1", "else", "col", "flow_dim", "row", "col", "col", "row", "wrap_dim", "n_subplots", "self", "subplot_spec", "f", "n", "wrap_dim", "s", "flow", "int", "np", "ceil", "n_subplots", "wrap", "if", "wrap", "self", "subplot_spec", "f", "n", "wrap_dim", "s", "self", "subplot_spec", "f", "n", "wrap_dim", "s", "wrap", "self", "subplot_spec", "f", "n", "flow_dim", "s", "flow", "self", "n_subplots", "n_subplots", "self", "wrap_dim", "wrap_dim"], "doc_len": 92}
{"doc_id": "seaborn/_core/subplots.py::Subplots._determine_axis_sharing", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "_determine_axis_sharing", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:\n        \"\"\"Update subplot spec with default or specified axis sharing parameters.\"\"\"\n        axis_to_dim = {\"x\": \"col\", \"y\": \"row\"}\n        key: str\n        val: str | bool\n        for axis in \"xy\":\n            key = f\"share{axis}\"\n            # Always use user-specified value, if present\n            if key not in self.subplot_spec:\n                if axis in pair_spec.get(\"structure\", {}):\n                    # Paired axes are shared along one dimension by default\n                    if self.wrap is None and pair_spec.get(\"cross\", True):\n                        val = axis_to_dim[axis]\n                    else:\n                        val = False\n                else:\n                    # This will pick up faceted plots, as well as single subplot\n                    # figures, where the value doesn't really matter\n                    val = True\n                self.subplot_spec[key] = val\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "_determine_axis_sharing", "self", "pair_spec", "pairspec", "none", "update", "subplot", "spec", "with", "default", "or", "specified", "axis", "sharing", "parameters", "axis_to_dim", "x", "col", "y", "row", "key", "str", "val", "str", "bool", "for", "axis", "in", "xy", "key", "f", "share", "axis", "always", "use", "user", "specified", "value", "if", "present", "if", "key", "not", "in", "self", "subplot_spec", "if", "axis", "in", "pair_spec", "get", "structure", "paired", "axes", "are", "shared", "along", "one", "dimension", "by", "default", "if", "self", "wrap", "is", "none", "and", "pair_spec", "get", "cross", "true", "val", "axis_to_dim", "axis", "else", "val", "false", "else", "this", "will", "pick", "up", "faceted", "plots", "as", "well", "as", "single", "subplot", "figures", "where", "the", "value", "doesn", "t", "really", "matter", "val", "true", "self", "subplot_spec", "key", "val"], "doc_len": 109}
{"doc_id": "seaborn/_core/subplots.py::Subplots.init_figure", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "init_figure", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def init_figure(\n        self,\n        pair_spec: PairSpec,\n        pyplot: bool = False,\n        figure_kws: dict | None = None,\n        target: Axes | Figure | SubFigure = None,\n    ) -> Figure:\n        \"\"\"Initialize matplotlib objects and add seaborn-relevant metadata.\"\"\"\n        # TODO reduce need to pass pair_spec here?\n\n        if figure_kws is None:\n            figure_kws = {}\n\n        if isinstance(target, mpl.axes.Axes):\n\n            if max(self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]) > 1:\n                err = \" \".join([\n                    \"Cannot create multiple subplots after calling `Plot.on` with\",\n                    f\"a {mpl.axes.Axes} object.\",\n                ])\n                try:\n                    err += f\" You may want to use a {mpl.figure.SubFigure} instead.\"\n                except AttributeError:  # SubFigure added in mpl 3.4\n                    pass\n                raise RuntimeError(err)\n\n            self._subplot_list = [{\n                \"ax\": target,\n                \"left\": True,\n                \"right\": True,\n                \"top\": True,\n                \"bottom\": True,\n                \"col\": None,\n                \"row\": None,\n                \"x\": \"x\",\n                \"y\": \"y\",\n            }]\n            self._figure = target.figure\n            return self._figure\n\n        elif (\n            hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4\n            and isinstance(target, mpl.figure.SubFigure)\n        ):\n            figure = target.figure\n        elif isinstance(target, mpl.figure.Figure):\n            figure = target\n        else:\n            if pyplot:\n                figure = plt.figure(**figure_kws)\n            else:\n                figure = mpl.figure.Figure(**figure_kws)\n            target = figure\n        self._figure = figure\n\n        axs = target.subplots(**self.subplot_spec, squeeze=False)\n\n        if self.wrap:\n            # Remove unused Axes and flatten the rest into a (2D) vector\n            axs_flat = axs.ravel({\"col\": \"C\", \"row\": \"F\"}[self.wrap_dim])\n            axs, extra = np.split(axs_flat, [self.n_subplots])\n            for ax in extra:\n                ax.remove()\n            if self.wrap_dim == \"col\":\n                axs = axs[np.newaxis, :]\n            else:\n                axs = axs[:, np.newaxis]\n\n        # Get i, j coordinates for each Axes object\n        # Note that i, j are with respect to faceting/pairing,\n        # not the subplot grid itself, (which only matters in the case of wrapping).\n        iter_axs: np.ndenumerate | zip\n        if not pair_spec.get(\"cross\", True):\n            indices = np.arange(self.n_subplots)\n            iter_axs = zip(zip(indices, indices), axs.flat)\n        else:\n            iter_axs = np.ndenumerate(axs)\n\n        self._subplot_list = []\n        for (i, j), ax in iter_axs:\n\n            info = {\"ax\": ax}\n\n            nrows, ncols = self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]\n            if not self.wrap:\n                info[\"left\"] = j % ncols == 0\n                info[\"right\"] = (j + 1) % ncols == 0\n                info[\"top\"] = i == 0\n                info[\"bottom\"] = i == nrows - 1\n            elif self.wrap_dim == \"col\":\n                info[\"left\"] = j % ncols == 0\n                info[\"right\"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)\n                info[\"top\"] = j < ncols\n                info[\"bottom\"] = j >= (self.n_subplots - ncols)\n            elif self.wrap_dim == \"row\":\n                info[\"left\"] = i < nrows\n                info[\"right\"] = i >= self.n_subplots - nrows\n                info[\"top\"] = i % nrows == 0\n                info[\"bottom\"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)\n\n            if not pair_spec.get(\"cross\", True):\n                info[\"top\"] = j < ncols\n                info[\"bottom\"] = j >= self.n_subplots - ncols\n\n            for dim in [\"row\", \"col\"]:\n                idx = {\"row\": i, \"col\": j}[dim]\n                info[dim] = self.grid_dimensions[dim][idx]\n\n            for axis in \"xy\":\n\n                idx = {\"x\": j, \"y\": i}[axis]\n                if axis in pair_spec.get(\"structure\", {}):\n                    key = f\"{axis}{idx}\"\n                else:\n                    key = axis\n                info[axis] = key\n\n            self._subplot_list.append(info)\n\n        return figure\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "init_figure", "self", "pair_spec", "pairspec", "pyplot", "bool", "false", "figure_kws", "dict", "none", "none", "target", "axes", "figure", "subfigure", "none", "figure", "initialize", "matplotlib", "objects", "and", "add", "seaborn", "relevant", "metadata", "todo", "reduce", "need", "to", "pass", "pair_spec", "here", "if", "figure_kws", "is", "none", "figure_kws", "if", "isinstance", "target", "mpl", "axes", "axes", "if", "max", "self", "subplot_spec", "nrows", "self", "subplot_spec", "ncols", "1", "err", "join", "cannot", "create", "multiple", "subplots", "after", "calling", "plot", "on", "with", "f", "a", "mpl", "axes", "axes", "object", "try", "err", "f", "you", "may", "want", "to", "use", "a", "mpl", "figure", "subfigure", "instead", "except", "attributeerror", "subfigure", "added", "in", "mpl", "3", "4", "pass", "raise", "runtimeerror", "err", "self", "_subplot_list", "ax", "target", "left", "true", "right", "true", "top", "true", "bottom", "true", "col", "none", "row", "none", "x", "x", "y", "y", "self", "_figure", "target", "figure", "return", "self", "_figure", "elif", "hasattr", "mpl", "figure", "subfigure", "added", "in", "mpl", "3", "4", "and", "isinstance", "target", "mpl", "figure", "subfigure", "figure", "target", "figure", "elif", "isinstance", "target", "mpl", "figure", "figure", "figure", "target", "else", "if", "pyplot", "figure", "plt", "figure", "figure_kws", "else", "figure", "mpl", "figure", "figure", "figure_kws", "target", "figure", "self", "_figure", "figure", "axs", "target", "subplots", "self", "subplot_spec", "squeeze", "false", "if", "self", "wrap", "remove", "unused", "axes", "and", "flatten", "the", "rest", "into", "a", "2d", "vector", "axs_flat", "axs", "ravel", "col", "c", "row", "f", "self", "wrap_dim", "axs", "extra", "np", "split", "axs_flat", "self", "n_subplots", "for", "ax", "in", "extra", "ax", "remove", "if", "self", "wrap_dim", "col", "axs", "axs", "np", "newaxis", "else", "axs", "axs", "np", "newaxis", "get", "i", "j", "coordinates", "for", "each", "axes", "object", "note", "that", "i", "j", "are", "with", "respect", "to", "faceting", "pairing", "not", "the", "subplot", "grid", "itself", "which", "only", "matters", "in", "the", "case", "of", "wrapping", "iter_axs", "np", "ndenumerate", "zip", "if", "not", "pair_spec", "get", "cross", "true", "indices", "np", "arange", "self", "n_subplots", "iter_axs", "zip", "zip", "indices", "indices", "axs", "flat", "else", "iter_axs", "np", "ndenumerate", "axs", "self", "_subplot_list", "for", "i", "j", "ax", "in", "iter_axs", "info", "ax", "ax", "nrows", "ncols", "self", "subplot_spec", "nrows", "self", "subplot_spec", "ncols", "if", "not", "self", "wrap", "info", "left", "j", "ncols", "0", "info", "right", "j", "1", "ncols", "0", "info", "top", "i", "0", "info", "bottom", "i", "nrows", "1", "elif", "self", "wrap_dim", "col", "info", "left", "j", "ncols", "0", "info", "right", "j", "1", "ncols", "0", "or", "j", "1", "self", "n_subplots", "info", "top", "j", "ncols", "info", "bottom", "j", "self", "n_subplots", "ncols", "elif", "self", "wrap_dim", "row", "info", "left", "i", "nrows", "info", "right", "i", "self", "n_subplots", "nrows", "info", "top", "i", "nrows", "0", "info", "bottom", "i", "1", "nrows", "0", "or", "i", "1", "self", "n_subplots", "if", "not", "pair_spec", "get", "cross", "true", "info", "top", "j", "ncols", "info", "bottom", "j", "self", "n_subplots", "ncols", "for", "dim", "in", "row", "col", "idx", "row", "i", "col", "j", "dim", "info", "dim", "self", "grid_dimensions", "dim", "idx", "for", "axis", "in", "xy", "idx", "x", "j", "y", "i", "axis", "if", "axis", "in", "pair_spec", "get", "structure", "key", "f", "axis", "idx", "else", "key", "axis", "info", "axis", "key", "self", "_subplot_list", "append", "info", "return", "figure"], "doc_len": 454}
{"doc_id": "seaborn/_core/subplots.py::Subplots.__iter__", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "__iter__", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?\n        \"\"\"Yield each subplot dictionary with Axes object and metadata.\"\"\"\n        yield from self._subplot_list\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "__iter__", "self", "generator", "dict", "none", "none", "todo", "typeddict", "yield", "each", "subplot", "dictionary", "with", "axes", "object", "and", "metadata", "yield", "from", "self", "_subplot_list"], "doc_len": 27}
{"doc_id": "seaborn/_core/subplots.py::Subplots.__len__", "file_path": "seaborn/_core/subplots.py", "class_name": "Subplots", "func_name": "__len__", "text": "文件路径: seaborn/_core/subplots.py, 类名: Subplots\n    def __len__(self) -> int:\n        \"\"\"Return the number of subplots in this figure.\"\"\"\n        return len(self._subplot_list)\n", "tokens": ["seaborn", "_core", "subplots", "py", "subplots", "def", "__len__", "self", "int", "return", "the", "number", "of", "subplots", "in", "this", "figure", "return", "len", "self", "_subplot_list"], "doc_len": 21}
{"doc_id": "seaborn/_core/typing.py::Default.__repr__", "file_path": "seaborn/_core/typing.py", "class_name": "Default", "func_name": "__repr__", "text": "文件路径: seaborn/_core/typing.py, 类名: Default\n    def __repr__(self):\n        return \"<default>\"\n", "tokens": ["seaborn", "_core", "typing", "py", "default", "def", "__repr__", "self", "return", "default"], "doc_len": 10}
{"doc_id": "seaborn/_marks/area.py::AreaBase._plot", "file_path": "seaborn/_marks/area.py", "class_name": "AreaBase", "func_name": "_plot", "text": "文件路径: seaborn/_marks/area.py, 类名: AreaBase\n    def _plot(self, split_gen, scales, orient):\n\n        patches = defaultdict(list)\n\n        for keys, data, ax in split_gen():\n\n            kws = {}\n            data = self._standardize_coordinate_parameters(data, orient)\n            resolved = resolve_properties(self, keys, scales)\n            verts = self._get_verts(data, orient)\n            ax.update_datalim(verts)\n\n            # TODO should really move this logic into resolve_color\n            fc = resolve_color(self, keys, \"\", scales)\n            if not resolved[\"fill\"]:\n                fc = mpl.colors.to_rgba(fc, 0)\n\n            kws[\"facecolor\"] = fc\n            kws[\"edgecolor\"] = resolve_color(self, keys, \"edge\", scales)\n            kws[\"linewidth\"] = resolved[\"edgewidth\"]\n            kws[\"linestyle\"] = resolved[\"edgestyle\"]\n\n            patches[ax].append(mpl.patches.Polygon(verts, **kws))\n\n        for ax, ax_patches in patches.items():\n\n            for patch in ax_patches:\n                self._postprocess_artist(patch, ax, orient)\n                ax.add_patch(patch)\n", "tokens": ["seaborn", "_marks", "area", "py", "areabase", "def", "_plot", "self", "split_gen", "scales", "orient", "patches", "defaultdict", "list", "for", "keys", "data", "ax", "in", "split_gen", "kws", "data", "self", "_standardize_coordinate_parameters", "data", "orient", "resolved", "resolve_properties", "self", "keys", "scales", "verts", "self", "_get_verts", "data", "orient", "ax", "update_datalim", "verts", "todo", "should", "really", "move", "this", "logic", "into", "resolve_color", "fc", "resolve_color", "self", "keys", "scales", "if", "not", "resolved", "fill", "fc", "mpl", "colors", "to_rgba", "fc", "0", "kws", "facecolor", "fc", "kws", "edgecolor", "resolve_color", "self", "keys", "edge", "scales", "kws", "linewidth", "resolved", "edgewidth", "kws", "linestyle", "resolved", "edgestyle", "patches", "ax", "append", "mpl", "patches", "polygon", "verts", "kws", "for", "ax", "ax_patches", "in", "patches", "items", "for", "patch", "in", "ax_patches", "self", "_postprocess_artist", "patch", "ax", "orient", "ax", "add_patch", "patch"], "doc_len": 106}
{"doc_id": "seaborn/_marks/area.py::AreaBase._standardize_coordinate_parameters", "file_path": "seaborn/_marks/area.py", "class_name": "AreaBase", "func_name": "_standardize_coordinate_parameters", "text": "文件路径: seaborn/_marks/area.py, 类名: AreaBase\n    def _standardize_coordinate_parameters(self, data, orient):\n        return data\n", "tokens": ["seaborn", "_marks", "area", "py", "areabase", "def", "_standardize_coordinate_parameters", "self", "data", "orient", "return", "data"], "doc_len": 12}
{"doc_id": "seaborn/_marks/area.py::AreaBase._postprocess_artist", "file_path": "seaborn/_marks/area.py", "class_name": "AreaBase", "func_name": "_postprocess_artist", "text": "文件路径: seaborn/_marks/area.py, 类名: AreaBase\n    def _postprocess_artist(self, artist, ax, orient):\n        pass\n", "tokens": ["seaborn", "_marks", "area", "py", "areabase", "def", "_postprocess_artist", "self", "artist", "ax", "orient", "pass"], "doc_len": 12}
{"doc_id": "seaborn/_marks/area.py::AreaBase._get_verts", "file_path": "seaborn/_marks/area.py", "class_name": "AreaBase", "func_name": "_get_verts", "text": "文件路径: seaborn/_marks/area.py, 类名: AreaBase\n    def _get_verts(self, data, orient):\n\n        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        data = data.sort_values(orient, kind=\"mergesort\")\n        verts = np.concatenate([\n            data[[orient, f\"{dv}min\"]].to_numpy(),\n            data[[orient, f\"{dv}max\"]].to_numpy()[::-1],\n        ])\n        if orient == \"y\":\n            verts = verts[:, ::-1]\n        return verts\n", "tokens": ["seaborn", "_marks", "area", "py", "areabase", "def", "_get_verts", "self", "data", "orient", "dv", "x", "y", "y", "x", "orient", "data", "data", "sort_values", "orient", "kind", "mergesort", "verts", "np", "concatenate", "data", "orient", "f", "dv", "min", "to_numpy", "data", "orient", "f", "dv", "max", "to_numpy", "1", "if", "orient", "y", "verts", "verts", "1", "return", "verts"], "doc_len": 46}
{"doc_id": "seaborn/_marks/area.py::AreaBase._legend_artist", "file_path": "seaborn/_marks/area.py", "class_name": "AreaBase", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/area.py, 类名: AreaBase\n    def _legend_artist(self, variables, value, scales):\n\n        keys = {v: value for v in variables}\n        resolved = resolve_properties(self, keys, scales)\n\n        fc = resolve_color(self, keys, \"\", scales)\n        if not resolved[\"fill\"]:\n            fc = mpl.colors.to_rgba(fc, 0)\n\n        return mpl.patches.Patch(\n            facecolor=fc,\n            edgecolor=resolve_color(self, keys, \"edge\", scales),\n            linewidth=resolved[\"edgewidth\"],\n            linestyle=resolved[\"edgestyle\"],\n            **self.artist_kws,\n        )\n", "tokens": ["seaborn", "_marks", "area", "py", "areabase", "def", "_legend_artist", "self", "variables", "value", "scales", "keys", "v", "value", "for", "v", "in", "variables", "resolved", "resolve_properties", "self", "keys", "scales", "fc", "resolve_color", "self", "keys", "scales", "if", "not", "resolved", "fill", "fc", "mpl", "colors", "to_rgba", "fc", "0", "return", "mpl", "patches", "patch", "facecolor", "fc", "edgecolor", "resolve_color", "self", "keys", "edge", "scales", "linewidth", "resolved", "edgewidth", "linestyle", "resolved", "edgestyle", "self", "artist_kws"], "doc_len": 58}
{"doc_id": "seaborn/_marks/area.py::Area._standardize_coordinate_parameters", "file_path": "seaborn/_marks/area.py", "class_name": "Area", "func_name": "_standardize_coordinate_parameters", "text": "文件路径: seaborn/_marks/area.py, 类名: Area\n    def _standardize_coordinate_parameters(self, data, orient):\n        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        return data.rename(columns={\"baseline\": f\"{dv}min\", dv: f\"{dv}max\"})\n", "tokens": ["seaborn", "_marks", "area", "py", "area", "def", "_standardize_coordinate_parameters", "self", "data", "orient", "dv", "x", "y", "y", "x", "orient", "return", "data", "rename", "columns", "baseline", "f", "dv", "min", "dv", "f", "dv", "max"], "doc_len": 28}
{"doc_id": "seaborn/_marks/area.py::Area._postprocess_artist", "file_path": "seaborn/_marks/area.py", "class_name": "Area", "func_name": "_postprocess_artist", "text": "文件路径: seaborn/_marks/area.py, 类名: Area\n    def _postprocess_artist(self, artist, ax, orient):\n\n        # TODO copying a lot of code from Bar, let's abstract this\n        # See comments there, I am not going to repeat them too\n\n        artist.set_linewidth(artist.get_linewidth() * 2)\n\n        linestyle = artist.get_linestyle()\n        if linestyle[1]:\n            linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))\n        artist.set_linestyle(linestyle)\n\n        artist.set_clip_path(artist.get_path(), artist.get_transform() + ax.transData)\n        if self.artist_kws.get(\"clip_on\", True):\n            artist.set_clip_box(ax.bbox)\n\n        val_idx = [\"y\", \"x\"].index(orient)\n        artist.sticky_edges[val_idx][:] = (0, np.inf)\n", "tokens": ["seaborn", "_marks", "area", "py", "area", "def", "_postprocess_artist", "self", "artist", "ax", "orient", "todo", "copying", "a", "lot", "of", "code", "from", "bar", "let", "s", "abstract", "this", "see", "comments", "there", "i", "am", "not", "going", "to", "repeat", "them", "too", "artist", "set_linewidth", "artist", "get_linewidth", "2", "linestyle", "artist", "get_linestyle", "if", "linestyle", "1", "linestyle", "linestyle", "0", "tuple", "x", "2", "for", "x", "in", "linestyle", "1", "artist", "set_linestyle", "linestyle", "artist", "set_clip_path", "artist", "get_path", "artist", "get_transform", "ax", "transdata", "if", "self", "artist_kws", "get", "clip_on", "true", "artist", "set_clip_box", "ax", "bbox", "val_idx", "y", "x", "index", "orient", "artist", "sticky_edges", "val_idx", "0", "np", "inf"], "doc_len": 88}
{"doc_id": "seaborn/_marks/area.py::Band._standardize_coordinate_parameters", "file_path": "seaborn/_marks/area.py", "class_name": "Band", "func_name": "_standardize_coordinate_parameters", "text": "文件路径: seaborn/_marks/area.py, 类名: Band\n    def _standardize_coordinate_parameters(self, data, orient):\n        # dv = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        # TODO assert that all(ymax >= ymin)?\n        # TODO what if only one exist?\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:\n            agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}\n            data = data.groupby(orient).agg(**agg).reset_index()\n        return data\n", "tokens": ["seaborn", "_marks", "area", "py", "band", "def", "_standardize_coordinate_parameters", "self", "data", "orient", "dv", "x", "y", "y", "x", "orient", "todo", "assert", "that", "all", "ymax", "ymin", "todo", "what", "if", "only", "one", "exist", "other", "x", "y", "y", "x", "orient", "if", "not", "set", "data", "columns", "f", "other", "min", "f", "other", "max", "agg", "f", "other", "min", "other", "min", "f", "other", "max", "other", "max", "data", "data", "groupby", "orient", "agg", "agg", "reset_index", "return", "data"], "doc_len": 65}
{"doc_id": "seaborn/_marks/bar.py::BarBase._make_patches", "file_path": "seaborn/_marks/bar.py", "class_name": "BarBase", "func_name": "_make_patches", "text": "文件路径: seaborn/_marks/bar.py, 类名: BarBase\n    def _make_patches(self, data, scales, orient):\n\n        kws = self._resolve_properties(data, scales)\n        if orient == \"x\":\n            kws[\"x\"] = (data[\"x\"] - data[\"width\"] / 2).to_numpy()\n            kws[\"y\"] = data[\"baseline\"].to_numpy()\n            kws[\"w\"] = data[\"width\"].to_numpy()\n            kws[\"h\"] = (data[\"y\"] - data[\"baseline\"]).to_numpy()\n        else:\n            kws[\"x\"] = data[\"baseline\"].to_numpy()\n            kws[\"y\"] = (data[\"y\"] - data[\"width\"] / 2).to_numpy()\n            kws[\"w\"] = (data[\"x\"] - data[\"baseline\"]).to_numpy()\n            kws[\"h\"] = data[\"width\"].to_numpy()\n\n        kws.pop(\"width\", None)\n        kws.pop(\"baseline\", None)\n\n        val_dim = {\"x\": \"h\", \"y\": \"w\"}[orient]\n        bars, vals = [], []\n\n        for i in range(len(data)):\n\n            row = {k: v[i] for k, v in kws.items()}\n\n            # Skip bars with no value. It's possible we'll want to make this\n            # an option (i.e so you have an artist for animating or annotating),\n            # but let's keep things simple for now.\n            if not np.nan_to_num(row[val_dim]):\n                continue\n\n            bar = mpl.patches.Rectangle(\n                xy=(row[\"x\"], row[\"y\"]),\n                width=row[\"w\"],\n                height=row[\"h\"],\n                facecolor=row[\"facecolor\"],\n                edgecolor=row[\"edgecolor\"],\n                linestyle=row[\"edgestyle\"],\n                linewidth=row[\"edgewidth\"],\n                **self.artist_kws,\n            )\n            bars.append(bar)\n            vals.append(row[val_dim])\n\n        return bars, vals\n", "tokens": ["seaborn", "_marks", "bar", "py", "barbase", "def", "_make_patches", "self", "data", "scales", "orient", "kws", "self", "_resolve_properties", "data", "scales", "if", "orient", "x", "kws", "x", "data", "x", "data", "width", "2", "to_numpy", "kws", "y", "data", "baseline", "to_numpy", "kws", "w", "data", "width", "to_numpy", "kws", "h", "data", "y", "data", "baseline", "to_numpy", "else", "kws", "x", "data", "baseline", "to_numpy", "kws", "y", "data", "y", "data", "width", "2", "to_numpy", "kws", "w", "data", "x", "data", "baseline", "to_numpy", "kws", "h", "data", "width", "to_numpy", "kws", "pop", "width", "none", "kws", "pop", "baseline", "none", "val_dim", "x", "h", "y", "w", "orient", "bars", "vals", "for", "i", "in", "range", "len", "data", "row", "k", "v", "i", "for", "k", "v", "in", "kws", "items", "skip", "bars", "with", "no", "value", "it", "s", "possible", "we", "ll", "want", "to", "make", "this", "an", "option", "i", "e", "so", "you", "have", "an", "artist", "for", "animating", "or", "annotating", "but", "let", "s", "keep", "things", "simple", "for", "now", "if", "not", "np", "nan_to_num", "row", "val_dim", "continue", "bar", "mpl", "patches", "rectangle", "xy", "row", "x", "row", "y", "width", "row", "w", "height", "row", "h", "facecolor", "row", "facecolor", "edgecolor", "row", "edgecolor", "linestyle", "row", "edgestyle", "linewidth", "row", "edgewidth", "self", "artist_kws", "bars", "append", "bar", "vals", "append", "row", "val_dim", "return", "bars", "vals"], "doc_len": 183}
{"doc_id": "seaborn/_marks/bar.py::BarBase._resolve_properties", "file_path": "seaborn/_marks/bar.py", "class_name": "BarBase", "func_name": "_resolve_properties", "text": "文件路径: seaborn/_marks/bar.py, 类名: BarBase\n    def _resolve_properties(self, data, scales):\n\n        resolved = resolve_properties(self, data, scales)\n\n        resolved[\"facecolor\"] = resolve_color(self, data, \"\", scales)\n        resolved[\"edgecolor\"] = resolve_color(self, data, \"edge\", scales)\n\n        fc = resolved[\"facecolor\"]\n        if isinstance(fc, tuple):\n            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]\n        else:\n            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?\n            resolved[\"facecolor\"] = fc\n\n        return resolved\n", "tokens": ["seaborn", "_marks", "bar", "py", "barbase", "def", "_resolve_properties", "self", "data", "scales", "resolved", "resolve_properties", "self", "data", "scales", "resolved", "facecolor", "resolve_color", "self", "data", "scales", "resolved", "edgecolor", "resolve_color", "self", "data", "edge", "scales", "fc", "resolved", "facecolor", "if", "isinstance", "fc", "tuple", "resolved", "facecolor", "fc", "0", "fc", "1", "fc", "2", "fc", "3", "resolved", "fill", "else", "fc", "3", "fc", "3", "resolved", "fill", "todo", "is", "inplace", "mod", "a", "problem", "resolved", "facecolor", "fc", "return", "resolved"], "doc_len": 65}
{"doc_id": "seaborn/_marks/bar.py::BarBase._legend_artist", "file_path": "seaborn/_marks/bar.py", "class_name": "BarBase", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/bar.py, 类名: BarBase\n    def _legend_artist(\n        self, variables: list[str], value: Any, scales: dict[str, Scale],\n    ) -> Artist:\n        # TODO return some sensible default?\n        key = {v: value for v in variables}\n        key = self._resolve_properties(key, scales)\n        artist = mpl.patches.Patch(\n            facecolor=key[\"facecolor\"],\n            edgecolor=key[\"edgecolor\"],\n            linewidth=key[\"edgewidth\"],\n            linestyle=key[\"edgestyle\"],\n        )\n        return artist\n", "tokens": ["seaborn", "_marks", "bar", "py", "barbase", "def", "_legend_artist", "self", "variables", "list", "str", "value", "any", "scales", "dict", "str", "scale", "artist", "todo", "return", "some", "sensible", "default", "key", "v", "value", "for", "v", "in", "variables", "key", "self", "_resolve_properties", "key", "scales", "artist", "mpl", "patches", "patch", "facecolor", "key", "facecolor", "edgecolor", "key", "edgecolor", "linewidth", "key", "edgewidth", "linestyle", "key", "edgestyle", "return", "artist"], "doc_len": 53}
{"doc_id": "seaborn/_marks/bar.py::Bar._plot", "file_path": "seaborn/_marks/bar.py", "class_name": "Bar", "func_name": "_plot", "text": "文件路径: seaborn/_marks/bar.py, 类名: Bar\n    def _plot(self, split_gen, scales, orient):\n\n        val_idx = [\"y\", \"x\"].index(orient)\n\n        for _, data, ax in split_gen():\n\n            bars, vals = self._make_patches(data, scales, orient)\n\n            for bar in bars:\n\n                # Because we are clipping the artist (see below), the edges end up\n                # looking half as wide as they actually are. I don't love this clumsy\n                # workaround, which is going to cause surprises if you work with the\n                # artists directly. We may need to revisit after feedback.\n                bar.set_linewidth(bar.get_linewidth() * 2)\n                linestyle = bar.get_linestyle()\n                if linestyle[1]:\n                    linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))\n                bar.set_linestyle(linestyle)\n\n                # This is a bit of a hack to handle the fact that the edge lines are\n                # centered on the actual extents of the bar, and overlap when bars are\n                # stacked or dodged. We may discover that this causes problems and needs\n                # to be revisited at some point. Also it should be faster to clip with\n                # a bbox than a path, but I cant't work out how to get the intersection\n                # with the axes bbox.\n                bar.set_clip_path(bar.get_path(), bar.get_transform() + ax.transData)\n                if self.artist_kws.get(\"clip_on\", True):\n                    # It seems the above hack undoes the default axes clipping\n                    bar.set_clip_box(ax.bbox)\n                bar.sticky_edges[val_idx][:] = (0, np.inf)\n                ax.add_patch(bar)\n\n            # Add a container which is useful for, e.g. Axes.bar_label\n            if Version(mpl.__version__) >= Version(\"3.4.0\"):\n                orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]\n                container_kws = dict(datavalues=vals, orientation=orientation)\n            else:\n                container_kws = {}\n            container = mpl.container.BarContainer(bars, **container_kws)\n            ax.add_container(container)\n", "tokens": ["seaborn", "_marks", "bar", "py", "bar", "def", "_plot", "self", "split_gen", "scales", "orient", "val_idx", "y", "x", "index", "orient", "for", "_", "data", "ax", "in", "split_gen", "bars", "vals", "self", "_make_patches", "data", "scales", "orient", "for", "bar", "in", "bars", "because", "we", "are", "clipping", "the", "artist", "see", "below", "the", "edges", "end", "up", "looking", "half", "as", "wide", "as", "they", "actually", "are", "i", "don", "t", "love", "this", "clumsy", "workaround", "which", "is", "going", "to", "cause", "surprises", "if", "you", "work", "with", "the", "artists", "directly", "we", "may", "need", "to", "revisit", "after", "feedback", "bar", "set_linewidth", "bar", "get_linewidth", "2", "linestyle", "bar", "get_linestyle", "if", "linestyle", "1", "linestyle", "linestyle", "0", "tuple", "x", "2", "for", "x", "in", "linestyle", "1", "bar", "set_linestyle", "linestyle", "this", "is", "a", "bit", "of", "a", "hack", "to", "handle", "the", "fact", "that", "the", "edge", "lines", "are", "centered", "on", "the", "actual", "extents", "of", "the", "bar", "and", "overlap", "when", "bars", "are", "stacked", "or", "dodged", "we", "may", "discover", "that", "this", "causes", "problems", "and", "needs", "to", "be", "revisited", "at", "some", "point", "also", "it", "should", "be", "faster", "to", "clip", "with", "a", "bbox", "than", "a", "path", "but", "i", "cant", "t", "work", "out", "how", "to", "get", "the", "intersection", "with", "the", "axes", "bbox", "bar", "set_clip_path", "bar", "get_path", "bar", "get_transform", "ax", "transdata", "if", "self", "artist_kws", "get", "clip_on", "true", "it", "seems", "the", "above", "hack", "undoes", "the", "default", "axes", "clipping", "bar", "set_clip_box", "ax", "bbox", "bar", "sticky_edges", "val_idx", "0", "np", "inf", "ax", "add_patch", "bar", "add", "a", "container", "which", "is", "useful", "for", "e", "g", "axes", "bar_label", "if", "version", "mpl", "__version__", "version", "3", "4", "0", "orientation", "x", "vertical", "y", "horizontal", "orient", "container_kws", "dict", "datavalues", "vals", "orientation", "orientation", "else", "container_kws", "container", "mpl", "container", "barcontainer", "bars", "container_kws", "ax", "add_container", "container"], "doc_len": 259}
{"doc_id": "seaborn/_marks/bar.py::Bars._plot", "file_path": "seaborn/_marks/bar.py", "class_name": "Bars", "func_name": "_plot", "text": "文件路径: seaborn/_marks/bar.py, 类名: Bars\n    def _plot(self, split_gen, scales, orient):\n\n        ori_idx = [\"x\", \"y\"].index(orient)\n        val_idx = [\"y\", \"x\"].index(orient)\n\n        patches = defaultdict(list)\n        for _, data, ax in split_gen():\n            bars, _ = self._make_patches(data, scales, orient)\n            patches[ax].extend(bars)\n\n        collections = {}\n        for ax, ax_patches in patches.items():\n\n            col = mpl.collections.PatchCollection(ax_patches, match_original=True)\n            col.sticky_edges[val_idx][:] = (0, np.inf)\n            ax.add_collection(col, autolim=False)\n            collections[ax] = col\n\n            # Workaround for matplotlib autoscaling bug\n            # https://github.com/matplotlib/matplotlib/issues/11898\n            # https://github.com/matplotlib/matplotlib/issues/23129\n            xys = np.vstack([path.vertices for path in col.get_paths()])\n            ax.update_datalim(xys)\n\n        if \"edgewidth\" not in scales and isinstance(self.edgewidth, Mappable):\n\n            for ax in collections:\n                ax.autoscale_view()\n\n            def get_dimensions(collection):\n                edges, widths = [], []\n                for verts in (path.vertices for path in collection.get_paths()):\n                    edges.append(min(verts[:, ori_idx]))\n                    widths.append(np.ptp(verts[:, ori_idx]))\n                return np.array(edges), np.array(widths)\n\n            min_width = np.inf\n            for ax, col in collections.items():\n                edges, widths = get_dimensions(col)\n                points = 72 / ax.figure.dpi * abs(\n                    ax.transData.transform([edges + widths] * 2)\n                    - ax.transData.transform([edges] * 2)\n                )\n                min_width = min(min_width, min(points[:, ori_idx]))\n\n            linewidth = min(.1 * min_width, mpl.rcParams[\"patch.linewidth\"])\n            for _, col in collections.items():\n                col.set_linewidth(linewidth)\n", "tokens": ["seaborn", "_marks", "bar", "py", "bars", "def", "_plot", "self", "split_gen", "scales", "orient", "ori_idx", "x", "y", "index", "orient", "val_idx", "y", "x", "index", "orient", "patches", "defaultdict", "list", "for", "_", "data", "ax", "in", "split_gen", "bars", "_", "self", "_make_patches", "data", "scales", "orient", "patches", "ax", "extend", "bars", "collections", "for", "ax", "ax_patches", "in", "patches", "items", "col", "mpl", "collections", "patchcollection", "ax_patches", "match_original", "true", "col", "sticky_edges", "val_idx", "0", "np", "inf", "ax", "add_collection", "col", "autolim", "false", "collections", "ax", "col", "workaround", "for", "matplotlib", "autoscaling", "bug", "https", "github", "com", "matplotlib", "matplotlib", "issues", "11898", "https", "github", "com", "matplotlib", "matplotlib", "issues", "23129", "xys", "np", "vstack", "path", "vertices", "for", "path", "in", "col", "get_paths", "ax", "update_datalim", "xys", "if", "edgewidth", "not", "in", "scales", "and", "isinstance", "self", "edgewidth", "mappable", "for", "ax", "in", "collections", "ax", "autoscale_view", "def", "get_dimensions", "collection", "edges", "widths", "for", "verts", "in", "path", "vertices", "for", "path", "in", "collection", "get_paths", "edges", "append", "min", "verts", "ori_idx", "widths", "append", "np", "ptp", "verts", "ori_idx", "return", "np", "array", "edges", "np", "array", "widths", "min_width", "np", "inf", "for", "ax", "col", "in", "collections", "items", "edges", "widths", "get_dimensions", "col", "points", "72", "ax", "figure", "dpi", "abs", "ax", "transdata", "transform", "edges", "widths", "2", "ax", "transdata", "transform", "edges", "2", "min_width", "min", "min_width", "min", "points", "ori_idx", "linewidth", "min", "1", "min_width", "mpl", "rcparams", "patch", "linewidth", "for", "_", "col", "in", "collections", "items", "col", "set_linewidth", "linewidth"], "doc_len": 203}
{"doc_id": "seaborn/_marks/base.py::Mappable.__init__", "file_path": "seaborn/_marks/base.py", "class_name": "Mappable", "func_name": "__init__", "text": "文件路径: seaborn/_marks/base.py, 类名: Mappable\n    def __init__(\n        self,\n        val: Any = None,\n        depend: str | None = None,\n        rc: str | None = None,\n        auto: bool = False,\n        grouping: bool = True,\n    ):\n        \"\"\"\n        Property that can be mapped from data or set directly, with flexible defaults.\n\n        Parameters\n        ----------\n        val : Any\n            Use this value as the default.\n        depend : str\n            Use the value of this feature as the default.\n        rc : str\n            Use the value of this rcParam as the default.\n        auto : bool\n            The default value will depend on other parameters at compile time.\n        grouping : bool\n            If True, use the mapped variable to define groups.\n\n        \"\"\"\n        if depend is not None:\n            assert depend in PROPERTIES\n        if rc is not None:\n            assert rc in mpl.rcParams\n\n        self._val = val\n        self._rc = rc\n        self._depend = depend\n        self._auto = auto\n        self._grouping = grouping\n", "tokens": ["seaborn", "_marks", "base", "py", "mappable", "def", "__init__", "self", "val", "any", "none", "depend", "str", "none", "none", "rc", "str", "none", "none", "auto", "bool", "false", "grouping", "bool", "true", "property", "that", "can", "be", "mapped", "from", "data", "or", "set", "directly", "with", "flexible", "defaults", "parameters", "val", "any", "use", "this", "value", "as", "the", "default", "depend", "str", "use", "the", "value", "of", "this", "feature", "as", "the", "default", "rc", "str", "use", "the", "value", "of", "this", "rcparam", "as", "the", "default", "auto", "bool", "the", "default", "value", "will", "depend", "on", "other", "parameters", "at", "compile", "time", "grouping", "bool", "if", "true", "use", "the", "mapped", "variable", "to", "define", "groups", "if", "depend", "is", "not", "none", "assert", "depend", "in", "properties", "if", "rc", "is", "not", "none", "assert", "rc", "in", "mpl", "rcparams", "self", "_val", "val", "self", "_rc", "rc", "self", "_depend", "depend", "self", "_auto", "auto", "self", "_grouping", "grouping"], "doc_len": 127}
{"doc_id": "seaborn/_marks/base.py::Mappable.__repr__", "file_path": "seaborn/_marks/base.py", "class_name": "Mappable", "func_name": "__repr__", "text": "文件路径: seaborn/_marks/base.py, 类名: Mappable\n    def __repr__(self):\n        \"\"\"Nice formatting for when object appears in Mark init signature.\"\"\"\n        if self._val is not None:\n            s = f\"<{repr(self._val)}>\"\n        elif self._depend is not None:\n            s = f\"<depend:{self._depend}>\"\n        elif self._rc is not None:\n            s = f\"<rc:{self._rc}>\"\n        elif self._auto:\n            s = \"<auto>\"\n        else:\n            s = \"<undefined>\"\n        return s\n", "tokens": ["seaborn", "_marks", "base", "py", "mappable", "def", "__repr__", "self", "nice", "formatting", "for", "when", "object", "appears", "in", "mark", "init", "signature", "if", "self", "_val", "is", "not", "none", "s", "f", "repr", "self", "_val", "elif", "self", "_depend", "is", "not", "none", "s", "f", "depend", "self", "_depend", "elif", "self", "_rc", "is", "not", "none", "s", "f", "rc", "self", "_rc", "elif", "self", "_auto", "s", "auto", "else", "s", "undefined", "return", "s"], "doc_len": 61}
{"doc_id": "seaborn/_marks/base.py::Mappable.depend", "file_path": "seaborn/_marks/base.py", "class_name": "Mappable", "func_name": "depend", "text": "文件路径: seaborn/_marks/base.py, 类名: Mappable\n    def depend(self) -> Any:\n        \"\"\"Return the name of the feature to source a default value from.\"\"\"\n        return self._depend\n", "tokens": ["seaborn", "_marks", "base", "py", "mappable", "def", "depend", "self", "any", "return", "the", "name", "of", "the", "feature", "to", "source", "a", "default", "value", "from", "return", "self", "_depend"], "doc_len": 24}
{"doc_id": "seaborn/_marks/base.py::Mappable.grouping", "file_path": "seaborn/_marks/base.py", "class_name": "Mappable", "func_name": "grouping", "text": "文件路径: seaborn/_marks/base.py, 类名: Mappable\n    def grouping(self) -> bool:\n        return self._grouping\n", "tokens": ["seaborn", "_marks", "base", "py", "mappable", "def", "grouping", "self", "bool", "return", "self", "_grouping"], "doc_len": 12}
{"doc_id": "seaborn/_marks/base.py::Mappable.default", "file_path": "seaborn/_marks/base.py", "class_name": "Mappable", "func_name": "default", "text": "文件路径: seaborn/_marks/base.py, 类名: Mappable\n    def default(self) -> Any:\n        \"\"\"Get the default value for this feature, or access the relevant rcParam.\"\"\"\n        if self._val is not None:\n            return self._val\n        return mpl.rcParams.get(self._rc)\n", "tokens": ["seaborn", "_marks", "base", "py", "mappable", "def", "default", "self", "any", "get", "the", "default", "value", "for", "this", "feature", "or", "access", "the", "relevant", "rcparam", "if", "self", "_val", "is", "not", "none", "return", "self", "_val", "return", "mpl", "rcparams", "get", "self", "_rc"], "doc_len": 36}
{"doc_id": "seaborn/_marks/base.py::Mark._mappable_props", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_mappable_props", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _mappable_props(self):\n        return {\n            f.name: getattr(self, f.name) for f in fields(self)\n            if isinstance(f.default, Mappable)\n        }\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_mappable_props", "self", "return", "f", "name", "getattr", "self", "f", "name", "for", "f", "in", "fields", "self", "if", "isinstance", "f", "default", "mappable"], "doc_len": 25}
{"doc_id": "seaborn/_marks/base.py::Mark._grouping_props", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_grouping_props", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _grouping_props(self):\n        # TODO does it make sense to have variation within a Mark's\n        # properties about whether they are grouping?\n        return [\n            f.name for f in fields(self)\n            if isinstance(f.default, Mappable) and f.default.grouping\n        ]\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_grouping_props", "self", "todo", "does", "it", "make", "sense", "to", "have", "variation", "within", "a", "mark", "s", "properties", "about", "whether", "they", "are", "grouping", "return", "f", "name", "for", "f", "in", "fields", "self", "if", "isinstance", "f", "default", "mappable", "and", "f", "default", "grouping"], "doc_len": 43}
{"doc_id": "seaborn/_marks/base.py::Mark._resolve", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_resolve", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _resolve(\n        self,\n        data: DataFrame | dict[str, Any],\n        name: str,\n        scales: dict[str, Scale] | None = None,\n    ) -> Any:\n        \"\"\"Obtain default, specified, or mapped value for a named feature.\n\n        Parameters\n        ----------\n        data : DataFrame or dict with scalar values\n            Container with data values for features that will be semantically mapped.\n        name : string\n            Identity of the feature / semantic.\n        scales: dict\n            Mapping from variable to corresponding scale object.\n\n        Returns\n        -------\n        value or array of values\n            Outer return type depends on whether `data` is a dict (implying that\n            we want a single value) or DataFrame (implying that we want an array\n            of values with matching length).\n\n        \"\"\"\n        feature = self._mappable_props[name]\n        prop = PROPERTIES.get(name, Property(name))\n        directly_specified = not isinstance(feature, Mappable)\n        return_multiple = isinstance(data, pd.DataFrame)\n        return_array = return_multiple and not name.endswith(\"style\")\n\n        # Special case width because it needs to be resolved and added to the dataframe\n        # during layer prep (so the Move operations use it properly).\n        # TODO how does width *scaling* work, e.g. for violin width by count?\n        if name == \"width\":\n            directly_specified = directly_specified and name not in data\n\n        if directly_specified:\n            feature = prop.standardize(feature)\n            if return_multiple:\n                feature = [feature] * len(data)\n            if return_array:\n                feature = np.array(feature)\n            return feature\n\n        if name in data:\n            if scales is None or name not in scales:\n                # TODO Might this obviate the identity scale? Just don't add a scale?\n                feature = data[name]\n            else:\n                scale = scales[name]\n                value = data[name]\n                try:\n                    feature = scale(value)\n                except Exception as err:\n                    raise PlotSpecError._during(\"Scaling operation\", name) from err\n\n            if return_array:\n                feature = np.asarray(feature)\n            return feature\n\n        if feature.depend is not None:\n            # TODO add source_func or similar to transform the source value?\n            # e.g. set linewidth as a proportion of pointsize?\n            return self._resolve(data, feature.depend, scales)\n\n        default = prop.standardize(feature.default)\n        if return_multiple:\n            default = [default] * len(data)\n        if return_array:\n            default = np.array(default)\n        return default\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_resolve", "self", "data", "dataframe", "dict", "str", "any", "name", "str", "scales", "dict", "str", "scale", "none", "none", "any", "obtain", "default", "specified", "or", "mapped", "value", "for", "a", "named", "feature", "parameters", "data", "dataframe", "or", "dict", "with", "scalar", "values", "container", "with", "data", "values", "for", "features", "that", "will", "be", "semantically", "mapped", "name", "string", "identity", "of", "the", "feature", "semantic", "scales", "dict", "mapping", "from", "variable", "to", "corresponding", "scale", "object", "returns", "value", "or", "array", "of", "values", "outer", "return", "type", "depends", "on", "whether", "data", "is", "a", "dict", "implying", "that", "we", "want", "a", "single", "value", "or", "dataframe", "implying", "that", "we", "want", "an", "array", "of", "values", "with", "matching", "length", "feature", "self", "_mappable_props", "name", "prop", "properties", "get", "name", "property", "name", "directly_specified", "not", "isinstance", "feature", "mappable", "return_multiple", "isinstance", "data", "pd", "dataframe", "return_array", "return_multiple", "and", "not", "name", "endswith", "style", "special", "case", "width", "because", "it", "needs", "to", "be", "resolved", "and", "added", "to", "the", "dataframe", "during", "layer", "prep", "so", "the", "move", "operations", "use", "it", "properly", "todo", "how", "does", "width", "scaling", "work", "e", "g", "for", "violin", "width", "by", "count", "if", "name", "width", "directly_specified", "directly_specified", "and", "name", "not", "in", "data", "if", "directly_specified", "feature", "prop", "standardize", "feature", "if", "return_multiple", "feature", "feature", "len", "data", "if", "return_array", "feature", "np", "array", "feature", "return", "feature", "if", "name", "in", "data", "if", "scales", "is", "none", "or", "name", "not", "in", "scales", "todo", "might", "this", "obviate", "the", "identity", "scale", "just", "don", "t", "add", "a", "scale", "feature", "data", "name", "else", "scale", "scales", "name", "value", "data", "name", "try", "feature", "scale", "value", "except", "exception", "as", "err", "raise", "plotspecerror", "_during", "scaling", "operation", "name", "from", "err", "if", "return_array", "feature", "np", "asarray", "feature", "return", "feature", "if", "feature", "depend", "is", "not", "none", "todo", "add", "source_func", "or", "similar", "to", "transform", "the", "source", "value", "e", "g", "set", "linewidth", "as", "a", "proportion", "of", "pointsize", "return", "self", "_resolve", "data", "feature", "depend", "scales", "default", "prop", "standardize", "feature", "default", "if", "return_multiple", "default", "default", "len", "data", "if", "return_array", "default", "np", "array", "default", "return", "default"], "doc_len": 308}
{"doc_id": "seaborn/_marks/base.py::Mark._infer_orient", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_infer_orient", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _infer_orient(self, scales: dict) -> str:  # TODO type scales\n\n        # TODO The original version of this (in seaborn._oldcore) did more checking.\n        # Paring that down here for the prototype to see what restrictions make sense.\n\n        # TODO rethink this to map from scale type to \"DV priority\" and use that?\n        # e.g. Nominal > Discrete > Continuous\n\n        x = 0 if \"x\" not in scales else scales[\"x\"]._priority\n        y = 0 if \"y\" not in scales else scales[\"y\"]._priority\n\n        if y > x:\n            return \"y\"\n        else:\n            return \"x\"\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_infer_orient", "self", "scales", "dict", "str", "todo", "type", "scales", "todo", "the", "original", "version", "of", "this", "in", "seaborn", "_oldcore", "did", "more", "checking", "paring", "that", "down", "here", "for", "the", "prototype", "to", "see", "what", "restrictions", "make", "sense", "todo", "rethink", "this", "to", "map", "from", "scale", "type", "to", "dv", "priority", "and", "use", "that", "e", "g", "nominal", "discrete", "continuous", "x", "0", "if", "x", "not", "in", "scales", "else", "scales", "x", "_priority", "y", "0", "if", "y", "not", "in", "scales", "else", "scales", "y", "_priority", "if", "y", "x", "return", "y", "else", "return", "x"], "doc_len": 88}
{"doc_id": "seaborn/_marks/base.py::Mark._plot", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_plot", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _plot(\n        self,\n        split_generator: Callable[[], Generator],\n        scales: dict[str, Scale],\n        orient: str,\n    ) -> None:\n        \"\"\"Main interface for creating a plot.\"\"\"\n        raise NotImplementedError()\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_plot", "self", "split_generator", "callable", "generator", "scales", "dict", "str", "scale", "orient", "str", "none", "main", "interface", "for", "creating", "a", "plot", "raise", "notimplementederror"], "doc_len": 26}
{"doc_id": "seaborn/_marks/base.py::Mark._legend_artist", "file_path": "seaborn/_marks/base.py", "class_name": "Mark", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/base.py, 类名: Mark\n    def _legend_artist(\n        self, variables: list[str], value: Any, scales: dict[str, Scale],\n    ) -> Artist:\n\n        return None\n", "tokens": ["seaborn", "_marks", "base", "py", "mark", "def", "_legend_artist", "self", "variables", "list", "str", "value", "any", "scales", "dict", "str", "scale", "artist", "return", "none"], "doc_len": 20}
{"doc_id": "seaborn/_marks/base.py::resolve_properties", "file_path": "seaborn/_marks/base.py", "class_name": null, "func_name": "resolve_properties", "text": "文件路径: seaborn/_marks/base.py\ndef resolve_properties(\n    mark: Mark, data: DataFrame, scales: dict[str, Scale]\n) -> dict[str, Any]:\n\n    props = {\n        name: mark._resolve(data, name, scales) for name in mark._mappable_props\n    }\n    return props\n", "tokens": ["seaborn", "_marks", "base", "py", "def", "resolve_properties", "mark", "mark", "data", "dataframe", "scales", "dict", "str", "scale", "dict", "str", "any", "props", "name", "mark", "_resolve", "data", "name", "scales", "for", "name", "in", "mark", "_mappable_props", "return", "props"], "doc_len": 31}
{"doc_id": "seaborn/_marks/base.py::resolve_color", "file_path": "seaborn/_marks/base.py", "class_name": null, "func_name": "resolve_color", "text": "文件路径: seaborn/_marks/base.py\ndef resolve_color(\n    mark: Mark,\n    data: DataFrame | dict,\n    prefix: str = \"\",\n    scales: dict[str, Scale] | None = None,\n) -> RGBATuple | ndarray:\n    \"\"\"\n    Obtain a default, specified, or mapped value for a color feature.\n\n    This method exists separately to support the relationship between a\n    color and its corresponding alpha. We want to respect alpha values that\n    are passed in specified (or mapped) color values but also make use of a\n    separate `alpha` variable, which can be mapped. This approach may also\n    be extended to support mapping of specific color channels (i.e.\n    luminance, chroma) in the future.\n\n    Parameters\n    ----------\n    mark :\n        Mark with the color property.\n    data :\n        Container with data values for features that will be semantically mapped.\n    prefix :\n        Support \"color\", \"fillcolor\", etc.\n\n    \"\"\"\n    color = mark._resolve(data, f\"{prefix}color\", scales)\n\n    if f\"{prefix}alpha\" in mark._mappable_props:\n        alpha = mark._resolve(data, f\"{prefix}alpha\", scales)\n    else:\n        alpha = mark._resolve(data, \"alpha\", scales)\n\n    def visible(x, axis=None):\n        \"\"\"Detect \"invisible\" colors to set alpha appropriately.\"\"\"\n        # TODO First clause only needed to handle non-rgba arrays,\n        # which we are trying to handle upstream\n        return np.array(x).dtype.kind != \"f\" or np.isfinite(x).all(axis)\n\n    # Second check here catches vectors of strings with identity scale\n    # It could probably be handled better upstream. This is a tricky problem\n    if np.ndim(color) < 2 and all(isinstance(x, float) for x in color):\n        if len(color) == 4:\n            return mpl.colors.to_rgba(color)\n        alpha = alpha if visible(color) else np.nan\n        return mpl.colors.to_rgba(color, alpha)\n    else:\n        if np.ndim(color) == 2 and color.shape[1] == 4:\n            return mpl.colors.to_rgba_array(color)\n        alpha = np.where(visible(color, axis=1), alpha, np.nan)\n        return mpl.colors.to_rgba_array(color, alpha)\n", "tokens": ["seaborn", "_marks", "base", "py", "def", "resolve_color", "mark", "mark", "data", "dataframe", "dict", "prefix", "str", "scales", "dict", "str", "scale", "none", "none", "rgbatuple", "ndarray", "obtain", "a", "default", "specified", "or", "mapped", "value", "for", "a", "color", "feature", "this", "method", "exists", "separately", "to", "support", "the", "relationship", "between", "a", "color", "and", "its", "corresponding", "alpha", "we", "want", "to", "respect", "alpha", "values", "that", "are", "passed", "in", "specified", "or", "mapped", "color", "values", "but", "also", "make", "use", "of", "a", "separate", "alpha", "variable", "which", "can", "be", "mapped", "this", "approach", "may", "also", "be", "extended", "to", "support", "mapping", "of", "specific", "color", "channels", "i", "e", "luminance", "chroma", "in", "the", "future", "parameters", "mark", "mark", "with", "the", "color", "property", "data", "container", "with", "data", "values", "for", "features", "that", "will", "be", "semantically", "mapped", "prefix", "support", "color", "fillcolor", "etc", "color", "mark", "_resolve", "data", "f", "prefix", "color", "scales", "if", "f", "prefix", "alpha", "in", "mark", "_mappable_props", "alpha", "mark", "_resolve", "data", "f", "prefix", "alpha", "scales", "else", "alpha", "mark", "_resolve", "data", "alpha", "scales", "def", "visible", "x", "axis", "none", "detect", "invisible", "colors", "to", "set", "alpha", "appropriately", "todo", "first", "clause", "only", "needed", "to", "handle", "non", "rgba", "arrays", "which", "we", "are", "trying", "to", "handle", "upstream", "return", "np", "array", "x", "dtype", "kind", "f", "or", "np", "isfinite", "x", "all", "axis", "second", "check", "here", "catches", "vectors", "of", "strings", "with", "identity", "scale", "it", "could", "probably", "be", "handled", "better", "upstream", "this", "is", "a", "tricky", "problem", "if", "np", "ndim", "color", "2", "and", "all", "isinstance", "x", "float", "for", "x", "in", "color", "if", "len", "color", "4", "return", "mpl", "colors", "to_rgba", "color", "alpha", "alpha", "if", "visible", "color", "else", "np", "nan", "return", "mpl", "colors", "to_rgba", "color", "alpha", "else", "if", "np", "ndim", "color", "2", "and", "color", "shape", "1", "4", "return", "mpl", "colors", "to_rgba_array", "color", "alpha", "np", "where", "visible", "color", "axis", "1", "alpha", "np", "nan", "return", "mpl", "colors", "to_rgba_array", "color", "alpha"], "doc_len": 282}
{"doc_id": "seaborn/_marks/base.py::document_properties", "file_path": "seaborn/_marks/base.py", "class_name": null, "func_name": "document_properties", "text": "文件路径: seaborn/_marks/base.py\ndef document_properties(mark):\n\n    properties = [f.name for f in fields(mark) if isinstance(f.default, Mappable)]\n    text = [\n        \"\",\n        \"    This mark defines the following properties:\",\n        textwrap.fill(\n            \", \".join([f\"|{p}|\" for p in properties]),\n            width=78, initial_indent=\" \" * 8, subsequent_indent=\" \" * 8,\n        ),\n    ]\n\n    docstring_lines = mark.__doc__.split(\"\\n\")\n    new_docstring = \"\\n\".join([\n        *docstring_lines[:2],\n        *text,\n        *docstring_lines[2:],\n    ])\n    mark.__doc__ = new_docstring\n    return mark\n", "tokens": ["seaborn", "_marks", "base", "py", "def", "document_properties", "mark", "properties", "f", "name", "for", "f", "in", "fields", "mark", "if", "isinstance", "f", "default", "mappable", "text", "this", "mark", "defines", "the", "following", "properties", "textwrap", "fill", "join", "f", "p", "for", "p", "in", "properties", "width", "78", "initial_indent", "8", "subsequent_indent", "8", "docstring_lines", "mark", "__doc__", "split", "n", "new_docstring", "n", "join", "docstring_lines", "2", "text", "docstring_lines", "2", "mark", "__doc__", "new_docstring", "return", "mark"], "doc_len": 60}
{"doc_id": "seaborn/_marks/dot.py::DotBase._resolve_paths", "file_path": "seaborn/_marks/dot.py", "class_name": "DotBase", "func_name": "_resolve_paths", "text": "文件路径: seaborn/_marks/dot.py, 类名: DotBase\n    def _resolve_paths(self, data):\n\n        paths = []\n        path_cache = {}\n        marker = data[\"marker\"]\n\n        def get_transformed_path(m):\n            return m.get_path().transformed(m.get_transform())\n\n        if isinstance(marker, mpl.markers.MarkerStyle):\n            return get_transformed_path(marker)\n\n        for m in marker:\n            if m not in path_cache:\n                path_cache[m] = get_transformed_path(m)\n            paths.append(path_cache[m])\n        return paths\n", "tokens": ["seaborn", "_marks", "dot", "py", "dotbase", "def", "_resolve_paths", "self", "data", "paths", "path_cache", "marker", "data", "marker", "def", "get_transformed_path", "m", "return", "m", "get_path", "transformed", "m", "get_transform", "if", "isinstance", "marker", "mpl", "markers", "markerstyle", "return", "get_transformed_path", "marker", "for", "m", "in", "marker", "if", "m", "not", "in", "path_cache", "path_cache", "m", "get_transformed_path", "m", "paths", "append", "path_cache", "m", "return", "paths"], "doc_len": 51}
{"doc_id": "seaborn/_marks/dot.py::DotBase._resolve_properties", "file_path": "seaborn/_marks/dot.py", "class_name": "DotBase", "func_name": "_resolve_properties", "text": "文件路径: seaborn/_marks/dot.py, 类名: DotBase\n    def _resolve_properties(self, data, scales):\n\n        resolved = resolve_properties(self, data, scales)\n        resolved[\"path\"] = self._resolve_paths(resolved)\n        resolved[\"size\"] = resolved[\"pointsize\"] ** 2\n\n        if isinstance(data, dict):  # Properties for single dot\n            filled_marker = resolved[\"marker\"].is_filled()\n        else:\n            filled_marker = [m.is_filled() for m in resolved[\"marker\"]]\n\n        resolved[\"fill\"] = resolved[\"fill\"] * filled_marker\n\n        return resolved\n", "tokens": ["seaborn", "_marks", "dot", "py", "dotbase", "def", "_resolve_properties", "self", "data", "scales", "resolved", "resolve_properties", "self", "data", "scales", "resolved", "path", "self", "_resolve_paths", "resolved", "resolved", "size", "resolved", "pointsize", "2", "if", "isinstance", "data", "dict", "properties", "for", "single", "dot", "filled_marker", "resolved", "marker", "is_filled", "else", "filled_marker", "m", "is_filled", "for", "m", "in", "resolved", "marker", "resolved", "fill", "resolved", "fill", "filled_marker", "return", "resolved"], "doc_len": 53}
{"doc_id": "seaborn/_marks/dot.py::DotBase._plot", "file_path": "seaborn/_marks/dot.py", "class_name": "DotBase", "func_name": "_plot", "text": "文件路径: seaborn/_marks/dot.py, 类名: DotBase\n    def _plot(self, split_gen, scales, orient):\n\n        # TODO Not backcompat with allowed (but nonfunctional) univariate plots\n        # (That should be solved upstream by defaulting to \"\" for unset x/y?)\n        # (Be mindful of xmin/xmax, etc!)\n\n        for _, data, ax in split_gen():\n\n            offsets = np.column_stack([data[\"x\"], data[\"y\"]])\n            data = self._resolve_properties(data, scales)\n\n            points = mpl.collections.PathCollection(\n                offsets=offsets,\n                paths=data[\"path\"],\n                sizes=data[\"size\"],\n                facecolors=data[\"facecolor\"],\n                edgecolors=data[\"edgecolor\"],\n                linewidths=data[\"linewidth\"],\n                linestyles=data[\"edgestyle\"],\n                transOffset=ax.transData,\n                transform=mpl.transforms.IdentityTransform(),\n                **self.artist_kws,\n            )\n            ax.add_collection(points)\n", "tokens": ["seaborn", "_marks", "dot", "py", "dotbase", "def", "_plot", "self", "split_gen", "scales", "orient", "todo", "not", "backcompat", "with", "allowed", "but", "nonfunctional", "univariate", "plots", "that", "should", "be", "solved", "upstream", "by", "defaulting", "to", "for", "unset", "x", "y", "be", "mindful", "of", "xmin", "xmax", "etc", "for", "_", "data", "ax", "in", "split_gen", "offsets", "np", "column_stack", "data", "x", "data", "y", "data", "self", "_resolve_properties", "data", "scales", "points", "mpl", "collections", "pathcollection", "offsets", "offsets", "paths", "data", "path", "sizes", "data", "size", "facecolors", "data", "facecolor", "edgecolors", "data", "edgecolor", "linewidths", "data", "linewidth", "linestyles", "data", "edgestyle", "transoffset", "ax", "transdata", "transform", "mpl", "transforms", "identitytransform", "self", "artist_kws", "ax", "add_collection", "points"], "doc_len": 92}
{"doc_id": "seaborn/_marks/dot.py::DotBase._legend_artist", "file_path": "seaborn/_marks/dot.py", "class_name": "DotBase", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/dot.py, 类名: DotBase\n    def _legend_artist(\n        self, variables: list[str], value: Any, scales: dict[str, Scale],\n    ) -> Artist:\n\n        key = {v: value for v in variables}\n        res = self._resolve_properties(key, scales)\n\n        return mpl.collections.PathCollection(\n            paths=[res[\"path\"]],\n            sizes=[res[\"size\"]],\n            facecolors=[res[\"facecolor\"]],\n            edgecolors=[res[\"edgecolor\"]],\n            linewidths=[res[\"linewidth\"]],\n            linestyles=[res[\"edgestyle\"]],\n            transform=mpl.transforms.IdentityTransform(),\n            **self.artist_kws,\n        )\n", "tokens": ["seaborn", "_marks", "dot", "py", "dotbase", "def", "_legend_artist", "self", "variables", "list", "str", "value", "any", "scales", "dict", "str", "scale", "artist", "key", "v", "value", "for", "v", "in", "variables", "res", "self", "_resolve_properties", "key", "scales", "return", "mpl", "collections", "pathcollection", "paths", "res", "path", "sizes", "res", "size", "facecolors", "res", "facecolor", "edgecolors", "res", "edgecolor", "linewidths", "res", "linewidth", "linestyles", "res", "edgestyle", "transform", "mpl", "transforms", "identitytransform", "self", "artist_kws"], "doc_len": 58}
{"doc_id": "seaborn/_marks/dot.py::Dot._resolve_properties", "file_path": "seaborn/_marks/dot.py", "class_name": "Dot", "func_name": "_resolve_properties", "text": "文件路径: seaborn/_marks/dot.py, 类名: Dot\n    def _resolve_properties(self, data, scales):\n\n        resolved = super()._resolve_properties(data, scales)\n        filled = resolved[\"fill\"]\n\n        main_stroke = resolved[\"stroke\"]\n        edge_stroke = resolved[\"edgewidth\"]\n        resolved[\"linewidth\"] = np.where(filled, edge_stroke, main_stroke)\n\n        main_color = resolve_color(self, data, \"\", scales)\n        edge_color = resolve_color(self, data, \"edge\", scales)\n\n        if not np.isscalar(filled):\n            # Expand dims to use in np.where with rgba arrays\n            filled = filled[:, None]\n        resolved[\"edgecolor\"] = np.where(filled, edge_color, main_color)\n\n        filled = np.squeeze(filled)\n        if isinstance(main_color, tuple):\n            # TODO handle this in resolve_color\n            main_color = tuple([*main_color[:3], main_color[3] * filled])\n        else:\n            main_color = np.c_[main_color[:, :3], main_color[:, 3] * filled]\n        resolved[\"facecolor\"] = main_color\n\n        return resolved\n", "tokens": ["seaborn", "_marks", "dot", "py", "dot", "def", "_resolve_properties", "self", "data", "scales", "resolved", "super", "_resolve_properties", "data", "scales", "filled", "resolved", "fill", "main_stroke", "resolved", "stroke", "edge_stroke", "resolved", "edgewidth", "resolved", "linewidth", "np", "where", "filled", "edge_stroke", "main_stroke", "main_color", "resolve_color", "self", "data", "scales", "edge_color", "resolve_color", "self", "data", "edge", "scales", "if", "not", "np", "isscalar", "filled", "expand", "dims", "to", "use", "in", "np", "where", "with", "rgba", "arrays", "filled", "filled", "none", "resolved", "edgecolor", "np", "where", "filled", "edge_color", "main_color", "filled", "np", "squeeze", "filled", "if", "isinstance", "main_color", "tuple", "todo", "handle", "this", "in", "resolve_color", "main_color", "tuple", "main_color", "3", "main_color", "3", "filled", "else", "main_color", "np", "c_", "main_color", "3", "main_color", "3", "filled", "resolved", "facecolor", "main_color", "return", "resolved"], "doc_len": 101}
{"doc_id": "seaborn/_marks/dot.py::Dots._resolve_properties", "file_path": "seaborn/_marks/dot.py", "class_name": "Dots", "func_name": "_resolve_properties", "text": "文件路径: seaborn/_marks/dot.py, 类名: Dots\n    def _resolve_properties(self, data, scales):\n\n        resolved = super()._resolve_properties(data, scales)\n        resolved[\"linewidth\"] = resolved.pop(\"stroke\")\n        resolved[\"facecolor\"] = resolve_color(self, data, \"fill\", scales)\n        resolved[\"edgecolor\"] = resolve_color(self, data, \"\", scales)\n        resolved.setdefault(\"edgestyle\", (0, None))\n\n        fc = resolved[\"facecolor\"]\n        if isinstance(fc, tuple):\n            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]\n        else:\n            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?\n            resolved[\"facecolor\"] = fc\n\n        return resolved\n", "tokens": ["seaborn", "_marks", "dot", "py", "dots", "def", "_resolve_properties", "self", "data", "scales", "resolved", "super", "_resolve_properties", "data", "scales", "resolved", "linewidth", "resolved", "pop", "stroke", "resolved", "facecolor", "resolve_color", "self", "data", "fill", "scales", "resolved", "edgecolor", "resolve_color", "self", "data", "scales", "resolved", "setdefault", "edgestyle", "0", "none", "fc", "resolved", "facecolor", "if", "isinstance", "fc", "tuple", "resolved", "facecolor", "fc", "0", "fc", "1", "fc", "2", "fc", "3", "resolved", "fill", "else", "fc", "3", "fc", "3", "resolved", "fill", "todo", "is", "inplace", "mod", "a", "problem", "resolved", "facecolor", "fc", "return", "resolved"], "doc_len": 75}
{"doc_id": "seaborn/_marks/line.py::Path._plot", "file_path": "seaborn/_marks/line.py", "class_name": "Path", "func_name": "_plot", "text": "文件路径: seaborn/_marks/line.py, 类名: Path\n    def _plot(self, split_gen, scales, orient):\n\n        for keys, data, ax in split_gen(keep_na=not self._sort):\n\n            vals = resolve_properties(self, keys, scales)\n            vals[\"color\"] = resolve_color(self, keys, scales=scales)\n            vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)\n            vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)\n\n            # https://github.com/matplotlib/matplotlib/pull/16692\n            if Version(mpl.__version__) < Version(\"3.3.0\"):\n                vals[\"marker\"] = vals[\"marker\"]._marker\n\n            if self._sort:\n                data = data.sort_values(orient, kind=\"mergesort\")\n\n            artist_kws = self.artist_kws.copy()\n            self._handle_capstyle(artist_kws, vals)\n\n            line = mpl.lines.Line2D(\n                data[\"x\"].to_numpy(),\n                data[\"y\"].to_numpy(),\n                color=vals[\"color\"],\n                linewidth=vals[\"linewidth\"],\n                linestyle=vals[\"linestyle\"],\n                marker=vals[\"marker\"],\n                markersize=vals[\"pointsize\"],\n                markerfacecolor=vals[\"fillcolor\"],\n                markeredgecolor=vals[\"edgecolor\"],\n                markeredgewidth=vals[\"edgewidth\"],\n                **artist_kws,\n            )\n            ax.add_line(line)\n", "tokens": ["seaborn", "_marks", "line", "py", "path", "def", "_plot", "self", "split_gen", "scales", "orient", "for", "keys", "data", "ax", "in", "split_gen", "keep_na", "not", "self", "_sort", "vals", "resolve_properties", "self", "keys", "scales", "vals", "color", "resolve_color", "self", "keys", "scales", "scales", "vals", "fillcolor", "resolve_color", "self", "keys", "prefix", "fill", "scales", "scales", "vals", "edgecolor", "resolve_color", "self", "keys", "prefix", "edge", "scales", "scales", "https", "github", "com", "matplotlib", "matplotlib", "pull", "16692", "if", "version", "mpl", "__version__", "version", "3", "3", "0", "vals", "marker", "vals", "marker", "_marker", "if", "self", "_sort", "data", "data", "sort_values", "orient", "kind", "mergesort", "artist_kws", "self", "artist_kws", "copy", "self", "_handle_capstyle", "artist_kws", "vals", "line", "mpl", "lines", "line2d", "data", "x", "to_numpy", "data", "y", "to_numpy", "color", "vals", "color", "linewidth", "vals", "linewidth", "linestyle", "vals", "linestyle", "marker", "vals", "marker", "markersize", "vals", "pointsize", "markerfacecolor", "vals", "fillcolor", "markeredgecolor", "vals", "edgecolor", "markeredgewidth", "vals", "edgewidth", "artist_kws", "ax", "add_line", "line"], "doc_len": 126}
{"doc_id": "seaborn/_marks/line.py::Path._legend_artist", "file_path": "seaborn/_marks/line.py", "class_name": "Path", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/line.py, 类名: Path\n    def _legend_artist(self, variables, value, scales):\n\n        keys = {v: value for v in variables}\n        vals = resolve_properties(self, keys, scales)\n        vals[\"color\"] = resolve_color(self, keys, scales=scales)\n        vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)\n        vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)\n\n        # https://github.com/matplotlib/matplotlib/pull/16692\n        if Version(mpl.__version__) < Version(\"3.3.0\"):\n            vals[\"marker\"] = vals[\"marker\"]._marker\n\n        artist_kws = self.artist_kws.copy()\n        self._handle_capstyle(artist_kws, vals)\n\n        return mpl.lines.Line2D(\n            [], [],\n            color=vals[\"color\"],\n            linewidth=vals[\"linewidth\"],\n            linestyle=vals[\"linestyle\"],\n            marker=vals[\"marker\"],\n            markersize=vals[\"pointsize\"],\n            markerfacecolor=vals[\"fillcolor\"],\n            markeredgecolor=vals[\"edgecolor\"],\n            markeredgewidth=vals[\"edgewidth\"],\n            **artist_kws,\n        )\n", "tokens": ["seaborn", "_marks", "line", "py", "path", "def", "_legend_artist", "self", "variables", "value", "scales", "keys", "v", "value", "for", "v", "in", "variables", "vals", "resolve_properties", "self", "keys", "scales", "vals", "color", "resolve_color", "self", "keys", "scales", "scales", "vals", "fillcolor", "resolve_color", "self", "keys", "prefix", "fill", "scales", "scales", "vals", "edgecolor", "resolve_color", "self", "keys", "prefix", "edge", "scales", "scales", "https", "github", "com", "matplotlib", "matplotlib", "pull", "16692", "if", "version", "mpl", "__version__", "version", "3", "3", "0", "vals", "marker", "vals", "marker", "_marker", "artist_kws", "self", "artist_kws", "copy", "self", "_handle_capstyle", "artist_kws", "vals", "return", "mpl", "lines", "line2d", "color", "vals", "color", "linewidth", "vals", "linewidth", "linestyle", "vals", "linestyle", "marker", "vals", "marker", "markersize", "vals", "pointsize", "markerfacecolor", "vals", "fillcolor", "markeredgecolor", "vals", "edgecolor", "markeredgewidth", "vals", "edgewidth", "artist_kws"], "doc_len": 105}
{"doc_id": "seaborn/_marks/line.py::Path._handle_capstyle", "file_path": "seaborn/_marks/line.py", "class_name": "Path", "func_name": "_handle_capstyle", "text": "文件路径: seaborn/_marks/line.py, 类名: Path\n    def _handle_capstyle(self, kws, vals):\n\n        # Work around for this matplotlib issue:\n        # https://github.com/matplotlib/matplotlib/issues/23437\n        if vals[\"linestyle\"][1] is None:\n            capstyle = kws.get(\"solid_capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])\n            kws[\"dash_capstyle\"] = capstyle\n", "tokens": ["seaborn", "_marks", "line", "py", "path", "def", "_handle_capstyle", "self", "kws", "vals", "work", "around", "for", "this", "matplotlib", "issue", "https", "github", "com", "matplotlib", "matplotlib", "issues", "23437", "if", "vals", "linestyle", "1", "is", "none", "capstyle", "kws", "get", "solid_capstyle", "mpl", "rcparams", "lines", "solid_capstyle", "kws", "dash_capstyle", "capstyle"], "doc_len": 40}
{"doc_id": "seaborn/_marks/line.py::Paths.__post_init__", "file_path": "seaborn/_marks/line.py", "class_name": "Paths", "func_name": "__post_init__", "text": "文件路径: seaborn/_marks/line.py, 类名: Paths\n    def __post_init__(self):\n\n        # LineCollection artists have a capstyle property but don't source its value\n        # from the rc, so we do that manually here. Unfortunately, because we add\n        # only one LineCollection, we have the use the same capstyle for all lines\n        # even when they are dashed. It's a slight inconsistency, but looks fine IMO.\n        self.artist_kws.setdefault(\"capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])\n", "tokens": ["seaborn", "_marks", "line", "py", "paths", "def", "__post_init__", "self", "linecollection", "artists", "have", "a", "capstyle", "property", "but", "don", "t", "source", "its", "value", "from", "the", "rc", "so", "we", "do", "that", "manually", "here", "unfortunately", "because", "we", "add", "only", "one", "linecollection", "we", "have", "the", "use", "the", "same", "capstyle", "for", "all", "lines", "even", "when", "they", "are", "dashed", "it", "s", "a", "slight", "inconsistency", "but", "looks", "fine", "imo", "self", "artist_kws", "setdefault", "capstyle", "mpl", "rcparams", "lines", "solid_capstyle"], "doc_len": 68}
{"doc_id": "seaborn/_marks/line.py::Paths._plot", "file_path": "seaborn/_marks/line.py", "class_name": "Paths", "func_name": "_plot", "text": "文件路径: seaborn/_marks/line.py, 类名: Paths\n    def _plot(self, split_gen, scales, orient):\n\n        line_data = {}\n        for keys, data, ax in split_gen(keep_na=not self._sort):\n\n            if ax not in line_data:\n                line_data[ax] = {\n                    \"segments\": [],\n                    \"colors\": [],\n                    \"linewidths\": [],\n                    \"linestyles\": [],\n                }\n\n            segments = self._setup_segments(data, orient)\n            line_data[ax][\"segments\"].extend(segments)\n            n = len(segments)\n\n            vals = resolve_properties(self, keys, scales)\n            vals[\"color\"] = resolve_color(self, keys, scales=scales)\n\n            line_data[ax][\"colors\"].extend([vals[\"color\"]] * n)\n            line_data[ax][\"linewidths\"].extend([vals[\"linewidth\"]] * n)\n            line_data[ax][\"linestyles\"].extend([vals[\"linestyle\"]] * n)\n\n        for ax, ax_data in line_data.items():\n            lines = mpl.collections.LineCollection(**ax_data, **self.artist_kws)\n            # Handle datalim update manually\n            # https://github.com/matplotlib/matplotlib/issues/23129\n            ax.add_collection(lines, autolim=False)\n            if ax_data[\"segments\"]:\n                xy = np.concatenate(ax_data[\"segments\"])\n                ax.update_datalim(xy)\n", "tokens": ["seaborn", "_marks", "line", "py", "paths", "def", "_plot", "self", "split_gen", "scales", "orient", "line_data", "for", "keys", "data", "ax", "in", "split_gen", "keep_na", "not", "self", "_sort", "if", "ax", "not", "in", "line_data", "line_data", "ax", "segments", "colors", "linewidths", "linestyles", "segments", "self", "_setup_segments", "data", "orient", "line_data", "ax", "segments", "extend", "segments", "n", "len", "segments", "vals", "resolve_properties", "self", "keys", "scales", "vals", "color", "resolve_color", "self", "keys", "scales", "scales", "line_data", "ax", "colors", "extend", "vals", "color", "n", "line_data", "ax", "linewidths", "extend", "vals", "linewidth", "n", "line_data", "ax", "linestyles", "extend", "vals", "linestyle", "n", "for", "ax", "ax_data", "in", "line_data", "items", "lines", "mpl", "collections", "linecollection", "ax_data", "self", "artist_kws", "handle", "datalim", "update", "manually", "https", "github", "com", "matplotlib", "matplotlib", "issues", "23129", "ax", "add_collection", "lines", "autolim", "false", "if", "ax_data", "segments", "xy", "np", "concatenate", "ax_data", "segments", "ax", "update_datalim", "xy"], "doc_len": 119}
{"doc_id": "seaborn/_marks/line.py::Paths._legend_artist", "file_path": "seaborn/_marks/line.py", "class_name": "Paths", "func_name": "_legend_artist", "text": "文件路径: seaborn/_marks/line.py, 类名: Paths\n    def _legend_artist(self, variables, value, scales):\n\n        key = resolve_properties(self, {v: value for v in variables}, scales)\n\n        artist_kws = self.artist_kws.copy()\n        capstyle = artist_kws.pop(\"capstyle\")\n        artist_kws[\"solid_capstyle\"] = capstyle\n        artist_kws[\"dash_capstyle\"] = capstyle\n\n        return mpl.lines.Line2D(\n            [], [],\n            color=key[\"color\"],\n            linewidth=key[\"linewidth\"],\n            linestyle=key[\"linestyle\"],\n            **artist_kws,\n        )\n", "tokens": ["seaborn", "_marks", "line", "py", "paths", "def", "_legend_artist", "self", "variables", "value", "scales", "key", "resolve_properties", "self", "v", "value", "for", "v", "in", "variables", "scales", "artist_kws", "self", "artist_kws", "copy", "capstyle", "artist_kws", "pop", "capstyle", "artist_kws", "solid_capstyle", "capstyle", "artist_kws", "dash_capstyle", "capstyle", "return", "mpl", "lines", "line2d", "color", "key", "color", "linewidth", "key", "linewidth", "linestyle", "key", "linestyle", "artist_kws"], "doc_len": 49}
{"doc_id": "seaborn/_marks/line.py::Paths._setup_segments", "file_path": "seaborn/_marks/line.py", "class_name": "Paths", "func_name": "_setup_segments", "text": "文件路径: seaborn/_marks/line.py, 类名: Paths\n    def _setup_segments(self, data, orient):\n\n        if self._sort:\n            data = data.sort_values(orient, kind=\"mergesort\")\n\n        # Column stack to avoid block consolidation\n        xy = np.column_stack([data[\"x\"], data[\"y\"]])\n\n        return [xy]\n", "tokens": ["seaborn", "_marks", "line", "py", "paths", "def", "_setup_segments", "self", "data", "orient", "if", "self", "_sort", "data", "data", "sort_values", "orient", "kind", "mergesort", "column", "stack", "to", "avoid", "block", "consolidation", "xy", "np", "column_stack", "data", "x", "data", "y", "return", "xy"], "doc_len": 34}
{"doc_id": "seaborn/_marks/line.py::Range._setup_segments", "file_path": "seaborn/_marks/line.py", "class_name": "Range", "func_name": "_setup_segments", "text": "文件路径: seaborn/_marks/line.py, 类名: Range\n    def _setup_segments(self, data, orient):\n\n        # TODO better checks on what variables we have\n        # TODO what if only one exist?\n        val = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        if not set(data.columns) & {f\"{val}min\", f\"{val}max\"}:\n            agg = {f\"{val}min\": (val, \"min\"), f\"{val}max\": (val, \"max\")}\n            data = data.groupby(orient).agg(**agg).reset_index()\n\n        cols = [orient, f\"{val}min\", f\"{val}max\"]\n        data = data[cols].melt(orient, value_name=val)[[\"x\", \"y\"]]\n        segments = [d.to_numpy() for _, d in data.groupby(orient)]\n        return segments\n", "tokens": ["seaborn", "_marks", "line", "py", "range", "def", "_setup_segments", "self", "data", "orient", "todo", "better", "checks", "on", "what", "variables", "we", "have", "todo", "what", "if", "only", "one", "exist", "val", "x", "y", "y", "x", "orient", "if", "not", "set", "data", "columns", "f", "val", "min", "f", "val", "max", "agg", "f", "val", "min", "val", "min", "f", "val", "max", "val", "max", "data", "data", "groupby", "orient", "agg", "agg", "reset_index", "cols", "orient", "f", "val", "min", "f", "val", "max", "data", "data", "cols", "melt", "orient", "value_name", "val", "x", "y", "segments", "d", "to_numpy", "for", "_", "d", "in", "data", "groupby", "orient", "return", "segments"], "doc_len": 88}
{"doc_id": "seaborn/_marks/line.py::Dash._setup_segments", "file_path": "seaborn/_marks/line.py", "class_name": "Dash", "func_name": "_setup_segments", "text": "文件路径: seaborn/_marks/line.py, 类名: Dash\n    def _setup_segments(self, data, orient):\n\n        ori = [\"x\", \"y\"].index(orient)\n        xys = data[[\"x\", \"y\"]].to_numpy().astype(float)\n        segments = np.stack([xys, xys], axis=1)\n        segments[:, 0, ori] -= data[\"width\"] / 2\n        segments[:, 1, ori] += data[\"width\"] / 2\n        return segments\n", "tokens": ["seaborn", "_marks", "line", "py", "dash", "def", "_setup_segments", "self", "data", "orient", "ori", "x", "y", "index", "orient", "xys", "data", "x", "y", "to_numpy", "astype", "float", "segments", "np", "stack", "xys", "xys", "axis", "1", "segments", "0", "ori", "data", "width", "2", "segments", "1", "ori", "data", "width", "2", "return", "segments"], "doc_len": 43}
{"doc_id": "seaborn/_marks/text.py::Text._plot", "file_path": "seaborn/_marks/text.py", "class_name": "Text", "func_name": "_plot", "text": "文件路径: seaborn/_marks/text.py, 类名: Text\n    def _plot(self, split_gen, scales, orient):\n\n        ax_data = defaultdict(list)\n\n        for keys, data, ax in split_gen():\n\n            vals = resolve_properties(self, keys, scales)\n            color = resolve_color(self, keys, \"\", scales)\n\n            halign = vals[\"halign\"]\n            valign = vals[\"valign\"]\n            fontsize = vals[\"fontsize\"]\n            offset = vals[\"offset\"] / 72\n\n            offset_trans = ScaledTranslation(\n                {\"right\": -offset, \"left\": +offset}.get(halign, 0),\n                {\"top\": -offset, \"bottom\": +offset, \"baseline\": +offset}.get(valign, 0),\n                ax.figure.dpi_scale_trans,\n            )\n\n            for row in data.to_dict(\"records\"):\n                artist = mpl.text.Text(\n                    x=row[\"x\"],\n                    y=row[\"y\"],\n                    text=str(row.get(\"text\", vals[\"text\"])),\n                    color=color,\n                    fontsize=fontsize,\n                    horizontalalignment=halign,\n                    verticalalignment=valign,\n                    transform=ax.transData + offset_trans,\n                    **self.artist_kws,\n                )\n                ax.add_artist(artist)\n                ax_data[ax].append([row[\"x\"], row[\"y\"]])\n\n        for ax, ax_vals in ax_data.items():\n            ax.update_datalim(np.array(ax_vals))\n", "tokens": ["seaborn", "_marks", "text", "py", "text", "def", "_plot", "self", "split_gen", "scales", "orient", "ax_data", "defaultdict", "list", "for", "keys", "data", "ax", "in", "split_gen", "vals", "resolve_properties", "self", "keys", "scales", "color", "resolve_color", "self", "keys", "scales", "halign", "vals", "halign", "valign", "vals", "valign", "fontsize", "vals", "fontsize", "offset", "vals", "offset", "72", "offset_trans", "scaledtranslation", "right", "offset", "left", "offset", "get", "halign", "0", "top", "offset", "bottom", "offset", "baseline", "offset", "get", "valign", "0", "ax", "figure", "dpi_scale_trans", "for", "row", "in", "data", "to_dict", "records", "artist", "mpl", "text", "text", "x", "row", "x", "y", "row", "y", "text", "str", "row", "get", "text", "vals", "text", "color", "color", "fontsize", "fontsize", "horizontalalignment", "halign", "verticalalignment", "valign", "transform", "ax", "transdata", "offset_trans", "self", "artist_kws", "ax", "add_artist", "artist", "ax_data", "ax", "append", "row", "x", "row", "y", "for", "ax", "ax_vals", "in", "ax_data", "items", "ax", "update_datalim", "np", "array", "ax_vals"], "doc_len": 122}
{"doc_id": "seaborn/_stats/aggregation.py::Agg.__call__", "file_path": "seaborn/_stats/aggregation.py", "class_name": "Agg", "func_name": "__call__", "text": "文件路径: seaborn/_stats/aggregation.py, 类名: Agg\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        var = {\"x\": \"y\", \"y\": \"x\"}.get(orient)\n        res = (\n            groupby\n            .agg(data, {var: self.func})\n            .dropna(subset=[var])\n            .reset_index(drop=True)\n        )\n        return res\n", "tokens": ["seaborn", "_stats", "aggregation", "py", "agg", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "var", "x", "y", "y", "x", "get", "orient", "res", "groupby", "agg", "data", "var", "self", "func", "dropna", "subset", "var", "reset_index", "drop", "true", "return", "res"], "doc_len": 41}
{"doc_id": "seaborn/_stats/aggregation.py::Est._process", "file_path": "seaborn/_stats/aggregation.py", "class_name": "Est", "func_name": "_process", "text": "文件路径: seaborn/_stats/aggregation.py, 类名: Est\n    def _process(\n        self, data: DataFrame, var: str, estimator: EstimateAggregator\n    ) -> DataFrame:\n        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame\n        # which we could probably make more general to allow Series return\n        res = estimator(data, var)\n        return pd.DataFrame([res])\n", "tokens": ["seaborn", "_stats", "aggregation", "py", "est", "def", "_process", "self", "data", "dataframe", "var", "str", "estimator", "estimateaggregator", "dataframe", "needed", "because", "groupby", "apply", "assumes", "func", "is", "dataframe", "dataframe", "which", "we", "could", "probably", "make", "more", "general", "to", "allow", "series", "return", "res", "estimator", "data", "var", "return", "pd", "dataframe", "res"], "doc_len": 43}
{"doc_id": "seaborn/_stats/aggregation.py::Est.__call__", "file_path": "seaborn/_stats/aggregation.py", "class_name": "Est", "func_name": "__call__", "text": "文件路径: seaborn/_stats/aggregation.py, 类名: Est\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}\n        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)\n\n        var = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        res = (\n            groupby\n            .apply(data, self._process, var, engine)\n            .dropna(subset=[var])\n            .reset_index(drop=True)\n        )\n\n        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})\n\n        return res\n", "tokens": ["seaborn", "_stats", "aggregation", "py", "est", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "boot_kws", "n_boot", "self", "n_boot", "seed", "self", "seed", "engine", "estimateaggregator", "self", "func", "self", "errorbar", "boot_kws", "var", "x", "y", "y", "x", "orient", "res", "groupby", "apply", "data", "self", "_process", "var", "engine", "dropna", "subset", "var", "reset_index", "drop", "true", "res", "res", "fillna", "f", "var", "min", "res", "var", "f", "var", "max", "res", "var", "return", "res"], "doc_len": 68}
{"doc_id": "seaborn/_stats/aggregation.py::Rolling.__call__", "file_path": "seaborn/_stats/aggregation.py", "class_name": "Rolling", "func_name": "__call__", "text": "文件路径: seaborn/_stats/aggregation.py, 类名: Rolling\n    def __call__(self, data, groupby, orient, scales):\n        ...\n", "tokens": ["seaborn", "_stats", "aggregation", "py", "rolling", "def", "__call__", "self", "data", "groupby", "orient", "scales"], "doc_len": 12}
{"doc_id": "seaborn/_stats/base.py::Stat._check_param_one_of", "file_path": "seaborn/_stats/base.py", "class_name": "Stat", "func_name": "_check_param_one_of", "text": "文件路径: seaborn/_stats/base.py, 类名: Stat\n    def _check_param_one_of(self, param: str, options: Iterable[Any]) -> None:\n        \"\"\"Raise when parameter value is not one of a specified set.\"\"\"\n        value = getattr(self, param)\n        if value not in options:\n            *most, last = options\n            option_str = \", \".join(f\"{x!r}\" for x in most[:-1]) + f\" or {last!r}\"\n            err = \" \".join([\n                f\"The `{param}` parameter for `{self.__class__.__name__}` must be\",\n                f\"one of {option_str}; not {value!r}.\",\n            ])\n            raise ValueError(err)\n", "tokens": ["seaborn", "_stats", "base", "py", "stat", "def", "_check_param_one_of", "self", "param", "str", "options", "iterable", "any", "none", "raise", "when", "parameter", "value", "is", "not", "one", "of", "a", "specified", "set", "value", "getattr", "self", "param", "if", "value", "not", "in", "options", "most", "last", "options", "option_str", "join", "f", "x", "r", "for", "x", "in", "most", "1", "f", "or", "last", "r", "err", "join", "f", "the", "param", "parameter", "for", "self", "__class__", "__name__", "must", "be", "f", "one", "of", "option_str", "not", "value", "r", "raise", "valueerror", "err"], "doc_len": 73}
{"doc_id": "seaborn/_stats/base.py::Stat._check_grouping_vars", "file_path": "seaborn/_stats/base.py", "class_name": "Stat", "func_name": "_check_grouping_vars", "text": "文件路径: seaborn/_stats/base.py, 类名: Stat\n    def _check_grouping_vars(\n        self, param: str, data_vars: list[str], stacklevel: int = 2,\n    ) -> None:\n        \"\"\"Warn if vars are named in parameter without being present in the data.\"\"\"\n        param_vars = getattr(self, param)\n        undefined = set(param_vars) - set(data_vars)\n        if undefined:\n            param = f\"{self.__class__.__name__}.{param}\"\n            names = \", \".join(f\"{x!r}\" for x in undefined)\n            msg = f\"Undefined variable(s) passed for {param}: {names}.\"\n            warnings.warn(msg, stacklevel=stacklevel)\n", "tokens": ["seaborn", "_stats", "base", "py", "stat", "def", "_check_grouping_vars", "self", "param", "str", "data_vars", "list", "str", "stacklevel", "int", "2", "none", "warn", "if", "vars", "are", "named", "in", "parameter", "without", "being", "present", "in", "the", "data", "param_vars", "getattr", "self", "param", "undefined", "set", "param_vars", "set", "data_vars", "if", "undefined", "param", "f", "self", "__class__", "__name__", "param", "names", "join", "f", "x", "r", "for", "x", "in", "undefined", "msg", "f", "undefined", "variable", "s", "passed", "for", "param", "names", "warnings", "warn", "msg", "stacklevel", "stacklevel"], "doc_len": 70}
{"doc_id": "seaborn/_stats/base.py::Stat.__call__", "file_path": "seaborn/_stats/base.py", "class_name": "Stat", "func_name": "__call__", "text": "文件路径: seaborn/_stats/base.py, 类名: Stat\n    def __call__(\n        self,\n        data: DataFrame,\n        groupby: GroupBy,\n        orient: str,\n        scales: dict[str, Scale],\n    ) -> DataFrame:\n        \"\"\"Apply statistical transform to data subgroups and return combined result.\"\"\"\n        return data\n", "tokens": ["seaborn", "_stats", "base", "py", "stat", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "apply", "statistical", "transform", "to", "data", "subgroups", "and", "return", "combined", "result", "return", "data"], "doc_len": 31}
{"doc_id": "seaborn/_stats/counting.py::Count.__call__", "file_path": "seaborn/_stats/counting.py", "class_name": "Count", "func_name": "__call__", "text": "文件路径: seaborn/_stats/counting.py, 类名: Count\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        var = {\"x\": \"y\", \"y\": \"x\"}.get(orient)\n        data[var] = data[orient]\n        res = (\n            groupby\n            .agg(data, {var: len})\n            .dropna(subset=[\"x\", \"y\"])\n            .reset_index(drop=True)\n        )\n        return res\n", "tokens": ["seaborn", "_stats", "counting", "py", "count", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "var", "x", "y", "y", "x", "get", "orient", "data", "var", "data", "orient", "res", "groupby", "agg", "data", "var", "len", "dropna", "subset", "x", "y", "reset_index", "drop", "true", "return", "res"], "doc_len": 45}
{"doc_id": "seaborn/_stats/counting.py::Hist.__post_init__", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "__post_init__", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def __post_init__(self):\n\n        stat_options = [\n            \"count\", \"density\", \"percent\", \"probability\", \"proportion\", \"frequency\"\n        ]\n        self._check_param_one_of(\"stat\", stat_options)\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "__post_init__", "self", "stat_options", "count", "density", "percent", "probability", "proportion", "frequency", "self", "_check_param_one_of", "stat", "stat_options"], "doc_len": 19}
{"doc_id": "seaborn/_stats/counting.py::Hist._define_bin_edges", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "_define_bin_edges", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange, discrete):\n        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"\n        vals = vals.dropna()\n\n        if binrange is None:\n            start, stop = vals.min(), vals.max()\n        else:\n            start, stop = binrange\n\n        if discrete:\n            bin_edges = np.arange(start - .5, stop + 1.5)\n        elif binwidth is not None:\n            step = binwidth\n            bin_edges = np.arange(start, stop + step, step)\n        else:\n            bin_edges = np.histogram_bin_edges(vals, bins, binrange, weight)\n\n        # TODO warning or cap on too many bins?\n\n        return bin_edges\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "_define_bin_edges", "self", "vals", "weight", "bins", "binwidth", "binrange", "discrete", "inner", "function", "that", "takes", "bin", "parameters", "as", "arguments", "vals", "vals", "dropna", "if", "binrange", "is", "none", "start", "stop", "vals", "min", "vals", "max", "else", "start", "stop", "binrange", "if", "discrete", "bin_edges", "np", "arange", "start", "5", "stop", "1", "5", "elif", "binwidth", "is", "not", "none", "step", "binwidth", "bin_edges", "np", "arange", "start", "stop", "step", "step", "else", "bin_edges", "np", "histogram_bin_edges", "vals", "bins", "binrange", "weight", "todo", "warning", "or", "cap", "on", "too", "many", "bins", "return", "bin_edges"], "doc_len": 81}
{"doc_id": "seaborn/_stats/counting.py::Hist._define_bin_params", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "_define_bin_params", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def _define_bin_params(self, data, orient, scale_type):\n        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"\n        vals = data[orient]\n        weights = data.get(\"weight\", None)\n\n        # TODO We'll want this for ordinal / discrete scales too\n        # (Do we need discrete as a parameter or just infer from scale?)\n        discrete = self.discrete or scale_type == \"nominal\"\n\n        bin_edges = self._define_bin_edges(\n            vals, weights, self.bins, self.binwidth, self.binrange, discrete,\n        )\n\n        if isinstance(self.bins, (str, int)):\n            n_bins = len(bin_edges) - 1\n            bin_range = bin_edges.min(), bin_edges.max()\n            bin_kws = dict(bins=n_bins, range=bin_range)\n        else:\n            bin_kws = dict(bins=bin_edges)\n\n        return bin_kws\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "_define_bin_params", "self", "data", "orient", "scale_type", "given", "data", "return", "numpy", "histogram", "parameters", "to", "define", "bins", "vals", "data", "orient", "weights", "data", "get", "weight", "none", "todo", "we", "ll", "want", "this", "for", "ordinal", "discrete", "scales", "too", "do", "we", "need", "discrete", "as", "a", "parameter", "or", "just", "infer", "from", "scale", "discrete", "self", "discrete", "or", "scale_type", "nominal", "bin_edges", "self", "_define_bin_edges", "vals", "weights", "self", "bins", "self", "binwidth", "self", "binrange", "discrete", "if", "isinstance", "self", "bins", "str", "int", "n_bins", "len", "bin_edges", "1", "bin_range", "bin_edges", "min", "bin_edges", "max", "bin_kws", "dict", "bins", "n_bins", "range", "bin_range", "else", "bin_kws", "dict", "bins", "bin_edges", "return", "bin_kws"], "doc_len": 96}
{"doc_id": "seaborn/_stats/counting.py::Hist._get_bins_and_eval", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "_get_bins_and_eval", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def _get_bins_and_eval(self, data, orient, groupby, scale_type):\n\n        bin_kws = self._define_bin_params(data, orient, scale_type)\n        return groupby.apply(data, self._eval, orient, bin_kws)\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "_get_bins_and_eval", "self", "data", "orient", "groupby", "scale_type", "bin_kws", "self", "_define_bin_params", "data", "orient", "scale_type", "return", "groupby", "apply", "data", "self", "_eval", "orient", "bin_kws"], "doc_len": 26}
{"doc_id": "seaborn/_stats/counting.py::Hist._eval", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "_eval", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def _eval(self, data, orient, bin_kws):\n\n        vals = data[orient]\n        weights = data.get(\"weight\", None)\n\n        density = self.stat == \"density\"\n        hist, edges = np.histogram(vals, **bin_kws, weights=weights, density=density)\n\n        width = np.diff(edges)\n        center = edges[:-1] + width / 2\n\n        return pd.DataFrame({orient: center, \"count\": hist, \"space\": width})\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "_eval", "self", "data", "orient", "bin_kws", "vals", "data", "orient", "weights", "data", "get", "weight", "none", "density", "self", "stat", "density", "hist", "edges", "np", "histogram", "vals", "bin_kws", "weights", "weights", "density", "density", "width", "np", "diff", "edges", "center", "edges", "1", "width", "2", "return", "pd", "dataframe", "orient", "center", "count", "hist", "space", "width"], "doc_len": 51}
{"doc_id": "seaborn/_stats/counting.py::Hist._normalize", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "_normalize", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def _normalize(self, data):\n\n        hist = data[\"count\"]\n        if self.stat == \"probability\" or self.stat == \"proportion\":\n            hist = hist.astype(float) / hist.sum()\n        elif self.stat == \"percent\":\n            hist = hist.astype(float) / hist.sum() * 100\n        elif self.stat == \"frequency\":\n            hist = hist.astype(float) / data[\"space\"]\n\n        if self.cumulative:\n            if self.stat in [\"density\", \"frequency\"]:\n                hist = (hist * data[\"space\"]).cumsum()\n            else:\n                hist = hist.cumsum()\n\n        return data.assign(**{self.stat: hist})\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "_normalize", "self", "data", "hist", "data", "count", "if", "self", "stat", "probability", "or", "self", "stat", "proportion", "hist", "hist", "astype", "float", "hist", "sum", "elif", "self", "stat", "percent", "hist", "hist", "astype", "float", "hist", "sum", "100", "elif", "self", "stat", "frequency", "hist", "hist", "astype", "float", "data", "space", "if", "self", "cumulative", "if", "self", "stat", "in", "density", "frequency", "hist", "hist", "data", "space", "cumsum", "else", "hist", "hist", "cumsum", "return", "data", "assign", "self", "stat", "hist"], "doc_len": 71}
{"doc_id": "seaborn/_stats/counting.py::Hist.__call__", "file_path": "seaborn/_stats/counting.py", "class_name": "Hist", "func_name": "__call__", "text": "文件路径: seaborn/_stats/counting.py, 类名: Hist\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        scale_type = scales[orient].__class__.__name__.lower()\n        grouping_vars = [str(v) for v in data if v in groupby.order]\n        if not grouping_vars or self.common_bins is True:\n            bin_kws = self._define_bin_params(data, orient, scale_type)\n            data = groupby.apply(data, self._eval, orient, bin_kws)\n        else:\n            if self.common_bins is False:\n                bin_groupby = GroupBy(grouping_vars)\n            else:\n                bin_groupby = GroupBy(self.common_bins)\n                self._check_grouping_vars(\"common_bins\", grouping_vars)\n\n            data = bin_groupby.apply(\n                data, self._get_bins_and_eval, orient, groupby, scale_type,\n            )\n\n        if not grouping_vars or self.common_norm is True:\n            data = self._normalize(data)\n        else:\n            if self.common_norm is False:\n                norm_groupby = GroupBy(grouping_vars)\n            else:\n                norm_groupby = GroupBy(self.common_norm)\n                self._check_grouping_vars(\"common_norm\", grouping_vars)\n            data = norm_groupby.apply(data, self._normalize)\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        return data.assign(**{other: data[self.stat]})\n", "tokens": ["seaborn", "_stats", "counting", "py", "hist", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "scale_type", "scales", "orient", "__class__", "__name__", "lower", "grouping_vars", "str", "v", "for", "v", "in", "data", "if", "v", "in", "groupby", "order", "if", "not", "grouping_vars", "or", "self", "common_bins", "is", "true", "bin_kws", "self", "_define_bin_params", "data", "orient", "scale_type", "data", "groupby", "apply", "data", "self", "_eval", "orient", "bin_kws", "else", "if", "self", "common_bins", "is", "false", "bin_groupby", "groupby", "grouping_vars", "else", "bin_groupby", "groupby", "self", "common_bins", "self", "_check_grouping_vars", "common_bins", "grouping_vars", "data", "bin_groupby", "apply", "data", "self", "_get_bins_and_eval", "orient", "groupby", "scale_type", "if", "not", "grouping_vars", "or", "self", "common_norm", "is", "true", "data", "self", "_normalize", "data", "else", "if", "self", "common_norm", "is", "false", "norm_groupby", "groupby", "grouping_vars", "else", "norm_groupby", "groupby", "self", "common_norm", "self", "_check_grouping_vars", "common_norm", "grouping_vars", "data", "norm_groupby", "apply", "data", "self", "_normalize", "other", "x", "y", "y", "x", "orient", "return", "data", "assign", "other", "data", "self", "stat"], "doc_len": 135}
{"doc_id": "seaborn/_stats/density.py::KDE.__post_init__", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "__post_init__", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def __post_init__(self):\n\n        if self.cumulative and _no_scipy:\n            raise RuntimeError(\"Cumulative KDE evaluation requires scipy\")\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "__post_init__", "self", "if", "self", "cumulative", "and", "_no_scipy", "raise", "runtimeerror", "cumulative", "kde", "evaluation", "requires", "scipy"], "doc_len": 20}
{"doc_id": "seaborn/_stats/density.py::KDE._check_var_list_or_boolean", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "_check_var_list_or_boolean", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def _check_var_list_or_boolean(self, param: str, grouping_vars: Any) -> None:\n        \"\"\"Do input checks on grouping parameters.\"\"\"\n        value = getattr(self, param)\n        if not (\n            isinstance(value, bool)\n            or (isinstance(value, list) and all(isinstance(v, str) for v in value))\n        ):\n            param_name = f\"{self.__class__.__name__}.{param}\"\n            raise TypeError(f\"{param_name} must be a boolean or list of strings.\")\n        self._check_grouping_vars(param, grouping_vars, stacklevel=3)\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "_check_var_list_or_boolean", "self", "param", "str", "grouping_vars", "any", "none", "do", "input", "checks", "on", "grouping", "parameters", "value", "getattr", "self", "param", "if", "not", "isinstance", "value", "bool", "or", "isinstance", "value", "list", "and", "all", "isinstance", "v", "str", "for", "v", "in", "value", "param_name", "f", "self", "__class__", "__name__", "param", "raise", "typeerror", "f", "param_name", "must", "be", "a", "boolean", "or", "list", "of", "strings", "self", "_check_grouping_vars", "param", "grouping_vars", "stacklevel", "3"], "doc_len": 65}
{"doc_id": "seaborn/_stats/density.py::KDE._fit", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "_fit", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def _fit(self, data: DataFrame, orient: str) -> gaussian_kde:\n        \"\"\"Fit and return a KDE object.\"\"\"\n        # TODO need to handle singular data\n\n        fit_kws: dict[str, Any] = {\"bw_method\": self.bw_method}\n        if \"weight\" in data:\n            fit_kws[\"weights\"] = data[\"weight\"]\n        kde = gaussian_kde(data[orient], **fit_kws)\n        kde.set_bandwidth(kde.factor * self.bw_adjust)\n\n        return kde\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "_fit", "self", "data", "dataframe", "orient", "str", "gaussian_kde", "fit", "and", "return", "a", "kde", "object", "todo", "need", "to", "handle", "singular", "data", "fit_kws", "dict", "str", "any", "bw_method", "self", "bw_method", "if", "weight", "in", "data", "fit_kws", "weights", "data", "weight", "kde", "gaussian_kde", "data", "orient", "fit_kws", "kde", "set_bandwidth", "kde", "factor", "self", "bw_adjust", "return", "kde"], "doc_len": 53}
{"doc_id": "seaborn/_stats/density.py::KDE._get_support", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "_get_support", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def _get_support(self, data: DataFrame, orient: str) -> ndarray:\n        \"\"\"Define the grid that the KDE will be evaluated on.\"\"\"\n        if self.gridsize is None:\n            return data[orient].to_numpy()\n\n        kde = self._fit(data, orient)\n        bw = np.sqrt(kde.covariance.squeeze())\n        gridmin = data[orient].min() - bw * self.cut\n        gridmax = data[orient].max() + bw * self.cut\n        return np.linspace(gridmin, gridmax, self.gridsize)\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "_get_support", "self", "data", "dataframe", "orient", "str", "ndarray", "define", "the", "grid", "that", "the", "kde", "will", "be", "evaluated", "on", "if", "self", "gridsize", "is", "none", "return", "data", "orient", "to_numpy", "kde", "self", "_fit", "data", "orient", "bw", "np", "sqrt", "kde", "covariance", "squeeze", "gridmin", "data", "orient", "min", "bw", "self", "cut", "gridmax", "data", "orient", "max", "bw", "self", "cut", "return", "np", "linspace", "gridmin", "gridmax", "self", "gridsize"], "doc_len": 64}
{"doc_id": "seaborn/_stats/density.py::KDE._fit_and_evaluate", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "_fit_and_evaluate", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def _fit_and_evaluate(\n        self, data: DataFrame, orient: str, support: ndarray\n    ) -> DataFrame:\n        \"\"\"Transform single group by fitting a KDE and evaluating on a support grid.\"\"\"\n        empty = pd.DataFrame(columns=[orient, \"weight\", \"density\"], dtype=float)\n        if len(data) < 2:\n            return empty\n        try:\n            kde = self._fit(data, orient)\n        except np.linalg.LinAlgError:\n            return empty\n\n        if self.cumulative:\n            s_0 = support[0]\n            density = np.array([kde.integrate_box_1d(s_0, s_i) for s_i in support])\n        else:\n            density = kde(support)\n\n        weight = data[\"weight\"].sum()\n        return pd.DataFrame({orient: support, \"weight\": weight, \"density\": density})\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "_fit_and_evaluate", "self", "data", "dataframe", "orient", "str", "support", "ndarray", "dataframe", "transform", "single", "group", "by", "fitting", "a", "kde", "and", "evaluating", "on", "a", "support", "grid", "empty", "pd", "dataframe", "columns", "orient", "weight", "density", "dtype", "float", "if", "len", "data", "2", "return", "empty", "try", "kde", "self", "_fit", "data", "orient", "except", "np", "linalg", "linalgerror", "return", "empty", "if", "self", "cumulative", "s_0", "support", "0", "density", "np", "array", "kde", "integrate_box_1d", "s_0", "s_i", "for", "s_i", "in", "support", "else", "density", "kde", "support", "weight", "data", "weight", "sum", "return", "pd", "dataframe", "orient", "support", "weight", "weight", "density", "density"], "doc_len": 89}
{"doc_id": "seaborn/_stats/density.py::KDE._transform", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "_transform", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def _transform(\n        self, data: DataFrame, orient: str, grouping_vars: list[str]\n    ) -> DataFrame:\n        \"\"\"Transform multiple groups by fitting KDEs and evaluating.\"\"\"\n        empty = pd.DataFrame(columns=[*data.columns, \"density\"], dtype=float)\n        if len(data) < 2:\n            return empty\n        try:\n            support = self._get_support(data, orient)\n        except np.linalg.LinAlgError:\n            return empty\n\n        grouping_vars = [x for x in grouping_vars if data[x].nunique() > 1]\n        if not grouping_vars:\n            return self._fit_and_evaluate(data, orient, support)\n        groupby = GroupBy(grouping_vars)\n        return groupby.apply(data, self._fit_and_evaluate, orient, support)\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "_transform", "self", "data", "dataframe", "orient", "str", "grouping_vars", "list", "str", "dataframe", "transform", "multiple", "groups", "by", "fitting", "kdes", "and", "evaluating", "empty", "pd", "dataframe", "columns", "data", "columns", "density", "dtype", "float", "if", "len", "data", "2", "return", "empty", "try", "support", "self", "_get_support", "data", "orient", "except", "np", "linalg", "linalgerror", "return", "empty", "grouping_vars", "x", "for", "x", "in", "grouping_vars", "if", "data", "x", "nunique", "1", "if", "not", "grouping_vars", "return", "self", "_fit_and_evaluate", "data", "orient", "support", "groupby", "groupby", "grouping_vars", "return", "groupby", "apply", "data", "self", "_fit_and_evaluate", "orient", "support"], "doc_len": 82}
{"doc_id": "seaborn/_stats/density.py::KDE.__call__", "file_path": "seaborn/_stats/density.py", "class_name": "KDE", "func_name": "__call__", "text": "文件路径: seaborn/_stats/density.py, 类名: KDE\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        if \"weight\" not in data:\n            data = data.assign(weight=1)\n        data = data.dropna(subset=[orient, \"weight\"])\n\n        # Transform each group separately\n        grouping_vars = [str(v) for v in data if v in groupby.order]\n        if not grouping_vars or self.common_grid is True:\n            res = self._transform(data, orient, grouping_vars)\n        else:\n            if self.common_grid is False:\n                grid_vars = grouping_vars\n            else:\n                self._check_var_list_or_boolean(\"common_grid\", grouping_vars)\n                grid_vars = [v for v in self.common_grid if v in grouping_vars]\n\n            res = (\n                GroupBy(grid_vars)\n                .apply(data, self._transform, orient, grouping_vars)\n            )\n\n        # Normalize, potentially within groups\n        if not grouping_vars or self.common_norm is True:\n            res = res.assign(group_weight=data[\"weight\"].sum())\n        else:\n            if self.common_norm is False:\n                norm_vars = grouping_vars\n            else:\n                self._check_var_list_or_boolean(\"common_norm\", grouping_vars)\n                norm_vars = [v for v in self.common_norm if v in grouping_vars]\n\n            res = res.join(\n                data.groupby(norm_vars)[\"weight\"].sum().rename(\"group_weight\"),\n                on=norm_vars,\n            )\n\n        res[\"density\"] *= res.eval(\"weight / group_weight\")\n        value = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        res[value] = res[\"density\"]\n        return res.drop([\"weight\", \"group_weight\"], axis=1)\n", "tokens": ["seaborn", "_stats", "density", "py", "kde", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "if", "weight", "not", "in", "data", "data", "data", "assign", "weight", "1", "data", "data", "dropna", "subset", "orient", "weight", "transform", "each", "group", "separately", "grouping_vars", "str", "v", "for", "v", "in", "data", "if", "v", "in", "groupby", "order", "if", "not", "grouping_vars", "or", "self", "common_grid", "is", "true", "res", "self", "_transform", "data", "orient", "grouping_vars", "else", "if", "self", "common_grid", "is", "false", "grid_vars", "grouping_vars", "else", "self", "_check_var_list_or_boolean", "common_grid", "grouping_vars", "grid_vars", "v", "for", "v", "in", "self", "common_grid", "if", "v", "in", "grouping_vars", "res", "groupby", "grid_vars", "apply", "data", "self", "_transform", "orient", "grouping_vars", "normalize", "potentially", "within", "groups", "if", "not", "grouping_vars", "or", "self", "common_norm", "is", "true", "res", "res", "assign", "group_weight", "data", "weight", "sum", "else", "if", "self", "common_norm", "is", "false", "norm_vars", "grouping_vars", "else", "self", "_check_var_list_or_boolean", "common_norm", "grouping_vars", "norm_vars", "v", "for", "v", "in", "self", "common_norm", "if", "v", "in", "grouping_vars", "res", "res", "join", "data", "groupby", "norm_vars", "weight", "sum", "rename", "group_weight", "on", "norm_vars", "res", "density", "res", "eval", "weight", "group_weight", "value", "x", "y", "y", "x", "orient", "res", "value", "res", "density", "return", "res", "drop", "weight", "group_weight", "axis", "1"], "doc_len": 176}
{"doc_id": "seaborn/_stats/order.py::Perc._percentile", "file_path": "seaborn/_stats/order.py", "class_name": "Perc", "func_name": "_percentile", "text": "文件路径: seaborn/_stats/order.py, 类名: Perc\n    def _percentile(self, data: DataFrame, var: str) -> DataFrame:\n\n        k = list(np.linspace(0, 100, self.k)) if isinstance(self.k, int) else self.k\n        method = cast(_MethodKind, self.method)\n        values = data[var].dropna()\n        if Version(np.__version__) < Version(\"1.22.0\"):\n            res = np.percentile(values, k, interpolation=method)  # type: ignore\n        else:\n            res = np.percentile(data[var].dropna(), k, method=method)\n        return DataFrame({var: res, \"percentile\": k})\n", "tokens": ["seaborn", "_stats", "order", "py", "perc", "def", "_percentile", "self", "data", "dataframe", "var", "str", "dataframe", "k", "list", "np", "linspace", "0", "100", "self", "k", "if", "isinstance", "self", "k", "int", "else", "self", "k", "method", "cast", "_methodkind", "self", "method", "values", "data", "var", "dropna", "if", "version", "np", "__version__", "version", "1", "22", "0", "res", "np", "percentile", "values", "k", "interpolation", "method", "type", "ignore", "else", "res", "np", "percentile", "data", "var", "dropna", "k", "method", "method", "return", "dataframe", "var", "res", "percentile", "k"], "doc_len": 71}
{"doc_id": "seaborn/_stats/order.py::Perc.__call__", "file_path": "seaborn/_stats/order.py", "class_name": "Perc", "func_name": "__call__", "text": "文件路径: seaborn/_stats/order.py, 类名: Perc\n    def __call__(\n        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],\n    ) -> DataFrame:\n\n        var = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        return groupby.apply(data, self._percentile, var)\n", "tokens": ["seaborn", "_stats", "order", "py", "perc", "def", "__call__", "self", "data", "dataframe", "groupby", "groupby", "orient", "str", "scales", "dict", "str", "scale", "dataframe", "var", "x", "y", "y", "x", "orient", "return", "groupby", "apply", "data", "self", "_percentile", "var"], "doc_len": 32}
{"doc_id": "seaborn/_stats/regression.py::PolyFit._fit_predict", "file_path": "seaborn/_stats/regression.py", "class_name": "PolyFit", "func_name": "_fit_predict", "text": "文件路径: seaborn/_stats/regression.py, 类名: PolyFit\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        if x.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x, y, self.order)\n            xx = np.linspace(x.min(), x.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n", "tokens": ["seaborn", "_stats", "regression", "py", "polyfit", "def", "_fit_predict", "self", "data", "x", "data", "x", "y", "data", "y", "if", "x", "nunique", "self", "order", "todo", "warn", "xx", "yy", "else", "p", "np", "polyfit", "x", "y", "self", "order", "xx", "np", "linspace", "x", "min", "x", "max", "self", "gridsize", "yy", "np", "polyval", "p", "xx", "return", "pd", "dataframe", "dict", "x", "xx", "y", "yy"], "doc_len": 54}
{"doc_id": "seaborn/_stats/regression.py::PolyFit.__call__", "file_path": "seaborn/_stats/regression.py", "class_name": "PolyFit", "func_name": "__call__", "text": "文件路径: seaborn/_stats/regression.py, 类名: PolyFit\n    def __call__(self, data, groupby, orient, scales):\n\n        return (\n            groupby\n            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)\n        )\n", "tokens": ["seaborn", "_stats", "regression", "py", "polyfit", "def", "__call__", "self", "data", "groupby", "orient", "scales", "return", "groupby", "apply", "data", "dropna", "subset", "x", "y", "self", "_fit_predict"], "doc_len": 22}
{"doc_id": "tests/conftest.py::close_figs", "file_path": "tests/conftest.py", "class_name": null, "func_name": "close_figs", "text": "文件路径: tests/conftest.py\ndef close_figs():\n    yield\n    import matplotlib.pyplot as plt\n    plt.close(\"all\")\n", "tokens": ["tests", "conftest", "py", "def", "close_figs", "yield", "import", "matplotlib", "pyplot", "as", "plt", "plt", "close", "all"], "doc_len": 14}
{"doc_id": "tests/conftest.py::random_seed", "file_path": "tests/conftest.py", "class_name": null, "func_name": "random_seed", "text": "文件路径: tests/conftest.py\ndef random_seed():\n    seed = sum(map(ord, \"seaborn random global\"))\n    np.random.seed(seed)\n", "tokens": ["tests", "conftest", "py", "def", "random_seed", "seed", "sum", "map", "ord", "seaborn", "random", "global", "np", "random", "seed", "seed"], "doc_len": 16}
{"doc_id": "tests/conftest.py::rng", "file_path": "tests/conftest.py", "class_name": null, "func_name": "rng", "text": "文件路径: tests/conftest.py\ndef rng():\n    seed = sum(map(ord, \"seaborn random object\"))\n    return np.random.RandomState(seed)\n", "tokens": ["tests", "conftest", "py", "def", "rng", "seed", "sum", "map", "ord", "seaborn", "random", "object", "return", "np", "random", "randomstate", "seed"], "doc_len": 17}
{"doc_id": "tests/conftest.py::wide_df", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_df", "text": "文件路径: tests/conftest.py\ndef wide_df(rng):\n\n    columns = list(\"abc\")\n    index = pd.RangeIndex(10, 50, 2, name=\"wide_index\")\n    values = rng.normal(size=(len(index), len(columns)))\n    return pd.DataFrame(values, index=index, columns=columns)\n", "tokens": ["tests", "conftest", "py", "def", "wide_df", "rng", "columns", "list", "abc", "index", "pd", "rangeindex", "10", "50", "2", "name", "wide_index", "values", "rng", "normal", "size", "len", "index", "len", "columns", "return", "pd", "dataframe", "values", "index", "index", "columns", "columns"], "doc_len": 33}
{"doc_id": "tests/conftest.py::wide_array", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_array", "text": "文件路径: tests/conftest.py\ndef wide_array(wide_df):\n\n    return wide_df.to_numpy()\n", "tokens": ["tests", "conftest", "py", "def", "wide_array", "wide_df", "return", "wide_df", "to_numpy"], "doc_len": 9}
{"doc_id": "tests/conftest.py::flat_series", "file_path": "tests/conftest.py", "class_name": null, "func_name": "flat_series", "text": "文件路径: tests/conftest.py\ndef flat_series(rng):\n\n    index = pd.RangeIndex(10, 30, name=\"t\")\n    return pd.Series(rng.normal(size=20), index, name=\"s\")\n", "tokens": ["tests", "conftest", "py", "def", "flat_series", "rng", "index", "pd", "rangeindex", "10", "30", "name", "t", "return", "pd", "series", "rng", "normal", "size", "20", "index", "name", "s"], "doc_len": 23}
{"doc_id": "tests/conftest.py::flat_array", "file_path": "tests/conftest.py", "class_name": null, "func_name": "flat_array", "text": "文件路径: tests/conftest.py\ndef flat_array(flat_series):\n\n    return flat_series.to_numpy()\n", "tokens": ["tests", "conftest", "py", "def", "flat_array", "flat_series", "return", "flat_series", "to_numpy"], "doc_len": 9}
{"doc_id": "tests/conftest.py::flat_list", "file_path": "tests/conftest.py", "class_name": null, "func_name": "flat_list", "text": "文件路径: tests/conftest.py\ndef flat_list(flat_series):\n\n    return flat_series.to_list()\n", "tokens": ["tests", "conftest", "py", "def", "flat_list", "flat_series", "return", "flat_series", "to_list"], "doc_len": 9}
{"doc_id": "tests/conftest.py::flat_data", "file_path": "tests/conftest.py", "class_name": null, "func_name": "flat_data", "text": "文件路径: tests/conftest.py\ndef flat_data(rng, request):\n\n    index = pd.RangeIndex(10, 30, name=\"t\")\n    series = pd.Series(rng.normal(size=20), index, name=\"s\")\n    if request.param == \"series\":\n        data = series\n    elif request.param == \"array\":\n        data = series.to_numpy()\n    elif request.param == \"list\":\n        data = series.to_list()\n    return data\n", "tokens": ["tests", "conftest", "py", "def", "flat_data", "rng", "request", "index", "pd", "rangeindex", "10", "30", "name", "t", "series", "pd", "series", "rng", "normal", "size", "20", "index", "name", "s", "if", "request", "param", "series", "data", "series", "elif", "request", "param", "array", "data", "series", "to_numpy", "elif", "request", "param", "list", "data", "series", "to_list", "return", "data"], "doc_len": 46}
{"doc_id": "tests/conftest.py::wide_list_of_series", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_list_of_series", "text": "文件路径: tests/conftest.py\ndef wide_list_of_series(rng):\n\n    return [pd.Series(rng.normal(size=20), np.arange(20), name=\"a\"),\n            pd.Series(rng.normal(size=10), np.arange(5, 15), name=\"b\")]\n", "tokens": ["tests", "conftest", "py", "def", "wide_list_of_series", "rng", "return", "pd", "series", "rng", "normal", "size", "20", "np", "arange", "20", "name", "a", "pd", "series", "rng", "normal", "size", "10", "np", "arange", "5", "15", "name", "b"], "doc_len": 30}
{"doc_id": "tests/conftest.py::wide_list_of_arrays", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_list_of_arrays", "text": "文件路径: tests/conftest.py\ndef wide_list_of_arrays(wide_list_of_series):\n\n    return [s.to_numpy() for s in wide_list_of_series]\n", "tokens": ["tests", "conftest", "py", "def", "wide_list_of_arrays", "wide_list_of_series", "return", "s", "to_numpy", "for", "s", "in", "wide_list_of_series"], "doc_len": 13}
{"doc_id": "tests/conftest.py::wide_list_of_lists", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_list_of_lists", "text": "文件路径: tests/conftest.py\ndef wide_list_of_lists(wide_list_of_series):\n\n    return [s.to_list() for s in wide_list_of_series]\n", "tokens": ["tests", "conftest", "py", "def", "wide_list_of_lists", "wide_list_of_series", "return", "s", "to_list", "for", "s", "in", "wide_list_of_series"], "doc_len": 13}
{"doc_id": "tests/conftest.py::wide_dict_of_series", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_dict_of_series", "text": "文件路径: tests/conftest.py\ndef wide_dict_of_series(wide_list_of_series):\n\n    return {s.name: s for s in wide_list_of_series}\n", "tokens": ["tests", "conftest", "py", "def", "wide_dict_of_series", "wide_list_of_series", "return", "s", "name", "s", "for", "s", "in", "wide_list_of_series"], "doc_len": 14}
{"doc_id": "tests/conftest.py::wide_dict_of_arrays", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_dict_of_arrays", "text": "文件路径: tests/conftest.py\ndef wide_dict_of_arrays(wide_list_of_series):\n\n    return {s.name: s.to_numpy() for s in wide_list_of_series}\n", "tokens": ["tests", "conftest", "py", "def", "wide_dict_of_arrays", "wide_list_of_series", "return", "s", "name", "s", "to_numpy", "for", "s", "in", "wide_list_of_series"], "doc_len": 15}
{"doc_id": "tests/conftest.py::wide_dict_of_lists", "file_path": "tests/conftest.py", "class_name": null, "func_name": "wide_dict_of_lists", "text": "文件路径: tests/conftest.py\ndef wide_dict_of_lists(wide_list_of_series):\n\n    return {s.name: s.to_list() for s in wide_list_of_series}\n", "tokens": ["tests", "conftest", "py", "def", "wide_dict_of_lists", "wide_list_of_series", "return", "s", "name", "s", "to_list", "for", "s", "in", "wide_list_of_series"], "doc_len": 15}
{"doc_id": "tests/conftest.py::long_df", "file_path": "tests/conftest.py", "class_name": null, "func_name": "long_df", "text": "文件路径: tests/conftest.py\ndef long_df(rng):\n\n    n = 100\n    df = pd.DataFrame(dict(\n        x=rng.uniform(0, 20, n).round().astype(\"int\"),\n        y=rng.normal(size=n),\n        z=rng.lognormal(size=n),\n        a=rng.choice(list(\"abc\"), n),\n        b=rng.choice(list(\"mnop\"), n),\n        c=rng.choice([0, 1], n, [.3, .7]),\n        d=rng.choice(np.arange(\"2004-07-30\", \"2007-07-30\", dtype=\"datetime64[Y]\"), n),\n        t=rng.choice(np.arange(\"2004-07-30\", \"2004-07-31\", dtype=\"datetime64[m]\"), n),\n        s=rng.choice([2, 4, 8], n),\n        f=rng.choice([0.2, 0.3], n),\n    ))\n\n    a_cat = df[\"a\"].astype(\"category\")\n    new_categories = np.roll(a_cat.cat.categories, 1)\n    df[\"a_cat\"] = a_cat.cat.reorder_categories(new_categories)\n\n    df[\"s_cat\"] = df[\"s\"].astype(\"category\")\n    df[\"s_str\"] = df[\"s\"].astype(str)\n\n    return df\n", "tokens": ["tests", "conftest", "py", "def", "long_df", "rng", "n", "100", "df", "pd", "dataframe", "dict", "x", "rng", "uniform", "0", "20", "n", "round", "astype", "int", "y", "rng", "normal", "size", "n", "z", "rng", "lognormal", "size", "n", "a", "rng", "choice", "list", "abc", "n", "b", "rng", "choice", "list", "mnop", "n", "c", "rng", "choice", "0", "1", "n", "3", "7", "d", "rng", "choice", "np", "arange", "2004", "07", "30", "2007", "07", "30", "dtype", "datetime64", "y", "n", "t", "rng", "choice", "np", "arange", "2004", "07", "30", "2004", "07", "31", "dtype", "datetime64", "m", "n", "s", "rng", "choice", "2", "4", "8", "n", "f", "rng", "choice", "0", "2", "0", "3", "n", "a_cat", "df", "a", "astype", "category", "new_categories", "np", "roll", "a_cat", "cat", "categories", "1", "df", "a_cat", "a_cat", "cat", "reorder_categories", "new_categories", "df", "s_cat", "df", "s", "astype", "category", "df", "s_str", "df", "s", "astype", "str", "return", "df"], "doc_len": 128}
{"doc_id": "tests/conftest.py::long_dict", "file_path": "tests/conftest.py", "class_name": null, "func_name": "long_dict", "text": "文件路径: tests/conftest.py\ndef long_dict(long_df):\n\n    return long_df.to_dict()\n", "tokens": ["tests", "conftest", "py", "def", "long_dict", "long_df", "return", "long_df", "to_dict"], "doc_len": 9}
{"doc_id": "tests/conftest.py::repeated_df", "file_path": "tests/conftest.py", "class_name": null, "func_name": "repeated_df", "text": "文件路径: tests/conftest.py\ndef repeated_df(rng):\n\n    n = 100\n    return pd.DataFrame(dict(\n        x=np.tile(np.arange(n // 2), 2),\n        y=rng.normal(size=n),\n        a=rng.choice(list(\"abc\"), n),\n        u=np.repeat(np.arange(2), n // 2),\n    ))\n", "tokens": ["tests", "conftest", "py", "def", "repeated_df", "rng", "n", "100", "return", "pd", "dataframe", "dict", "x", "np", "tile", "np", "arange", "n", "2", "2", "y", "rng", "normal", "size", "n", "a", "rng", "choice", "list", "abc", "n", "u", "np", "repeat", "np", "arange", "2", "n", "2"], "doc_len": 39}
{"doc_id": "tests/conftest.py::missing_df", "file_path": "tests/conftest.py", "class_name": null, "func_name": "missing_df", "text": "文件路径: tests/conftest.py\ndef missing_df(rng, long_df):\n\n    df = long_df.copy()\n    for col in df:\n        idx = rng.permutation(df.index)[:10]\n        df.loc[idx, col] = np.nan\n    return df\n", "tokens": ["tests", "conftest", "py", "def", "missing_df", "rng", "long_df", "df", "long_df", "copy", "for", "col", "in", "df", "idx", "rng", "permutation", "df", "index", "10", "df", "loc", "idx", "col", "np", "nan", "return", "df"], "doc_len": 28}
{"doc_id": "tests/conftest.py::object_df", "file_path": "tests/conftest.py", "class_name": null, "func_name": "object_df", "text": "文件路径: tests/conftest.py\ndef object_df(rng, long_df):\n\n    df = long_df.copy()\n    # objectify numeric columns\n    for col in [\"c\", \"s\", \"f\"]:\n        df[col] = df[col].astype(object)\n    return df\n", "tokens": ["tests", "conftest", "py", "def", "object_df", "rng", "long_df", "df", "long_df", "copy", "objectify", "numeric", "columns", "for", "col", "in", "c", "s", "f", "df", "col", "df", "col", "astype", "object", "return", "df"], "doc_len": 27}
{"doc_id": "tests/conftest.py::null_series", "file_path": "tests/conftest.py", "class_name": null, "func_name": "null_series", "text": "文件路径: tests/conftest.py\ndef null_series(flat_series):\n\n    return pd.Series(index=flat_series.index, dtype='float64')\n", "tokens": ["tests", "conftest", "py", "def", "null_series", "flat_series", "return", "pd", "series", "index", "flat_series", "index", "dtype", "float64"], "doc_len": 14}
{"doc_id": "tests/test_algorithms.py::random", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "random", "text": "文件路径: tests/test_algorithms.py\ndef random():\n    np.random.seed(sum(map(ord, \"test_algorithms\")))\n", "tokens": ["tests", "test_algorithms", "py", "def", "random", "np", "random", "seed", "sum", "map", "ord", "test_algorithms"], "doc_len": 12}
{"doc_id": "tests/test_algorithms.py::test_bootstrap", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap(random):\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = algo.bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = algo.bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap", "random", "test", "that", "bootstrapping", "gives", "the", "right", "answer", "in", "dumb", "cases", "a_ones", "np", "ones", "10", "n_boot", "5", "out1", "algo", "bootstrap", "a_ones", "n_boot", "n_boot", "assert_array_equal", "out1", "np", "ones", "n_boot", "out2", "algo", "bootstrap", "a_ones", "n_boot", "n_boot", "func", "np", "median", "assert_array_equal", "out2", "np", "ones", "n_boot"], "doc_len": 47}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_length", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_length", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_length(random):\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = algo.bootstrap(a_norm)\n    assert len(out) == 10000\n\n    n_boot = 100\n    out = algo.bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_length", "random", "test", "that", "we", "get", "a", "bootstrap", "array", "of", "the", "right", "shape", "a_norm", "np", "random", "randn", "1000", "out", "algo", "bootstrap", "a_norm", "assert", "len", "out", "10000", "n_boot", "100", "out", "algo", "bootstrap", "a_norm", "n_boot", "n_boot", "assert", "len", "out", "n_boot"], "doc_len": 42}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_range", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_range", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_range(random):\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = algo.bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_range", "random", "test", "that", "bootstrapping", "a", "random", "array", "stays", "within", "the", "right", "range", "a_norm", "np", "random", "randn", "1000", "amin", "amax", "a_norm", "min", "a_norm", "max", "out", "algo", "bootstrap", "a_norm", "assert", "amin", "out", "min", "assert", "amax", "out", "max"], "doc_len": 40}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_multiarg", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_multiarg", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_multiarg(random):\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n\n    out_actual = algo.bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_multiarg", "random", "test", "that", "bootstrap", "works", "with", "multiple", "input", "arrays", "x", "np", "vstack", "1", "10", "for", "i", "in", "range", "10", "y", "np", "vstack", "5", "5", "for", "i", "in", "range", "10", "def", "f", "x", "y", "return", "np", "vstack", "x", "y", "max", "axis", "0", "out_actual", "algo", "bootstrap", "x", "y", "n_boot", "2", "func", "f", "out_wanted", "np", "array", "5", "10", "5", "10", "assert_array_equal", "out_actual", "out_wanted"], "doc_len": 65}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_axis", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_axis", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_axis(random):\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n\n    out_default = algo.bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n\n    out_axis = algo.bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_axis", "random", "test", "axis", "kwarg", "to", "bootstrap", "function", "x", "np", "random", "randn", "10", "20", "n_boot", "100", "out_default", "algo", "bootstrap", "x", "n_boot", "n_boot", "assert", "out_default", "shape", "n_boot", "out_axis", "algo", "bootstrap", "x", "n_boot", "n_boot", "axis", "0", "assert", "out_axis", "shape", "n_boot", "x", "shape", "1"], "doc_len": 45}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_seed", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_seed", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_seed(random):\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = algo.bootstrap(data, seed=seed)\n    boots2 = algo.bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_seed", "random", "test", "that", "we", "can", "get", "reproducible", "resamples", "by", "seeding", "the", "rng", "data", "np", "random", "randn", "50", "seed", "42", "boots1", "algo", "bootstrap", "data", "seed", "seed", "boots2", "algo", "bootstrap", "data", "seed", "seed", "assert_array_equal", "boots1", "boots2"], "doc_len": 39}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_ols", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_ols", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_ols(random):\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n\n    n_boot = 500\n    w_boot_noisy = algo.bootstrap(X, y_noisy,\n                                  n_boot=n_boot,\n                                  func=ols_fit)\n    w_boot_lownoise = algo.bootstrap(X, y_lownoise,\n                                     n_boot=n_boot,\n                                     func=ols_fit)\n\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_ols", "random", "test", "bootstrap", "of", "ols", "model", "fit", "def", "ols_fit", "x", "y", "xtxinv", "np", "linalg", "inv", "np", "dot", "x", "t", "x", "return", "xtxinv", "dot", "x", "t", "dot", "y", "x", "np", "column_stack", "np", "random", "randn", "50", "4", "np", "ones", "50", "w", "2", "4", "0", "3", "5", "y_noisy", "np", "dot", "x", "w", "np", "random", "randn", "50", "20", "y_lownoise", "np", "dot", "x", "w", "np", "random", "randn", "50", "n_boot", "500", "w_boot_noisy", "algo", "bootstrap", "x", "y_noisy", "n_boot", "n_boot", "func", "ols_fit", "w_boot_lownoise", "algo", "bootstrap", "x", "y_lownoise", "n_boot", "n_boot", "func", "ols_fit", "assert", "w_boot_noisy", "shape", "n_boot", "5", "assert", "w_boot_lownoise", "shape", "n_boot", "5", "assert", "w_boot_noisy", "std", "w_boot_lownoise", "std"], "doc_len": 103}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_units", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_units", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_units(random):\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n\n    boots_orig = algo.bootstrap(data_rm, seed=seed)\n    boots_rm = algo.bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_units", "random", "test", "that", "results", "make", "sense", "when", "passing", "unit", "ids", "to", "bootstrap", "data", "np", "random", "randn", "50", "ids", "np", "repeat", "range", "10", "5", "bwerr", "np", "random", "normal", "0", "2", "10", "bwerr", "bwerr", "ids", "data_rm", "data", "bwerr", "seed", "77", "boots_orig", "algo", "bootstrap", "data_rm", "seed", "seed", "boots_rm", "algo", "bootstrap", "data_rm", "units", "ids", "seed", "seed", "assert", "boots_rm", "std", "boots_orig", "std"], "doc_len": 62}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_arglength", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_arglength", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_arglength():\n    \"\"\"Test that different length args raise ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        algo.bootstrap(np.arange(5), np.arange(10))\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_arglength", "test", "that", "different", "length", "args", "raise", "valueerror", "with", "pytest", "raises", "valueerror", "algo", "bootstrap", "np", "arange", "5", "np", "arange", "10"], "doc_len": 24}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_string_func", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_string_func", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n\n    res_a = algo.bootstrap(x, func=\"mean\", seed=0)\n    res_b = algo.bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n\n    res_a = algo.bootstrap(x, func=\"std\", seed=0)\n    res_b = algo.bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n\n    with pytest.raises(AttributeError):\n        algo.bootstrap(x, func=\"not_a_method_name\")\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_string_func", "test", "that", "named", "numpy", "methods", "are", "the", "same", "as", "the", "numpy", "function", "x", "np", "random", "randn", "100", "res_a", "algo", "bootstrap", "x", "func", "mean", "seed", "0", "res_b", "algo", "bootstrap", "x", "func", "np", "mean", "seed", "0", "assert", "np", "array_equal", "res_a", "res_b", "res_a", "algo", "bootstrap", "x", "func", "std", "seed", "0", "res_b", "algo", "bootstrap", "x", "func", "np", "std", "seed", "0", "assert", "np", "array_equal", "res_a", "res_b", "with", "pytest", "raises", "attributeerror", "algo", "bootstrap", "x", "func", "not_a_method_name"], "doc_len": 75}
{"doc_id": "tests/test_algorithms.py::test_bootstrap_reproducibility", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bootstrap_reproducibility", "text": "文件路径: tests/test_algorithms.py\ndef test_bootstrap_reproducibility(random):\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = algo.bootstrap(data, seed=100)\n    boots2 = algo.bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n\n    with pytest.warns(UserWarning):\n        # Deprecatd, remove when removing random_seed\n        boots1 = algo.bootstrap(data, random_seed=100)\n        boots2 = algo.bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bootstrap_reproducibility", "random", "test", "that", "bootstrapping", "uses", "the", "internal", "random", "state", "data", "np", "random", "randn", "50", "boots1", "algo", "bootstrap", "data", "seed", "100", "boots2", "algo", "bootstrap", "data", "seed", "100", "assert_array_equal", "boots1", "boots2", "with", "pytest", "warns", "userwarning", "deprecatd", "remove", "when", "removing", "random_seed", "boots1", "algo", "bootstrap", "data", "random_seed", "100", "boots2", "algo", "bootstrap", "data", "random_seed", "100", "assert_array_equal", "boots1", "boots2"], "doc_len": 58}
{"doc_id": "tests/test_algorithms.py::test_seed_new", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_seed_new", "text": "文件路径: tests/test_algorithms.py\ndef test_seed_new():\n\n    # Can't use pytest parametrize because tests will fail where the new\n    # Generator object and related function are not defined\n\n    test_bank = [\n        (None, None, npr.Generator, False),\n        (npr.RandomState(0), npr.RandomState(0), npr.RandomState, True),\n        (npr.RandomState(0), npr.RandomState(1), npr.RandomState, False),\n        (npr.default_rng(1), npr.default_rng(1), npr.Generator, True),\n        (npr.default_rng(1), npr.default_rng(2), npr.Generator, False),\n        (npr.SeedSequence(10), npr.SeedSequence(10), npr.Generator, True),\n        (npr.SeedSequence(10), npr.SeedSequence(20), npr.Generator, False),\n        (100, 100, npr.Generator, True),\n        (100, 200, npr.Generator, False),\n    ]\n    for seed1, seed2, rng_class, match in test_bank:\n        rng1 = algo._handle_random_seed(seed1)\n        rng2 = algo._handle_random_seed(seed2)\n        assert isinstance(rng1, rng_class)\n        assert isinstance(rng2, rng_class)\n        assert (rng1.uniform() == rng2.uniform()) == match\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_seed_new", "can", "t", "use", "pytest", "parametrize", "because", "tests", "will", "fail", "where", "the", "new", "generator", "object", "and", "related", "function", "are", "not", "defined", "test_bank", "none", "none", "npr", "generator", "false", "npr", "randomstate", "0", "npr", "randomstate", "0", "npr", "randomstate", "true", "npr", "randomstate", "0", "npr", "randomstate", "1", "npr", "randomstate", "false", "npr", "default_rng", "1", "npr", "default_rng", "1", "npr", "generator", "true", "npr", "default_rng", "1", "npr", "default_rng", "2", "npr", "generator", "false", "npr", "seedsequence", "10", "npr", "seedsequence", "10", "npr", "generator", "true", "npr", "seedsequence", "10", "npr", "seedsequence", "20", "npr", "generator", "false", "100", "100", "npr", "generator", "true", "100", "200", "npr", "generator", "false", "for", "seed1", "seed2", "rng_class", "match", "in", "test_bank", "rng1", "algo", "_handle_random_seed", "seed1", "rng2", "algo", "_handle_random_seed", "seed2", "assert", "isinstance", "rng1", "rng_class", "assert", "isinstance", "rng2", "rng_class", "assert", "rng1", "uniform", "rng2", "uniform", "match"], "doc_len": 124}
{"doc_id": "tests/test_algorithms.py::test_seed_old", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_seed_old", "text": "文件路径: tests/test_algorithms.py\ndef test_seed_old(seed1, seed2, match):\n    rng1 = algo._handle_random_seed(seed1)\n    rng2 = algo._handle_random_seed(seed2)\n    assert isinstance(rng1, np.random.RandomState)\n    assert isinstance(rng2, np.random.RandomState)\n    assert (rng1.uniform() == rng2.uniform()) == match\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_seed_old", "seed1", "seed2", "match", "rng1", "algo", "_handle_random_seed", "seed1", "rng2", "algo", "_handle_random_seed", "seed2", "assert", "isinstance", "rng1", "np", "random", "randomstate", "assert", "isinstance", "rng2", "np", "random", "randomstate", "assert", "rng1", "uniform", "rng2", "uniform", "match"], "doc_len": 34}
{"doc_id": "tests/test_algorithms.py::test_bad_seed_old", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_bad_seed_old", "text": "文件路径: tests/test_algorithms.py\ndef test_bad_seed_old():\n\n    with pytest.raises(ValueError):\n        algo._handle_random_seed(\"not_a_random_seed\")\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_bad_seed_old", "with", "pytest", "raises", "valueerror", "algo", "_handle_random_seed", "not_a_random_seed"], "doc_len": 12}
{"doc_id": "tests/test_algorithms.py::test_nanaware_func_auto", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_nanaware_func_auto", "text": "文件路径: tests/test_algorithms.py\ndef test_nanaware_func_auto(random):\n\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = algo.bootstrap(x, func=\"mean\")\n    assert not np.isnan(boots).any()\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_nanaware_func_auto", "random", "x", "np", "random", "normal", "size", "10", "x", "0", "np", "nan", "boots", "algo", "bootstrap", "x", "func", "mean", "assert", "not", "np", "isnan", "boots", "any"], "doc_len": 28}
{"doc_id": "tests/test_algorithms.py::test_nanaware_func_warning", "file_path": "tests/test_algorithms.py", "class_name": null, "func_name": "test_nanaware_func_warning", "text": "文件路径: tests/test_algorithms.py\ndef test_nanaware_func_warning(random):\n\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match=\"Data contain nans but\"):\n        boots = algo.bootstrap(x, func=\"ptp\")\n    assert np.isnan(boots).any()\n", "tokens": ["tests", "test_algorithms", "py", "def", "test_nanaware_func_warning", "random", "x", "np", "random", "normal", "size", "10", "x", "0", "np", "nan", "with", "pytest", "warns", "userwarning", "match", "data", "contain", "nans", "but", "boots", "algo", "bootstrap", "x", "func", "ptp", "assert", "np", "isnan", "boots", "any"], "doc_len": 36}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_self_data", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_self_data", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_self_data(self):\n\n        g = ag.FacetGrid(self.df)\n        assert g.data is self.df\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_self_data", "self", "g", "ag", "facetgrid", "self", "df", "assert", "g", "data", "is", "self", "df"], "doc_len": 18}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_self_figure", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_self_figure", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_self_figure(self):\n\n        g = ag.FacetGrid(self.df)\n        assert isinstance(g.figure, plt.Figure)\n        assert g.figure is g._figure\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_self_figure", "self", "g", "ag", "facetgrid", "self", "df", "assert", "isinstance", "g", "figure", "plt", "figure", "assert", "g", "figure", "is", "g", "_figure"], "doc_len": 24}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_self_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_self_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_self_axes(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n        for ax in g.axes.flat:\n            assert isinstance(ax, plt.Axes)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_self_axes", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "for", "ax", "in", "g", "axes", "flat", "assert", "isinstance", "ax", "plt", "axes"], "doc_len": 29}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_axes_array_size", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_axes_array_size", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_axes_array_size(self):\n\n        g = ag.FacetGrid(self.df)\n        assert g.axes.shape == (1, 1)\n\n        g = ag.FacetGrid(self.df, row=\"a\")\n        assert g.axes.shape == (3, 1)\n\n        g = ag.FacetGrid(self.df, col=\"b\")\n        assert g.axes.shape == (1, 2)\n\n        g = ag.FacetGrid(self.df, hue=\"c\")\n        assert g.axes.shape == (1, 1)\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n        assert g.axes.shape == (3, 2)\n        for ax in g.axes.flat:\n            assert isinstance(ax, plt.Axes)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_axes_array_size", "self", "g", "ag", "facetgrid", "self", "df", "assert", "g", "axes", "shape", "1", "1", "g", "ag", "facetgrid", "self", "df", "row", "a", "assert", "g", "axes", "shape", "3", "1", "g", "ag", "facetgrid", "self", "df", "col", "b", "assert", "g", "axes", "shape", "1", "2", "g", "ag", "facetgrid", "self", "df", "hue", "c", "assert", "g", "axes", "shape", "1", "1", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "assert", "g", "axes", "shape", "3", "2", "for", "ax", "in", "g", "axes", "flat", "assert", "isinstance", "ax", "plt", "axes"], "doc_len": 85}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_single_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_single_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_single_axes(self):\n\n        g = ag.FacetGrid(self.df)\n        assert isinstance(g.ax, plt.Axes)\n\n        g = ag.FacetGrid(self.df, row=\"a\")\n        with pytest.raises(AttributeError):\n            g.ax\n\n        g = ag.FacetGrid(self.df, col=\"a\")\n        with pytest.raises(AttributeError):\n            g.ax\n\n        g = ag.FacetGrid(self.df, col=\"a\", row=\"b\")\n        with pytest.raises(AttributeError):\n            g.ax\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_single_axes", "self", "g", "ag", "facetgrid", "self", "df", "assert", "isinstance", "g", "ax", "plt", "axes", "g", "ag", "facetgrid", "self", "df", "row", "a", "with", "pytest", "raises", "attributeerror", "g", "ax", "g", "ag", "facetgrid", "self", "df", "col", "a", "with", "pytest", "raises", "attributeerror", "g", "ax", "g", "ag", "facetgrid", "self", "df", "col", "a", "row", "b", "with", "pytest", "raises", "attributeerror", "g", "ax"], "doc_len": 59}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_col_wrap", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_col_wrap", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_col_wrap(self):\n\n        n = len(self.df.d.unique())\n\n        g = ag.FacetGrid(self.df, col=\"d\")\n        assert g.axes.shape == (1, n)\n        assert g.facet_axis(0, 8) is g.axes[0, 8]\n\n        g_wrap = ag.FacetGrid(self.df, col=\"d\", col_wrap=4)\n        assert g_wrap.axes.shape == (n,)\n        assert g_wrap.facet_axis(0, 8) is g_wrap.axes[8]\n        assert g_wrap._ncol == 4\n        assert g_wrap._nrow == (n / 4)\n\n        with pytest.raises(ValueError):\n            g = ag.FacetGrid(self.df, row=\"b\", col=\"d\", col_wrap=4)\n\n        df = self.df.copy()\n        df.loc[df.d == \"j\"] = np.nan\n        g_missing = ag.FacetGrid(df, col=\"d\")\n        assert g_missing.axes.shape == (1, n - 1)\n\n        g_missing_wrap = ag.FacetGrid(df, col=\"d\", col_wrap=4)\n        assert g_missing_wrap.axes.shape == (n - 1,)\n\n        g = ag.FacetGrid(self.df, col=\"d\", col_wrap=1)\n        assert len(list(g.facet_data())) == n\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_col_wrap", "self", "n", "len", "self", "df", "d", "unique", "g", "ag", "facetgrid", "self", "df", "col", "d", "assert", "g", "axes", "shape", "1", "n", "assert", "g", "facet_axis", "0", "8", "is", "g", "axes", "0", "8", "g_wrap", "ag", "facetgrid", "self", "df", "col", "d", "col_wrap", "4", "assert", "g_wrap", "axes", "shape", "n", "assert", "g_wrap", "facet_axis", "0", "8", "is", "g_wrap", "axes", "8", "assert", "g_wrap", "_ncol", "4", "assert", "g_wrap", "_nrow", "n", "4", "with", "pytest", "raises", "valueerror", "g", "ag", "facetgrid", "self", "df", "row", "b", "col", "d", "col_wrap", "4", "df", "self", "df", "copy", "df", "loc", "df", "d", "j", "np", "nan", "g_missing", "ag", "facetgrid", "df", "col", "d", "assert", "g_missing", "axes", "shape", "1", "n", "1", "g_missing_wrap", "ag", "facetgrid", "df", "col", "d", "col_wrap", "4", "assert", "g_missing_wrap", "axes", "shape", "n", "1", "g", "ag", "facetgrid", "self", "df", "col", "d", "col_wrap", "1", "assert", "len", "list", "g", "facet_data", "n"], "doc_len": 136}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_normal_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_normal_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_normal_axes(self):\n\n        null = np.empty(0, object).flat\n\n        g = ag.FacetGrid(self.df)\n        npt.assert_array_equal(g._bottom_axes, g.axes.flat)\n        npt.assert_array_equal(g._not_bottom_axes, null)\n        npt.assert_array_equal(g._left_axes, g.axes.flat)\n        npt.assert_array_equal(g._not_left_axes, null)\n        npt.assert_array_equal(g._inner_axes, null)\n\n        g = ag.FacetGrid(self.df, col=\"c\")\n        npt.assert_array_equal(g._bottom_axes, g.axes.flat)\n        npt.assert_array_equal(g._not_bottom_axes, null)\n        npt.assert_array_equal(g._left_axes, g.axes[:, 0].flat)\n        npt.assert_array_equal(g._not_left_axes, g.axes[:, 1:].flat)\n        npt.assert_array_equal(g._inner_axes, null)\n\n        g = ag.FacetGrid(self.df, row=\"c\")\n        npt.assert_array_equal(g._bottom_axes, g.axes[-1, :].flat)\n        npt.assert_array_equal(g._not_bottom_axes, g.axes[:-1, :].flat)\n        npt.assert_array_equal(g._left_axes, g.axes.flat)\n        npt.assert_array_equal(g._not_left_axes, null)\n        npt.assert_array_equal(g._inner_axes, null)\n\n        g = ag.FacetGrid(self.df, col=\"a\", row=\"c\")\n        npt.assert_array_equal(g._bottom_axes, g.axes[-1, :].flat)\n        npt.assert_array_equal(g._not_bottom_axes, g.axes[:-1, :].flat)\n        npt.assert_array_equal(g._left_axes, g.axes[:, 0].flat)\n        npt.assert_array_equal(g._not_left_axes, g.axes[:, 1:].flat)\n        npt.assert_array_equal(g._inner_axes, g.axes[:-1, 1:].flat)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_normal_axes", "self", "null", "np", "empty", "0", "object", "flat", "g", "ag", "facetgrid", "self", "df", "npt", "assert_array_equal", "g", "_bottom_axes", "g", "axes", "flat", "npt", "assert_array_equal", "g", "_not_bottom_axes", "null", "npt", "assert_array_equal", "g", "_left_axes", "g", "axes", "flat", "npt", "assert_array_equal", "g", "_not_left_axes", "null", "npt", "assert_array_equal", "g", "_inner_axes", "null", "g", "ag", "facetgrid", "self", "df", "col", "c", "npt", "assert_array_equal", "g", "_bottom_axes", "g", "axes", "flat", "npt", "assert_array_equal", "g", "_not_bottom_axes", "null", "npt", "assert_array_equal", "g", "_left_axes", "g", "axes", "0", "flat", "npt", "assert_array_equal", "g", "_not_left_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_inner_axes", "null", "g", "ag", "facetgrid", "self", "df", "row", "c", "npt", "assert_array_equal", "g", "_bottom_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_not_bottom_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_left_axes", "g", "axes", "flat", "npt", "assert_array_equal", "g", "_not_left_axes", "null", "npt", "assert_array_equal", "g", "_inner_axes", "null", "g", "ag", "facetgrid", "self", "df", "col", "a", "row", "c", "npt", "assert_array_equal", "g", "_bottom_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_not_bottom_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_left_axes", "g", "axes", "0", "flat", "npt", "assert_array_equal", "g", "_not_left_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_inner_axes", "g", "axes", "1", "1", "flat"], "doc_len": 177}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_wrapped_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_wrapped_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_wrapped_axes(self):\n\n        null = np.empty(0, object).flat\n\n        g = ag.FacetGrid(self.df, col=\"a\", col_wrap=2)\n        npt.assert_array_equal(g._bottom_axes,\n                               g.axes[np.array([1, 2])].flat)\n        npt.assert_array_equal(g._not_bottom_axes, g.axes[:1].flat)\n        npt.assert_array_equal(g._left_axes, g.axes[np.array([0, 2])].flat)\n        npt.assert_array_equal(g._not_left_axes, g.axes[np.array([1])].flat)\n        npt.assert_array_equal(g._inner_axes, null)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_wrapped_axes", "self", "null", "np", "empty", "0", "object", "flat", "g", "ag", "facetgrid", "self", "df", "col", "a", "col_wrap", "2", "npt", "assert_array_equal", "g", "_bottom_axes", "g", "axes", "np", "array", "1", "2", "flat", "npt", "assert_array_equal", "g", "_not_bottom_axes", "g", "axes", "1", "flat", "npt", "assert_array_equal", "g", "_left_axes", "g", "axes", "np", "array", "0", "2", "flat", "npt", "assert_array_equal", "g", "_not_left_axes", "g", "axes", "np", "array", "1", "flat", "npt", "assert_array_equal", "g", "_inner_axes", "null"], "doc_len": 67}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_axes_dict", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_axes_dict", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_axes_dict(self):\n\n        g = ag.FacetGrid(self.df)\n        assert isinstance(g.axes_dict, dict)\n        assert not g.axes_dict\n\n        g = ag.FacetGrid(self.df, row=\"c\")\n        assert list(g.axes_dict.keys()) == g.row_names\n        for (name, ax) in zip(g.row_names, g.axes.flat):\n            assert g.axes_dict[name] is ax\n\n        g = ag.FacetGrid(self.df, col=\"c\")\n        assert list(g.axes_dict.keys()) == g.col_names\n        for (name, ax) in zip(g.col_names, g.axes.flat):\n            assert g.axes_dict[name] is ax\n\n        g = ag.FacetGrid(self.df, col=\"a\", col_wrap=2)\n        assert list(g.axes_dict.keys()) == g.col_names\n        for (name, ax) in zip(g.col_names, g.axes.flat):\n            assert g.axes_dict[name] is ax\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"c\")\n        for (row_var, col_var), ax in g.axes_dict.items():\n            i = g.row_names.index(row_var)\n            j = g.col_names.index(col_var)\n            assert g.axes[i, j] is ax\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_axes_dict", "self", "g", "ag", "facetgrid", "self", "df", "assert", "isinstance", "g", "axes_dict", "dict", "assert", "not", "g", "axes_dict", "g", "ag", "facetgrid", "self", "df", "row", "c", "assert", "list", "g", "axes_dict", "keys", "g", "row_names", "for", "name", "ax", "in", "zip", "g", "row_names", "g", "axes", "flat", "assert", "g", "axes_dict", "name", "is", "ax", "g", "ag", "facetgrid", "self", "df", "col", "c", "assert", "list", "g", "axes_dict", "keys", "g", "col_names", "for", "name", "ax", "in", "zip", "g", "col_names", "g", "axes", "flat", "assert", "g", "axes_dict", "name", "is", "ax", "g", "ag", "facetgrid", "self", "df", "col", "a", "col_wrap", "2", "assert", "list", "g", "axes_dict", "keys", "g", "col_names", "for", "name", "ax", "in", "zip", "g", "col_names", "g", "axes", "flat", "assert", "g", "axes_dict", "name", "is", "ax", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "c", "for", "row_var", "col_var", "ax", "in", "g", "axes_dict", "items", "i", "g", "row_names", "index", "row_var", "j", "g", "col_names", "index", "col_var", "assert", "g", "axes", "i", "j", "is", "ax"], "doc_len": 147}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_figure_size", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_figure_size", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_figure_size(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        npt.assert_array_equal(g.figure.get_size_inches(), (6, 9))\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", height=6)\n        npt.assert_array_equal(g.figure.get_size_inches(), (12, 18))\n\n        g = ag.FacetGrid(self.df, col=\"c\", height=4, aspect=.5)\n        npt.assert_array_equal(g.figure.get_size_inches(), (6, 4))\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_figure_size", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "6", "9", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "height", "6", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "12", "18", "g", "ag", "facetgrid", "self", "df", "col", "c", "height", "4", "aspect", "5", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "6", "4"], "doc_len": 59}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_figure_size_with_legend", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_figure_size_with_legend", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_figure_size_with_legend(self):\n\n        g = ag.FacetGrid(self.df, col=\"a\", hue=\"c\", height=4, aspect=.5)\n        npt.assert_array_equal(g.figure.get_size_inches(), (6, 4))\n        g.add_legend()\n        assert g.figure.get_size_inches()[0] > 6\n\n        g = ag.FacetGrid(self.df, col=\"a\", hue=\"c\", height=4, aspect=.5,\n                         legend_out=False)\n        npt.assert_array_equal(g.figure.get_size_inches(), (6, 4))\n        g.add_legend()\n        npt.assert_array_equal(g.figure.get_size_inches(), (6, 4))\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_figure_size_with_legend", "self", "g", "ag", "facetgrid", "self", "df", "col", "a", "hue", "c", "height", "4", "aspect", "5", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "6", "4", "g", "add_legend", "assert", "g", "figure", "get_size_inches", "0", "6", "g", "ag", "facetgrid", "self", "df", "col", "a", "hue", "c", "height", "4", "aspect", "5", "legend_out", "false", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "6", "4", "g", "add_legend", "npt", "assert_array_equal", "g", "figure", "get_size_inches", "6", "4"], "doc_len": 66}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legend_data", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legend_data", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legend_data(self):\n\n        g = ag.FacetGrid(self.df, hue=\"a\")\n        g.map(plt.plot, \"x\", \"y\")\n        g.add_legend()\n        palette = color_palette(n_colors=3)\n\n        assert g._legend.get_title().get_text() == \"a\"\n\n        a_levels = sorted(self.df.a.unique())\n\n        lines = g._legend.get_lines()\n        assert len(lines) == len(a_levels)\n\n        for line, hue in zip(lines, palette):\n            assert_colors_equal(line.get_color(), hue)\n\n        labels = g._legend.get_texts()\n        assert len(labels) == len(a_levels)\n\n        for label, level in zip(labels, a_levels):\n            assert label.get_text() == level\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legend_data", "self", "g", "ag", "facetgrid", "self", "df", "hue", "a", "g", "map", "plt", "plot", "x", "y", "g", "add_legend", "palette", "color_palette", "n_colors", "3", "assert", "g", "_legend", "get_title", "get_text", "a", "a_levels", "sorted", "self", "df", "a", "unique", "lines", "g", "_legend", "get_lines", "assert", "len", "lines", "len", "a_levels", "for", "line", "hue", "in", "zip", "lines", "palette", "assert_colors_equal", "line", "get_color", "hue", "labels", "g", "_legend", "get_texts", "assert", "len", "labels", "len", "a_levels", "for", "label", "level", "in", "zip", "labels", "a_levels", "assert", "label", "get_text", "level"], "doc_len": 78}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legend_data_missing_level", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legend_data_missing_level", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legend_data_missing_level(self):\n\n        g = ag.FacetGrid(self.df, hue=\"a\", hue_order=list(\"azbc\"))\n        g.map(plt.plot, \"x\", \"y\")\n        g.add_legend()\n\n        c1, c2, c3, c4 = color_palette(n_colors=4)\n        palette = [c1, c3, c4]\n\n        assert g._legend.get_title().get_text() == \"a\"\n\n        a_levels = sorted(self.df.a.unique())\n\n        lines = g._legend.get_lines()\n        assert len(lines) == len(a_levels)\n\n        for line, hue in zip(lines, palette):\n            assert_colors_equal(line.get_color(), hue)\n\n        labels = g._legend.get_texts()\n        assert len(labels) == 4\n\n        for label, level in zip(labels, list(\"azbc\")):\n            assert label.get_text() == level\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legend_data_missing_level", "self", "g", "ag", "facetgrid", "self", "df", "hue", "a", "hue_order", "list", "azbc", "g", "map", "plt", "plot", "x", "y", "g", "add_legend", "c1", "c2", "c3", "c4", "color_palette", "n_colors", "4", "palette", "c1", "c3", "c4", "assert", "g", "_legend", "get_title", "get_text", "a", "a_levels", "sorted", "self", "df", "a", "unique", "lines", "g", "_legend", "get_lines", "assert", "len", "lines", "len", "a_levels", "for", "line", "hue", "in", "zip", "lines", "palette", "assert_colors_equal", "line", "get_color", "hue", "labels", "g", "_legend", "get_texts", "assert", "len", "labels", "4", "for", "label", "level", "in", "zip", "labels", "list", "azbc", "assert", "label", "get_text", "level"], "doc_len": 88}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_get_boolean_legend_data", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_get_boolean_legend_data", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_get_boolean_legend_data(self):\n\n        self.df[\"b_bool\"] = self.df.b == \"m\"\n        g = ag.FacetGrid(self.df, hue=\"b_bool\")\n        g.map(plt.plot, \"x\", \"y\")\n        g.add_legend()\n        palette = color_palette(n_colors=2)\n\n        assert g._legend.get_title().get_text() == \"b_bool\"\n\n        b_levels = list(map(str, categorical_order(self.df.b_bool)))\n\n        lines = g._legend.get_lines()\n        assert len(lines) == len(b_levels)\n\n        for line, hue in zip(lines, palette):\n            assert_colors_equal(line.get_color(), hue)\n\n        labels = g._legend.get_texts()\n        assert len(labels) == len(b_levels)\n\n        for label, level in zip(labels, b_levels):\n            assert label.get_text() == level\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_get_boolean_legend_data", "self", "self", "df", "b_bool", "self", "df", "b", "m", "g", "ag", "facetgrid", "self", "df", "hue", "b_bool", "g", "map", "plt", "plot", "x", "y", "g", "add_legend", "palette", "color_palette", "n_colors", "2", "assert", "g", "_legend", "get_title", "get_text", "b_bool", "b_levels", "list", "map", "str", "categorical_order", "self", "df", "b_bool", "lines", "g", "_legend", "get_lines", "assert", "len", "lines", "len", "b_levels", "for", "line", "hue", "in", "zip", "lines", "palette", "assert_colors_equal", "line", "get_color", "hue", "labels", "g", "_legend", "get_texts", "assert", "len", "labels", "len", "b_levels", "for", "label", "level", "in", "zip", "labels", "b_levels", "assert", "label", "get_text", "level"], "doc_len": 87}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legend_tuples", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legend_tuples", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legend_tuples(self):\n\n        g = ag.FacetGrid(self.df, hue=\"a\")\n        g.map(plt.plot, \"x\", \"y\")\n\n        handles, labels = g.ax.get_legend_handles_labels()\n        label_tuples = [(\"\", l) for l in labels]\n        legend_data = dict(zip(label_tuples, handles))\n        g.add_legend(legend_data, label_tuples)\n        for entry, label in zip(g._legend.get_texts(), labels):\n            assert entry.get_text() == label\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legend_tuples", "self", "g", "ag", "facetgrid", "self", "df", "hue", "a", "g", "map", "plt", "plot", "x", "y", "handles", "labels", "g", "ax", "get_legend_handles_labels", "label_tuples", "l", "for", "l", "in", "labels", "legend_data", "dict", "zip", "label_tuples", "handles", "g", "add_legend", "legend_data", "label_tuples", "for", "entry", "label", "in", "zip", "g", "_legend", "get_texts", "labels", "assert", "entry", "get_text", "label"], "doc_len": 53}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legend_options", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legend_options", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legend_options(self):\n\n        g = ag.FacetGrid(self.df, hue=\"b\")\n        g.map(plt.plot, \"x\", \"y\")\n        g.add_legend()\n\n        g1 = ag.FacetGrid(self.df, hue=\"b\", legend_out=False)\n        g1.add_legend(adjust_subtitles=True)\n\n        g1 = ag.FacetGrid(self.df, hue=\"b\", legend_out=False)\n        g1.add_legend(adjust_subtitles=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legend_options", "self", "g", "ag", "facetgrid", "self", "df", "hue", "b", "g", "map", "plt", "plot", "x", "y", "g", "add_legend", "g1", "ag", "facetgrid", "self", "df", "hue", "b", "legend_out", "false", "g1", "add_legend", "adjust_subtitles", "true", "g1", "ag", "facetgrid", "self", "df", "hue", "b", "legend_out", "false", "g1", "add_legend", "adjust_subtitles", "false"], "doc_len": 48}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legendout_with_colwrap", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legendout_with_colwrap", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legendout_with_colwrap(self):\n\n        g = ag.FacetGrid(self.df, col=\"d\", hue='b',\n                         col_wrap=4, legend_out=False)\n        g.map(plt.plot, \"x\", \"y\", linewidth=3)\n        g.add_legend()\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legendout_with_colwrap", "self", "g", "ag", "facetgrid", "self", "df", "col", "d", "hue", "b", "col_wrap", "4", "legend_out", "false", "g", "map", "plt", "plot", "x", "y", "linewidth", "3", "g", "add_legend"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_legend_tight_layout", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_legend_tight_layout", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_legend_tight_layout(self):\n\n        g = ag.FacetGrid(self.df, hue='b')\n        g.map(plt.plot, \"x\", \"y\", linewidth=3)\n        g.add_legend()\n        g.tight_layout()\n\n        axes_right_edge = g.ax.get_window_extent().xmax\n        legend_left_edge = g._legend.get_window_extent().xmin\n\n        assert axes_right_edge < legend_left_edge\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_legend_tight_layout", "self", "g", "ag", "facetgrid", "self", "df", "hue", "b", "g", "map", "plt", "plot", "x", "y", "linewidth", "3", "g", "add_legend", "g", "tight_layout", "axes_right_edge", "g", "ax", "get_window_extent", "xmax", "legend_left_edge", "g", "_legend", "get_window_extent", "xmin", "assert", "axes_right_edge", "legend_left_edge"], "doc_len": 39}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_subplot_kws", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_subplot_kws", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_subplot_kws(self):\n\n        g = ag.FacetGrid(self.df, despine=False,\n                         subplot_kws=dict(projection=\"polar\"))\n        for ax in g.axes.flat:\n            assert \"PolarAxesSubplot\" in str(type(ax))\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_subplot_kws", "self", "g", "ag", "facetgrid", "self", "df", "despine", "false", "subplot_kws", "dict", "projection", "polar", "for", "ax", "in", "g", "axes", "flat", "assert", "polaraxessubplot", "in", "str", "type", "ax"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_gridspec_kws", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_gridspec_kws", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_gridspec_kws(self):\n        ratios = [3, 1, 2]\n\n        gskws = dict(width_ratios=ratios)\n        g = ag.FacetGrid(self.df, col='c', row='a', gridspec_kws=gskws)\n\n        for ax in g.axes.flat:\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        g.figure.tight_layout()\n\n        for (l, m, r) in g.axes:\n            assert l.get_position().width > m.get_position().width\n            assert r.get_position().width > m.get_position().width\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_gridspec_kws", "self", "ratios", "3", "1", "2", "gskws", "dict", "width_ratios", "ratios", "g", "ag", "facetgrid", "self", "df", "col", "c", "row", "a", "gridspec_kws", "gskws", "for", "ax", "in", "g", "axes", "flat", "ax", "set_xticks", "ax", "set_yticks", "g", "figure", "tight_layout", "for", "l", "m", "r", "in", "g", "axes", "assert", "l", "get_position", "width", "m", "get_position", "width", "assert", "r", "get_position", "width", "m", "get_position", "width"], "doc_len": 60}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_gridspec_kws_col_wrap", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_gridspec_kws_col_wrap", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_gridspec_kws_col_wrap(self):\n        ratios = [3, 1, 2, 1, 1]\n\n        gskws = dict(width_ratios=ratios)\n        with pytest.warns(UserWarning):\n            ag.FacetGrid(self.df, col='d', col_wrap=5, gridspec_kws=gskws)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_gridspec_kws_col_wrap", "self", "ratios", "3", "1", "2", "1", "1", "gskws", "dict", "width_ratios", "ratios", "with", "pytest", "warns", "userwarning", "ag", "facetgrid", "self", "df", "col", "d", "col_wrap", "5", "gridspec_kws", "gskws"], "doc_len": 31}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_data_generator", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_data_generator", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_data_generator(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\")\n        d = list(g.facet_data())\n        assert len(d) == 3\n\n        tup, data = d[0]\n        assert tup == (0, 0, 0)\n        assert (data[\"a\"] == \"a\").all()\n\n        tup, data = d[1]\n        assert tup == (1, 0, 0)\n        assert (data[\"a\"] == \"b\").all()\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        d = list(g.facet_data())\n        assert len(d) == 6\n\n        tup, data = d[0]\n        assert tup == (0, 0, 0)\n        assert (data[\"a\"] == \"a\").all()\n        assert (data[\"b\"] == \"m\").all()\n\n        tup, data = d[1]\n        assert tup == (0, 1, 0)\n        assert (data[\"a\"] == \"a\").all()\n        assert (data[\"b\"] == \"n\").all()\n\n        tup, data = d[2]\n        assert tup == (1, 0, 0)\n        assert (data[\"a\"] == \"b\").all()\n        assert (data[\"b\"] == \"m\").all()\n\n        g = ag.FacetGrid(self.df, hue=\"c\")\n        d = list(g.facet_data())\n        assert len(d) == 3\n        tup, data = d[1]\n        assert tup == (0, 0, 1)\n        assert (data[\"c\"] == \"u\").all()\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_data_generator", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "d", "list", "g", "facet_data", "assert", "len", "d", "3", "tup", "data", "d", "0", "assert", "tup", "0", "0", "0", "assert", "data", "a", "a", "all", "tup", "data", "d", "1", "assert", "tup", "1", "0", "0", "assert", "data", "a", "b", "all", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "d", "list", "g", "facet_data", "assert", "len", "d", "6", "tup", "data", "d", "0", "assert", "tup", "0", "0", "0", "assert", "data", "a", "a", "all", "assert", "data", "b", "m", "all", "tup", "data", "d", "1", "assert", "tup", "0", "1", "0", "assert", "data", "a", "a", "all", "assert", "data", "b", "n", "all", "tup", "data", "d", "2", "assert", "tup", "1", "0", "0", "assert", "data", "a", "b", "all", "assert", "data", "b", "m", "all", "g", "ag", "facetgrid", "self", "df", "hue", "c", "d", "list", "g", "facet_data", "assert", "len", "d", "3", "tup", "data", "d", "1", "assert", "tup", "0", "0", "1", "assert", "data", "c", "u", "all"], "doc_len": 153}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_map", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_map", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_map(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n        g.map(plt.plot, \"x\", \"y\", linewidth=3)\n\n        lines = g.axes[0, 0].lines\n        assert len(lines) == 3\n\n        line1, _, _ = lines\n        assert line1.get_linewidth() == 3\n        x, y = line1.get_data()\n        mask = (self.df.a == \"a\") & (self.df.b == \"m\") & (self.df.c == \"t\")\n        npt.assert_array_equal(x, self.df.x[mask])\n        npt.assert_array_equal(y, self.df.y[mask])\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_map", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "g", "map", "plt", "plot", "x", "y", "linewidth", "3", "lines", "g", "axes", "0", "0", "lines", "assert", "len", "lines", "3", "line1", "_", "_", "lines", "assert", "line1", "get_linewidth", "3", "x", "y", "line1", "get_data", "mask", "self", "df", "a", "a", "self", "df", "b", "m", "self", "df", "c", "t", "npt", "assert_array_equal", "x", "self", "df", "x", "mask", "npt", "assert_array_equal", "y", "self", "df", "y", "mask"], "doc_len": 75}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_map_dataframe", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_map_dataframe", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_map_dataframe(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n\n        def plot(x, y, data=None, **kws):\n            plt.plot(data[x], data[y], **kws)\n        # Modify __module__ so this doesn't look like a seaborn function\n        plot.__module__ = \"test\"\n\n        g.map_dataframe(plot, \"x\", \"y\", linestyle=\"--\")\n\n        lines = g.axes[0, 0].lines\n        assert len(g.axes[0, 0].lines) == 3\n\n        line1, _, _ = lines\n        assert line1.get_linestyle() == \"--\"\n        x, y = line1.get_data()\n        mask = (self.df.a == \"a\") & (self.df.b == \"m\") & (self.df.c == \"t\")\n        npt.assert_array_equal(x, self.df.x[mask])\n        npt.assert_array_equal(y, self.df.y[mask])\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_map_dataframe", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "def", "plot", "x", "y", "data", "none", "kws", "plt", "plot", "data", "x", "data", "y", "kws", "modify", "__module__", "so", "this", "doesn", "t", "look", "like", "a", "seaborn", "function", "plot", "__module__", "test", "g", "map_dataframe", "plot", "x", "y", "linestyle", "lines", "g", "axes", "0", "0", "lines", "assert", "len", "g", "axes", "0", "0", "lines", "3", "line1", "_", "_", "lines", "assert", "line1", "get_linestyle", "x", "y", "line1", "get_data", "mask", "self", "df", "a", "a", "self", "df", "b", "m", "self", "df", "c", "t", "npt", "assert_array_equal", "x", "self", "df", "x", "mask", "npt", "assert_array_equal", "y", "self", "df", "y", "mask"], "doc_len": 104}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_set", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_set", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_set(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        xlim = (-2, 5)\n        ylim = (3, 6)\n        xticks = [-2, 0, 3, 5]\n        yticks = [3, 4.5, 6]\n        g.set(xlim=xlim, ylim=ylim, xticks=xticks, yticks=yticks)\n        for ax in g.axes.flat:\n            npt.assert_array_equal(ax.get_xlim(), xlim)\n            npt.assert_array_equal(ax.get_ylim(), ylim)\n            npt.assert_array_equal(ax.get_xticks(), xticks)\n            npt.assert_array_equal(ax.get_yticks(), yticks)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_set", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "xlim", "2", "5", "ylim", "3", "6", "xticks", "2", "0", "3", "5", "yticks", "3", "4", "5", "6", "g", "set", "xlim", "xlim", "ylim", "ylim", "xticks", "xticks", "yticks", "yticks", "for", "ax", "in", "g", "axes", "flat", "npt", "assert_array_equal", "ax", "get_xlim", "xlim", "npt", "assert_array_equal", "ax", "get_ylim", "ylim", "npt", "assert_array_equal", "ax", "get_xticks", "xticks", "npt", "assert_array_equal", "ax", "get_yticks", "yticks"], "doc_len": 68}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_set_titles", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_set_titles", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_set_titles(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        g.map(plt.plot, \"x\", \"y\")\n\n        # Test the default titles\n        assert g.axes[0, 0].get_title() == \"a = a | b = m\"\n        assert g.axes[0, 1].get_title() == \"a = a | b = n\"\n        assert g.axes[1, 0].get_title() == \"a = b | b = m\"\n\n        # Test a provided title\n        g.set_titles(\"{row_var} == {row_name} \\\\/ {col_var} == {col_name}\")\n        assert g.axes[0, 0].get_title() == \"a == a \\\\/ b == m\"\n        assert g.axes[0, 1].get_title() == \"a == a \\\\/ b == n\"\n        assert g.axes[1, 0].get_title() == \"a == b \\\\/ b == m\"\n\n        # Test a single row\n        g = ag.FacetGrid(self.df, col=\"b\")\n        g.map(plt.plot, \"x\", \"y\")\n\n        # Test the default titles\n        assert g.axes[0, 0].get_title() == \"b = m\"\n        assert g.axes[0, 1].get_title() == \"b = n\"\n\n        # test with dropna=False\n        g = ag.FacetGrid(self.df, col=\"b\", hue=\"b\", dropna=False)\n        g.map(plt.plot, 'x', 'y')\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_set_titles", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "g", "map", "plt", "plot", "x", "y", "test", "the", "default", "titles", "assert", "g", "axes", "0", "0", "get_title", "a", "a", "b", "m", "assert", "g", "axes", "0", "1", "get_title", "a", "a", "b", "n", "assert", "g", "axes", "1", "0", "get_title", "a", "b", "b", "m", "test", "a", "provided", "title", "g", "set_titles", "row_var", "row_name", "col_var", "col_name", "assert", "g", "axes", "0", "0", "get_title", "a", "a", "b", "m", "assert", "g", "axes", "0", "1", "get_title", "a", "a", "b", "n", "assert", "g", "axes", "1", "0", "get_title", "a", "b", "b", "m", "test", "a", "single", "row", "g", "ag", "facetgrid", "self", "df", "col", "b", "g", "map", "plt", "plot", "x", "y", "test", "the", "default", "titles", "assert", "g", "axes", "0", "0", "get_title", "b", "m", "assert", "g", "axes", "0", "1", "get_title", "b", "n", "test", "with", "dropna", "false", "g", "ag", "facetgrid", "self", "df", "col", "b", "hue", "b", "dropna", "false", "g", "map", "plt", "plot", "x", "y"], "doc_len": 154}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_set_titles_margin_titles", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_set_titles_margin_titles", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_set_titles_margin_titles(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", margin_titles=True)\n        g.map(plt.plot, \"x\", \"y\")\n\n        # Test the default titles\n        assert g.axes[0, 0].get_title() == \"b = m\"\n        assert g.axes[0, 1].get_title() == \"b = n\"\n        assert g.axes[1, 0].get_title() == \"\"\n\n        # Test the row \"titles\"\n        assert g.axes[0, 1].texts[0].get_text() == \"a = a\"\n        assert g.axes[1, 1].texts[0].get_text() == \"a = b\"\n        assert g.axes[0, 1].texts[0] is g._margin_titles_texts[0]\n\n        # Test provided titles\n        g.set_titles(col_template=\"{col_name}\", row_template=\"{row_name}\")\n        assert g.axes[0, 0].get_title() == \"m\"\n        assert g.axes[0, 1].get_title() == \"n\"\n        assert g.axes[1, 0].get_title() == \"\"\n\n        assert len(g.axes[1, 1].texts) == 1\n        assert g.axes[1, 1].texts[0].get_text() == \"b\"\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_set_titles_margin_titles", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "margin_titles", "true", "g", "map", "plt", "plot", "x", "y", "test", "the", "default", "titles", "assert", "g", "axes", "0", "0", "get_title", "b", "m", "assert", "g", "axes", "0", "1", "get_title", "b", "n", "assert", "g", "axes", "1", "0", "get_title", "test", "the", "row", "titles", "assert", "g", "axes", "0", "1", "texts", "0", "get_text", "a", "a", "assert", "g", "axes", "1", "1", "texts", "0", "get_text", "a", "b", "assert", "g", "axes", "0", "1", "texts", "0", "is", "g", "_margin_titles_texts", "0", "test", "provided", "titles", "g", "set_titles", "col_template", "col_name", "row_template", "row_name", "assert", "g", "axes", "0", "0", "get_title", "m", "assert", "g", "axes", "0", "1", "get_title", "n", "assert", "g", "axes", "1", "0", "get_title", "assert", "len", "g", "axes", "1", "1", "texts", "1", "assert", "g", "axes", "1", "1", "texts", "0", "get_text", "b"], "doc_len": 131}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_set_ticklabels", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_set_ticklabels", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_set_ticklabels(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        g.map(plt.plot, \"x\", \"y\")\n\n        ax = g.axes[-1, 0]\n        xlab = [l.get_text() + \"h\" for l in ax.get_xticklabels()]\n        ylab = [l.get_text() + \"i\" for l in ax.get_yticklabels()]\n\n        g.set_xticklabels(xlab)\n        g.set_yticklabels(ylab)\n        got_x = [l.get_text() for l in g.axes[-1, 1].get_xticklabels()]\n        got_y = [l.get_text() for l in g.axes[0, 0].get_yticklabels()]\n        npt.assert_array_equal(got_x, xlab)\n        npt.assert_array_equal(got_y, ylab)\n\n        x, y = np.arange(10), np.arange(10)\n        df = pd.DataFrame(np.c_[x, y], columns=[\"x\", \"y\"])\n        g = ag.FacetGrid(df).map_dataframe(pointplot, x=\"x\", y=\"y\", order=x)\n        g.set_xticklabels(step=2)\n        got_x = [int(l.get_text()) for l in g.axes[0, 0].get_xticklabels()]\n        npt.assert_array_equal(x[::2], got_x)\n\n        g = ag.FacetGrid(self.df, col=\"d\", col_wrap=5)\n        g.map(plt.plot, \"x\", \"y\")\n        g.set_xticklabels(rotation=45)\n        g.set_yticklabels(rotation=75)\n        for ax in g._bottom_axes:\n            for l in ax.get_xticklabels():\n                assert l.get_rotation() == 45\n        for ax in g._left_axes:\n            for l in ax.get_yticklabels():\n                assert l.get_rotation() == 75\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_set_ticklabels", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "g", "map", "plt", "plot", "x", "y", "ax", "g", "axes", "1", "0", "xlab", "l", "get_text", "h", "for", "l", "in", "ax", "get_xticklabels", "ylab", "l", "get_text", "i", "for", "l", "in", "ax", "get_yticklabels", "g", "set_xticklabels", "xlab", "g", "set_yticklabels", "ylab", "got_x", "l", "get_text", "for", "l", "in", "g", "axes", "1", "1", "get_xticklabels", "got_y", "l", "get_text", "for", "l", "in", "g", "axes", "0", "0", "get_yticklabels", "npt", "assert_array_equal", "got_x", "xlab", "npt", "assert_array_equal", "got_y", "ylab", "x", "y", "np", "arange", "10", "np", "arange", "10", "df", "pd", "dataframe", "np", "c_", "x", "y", "columns", "x", "y", "g", "ag", "facetgrid", "df", "map_dataframe", "pointplot", "x", "x", "y", "y", "order", "x", "g", "set_xticklabels", "step", "2", "got_x", "int", "l", "get_text", "for", "l", "in", "g", "axes", "0", "0", "get_xticklabels", "npt", "assert_array_equal", "x", "2", "got_x", "g", "ag", "facetgrid", "self", "df", "col", "d", "col_wrap", "5", "g", "map", "plt", "plot", "x", "y", "g", "set_xticklabels", "rotation", "45", "g", "set_yticklabels", "rotation", "75", "for", "ax", "in", "g", "_bottom_axes", "for", "l", "in", "ax", "get_xticklabels", "assert", "l", "get_rotation", "45", "for", "ax", "in", "g", "_left_axes", "for", "l", "in", "ax", "get_yticklabels", "assert", "l", "get_rotation", "75"], "doc_len": 183}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_set_axis_labels", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_set_axis_labels", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_set_axis_labels(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        g.map(plt.plot, \"x\", \"y\")\n        xlab = 'xx'\n        ylab = 'yy'\n\n        g.set_axis_labels(xlab, ylab)\n\n        got_x = [ax.get_xlabel() for ax in g.axes[-1, :]]\n        got_y = [ax.get_ylabel() for ax in g.axes[:, 0]]\n        npt.assert_array_equal(got_x, xlab)\n        npt.assert_array_equal(got_y, ylab)\n\n        for ax in g.axes.flat:\n            ax.set(xlabel=\"x\", ylabel=\"y\")\n\n        g.set_axis_labels(xlab, ylab)\n        for ax in g._not_bottom_axes:\n            assert not ax.get_xlabel()\n        for ax in g._not_left_axes:\n            assert not ax.get_ylabel()\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_set_axis_labels", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "g", "map", "plt", "plot", "x", "y", "xlab", "xx", "ylab", "yy", "g", "set_axis_labels", "xlab", "ylab", "got_x", "ax", "get_xlabel", "for", "ax", "in", "g", "axes", "1", "got_y", "ax", "get_ylabel", "for", "ax", "in", "g", "axes", "0", "npt", "assert_array_equal", "got_x", "xlab", "npt", "assert_array_equal", "got_y", "ylab", "for", "ax", "in", "g", "axes", "flat", "ax", "set", "xlabel", "x", "ylabel", "y", "g", "set_axis_labels", "xlab", "ylab", "for", "ax", "in", "g", "_not_bottom_axes", "assert", "not", "ax", "get_xlabel", "for", "ax", "in", "g", "_not_left_axes", "assert", "not", "ax", "get_ylabel"], "doc_len": 90}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_axis_lims", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_axis_lims", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_axis_lims(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", xlim=(0, 4), ylim=(-2, 3))\n        assert g.axes[0, 0].get_xlim() == (0, 4)\n        assert g.axes[0, 0].get_ylim() == (-2, 3)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_axis_lims", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "xlim", "0", "4", "ylim", "2", "3", "assert", "g", "axes", "0", "0", "get_xlim", "0", "4", "assert", "g", "axes", "0", "0", "get_ylim", "2", "3"], "doc_len": 38}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_data_orders", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_data_orders", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_data_orders(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\")\n\n        assert g.row_names == list(\"abc\")\n        assert g.col_names == list(\"mn\")\n        assert g.hue_names == list(\"tuv\")\n        assert g.axes.shape == (3, 2)\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\",\n                         row_order=list(\"bca\"),\n                         col_order=list(\"nm\"),\n                         hue_order=list(\"vtu\"))\n\n        assert g.row_names == list(\"bca\")\n        assert g.col_names == list(\"nm\")\n        assert g.hue_names == list(\"vtu\")\n        assert g.axes.shape == (3, 2)\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\", hue=\"c\",\n                         row_order=list(\"bcda\"),\n                         col_order=list(\"nom\"),\n                         hue_order=list(\"qvtu\"))\n\n        assert g.row_names == list(\"bcda\")\n        assert g.col_names == list(\"nom\")\n        assert g.hue_names == list(\"qvtu\")\n        assert g.axes.shape == (4, 3)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_data_orders", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "assert", "g", "row_names", "list", "abc", "assert", "g", "col_names", "list", "mn", "assert", "g", "hue_names", "list", "tuv", "assert", "g", "axes", "shape", "3", "2", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "row_order", "list", "bca", "col_order", "list", "nm", "hue_order", "list", "vtu", "assert", "g", "row_names", "list", "bca", "assert", "g", "col_names", "list", "nm", "assert", "g", "hue_names", "list", "vtu", "assert", "g", "axes", "shape", "3", "2", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "hue", "c", "row_order", "list", "bcda", "col_order", "list", "nom", "hue_order", "list", "qvtu", "assert", "g", "row_names", "list", "bcda", "assert", "g", "col_names", "list", "nom", "assert", "g", "hue_names", "list", "qvtu", "assert", "g", "axes", "shape", "4", "3"], "doc_len": 121}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_palette", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_palette", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_palette(self):\n\n        rcmod.set()\n\n        g = ag.FacetGrid(self.df, hue=\"c\")\n        assert g._colors == color_palette(n_colors=len(self.df.c.unique()))\n\n        g = ag.FacetGrid(self.df, hue=\"d\")\n        assert g._colors == color_palette(\"husl\", len(self.df.d.unique()))\n\n        g = ag.FacetGrid(self.df, hue=\"c\", palette=\"Set2\")\n        assert g._colors == color_palette(\"Set2\", len(self.df.c.unique()))\n\n        dict_pal = dict(t=\"red\", u=\"green\", v=\"blue\")\n        list_pal = color_palette([\"red\", \"green\", \"blue\"], 3)\n        g = ag.FacetGrid(self.df, hue=\"c\", palette=dict_pal)\n        assert g._colors == list_pal\n\n        list_pal = color_palette([\"green\", \"blue\", \"red\"], 3)\n        g = ag.FacetGrid(self.df, hue=\"c\", hue_order=list(\"uvt\"),\n                         palette=dict_pal)\n        assert g._colors == list_pal\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_palette", "self", "rcmod", "set", "g", "ag", "facetgrid", "self", "df", "hue", "c", "assert", "g", "_colors", "color_palette", "n_colors", "len", "self", "df", "c", "unique", "g", "ag", "facetgrid", "self", "df", "hue", "d", "assert", "g", "_colors", "color_palette", "husl", "len", "self", "df", "d", "unique", "g", "ag", "facetgrid", "self", "df", "hue", "c", "palette", "set2", "assert", "g", "_colors", "color_palette", "set2", "len", "self", "df", "c", "unique", "dict_pal", "dict", "t", "red", "u", "green", "v", "blue", "list_pal", "color_palette", "red", "green", "blue", "3", "g", "ag", "facetgrid", "self", "df", "hue", "c", "palette", "dict_pal", "assert", "g", "_colors", "list_pal", "list_pal", "color_palette", "green", "blue", "red", "3", "g", "ag", "facetgrid", "self", "df", "hue", "c", "hue_order", "list", "uvt", "palette", "dict_pal", "assert", "g", "_colors", "list_pal"], "doc_len": 111}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_hue_kws", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_hue_kws", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_hue_kws(self):\n\n        kws = dict(marker=[\"o\", \"s\", \"D\"])\n        g = ag.FacetGrid(self.df, hue=\"c\", hue_kws=kws)\n        g.map(plt.plot, \"x\", \"y\")\n\n        for line, marker in zip(g.axes[0, 0].lines, kws[\"marker\"]):\n            assert line.get_marker() == marker\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_hue_kws", "self", "kws", "dict", "marker", "o", "s", "d", "g", "ag", "facetgrid", "self", "df", "hue", "c", "hue_kws", "kws", "g", "map", "plt", "plot", "x", "y", "for", "line", "marker", "in", "zip", "g", "axes", "0", "0", "lines", "kws", "marker", "assert", "line", "get_marker", "marker"], "doc_len": 44}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_dropna", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_dropna", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_dropna(self):\n\n        df = self.df.copy()\n        hasna = pd.Series(np.tile(np.arange(6), 10), dtype=float)\n        hasna[hasna == 5] = np.nan\n        df[\"hasna\"] = hasna\n        g = ag.FacetGrid(df, dropna=False, row=\"hasna\")\n        assert g._not_na.sum() == 60\n\n        g = ag.FacetGrid(df, dropna=True, row=\"hasna\")\n        assert g._not_na.sum() == 50\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_dropna", "self", "df", "self", "df", "copy", "hasna", "pd", "series", "np", "tile", "np", "arange", "6", "10", "dtype", "float", "hasna", "hasna", "5", "np", "nan", "df", "hasna", "hasna", "g", "ag", "facetgrid", "df", "dropna", "false", "row", "hasna", "assert", "g", "_not_na", "sum", "60", "g", "ag", "facetgrid", "df", "dropna", "true", "row", "hasna", "assert", "g", "_not_na", "sum", "50"], "doc_len": 56}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_categorical_column_missing_categories", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_categorical_column_missing_categories", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_categorical_column_missing_categories(self):\n\n        df = self.df.copy()\n        df['a'] = df['a'].astype('category')\n\n        g = ag.FacetGrid(df[df['a'] == 'a'], col=\"a\", col_wrap=1)\n\n        assert g.axes.shape == (len(df['a'].cat.categories),)\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_categorical_column_missing_categories", "self", "df", "self", "df", "copy", "df", "a", "df", "a", "astype", "category", "g", "ag", "facetgrid", "df", "df", "a", "a", "col", "a", "col_wrap", "1", "assert", "g", "axes", "shape", "len", "df", "a", "cat", "categories"], "doc_len": 37}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_categorical_warning", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_categorical_warning", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_categorical_warning(self):\n\n        g = ag.FacetGrid(self.df, col=\"b\")\n        with pytest.warns(UserWarning):\n            g.map(pointplot, \"b\", \"x\")\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_categorical_warning", "self", "g", "ag", "facetgrid", "self", "df", "col", "b", "with", "pytest", "warns", "userwarning", "g", "map", "pointplot", "b", "x"], "doc_len": 23}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_refline", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_refline", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_refline(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        g.refline()\n        for ax in g.axes.flat:\n            assert not ax.lines\n\n        refx = refy = 0.5\n        hline = np.array([[0, refy], [1, refy]])\n        vline = np.array([[refx, 0], [refx, 1]])\n        g.refline(x=refx, y=refy)\n        for ax in g.axes.flat:\n            assert ax.lines[0].get_color() == '.5'\n            assert ax.lines[0].get_linestyle() == '--'\n            assert len(ax.lines) == 2\n            npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n            npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n\n        color, linestyle = 'red', '-'\n        g.refline(x=refx, color=color, linestyle=linestyle)\n        npt.assert_array_equal(g.axes[0, 0].lines[-1].get_xydata(), vline)\n        assert g.axes[0, 0].lines[-1].get_color() == color\n        assert g.axes[0, 0].lines[-1].get_linestyle() == linestyle\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_refline", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "g", "refline", "for", "ax", "in", "g", "axes", "flat", "assert", "not", "ax", "lines", "refx", "refy", "0", "5", "hline", "np", "array", "0", "refy", "1", "refy", "vline", "np", "array", "refx", "0", "refx", "1", "g", "refline", "x", "refx", "y", "refy", "for", "ax", "in", "g", "axes", "flat", "assert", "ax", "lines", "0", "get_color", "5", "assert", "ax", "lines", "0", "get_linestyle", "assert", "len", "ax", "lines", "2", "npt", "assert_array_equal", "ax", "lines", "0", "get_xydata", "vline", "npt", "assert_array_equal", "ax", "lines", "1", "get_xydata", "hline", "color", "linestyle", "red", "g", "refline", "x", "refx", "color", "color", "linestyle", "linestyle", "npt", "assert_array_equal", "g", "axes", "0", "0", "lines", "1", "get_xydata", "vline", "assert", "g", "axes", "0", "0", "lines", "1", "get_color", "color", "assert", "g", "axes", "0", "0", "lines", "1", "get_linestyle", "linestyle"], "doc_len": 127}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_apply", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_apply", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_apply(self, long_df):\n\n        def f(grid, color):\n            grid.figure.set_facecolor(color)\n\n        color = (.1, .6, .3, .9)\n        g = ag.FacetGrid(long_df)\n        res = g.apply(f, color)\n        assert res is g\n        assert g.figure.get_facecolor() == color\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_apply", "self", "long_df", "def", "f", "grid", "color", "grid", "figure", "set_facecolor", "color", "color", "1", "6", "3", "9", "g", "ag", "facetgrid", "long_df", "res", "g", "apply", "f", "color", "assert", "res", "is", "g", "assert", "g", "figure", "get_facecolor", "color"], "doc_len": 39}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_pipe", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_pipe", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_pipe(self, long_df):\n\n        def f(grid, color):\n            grid.figure.set_facecolor(color)\n            return color\n\n        color = (.1, .6, .3, .9)\n        g = ag.FacetGrid(long_df)\n        res = g.pipe(f, color)\n        assert res == color\n        assert g.figure.get_facecolor() == color\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_pipe", "self", "long_df", "def", "f", "grid", "color", "grid", "figure", "set_facecolor", "color", "return", "color", "color", "1", "6", "3", "9", "g", "ag", "facetgrid", "long_df", "res", "g", "pipe", "f", "color", "assert", "res", "color", "assert", "g", "figure", "get_facecolor", "color"], "doc_len": 40}
{"doc_id": "tests/test_axisgrid.py::TestFacetGrid.test_tick_params", "file_path": "tests/test_axisgrid.py", "class_name": "TestFacetGrid", "func_name": "test_tick_params", "text": "文件路径: tests/test_axisgrid.py, 类名: TestFacetGrid\n    def test_tick_params(self):\n\n        g = ag.FacetGrid(self.df, row=\"a\", col=\"b\")\n        color = \"blue\"\n        pad = 3\n        g.tick_params(pad=pad, color=color)\n        for ax in g.axes.flat:\n            for axis in [\"xaxis\", \"yaxis\"]:\n                for tick in getattr(ax, axis).get_major_ticks():\n                    assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                    assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                    assert tick.get_pad() == pad\n", "tokens": ["tests", "test_axisgrid", "py", "testfacetgrid", "def", "test_tick_params", "self", "g", "ag", "facetgrid", "self", "df", "row", "a", "col", "b", "color", "blue", "pad", "3", "g", "tick_params", "pad", "pad", "color", "color", "for", "ax", "in", "g", "axes", "flat", "for", "axis", "in", "xaxis", "yaxis", "for", "tick", "in", "getattr", "ax", "axis", "get_major_ticks", "assert", "mpl", "colors", "same_color", "tick", "tick1line", "get_color", "color", "assert", "mpl", "colors", "same_color", "tick", "tick2line", "get_color", "color", "assert", "tick", "get_pad", "pad"], "doc_len": 64}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_self_data", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_self_data", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_self_data(self):\n\n        g = ag.PairGrid(self.df)\n        assert g.data is self.df\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_self_data", "self", "g", "ag", "pairgrid", "self", "df", "assert", "g", "data", "is", "self", "df"], "doc_len": 18}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_ignore_datelike_data", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_ignore_datelike_data", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_ignore_datelike_data(self):\n\n        df = self.df.copy()\n        df['date'] = pd.date_range('2010-01-01', periods=len(df), freq='d')\n        result = ag.PairGrid(self.df).data\n        expected = df.drop('date', axis=1)\n        tm.assert_frame_equal(result, expected)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_ignore_datelike_data", "self", "df", "self", "df", "copy", "df", "date", "pd", "date_range", "2010", "01", "01", "periods", "len", "df", "freq", "d", "result", "ag", "pairgrid", "self", "df", "data", "expected", "df", "drop", "date", "axis", "1", "tm", "assert_frame_equal", "result", "expected"], "doc_len": 39}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_self_figure", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_self_figure", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_self_figure(self):\n\n        g = ag.PairGrid(self.df)\n        assert isinstance(g.figure, plt.Figure)\n        assert g.figure is g._figure\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_self_figure", "self", "g", "ag", "pairgrid", "self", "df", "assert", "isinstance", "g", "figure", "plt", "figure", "assert", "g", "figure", "is", "g", "_figure"], "doc_len": 24}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_self_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_self_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_self_axes(self):\n\n        g = ag.PairGrid(self.df)\n        for ax in g.axes.flat:\n            assert isinstance(ax, plt.Axes)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_self_axes", "self", "g", "ag", "pairgrid", "self", "df", "for", "ax", "in", "g", "axes", "flat", "assert", "isinstance", "ax", "plt", "axes"], "doc_len": 23}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_default_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_default_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_default_axes(self):\n\n        g = ag.PairGrid(self.df)\n        assert g.axes.shape == (3, 3)\n        assert g.x_vars == [\"x\", \"y\", \"z\"]\n        assert g.y_vars == [\"x\", \"y\", \"z\"]\n        assert g.square_grid\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_default_axes", "self", "g", "ag", "pairgrid", "self", "df", "assert", "g", "axes", "shape", "3", "3", "assert", "g", "x_vars", "x", "y", "z", "assert", "g", "y_vars", "x", "y", "z", "assert", "g", "square_grid"], "doc_len": 33}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_specific_square_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_specific_square_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_specific_square_axes(self, vars):\n\n        g = ag.PairGrid(self.df, vars=vars)\n        assert g.axes.shape == (len(vars), len(vars))\n        assert g.x_vars == list(vars)\n        assert g.y_vars == list(vars)\n        assert g.square_grid\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_specific_square_axes", "self", "vars", "g", "ag", "pairgrid", "self", "df", "vars", "vars", "assert", "g", "axes", "shape", "len", "vars", "len", "vars", "assert", "g", "x_vars", "list", "vars", "assert", "g", "y_vars", "list", "vars", "assert", "g", "square_grid"], "doc_len": 36}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_remove_hue_from_default", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_remove_hue_from_default", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_remove_hue_from_default(self):\n\n        hue = \"z\"\n        g = ag.PairGrid(self.df, hue=hue)\n        assert hue not in g.x_vars\n        assert hue not in g.y_vars\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, hue=hue, vars=vars)\n        assert hue in g.x_vars\n        assert hue in g.y_vars\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_remove_hue_from_default", "self", "hue", "z", "g", "ag", "pairgrid", "self", "df", "hue", "hue", "assert", "hue", "not", "in", "g", "x_vars", "assert", "hue", "not", "in", "g", "y_vars", "vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "hue", "hue", "vars", "vars", "assert", "hue", "in", "g", "x_vars", "assert", "hue", "in", "g", "y_vars"], "doc_len": 51}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_specific_nonsquare_axes", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_specific_nonsquare_axes", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_specific_nonsquare_axes(self, x_vars, y_vars):\n\n        g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        assert g.axes.shape == (len(y_vars), len(x_vars))\n        assert g.x_vars == list(x_vars)\n        assert g.y_vars == list(y_vars)\n        assert not g.square_grid\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_specific_nonsquare_axes", "self", "x_vars", "y_vars", "g", "ag", "pairgrid", "self", "df", "x_vars", "x_vars", "y_vars", "y_vars", "assert", "g", "axes", "shape", "len", "y_vars", "len", "x_vars", "assert", "g", "x_vars", "list", "x_vars", "assert", "g", "y_vars", "list", "y_vars", "assert", "not", "g", "square_grid"], "doc_len": 40}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_corner", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_corner", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_corner(self):\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n        corner_size = sum(i + 1 for i in range(len(plot_vars)))\n        assert len(g.figure.axes) == corner_size\n\n        g.map_diag(plt.hist)\n        assert len(g.figure.axes) == (corner_size + len(plot_vars))\n\n        for ax in np.diag(g.axes):\n            assert not ax.yaxis.get_visible()\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n        g.map(scatterplot)\n        assert len(g.figure.axes) == corner_size\n        assert g.axes[0, 0].get_ylabel() == \"x\"\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_corner", "self", "plot_vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "vars", "plot_vars", "corner", "true", "corner_size", "sum", "i", "1", "for", "i", "in", "range", "len", "plot_vars", "assert", "len", "g", "figure", "axes", "corner_size", "g", "map_diag", "plt", "hist", "assert", "len", "g", "figure", "axes", "corner_size", "len", "plot_vars", "for", "ax", "in", "np", "diag", "g", "axes", "assert", "not", "ax", "yaxis", "get_visible", "plot_vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "vars", "plot_vars", "corner", "true", "g", "map", "scatterplot", "assert", "len", "g", "figure", "axes", "corner_size", "assert", "g", "axes", "0", "0", "get_ylabel", "x"], "doc_len": 89}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_size", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_size", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_size(self):\n\n        g1 = ag.PairGrid(self.df, height=3)\n        npt.assert_array_equal(g1.fig.get_size_inches(), (9, 9))\n\n        g2 = ag.PairGrid(self.df, height=4, aspect=.5)\n        npt.assert_array_equal(g2.fig.get_size_inches(), (6, 12))\n\n        g3 = ag.PairGrid(self.df, y_vars=[\"z\"], x_vars=[\"x\", \"y\"],\n                         height=2, aspect=2)\n        npt.assert_array_equal(g3.fig.get_size_inches(), (8, 2))\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_size", "self", "g1", "ag", "pairgrid", "self", "df", "height", "3", "npt", "assert_array_equal", "g1", "fig", "get_size_inches", "9", "9", "g2", "ag", "pairgrid", "self", "df", "height", "4", "aspect", "5", "npt", "assert_array_equal", "g2", "fig", "get_size_inches", "6", "12", "g3", "ag", "pairgrid", "self", "df", "y_vars", "z", "x_vars", "x", "y", "height", "2", "aspect", "2", "npt", "assert_array_equal", "g3", "fig", "get_size_inches", "8", "2"], "doc_len": 58}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_empty_grid", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_empty_grid", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_empty_grid(self):\n\n        with pytest.raises(ValueError, match=\"No variables found\"):\n            ag.PairGrid(self.df[[\"a\", \"b\"]])\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_empty_grid", "self", "with", "pytest", "raises", "valueerror", "match", "no", "variables", "found", "ag", "pairgrid", "self", "df", "a", "b"], "doc_len": 21}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g1 = ag.PairGrid(self.df)\n        g1.map(plt.scatter)\n\n        for i, axes_i in enumerate(g1.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[vars[j]]\n                y_in = self.df[vars[i]]\n                x_out, y_out = ax.collections[0].get_offsets().T\n                npt.assert_array_equal(x_in, x_out)\n                npt.assert_array_equal(y_in, y_out)\n\n        g2 = ag.PairGrid(self.df, hue=\"a\")\n        g2.map(plt.scatter)\n\n        for i, axes_i in enumerate(g2.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[vars[j]]\n                y_in = self.df[vars[i]]\n                for k, k_level in enumerate(self.df.a.unique()):\n                    x_in_k = x_in[self.df.a == k_level]\n                    y_in_k = y_in[self.df.a == k_level]\n                    x_out, y_out = ax.collections[k].get_offsets().T\n                npt.assert_array_equal(x_in_k, x_out)\n                npt.assert_array_equal(y_in_k, y_out)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map", "self", "vars", "x", "y", "z", "g1", "ag", "pairgrid", "self", "df", "g1", "map", "plt", "scatter", "for", "i", "axes_i", "in", "enumerate", "g1", "axes", "for", "j", "ax", "in", "enumerate", "axes_i", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "g2", "ag", "pairgrid", "self", "df", "hue", "a", "g2", "map", "plt", "scatter", "for", "i", "axes_i", "in", "enumerate", "g2", "axes", "for", "j", "ax", "in", "enumerate", "axes_i", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "for", "k", "k_level", "in", "enumerate", "self", "df", "a", "unique", "x_in_k", "x_in", "self", "df", "a", "k_level", "y_in_k", "y_in", "self", "df", "a", "k_level", "x_out", "y_out", "ax", "collections", "k", "get_offsets", "t", "npt", "assert_array_equal", "x_in_k", "x_out", "npt", "assert_array_equal", "y_in_k", "y_out"], "doc_len": 128}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_nonsquare", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_nonsquare", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_nonsquare(self):\n\n        x_vars = [\"x\"]\n        y_vars = [\"y\", \"z\"]\n        g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g.map(plt.scatter)\n\n        x_in = self.df.x\n        for i, i_var in enumerate(y_vars):\n            ax = g.axes[i, 0]\n            y_in = self.df[i_var]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_nonsquare", "self", "x_vars", "x", "y_vars", "y", "z", "g", "ag", "pairgrid", "self", "df", "x_vars", "x_vars", "y_vars", "y_vars", "g", "map", "plt", "scatter", "x_in", "self", "df", "x", "for", "i", "i_var", "in", "enumerate", "y_vars", "ax", "g", "axes", "i", "0", "y_in", "self", "df", "i_var", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out"], "doc_len": 59}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_lower", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_lower", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_lower(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df)\n        g.map_lower(plt.scatter)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.triu_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_lower", "self", "vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "g", "map_lower", "plt", "scatter", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0"], "doc_len": 79}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_upper", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_upper", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_upper(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df)\n        g.map_upper(plt.scatter)\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_upper", "self", "vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "g", "map_upper", "plt", "scatter", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0"], "doc_len": 79}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_mixed_funcsig", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_mixed_funcsig", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_mixed_funcsig(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df, vars=vars)\n        g.map_lower(scatterplot)\n        g.map_upper(plt.scatter)\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_mixed_funcsig", "self", "vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "vars", "vars", "g", "map_lower", "scatterplot", "g", "map_upper", "plt", "scatter", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out"], "doc_len": 65}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag(self):\n\n        g = ag.PairGrid(self.df)\n        g.map_diag(plt.hist)\n\n        for var, ax in zip(g.diag_vars, g.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        g = ag.PairGrid(self.df, hue=\"a\")\n        g.map_diag(plt.hist)\n\n        for ax in g.diag_axes:\n            assert len(ax.patches) == 30\n\n        g = ag.PairGrid(self.df, hue=\"a\")\n        g.map_diag(plt.hist, histtype='step')\n\n        for ax in g.diag_axes:\n            for ptch in ax.patches:\n                assert not ptch.fill\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag", "self", "g", "ag", "pairgrid", "self", "df", "g", "map_diag", "plt", "hist", "for", "var", "ax", "in", "zip", "g", "diag_vars", "g", "diag_axes", "assert", "len", "ax", "patches", "10", "assert", "pytest", "approx", "ax", "patches", "0", "get_x", "self", "df", "var", "min", "g", "ag", "pairgrid", "self", "df", "hue", "a", "g", "map_diag", "plt", "hist", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "30", "g", "ag", "pairgrid", "self", "df", "hue", "a", "g", "map_diag", "plt", "hist", "histtype", "step", "for", "ax", "in", "g", "diag_axes", "for", "ptch", "in", "ax", "patches", "assert", "not", "ptch", "fill"], "doc_len": 89}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag_rectangular", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag_rectangular", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag_rectangular(self):\n\n        x_vars = [\"x\", \"y\"]\n        y_vars = [\"x\", \"z\", \"y\"]\n        g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g1.map_diag(plt.hist)\n        g1.map_offdiag(plt.scatter)\n\n        assert set(g1.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for var, ax in zip(g1.diag_vars, g1.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        for j, x_var in enumerate(x_vars):\n            for i, y_var in enumerate(y_vars):\n\n                ax = g1.axes[i, j]\n                if x_var == y_var:\n                    diag_ax = g1.diag_axes[j]  # because fewer x than y vars\n                    assert ax.bbox.bounds == diag_ax.bbox.bounds\n\n                else:\n                    x, y = ax.collections[0].get_offsets().T\n                    assert_array_equal(x, self.df[x_var])\n                    assert_array_equal(y, self.df[y_var])\n\n        g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue=\"a\")\n        g2.map_diag(plt.hist)\n        g2.map_offdiag(plt.scatter)\n\n        assert set(g2.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for ax in g2.diag_axes:\n            assert len(ax.patches) == 30\n\n        x_vars = [\"x\", \"y\", \"z\"]\n        y_vars = [\"x\", \"z\"]\n        g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n        g3.map_diag(plt.hist)\n        g3.map_offdiag(plt.scatter)\n\n        assert set(g3.diag_vars) == (set(x_vars) & set(y_vars))\n\n        for var, ax in zip(g3.diag_vars, g3.diag_axes):\n            assert len(ax.patches) == 10\n            assert pytest.approx(ax.patches[0].get_x()) == self.df[var].min()\n\n        for j, x_var in enumerate(x_vars):\n            for i, y_var in enumerate(y_vars):\n\n                ax = g3.axes[i, j]\n                if x_var == y_var:\n                    diag_ax = g3.diag_axes[i]  # because fewer y than x vars\n                    assert ax.bbox.bounds == diag_ax.bbox.bounds\n                else:\n                    x, y = ax.collections[0].get_offsets().T\n                    assert_array_equal(x, self.df[x_var])\n                    assert_array_equal(y, self.df[y_var])\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag_rectangular", "self", "x_vars", "x", "y", "y_vars", "x", "z", "y", "g1", "ag", "pairgrid", "self", "df", "x_vars", "x_vars", "y_vars", "y_vars", "g1", "map_diag", "plt", "hist", "g1", "map_offdiag", "plt", "scatter", "assert", "set", "g1", "diag_vars", "set", "x_vars", "set", "y_vars", "for", "var", "ax", "in", "zip", "g1", "diag_vars", "g1", "diag_axes", "assert", "len", "ax", "patches", "10", "assert", "pytest", "approx", "ax", "patches", "0", "get_x", "self", "df", "var", "min", "for", "j", "x_var", "in", "enumerate", "x_vars", "for", "i", "y_var", "in", "enumerate", "y_vars", "ax", "g1", "axes", "i", "j", "if", "x_var", "y_var", "diag_ax", "g1", "diag_axes", "j", "because", "fewer", "x", "than", "y", "vars", "assert", "ax", "bbox", "bounds", "diag_ax", "bbox", "bounds", "else", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "self", "df", "x_var", "assert_array_equal", "y", "self", "df", "y_var", "g2", "ag", "pairgrid", "self", "df", "x_vars", "x_vars", "y_vars", "y_vars", "hue", "a", "g2", "map_diag", "plt", "hist", "g2", "map_offdiag", "plt", "scatter", "assert", "set", "g2", "diag_vars", "set", "x_vars", "set", "y_vars", "for", "ax", "in", "g2", "diag_axes", "assert", "len", "ax", "patches", "30", "x_vars", "x", "y", "z", "y_vars", "x", "z", "g3", "ag", "pairgrid", "self", "df", "x_vars", "x_vars", "y_vars", "y_vars", "g3", "map_diag", "plt", "hist", "g3", "map_offdiag", "plt", "scatter", "assert", "set", "g3", "diag_vars", "set", "x_vars", "set", "y_vars", "for", "var", "ax", "in", "zip", "g3", "diag_vars", "g3", "diag_axes", "assert", "len", "ax", "patches", "10", "assert", "pytest", "approx", "ax", "patches", "0", "get_x", "self", "df", "var", "min", "for", "j", "x_var", "in", "enumerate", "x_vars", "for", "i", "y_var", "in", "enumerate", "y_vars", "ax", "g3", "axes", "i", "j", "if", "x_var", "y_var", "diag_ax", "g3", "diag_axes", "i", "because", "fewer", "y", "than", "x", "vars", "assert", "ax", "bbox", "bounds", "diag_ax", "bbox", "bounds", "else", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "self", "df", "x_var", "assert_array_equal", "y", "self", "df", "y_var"], "doc_len": 268}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag_color", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag_color", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag_color(self):\n\n        color = \"red\"\n\n        g1 = ag.PairGrid(self.df)\n        g1.map_diag(plt.hist, color=color)\n\n        for ax in g1.diag_axes:\n            for patch in ax.patches:\n                assert_colors_equal(patch.get_facecolor(), color)\n\n        g2 = ag.PairGrid(self.df)\n        g2.map_diag(kdeplot, color='red')\n\n        for ax in g2.diag_axes:\n            for line in ax.lines:\n                assert_colors_equal(line.get_color(), color)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag_color", "self", "color", "red", "g1", "ag", "pairgrid", "self", "df", "g1", "map_diag", "plt", "hist", "color", "color", "for", "ax", "in", "g1", "diag_axes", "for", "patch", "in", "ax", "patches", "assert_colors_equal", "patch", "get_facecolor", "color", "g2", "ag", "pairgrid", "self", "df", "g2", "map_diag", "kdeplot", "color", "red", "for", "ax", "in", "g2", "diag_axes", "for", "line", "in", "ax", "lines", "assert_colors_equal", "line", "get_color", "color"], "doc_len": 58}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag_palette", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag_palette", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag_palette(self):\n\n        palette = \"muted\"\n        pal = color_palette(palette, n_colors=len(self.df.a.unique()))\n        g = ag.PairGrid(self.df, hue=\"a\", palette=palette)\n        g.map_diag(kdeplot)\n\n        for ax in g.diag_axes:\n            for line, color in zip(ax.lines[::-1], pal):\n                assert_colors_equal(line.get_color(), color)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag_palette", "self", "palette", "muted", "pal", "color_palette", "palette", "n_colors", "len", "self", "df", "a", "unique", "g", "ag", "pairgrid", "self", "df", "hue", "a", "palette", "palette", "g", "map_diag", "kdeplot", "for", "ax", "in", "g", "diag_axes", "for", "line", "color", "in", "zip", "ax", "lines", "1", "pal", "assert_colors_equal", "line", "get_color", "color"], "doc_len": 48}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag_and_offdiag", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag_and_offdiag", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag_and_offdiag(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.PairGrid(self.df)\n        g.map_offdiag(plt.scatter)\n        g.map_diag(plt.hist)\n\n        for ax in g.diag_axes:\n            assert len(ax.patches) == 10\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag_and_offdiag", "self", "vars", "x", "y", "z", "g", "ag", "pairgrid", "self", "df", "g", "map_offdiag", "plt", "scatter", "g", "map_diag", "plt", "hist", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "10", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "diag_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0"], "doc_len": 133}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_diag_sharey", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_diag_sharey", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_diag_sharey(self):\n\n        g = ag.PairGrid(self.df, diag_sharey=True)\n        g.map_diag(kdeplot)\n        for ax in g.diag_axes[1:]:\n            assert ax.get_ylim() == g.diag_axes[0].get_ylim()\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_diag_sharey", "self", "g", "ag", "pairgrid", "self", "df", "diag_sharey", "true", "g", "map_diag", "kdeplot", "for", "ax", "in", "g", "diag_axes", "1", "assert", "ax", "get_ylim", "g", "diag_axes", "0", "get_ylim"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_map_diag_matplotlib", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_map_diag_matplotlib", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_map_diag_matplotlib(self):\n\n        bins = 10\n        g = ag.PairGrid(self.df)\n        g.map_diag(plt.hist, bins=bins)\n        for ax in g.diag_axes:\n            assert len(ax.patches) == bins\n\n        levels = len(self.df[\"a\"].unique())\n        g = ag.PairGrid(self.df, hue=\"a\")\n        g.map_diag(plt.hist, bins=bins)\n        for ax in g.diag_axes:\n            assert len(ax.patches) == (bins * levels)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_map_diag_matplotlib", "self", "bins", "10", "g", "ag", "pairgrid", "self", "df", "g", "map_diag", "plt", "hist", "bins", "bins", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "bins", "levels", "len", "self", "df", "a", "unique", "g", "ag", "pairgrid", "self", "df", "hue", "a", "g", "map_diag", "plt", "hist", "bins", "bins", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "bins", "levels"], "doc_len": 60}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_palette", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_palette", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_palette(self):\n\n        rcmod.set()\n\n        g = ag.PairGrid(self.df, hue=\"a\")\n        assert g.palette == color_palette(n_colors=len(self.df.a.unique()))\n\n        g = ag.PairGrid(self.df, hue=\"b\")\n        assert g.palette == color_palette(\"husl\", len(self.df.b.unique()))\n\n        g = ag.PairGrid(self.df, hue=\"a\", palette=\"Set2\")\n        assert g.palette == color_palette(\"Set2\", len(self.df.a.unique()))\n\n        dict_pal = dict(a=\"red\", b=\"green\", c=\"blue\")\n        list_pal = color_palette([\"red\", \"green\", \"blue\"])\n        g = ag.PairGrid(self.df, hue=\"a\", palette=dict_pal)\n        assert g.palette == list_pal\n\n        list_pal = color_palette([\"blue\", \"red\", \"green\"])\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=list(\"cab\"),\n                        palette=dict_pal)\n        assert g.palette == list_pal\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_palette", "self", "rcmod", "set", "g", "ag", "pairgrid", "self", "df", "hue", "a", "assert", "g", "palette", "color_palette", "n_colors", "len", "self", "df", "a", "unique", "g", "ag", "pairgrid", "self", "df", "hue", "b", "assert", "g", "palette", "color_palette", "husl", "len", "self", "df", "b", "unique", "g", "ag", "pairgrid", "self", "df", "hue", "a", "palette", "set2", "assert", "g", "palette", "color_palette", "set2", "len", "self", "df", "a", "unique", "dict_pal", "dict", "a", "red", "b", "green", "c", "blue", "list_pal", "color_palette", "red", "green", "blue", "g", "ag", "pairgrid", "self", "df", "hue", "a", "palette", "dict_pal", "assert", "g", "palette", "list_pal", "list_pal", "color_palette", "blue", "red", "green", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "list", "cab", "palette", "dict_pal", "assert", "g", "palette", "list_pal"], "doc_len": 109}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_hue_kws", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_hue_kws", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_hue_kws(self):\n\n        kws = dict(marker=[\"o\", \"s\", \"d\", \"+\"])\n        g = ag.PairGrid(self.df, hue=\"a\", hue_kws=kws)\n        g.map(plt.plot)\n\n        for line, marker in zip(g.axes[0, 0].lines, kws[\"marker\"]):\n            assert line.get_marker() == marker\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_kws=kws,\n                        hue_order=list(\"dcab\"))\n        g.map(plt.plot)\n\n        for line, marker in zip(g.axes[0, 0].lines, kws[\"marker\"]):\n            assert line.get_marker() == marker\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_hue_kws", "self", "kws", "dict", "marker", "o", "s", "d", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_kws", "kws", "g", "map", "plt", "plot", "for", "line", "marker", "in", "zip", "g", "axes", "0", "0", "lines", "kws", "marker", "assert", "line", "get_marker", "marker", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_kws", "kws", "hue_order", "list", "dcab", "g", "map", "plt", "plot", "for", "line", "marker", "in", "zip", "g", "axes", "0", "0", "lines", "kws", "marker", "assert", "line", "get_marker", "marker"], "doc_len": 74}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_hue_order", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_hue_order", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_hue_order(self):\n\n        order = list(\"dcab\")\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_diag(plt.plot)\n\n        for line, level in zip(g.axes[0, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_lower(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_upper(plt.plot)\n\n        for line, level in zip(g.axes[0, 1].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"y\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_hue_order", "self", "order", "list", "dcab", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "1", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "y", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_diag", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "0", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "x", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_lower", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "1", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "y", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_upper", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "0", "1", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "y", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "x", "plt", "close", "all"], "doc_len": 226}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_hue_order_missing_level", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_hue_order_missing_level", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_hue_order_missing_level(self):\n\n        order = list(\"dcaeb\")\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_diag(plt.plot)\n\n        for line, level in zip(g.axes[0, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_lower(plt.plot)\n\n        for line, level in zip(g.axes[1, 0].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"x\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"y\"])\n\n        plt.close(\"all\")\n\n        g = ag.PairGrid(self.df, hue=\"a\", hue_order=order)\n        g.map_upper(plt.plot)\n\n        for line, level in zip(g.axes[0, 1].lines, order):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, self.df.loc[self.df.a == level, \"y\"])\n            npt.assert_array_equal(y, self.df.loc[self.df.a == level, \"x\"])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_hue_order_missing_level", "self", "order", "list", "dcaeb", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "1", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "y", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_diag", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "0", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "x", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_lower", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "1", "0", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "x", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "y", "plt", "close", "all", "g", "ag", "pairgrid", "self", "df", "hue", "a", "hue_order", "order", "g", "map_upper", "plt", "plot", "for", "line", "level", "in", "zip", "g", "axes", "0", "1", "lines", "order", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "df", "loc", "self", "df", "a", "level", "y", "npt", "assert_array_equal", "y", "self", "df", "loc", "self", "df", "a", "level", "x", "plt", "close", "all"], "doc_len": 226}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_hue_in_map", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_hue_in_map", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_hue_in_map(self, long_df):\n\n        g = ag.PairGrid(long_df, vars=[\"x\", \"y\"])\n        g.map(scatterplot, hue=long_df[\"a\"])\n        ax = g.axes.flat[0]\n        points = ax.collections[0]\n        assert len(set(map(tuple, points.get_facecolors()))) == 3\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_hue_in_map", "self", "long_df", "g", "ag", "pairgrid", "long_df", "vars", "x", "y", "g", "map", "scatterplot", "hue", "long_df", "a", "ax", "g", "axes", "flat", "0", "points", "ax", "collections", "0", "assert", "len", "set", "map", "tuple", "points", "get_facecolors", "3"], "doc_len": 38}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_nondefault_index", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_nondefault_index", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_nondefault_index(self):\n\n        df = self.df.copy().set_index(\"b\")\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n        g1 = ag.PairGrid(df)\n        g1.map(plt.scatter)\n\n        for i, axes_i in enumerate(g1.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[plot_vars[j]]\n                y_in = self.df[plot_vars[i]]\n                x_out, y_out = ax.collections[0].get_offsets().T\n                npt.assert_array_equal(x_in, x_out)\n                npt.assert_array_equal(y_in, y_out)\n\n        g2 = ag.PairGrid(df, hue=\"a\")\n        g2.map(plt.scatter)\n\n        for i, axes_i in enumerate(g2.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = self.df[plot_vars[j]]\n                y_in = self.df[plot_vars[i]]\n                for k, k_level in enumerate(self.df.a.unique()):\n                    x_in_k = x_in[self.df.a == k_level]\n                    y_in_k = y_in[self.df.a == k_level]\n                    x_out, y_out = ax.collections[k].get_offsets().T\n                    npt.assert_array_equal(x_in_k, x_out)\n                    npt.assert_array_equal(y_in_k, y_out)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_nondefault_index", "self", "df", "self", "df", "copy", "set_index", "b", "plot_vars", "x", "y", "z", "g1", "ag", "pairgrid", "df", "g1", "map", "plt", "scatter", "for", "i", "axes_i", "in", "enumerate", "g1", "axes", "for", "j", "ax", "in", "enumerate", "axes_i", "x_in", "self", "df", "plot_vars", "j", "y_in", "self", "df", "plot_vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "g2", "ag", "pairgrid", "df", "hue", "a", "g2", "map", "plt", "scatter", "for", "i", "axes_i", "in", "enumerate", "g2", "axes", "for", "j", "ax", "in", "enumerate", "axes_i", "x_in", "self", "df", "plot_vars", "j", "y_in", "self", "df", "plot_vars", "i", "for", "k", "k_level", "in", "enumerate", "self", "df", "a", "unique", "x_in_k", "x_in", "self", "df", "a", "k_level", "y_in_k", "y_in", "self", "df", "a", "k_level", "x_out", "y_out", "ax", "collections", "k", "get_offsets", "t", "npt", "assert_array_equal", "x_in_k", "x_out", "npt", "assert_array_equal", "y_in_k", "y_out"], "doc_len": 132}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_dropna", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_dropna", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_dropna(self, func):\n\n        df = self.df.copy()\n        n_null = 20\n        df.loc[np.arange(n_null), \"x\"] = np.nan\n\n        plot_vars = [\"x\", \"y\", \"z\"]\n\n        g1 = ag.PairGrid(df, vars=plot_vars, dropna=True)\n        g1.map(func)\n\n        for i, axes_i in enumerate(g1.axes):\n            for j, ax in enumerate(axes_i):\n                x_in = df[plot_vars[j]]\n                y_in = df[plot_vars[i]]\n                x_out, y_out = ax.collections[0].get_offsets().T\n\n                n_valid = (x_in * y_in).notnull().sum()\n\n                assert n_valid == len(x_out)\n                assert n_valid == len(y_out)\n\n        g1.map_diag(histplot)\n        for i, ax in enumerate(g1.diag_axes):\n            var = plot_vars[i]\n            count = sum(p.get_height() for p in ax.patches)\n            assert count == df[var].notna().sum()\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_dropna", "self", "func", "df", "self", "df", "copy", "n_null", "20", "df", "loc", "np", "arange", "n_null", "x", "np", "nan", "plot_vars", "x", "y", "z", "g1", "ag", "pairgrid", "df", "vars", "plot_vars", "dropna", "true", "g1", "map", "func", "for", "i", "axes_i", "in", "enumerate", "g1", "axes", "for", "j", "ax", "in", "enumerate", "axes_i", "x_in", "df", "plot_vars", "j", "y_in", "df", "plot_vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "n_valid", "x_in", "y_in", "notnull", "sum", "assert", "n_valid", "len", "x_out", "assert", "n_valid", "len", "y_out", "g1", "map_diag", "histplot", "for", "i", "ax", "in", "enumerate", "g1", "diag_axes", "var", "plot_vars", "i", "count", "sum", "p", "get_height", "for", "p", "in", "ax", "patches", "assert", "count", "df", "var", "notna", "sum"], "doc_len": 106}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_histplot_legend", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_histplot_legend", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_histplot_legend(self):\n\n        # Tests _extract_legend_handles\n        g = ag.PairGrid(self.df, vars=[\"x\", \"y\"], hue=\"a\")\n        g.map_offdiag(histplot)\n        g.add_legend()\n\n        assert len(g._legend.legendHandles) == len(self.df[\"a\"].unique())\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_histplot_legend", "self", "tests", "_extract_legend_handles", "g", "ag", "pairgrid", "self", "df", "vars", "x", "y", "hue", "a", "g", "map_offdiag", "histplot", "g", "add_legend", "assert", "len", "g", "_legend", "legendhandles", "len", "self", "df", "a", "unique"], "doc_len": 34}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df)\n\n        for ax in g.diag_axes:\n            assert len(ax.patches) > 1\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n\n        g = ag.pairplot(self.df, hue=\"a\")\n        n = len(self.df.a.unique())\n\n        for ax in g.diag_axes:\n            assert len(ax.collections) == n\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot", "self", "vars", "x", "y", "z", "g", "ag", "pairplot", "self", "df", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "1", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "diag_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0", "g", "ag", "pairplot", "self", "df", "hue", "a", "n", "len", "self", "df", "a", "unique", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "collections", "n"], "doc_len": 148}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_reg", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_reg", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_reg(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df, diag_kind=\"hist\", kind=\"reg\")\n\n        for ax in g.diag_axes:\n            assert len(ax.patches)\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 2\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 2\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_reg", "self", "vars", "x", "y", "z", "g", "ag", "pairplot", "self", "df", "diag_kind", "hist", "kind", "reg", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "patches", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "2", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "2", "for", "i", "j", "in", "zip", "np", "diag_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0"], "doc_len": 148}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_reg_hue", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_reg_hue", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_reg_hue(self):\n\n        markers = [\"o\", \"s\", \"d\"]\n        g = ag.pairplot(self.df, kind=\"reg\", hue=\"a\", markers=markers)\n\n        ax = g.axes[-1, 0]\n        c1 = ax.collections[0]\n        c2 = ax.collections[2]\n\n        assert not np.array_equal(c1.get_facecolor(), c2.get_facecolor())\n        assert not np.array_equal(\n            c1.get_paths()[0].vertices, c2.get_paths()[0].vertices,\n        )\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_reg_hue", "self", "markers", "o", "s", "d", "g", "ag", "pairplot", "self", "df", "kind", "reg", "hue", "a", "markers", "markers", "ax", "g", "axes", "1", "0", "c1", "ax", "collections", "0", "c2", "ax", "collections", "2", "assert", "not", "np", "array_equal", "c1", "get_facecolor", "c2", "get_facecolor", "assert", "not", "np", "array_equal", "c1", "get_paths", "0", "vertices", "c2", "get_paths", "0", "vertices"], "doc_len": 55}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_diag_kde", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_diag_kde", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_diag_kde(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        g = ag.pairplot(self.df, diag_kind=\"kde\")\n\n        for ax in g.diag_axes:\n            assert len(ax.collections) == 1\n\n        for i, j in zip(*np.triu_indices_from(g.axes, 1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.tril_indices_from(g.axes, -1)):\n            ax = g.axes[i, j]\n            x_in = self.df[vars[j]]\n            y_in = self.df[vars[i]]\n            x_out, y_out = ax.collections[0].get_offsets().T\n            npt.assert_array_equal(x_in, x_out)\n            npt.assert_array_equal(y_in, y_out)\n\n        for i, j in zip(*np.diag_indices_from(g.axes)):\n            ax = g.axes[i, j]\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_diag_kde", "self", "vars", "x", "y", "z", "g", "ag", "pairplot", "self", "df", "diag_kind", "kde", "for", "ax", "in", "g", "diag_axes", "assert", "len", "ax", "collections", "1", "for", "i", "j", "in", "zip", "np", "triu_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "tril_indices_from", "g", "axes", "1", "ax", "g", "axes", "i", "j", "x_in", "self", "df", "vars", "j", "y_in", "self", "df", "vars", "i", "x_out", "y_out", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x_in", "x_out", "npt", "assert_array_equal", "y_in", "y_out", "for", "i", "j", "in", "zip", "np", "diag_indices_from", "g", "axes", "ax", "g", "axes", "i", "j", "assert", "len", "ax", "collections", "0"], "doc_len": 127}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_kde", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_kde", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_kde(self):\n\n        f, ax1 = plt.subplots()\n        kdeplot(data=self.df, x=\"x\", y=\"y\", ax=ax1)\n\n        g = ag.pairplot(self.df, kind=\"kde\")\n        ax2 = g.axes[1, 0]\n\n        assert_plots_equal(ax1, ax2, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_kde", "self", "f", "ax1", "plt", "subplots", "kdeplot", "data", "self", "df", "x", "x", "y", "y", "ax", "ax1", "g", "ag", "pairplot", "self", "df", "kind", "kde", "ax2", "g", "axes", "1", "0", "assert_plots_equal", "ax1", "ax2", "labels", "false"], "doc_len": 38}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_hist", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_hist", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_hist(self):\n\n        f, ax1 = plt.subplots()\n        histplot(data=self.df, x=\"x\", y=\"y\", ax=ax1)\n\n        g = ag.pairplot(self.df, kind=\"hist\")\n        ax2 = g.axes[1, 0]\n\n        assert_plots_equal(ax1, ax2, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_hist", "self", "f", "ax1", "plt", "subplots", "histplot", "data", "self", "df", "x", "x", "y", "y", "ax", "ax1", "g", "ag", "pairplot", "self", "df", "kind", "hist", "ax2", "g", "axes", "1", "0", "assert_plots_equal", "ax1", "ax2", "labels", "false"], "doc_len": 38}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_pairplot_markers", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_pairplot_markers", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_pairplot_markers(self):\n\n        vars = [\"x\", \"y\", \"z\"]\n        markers = [\"o\", \"X\", \"s\"]\n        g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers)\n        m1 = g._legend.legendHandles[0].get_paths()[0]\n        m2 = g._legend.legendHandles[1].get_paths()[0]\n        assert m1 != m2\n\n        with pytest.warns(UserWarning):\n            g = ag.pairplot(self.df, hue=\"a\", vars=vars, markers=markers[:-2])\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_pairplot_markers", "self", "vars", "x", "y", "z", "markers", "o", "x", "s", "g", "ag", "pairplot", "self", "df", "hue", "a", "vars", "vars", "markers", "markers", "m1", "g", "_legend", "legendhandles", "0", "get_paths", "0", "m2", "g", "_legend", "legendhandles", "1", "get_paths", "0", "assert", "m1", "m2", "with", "pytest", "warns", "userwarning", "g", "ag", "pairplot", "self", "df", "hue", "a", "vars", "vars", "markers", "markers", "2"], "doc_len": 59}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_corner_despine", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_corner_despine", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_corner_despine(self):\n\n        g = ag.PairGrid(self.df, corner=True, despine=False)\n        g.map_diag(histplot)\n        assert g.axes[0, 0].spines[\"top\"].get_visible()\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_corner_despine", "self", "g", "ag", "pairgrid", "self", "df", "corner", "true", "despine", "false", "g", "map_diag", "histplot", "assert", "g", "axes", "0", "0", "spines", "top", "get_visible"], "doc_len": 27}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_corner_set", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_corner_set", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_corner_set(self):\n\n        g = ag.PairGrid(self.df, corner=True, despine=False)\n        g.set(xlim=(0, 10))\n        assert g.axes[-1, 0].get_xlim() == (0, 10)\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_corner_set", "self", "g", "ag", "pairgrid", "self", "df", "corner", "true", "despine", "false", "g", "set", "xlim", "0", "10", "assert", "g", "axes", "1", "0", "get_xlim", "0", "10"], "doc_len": 29}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_legend", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_legend", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_legend(self):\n\n        g1 = ag.pairplot(self.df, hue=\"a\")\n        assert isinstance(g1.legend, mpl.legend.Legend)\n\n        g2 = ag.pairplot(self.df)\n        assert g2.legend is None\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_legend", "self", "g1", "ag", "pairplot", "self", "df", "hue", "a", "assert", "isinstance", "g1", "legend", "mpl", "legend", "legend", "g2", "ag", "pairplot", "self", "df", "assert", "g2", "legend", "is", "none"], "doc_len": 31}
{"doc_id": "tests/test_axisgrid.py::TestPairGrid.test_tick_params", "file_path": "tests/test_axisgrid.py", "class_name": "TestPairGrid", "func_name": "test_tick_params", "text": "文件路径: tests/test_axisgrid.py, 类名: TestPairGrid\n    def test_tick_params(self):\n\n        g = ag.PairGrid(self.df)\n        color = \"red\"\n        pad = 3\n        g.tick_params(pad=pad, color=color)\n        for ax in g.axes.flat:\n            for axis in [\"xaxis\", \"yaxis\"]:\n                for tick in getattr(ax, axis).get_major_ticks():\n                    assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                    assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                    assert tick.get_pad() == pad\n", "tokens": ["tests", "test_axisgrid", "py", "testpairgrid", "def", "test_tick_params", "self", "g", "ag", "pairgrid", "self", "df", "color", "red", "pad", "3", "g", "tick_params", "pad", "pad", "color", "color", "for", "ax", "in", "g", "axes", "flat", "for", "axis", "in", "xaxis", "yaxis", "for", "tick", "in", "getattr", "ax", "axis", "get_major_ticks", "assert", "mpl", "colors", "same_color", "tick", "tick1line", "get_color", "color", "assert", "mpl", "colors", "same_color", "tick", "tick2line", "get_color", "color", "assert", "tick", "get_pad", "pad"], "doc_len": 60}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_from_lists", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_from_lists", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_from_lists(self):\n\n        g = ag.JointGrid(x=self.x.tolist(), y=self.y.tolist())\n        npt.assert_array_equal(g.x, self.x)\n        npt.assert_array_equal(g.y, self.y)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_from_lists", "self", "g", "ag", "jointgrid", "x", "self", "x", "tolist", "y", "self", "y", "tolist", "npt", "assert_array_equal", "g", "x", "self", "x", "npt", "assert_array_equal", "g", "y", "self", "y"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_from_arrays", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_from_arrays", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_from_arrays(self):\n\n        g = ag.JointGrid(x=self.x, y=self.y)\n        npt.assert_array_equal(g.x, self.x)\n        npt.assert_array_equal(g.y, self.y)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_from_arrays", "self", "g", "ag", "jointgrid", "x", "self", "x", "y", "self", "y", "npt", "assert_array_equal", "g", "x", "self", "x", "npt", "assert_array_equal", "g", "y", "self", "y"], "doc_len": 28}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_from_series", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_from_series", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_from_series(self):\n\n        g = ag.JointGrid(x=self.data.x, y=self.data.y)\n        npt.assert_array_equal(g.x, self.x)\n        npt.assert_array_equal(g.y, self.y)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_from_series", "self", "g", "ag", "jointgrid", "x", "self", "data", "x", "y", "self", "data", "y", "npt", "assert_array_equal", "g", "x", "self", "x", "npt", "assert_array_equal", "g", "y", "self", "y"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_from_dataframe", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_from_dataframe", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_from_dataframe(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data)\n        npt.assert_array_equal(g.x, self.x)\n        npt.assert_array_equal(g.y, self.y)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_from_dataframe", "self", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "npt", "assert_array_equal", "g", "x", "self", "x", "npt", "assert_array_equal", "g", "y", "self", "y"], "doc_len": 29}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_from_dataframe_bad_variable", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_from_dataframe_bad_variable", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_from_dataframe_bad_variable(self):\n\n        with pytest.raises(ValueError):\n            ag.JointGrid(x=\"x\", y=\"bad_column\", data=self.data)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_from_dataframe_bad_variable", "self", "with", "pytest", "raises", "valueerror", "ag", "jointgrid", "x", "x", "y", "bad_column", "data", "self", "data"], "doc_len": 20}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_margin_grid_axis_labels", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_margin_grid_axis_labels", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_margin_grid_axis_labels(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data)\n\n        xlabel, ylabel = g.ax_joint.get_xlabel(), g.ax_joint.get_ylabel()\n        assert xlabel == \"x\"\n        assert ylabel == \"y\"\n\n        g.set_axis_labels(\"x variable\", \"y variable\")\n        xlabel, ylabel = g.ax_joint.get_xlabel(), g.ax_joint.get_ylabel()\n        assert xlabel == \"x variable\"\n        assert ylabel == \"y variable\"\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_margin_grid_axis_labels", "self", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "xlabel", "ylabel", "g", "ax_joint", "get_xlabel", "g", "ax_joint", "get_ylabel", "assert", "xlabel", "x", "assert", "ylabel", "y", "g", "set_axis_labels", "x", "variable", "y", "variable", "xlabel", "ylabel", "g", "ax_joint", "get_xlabel", "g", "ax_joint", "get_ylabel", "assert", "xlabel", "x", "variable", "assert", "ylabel", "y", "variable"], "doc_len": 53}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_dropna", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_dropna", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_dropna(self):\n\n        g = ag.JointGrid(x=\"x_na\", y=\"y\", data=self.data, dropna=False)\n        assert len(g.x) == len(self.x_na)\n\n        g = ag.JointGrid(x=\"x_na\", y=\"y\", data=self.data, dropna=True)\n        assert len(g.x) == pd.notnull(self.x_na).sum()\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_dropna", "self", "g", "ag", "jointgrid", "x", "x_na", "y", "y", "data", "self", "data", "dropna", "false", "assert", "len", "g", "x", "len", "self", "x_na", "g", "ag", "jointgrid", "x", "x_na", "y", "y", "data", "self", "data", "dropna", "true", "assert", "len", "g", "x", "pd", "notnull", "self", "x_na", "sum"], "doc_len": 47}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_axlims", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_axlims", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_axlims(self):\n\n        lim = (-3, 3)\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data, xlim=lim, ylim=lim)\n\n        assert g.ax_joint.get_xlim() == lim\n        assert g.ax_joint.get_ylim() == lim\n\n        assert g.ax_marg_x.get_xlim() == lim\n        assert g.ax_marg_y.get_ylim() == lim\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_axlims", "self", "lim", "3", "3", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "xlim", "lim", "ylim", "lim", "assert", "g", "ax_joint", "get_xlim", "lim", "assert", "g", "ax_joint", "get_ylim", "lim", "assert", "g", "ax_marg_x", "get_xlim", "lim", "assert", "g", "ax_marg_y", "get_ylim", "lim"], "doc_len": 44}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_marginal_ticks", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_marginal_ticks", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_marginal_ticks(self):\n\n        g = ag.JointGrid(marginal_ticks=False)\n        assert not sum(t.get_visible() for t in g.ax_marg_x.get_yticklabels())\n        assert not sum(t.get_visible() for t in g.ax_marg_y.get_xticklabels())\n\n        g = ag.JointGrid(marginal_ticks=True)\n        assert sum(t.get_visible() for t in g.ax_marg_x.get_yticklabels())\n        assert sum(t.get_visible() for t in g.ax_marg_y.get_xticklabels())\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_marginal_ticks", "self", "g", "ag", "jointgrid", "marginal_ticks", "false", "assert", "not", "sum", "t", "get_visible", "for", "t", "in", "g", "ax_marg_x", "get_yticklabels", "assert", "not", "sum", "t", "get_visible", "for", "t", "in", "g", "ax_marg_y", "get_xticklabels", "g", "ag", "jointgrid", "marginal_ticks", "true", "assert", "sum", "t", "get_visible", "for", "t", "in", "g", "ax_marg_x", "get_yticklabels", "assert", "sum", "t", "get_visible", "for", "t", "in", "g", "ax_marg_y", "get_xticklabels"], "doc_len": 59}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_bivariate_plot", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_bivariate_plot", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_bivariate_plot(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data)\n        g.plot_joint(plt.plot)\n\n        x, y = g.ax_joint.lines[0].get_xydata().T\n        npt.assert_array_equal(x, self.x)\n        npt.assert_array_equal(y, self.y)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_bivariate_plot", "self", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "g", "plot_joint", "plt", "plot", "x", "y", "g", "ax_joint", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "x", "npt", "assert_array_equal", "y", "self", "y"], "doc_len": 39}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_univariate_plot", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_univariate_plot", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_univariate_plot(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"x\", data=self.data)\n        g.plot_marginals(kdeplot)\n\n        _, y1 = g.ax_marg_x.lines[0].get_xydata().T\n        y2, _ = g.ax_marg_y.lines[0].get_xydata().T\n        npt.assert_array_equal(y1, y2)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_univariate_plot", "self", "g", "ag", "jointgrid", "x", "x", "y", "x", "data", "self", "data", "g", "plot_marginals", "kdeplot", "_", "y1", "g", "ax_marg_x", "lines", "0", "get_xydata", "t", "y2", "_", "g", "ax_marg_y", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "y1", "y2"], "doc_len": 40}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_univariate_plot_distplot", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_univariate_plot_distplot", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_univariate_plot_distplot(self):\n\n        bins = 10\n        g = ag.JointGrid(x=\"x\", y=\"x\", data=self.data)\n        with pytest.warns(UserWarning):\n            g.plot_marginals(distplot, bins=bins)\n        assert len(g.ax_marg_x.patches) == bins\n        assert len(g.ax_marg_y.patches) == bins\n        for x, y in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n            assert x.get_height() == y.get_width()\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_univariate_plot_distplot", "self", "bins", "10", "g", "ag", "jointgrid", "x", "x", "y", "x", "data", "self", "data", "with", "pytest", "warns", "userwarning", "g", "plot_marginals", "distplot", "bins", "bins", "assert", "len", "g", "ax_marg_x", "patches", "bins", "assert", "len", "g", "ax_marg_y", "patches", "bins", "for", "x", "y", "in", "zip", "g", "ax_marg_x", "patches", "g", "ax_marg_y", "patches", "assert", "x", "get_height", "y", "get_width"], "doc_len": 56}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_univariate_plot_matplotlib", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_univariate_plot_matplotlib", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_univariate_plot_matplotlib(self):\n\n        bins = 10\n        g = ag.JointGrid(x=\"x\", y=\"x\", data=self.data)\n        g.plot_marginals(plt.hist, bins=bins)\n        assert len(g.ax_marg_x.patches) == bins\n        assert len(g.ax_marg_y.patches) == bins\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_univariate_plot_matplotlib", "self", "bins", "10", "g", "ag", "jointgrid", "x", "x", "y", "x", "data", "self", "data", "g", "plot_marginals", "plt", "hist", "bins", "bins", "assert", "len", "g", "ax_marg_x", "patches", "bins", "assert", "len", "g", "ax_marg_y", "patches", "bins"], "doc_len": 37}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_plot", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_plot", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_plot(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"x\", data=self.data)\n        g.plot(plt.plot, kdeplot)\n\n        x, y = g.ax_joint.lines[0].get_xydata().T\n        npt.assert_array_equal(x, self.x)\n        npt.assert_array_equal(y, self.x)\n\n        _, y1 = g.ax_marg_x.lines[0].get_xydata().T\n        y2, _ = g.ax_marg_y.lines[0].get_xydata().T\n        npt.assert_array_equal(y1, y2)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_plot", "self", "g", "ag", "jointgrid", "x", "x", "y", "x", "data", "self", "data", "g", "plot", "plt", "plot", "kdeplot", "x", "y", "g", "ax_joint", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "self", "x", "npt", "assert_array_equal", "y", "self", "x", "_", "y1", "g", "ax_marg_x", "lines", "0", "get_xydata", "t", "y2", "_", "g", "ax_marg_y", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "y1", "y2"], "doc_len": 60}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_space", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_space", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_space(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data, space=0)\n\n        joint_bounds = g.ax_joint.bbox.bounds\n        marg_x_bounds = g.ax_marg_x.bbox.bounds\n        marg_y_bounds = g.ax_marg_y.bbox.bounds\n\n        assert joint_bounds[2] == marg_x_bounds[2]\n        assert joint_bounds[3] == marg_y_bounds[3]\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_space", "self", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "space", "0", "joint_bounds", "g", "ax_joint", "bbox", "bounds", "marg_x_bounds", "g", "ax_marg_x", "bbox", "bounds", "marg_y_bounds", "g", "ax_marg_y", "bbox", "bounds", "assert", "joint_bounds", "2", "marg_x_bounds", "2", "assert", "joint_bounds", "3", "marg_y_bounds", "3"], "doc_len": 44}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_hue", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_hue", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_hue(self, long_df, as_vector):\n\n        if as_vector:\n            data = None\n            x, y, hue = long_df[\"x\"], long_df[\"y\"], long_df[\"a\"]\n        else:\n            data = long_df\n            x, y, hue = \"x\", \"y\", \"a\"\n\n        g = ag.JointGrid(data=data, x=x, y=y, hue=hue)\n        g.plot_joint(scatterplot)\n        g.plot_marginals(histplot)\n\n        g2 = ag.JointGrid()\n        scatterplot(data=long_df, x=x, y=y, hue=hue, ax=g2.ax_joint)\n        histplot(data=long_df, x=x, hue=hue, ax=g2.ax_marg_x)\n        histplot(data=long_df, y=y, hue=hue, ax=g2.ax_marg_y)\n\n        assert_plots_equal(g.ax_joint, g2.ax_joint)\n        assert_plots_equal(g.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_hue", "self", "long_df", "as_vector", "if", "as_vector", "data", "none", "x", "y", "hue", "long_df", "x", "long_df", "y", "long_df", "a", "else", "data", "long_df", "x", "y", "hue", "x", "y", "a", "g", "ag", "jointgrid", "data", "data", "x", "x", "y", "y", "hue", "hue", "g", "plot_joint", "scatterplot", "g", "plot_marginals", "histplot", "g2", "ag", "jointgrid", "scatterplot", "data", "long_df", "x", "x", "y", "y", "hue", "hue", "ax", "g2", "ax_joint", "histplot", "data", "long_df", "x", "x", "hue", "hue", "ax", "g2", "ax_marg_x", "histplot", "data", "long_df", "y", "y", "hue", "hue", "ax", "g2", "ax_marg_y", "assert_plots_equal", "g", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 102}
{"doc_id": "tests/test_axisgrid.py::TestJointGrid.test_refline", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointGrid", "func_name": "test_refline", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointGrid\n    def test_refline(self):\n\n        g = ag.JointGrid(x=\"x\", y=\"y\", data=self.data)\n        g.plot(scatterplot, histplot)\n        g.refline()\n        assert not g.ax_joint.lines and not g.ax_marg_x.lines and not g.ax_marg_y.lines\n\n        refx = refy = 0.5\n        hline = np.array([[0, refy], [1, refy]])\n        vline = np.array([[refx, 0], [refx, 1]])\n        g.refline(x=refx, y=refy, joint=False, marginal=False)\n        assert not g.ax_joint.lines and not g.ax_marg_x.lines and not g.ax_marg_y.lines\n\n        g.refline(x=refx, y=refy)\n        assert g.ax_joint.lines[0].get_color() == '.5'\n        assert g.ax_joint.lines[0].get_linestyle() == '--'\n        assert len(g.ax_joint.lines) == 2\n        assert len(g.ax_marg_x.lines) == 1\n        assert len(g.ax_marg_y.lines) == 1\n        npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n        npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n\n        color, linestyle = 'red', '-'\n        g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n        npt.assert_array_equal(g.ax_joint.lines[-1].get_xydata(), vline)\n        assert g.ax_joint.lines[-1].get_color() == color\n        assert g.ax_joint.lines[-1].get_linestyle() == linestyle\n        assert len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines)\n\n        g.refline(x=refx, joint=False)\n        npt.assert_array_equal(g.ax_marg_x.lines[-1].get_xydata(), vline)\n        assert len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines) + 1\n\n        g.refline(y=refy, joint=False)\n        npt.assert_array_equal(g.ax_marg_y.lines[-1].get_xydata(), hline)\n        assert len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines)\n\n        g.refline(y=refy, marginal=False)\n        npt.assert_array_equal(g.ax_joint.lines[-1].get_xydata(), hline)\n        assert len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointgrid", "def", "test_refline", "self", "g", "ag", "jointgrid", "x", "x", "y", "y", "data", "self", "data", "g", "plot", "scatterplot", "histplot", "g", "refline", "assert", "not", "g", "ax_joint", "lines", "and", "not", "g", "ax_marg_x", "lines", "and", "not", "g", "ax_marg_y", "lines", "refx", "refy", "0", "5", "hline", "np", "array", "0", "refy", "1", "refy", "vline", "np", "array", "refx", "0", "refx", "1", "g", "refline", "x", "refx", "y", "refy", "joint", "false", "marginal", "false", "assert", "not", "g", "ax_joint", "lines", "and", "not", "g", "ax_marg_x", "lines", "and", "not", "g", "ax_marg_y", "lines", "g", "refline", "x", "refx", "y", "refy", "assert", "g", "ax_joint", "lines", "0", "get_color", "5", "assert", "g", "ax_joint", "lines", "0", "get_linestyle", "assert", "len", "g", "ax_joint", "lines", "2", "assert", "len", "g", "ax_marg_x", "lines", "1", "assert", "len", "g", "ax_marg_y", "lines", "1", "npt", "assert_array_equal", "g", "ax_joint", "lines", "0", "get_xydata", "vline", "npt", "assert_array_equal", "g", "ax_joint", "lines", "1", "get_xydata", "hline", "npt", "assert_array_equal", "g", "ax_marg_x", "lines", "0", "get_xydata", "vline", "npt", "assert_array_equal", "g", "ax_marg_y", "lines", "0", "get_xydata", "hline", "color", "linestyle", "red", "g", "refline", "x", "refx", "marginal", "false", "color", "color", "linestyle", "linestyle", "npt", "assert_array_equal", "g", "ax_joint", "lines", "1", "get_xydata", "vline", "assert", "g", "ax_joint", "lines", "1", "get_color", "color", "assert", "g", "ax_joint", "lines", "1", "get_linestyle", "linestyle", "assert", "len", "g", "ax_marg_x", "lines", "len", "g", "ax_marg_y", "lines", "g", "refline", "x", "refx", "joint", "false", "npt", "assert_array_equal", "g", "ax_marg_x", "lines", "1", "get_xydata", "vline", "assert", "len", "g", "ax_marg_x", "lines", "len", "g", "ax_marg_y", "lines", "1", "g", "refline", "y", "refy", "joint", "false", "npt", "assert_array_equal", "g", "ax_marg_y", "lines", "1", "get_xydata", "hline", "assert", "len", "g", "ax_marg_x", "lines", "len", "g", "ax_marg_y", "lines", "g", "refline", "y", "refy", "marginal", "false", "npt", "assert_array_equal", "g", "ax_joint", "lines", "1", "get_xydata", "hline", "assert", "len", "g", "ax_marg_x", "lines", "len", "g", "ax_marg_y", "lines"], "doc_len": 264}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_scatter", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_scatter", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_scatter(self):\n\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data)\n        assert len(g.ax_joint.collections) == 1\n\n        x, y = g.ax_joint.collections[0].get_offsets().T\n        assert_array_equal(self.x, x)\n        assert_array_equal(self.y, y)\n\n        assert_array_almost_equal(\n            [b.get_x() for b in g.ax_marg_x.patches],\n            np.histogram_bin_edges(self.x, \"auto\")[:-1],\n        )\n\n        assert_array_almost_equal(\n            [b.get_y() for b in g.ax_marg_y.patches],\n            np.histogram_bin_edges(self.y, \"auto\")[:-1],\n        )\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_scatter", "self", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "assert", "len", "g", "ax_joint", "collections", "1", "x", "y", "g", "ax_joint", "collections", "0", "get_offsets", "t", "assert_array_equal", "self", "x", "x", "assert_array_equal", "self", "y", "y", "assert_array_almost_equal", "b", "get_x", "for", "b", "in", "g", "ax_marg_x", "patches", "np", "histogram_bin_edges", "self", "x", "auto", "1", "assert_array_almost_equal", "b", "get_y", "for", "b", "in", "g", "ax_marg_y", "patches", "np", "histogram_bin_edges", "self", "y", "auto", "1"], "doc_len": 69}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_scatter_hue", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_scatter_hue", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_scatter_hue(self, long_df):\n\n        g1 = ag.jointplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\")\n\n        g2 = ag.JointGrid()\n        scatterplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", ax=g2.ax_joint)\n        kdeplot(data=long_df, x=\"x\", hue=\"a\", ax=g2.ax_marg_x, fill=True)\n        kdeplot(data=long_df, y=\"y\", hue=\"a\", ax=g2.ax_marg_y, fill=True)\n\n        assert_plots_equal(g1.ax_joint, g2.ax_joint)\n        assert_plots_equal(g1.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g1.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_scatter_hue", "self", "long_df", "g1", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "g2", "ag", "jointgrid", "scatterplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "ax", "g2", "ax_joint", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "ax", "g2", "ax_marg_x", "fill", "true", "kdeplot", "data", "long_df", "y", "y", "hue", "a", "ax", "g2", "ax_marg_y", "fill", "true", "assert_plots_equal", "g1", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g1", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g1", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 77}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_reg", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_reg", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_reg(self):\n\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=\"reg\")\n        assert len(g.ax_joint.collections) == 2\n\n        x, y = g.ax_joint.collections[0].get_offsets().T\n        assert_array_equal(self.x, x)\n        assert_array_equal(self.y, y)\n\n        assert g.ax_marg_x.patches\n        assert g.ax_marg_y.patches\n\n        assert g.ax_marg_x.lines\n        assert g.ax_marg_y.lines\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_reg", "self", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "reg", "assert", "len", "g", "ax_joint", "collections", "2", "x", "y", "g", "ax_joint", "collections", "0", "get_offsets", "t", "assert_array_equal", "self", "x", "x", "assert_array_equal", "self", "y", "y", "assert", "g", "ax_marg_x", "patches", "assert", "g", "ax_marg_y", "patches", "assert", "g", "ax_marg_x", "lines", "assert", "g", "ax_marg_y", "lines"], "doc_len": 57}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_resid", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_resid", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_resid(self):\n\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=\"resid\")\n        assert g.ax_joint.collections\n        assert g.ax_joint.lines\n        assert not g.ax_marg_x.lines\n        assert not g.ax_marg_y.lines\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_resid", "self", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "resid", "assert", "g", "ax_joint", "collections", "assert", "g", "ax_joint", "lines", "assert", "not", "g", "ax_marg_x", "lines", "assert", "not", "g", "ax_marg_y", "lines"], "doc_len": 37}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_hist", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_hist", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_hist(self, long_df):\n\n        bins = 3, 6\n        g1 = ag.jointplot(data=long_df, x=\"x\", y=\"y\", kind=\"hist\", bins=bins)\n\n        g2 = ag.JointGrid()\n        histplot(data=long_df, x=\"x\", y=\"y\", ax=g2.ax_joint, bins=bins)\n        histplot(data=long_df, x=\"x\", ax=g2.ax_marg_x, bins=bins[0])\n        histplot(data=long_df, y=\"y\", ax=g2.ax_marg_y, bins=bins[1])\n\n        assert_plots_equal(g1.ax_joint, g2.ax_joint)\n        assert_plots_equal(g1.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g1.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_hist", "self", "long_df", "bins", "3", "6", "g1", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "kind", "hist", "bins", "bins", "g2", "ag", "jointgrid", "histplot", "data", "long_df", "x", "x", "y", "y", "ax", "g2", "ax_joint", "bins", "bins", "histplot", "data", "long_df", "x", "x", "ax", "g2", "ax_marg_x", "bins", "bins", "0", "histplot", "data", "long_df", "y", "y", "ax", "g2", "ax_marg_y", "bins", "bins", "1", "assert_plots_equal", "g1", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g1", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g1", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 80}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_hex", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_hex", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_hex(self):\n\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=\"hex\")\n        assert g.ax_joint.collections\n        assert g.ax_marg_x.patches\n        assert g.ax_marg_y.patches\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_hex", "self", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "hex", "assert", "g", "ax_joint", "collections", "assert", "g", "ax_marg_x", "patches", "assert", "g", "ax_marg_y", "patches"], "doc_len": 31}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_kde", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_kde", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_kde(self, long_df):\n\n        g1 = ag.jointplot(data=long_df, x=\"x\", y=\"y\", kind=\"kde\")\n\n        g2 = ag.JointGrid()\n        kdeplot(data=long_df, x=\"x\", y=\"y\", ax=g2.ax_joint)\n        kdeplot(data=long_df, x=\"x\", ax=g2.ax_marg_x)\n        kdeplot(data=long_df, y=\"y\", ax=g2.ax_marg_y)\n\n        assert_plots_equal(g1.ax_joint, g2.ax_joint)\n        assert_plots_equal(g1.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g1.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_kde", "self", "long_df", "g1", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "kind", "kde", "g2", "ag", "jointgrid", "kdeplot", "data", "long_df", "x", "x", "y", "y", "ax", "g2", "ax_joint", "kdeplot", "data", "long_df", "x", "x", "ax", "g2", "ax_marg_x", "kdeplot", "data", "long_df", "y", "y", "ax", "g2", "ax_marg_y", "assert_plots_equal", "g1", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g1", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g1", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 67}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_kde_hue", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_kde_hue", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_kde_hue(self, long_df):\n\n        g1 = ag.jointplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", kind=\"kde\")\n\n        g2 = ag.JointGrid()\n        kdeplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", ax=g2.ax_joint)\n        kdeplot(data=long_df, x=\"x\", hue=\"a\", ax=g2.ax_marg_x)\n        kdeplot(data=long_df, y=\"y\", hue=\"a\", ax=g2.ax_marg_y)\n\n        assert_plots_equal(g1.ax_joint, g2.ax_joint)\n        assert_plots_equal(g1.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g1.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_kde_hue", "self", "long_df", "g1", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "kind", "kde", "g2", "ag", "jointgrid", "kdeplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "ax", "g2", "ax_joint", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "ax", "g2", "ax_marg_x", "kdeplot", "data", "long_df", "y", "y", "hue", "a", "ax", "g2", "ax_marg_y", "assert_plots_equal", "g1", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g1", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g1", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 75}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_color", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_color", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_color(self):\n\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data, color=\"purple\")\n\n        scatter_color = g.ax_joint.collections[0].get_facecolor()\n        assert_colors_equal(scatter_color, \"purple\")\n\n        hist_color = g.ax_marg_x.patches[0].get_facecolor()[:3]\n        assert_colors_equal(hist_color, \"purple\")\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_color", "self", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "color", "purple", "scatter_color", "g", "ax_joint", "collections", "0", "get_facecolor", "assert_colors_equal", "scatter_color", "purple", "hist_color", "g", "ax_marg_x", "patches", "0", "get_facecolor", "3", "assert_colors_equal", "hist_color", "purple"], "doc_len": 38}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_palette", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_palette", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_palette(self, long_df):\n\n        kws = dict(data=long_df, hue=\"a\", palette=\"Set2\")\n\n        g1 = ag.jointplot(x=\"x\", y=\"y\", **kws)\n\n        g2 = ag.JointGrid()\n        scatterplot(x=\"x\", y=\"y\", ax=g2.ax_joint, **kws)\n        kdeplot(x=\"x\", ax=g2.ax_marg_x, fill=True, **kws)\n        kdeplot(y=\"y\", ax=g2.ax_marg_y, fill=True, **kws)\n\n        assert_plots_equal(g1.ax_joint, g2.ax_joint)\n        assert_plots_equal(g1.ax_marg_x, g2.ax_marg_x, labels=False)\n        assert_plots_equal(g1.ax_marg_y, g2.ax_marg_y, labels=False)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_palette", "self", "long_df", "kws", "dict", "data", "long_df", "hue", "a", "palette", "set2", "g1", "ag", "jointplot", "x", "x", "y", "y", "kws", "g2", "ag", "jointgrid", "scatterplot", "x", "x", "y", "y", "ax", "g2", "ax_joint", "kws", "kdeplot", "x", "x", "ax", "g2", "ax_marg_x", "fill", "true", "kws", "kdeplot", "y", "y", "ax", "g2", "ax_marg_y", "fill", "true", "kws", "assert_plots_equal", "g1", "ax_joint", "g2", "ax_joint", "assert_plots_equal", "g1", "ax_marg_x", "g2", "ax_marg_x", "labels", "false", "assert_plots_equal", "g1", "ax_marg_y", "g2", "ax_marg_y", "labels", "false"], "doc_len": 73}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_hex_customise", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_hex_customise", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_hex_customise(self):\n\n        # test that default gridsize can be overridden\n        g = ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=\"hex\",\n                         joint_kws=dict(gridsize=5))\n        assert len(g.ax_joint.collections) == 1\n        a = g.ax_joint.collections[0].get_array()\n        assert a.shape[0] == 28  # 28 hexagons expected for gridsize 5\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_hex_customise", "self", "test", "that", "default", "gridsize", "can", "be", "overridden", "g", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "hex", "joint_kws", "dict", "gridsize", "5", "assert", "len", "g", "ax_joint", "collections", "1", "a", "g", "ax_joint", "collections", "0", "get_array", "assert", "a", "shape", "0", "28", "28", "hexagons", "expected", "for", "gridsize", "5"], "doc_len": 53}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_bad_kind", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_bad_kind", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_bad_kind(self):\n\n        with pytest.raises(ValueError):\n            ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=\"not_a_kind\")\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_bad_kind", "self", "with", "pytest", "raises", "valueerror", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "not_a_kind"], "doc_len": 22}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_unsupported_hue_kind", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_unsupported_hue_kind", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_unsupported_hue_kind(self):\n\n        for kind in [\"reg\", \"resid\", \"hex\"]:\n            with pytest.raises(ValueError):\n                ag.jointplot(x=\"x\", y=\"y\", hue=\"a\", data=self.data, kind=kind)\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_unsupported_hue_kind", "self", "for", "kind", "in", "reg", "resid", "hex", "with", "pytest", "raises", "valueerror", "ag", "jointplot", "x", "x", "y", "y", "hue", "a", "data", "self", "data", "kind", "kind"], "doc_len": 30}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_leaky_dict", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_leaky_dict", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_leaky_dict(self):\n        # Validate input dicts are unchanged by jointplot plotting function\n\n        for kwarg in (\"joint_kws\", \"marginal_kws\"):\n            for kind in (\"hex\", \"kde\", \"resid\", \"reg\", \"scatter\"):\n                empty_dict = {}\n                ag.jointplot(x=\"x\", y=\"y\", data=self.data, kind=kind,\n                             **{kwarg: empty_dict})\n                assert empty_dict == {}\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_leaky_dict", "self", "validate", "input", "dicts", "are", "unchanged", "by", "jointplot", "plotting", "function", "for", "kwarg", "in", "joint_kws", "marginal_kws", "for", "kind", "in", "hex", "kde", "resid", "reg", "scatter", "empty_dict", "ag", "jointplot", "x", "x", "y", "y", "data", "self", "data", "kind", "kind", "kwarg", "empty_dict", "assert", "empty_dict"], "doc_len": 45}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_distplot_kwarg_warning", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_distplot_kwarg_warning", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_distplot_kwarg_warning(self, long_df):\n\n        with pytest.warns(UserWarning):\n            g = ag.jointplot(data=long_df, x=\"x\", y=\"y\", marginal_kws=dict(rug=True))\n        assert g.ax_marg_x.patches\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_distplot_kwarg_warning", "self", "long_df", "with", "pytest", "warns", "userwarning", "g", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "marginal_kws", "dict", "rug", "true", "assert", "g", "ax_marg_x", "patches"], "doc_len": 29}
{"doc_id": "tests/test_axisgrid.py::TestJointPlot.test_ax_warning", "file_path": "tests/test_axisgrid.py", "class_name": "TestJointPlot", "func_name": "test_ax_warning", "text": "文件路径: tests/test_axisgrid.py, 类名: TestJointPlot\n    def test_ax_warning(self, long_df):\n\n        ax = plt.gca()\n        with pytest.warns(UserWarning):\n            g = ag.jointplot(data=long_df, x=\"x\", y=\"y\", ax=ax)\n        assert g.ax_joint.collections\n", "tokens": ["tests", "test_axisgrid", "py", "testjointplot", "def", "test_ax_warning", "self", "long_df", "ax", "plt", "gca", "with", "pytest", "warns", "userwarning", "g", "ag", "jointplot", "data", "long_df", "x", "x", "y", "y", "ax", "ax", "assert", "g", "ax_joint", "collections"], "doc_len": 30}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotterNew.test_axis_labels", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotterNew", "func_name": "test_axis_labels", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotterNew\n    def test_axis_labels(self, long_df, func, kwargs):\n\n        func(data=long_df, **kwargs)\n\n        ax = plt.gca()\n        for axis in \"xy\":\n            val = kwargs.get(axis, \"\")\n            label_func = getattr(ax, f\"get_{axis}label\")\n            assert label_func() == val\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotternew", "def", "test_axis_labels", "self", "long_df", "func", "kwargs", "func", "data", "long_df", "kwargs", "ax", "plt", "gca", "for", "axis", "in", "xy", "val", "kwargs", "get", "axis", "label_func", "getattr", "ax", "f", "get_", "axis", "label", "assert", "label_func", "val"], "doc_len": 35}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotterNew.test_empty", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotterNew", "func_name": "test_empty", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotterNew\n    def test_empty(self, func):\n\n        func()\n        ax = plt.gca()\n        assert not ax.collections\n        assert not ax.patches\n        assert not ax.lines\n\n        func(x=[], y=[])\n        ax = plt.gca()\n        assert not ax.collections\n        assert not ax.patches\n        assert not ax.lines\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotternew", "def", "test_empty", "self", "func", "func", "ax", "plt", "gca", "assert", "not", "ax", "collections", "assert", "not", "ax", "patches", "assert", "not", "ax", "lines", "func", "x", "y", "ax", "plt", "gca", "assert", "not", "ax", "collections", "assert", "not", "ax", "patches", "assert", "not", "ax", "lines"], "doc_len": 42}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotterNew.test_redundant_hue_backcompat", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotterNew", "func_name": "test_redundant_hue_backcompat", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotterNew\n    def test_redundant_hue_backcompat(self, long_df):\n\n        p = _CategoricalPlotterNew(\n            data=long_df,\n            variables={\"x\": \"s\", \"y\": \"y\"},\n        )\n\n        color = None\n        palette = dict(zip(long_df[\"s\"].unique(), color_palette()))\n        hue_order = None\n\n        palette, _ = p._hue_backcompat(color, palette, hue_order, force_hue=True)\n\n        assert p.variables[\"hue\"] == \"s\"\n        assert_array_equal(p.plot_data[\"hue\"], p.plot_data[\"x\"])\n        assert all(isinstance(k, str) for k in palette)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotternew", "def", "test_redundant_hue_backcompat", "self", "long_df", "p", "_categoricalplotternew", "data", "long_df", "variables", "x", "s", "y", "y", "color", "none", "palette", "dict", "zip", "long_df", "s", "unique", "color_palette", "hue_order", "none", "palette", "_", "p", "_hue_backcompat", "color", "palette", "hue_order", "force_hue", "true", "assert", "p", "variables", "hue", "s", "assert_array_equal", "p", "plot_data", "hue", "p", "plot_data", "x", "assert", "all", "isinstance", "k", "str", "for", "k", "in", "palette"], "doc_len": 58}
{"doc_id": "tests/test_categorical.py::CategoricalFixture.get_box_artists", "file_path": "tests/test_categorical.py", "class_name": "CategoricalFixture", "func_name": "get_box_artists", "text": "文件路径: tests/test_categorical.py, 类名: CategoricalFixture\n    def get_box_artists(self, ax):\n\n        if Version(mpl.__version__) < Version(\"3.5.0b0\"):\n            return ax.artists\n        else:\n            # Exclude labeled patches, which are for the legend\n            return [p for p in ax.patches if not p.get_label()]\n", "tokens": ["tests", "test_categorical", "py", "categoricalfixture", "def", "get_box_artists", "self", "ax", "if", "version", "mpl", "__version__", "version", "3", "5", "0b0", "return", "ax", "artists", "else", "exclude", "labeled", "patches", "which", "are", "for", "the", "legend", "return", "p", "for", "p", "in", "ax", "patches", "if", "not", "p", "get_label"], "doc_len": 39}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_wide_df_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_wide_df_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_wide_df_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test basic wide DataFrame\n        p.establish_variables(data=self.x_df)\n\n        # Check data attribute\n        for x, y, in zip(p.plot_data, self.x_df[[\"X\", \"Y\", \"Z\"]].values.T):\n            npt.assert_array_equal(x, y)\n\n        # Check semantic attributes\n        assert p.orient == \"v\"\n        assert p.plot_hues is None\n        assert p.group_label == \"big\"\n        assert p.value_label is None\n\n        # Test wide dataframe with forced horizontal orientation\n        p.establish_variables(data=self.x_df, orient=\"horiz\")\n        assert p.orient == \"h\"\n\n        # Test exception by trying to hue-group with a wide dataframe\n        with pytest.raises(ValueError):\n            p.establish_variables(hue=\"d\", data=self.x_df)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_wide_df_data", "self", "p", "cat", "_categoricalplotter", "test", "basic", "wide", "dataframe", "p", "establish_variables", "data", "self", "x_df", "check", "data", "attribute", "for", "x", "y", "in", "zip", "p", "plot_data", "self", "x_df", "x", "y", "z", "values", "t", "npt", "assert_array_equal", "x", "y", "check", "semantic", "attributes", "assert", "p", "orient", "v", "assert", "p", "plot_hues", "is", "none", "assert", "p", "group_label", "big", "assert", "p", "value_label", "is", "none", "test", "wide", "dataframe", "with", "forced", "horizontal", "orientation", "p", "establish_variables", "data", "self", "x_df", "orient", "horiz", "assert", "p", "orient", "h", "test", "exception", "by", "trying", "to", "hue", "group", "with", "a", "wide", "dataframe", "with", "pytest", "raises", "valueerror", "p", "establish_variables", "hue", "d", "data", "self", "x_df"], "doc_len": 101}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_1d_input_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_1d_input_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_1d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test basic vector data\n        x_1d_array = self.x.ravel()\n        p.establish_variables(data=x_1d_array)\n        assert len(p.plot_data) == 1\n        assert len(p.plot_data[0]) == self.n_total\n        assert p.group_label is None\n        assert p.value_label is None\n\n        # Test basic vector data in list form\n        x_1d_list = x_1d_array.tolist()\n        p.establish_variables(data=x_1d_list)\n        assert len(p.plot_data) == 1\n        assert len(p.plot_data[0]) == self.n_total\n        assert p.group_label is None\n        assert p.value_label is None\n\n        # Test an object array that looks 1D but isn't\n        x_notreally_1d = np.array([self.x.ravel(),\n                                   self.x.ravel()[:int(self.n_total / 2)]],\n                                  dtype=object)\n        p.establish_variables(data=x_notreally_1d)\n        assert len(p.plot_data) == 2\n        assert len(p.plot_data[0]) == self.n_total\n        assert len(p.plot_data[1]) == self.n_total / 2\n        assert p.group_label is None\n        assert p.value_label is None\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_1d_input_data", "self", "p", "cat", "_categoricalplotter", "test", "basic", "vector", "data", "x_1d_array", "self", "x", "ravel", "p", "establish_variables", "data", "x_1d_array", "assert", "len", "p", "plot_data", "1", "assert", "len", "p", "plot_data", "0", "self", "n_total", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none", "test", "basic", "vector", "data", "in", "list", "form", "x_1d_list", "x_1d_array", "tolist", "p", "establish_variables", "data", "x_1d_list", "assert", "len", "p", "plot_data", "1", "assert", "len", "p", "plot_data", "0", "self", "n_total", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none", "test", "an", "object", "array", "that", "looks", "1d", "but", "isn", "t", "x_notreally_1d", "np", "array", "self", "x", "ravel", "self", "x", "ravel", "int", "self", "n_total", "2", "dtype", "object", "p", "establish_variables", "data", "x_notreally_1d", "assert", "len", "p", "plot_data", "2", "assert", "len", "p", "plot_data", "0", "self", "n_total", "assert", "len", "p", "plot_data", "1", "self", "n_total", "2", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none"], "doc_len": 139}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_2d_input_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_2d_input_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_2d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        x = self.x[:, 0]\n\n        # Test vector data that looks 2D but doesn't really have columns\n        p.establish_variables(data=x[:, np.newaxis])\n        assert len(p.plot_data) == 1\n        assert len(p.plot_data[0]) == self.x.shape[0]\n        assert p.group_label is None\n        assert p.value_label is None\n\n        # Test vector data that looks 2D but doesn't really have rows\n        p.establish_variables(data=x[np.newaxis, :])\n        assert len(p.plot_data) == 1\n        assert len(p.plot_data[0]) == self.x.shape[0]\n        assert p.group_label is None\n        assert p.value_label is None\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_2d_input_data", "self", "p", "cat", "_categoricalplotter", "x", "self", "x", "0", "test", "vector", "data", "that", "looks", "2d", "but", "doesn", "t", "really", "have", "columns", "p", "establish_variables", "data", "x", "np", "newaxis", "assert", "len", "p", "plot_data", "1", "assert", "len", "p", "plot_data", "0", "self", "x", "shape", "0", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none", "test", "vector", "data", "that", "looks", "2d", "but", "doesn", "t", "really", "have", "rows", "p", "establish_variables", "data", "x", "np", "newaxis", "assert", "len", "p", "plot_data", "1", "assert", "len", "p", "plot_data", "0", "self", "x", "shape", "0", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none"], "doc_len": 98}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_3d_input_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_3d_input_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_3d_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test that passing actually 3D data raises\n        x = np.zeros((5, 5, 5))\n        with pytest.raises(ValueError):\n            p.establish_variables(data=x)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_3d_input_data", "self", "p", "cat", "_categoricalplotter", "test", "that", "passing", "actually", "3d", "data", "raises", "x", "np", "zeros", "5", "5", "5", "with", "pytest", "raises", "valueerror", "p", "establish_variables", "data", "x"], "doc_len": 31}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_list_of_array_input_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_list_of_array_input_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_list_of_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test 2D input in list form\n        x_list = self.x.T.tolist()\n        p.establish_variables(data=x_list)\n        assert len(p.plot_data) == 3\n\n        lengths = [len(v_i) for v_i in p.plot_data]\n        assert lengths == [self.n_total / 3] * 3\n\n        assert p.group_label is None\n        assert p.value_label is None\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_list_of_array_input_data", "self", "p", "cat", "_categoricalplotter", "test", "2d", "input", "in", "list", "form", "x_list", "self", "x", "t", "tolist", "p", "establish_variables", "data", "x_list", "assert", "len", "p", "plot_data", "3", "lengths", "len", "v_i", "for", "v_i", "in", "p", "plot_data", "assert", "lengths", "self", "n_total", "3", "3", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none"], "doc_len": 54}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_wide_array_input_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_wide_array_input_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_wide_array_input_data(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test 2D input in array form\n        p.establish_variables(data=self.x)\n        assert np.shape(p.plot_data) == (3, self.n_total / 3)\n        npt.assert_array_equal(p.plot_data, self.x.T)\n\n        assert p.group_label is None\n        assert p.value_label is None\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_wide_array_input_data", "self", "p", "cat", "_categoricalplotter", "test", "2d", "input", "in", "array", "form", "p", "establish_variables", "data", "self", "x", "assert", "np", "shape", "p", "plot_data", "3", "self", "n_total", "3", "npt", "assert_array_equal", "p", "plot_data", "self", "x", "t", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none"], "doc_len": 47}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_single_long_direct_inputs", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_single_long_direct_inputs", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_single_long_direct_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test passing a series to the x variable\n        p.establish_variables(x=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        assert p.orient == \"h\"\n        assert p.value_label == \"y_data\"\n        assert p.group_label is None\n\n        # Test passing a series to the y variable\n        p.establish_variables(y=self.y)\n        npt.assert_equal(p.plot_data, [self.y])\n        assert p.orient == \"v\"\n        assert p.value_label == \"y_data\"\n        assert p.group_label is None\n\n        # Test passing an array to the y variable\n        p.establish_variables(y=self.y.values)\n        npt.assert_equal(p.plot_data, [self.y])\n        assert p.orient == \"v\"\n        assert p.group_label is None\n        assert p.value_label is None\n\n        # Test array and series with non-default index\n        x = pd.Series([1, 1, 1, 1], index=[0, 2, 4, 6])\n        y = np.array([1, 2, 3, 4])\n        p.establish_variables(x, y)\n        assert len(p.plot_data[0]) == 4\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_single_long_direct_inputs", "self", "p", "cat", "_categoricalplotter", "test", "passing", "a", "series", "to", "the", "x", "variable", "p", "establish_variables", "x", "self", "y", "npt", "assert_equal", "p", "plot_data", "self", "y", "assert", "p", "orient", "h", "assert", "p", "value_label", "y_data", "assert", "p", "group_label", "is", "none", "test", "passing", "a", "series", "to", "the", "y", "variable", "p", "establish_variables", "y", "self", "y", "npt", "assert_equal", "p", "plot_data", "self", "y", "assert", "p", "orient", "v", "assert", "p", "value_label", "y_data", "assert", "p", "group_label", "is", "none", "test", "passing", "an", "array", "to", "the", "y", "variable", "p", "establish_variables", "y", "self", "y", "values", "npt", "assert_equal", "p", "plot_data", "self", "y", "assert", "p", "orient", "v", "assert", "p", "group_label", "is", "none", "assert", "p", "value_label", "is", "none", "test", "array", "and", "series", "with", "non", "default", "index", "x", "pd", "series", "1", "1", "1", "1", "index", "0", "2", "4", "6", "y", "np", "array", "1", "2", "3", "4", "p", "establish_variables", "x", "y", "assert", "len", "p", "plot_data", "0", "4"], "doc_len": 145}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_single_long_indirect_inputs", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_single_long_indirect_inputs", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_single_long_indirect_inputs(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test referencing a DataFrame series in the x variable\n        p.establish_variables(x=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        assert p.orient == \"h\"\n        assert p.value_label == \"y\"\n        assert p.group_label is None\n\n        # Test referencing a DataFrame series in the y variable\n        p.establish_variables(y=\"y\", data=self.df)\n        npt.assert_equal(p.plot_data, [self.y])\n        assert p.orient == \"v\"\n        assert p.value_label == \"y\"\n        assert p.group_label is None\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_single_long_indirect_inputs", "self", "p", "cat", "_categoricalplotter", "test", "referencing", "a", "dataframe", "series", "in", "the", "x", "variable", "p", "establish_variables", "x", "y", "data", "self", "df", "npt", "assert_equal", "p", "plot_data", "self", "y", "assert", "p", "orient", "h", "assert", "p", "value_label", "y", "assert", "p", "group_label", "is", "none", "test", "referencing", "a", "dataframe", "series", "in", "the", "y", "variable", "p", "establish_variables", "y", "y", "data", "self", "df", "npt", "assert_equal", "p", "plot_data", "self", "y", "assert", "p", "orient", "v", "assert", "p", "value_label", "y", "assert", "p", "group_label", "is", "none"], "doc_len": 80}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_longform_groupby", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_longform_groupby", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_longform_groupby(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test a vertically oriented grouped and nested plot\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert len(p.plot_data) == 3\n        assert len(p.plot_hues) == 3\n        assert p.orient == \"v\"\n        assert p.value_label == \"y\"\n        assert p.group_label == \"g\"\n        assert p.hue_title == \"h\"\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        # Test a grouped and nested plot with direct array value data\n        p.establish_variables(\"g\", self.y.values, \"h\", self.df)\n        assert p.value_label is None\n        assert p.group_label == \"g\"\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        # Test a grouped and nested plot with direct array hue data\n        p.establish_variables(\"g\", \"y\", self.h.values, self.df)\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        # Test categorical grouping data\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n\n        # Test that horizontal orientation is automatically detected\n        p.establish_variables(\"y\", \"g\", hue=\"h\", data=df)\n        assert len(p.plot_data) == 3\n        assert len(p.plot_hues) == 3\n        assert p.orient == \"h\"\n        assert p.value_label == \"y\"\n        assert p.group_label == \"g\"\n        assert p.hue_title == \"h\"\n\n        for group, vals in zip([\"a\", \"b\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        for group, hues in zip([\"a\", \"b\", \"c\"], p.plot_hues):\n            npt.assert_array_equal(hues, self.h[self.g == group])\n\n        # Test grouped data that matches on index\n        p1 = cat._CategoricalPlotter()\n        p1.establish_variables(self.g, self.y, hue=self.h)\n        p2 = cat._CategoricalPlotter()\n        p2.establish_variables(self.g, self.y.iloc[::-1], self.h)\n        for i, (d1, d2) in enumerate(zip(p1.plot_data, p2.plot_data)):\n            assert np.array_equal(d1.sort_index(), d2.sort_index())\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_longform_groupby", "self", "p", "cat", "_categoricalplotter", "test", "a", "vertically", "oriented", "grouped", "and", "nested", "plot", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "len", "p", "plot_data", "3", "assert", "len", "p", "plot_hues", "3", "assert", "p", "orient", "v", "assert", "p", "value_label", "y", "assert", "p", "group_label", "g", "assert", "p", "hue_title", "h", "for", "group", "vals", "in", "zip", "a", "b", "c", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "y", "self", "g", "group", "for", "group", "hues", "in", "zip", "a", "b", "c", "p", "plot_hues", "npt", "assert_array_equal", "hues", "self", "h", "self", "g", "group", "test", "a", "grouped", "and", "nested", "plot", "with", "direct", "array", "value", "data", "p", "establish_variables", "g", "self", "y", "values", "h", "self", "df", "assert", "p", "value_label", "is", "none", "assert", "p", "group_label", "g", "for", "group", "vals", "in", "zip", "a", "b", "c", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "y", "self", "g", "group", "test", "a", "grouped", "and", "nested", "plot", "with", "direct", "array", "hue", "data", "p", "establish_variables", "g", "y", "self", "h", "values", "self", "df", "for", "group", "hues", "in", "zip", "a", "b", "c", "p", "plot_hues", "npt", "assert_array_equal", "hues", "self", "h", "self", "g", "group", "test", "categorical", "grouping", "data", "df", "self", "df", "copy", "df", "g", "df", "g", "astype", "category", "test", "that", "horizontal", "orientation", "is", "automatically", "detected", "p", "establish_variables", "y", "g", "hue", "h", "data", "df", "assert", "len", "p", "plot_data", "3", "assert", "len", "p", "plot_hues", "3", "assert", "p", "orient", "h", "assert", "p", "value_label", "y", "assert", "p", "group_label", "g", "assert", "p", "hue_title", "h", "for", "group", "vals", "in", "zip", "a", "b", "c", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "y", "self", "g", "group", "for", "group", "hues", "in", "zip", "a", "b", "c", "p", "plot_hues", "npt", "assert_array_equal", "hues", "self", "h", "self", "g", "group", "test", "grouped", "data", "that", "matches", "on", "index", "p1", "cat", "_categoricalplotter", "p1", "establish_variables", "self", "g", "self", "y", "hue", "self", "h", "p2", "cat", "_categoricalplotter", "p2", "establish_variables", "self", "g", "self", "y", "iloc", "1", "self", "h", "for", "i", "d1", "d2", "in", "enumerate", "zip", "p1", "plot_data", "p2", "plot_data", "assert", "np", "array_equal", "d1", "sort_index", "d2", "sort_index"], "doc_len": 315}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_input_validation", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_input_validation", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_input_validation(self):\n\n        p = cat._CategoricalPlotter()\n\n        kws = dict(x=\"g\", y=\"y\", hue=\"h\", units=\"u\", data=self.df)\n        for var in [\"x\", \"y\", \"hue\", \"units\"]:\n            input_kws = kws.copy()\n            input_kws[var] = \"bad_input\"\n            with pytest.raises(ValueError):\n                p.establish_variables(**input_kws)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_input_validation", "self", "p", "cat", "_categoricalplotter", "kws", "dict", "x", "g", "y", "y", "hue", "h", "units", "u", "data", "self", "df", "for", "var", "in", "x", "y", "hue", "units", "input_kws", "kws", "copy", "input_kws", "var", "bad_input", "with", "pytest", "raises", "valueerror", "p", "establish_variables", "input_kws"], "doc_len": 43}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_order", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_order", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test inferred order from a wide dataframe input\n        p.establish_variables(data=self.x_df)\n        assert p.group_names == [\"X\", \"Y\", \"Z\"]\n\n        # Test specified order with a wide dataframe input\n        p.establish_variables(data=self.x_df, order=[\"Y\", \"Z\", \"X\"])\n        assert p.group_names == [\"Y\", \"Z\", \"X\"]\n\n        for group, vals in zip([\"Y\", \"Z\", \"X\"], p.plot_data):\n            npt.assert_array_equal(vals, self.x_df[group])\n\n        with pytest.raises(ValueError):\n            p.establish_variables(data=self.x, order=[1, 2, 0])\n\n        # Test inferred order from a grouped longform input\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        assert p.group_names == [\"a\", \"b\", \"c\"]\n\n        # Test specified order from a grouped longform input\n        p.establish_variables(\"g\", \"y\", data=self.df, order=[\"b\", \"a\", \"c\"])\n        assert p.group_names == [\"b\", \"a\", \"c\"]\n\n        for group, vals in zip([\"b\", \"a\", \"c\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        # Test inferred order from a grouped input with categorical groups\n        df = self.df.copy()\n        df.g = df.g.astype(\"category\")\n        df.g = df.g.cat.reorder_categories([\"c\", \"b\", \"a\"])\n        p.establish_variables(\"g\", \"y\", data=df)\n        assert p.group_names == [\"c\", \"b\", \"a\"]\n\n        for group, vals in zip([\"c\", \"b\", \"a\"], p.plot_data):\n            npt.assert_array_equal(vals, self.y[self.g == group])\n\n        df.g = (df.g.cat.add_categories(\"d\")\n                    .cat.reorder_categories([\"c\", \"b\", \"d\", \"a\"]))\n        p.establish_variables(\"g\", \"y\", data=df)\n        assert p.group_names == [\"c\", \"b\", \"d\", \"a\"]\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_order", "self", "p", "cat", "_categoricalplotter", "test", "inferred", "order", "from", "a", "wide", "dataframe", "input", "p", "establish_variables", "data", "self", "x_df", "assert", "p", "group_names", "x", "y", "z", "test", "specified", "order", "with", "a", "wide", "dataframe", "input", "p", "establish_variables", "data", "self", "x_df", "order", "y", "z", "x", "assert", "p", "group_names", "y", "z", "x", "for", "group", "vals", "in", "zip", "y", "z", "x", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "x_df", "group", "with", "pytest", "raises", "valueerror", "p", "establish_variables", "data", "self", "x", "order", "1", "2", "0", "test", "inferred", "order", "from", "a", "grouped", "longform", "input", "p", "establish_variables", "g", "y", "data", "self", "df", "assert", "p", "group_names", "a", "b", "c", "test", "specified", "order", "from", "a", "grouped", "longform", "input", "p", "establish_variables", "g", "y", "data", "self", "df", "order", "b", "a", "c", "assert", "p", "group_names", "b", "a", "c", "for", "group", "vals", "in", "zip", "b", "a", "c", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "y", "self", "g", "group", "test", "inferred", "order", "from", "a", "grouped", "input", "with", "categorical", "groups", "df", "self", "df", "copy", "df", "g", "df", "g", "astype", "category", "df", "g", "df", "g", "cat", "reorder_categories", "c", "b", "a", "p", "establish_variables", "g", "y", "data", "df", "assert", "p", "group_names", "c", "b", "a", "for", "group", "vals", "in", "zip", "c", "b", "a", "p", "plot_data", "npt", "assert_array_equal", "vals", "self", "y", "self", "g", "group", "df", "g", "df", "g", "cat", "add_categories", "d", "cat", "reorder_categories", "c", "b", "d", "a", "p", "establish_variables", "g", "y", "data", "df", "assert", "p", "group_names", "c", "b", "d", "a"], "doc_len": 230}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_hue_order", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_hue_order", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_hue_order(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test inferred hue order\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert p.hue_names == [\"m\", \"n\"]\n\n        # Test specified hue order\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df,\n                              hue_order=[\"n\", \"m\"])\n        assert p.hue_names == [\"n\", \"m\"]\n\n        # Test inferred hue order from a categorical hue input\n        df = self.df.copy()\n        df.h = df.h.astype(\"category\")\n        df.h = df.h.cat.reorder_categories([\"n\", \"m\"])\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=df)\n        assert p.hue_names == [\"n\", \"m\"]\n\n        df.h = (df.h.cat.add_categories(\"o\")\n                    .cat.reorder_categories([\"o\", \"m\", \"n\"]))\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=df)\n        assert p.hue_names == [\"o\", \"m\", \"n\"]\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_hue_order", "self", "p", "cat", "_categoricalplotter", "test", "inferred", "hue", "order", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "p", "hue_names", "m", "n", "test", "specified", "hue", "order", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "hue_order", "n", "m", "assert", "p", "hue_names", "n", "m", "test", "inferred", "hue", "order", "from", "a", "categorical", "hue", "input", "df", "self", "df", "copy", "df", "h", "df", "h", "astype", "category", "df", "h", "df", "h", "cat", "reorder_categories", "n", "m", "p", "establish_variables", "g", "y", "hue", "h", "data", "df", "assert", "p", "hue_names", "n", "m", "df", "h", "df", "h", "cat", "add_categories", "o", "cat", "reorder_categories", "o", "m", "n", "p", "establish_variables", "g", "y", "hue", "h", "data", "df", "assert", "p", "hue_names", "o", "m", "n"], "doc_len": 115}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_plot_units", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_plot_units", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_plot_units(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert p.plot_units is None\n\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df, units=\"u\")\n        for group, units in zip([\"a\", \"b\", \"c\"], p.plot_units):\n            npt.assert_array_equal(units, self.u[self.g == group])\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_plot_units", "self", "p", "cat", "_categoricalplotter", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "p", "plot_units", "is", "none", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "units", "u", "for", "group", "units", "in", "zip", "a", "b", "c", "p", "plot_units", "npt", "assert_array_equal", "units", "self", "u", "self", "g", "group"], "doc_len": 53}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_default_palettes", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_default_palettes", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_default_palettes(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=3)\n\n        # Test palette mapping the hue position\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, None, 1)\n        assert p.colors == palettes.color_palette(n_colors=2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_default_palettes", "self", "p", "cat", "_categoricalplotter", "test", "palette", "mapping", "the", "x", "position", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "none", "none", "1", "assert", "p", "colors", "palettes", "color_palette", "n_colors", "3", "test", "palette", "mapping", "the", "hue", "position", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "p", "establish_colors", "none", "none", "1", "assert", "p", "colors", "palettes", "color_palette", "n_colors", "2"], "doc_len": 62}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_default_palette_with_many_levels", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_default_palette_with_many_levels", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_default_palette_with_many_levels(self):\n\n        with palettes.color_palette([\"blue\", \"red\"], 2):\n            p = cat._CategoricalPlotter()\n            p.establish_variables(\"g\", \"y\", data=self.df)\n            p.establish_colors(None, None, 1)\n            npt.assert_array_equal(p.colors,\n                                   palettes.husl_palette(3, l=.7))  # noqa\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_default_palette_with_many_levels", "self", "with", "palettes", "color_palette", "blue", "red", "2", "p", "cat", "_categoricalplotter", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "none", "none", "1", "npt", "assert_array_equal", "p", "colors", "palettes", "husl_palette", "3", "l", "7", "noqa"], "doc_len": 38}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_specific_color", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_specific_color", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_specific_color(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test the same color for each x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", None, 1)\n        blue_rgb = mpl.colors.colorConverter.to_rgb(\"blue\")\n        assert p.colors == [blue_rgb] * 3\n\n        # Test a color-based blend for the hue mapping\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(\"#ff0022\", None, 1)\n        rgba_array = np.array(palettes.light_palette(\"#ff0022\", 2))\n        npt.assert_array_almost_equal(p.colors,\n                                      rgba_array[:, :3])\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_specific_color", "self", "p", "cat", "_categoricalplotter", "test", "the", "same", "color", "for", "each", "x", "position", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "blue", "none", "1", "blue_rgb", "mpl", "colors", "colorconverter", "to_rgb", "blue", "assert", "p", "colors", "blue_rgb", "3", "test", "a", "color", "based", "blend", "for", "the", "hue", "mapping", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "p", "establish_colors", "ff0022", "none", "1", "rgba_array", "np", "array", "palettes", "light_palette", "ff0022", "2", "npt", "assert_array_almost_equal", "p", "colors", "rgba_array", "3"], "doc_len": 77}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_specific_palette", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_specific_palette", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_specific_palette(self):\n\n        p = cat._CategoricalPlotter()\n\n        # Test palette mapping the x position\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(None, \"dark\", 1)\n        assert p.colors == palettes.color_palette(\"dark\", 3)\n\n        # Test that non-None `color` and `hue` raises an error\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.establish_colors(None, \"muted\", 1)\n        assert p.colors == palettes.color_palette(\"muted\", 2)\n\n        # Test that specified palette overrides specified color\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors(\"blue\", \"deep\", 1)\n        assert p.colors == palettes.color_palette(\"deep\", 3)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_specific_palette", "self", "p", "cat", "_categoricalplotter", "test", "palette", "mapping", "the", "x", "position", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "none", "dark", "1", "assert", "p", "colors", "palettes", "color_palette", "dark", "3", "test", "that", "non", "none", "color", "and", "hue", "raises", "an", "error", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "p", "establish_colors", "none", "muted", "1", "assert", "p", "colors", "palettes", "color_palette", "muted", "2", "test", "that", "specified", "palette", "overrides", "specified", "color", "p", "cat", "_categoricalplotter", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "blue", "deep", "1", "assert", "p", "colors", "palettes", "color_palette", "deep", "3"], "doc_len": 95}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_dict_as_palette", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_dict_as_palette", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_dict_as_palette(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        pal = {\"m\": (0, 0, 1), \"n\": (1, 0, 0)}\n        p.establish_colors(None, pal, 1)\n        assert p.colors == [(0, 0, 1), (1, 0, 0)]\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_dict_as_palette", "self", "p", "cat", "_categoricalplotter", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "pal", "m", "0", "0", "1", "n", "1", "0", "0", "p", "establish_colors", "none", "pal", "1", "assert", "p", "colors", "0", "0", "1", "1", "0", "0"], "doc_len": 42}
{"doc_id": "tests/test_categorical.py::TestCategoricalPlotter.test_palette_desaturation", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalPlotter", "func_name": "test_palette_desaturation", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalPlotter\n    def test_palette_desaturation(self):\n\n        p = cat._CategoricalPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.establish_colors((0, 0, 1), None, .5)\n        assert p.colors == [(.25, .25, .75)] * 3\n\n        p.establish_colors(None, [(0, 0, 1), (1, 0, 0), \"w\"], .5)\n        assert p.colors == [(.25, .25, .75), (.75, .25, .25), (1, 1, 1)]\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalplotter", "def", "test_palette_desaturation", "self", "p", "cat", "_categoricalplotter", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "establish_colors", "0", "0", "1", "none", "5", "assert", "p", "colors", "25", "25", "75", "3", "p", "establish_colors", "none", "0", "0", "1", "1", "0", "0", "w", "5", "assert", "p", "colors", "25", "25", "75", "75", "25", "25", "1", "1", "1"], "doc_len": 54}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_no_bootstrappig", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_no_bootstrappig", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_no_bootstrappig(self):\n\n        p = cat._CategoricalStatPlotter()\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        p.estimate_statistic(\"mean\", None, 100, None)\n        npt.assert_array_equal(p.confint, np.array([]))\n\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        p.estimate_statistic(np.mean, None, 100, None)\n        npt.assert_array_equal(p.confint, np.array([[], [], []]))\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_no_bootstrappig", "self", "p", "cat", "_categoricalstatplotter", "p", "establish_variables", "g", "y", "data", "self", "df", "p", "estimate_statistic", "mean", "none", "100", "none", "npt", "assert_array_equal", "p", "confint", "np", "array", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "p", "estimate_statistic", "np", "mean", "none", "100", "none", "npt", "assert_array_equal", "p", "confint", "np", "array"], "doc_len": 51}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_single_layer_stats", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_single_layer_stats", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_single_layer_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n\n        assert p.statistic.shape == (3,)\n        assert p.confint.shape == (3, 2)\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            sem = grp_y.std() / np.sqrt(len(grp_y))\n            mean = grp_y.mean()\n            half_ci = _normal_quantile_func(.975) * sem\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_single_layer_stats", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "assert", "p", "statistic", "shape", "3", "assert", "p", "confint", "shape", "3", "2", "npt", "assert_array_almost_equal", "p", "statistic", "y", "groupby", "g", "mean", "for", "ci", "_", "grp_y", "in", "zip", "p", "confint", "y", "groupby", "g", "sem", "grp_y", "std", "np", "sqrt", "len", "grp_y", "mean", "grp_y", "mean", "half_ci", "_normal_quantile_func", "975", "sem", "ci_want", "mean", "half_ci", "mean", "half_ci", "npt", "assert_array_almost_equal", "ci_want", "ci", "2"], "doc_len": 92}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_single_layer_stats_with_units", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_single_layer_stats_with_units", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_single_layer_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        u = pd.Series(np.repeat(np.tile(list(\"xyz\"), 30), 3))\n        y[u == \"x\"] -= 3\n        y[u == \"y\"] += 3\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, units=u)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 1] - ci1[:, 0]\n        ci2_size = ci2[:, 1] - ci2[:, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_single_layer_stats_with_units", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "90", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "270", "u", "pd", "series", "np", "repeat", "np", "tile", "list", "xyz", "30", "3", "y", "u", "x", "3", "y", "u", "y", "3", "p", "establish_variables", "g", "y", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "stat1", "ci1", "p", "statistic", "p", "confint", "p", "establish_variables", "g", "y", "units", "u", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "stat2", "ci2", "p", "statistic", "p", "confint", "npt", "assert_array_equal", "stat1", "stat2", "ci1_size", "ci1", "1", "ci1", "0", "ci2_size", "ci2", "1", "ci2", "0", "npt", "assert_array_less", "ci1_size", "ci2_size"], "doc_len": 100}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_single_layer_stats_with_missing_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_single_layer_stats_with_missing_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_single_layer_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, order=list(\"abdc\"))\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n\n        assert p.statistic.shape == (4,)\n        assert p.confint.shape == (4, 2)\n\n        rows = g == \"b\"\n        mean = y[rows].mean()\n        sem = y[rows].std() / np.sqrt(rows.sum())\n        half_ci = _normal_quantile_func(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1], mean)\n        npt.assert_array_almost_equal(p.confint[1], ci, 2)\n\n        npt.assert_equal(p.statistic[2], np.nan)\n        npt.assert_array_equal(p.confint[2], (np.nan, np.nan))\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_single_layer_stats_with_missing_data", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "order", "list", "abdc", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "assert", "p", "statistic", "shape", "4", "assert", "p", "confint", "shape", "4", "2", "rows", "g", "b", "mean", "y", "rows", "mean", "sem", "y", "rows", "std", "np", "sqrt", "rows", "sum", "half_ci", "_normal_quantile_func", "975", "sem", "ci", "mean", "half_ci", "mean", "half_ci", "npt", "assert_almost_equal", "p", "statistic", "1", "mean", "npt", "assert_array_almost_equal", "p", "confint", "1", "ci", "2", "npt", "assert_equal", "p", "statistic", "2", "np", "nan", "npt", "assert_array_equal", "p", "confint", "2", "np", "nan", "np", "nan"], "doc_len": 105}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_nested_stats", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_nested_stats", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_nested_stats(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 50000, None)\n\n        assert p.statistic.shape == (3, 2)\n        assert p.confint.shape == (3, 2, 2)\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y.iloc[::2], grp_y.iloc[1::2]]):\n                sem = hue_y.std() / np.sqrt(len(hue_y))\n                mean = hue_y.mean()\n                half_ci = _normal_quantile_func(.975) * sem\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_nested_stats", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "h", "pd", "series", "np", "tile", "list", "xy", "150", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "h", "p", "estimate_statistic", "mean", "ci", "95", "50000", "none", "assert", "p", "statistic", "shape", "3", "2", "assert", "p", "confint", "shape", "3", "2", "2", "npt", "assert_array_almost_equal", "p", "statistic", "y", "groupby", "g", "h", "mean", "unstack", "for", "ci_g", "_", "grp_y", "in", "zip", "p", "confint", "y", "groupby", "g", "for", "ci", "hue_y", "in", "zip", "ci_g", "grp_y", "iloc", "2", "grp_y", "iloc", "1", "2", "sem", "hue_y", "std", "np", "sqrt", "len", "hue_y", "mean", "hue_y", "mean", "half_ci", "_normal_quantile_func", "975", "sem", "ci_want", "mean", "half_ci", "mean", "half_ci", "npt", "assert_array_almost_equal", "ci_want", "ci", "2"], "doc_len": 118}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_bootstrap_seed", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_bootstrap_seed", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_bootstrap_seed(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 1000, 0)\n        confint_1 = p.confint\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 1000, 0)\n        confint_2 = p.confint\n\n        npt.assert_array_equal(confint_1, confint_2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_bootstrap_seed", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "h", "pd", "series", "np", "tile", "list", "xy", "150", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "h", "p", "estimate_statistic", "mean", "ci", "95", "1000", "0", "confint_1", "p", "confint", "p", "estimate_statistic", "mean", "ci", "95", "1000", "0", "confint_2", "p", "confint", "npt", "assert_array_equal", "confint_1", "confint_2"], "doc_len": 64}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_nested_stats_with_units", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_nested_stats_with_units", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_nested_stats_with_units(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 90))\n        h = pd.Series(np.tile(list(\"xy\"), 135))\n        u = pd.Series(np.repeat(list(\"ijkijk\"), 45))\n        y = pd.Series(np.random.RandomState(0).randn(270))\n        y[u == \"i\"] -= 3\n        y[u == \"k\"] += 3\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n        stat1, ci1 = p.statistic, p.confint\n\n        p.establish_variables(g, y, h, units=u)\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 10000, None)\n        stat2, ci2 = p.statistic, p.confint\n\n        npt.assert_array_equal(stat1, stat2)\n        ci1_size = ci1[:, 0, 1] - ci1[:, 0, 0]\n        ci2_size = ci2[:, 0, 1] - ci2[:, 0, 0]\n        npt.assert_array_less(ci1_size, ci2_size)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_nested_stats_with_units", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "90", "h", "pd", "series", "np", "tile", "list", "xy", "135", "u", "pd", "series", "np", "repeat", "list", "ijkijk", "45", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "270", "y", "u", "i", "3", "y", "u", "k", "3", "p", "establish_variables", "g", "y", "h", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "stat1", "ci1", "p", "statistic", "p", "confint", "p", "establish_variables", "g", "y", "h", "units", "u", "p", "estimate_statistic", "mean", "ci", "95", "10000", "none", "stat2", "ci2", "p", "statistic", "p", "confint", "npt", "assert_array_equal", "stat1", "stat2", "ci1_size", "ci1", "0", "1", "ci1", "0", "0", "ci2_size", "ci2", "0", "1", "ci2", "0", "0", "npt", "assert_array_less", "ci1_size", "ci2_size"], "doc_len": 111}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_nested_stats_with_missing_data", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_nested_stats_with_missing_data", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_nested_stats_with_missing_data(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n\n        p.establish_variables(g, y, h,\n                              order=list(\"abdc\"),\n                              hue_order=list(\"zyx\"))\n        p.estimate_statistic(\"mean\", (\"ci\", 95), 50000, None)\n\n        assert p.statistic.shape == (4, 3)\n        assert p.confint.shape == (4, 3, 2)\n\n        rows = (g == \"b\") & (h == \"x\")\n        mean = y[rows].mean()\n        sem = y[rows].std() / np.sqrt(rows.sum())\n        half_ci = _normal_quantile_func(.975) * sem\n        ci = mean - half_ci, mean + half_ci\n        npt.assert_almost_equal(p.statistic[1, 2], mean)\n        npt.assert_array_almost_equal(p.confint[1, 2], ci, 2)\n\n        npt.assert_array_equal(p.statistic[:, 0], [np.nan] * 4)\n        npt.assert_array_equal(p.statistic[2], [np.nan] * 3)\n        npt.assert_array_equal(p.confint[:, 0],\n                               np.zeros((4, 2)) * np.nan)\n        npt.assert_array_equal(p.confint[2],\n                               np.zeros((3, 2)) * np.nan)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_nested_stats_with_missing_data", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "h", "pd", "series", "np", "tile", "list", "xy", "150", "p", "establish_variables", "g", "y", "h", "order", "list", "abdc", "hue_order", "list", "zyx", "p", "estimate_statistic", "mean", "ci", "95", "50000", "none", "assert", "p", "statistic", "shape", "4", "3", "assert", "p", "confint", "shape", "4", "3", "2", "rows", "g", "b", "h", "x", "mean", "y", "rows", "mean", "sem", "y", "rows", "std", "np", "sqrt", "rows", "sum", "half_ci", "_normal_quantile_func", "975", "sem", "ci", "mean", "half_ci", "mean", "half_ci", "npt", "assert_almost_equal", "p", "statistic", "1", "2", "mean", "npt", "assert_array_almost_equal", "p", "confint", "1", "2", "ci", "2", "npt", "assert_array_equal", "p", "statistic", "0", "np", "nan", "4", "npt", "assert_array_equal", "p", "statistic", "2", "np", "nan", "3", "npt", "assert_array_equal", "p", "confint", "0", "np", "zeros", "4", "2", "np", "nan", "npt", "assert_array_equal", "p", "confint", "2", "np", "zeros", "3", "2", "np", "nan"], "doc_len": 145}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_sd_error_bars", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_sd_error_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y)\n        p.estimate_statistic(np.mean, \"sd\", None, None)\n\n        assert p.statistic.shape == (3,)\n        assert p.confint.shape == (3, 2)\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby(g).mean())\n\n        for ci, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            mean = grp_y.mean()\n            half_ci = np.std(grp_y)\n            ci_want = mean - half_ci, mean + half_ci\n            npt.assert_array_almost_equal(ci_want, ci, 2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_sd_error_bars", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "p", "estimate_statistic", "np", "mean", "sd", "none", "none", "assert", "p", "statistic", "shape", "3", "assert", "p", "confint", "shape", "3", "2", "npt", "assert_array_almost_equal", "p", "statistic", "y", "groupby", "g", "mean", "for", "ci", "_", "grp_y", "in", "zip", "p", "confint", "y", "groupby", "g", "mean", "grp_y", "mean", "half_ci", "np", "std", "grp_y", "ci_want", "mean", "half_ci", "mean", "half_ci", "npt", "assert_array_almost_equal", "ci_want", "ci", "2"], "doc_len": 85}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_nested_sd_error_bars", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_nested_sd_error_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_nested_sd_error_bars(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        g = pd.Series(np.repeat(list(\"abc\"), 100))\n        h = pd.Series(np.tile(list(\"xy\"), 150))\n        y = pd.Series(np.random.RandomState(0).randn(300))\n\n        p.establish_variables(g, y, h)\n        p.estimate_statistic(np.mean, \"sd\", None, None)\n\n        assert p.statistic.shape == (3, 2)\n        assert p.confint.shape == (3, 2, 2)\n\n        npt.assert_array_almost_equal(p.statistic,\n                                      y.groupby([g, h]).mean().unstack())\n\n        for ci_g, (_, grp_y) in zip(p.confint, y.groupby(g)):\n            for ci, hue_y in zip(ci_g, [grp_y.iloc[::2], grp_y.iloc[1::2]]):\n                mean = hue_y.mean()\n                half_ci = np.std(hue_y)\n                ci_want = mean - half_ci, mean + half_ci\n                npt.assert_array_almost_equal(ci_want, ci, 2)\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_nested_sd_error_bars", "self", "p", "cat", "_categoricalstatplotter", "g", "pd", "series", "np", "repeat", "list", "abc", "100", "h", "pd", "series", "np", "tile", "list", "xy", "150", "y", "pd", "series", "np", "random", "randomstate", "0", "randn", "300", "p", "establish_variables", "g", "y", "h", "p", "estimate_statistic", "np", "mean", "sd", "none", "none", "assert", "p", "statistic", "shape", "3", "2", "assert", "p", "confint", "shape", "3", "2", "2", "npt", "assert_array_almost_equal", "p", "statistic", "y", "groupby", "g", "h", "mean", "unstack", "for", "ci_g", "_", "grp_y", "in", "zip", "p", "confint", "y", "groupby", "g", "for", "ci", "hue_y", "in", "zip", "ci_g", "grp_y", "iloc", "2", "grp_y", "iloc", "1", "2", "mean", "hue_y", "mean", "half_ci", "np", "std", "hue_y", "ci_want", "mean", "half_ci", "mean", "half_ci", "npt", "assert_array_almost_equal", "ci_want", "ci", "2"], "doc_len": 111}
{"doc_id": "tests/test_categorical.py::TestCategoricalStatPlotter.test_draw_cis", "file_path": "tests/test_categorical.py", "class_name": "TestCategoricalStatPlotter", "func_name": "test_draw_cis", "text": "文件路径: tests/test_categorical.py, 类名: TestCategoricalStatPlotter\n    def test_draw_cis(self):\n\n        p = cat._CategoricalStatPlotter()\n\n        # Test vertical CIs\n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        at_group = [0, 1]\n        confints = [(.5, 1.5), (.25, .8)]\n        colors = [\".2\", \".3\"]\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, [at, at])\n            npt.assert_array_equal(y, ci)\n            assert line.get_color() == c\n\n        plt.close(\"all\")\n\n        # Test horizontal CIs\n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors)\n\n        lines = ax.lines\n        for line, at, ci, c in zip(lines, at_group, confints, colors):\n            x, y = line.get_xydata().T\n            npt.assert_array_equal(x, ci)\n            npt.assert_array_equal(y, [at, at])\n            assert line.get_color() == c\n\n        plt.close(\"all\")\n\n        # Test vertical CIs with endcaps\n        p.orient = \"v\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_xdata()[0]\n        caplineend = capline.get_xdata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        assert caplinelength == approx(0.3)\n        assert len(ax.lines) == 6\n\n        plt.close(\"all\")\n\n        # Test horizontal CIs with endcaps\n        p.orient = \"h\"\n\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, capsize=0.3)\n        capline = ax.lines[len(ax.lines) - 1]\n        caplinestart = capline.get_ydata()[0]\n        caplineend = capline.get_ydata()[1]\n        caplinelength = abs(caplineend - caplinestart)\n        assert caplinelength == approx(0.3)\n        assert len(ax.lines) == 6\n\n        # Test extra keyword arguments\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, lw=4)\n        line = ax.lines[0]\n        assert line.get_linewidth() == 4\n\n        plt.close(\"all\")\n\n        # Test errwidth is set appropriately\n        f, ax = plt.subplots()\n        p.draw_confints(ax, at_group, confints, colors, errwidth=2)\n        capline = ax.lines[len(ax.lines) - 1]\n        assert capline._linewidth == 2\n        assert len(ax.lines) == 2\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testcategoricalstatplotter", "def", "test_draw_cis", "self", "p", "cat", "_categoricalstatplotter", "test", "vertical", "cis", "p", "orient", "v", "f", "ax", "plt", "subplots", "at_group", "0", "1", "confints", "5", "1", "5", "25", "8", "colors", "2", "3", "p", "draw_confints", "ax", "at_group", "confints", "colors", "lines", "ax", "lines", "for", "line", "at", "ci", "c", "in", "zip", "lines", "at_group", "confints", "colors", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "at", "at", "npt", "assert_array_equal", "y", "ci", "assert", "line", "get_color", "c", "plt", "close", "all", "test", "horizontal", "cis", "p", "orient", "h", "f", "ax", "plt", "subplots", "p", "draw_confints", "ax", "at_group", "confints", "colors", "lines", "ax", "lines", "for", "line", "at", "ci", "c", "in", "zip", "lines", "at_group", "confints", "colors", "x", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "ci", "npt", "assert_array_equal", "y", "at", "at", "assert", "line", "get_color", "c", "plt", "close", "all", "test", "vertical", "cis", "with", "endcaps", "p", "orient", "v", "f", "ax", "plt", "subplots", "p", "draw_confints", "ax", "at_group", "confints", "colors", "capsize", "0", "3", "capline", "ax", "lines", "len", "ax", "lines", "1", "caplinestart", "capline", "get_xdata", "0", "caplineend", "capline", "get_xdata", "1", "caplinelength", "abs", "caplineend", "caplinestart", "assert", "caplinelength", "approx", "0", "3", "assert", "len", "ax", "lines", "6", "plt", "close", "all", "test", "horizontal", "cis", "with", "endcaps", "p", "orient", "h", "f", "ax", "plt", "subplots", "p", "draw_confints", "ax", "at_group", "confints", "colors", "capsize", "0", "3", "capline", "ax", "lines", "len", "ax", "lines", "1", "caplinestart", "capline", "get_ydata", "0", "caplineend", "capline", "get_ydata", "1", "caplinelength", "abs", "caplineend", "caplinestart", "assert", "caplinelength", "approx", "0", "3", "assert", "len", "ax", "lines", "6", "test", "extra", "keyword", "arguments", "f", "ax", "plt", "subplots", "p", "draw_confints", "ax", "at_group", "confints", "colors", "lw", "4", "line", "ax", "lines", "0", "assert", "line", "get_linewidth", "4", "plt", "close", "all", "test", "errwidth", "is", "set", "appropriately", "f", "ax", "plt", "subplots", "p", "draw_confints", "ax", "at_group", "confints", "colors", "errwidth", "2", "capline", "ax", "lines", "len", "ax", "lines", "1", "assert", "capline", "_linewidth", "2", "assert", "len", "ax", "lines", "2", "plt", "close", "all"], "doc_len": 290}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_nested_width", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_nested_width", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_nested_width(self):\n\n        kws = self.default_kws.copy()\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert p.nested_width == .4 * .98\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert p.nested_width == .3 * .98\n\n        kws = self.default_kws.copy()\n        kws[\"dodge\"] = False\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        assert p.nested_width == .8\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_nested_width", "self", "kws", "self", "default_kws", "copy", "p", "cat", "_boxplotter", "kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "p", "nested_width", "4", "98", "kws", "self", "default_kws", "copy", "kws", "width", "6", "p", "cat", "_boxplotter", "kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "p", "nested_width", "3", "98", "kws", "self", "default_kws", "copy", "kws", "dodge", "false", "p", "cat", "_boxplotter", "kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "assert", "p", "nested_width", "8"], "doc_len": 78}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_hue_offsets", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_hue_offsets", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_hue_offsets(self):\n\n        p = cat._BoxPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._BoxPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_hue_offsets", "self", "p", "cat", "_boxplotter", "self", "default_kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "npt", "assert_array_equal", "p", "hue_offsets", "2", "2", "kws", "self", "default_kws", "copy", "kws", "width", "6", "p", "cat", "_boxplotter", "kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "npt", "assert_array_equal", "p", "hue_offsets", "15", "15", "p", "cat", "_boxplotter", "kws", "p", "establish_variables", "h", "y", "g", "data", "self", "df", "npt", "assert_array_almost_equal", "p", "hue_offsets", "2", "0", "2"], "doc_len": 72}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_axes_data", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_axes_data", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_axes_data(self):\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", data=self.df)\n        assert len(self.get_box_artists(ax)) == 3\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        assert len(self.get_box_artists(ax)) == 6\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_axes_data", "self", "ax", "cat", "boxplot", "x", "g", "y", "y", "data", "self", "df", "assert", "len", "self", "get_box_artists", "ax", "3", "plt", "close", "all", "ax", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "assert", "len", "self", "get_box_artists", "ax", "6", "plt", "close", "all"], "doc_len": 47}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_box_colors", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_box_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_box_colors(self):\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=3)\n        assert same_color([patch.get_facecolor() for patch in self.get_box_artists(ax)],\n                          pal)\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, saturation=1)\n        pal = palettes.color_palette(n_colors=2)\n        assert same_color([patch.get_facecolor() for patch in self.get_box_artists(ax)],\n                          pal * 3)\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_box_colors", "self", "ax", "cat", "boxplot", "x", "g", "y", "y", "data", "self", "df", "saturation", "1", "pal", "palettes", "color_palette", "n_colors", "3", "assert", "same_color", "patch", "get_facecolor", "for", "patch", "in", "self", "get_box_artists", "ax", "pal", "plt", "close", "all", "ax", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "saturation", "1", "pal", "palettes", "color_palette", "n_colors", "2", "assert", "same_color", "patch", "get_facecolor", "for", "patch", "in", "self", "get_box_artists", "ax", "pal", "3", "plt", "close", "all"], "doc_len": 72}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_draw_missing_boxes", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_draw_missing_boxes", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_draw_missing_boxes(self):\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", data=self.df,\n                         order=[\"a\", \"b\", \"c\", \"d\"])\n        assert len(self.get_box_artists(ax)) == 3\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_draw_missing_boxes", "self", "ax", "cat", "boxplot", "x", "g", "y", "y", "data", "self", "df", "order", "a", "b", "c", "d", "assert", "len", "self", "get_box_artists", "ax", "3"], "doc_len": 28}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_missing_data", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_missing_data", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.boxplot(x=x, y=y)\n        assert len(self.get_box_artists(ax)) == 3\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.boxplot(x=x, y=y, hue=h)\n        assert len(self.get_box_artists(ax)) == 7\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_missing_data", "self", "x", "a", "a", "b", "b", "c", "c", "d", "d", "h", "x", "y", "x", "y", "x", "y", "x", "y", "y", "self", "rs", "randn", "8", "y", "2", "np", "nan", "ax", "cat", "boxplot", "x", "x", "y", "y", "assert", "len", "self", "get_box_artists", "ax", "3", "plt", "close", "all", "y", "1", "0", "ax", "cat", "boxplot", "x", "x", "y", "y", "hue", "h", "assert", "len", "self", "get_box_artists", "ax", "7", "plt", "close", "all"], "doc_len": 71}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_unaligned_index", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_unaligned_index", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_unaligned_index(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        cat.boxplot(x=self.g, y=self.y, ax=ax1)\n        cat.boxplot(x=self.g, y=self.y_perm, ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert np.array_equal(l1.get_xydata(), l2.get_xydata())\n\n        f, (ax1, ax2) = plt.subplots(2)\n        hue_order = self.h.unique()\n        cat.boxplot(x=self.g, y=self.y, hue=self.h,\n                    hue_order=hue_order, ax=ax1)\n        cat.boxplot(x=self.g, y=self.y_perm, hue=self.h,\n                    hue_order=hue_order, ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert np.array_equal(l1.get_xydata(), l2.get_xydata())\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_unaligned_index", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "cat", "boxplot", "x", "self", "g", "y", "self", "y", "ax", "ax1", "cat", "boxplot", "x", "self", "g", "y", "self", "y_perm", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "np", "array_equal", "l1", "get_xydata", "l2", "get_xydata", "f", "ax1", "ax2", "plt", "subplots", "2", "hue_order", "self", "h", "unique", "cat", "boxplot", "x", "self", "g", "y", "self", "y", "hue", "self", "h", "hue_order", "hue_order", "ax", "ax1", "cat", "boxplot", "x", "self", "g", "y", "self", "y_perm", "hue", "self", "h", "hue_order", "hue_order", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "np", "array_equal", "l1", "get_xydata", "l2", "get_xydata"], "doc_len": 105}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_boxplots", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_boxplots", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_boxplots(self):\n\n        # Smoke test the high level boxplot options\n\n        cat.boxplot(x=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"g\", y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"y\", y=\"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", order=list(\"nabc\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", hue_order=list(\"omn\"), data=self.df)\n        plt.close(\"all\")\n\n        cat.boxplot(x=\"y\", y=\"g\", hue=\"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_boxplots", "self", "smoke", "test", "the", "high", "level", "boxplot", "options", "cat", "boxplot", "x", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "x", "g", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "x", "y", "y", "g", "data", "self", "df", "orient", "h", "plt", "close", "all", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "order", "list", "nabc", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "hue_order", "list", "omn", "data", "self", "df", "plt", "close", "all", "cat", "boxplot", "x", "y", "y", "g", "hue", "h", "data", "self", "df", "orient", "h", "plt", "close", "all"], "doc_len": 124}
{"doc_id": "tests/test_categorical.py::TestBoxPlotter.test_axes_annotation", "file_path": "tests/test_categorical.py", "class_name": "TestBoxPlotter", "func_name": "test_axes_annotation", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxPlotter\n    def test_axes_annotation(self):\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", data=self.df)\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        assert ax.get_xlim() == (-.5, 2.5)\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxplot(x=\"y\", y=\"g\", data=self.df, orient=\"h\")\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        assert ax.get_ylim() == (2.5, -.5)\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxplotter", "def", "test_axes_annotation", "self", "ax", "cat", "boxplot", "x", "g", "y", "y", "data", "self", "df", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "assert", "ax", "get_xlim", "5", "2", "5", "npt", "assert_array_equal", "ax", "get_xticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "a", "b", "c", "plt", "close", "all", "ax", "cat", "boxplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "npt", "assert_array_equal", "ax", "get_xticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "a", "b", "c", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "legend_", "get_texts", "m", "n", "plt", "close", "all", "ax", "cat", "boxplot", "x", "y", "y", "g", "data", "self", "df", "orient", "h", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "assert", "ax", "get_ylim", "2", "5", "5", "npt", "assert_array_equal", "ax", "get_yticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_yticklabels", "a", "b", "c", "plt", "close", "all"], "doc_len": 155}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_split_error", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_split_error", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_split_error(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"h\", y=\"y\", hue=\"g\", data=self.df, split=True))\n\n        with pytest.raises(ValueError):\n            cat._ViolinPlotter(**kws)\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_split_error", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "x", "h", "y", "y", "hue", "g", "data", "self", "df", "split", "true", "with", "pytest", "raises", "valueerror", "cat", "_violinplotter", "kws"], "doc_len": 32}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_no_observations", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_no_observations", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_no_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        assert len(p.support[0]) == 20\n        assert len(p.support[1]) == 0\n\n        assert len(p.density[0]) == 20\n        assert len(p.density[1]) == 1\n\n        assert p.density[1].item() == 1\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        assert p.density[1].item() == 0\n\n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n\n        p.establish_variables(x, y, hue=h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        assert len(p.support[1][0]) == 20\n        assert len(p.support[1][1]) == 0\n\n        assert len(p.density[1][0]) == 20\n        assert len(p.density[1][1]) == 1\n\n        assert p.density[1][1].item() == 1\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        assert p.density[1][1].item() == 0\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_no_observations", "self", "p", "cat", "_violinplotter", "self", "default_kws", "x", "a", "a", "b", "y", "self", "rs", "randn", "3", "y", "1", "np", "nan", "p", "establish_variables", "x", "y", "p", "estimate_densities", "scott", "2", "area", "true", "20", "assert", "len", "p", "support", "0", "20", "assert", "len", "p", "support", "1", "0", "assert", "len", "p", "density", "0", "20", "assert", "len", "p", "density", "1", "1", "assert", "p", "density", "1", "item", "1", "p", "estimate_densities", "scott", "2", "count", "true", "20", "assert", "p", "density", "1", "item", "0", "x", "a", "4", "b", "2", "y", "self", "rs", "randn", "6", "h", "m", "n", "2", "m", "2", "p", "establish_variables", "x", "y", "hue", "h", "p", "estimate_densities", "scott", "2", "area", "true", "20", "assert", "len", "p", "support", "1", "0", "20", "assert", "len", "p", "support", "1", "1", "0", "assert", "len", "p", "density", "1", "0", "20", "assert", "len", "p", "density", "1", "1", "1", "assert", "p", "density", "1", "1", "item", "1", "p", "estimate_densities", "scott", "2", "count", "false", "20", "assert", "p", "density", "1", "1", "item", "0"], "doc_len": 157}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_single_observation", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_single_observation", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_single_observation(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        p.establish_variables(x, y)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        assert len(p.support[0]) == 20\n        assert len(p.support[1]) == 1\n\n        assert len(p.density[0]) == 20\n        assert len(p.density[1]) == 1\n\n        assert p.density[1].item() == 1\n\n        p.estimate_densities(\"scott\", 2, \"count\", True, 20)\n        assert p.density[1].item() == .5\n\n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n\n        p.establish_variables(x, y, hue=h)\n        p.estimate_densities(\"scott\", 2, \"area\", True, 20)\n\n        assert len(p.support[1][0]) == 20\n        assert len(p.support[1][1]) == 1\n\n        assert len(p.density[1][0]) == 20\n        assert len(p.density[1][1]) == 1\n\n        assert p.density[1][1].item() == 1\n\n        p.estimate_densities(\"scott\", 2, \"count\", False, 20)\n        assert p.density[1][1].item() == .5\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_single_observation", "self", "p", "cat", "_violinplotter", "self", "default_kws", "x", "a", "a", "b", "y", "self", "rs", "randn", "3", "p", "establish_variables", "x", "y", "p", "estimate_densities", "scott", "2", "area", "true", "20", "assert", "len", "p", "support", "0", "20", "assert", "len", "p", "support", "1", "1", "assert", "len", "p", "density", "0", "20", "assert", "len", "p", "density", "1", "1", "assert", "p", "density", "1", "item", "1", "p", "estimate_densities", "scott", "2", "count", "true", "20", "assert", "p", "density", "1", "item", "5", "x", "b", "4", "a", "3", "y", "self", "rs", "randn", "7", "h", "m", "n", "4", "1", "p", "establish_variables", "x", "y", "hue", "h", "p", "estimate_densities", "scott", "2", "area", "true", "20", "assert", "len", "p", "support", "1", "0", "20", "assert", "len", "p", "support", "1", "1", "1", "assert", "len", "p", "density", "1", "0", "20", "assert", "len", "p", "density", "1", "1", "1", "assert", "p", "density", "1", "1", "item", "1", "p", "estimate_densities", "scott", "2", "count", "false", "20", "assert", "p", "density", "1", "1", "item", "5"], "doc_len": 152}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_dwidth", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_dwidth", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_dwidth(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n\n        p = cat._ViolinPlotter(**kws)\n        assert p.dwidth == .4\n\n        kws.update(dict(width=.4))\n        p = cat._ViolinPlotter(**kws)\n        assert p.dwidth == .2\n\n        kws.update(dict(hue=\"h\", width=.8))\n        p = cat._ViolinPlotter(**kws)\n        assert p.dwidth == .2\n\n        kws.update(dict(split=True))\n        p = cat._ViolinPlotter(**kws)\n        assert p.dwidth == .4\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_dwidth", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "x", "g", "y", "y", "data", "self", "df", "p", "cat", "_violinplotter", "kws", "assert", "p", "dwidth", "4", "kws", "update", "dict", "width", "4", "p", "cat", "_violinplotter", "kws", "assert", "p", "dwidth", "2", "kws", "update", "dict", "hue", "h", "width", "8", "p", "cat", "_violinplotter", "kws", "assert", "p", "dwidth", "2", "kws", "update", "dict", "split", "true", "p", "cat", "_violinplotter", "kws", "assert", "p", "dwidth", "4"], "doc_len": 70}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_scale_area", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_scale_area", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_scale_area(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"area\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        max_before = np.array([d.max() for d in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([d.max() for d in density])\n        assert max_after[0] == 1\n\n        before_ratio = max_before[1] / max_before[0]\n        after_ratio = max_after[1] / max_after[0]\n        assert before_ratio == after_ratio\n\n        # Test nested grouping scaling across all densities\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        assert max_after[0, 0] == 1\n\n        before_ratio = max_before[1, 1] / max_before[0, 0]\n        after_ratio = max_after[1, 1] / max_after[0, 0]\n        assert before_ratio == after_ratio\n\n        # Test nested grouping scaling within hue\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        max_before = np.array([[r.max() for r in row] for row in density])\n        p.scale_area(density, max_before, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        assert max_after[0, 0] == 1\n        assert max_after[1, 0] == 1\n\n        before_ratio = max_before[1, 1] / max_before[1, 0]\n        after_ratio = max_after[1, 1] / max_after[1, 0]\n        assert before_ratio == after_ratio\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_scale_area", "self", "kws", "self", "default_kws", "copy", "kws", "scale", "area", "p", "cat", "_violinplotter", "kws", "test", "single", "layer", "of", "grouping", "p", "hue_names", "none", "density", "self", "rs", "uniform", "0", "8", "50", "self", "rs", "uniform", "0", "2", "50", "max_before", "np", "array", "d", "max", "for", "d", "in", "density", "p", "scale_area", "density", "max_before", "false", "max_after", "np", "array", "d", "max", "for", "d", "in", "density", "assert", "max_after", "0", "1", "before_ratio", "max_before", "1", "max_before", "0", "after_ratio", "max_after", "1", "max_after", "0", "assert", "before_ratio", "after_ratio", "test", "nested", "grouping", "scaling", "across", "all", "densities", "p", "hue_names", "foo", "bar", "density", "self", "rs", "uniform", "0", "8", "50", "self", "rs", "uniform", "0", "2", "50", "self", "rs", "uniform", "0", "1", "50", "self", "rs", "uniform", "0", "02", "50", "max_before", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "p", "scale_area", "density", "max_before", "false", "max_after", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "assert", "max_after", "0", "0", "1", "before_ratio", "max_before", "1", "1", "max_before", "0", "0", "after_ratio", "max_after", "1", "1", "max_after", "0", "0", "assert", "before_ratio", "after_ratio", "test", "nested", "grouping", "scaling", "within", "hue", "p", "hue_names", "foo", "bar", "density", "self", "rs", "uniform", "0", "8", "50", "self", "rs", "uniform", "0", "2", "50", "self", "rs", "uniform", "0", "1", "50", "self", "rs", "uniform", "0", "02", "50", "max_before", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "p", "scale_area", "density", "max_before", "true", "max_after", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "assert", "max_after", "0", "0", "1", "assert", "max_after", "1", "0", "1", "before_ratio", "max_before", "1", "1", "max_before", "1", "0", "after_ratio", "max_after", "1", "1", "max_after", "1", "0", "assert", "before_ratio", "after_ratio"], "doc_len": 261}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_scale_width", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_scale_width", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_scale_width(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"width\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)]\n        p.scale_width(density)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [1, 1])\n\n        # Test nested grouping\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 50), self.rs.uniform(0, .2, 50)],\n                   [self.rs.uniform(0, .1, 50), self.rs.uniform(0, .02, 50)]]\n\n        p.scale_width(density)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[1, 1], [1, 1]])\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_scale_width", "self", "kws", "self", "default_kws", "copy", "kws", "scale", "width", "p", "cat", "_violinplotter", "kws", "test", "single", "layer", "of", "grouping", "p", "hue_names", "none", "density", "self", "rs", "uniform", "0", "8", "50", "self", "rs", "uniform", "0", "2", "50", "p", "scale_width", "density", "max_after", "np", "array", "d", "max", "for", "d", "in", "density", "npt", "assert_array_equal", "max_after", "1", "1", "test", "nested", "grouping", "p", "hue_names", "foo", "bar", "density", "self", "rs", "uniform", "0", "8", "50", "self", "rs", "uniform", "0", "2", "50", "self", "rs", "uniform", "0", "1", "50", "self", "rs", "uniform", "0", "02", "50", "p", "scale_width", "density", "max_after", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "npt", "assert_array_equal", "max_after", "1", "1", "1", "1"], "doc_len": 111}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_scale_count", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_scale_count", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_scale_count(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"count\"\n        p = cat._ViolinPlotter(**kws)\n\n        # Test single layer of grouping\n        p.hue_names = None\n        density = [self.rs.uniform(0, .8, 20), self.rs.uniform(0, .2, 40)]\n        counts = np.array([20, 40])\n        p.scale_count(density, counts, False)\n        max_after = np.array([d.max() for d in density])\n        npt.assert_array_equal(max_after, [.5, 1])\n\n        # Test nested grouping scaling across all densities\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, False)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.05, .4], [1, .5]])\n\n        # Test nested grouping scaling within hue\n        p.hue_names = [\"foo\", \"bar\"]\n        density = [[self.rs.uniform(0, .8, 5), self.rs.uniform(0, .2, 40)],\n                   [self.rs.uniform(0, .1, 100), self.rs.uniform(0, .02, 50)]]\n\n        counts = np.array([[5, 40], [100, 50]])\n        p.scale_count(density, counts, True)\n        max_after = np.array([[r.max() for r in row] for row in density])\n        npt.assert_array_equal(max_after, [[.125, 1], [1, .5]])\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_scale_count", "self", "kws", "self", "default_kws", "copy", "kws", "scale", "count", "p", "cat", "_violinplotter", "kws", "test", "single", "layer", "of", "grouping", "p", "hue_names", "none", "density", "self", "rs", "uniform", "0", "8", "20", "self", "rs", "uniform", "0", "2", "40", "counts", "np", "array", "20", "40", "p", "scale_count", "density", "counts", "false", "max_after", "np", "array", "d", "max", "for", "d", "in", "density", "npt", "assert_array_equal", "max_after", "5", "1", "test", "nested", "grouping", "scaling", "across", "all", "densities", "p", "hue_names", "foo", "bar", "density", "self", "rs", "uniform", "0", "8", "5", "self", "rs", "uniform", "0", "2", "40", "self", "rs", "uniform", "0", "1", "100", "self", "rs", "uniform", "0", "02", "50", "counts", "np", "array", "5", "40", "100", "50", "p", "scale_count", "density", "counts", "false", "max_after", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "npt", "assert_array_equal", "max_after", "05", "4", "1", "5", "test", "nested", "grouping", "scaling", "within", "hue", "p", "hue_names", "foo", "bar", "density", "self", "rs", "uniform", "0", "8", "5", "self", "rs", "uniform", "0", "2", "40", "self", "rs", "uniform", "0", "1", "100", "self", "rs", "uniform", "0", "02", "50", "counts", "np", "array", "5", "40", "100", "50", "p", "scale_count", "density", "counts", "true", "max_after", "np", "array", "r", "max", "for", "r", "in", "row", "for", "row", "in", "density", "npt", "assert_array_equal", "max_after", "125", "1", "1", "5"], "doc_len": 198}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_bad_scale", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_bad_scale", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_bad_scale(self):\n\n        kws = self.default_kws.copy()\n        kws[\"scale\"] = \"not_a_scale_type\"\n        with pytest.raises(ValueError):\n            cat._ViolinPlotter(**kws)\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_bad_scale", "self", "kws", "self", "default_kws", "copy", "kws", "scale", "not_a_scale_type", "with", "pytest", "raises", "valueerror", "cat", "_violinplotter", "kws"], "doc_len": 21}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_kde_fit", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_kde_fit", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_kde_fit(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        data = self.y\n        data_std = data.std(ddof=1)\n\n        # Test reference rule bandwidth\n        kde, bw = p.fit_kde(data, \"scott\")\n        assert kde.factor == kde.scotts_factor()\n        assert bw == kde.scotts_factor() * data_std\n\n        # Test numeric scale factor\n        kde, bw = p.fit_kde(self.y, .2)\n        assert kde.factor == .2\n        assert bw == .2 * data_std\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_kde_fit", "self", "p", "cat", "_violinplotter", "self", "default_kws", "data", "self", "y", "data_std", "data", "std", "ddof", "1", "test", "reference", "rule", "bandwidth", "kde", "bw", "p", "fit_kde", "data", "scott", "assert", "kde", "factor", "kde", "scotts_factor", "assert", "bw", "kde", "scotts_factor", "data_std", "test", "numeric", "scale", "factor", "kde", "bw", "p", "fit_kde", "self", "y", "2", "assert", "kde", "factor", "2", "assert", "bw", "2", "data_std"], "doc_len": 59}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_to_density", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_to_density", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_to_density(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        # p.dwidth will be 1 for easier testing\n        p.width = 2\n\n        # Test vertical plots\n        support = np.array([.2, .6])\n        density = np.array([.1, .4])\n\n        # Test full vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Test left vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.99 * -.4, 0])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Test right vertical plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .5, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, .99 * .4])\n        npt.assert_array_equal(y, [.5, .5])\n        plt.close(\"all\")\n\n        # Switch orientation to test horizontal plots\n        p.orient = \"h\"\n        support = np.array([.2, .5])\n        density = np.array([.3, .7])\n\n        # Test full horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, False)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, .99 * .7])\n        plt.close(\"all\")\n\n        # Test left horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"left\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [.99 * -.7, 0])\n        plt.close(\"all\")\n\n        # Test right horizontal plot\n        _, ax = plt.subplots()\n        p.draw_to_density(ax, 0, .6, support, density, \"right\")\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [.6, .6])\n        npt.assert_array_equal(y, [0, .99 * .7])\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_to_density", "self", "p", "cat", "_violinplotter", "self", "default_kws", "p", "dwidth", "will", "be", "1", "for", "easier", "testing", "p", "width", "2", "test", "vertical", "plots", "support", "np", "array", "2", "6", "density", "np", "array", "1", "4", "test", "full", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "5", "support", "density", "false", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "99", "4", "99", "4", "npt", "assert_array_equal", "y", "5", "5", "plt", "close", "all", "test", "left", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "5", "support", "density", "left", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "99", "4", "0", "npt", "assert_array_equal", "y", "5", "5", "plt", "close", "all", "test", "right", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "5", "support", "density", "right", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "0", "99", "4", "npt", "assert_array_equal", "y", "5", "5", "plt", "close", "all", "switch", "orientation", "to", "test", "horizontal", "plots", "p", "orient", "h", "support", "np", "array", "2", "5", "density", "np", "array", "3", "7", "test", "full", "horizontal", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "6", "support", "density", "false", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "6", "6", "npt", "assert_array_equal", "y", "99", "7", "99", "7", "plt", "close", "all", "test", "left", "horizontal", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "6", "support", "density", "left", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "6", "6", "npt", "assert_array_equal", "y", "99", "7", "0", "plt", "close", "all", "test", "right", "horizontal", "plot", "_", "ax", "plt", "subplots", "p", "draw_to_density", "ax", "0", "6", "support", "density", "right", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "6", "6", "npt", "assert_array_equal", "y", "0", "99", "7", "plt", "close", "all"], "doc_len": 279}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_single_observations", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_single_observations", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_single_observations(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n        p.width = 2\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 1, 1.5, 1)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [0, 2])\n        npt.assert_array_equal(y, [1.5, 1.5])\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_single_observation(ax, 2, 2.2, .5)\n        x, y = ax.lines[0].get_xydata().T\n        npt.assert_array_equal(x, [2.2, 2.2])\n        npt.assert_array_equal(y, [1.5, 2.5])\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_single_observations", "self", "p", "cat", "_violinplotter", "self", "default_kws", "p", "width", "2", "test", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_single_observation", "ax", "1", "1", "5", "1", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "0", "2", "npt", "assert_array_equal", "y", "1", "5", "1", "5", "plt", "close", "all", "test", "horizontal", "plot", "p", "orient", "h", "_", "ax", "plt", "subplots", "p", "draw_single_observation", "ax", "2", "2", "2", "5", "x", "y", "ax", "lines", "0", "get_xydata", "t", "npt", "assert_array_equal", "x", "2", "2", "2", "2", "npt", "assert_array_equal", "y", "1", "5", "2", "5", "plt", "close", "all"], "doc_len": 92}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_box_lines", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_box_lines", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_box_lines(self):\n\n        # Test vertical plot\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, 0)\n        assert len(ax.lines) == 2\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        _, y = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(y, [q25, q75])\n\n        _, y = ax.collections[0].get_offsets().T\n        assert y == q50\n\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_box_lines(ax, self.y, 0)\n        assert len(ax.lines) == 2\n\n        q25, q50, q75 = np.percentile(self.y, [25, 50, 75])\n        x, _ = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(x, [q25, q75])\n\n        x, _ = ax.collections[0].get_offsets().T\n        assert x == q50\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_box_lines", "self", "test", "vertical", "plot", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "y", "y", "data", "self", "df", "inner", "none", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_box_lines", "ax", "self", "y", "0", "assert", "len", "ax", "lines", "2", "q25", "q50", "q75", "np", "percentile", "self", "y", "25", "50", "75", "_", "y", "ax", "lines", "1", "get_xydata", "t", "npt", "assert_array_equal", "y", "q25", "q75", "_", "y", "ax", "collections", "0", "get_offsets", "t", "assert", "y", "q50", "plt", "close", "all", "test", "horizontal", "plot", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "x", "y", "data", "self", "df", "inner", "none", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_box_lines", "ax", "self", "y", "0", "assert", "len", "ax", "lines", "2", "q25", "q50", "q75", "np", "percentile", "self", "y", "25", "50", "75", "x", "_", "ax", "lines", "1", "get_xydata", "t", "npt", "assert_array_equal", "x", "q25", "q75", "x", "_", "ax", "collections", "0", "get_offsets", "t", "assert", "x", "q50", "plt", "close", "all"], "doc_len": 149}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_quartiles", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_quartiles", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_quartiles(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_quartiles(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(np.percentile(self.y, [25, 50, 75]), ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_quartiles", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "y", "y", "data", "self", "df", "inner", "none", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_quartiles", "ax", "self", "y", "p", "support", "0", "p", "density", "0", "0", "for", "val", "line", "in", "zip", "np", "percentile", "self", "y", "25", "50", "75", "ax", "lines", "_", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "y", "val", "val"], "doc_len": 65}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_points", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_points", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_points(self):\n\n        p = cat._ViolinPlotter(**self.default_kws)\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, np.zeros_like(self.y))\n        npt.assert_array_equal(y, self.y)\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_points(ax, self.y, 0)\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, self.y)\n        npt.assert_array_equal(y, np.zeros_like(self.y))\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_points", "self", "p", "cat", "_violinplotter", "self", "default_kws", "test", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_points", "ax", "self", "y", "0", "x", "y", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x", "np", "zeros_like", "self", "y", "npt", "assert_array_equal", "y", "self", "y", "plt", "close", "all", "test", "horizontal", "plot", "p", "orient", "h", "_", "ax", "plt", "subplots", "p", "draw_points", "ax", "self", "y", "0", "x", "y", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x", "self", "y", "npt", "assert_array_equal", "y", "np", "zeros_like", "self", "y", "plt", "close", "all"], "doc_len": 85}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_sticks", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_sticks", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_sticks(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(y=\"y\", data=self.df, inner=None))\n        p = cat._ViolinPlotter(**kws)\n\n        # Test vertical plot\n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            _, y = line.get_xydata().T\n            npt.assert_array_equal(y, [val, val])\n        plt.close(\"all\")\n\n        # Test horizontal plot\n        p.orient = \"h\"\n        _, ax = plt.subplots()\n        p.draw_stick_lines(ax, self.y, p.support[0], p.density[0], 0)\n        for val, line in zip(self.y, ax.lines):\n            x, _ = line.get_xydata().T\n            npt.assert_array_equal(x, [val, val])\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_sticks", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "y", "y", "data", "self", "df", "inner", "none", "p", "cat", "_violinplotter", "kws", "test", "vertical", "plot", "_", "ax", "plt", "subplots", "p", "draw_stick_lines", "ax", "self", "y", "p", "support", "0", "p", "density", "0", "0", "for", "val", "line", "in", "zip", "self", "y", "ax", "lines", "_", "y", "line", "get_xydata", "t", "npt", "assert_array_equal", "y", "val", "val", "plt", "close", "all", "test", "horizontal", "plot", "p", "orient", "h", "_", "ax", "plt", "subplots", "p", "draw_stick_lines", "ax", "self", "y", "p", "support", "0", "p", "density", "0", "0", "for", "val", "line", "in", "zip", "self", "y", "ax", "lines", "x", "_", "line", "get_xydata", "t", "npt", "assert_array_equal", "x", "val", "val", "plt", "close", "all"], "doc_len": 110}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_validate_inner", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_validate_inner", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_validate_inner(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(inner=\"bad_inner\"))\n        with pytest.raises(ValueError):\n            cat._ViolinPlotter(**kws)\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_validate_inner", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "inner", "bad_inner", "with", "pytest", "raises", "valueerror", "cat", "_violinplotter", "kws"], "doc_len": 23}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_violinplots", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_violinplots", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_violinplots(self):\n\n        kws = self.default_kws.copy()\n\n        # Test single vertical violin\n        kws.update(dict(y=\"y\", data=self.df, inner=None,\n                        saturation=1, color=(1, 0, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 1\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(1, 0, 0, 1)])\n        plt.close(\"all\")\n\n        # Test single horizontal violin\n        kws.update(dict(x=\"y\", y=None, color=(0, 1, 0, 1)))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 1\n        npt.assert_array_equal(ax.collections[0].get_facecolors(),\n                               [(0, 1, 0, 1)])\n        plt.close(\"all\")\n\n        # Test multiple vertical violins\n        kws.update(dict(x=\"g\", y=\"y\", color=None,))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 3\n        for violin, color in zip(ax.collections, palettes.color_palette()):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        # Test multiple violins with hue nesting\n        kws.update(dict(hue=\"h\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 6\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n\n        # Test multiple split violins\n        kws.update(dict(split=True, palette=\"muted\"))\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 6\n        for violin, color in zip(ax.collections,\n                                 palettes.color_palette(\"muted\",\n                                                        n_colors=2) * 3):\n            npt.assert_array_equal(violin.get_facecolors()[0, :-1], color)\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_violinplots", "self", "kws", "self", "default_kws", "copy", "test", "single", "vertical", "violin", "kws", "update", "dict", "y", "y", "data", "self", "df", "inner", "none", "saturation", "1", "color", "1", "0", "0", "1", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "1", "npt", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "1", "0", "0", "1", "plt", "close", "all", "test", "single", "horizontal", "violin", "kws", "update", "dict", "x", "y", "y", "none", "color", "0", "1", "0", "1", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "1", "npt", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "0", "1", "0", "1", "plt", "close", "all", "test", "multiple", "vertical", "violins", "kws", "update", "dict", "x", "g", "y", "y", "color", "none", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "3", "for", "violin", "color", "in", "zip", "ax", "collections", "palettes", "color_palette", "npt", "assert_array_equal", "violin", "get_facecolors", "0", "1", "color", "plt", "close", "all", "test", "multiple", "violins", "with", "hue", "nesting", "kws", "update", "dict", "hue", "h", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "6", "for", "violin", "color", "in", "zip", "ax", "collections", "palettes", "color_palette", "n_colors", "2", "3", "npt", "assert_array_equal", "violin", "get_facecolors", "0", "1", "color", "plt", "close", "all", "test", "multiple", "split", "violins", "kws", "update", "dict", "split", "true", "palette", "muted", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "6", "for", "violin", "color", "in", "zip", "ax", "collections", "palettes", "color_palette", "muted", "n_colors", "2", "3", "npt", "assert_array_equal", "violin", "get_facecolors", "0", "1", "color", "plt", "close", "all"], "doc_len": 253}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_violinplots_no_observations", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_violinplots_no_observations", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_violinplots_no_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        # Test single layer of grouping\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        y[-1] = np.nan\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == 0\n        plt.close(\"all\")\n\n        # Test nested hue grouping\n        x = [\"a\"] * 4 + [\"b\"] * 2\n        y = self.rs.randn(6)\n        h = [\"m\", \"n\"] * 2 + [\"m\"] * 2\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 3\n        assert len(ax.lines) == 0\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_violinplots_no_observations", "self", "kws", "self", "default_kws", "copy", "kws", "inner", "none", "test", "single", "layer", "of", "grouping", "x", "a", "a", "b", "y", "self", "rs", "randn", "3", "y", "1", "np", "nan", "kws", "update", "x", "x", "y", "y", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "0", "plt", "close", "all", "test", "nested", "hue", "grouping", "x", "a", "4", "b", "2", "y", "self", "rs", "randn", "6", "h", "m", "n", "2", "m", "2", "kws", "update", "x", "x", "y", "y", "hue", "h", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "3", "assert", "len", "ax", "lines", "0", "plt", "close", "all"], "doc_len": 114}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_draw_violinplots_single_observations", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_draw_violinplots_single_observations", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_draw_violinplots_single_observations(self):\n\n        kws = self.default_kws.copy()\n        kws[\"inner\"] = None\n\n        # Test single layer of grouping\n        x = [\"a\", \"a\", \"b\"]\n        y = self.rs.randn(3)\n        kws.update(x=x, y=y)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == 1\n        plt.close(\"all\")\n\n        # Test nested hue grouping\n        x = [\"b\"] * 4 + [\"a\"] * 3\n        y = self.rs.randn(7)\n        h = ([\"m\", \"n\"] * 4)[:-1]\n        kws.update(x=x, y=y, hue=h)\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 3\n        assert len(ax.lines) == 1\n        plt.close(\"all\")\n\n        # Test nested hue grouping with split\n        kws[\"split\"] = True\n        p = cat._ViolinPlotter(**kws)\n\n        _, ax = plt.subplots()\n        p.draw_violins(ax)\n        assert len(ax.collections) == 3\n        assert len(ax.lines) == 1\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_draw_violinplots_single_observations", "self", "kws", "self", "default_kws", "copy", "kws", "inner", "none", "test", "single", "layer", "of", "grouping", "x", "a", "a", "b", "y", "self", "rs", "randn", "3", "kws", "update", "x", "x", "y", "y", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "1", "plt", "close", "all", "test", "nested", "hue", "grouping", "x", "b", "4", "a", "3", "y", "self", "rs", "randn", "7", "h", "m", "n", "4", "1", "kws", "update", "x", "x", "y", "y", "hue", "h", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "3", "assert", "len", "ax", "lines", "1", "plt", "close", "all", "test", "nested", "hue", "grouping", "with", "split", "kws", "split", "true", "p", "cat", "_violinplotter", "kws", "_", "ax", "plt", "subplots", "p", "draw_violins", "ax", "assert", "len", "ax", "collections", "3", "assert", "len", "ax", "lines", "1", "plt", "close", "all"], "doc_len": 142}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_violinplots", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_violinplots", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_violinplots(self):\n\n        # Smoke test the high level violinplot options\n\n        cat.violinplot(x=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(x=\"g\", y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(x=\"y\", y=\"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.violinplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        plt.close(\"all\")\n\n        order = list(\"nabc\")\n        cat.violinplot(x=\"g\", y=\"y\", hue=\"h\", order=order, data=self.df)\n        plt.close(\"all\")\n\n        order = list(\"omn\")\n        cat.violinplot(x=\"g\", y=\"y\", hue=\"h\", hue_order=order, data=self.df)\n        plt.close(\"all\")\n\n        cat.violinplot(x=\"y\", y=\"g\", hue=\"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        for inner in [\"box\", \"quart\", \"point\", \"stick\", None]:\n            cat.violinplot(x=\"g\", y=\"y\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, inner=inner)\n            plt.close(\"all\")\n\n            cat.violinplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df,\n                           inner=inner, split=True)\n            plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_violinplots", "self", "smoke", "test", "the", "high", "level", "violinplot", "options", "cat", "violinplot", "x", "y", "data", "self", "df", "plt", "close", "all", "cat", "violinplot", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "violinplot", "x", "g", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "violinplot", "x", "y", "y", "g", "data", "self", "df", "orient", "h", "plt", "close", "all", "cat", "violinplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "plt", "close", "all", "order", "list", "nabc", "cat", "violinplot", "x", "g", "y", "y", "hue", "h", "order", "order", "data", "self", "df", "plt", "close", "all", "order", "list", "omn", "cat", "violinplot", "x", "g", "y", "y", "hue", "h", "hue_order", "order", "data", "self", "df", "plt", "close", "all", "cat", "violinplot", "x", "y", "y", "g", "hue", "h", "data", "self", "df", "orient", "h", "plt", "close", "all", "for", "inner", "in", "box", "quart", "point", "stick", "none", "cat", "violinplot", "x", "g", "y", "y", "data", "self", "df", "inner", "inner", "plt", "close", "all", "cat", "violinplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "inner", "inner", "plt", "close", "all", "cat", "violinplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "inner", "inner", "split", "true", "plt", "close", "all"], "doc_len": 184}
{"doc_id": "tests/test_categorical.py::TestViolinPlotter.test_split_one_each", "file_path": "tests/test_categorical.py", "class_name": "TestViolinPlotter", "func_name": "test_split_one_each", "text": "文件路径: tests/test_categorical.py, 类名: TestViolinPlotter\n    def test_split_one_each(self, rng):\n\n        x = np.repeat([0, 1], 5)\n        y = rng.normal(0, 1, 10)\n        ax = cat.violinplot(x=x, y=y, hue=x, split=True, inner=\"box\")\n        assert len(ax.lines) == 4\n", "tokens": ["tests", "test_categorical", "py", "testviolinplotter", "def", "test_split_one_each", "self", "rng", "x", "np", "repeat", "0", "1", "5", "y", "rng", "normal", "0", "1", "10", "ax", "cat", "violinplot", "x", "x", "y", "y", "hue", "x", "split", "true", "inner", "box", "assert", "len", "ax", "lines", "4"], "doc_len": 38}
{"doc_id": "tests/test_categorical.py::SharedAxesLevelTests.test_color", "file_path": "tests/test_categorical.py", "class_name": "SharedAxesLevelTests", "func_name": "test_color", "text": "文件路径: tests/test_categorical.py, 类名: SharedAxesLevelTests\n    def test_color(self, long_df):\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C0\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        self.func(data=long_df, x=\"a\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C1\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C2\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C2\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", color=\"C3\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C3\")\n", "tokens": ["tests", "test_categorical", "py", "sharedaxesleveltests", "def", "test_color", "self", "long_df", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c0", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "ax", "ax", "self", "func", "data", "long_df", "x", "a", "y", "y", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c1", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "color", "c2", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c2", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "color", "c3", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c3"], "doc_len": 102}
{"doc_id": "tests/test_categorical.py::SharedAxesLevelTests.test_two_calls", "file_path": "tests/test_categorical.py", "class_name": "SharedAxesLevelTests", "func_name": "test_two_calls", "text": "文件路径: tests/test_categorical.py, 类名: SharedAxesLevelTests\n    def test_two_calls(self):\n\n        ax = plt.figure().subplots()\n        self.func(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3], ax=ax)\n        self.func(x=[\"e\", \"f\"], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-.5, 4.5)\n", "tokens": ["tests", "test_categorical", "py", "sharedaxesleveltests", "def", "test_two_calls", "self", "ax", "plt", "figure", "subplots", "self", "func", "x", "a", "b", "c", "y", "1", "2", "3", "ax", "ax", "self", "func", "x", "e", "f", "y", "4", "5", "ax", "ax", "assert", "ax", "get_xlim", "5", "4", "5"], "doc_len": 39}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.get_last_color", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "get_last_color", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def get_last_color(self, ax):\n\n        colors = ax.collections[-1].get_facecolors()\n        unique_colors = np.unique(colors, axis=0)\n        assert len(unique_colors) == 1\n        return to_rgba(unique_colors.squeeze())\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "get_last_color", "self", "ax", "colors", "ax", "collections", "1", "get_facecolors", "unique_colors", "np", "unique", "colors", "axis", "0", "assert", "len", "unique_colors", "1", "return", "to_rgba", "unique_colors", "squeeze"], "doc_len": 27}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_color", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_color", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_color(self, long_df):\n\n        super().test_color(long_df)\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"a\", y=\"y\", facecolor=\"C4\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C4\")\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n\n            ax = plt.figure().subplots()\n            self.func(data=long_df, x=\"a\", y=\"y\", fc=\"C5\", ax=ax)\n            assert self.get_last_color(ax) == to_rgba(\"C5\")\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_color", "self", "long_df", "super", "test_color", "long_df", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "facecolor", "c4", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c4", "if", "version", "mpl", "__version__", "version", "3", "1", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "12851", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "a", "y", "y", "fc", "c5", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c5"], "doc_len": 70}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_supplied_color_array", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_supplied_color_array", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_supplied_color_array(self, long_df):\n\n        cmap = get_colormap(\"Blues\")\n        norm = mpl.colors.Normalize()\n        colors = cmap(norm(long_df[\"y\"].to_numpy()))\n\n        keys = [\"c\", \"facecolor\", \"facecolors\"]\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n            keys.append(\"fc\")\n\n        for key in keys:\n\n            ax = plt.figure().subplots()\n            self.func(x=long_df[\"y\"], **{key: colors})\n            _draw_figure(ax.figure)\n            assert_array_equal(ax.collections[0].get_facecolors(), colors)\n\n        ax = plt.figure().subplots()\n        self.func(x=long_df[\"y\"], c=long_df[\"y\"], cmap=cmap)\n        _draw_figure(ax.figure)\n        assert_array_equal(ax.collections[0].get_facecolors(), colors)\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_supplied_color_array", "self", "long_df", "cmap", "get_colormap", "blues", "norm", "mpl", "colors", "normalize", "colors", "cmap", "norm", "long_df", "y", "to_numpy", "keys", "c", "facecolor", "facecolors", "if", "version", "mpl", "__version__", "version", "3", "1", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "12851", "keys", "append", "fc", "for", "key", "in", "keys", "ax", "plt", "figure", "subplots", "self", "func", "x", "long_df", "y", "key", "colors", "_draw_figure", "ax", "figure", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "colors", "ax", "plt", "figure", "subplots", "self", "func", "x", "long_df", "y", "c", "long_df", "y", "cmap", "cmap", "_draw_figure", "ax", "figure", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "colors"], "doc_len": 90}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_wide", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_wide", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_wide(self, wide_df, orient, data_type):\n\n        if data_type == \"dict\":\n            wide_df = {k: v.to_numpy() for k, v in wide_df.items()}\n\n        ax = self.func(data=wide_df, orient=orient)\n        _draw_figure(ax.figure)\n        palette = color_palette()\n\n        cat_idx = 0 if orient == \"v\" else 1\n        val_idx = int(not cat_idx)\n\n        axis_objs = ax.xaxis, ax.yaxis\n        cat_axis = axis_objs[cat_idx]\n\n        for i, label in enumerate(cat_axis.get_majorticklabels()):\n\n            key = label.get_text()\n            points = ax.collections[i]\n            point_pos = points.get_offsets().T\n            val_pos = point_pos[val_idx]\n            cat_pos = point_pos[cat_idx]\n\n            assert_array_equal(cat_pos.round(), i)\n            assert_array_equal(val_pos, wide_df[key])\n\n            for point_color in points.get_facecolors():\n                assert tuple(point_color) == to_rgba(palette[i])\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_wide", "self", "wide_df", "orient", "data_type", "if", "data_type", "dict", "wide_df", "k", "v", "to_numpy", "for", "k", "v", "in", "wide_df", "items", "ax", "self", "func", "data", "wide_df", "orient", "orient", "_draw_figure", "ax", "figure", "palette", "color_palette", "cat_idx", "0", "if", "orient", "v", "else", "1", "val_idx", "int", "not", "cat_idx", "axis_objs", "ax", "xaxis", "ax", "yaxis", "cat_axis", "axis_objs", "cat_idx", "for", "i", "label", "in", "enumerate", "cat_axis", "get_majorticklabels", "key", "label", "get_text", "points", "ax", "collections", "i", "point_pos", "points", "get_offsets", "t", "val_pos", "point_pos", "val_idx", "cat_pos", "point_pos", "cat_idx", "assert_array_equal", "cat_pos", "round", "i", "assert_array_equal", "val_pos", "wide_df", "key", "for", "point_color", "in", "points", "get_facecolors", "assert", "tuple", "point_color", "to_rgba", "palette", "i"], "doc_len": 97}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_flat", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_flat", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_flat(self, flat_series, orient):\n\n        ax = self.func(data=flat_series, orient=orient)\n        _draw_figure(ax.figure)\n\n        cat_idx = [\"v\", \"h\"].index(orient)\n        val_idx = int(not cat_idx)\n\n        points = ax.collections[0]\n        pos = points.get_offsets().T\n\n        assert_array_equal(pos[cat_idx].round(), np.zeros(len(flat_series)))\n        assert_array_equal(pos[val_idx], flat_series)\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_flat", "self", "flat_series", "orient", "ax", "self", "func", "data", "flat_series", "orient", "orient", "_draw_figure", "ax", "figure", "cat_idx", "v", "h", "index", "orient", "val_idx", "int", "not", "cat_idx", "points", "ax", "collections", "0", "pos", "points", "get_offsets", "t", "assert_array_equal", "pos", "cat_idx", "round", "np", "zeros", "len", "flat_series", "assert_array_equal", "pos", "val_idx", "flat_series"], "doc_len": 48}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_positions", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_positions", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_positions(self, long_df, variables, orient):\n\n        cat_var = variables[\"cat\"]\n        val_var = variables[\"val\"]\n        hue_var = variables[\"hue\"]\n        var_names = list(variables.values())\n        x_var, y_var, *_ = var_names\n\n        ax = self.func(\n            data=long_df, x=x_var, y=y_var, hue=hue_var, orient=orient,\n        )\n\n        _draw_figure(ax.figure)\n\n        cat_idx = var_names.index(cat_var)\n        val_idx = var_names.index(val_var)\n\n        axis_objs = ax.xaxis, ax.yaxis\n        cat_axis = axis_objs[cat_idx]\n        val_axis = axis_objs[val_idx]\n\n        cat_data = long_df[cat_var]\n        cat_levels = categorical_order(cat_data)\n\n        for i, label in enumerate(cat_levels):\n\n            vals = long_df.loc[cat_data == label, val_var]\n\n            points = ax.collections[i].get_offsets().T\n            cat_pos = points[var_names.index(cat_var)]\n            val_pos = points[var_names.index(val_var)]\n\n            assert_array_equal(val_pos, val_axis.convert_units(vals))\n            assert_array_equal(cat_pos.round(), i)\n            assert 0 <= np.ptp(cat_pos) <= .8\n\n            label = pd.Index([label]).astype(str)[0]\n            assert cat_axis.get_majorticklabels()[i].get_text() == label\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_positions", "self", "long_df", "variables", "orient", "cat_var", "variables", "cat", "val_var", "variables", "val", "hue_var", "variables", "hue", "var_names", "list", "variables", "values", "x_var", "y_var", "_", "var_names", "ax", "self", "func", "data", "long_df", "x", "x_var", "y", "y_var", "hue", "hue_var", "orient", "orient", "_draw_figure", "ax", "figure", "cat_idx", "var_names", "index", "cat_var", "val_idx", "var_names", "index", "val_var", "axis_objs", "ax", "xaxis", "ax", "yaxis", "cat_axis", "axis_objs", "cat_idx", "val_axis", "axis_objs", "val_idx", "cat_data", "long_df", "cat_var", "cat_levels", "categorical_order", "cat_data", "for", "i", "label", "in", "enumerate", "cat_levels", "vals", "long_df", "loc", "cat_data", "label", "val_var", "points", "ax", "collections", "i", "get_offsets", "t", "cat_pos", "points", "var_names", "index", "cat_var", "val_pos", "points", "var_names", "index", "val_var", "assert_array_equal", "val_pos", "val_axis", "convert_units", "vals", "assert_array_equal", "cat_pos", "round", "i", "assert", "0", "np", "ptp", "cat_pos", "8", "label", "pd", "index", "label", "astype", "str", "0", "assert", "cat_axis", "get_majorticklabels", "i", "get_text", "label"], "doc_len": 124}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_positions_dodged", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_positions_dodged", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_positions_dodged(self, long_df, variables):\n\n        cat_var = variables[\"cat\"]\n        val_var = variables[\"val\"]\n        hue_var = variables[\"hue\"]\n        var_names = list(variables.values())\n        x_var, y_var, *_ = var_names\n\n        ax = self.func(\n            data=long_df, x=x_var, y=y_var, hue=hue_var, dodge=True,\n        )\n\n        cat_vals = categorical_order(long_df[cat_var])\n        hue_vals = categorical_order(long_df[hue_var])\n\n        n_hue = len(hue_vals)\n        offsets = np.linspace(0, .8, n_hue + 1)[:-1]\n        offsets -= offsets.mean()\n        nest_width = .8 / n_hue\n\n        for i, cat_val in enumerate(cat_vals):\n            for j, hue_val in enumerate(hue_vals):\n                rows = (long_df[cat_var] == cat_val) & (long_df[hue_var] == hue_val)\n                vals = long_df.loc[rows, val_var]\n\n                points = ax.collections[n_hue * i + j].get_offsets().T\n                cat_pos = points[var_names.index(cat_var)]\n                val_pos = points[var_names.index(val_var)]\n\n                if pd.api.types.is_datetime64_any_dtype(vals):\n                    vals = mpl.dates.date2num(vals)\n\n                assert_array_equal(val_pos, vals)\n\n                assert_array_equal(cat_pos.round(), i)\n                assert_array_equal((cat_pos - (i + offsets[j])).round() / nest_width, 0)\n                assert 0 <= np.ptp(cat_pos) <= nest_width\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_positions_dodged", "self", "long_df", "variables", "cat_var", "variables", "cat", "val_var", "variables", "val", "hue_var", "variables", "hue", "var_names", "list", "variables", "values", "x_var", "y_var", "_", "var_names", "ax", "self", "func", "data", "long_df", "x", "x_var", "y", "y_var", "hue", "hue_var", "dodge", "true", "cat_vals", "categorical_order", "long_df", "cat_var", "hue_vals", "categorical_order", "long_df", "hue_var", "n_hue", "len", "hue_vals", "offsets", "np", "linspace", "0", "8", "n_hue", "1", "1", "offsets", "offsets", "mean", "nest_width", "8", "n_hue", "for", "i", "cat_val", "in", "enumerate", "cat_vals", "for", "j", "hue_val", "in", "enumerate", "hue_vals", "rows", "long_df", "cat_var", "cat_val", "long_df", "hue_var", "hue_val", "vals", "long_df", "loc", "rows", "val_var", "points", "ax", "collections", "n_hue", "i", "j", "get_offsets", "t", "cat_pos", "points", "var_names", "index", "cat_var", "val_pos", "points", "var_names", "index", "val_var", "if", "pd", "api", "types", "is_datetime64_any_dtype", "vals", "vals", "mpl", "dates", "date2num", "vals", "assert_array_equal", "val_pos", "vals", "assert_array_equal", "cat_pos", "round", "i", "assert_array_equal", "cat_pos", "i", "offsets", "j", "round", "nest_width", "0", "assert", "0", "np", "ptp", "cat_pos", "nest_width"], "doc_len": 138}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_positions_unfixed", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_positions_unfixed", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_positions_unfixed(self, long_df, cat_var):\n\n        long_df = long_df.sort_values(cat_var)\n\n        kws = dict(size=.001)\n        if \"stripplot\" in str(self.func):  # can't use __name__ with partial\n            kws[\"jitter\"] = False\n\n        ax = self.func(data=long_df, x=cat_var, y=\"y\", native_scale=True, **kws)\n\n        for i, (cat_level, cat_data) in enumerate(long_df.groupby(cat_var)):\n\n            points = ax.collections[i].get_offsets().T\n            cat_pos = points[0]\n            val_pos = points[1]\n\n            assert_array_equal(val_pos, cat_data[\"y\"])\n\n            comp_level = np.squeeze(ax.xaxis.convert_units(cat_level)).item()\n            assert_array_equal(cat_pos.round(), comp_level)\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_positions_unfixed", "self", "long_df", "cat_var", "long_df", "long_df", "sort_values", "cat_var", "kws", "dict", "size", "001", "if", "stripplot", "in", "str", "self", "func", "can", "t", "use", "__name__", "with", "partial", "kws", "jitter", "false", "ax", "self", "func", "data", "long_df", "x", "cat_var", "y", "y", "native_scale", "true", "kws", "for", "i", "cat_level", "cat_data", "in", "enumerate", "long_df", "groupby", "cat_var", "points", "ax", "collections", "i", "get_offsets", "t", "cat_pos", "points", "0", "val_pos", "points", "1", "assert_array_equal", "val_pos", "cat_data", "y", "comp_level", "np", "squeeze", "ax", "xaxis", "convert_units", "cat_level", "item", "assert_array_equal", "cat_pos", "round", "comp_level"], "doc_len": 81}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_order", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_order", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_order(self, x_type, order):\n\n        if x_type is str:\n            x = [\"b\", \"a\", \"c\"]\n        else:\n            x = [2, 1, 3]\n        y = [1, 2, 3]\n\n        ax = self.func(x=x, y=y, order=order)\n        _draw_figure(ax.figure)\n\n        if order is None:\n            order = x\n            if x_type is int:\n                order = np.sort(order)\n\n        assert len(ax.collections) == len(order)\n        tick_labels = ax.xaxis.get_majorticklabels()\n\n        assert ax.get_xlim()[1] == (len(order) - .5)\n\n        for i, points in enumerate(ax.collections):\n            cat = order[i]\n            assert tick_labels[i].get_text() == str(cat)\n\n            positions = points.get_offsets()\n            if x_type(cat) in x:\n                val = y[x.index(x_type(cat))]\n                assert positions[0, 1] == val\n            else:\n                assert not positions.size\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_order", "self", "x_type", "order", "if", "x_type", "is", "str", "x", "b", "a", "c", "else", "x", "2", "1", "3", "y", "1", "2", "3", "ax", "self", "func", "x", "x", "y", "y", "order", "order", "_draw_figure", "ax", "figure", "if", "order", "is", "none", "order", "x", "if", "x_type", "is", "int", "order", "np", "sort", "order", "assert", "len", "ax", "collections", "len", "order", "tick_labels", "ax", "xaxis", "get_majorticklabels", "assert", "ax", "get_xlim", "1", "len", "order", "5", "for", "i", "points", "in", "enumerate", "ax", "collections", "cat", "order", "i", "assert", "tick_labels", "i", "get_text", "str", "cat", "positions", "points", "get_offsets", "if", "x_type", "cat", "in", "x", "val", "y", "x", "index", "x_type", "cat", "assert", "positions", "0", "1", "val", "else", "assert", "not", "positions", "size"], "doc_len": 109}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_hue_categorical", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_hue_categorical", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_hue_categorical(self, long_df, hue_var):\n\n        cat_var = \"b\"\n\n        hue_levels = categorical_order(long_df[hue_var])\n        cat_levels = categorical_order(long_df[cat_var])\n\n        pal_name = \"muted\"\n        palette = dict(zip(hue_levels, color_palette(pal_name)))\n        ax = self.func(data=long_df, x=cat_var, y=\"y\", hue=hue_var, palette=pal_name)\n\n        for i, level in enumerate(cat_levels):\n\n            sub_df = long_df[long_df[cat_var] == level]\n            point_hues = sub_df[hue_var]\n\n            points = ax.collections[i]\n            point_colors = points.get_facecolors()\n\n            assert len(point_hues) == len(point_colors)\n\n            for hue, color in zip(point_hues, point_colors):\n                assert tuple(color) == to_rgba(palette[hue])\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_hue_categorical", "self", "long_df", "hue_var", "cat_var", "b", "hue_levels", "categorical_order", "long_df", "hue_var", "cat_levels", "categorical_order", "long_df", "cat_var", "pal_name", "muted", "palette", "dict", "zip", "hue_levels", "color_palette", "pal_name", "ax", "self", "func", "data", "long_df", "x", "cat_var", "y", "y", "hue", "hue_var", "palette", "pal_name", "for", "i", "level", "in", "enumerate", "cat_levels", "sub_df", "long_df", "long_df", "cat_var", "level", "point_hues", "sub_df", "hue_var", "points", "ax", "collections", "i", "point_colors", "points", "get_facecolors", "assert", "len", "point_hues", "len", "point_colors", "for", "hue", "color", "in", "zip", "point_hues", "point_colors", "assert", "tuple", "color", "to_rgba", "palette", "hue"], "doc_len": 79}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_hue_dodged", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_hue_dodged", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_hue_dodged(self, long_df, hue_var):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=hue_var, dodge=True)\n        colors = color_palette(n_colors=long_df[hue_var].nunique())\n        collections = iter(ax.collections)\n\n        # Slightly awkward logic to handle challenges of how the artists work.\n        # e.g. there are empty scatter collections but the because facecolors\n        # for the empty collections will return the default scatter color\n        while colors:\n            points = next(collections)\n            if points.get_offsets().any():\n                face_color = tuple(points.get_facecolors()[0])\n                expected_color = to_rgba(colors.pop(0))\n                assert face_color == expected_color\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_hue_dodged", "self", "long_df", "hue_var", "ax", "self", "func", "data", "long_df", "x", "y", "y", "a", "hue", "hue_var", "dodge", "true", "colors", "color_palette", "n_colors", "long_df", "hue_var", "nunique", "collections", "iter", "ax", "collections", "slightly", "awkward", "logic", "to", "handle", "challenges", "of", "how", "the", "artists", "work", "e", "g", "there", "are", "empty", "scatter", "collections", "but", "the", "because", "facecolors", "for", "the", "empty", "collections", "will", "return", "the", "default", "scatter", "color", "while", "colors", "points", "next", "collections", "if", "points", "get_offsets", "any", "face_color", "tuple", "points", "get_facecolors", "0", "expected_color", "to_rgba", "colors", "pop", "0", "assert", "face_color", "expected_color"], "doc_len": 86}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_single", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_single", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_single(self, long_df, val_var, val_col, hue_col):\n\n        var_kws = {val_var: val_col, \"hue\": hue_col}\n        ax = self.func(data=long_df, **var_kws)\n        _draw_figure(ax.figure)\n\n        axis_vars = [\"x\", \"y\"]\n        val_idx = axis_vars.index(val_var)\n        cat_idx = int(not val_idx)\n        cat_var = axis_vars[cat_idx]\n\n        cat_axis = getattr(ax, f\"{cat_var}axis\")\n        val_axis = getattr(ax, f\"{val_var}axis\")\n\n        points = ax.collections[0]\n        point_pos = points.get_offsets().T\n        cat_pos = point_pos[cat_idx]\n        val_pos = point_pos[val_idx]\n\n        assert_array_equal(cat_pos.round(), 0)\n        assert cat_pos.max() <= .4\n        assert cat_pos.min() >= -.4\n\n        num_vals = val_axis.convert_units(long_df[val_col])\n        assert_array_equal(val_pos, num_vals)\n\n        if hue_col is not None:\n            palette = dict(zip(\n                categorical_order(long_df[hue_col]), color_palette()\n            ))\n\n        facecolors = points.get_facecolors()\n        for i, color in enumerate(facecolors):\n            if hue_col is None:\n                assert tuple(color) == to_rgba(\"C0\")\n            else:\n                hue_level = long_df.loc[i, hue_col]\n                expected_color = palette[hue_level]\n                assert tuple(color) == to_rgba(expected_color)\n\n        ticklabels = cat_axis.get_majorticklabels()\n        assert len(ticklabels) == 1\n        assert not ticklabels[0].get_text()\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_single", "self", "long_df", "val_var", "val_col", "hue_col", "var_kws", "val_var", "val_col", "hue", "hue_col", "ax", "self", "func", "data", "long_df", "var_kws", "_draw_figure", "ax", "figure", "axis_vars", "x", "y", "val_idx", "axis_vars", "index", "val_var", "cat_idx", "int", "not", "val_idx", "cat_var", "axis_vars", "cat_idx", "cat_axis", "getattr", "ax", "f", "cat_var", "axis", "val_axis", "getattr", "ax", "f", "val_var", "axis", "points", "ax", "collections", "0", "point_pos", "points", "get_offsets", "t", "cat_pos", "point_pos", "cat_idx", "val_pos", "point_pos", "val_idx", "assert_array_equal", "cat_pos", "round", "0", "assert", "cat_pos", "max", "4", "assert", "cat_pos", "min", "4", "num_vals", "val_axis", "convert_units", "long_df", "val_col", "assert_array_equal", "val_pos", "num_vals", "if", "hue_col", "is", "not", "none", "palette", "dict", "zip", "categorical_order", "long_df", "hue_col", "color_palette", "facecolors", "points", "get_facecolors", "for", "i", "color", "in", "enumerate", "facecolors", "if", "hue_col", "is", "none", "assert", "tuple", "color", "to_rgba", "c0", "else", "hue_level", "long_df", "loc", "i", "hue_col", "expected_color", "palette", "hue_level", "assert", "tuple", "color", "to_rgba", "expected_color", "ticklabels", "cat_axis", "get_majorticklabels", "assert", "len", "ticklabels", "1", "assert", "not", "ticklabels", "0", "get_text"], "doc_len": 141}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_attributes", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_attributes", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_attributes(self, long_df):\n\n        kwargs = dict(\n            size=2,\n            linewidth=1,\n            edgecolor=\"C2\",\n        )\n\n        ax = self.func(x=long_df[\"y\"], **kwargs)\n        points, = ax.collections\n\n        assert points.get_sizes().item() == kwargs[\"size\"] ** 2\n        assert points.get_linewidths().item() == kwargs[\"linewidth\"]\n        assert tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs[\"edgecolor\"])\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_attributes", "self", "long_df", "kwargs", "dict", "size", "2", "linewidth", "1", "edgecolor", "c2", "ax", "self", "func", "x", "long_df", "y", "kwargs", "points", "ax", "collections", "assert", "points", "get_sizes", "item", "kwargs", "size", "2", "assert", "points", "get_linewidths", "item", "kwargs", "linewidth", "assert", "tuple", "points", "get_edgecolors", "squeeze", "to_rgba", "kwargs", "edgecolor"], "doc_len": 47}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_three_points", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_three_points", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_three_points(self):\n\n        x = np.arange(3)\n        ax = self.func(x=x)\n        for point_color in ax.collections[0].get_facecolor():\n            assert tuple(point_color) == to_rgba(\"C0\")\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_three_points", "self", "x", "np", "arange", "3", "ax", "self", "func", "x", "x", "for", "point_color", "in", "ax", "collections", "0", "get_facecolor", "assert", "tuple", "point_color", "to_rgba", "c0"], "doc_len": 28}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_legend_categorical", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_legend_categorical", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_legend_categorical(self, long_df):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=\"b\")\n        legend_texts = [t.get_text() for t in ax.legend_.texts]\n        expected = categorical_order(long_df[\"b\"])\n        assert legend_texts == expected\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_legend_categorical", "self", "long_df", "ax", "self", "func", "data", "long_df", "x", "y", "y", "a", "hue", "b", "legend_texts", "t", "get_text", "for", "t", "in", "ax", "legend_", "texts", "expected", "categorical_order", "long_df", "b", "assert", "legend_texts", "expected"], "doc_len": 35}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_legend_numeric", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_legend_numeric", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_legend_numeric(self, long_df):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=\"z\")\n        vals = [float(t.get_text()) for t in ax.legend_.texts]\n        assert (vals[1] - vals[0]) == pytest.approx(vals[2] - vals[1])\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_legend_numeric", "self", "long_df", "ax", "self", "func", "data", "long_df", "x", "y", "y", "a", "hue", "z", "vals", "float", "t", "get_text", "for", "t", "in", "ax", "legend_", "texts", "assert", "vals", "1", "vals", "0", "pytest", "approx", "vals", "2", "vals", "1"], "doc_len": 40}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_legend_disabled", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_legend_disabled", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_legend_disabled(self, long_df):\n\n        ax = self.func(data=long_df, x=\"y\", y=\"a\", hue=\"b\", legend=False)\n        assert ax.legend_ is None\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_legend_disabled", "self", "long_df", "ax", "self", "func", "data", "long_df", "x", "y", "y", "a", "hue", "b", "legend", "false", "assert", "ax", "legend_", "is", "none"], "doc_len": 26}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_palette_from_color_deprecation", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_palette_from_color_deprecation", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_palette_from_color_deprecation(self, long_df):\n\n        color = (.9, .4, .5)\n        hex_color = mpl.colors.to_hex(color)\n\n        hue_var = \"a\"\n        n_hue = long_df[hue_var].nunique()\n        palette = color_palette(f\"dark:{hex_color}\", n_hue)\n\n        with pytest.warns(FutureWarning, match=\"Setting a gradient palette\"):\n            ax = self.func(data=long_df, x=\"z\", hue=hue_var, color=color)\n\n        points = ax.collections[0]\n        for point_color in points.get_facecolors():\n            assert to_rgb(point_color) in palette\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_palette_from_color_deprecation", "self", "long_df", "color", "9", "4", "5", "hex_color", "mpl", "colors", "to_hex", "color", "hue_var", "a", "n_hue", "long_df", "hue_var", "nunique", "palette", "color_palette", "f", "dark", "hex_color", "n_hue", "with", "pytest", "warns", "futurewarning", "match", "setting", "a", "gradient", "palette", "ax", "self", "func", "data", "long_df", "x", "z", "hue", "hue_var", "color", "color", "points", "ax", "collections", "0", "for", "point_color", "in", "points", "get_facecolors", "assert", "to_rgb", "point_color", "in", "palette"], "doc_len": 63}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_palette_with_hue_deprecation", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_palette_with_hue_deprecation", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_palette_with_hue_deprecation(self, long_df):\n        palette = \"Blues\"\n        with pytest.warns(FutureWarning, match=\"Passing `palette` without\"):\n            ax = self.func(data=long_df, x=\"a\", y=long_df[\"y\"], palette=palette)\n        strips = ax.collections\n        colors = color_palette(palette, len(strips))\n        for strip, color in zip(strips, colors):\n            assert same_color(strip.get_facecolor()[0], color)\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_palette_with_hue_deprecation", "self", "long_df", "palette", "blues", "with", "pytest", "warns", "futurewarning", "match", "passing", "palette", "without", "ax", "self", "func", "data", "long_df", "x", "a", "y", "long_df", "y", "palette", "palette", "strips", "ax", "collections", "colors", "color_palette", "palette", "len", "strips", "for", "strip", "color", "in", "zip", "strips", "colors", "assert", "same_color", "strip", "get_facecolor", "0", "color"], "doc_len": 51}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_log_scale", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_log_scale", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_log_scale(self):\n\n        x = [1, 10, 100, 1000]\n\n        ax = plt.figure().subplots()\n        ax.set_xscale(\"log\")\n        self.func(x=x)\n        vals = ax.collections[0].get_offsets()[:, 0]\n        assert_array_equal(x, vals)\n\n        y = [1, 2, 3, 4]\n\n        ax = plt.figure().subplots()\n        ax.set_xscale(\"log\")\n        self.func(x=x, y=y, native_scale=True)\n        for i, point in enumerate(ax.collections):\n            val = point.get_offsets()[0, 0]\n            assert val == pytest.approx(x[i])\n\n        x = y = np.ones(100)\n\n        # Following test fails on pinned (but not latest) matplotlib.\n        # (Even though visual output is ok -- so it's not an actual bug).\n        # I'm not exactly sure why, so this version check is approximate\n        # and should be revisited on a version bump.\n        if Version(mpl.__version__) < Version(\"3.1\"):\n            pytest.xfail()\n\n        ax = plt.figure().subplots()\n        ax.set_yscale(\"log\")\n        self.func(x=x, y=y, orient=\"h\", native_scale=True)\n        cat_points = ax.collections[0].get_offsets().copy()[:, 1]\n        assert np.ptp(np.log10(cat_points)) <= .8\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_log_scale", "self", "x", "1", "10", "100", "1000", "ax", "plt", "figure", "subplots", "ax", "set_xscale", "log", "self", "func", "x", "x", "vals", "ax", "collections", "0", "get_offsets", "0", "assert_array_equal", "x", "vals", "y", "1", "2", "3", "4", "ax", "plt", "figure", "subplots", "ax", "set_xscale", "log", "self", "func", "x", "x", "y", "y", "native_scale", "true", "for", "i", "point", "in", "enumerate", "ax", "collections", "val", "point", "get_offsets", "0", "0", "assert", "val", "pytest", "approx", "x", "i", "x", "y", "np", "ones", "100", "following", "test", "fails", "on", "pinned", "but", "not", "latest", "matplotlib", "even", "though", "visual", "output", "is", "ok", "so", "it", "s", "not", "an", "actual", "bug", "i", "m", "not", "exactly", "sure", "why", "so", "this", "version", "check", "is", "approximate", "and", "should", "be", "revisited", "on", "a", "version", "bump", "if", "version", "mpl", "__version__", "version", "3", "1", "pytest", "xfail", "ax", "plt", "figure", "subplots", "ax", "set_yscale", "log", "self", "func", "x", "x", "y", "y", "orient", "h", "native_scale", "true", "cat_points", "ax", "collections", "0", "get_offsets", "copy", "1", "assert", "np", "ptp", "np", "log10", "cat_points", "8"], "doc_len": 157}
{"doc_id": "tests/test_categorical.py::SharedScatterTests.test_vs_catplot", "file_path": "tests/test_categorical.py", "class_name": "SharedScatterTests", "func_name": "test_vs_catplot", "text": "文件路径: tests/test_categorical.py, 类名: SharedScatterTests\n    def test_vs_catplot(self, long_df, wide_df, kwargs):\n\n        kwargs = kwargs.copy()\n        if kwargs[\"data\"] == \"long\":\n            kwargs[\"data\"] = long_df\n        elif kwargs[\"data\"] == \"wide\":\n            kwargs[\"data\"] = wide_df\n\n        try:\n            name = self.func.__name__[:-4]\n        except AttributeError:\n            name = self.func.func.__name__[:-4]\n        if name == \"swarm\":\n            kwargs.pop(\"jitter\", None)\n\n        np.random.seed(0)  # for jitter\n        ax = self.func(**kwargs)\n\n        np.random.seed(0)\n        g = catplot(**kwargs, kind=name)\n\n        assert_plots_equal(ax, g.ax)\n", "tokens": ["tests", "test_categorical", "py", "sharedscattertests", "def", "test_vs_catplot", "self", "long_df", "wide_df", "kwargs", "kwargs", "kwargs", "copy", "if", "kwargs", "data", "long", "kwargs", "data", "long_df", "elif", "kwargs", "data", "wide", "kwargs", "data", "wide_df", "try", "name", "self", "func", "__name__", "4", "except", "attributeerror", "name", "self", "func", "func", "__name__", "4", "if", "name", "swarm", "kwargs", "pop", "jitter", "none", "np", "random", "seed", "0", "for", "jitter", "ax", "self", "func", "kwargs", "np", "random", "seed", "0", "g", "catplot", "kwargs", "kind", "name", "assert_plots_equal", "ax", "g", "ax"], "doc_len": 71}
{"doc_id": "tests/test_categorical.py::TestStripPlot.test_jitter_unfixed", "file_path": "tests/test_categorical.py", "class_name": "TestStripPlot", "func_name": "test_jitter_unfixed", "text": "文件路径: tests/test_categorical.py, 类名: TestStripPlot\n    def test_jitter_unfixed(self, long_df):\n\n        ax1, ax2 = plt.figure().subplots(2)\n        kws = dict(data=long_df, x=\"y\", orient=\"h\", native_scale=True)\n\n        np.random.seed(0)\n        stripplot(**kws, y=\"s\", ax=ax1)\n\n        np.random.seed(0)\n        stripplot(**kws, y=long_df[\"s\"] * 2, ax=ax2)\n\n        p1 = ax1.collections[0].get_offsets()[1]\n        p2 = ax2.collections[0].get_offsets()[1]\n\n        assert p2.std() > p1.std()\n", "tokens": ["tests", "test_categorical", "py", "teststripplot", "def", "test_jitter_unfixed", "self", "long_df", "ax1", "ax2", "plt", "figure", "subplots", "2", "kws", "dict", "data", "long_df", "x", "y", "orient", "h", "native_scale", "true", "np", "random", "seed", "0", "stripplot", "kws", "y", "s", "ax", "ax1", "np", "random", "seed", "0", "stripplot", "kws", "y", "long_df", "s", "2", "ax", "ax2", "p1", "ax1", "collections", "0", "get_offsets", "1", "p2", "ax2", "collections", "0", "get_offsets", "1", "assert", "p2", "std", "p1", "std"], "doc_len": 63}
{"doc_id": "tests/test_categorical.py::TestStripPlot.test_jitter", "file_path": "tests/test_categorical.py", "class_name": "TestStripPlot", "func_name": "test_jitter", "text": "文件路径: tests/test_categorical.py, 类名: TestStripPlot\n    def test_jitter(self, long_df, orient, jitter):\n\n        cat_var, val_var = \"a\", \"y\"\n        if orient == \"v\":\n            x_var, y_var = cat_var, val_var\n            cat_idx, val_idx = 0, 1\n        else:\n            x_var, y_var = val_var, cat_var\n            cat_idx, val_idx = 1, 0\n\n        cat_vals = categorical_order(long_df[cat_var])\n\n        ax = stripplot(\n            data=long_df, x=x_var, y=y_var, jitter=jitter,\n        )\n\n        if jitter is True:\n            jitter_range = .4\n        else:\n            jitter_range = 2 * jitter\n\n        for i, level in enumerate(cat_vals):\n\n            vals = long_df.loc[long_df[cat_var] == level, val_var]\n            points = ax.collections[i].get_offsets().T\n            cat_points = points[cat_idx]\n            val_points = points[val_idx]\n\n            assert_array_equal(val_points, vals)\n            assert np.std(cat_points) > 0\n            assert np.ptp(cat_points) <= jitter_range\n", "tokens": ["tests", "test_categorical", "py", "teststripplot", "def", "test_jitter", "self", "long_df", "orient", "jitter", "cat_var", "val_var", "a", "y", "if", "orient", "v", "x_var", "y_var", "cat_var", "val_var", "cat_idx", "val_idx", "0", "1", "else", "x_var", "y_var", "val_var", "cat_var", "cat_idx", "val_idx", "1", "0", "cat_vals", "categorical_order", "long_df", "cat_var", "ax", "stripplot", "data", "long_df", "x", "x_var", "y", "y_var", "jitter", "jitter", "if", "jitter", "is", "true", "jitter_range", "4", "else", "jitter_range", "2", "jitter", "for", "i", "level", "in", "enumerate", "cat_vals", "vals", "long_df", "loc", "long_df", "cat_var", "level", "val_var", "points", "ax", "collections", "i", "get_offsets", "t", "cat_points", "points", "cat_idx", "val_points", "points", "val_idx", "assert_array_equal", "val_points", "vals", "assert", "np", "std", "cat_points", "0", "assert", "np", "ptp", "cat_points", "jitter_range"], "doc_len": 96}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_nested_width", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_nested_width", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_nested_width(self):\n\n        ax = cat.barplot(data=self.df, x=\"g\", y=\"y\", hue=\"h\")\n        for bar in ax.patches:\n            assert bar.get_width() == pytest.approx(.8 / 2)\n        ax.clear()\n\n        ax = cat.barplot(data=self.df, x=\"g\", y=\"y\", hue=\"g\", width=.5)\n        for bar in ax.patches:\n            assert bar.get_width() == pytest.approx(.5 / 3)\n        ax.clear()\n\n        ax = cat.barplot(data=self.df, x=\"g\", y=\"y\", hue=\"g\", dodge=False)\n        for bar in ax.patches:\n            assert bar.get_width() == pytest.approx(.8)\n        ax.clear()\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_nested_width", "self", "ax", "cat", "barplot", "data", "self", "df", "x", "g", "y", "y", "hue", "h", "for", "bar", "in", "ax", "patches", "assert", "bar", "get_width", "pytest", "approx", "8", "2", "ax", "clear", "ax", "cat", "barplot", "data", "self", "df", "x", "g", "y", "y", "hue", "g", "width", "5", "for", "bar", "in", "ax", "patches", "assert", "bar", "get_width", "pytest", "approx", "5", "3", "ax", "clear", "ax", "cat", "barplot", "data", "self", "df", "x", "g", "y", "y", "hue", "g", "dodge", "false", "for", "bar", "in", "ax", "patches", "assert", "bar", "get_width", "pytest", "approx", "8", "ax", "clear"], "doc_len": 88}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_draw_vertical_bars", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_draw_vertical_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_draw_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        assert len(ax.patches) == len(p.plot_data)\n        assert len(ax.lines) == len(p.plot_data)\n\n        for bar, color in zip(ax.patches, p.colors):\n            assert bar.get_facecolor()[:-1] == color\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            assert bar.get_x() == pos\n            assert bar.get_width() == p.width\n            assert bar.get_y() == 0\n            assert bar.get_height() == stat\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_draw_vertical_bars", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "assert", "len", "ax", "patches", "len", "p", "plot_data", "assert", "len", "ax", "lines", "len", "p", "plot_data", "for", "bar", "color", "in", "zip", "ax", "patches", "p", "colors", "assert", "bar", "get_facecolor", "1", "color", "positions", "np", "arange", "len", "p", "plot_data", "p", "width", "2", "for", "bar", "pos", "stat", "in", "zip", "ax", "patches", "positions", "p", "statistic", "assert", "bar", "get_x", "pos", "assert", "bar", "get_width", "p", "width", "assert", "bar", "get_y", "0", "assert", "bar", "get_height", "stat"], "doc_len": 96}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_draw_horizontal_bars", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_draw_horizontal_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_draw_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        assert len(ax.patches) == len(p.plot_data)\n        assert len(ax.lines) == len(p.plot_data)\n\n        for bar, color in zip(ax.patches, p.colors):\n            assert bar.get_facecolor()[:-1] == color\n\n        positions = np.arange(len(p.plot_data)) - p.width / 2\n        for bar, pos, stat in zip(ax.patches, positions, p.statistic):\n            assert bar.get_y() == pos\n            assert bar.get_height() == p.width\n            assert bar.get_x() == 0\n            assert bar.get_width() == stat\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_draw_horizontal_bars", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "y", "y", "g", "orient", "h", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "assert", "len", "ax", "patches", "len", "p", "plot_data", "assert", "len", "ax", "lines", "len", "p", "plot_data", "for", "bar", "color", "in", "zip", "ax", "patches", "p", "colors", "assert", "bar", "get_facecolor", "1", "color", "positions", "np", "arange", "len", "p", "plot_data", "p", "width", "2", "for", "bar", "pos", "stat", "in", "zip", "ax", "patches", "positions", "p", "statistic", "assert", "bar", "get_y", "pos", "assert", "bar", "get_height", "p", "width", "assert", "bar", "get_x", "0", "assert", "bar", "get_width", "stat"], "doc_len": 98}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_draw_nested_vertical_bars", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_draw_nested_vertical_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_draw_nested_vertical_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        assert len(ax.patches) == n_groups * n_hues\n        assert len(ax.lines) == n_groups * n_hues\n\n        for bar in ax.patches[:n_groups]:\n            assert bar.get_facecolor()[:-1] == p.colors[0]\n        for bar in ax.patches[n_groups:]:\n            assert bar.get_facecolor()[:-1] == p.colors[1]\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            assert bar.get_x() == approx(pos - p.width / 2)\n            assert bar.get_width() == approx(p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            assert bar.get_y() == approx(0)\n            assert bar.get_height() == approx(stat)\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_draw_nested_vertical_bars", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "n_groups", "n_hues", "len", "p", "plot_data", "len", "p", "hue_names", "assert", "len", "ax", "patches", "n_groups", "n_hues", "assert", "len", "ax", "lines", "n_groups", "n_hues", "for", "bar", "in", "ax", "patches", "n_groups", "assert", "bar", "get_facecolor", "1", "p", "colors", "0", "for", "bar", "in", "ax", "patches", "n_groups", "assert", "bar", "get_facecolor", "1", "p", "colors", "1", "positions", "np", "arange", "len", "p", "plot_data", "for", "bar", "pos", "in", "zip", "ax", "patches", "n_groups", "positions", "assert", "bar", "get_x", "approx", "pos", "p", "width", "2", "assert", "bar", "get_width", "approx", "p", "nested_width", "for", "bar", "stat", "in", "zip", "ax", "patches", "p", "statistic", "t", "flat", "assert", "bar", "get_y", "approx", "0", "assert", "bar", "get_height", "approx", "stat"], "doc_len": 129}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_draw_nested_horizontal_bars", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_draw_nested_horizontal_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_draw_nested_horizontal_bars(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        n_groups, n_hues = len(p.plot_data), len(p.hue_names)\n        assert len(ax.patches) == n_groups * n_hues\n        assert len(ax.lines) == n_groups * n_hues\n\n        for bar in ax.patches[:n_groups]:\n            assert bar.get_facecolor()[:-1] == p.colors[0]\n        for bar in ax.patches[n_groups:]:\n            assert bar.get_facecolor()[:-1] == p.colors[1]\n\n        positions = np.arange(len(p.plot_data))\n        for bar, pos in zip(ax.patches[:n_groups], positions):\n            assert bar.get_y() == approx(pos - p.width / 2)\n            assert bar.get_height() == approx(p.nested_width)\n\n        for bar, stat in zip(ax.patches, p.statistic.T.flat):\n            assert bar.get_x() == approx(0)\n            assert bar.get_width() == approx(stat)\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_draw_nested_horizontal_bars", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "y", "y", "g", "hue", "h", "orient", "h", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "n_groups", "n_hues", "len", "p", "plot_data", "len", "p", "hue_names", "assert", "len", "ax", "patches", "n_groups", "n_hues", "assert", "len", "ax", "lines", "n_groups", "n_hues", "for", "bar", "in", "ax", "patches", "n_groups", "assert", "bar", "get_facecolor", "1", "p", "colors", "0", "for", "bar", "in", "ax", "patches", "n_groups", "assert", "bar", "get_facecolor", "1", "p", "colors", "1", "positions", "np", "arange", "len", "p", "plot_data", "for", "bar", "pos", "in", "zip", "ax", "patches", "n_groups", "positions", "assert", "bar", "get_y", "approx", "pos", "p", "width", "2", "assert", "bar", "get_height", "approx", "p", "nested_width", "for", "bar", "stat", "in", "zip", "ax", "patches", "p", "statistic", "t", "flat", "assert", "bar", "get_x", "approx", "0", "assert", "bar", "get_width", "approx", "stat"], "doc_len": 131}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_draw_missing_bars", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_draw_missing_bars", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_draw_missing_bars(self):\n\n        kws = self.default_kws.copy()\n\n        order = list(\"abcd\")\n        kws.update(x=\"g\", y=\"y\", order=order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        assert len(ax.patches) == len(order)\n        assert len(ax.lines) == len(order)\n\n        plt.close(\"all\")\n\n        hue_order = list(\"mno\")\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", hue_order=hue_order, data=self.df)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        assert len(ax.patches) == len(p.plot_data) * len(hue_order)\n        assert len(ax.lines) == len(p.plot_data) * len(hue_order)\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_draw_missing_bars", "self", "kws", "self", "default_kws", "copy", "order", "list", "abcd", "kws", "update", "x", "g", "y", "y", "order", "order", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "assert", "len", "ax", "patches", "len", "order", "assert", "len", "ax", "lines", "len", "order", "plt", "close", "all", "hue_order", "list", "mno", "kws", "update", "x", "g", "y", "y", "hue", "h", "hue_order", "hue_order", "data", "self", "df", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "assert", "len", "ax", "patches", "len", "p", "plot_data", "len", "hue_order", "assert", "len", "ax", "lines", "len", "p", "plot_data", "len", "hue_order", "plt", "close", "all"], "doc_len": 99}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_unaligned_index", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_unaligned_index", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_unaligned_index(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        cat.barplot(x=self.g, y=self.y, errorbar=\"sd\", ax=ax1)\n        cat.barplot(x=self.g, y=self.y_perm, errorbar=\"sd\", ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert approx(l1.get_xydata()) == l2.get_xydata()\n        for p1, p2 in zip(ax1.patches, ax2.patches):\n            assert approx(p1.get_xy()) == p2.get_xy()\n            assert approx(p1.get_height()) == p2.get_height()\n            assert approx(p1.get_width()) == p2.get_width()\n\n        f, (ax1, ax2) = plt.subplots(2)\n        hue_order = self.h.unique()\n        cat.barplot(x=self.g, y=self.y, hue=self.h,\n                    hue_order=hue_order, errorbar=\"sd\", ax=ax1)\n        cat.barplot(x=self.g, y=self.y_perm, hue=self.h,\n                    hue_order=hue_order, errorbar=\"sd\", ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert approx(l1.get_xydata()) == l2.get_xydata()\n        for p1, p2 in zip(ax1.patches, ax2.patches):\n            assert approx(p1.get_xy()) == p2.get_xy()\n            assert approx(p1.get_height()) == p2.get_height()\n            assert approx(p1.get_width()) == p2.get_width()\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_unaligned_index", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "cat", "barplot", "x", "self", "g", "y", "self", "y", "errorbar", "sd", "ax", "ax1", "cat", "barplot", "x", "self", "g", "y", "self", "y_perm", "errorbar", "sd", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "approx", "l1", "get_xydata", "l2", "get_xydata", "for", "p1", "p2", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "approx", "p1", "get_xy", "p2", "get_xy", "assert", "approx", "p1", "get_height", "p2", "get_height", "assert", "approx", "p1", "get_width", "p2", "get_width", "f", "ax1", "ax2", "plt", "subplots", "2", "hue_order", "self", "h", "unique", "cat", "barplot", "x", "self", "g", "y", "self", "y", "hue", "self", "h", "hue_order", "hue_order", "errorbar", "sd", "ax", "ax1", "cat", "barplot", "x", "self", "g", "y", "self", "y_perm", "hue", "self", "h", "hue_order", "hue_order", "errorbar", "sd", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "approx", "l1", "get_xydata", "l2", "get_xydata", "for", "p1", "p2", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "approx", "p1", "get_xy", "p2", "get_xy", "assert", "approx", "p1", "get_height", "p2", "get_height", "assert", "approx", "p1", "get_width", "p2", "get_width"], "doc_len": 165}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_barplot_colors", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_barplot_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_barplot_colors(self):\n\n        # Test unnested palette colors\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, palette=\"muted\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"muted\", len(self.g.unique()))\n        for patch, pal_color in zip(ax.patches, palette):\n            assert patch.get_facecolor()[:-1] == pal_color\n\n        plt.close(\"all\")\n\n        # Test single color\n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df,\n                   saturation=1, color=color)\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        for patch in ax.patches:\n            assert patch.get_facecolor() == color\n\n        plt.close(\"all\")\n\n        # Test nested palette colors\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df,\n                   saturation=1, palette=\"Set2\")\n        p = cat._BarPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_bars(ax, {})\n\n        palette = palettes.color_palette(\"Set2\", len(self.h.unique()))\n        for patch in ax.patches[:len(self.g.unique())]:\n            assert patch.get_facecolor()[:-1] == palette[0]\n        for patch in ax.patches[len(self.g.unique()):]:\n            assert patch.get_facecolor()[:-1] == palette[1]\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_barplot_colors", "self", "test", "unnested", "palette", "colors", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "saturation", "1", "palette", "muted", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "palette", "palettes", "color_palette", "muted", "len", "self", "g", "unique", "for", "patch", "pal_color", "in", "zip", "ax", "patches", "palette", "assert", "patch", "get_facecolor", "1", "pal_color", "plt", "close", "all", "test", "single", "color", "color", "2", "2", "3", "1", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "saturation", "1", "color", "color", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "for", "patch", "in", "ax", "patches", "assert", "patch", "get_facecolor", "color", "plt", "close", "all", "test", "nested", "palette", "colors", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "saturation", "1", "palette", "set2", "p", "cat", "_barplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_bars", "ax", "palette", "palettes", "color_palette", "set2", "len", "self", "h", "unique", "for", "patch", "in", "ax", "patches", "len", "self", "g", "unique", "assert", "patch", "get_facecolor", "1", "palette", "0", "for", "patch", "in", "ax", "patches", "len", "self", "g", "unique", "assert", "patch", "get_facecolor", "1", "palette", "1", "plt", "close", "all"], "doc_len": 186}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_simple_barplots", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_simple_barplots", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_simple_barplots(self):\n\n        ax = cat.barplot(x=\"g\", y=\"y\", data=self.df)\n        assert len(ax.patches) == len(self.g.unique())\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        plt.close(\"all\")\n\n        ax = cat.barplot(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        assert len(ax.patches) == len(self.g.unique())\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        plt.close(\"all\")\n\n        ax = cat.barplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        assert len(ax.patches) == len(self.g.unique()) * len(self.h.unique())\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        plt.close(\"all\")\n\n        ax = cat.barplot(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        assert len(ax.patches) == len(self.g.unique()) * len(self.h.unique())\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_simple_barplots", "self", "ax", "cat", "barplot", "x", "g", "y", "y", "data", "self", "df", "assert", "len", "ax", "patches", "len", "self", "g", "unique", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "plt", "close", "all", "ax", "cat", "barplot", "x", "y", "y", "g", "orient", "h", "data", "self", "df", "assert", "len", "ax", "patches", "len", "self", "g", "unique", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "plt", "close", "all", "ax", "cat", "barplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "assert", "len", "ax", "patches", "len", "self", "g", "unique", "len", "self", "h", "unique", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "plt", "close", "all", "ax", "cat", "barplot", "x", "y", "y", "g", "hue", "h", "orient", "h", "data", "self", "df", "assert", "len", "ax", "patches", "len", "self", "g", "unique", "len", "self", "h", "unique", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "plt", "close", "all"], "doc_len": 139}
{"doc_id": "tests/test_categorical.py::TestBarPlotter.test_errorbar", "file_path": "tests/test_categorical.py", "class_name": "TestBarPlotter", "func_name": "test_errorbar", "text": "文件路径: tests/test_categorical.py, 类名: TestBarPlotter\n    def test_errorbar(self, long_df):\n\n        ax = cat.barplot(data=long_df, x=\"a\", y=\"y\", errorbar=(\"sd\", 2))\n        order = categorical_order(long_df[\"a\"])\n\n        for i, line in enumerate(ax.lines):\n            sub_df = long_df.loc[long_df[\"a\"] == order[i], \"y\"]\n            mean = sub_df.mean()\n            sd = sub_df.std()\n            expected = mean - 2 * sd, mean + 2 * sd\n            assert_array_equal(line.get_ydata(), expected)\n", "tokens": ["tests", "test_categorical", "py", "testbarplotter", "def", "test_errorbar", "self", "long_df", "ax", "cat", "barplot", "data", "long_df", "x", "a", "y", "y", "errorbar", "sd", "2", "order", "categorical_order", "long_df", "a", "for", "i", "line", "in", "enumerate", "ax", "lines", "sub_df", "long_df", "loc", "long_df", "a", "order", "i", "y", "mean", "sub_df", "mean", "sd", "sub_df", "std", "expected", "mean", "2", "sd", "mean", "2", "sd", "assert_array_equal", "line", "get_ydata", "expected"], "doc_len": 56}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_different_defualt_colors", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_different_defualt_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_different_defualt_colors(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", data=self.df))\n        p = cat._PointPlotter(**kws)\n        color = palettes.color_palette()[0]\n        npt.assert_array_equal(p.colors, [color, color, color])\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_different_defualt_colors", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "x", "g", "y", "y", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "color", "palettes", "color_palette", "0", "npt", "assert_array_equal", "p", "colors", "color", "color", "color"], "doc_len": 36}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_hue_offsets", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_hue_offsets", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_hue_offsets(self):\n\n        kws = self.default_kws.copy()\n        kws.update(dict(x=\"g\", y=\"y\", hue=\"h\", data=self.df))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0])\n\n        kws.update(dict(dodge=.5))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.25, .25])\n\n        kws.update(dict(x=\"h\", hue=\"g\", dodge=0))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [0, 0, 0])\n\n        kws.update(dict(dodge=.3))\n\n        p = cat._PointPlotter(**kws)\n        npt.assert_array_equal(p.hue_offsets, [-.15, 0, .15])\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_hue_offsets", "self", "kws", "self", "default_kws", "copy", "kws", "update", "dict", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "npt", "assert_array_equal", "p", "hue_offsets", "0", "0", "kws", "update", "dict", "dodge", "5", "p", "cat", "_pointplotter", "kws", "npt", "assert_array_equal", "p", "hue_offsets", "25", "25", "kws", "update", "dict", "x", "h", "hue", "g", "dodge", "0", "p", "cat", "_pointplotter", "kws", "npt", "assert_array_equal", "p", "hue_offsets", "0", "0", "0", "kws", "update", "dict", "dodge", "3", "p", "cat", "_pointplotter", "kws", "npt", "assert_array_equal", "p", "hue_offsets", "15", "0", "15"], "doc_len": 84}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_draw_vertical_points", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_draw_vertical_points", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_draw_vertical_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == len(p.plot_data) + 1\n        points = ax.collections[0]\n        assert len(points.get_offsets()) == len(p.plot_data)\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n        npt.assert_array_equal(y, p.statistic)\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_draw_vertical_points", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "len", "p", "plot_data", "1", "points", "ax", "collections", "0", "assert", "len", "points", "get_offsets", "len", "p", "plot_data", "x", "y", "points", "get_offsets", "t", "npt", "assert_array_equal", "x", "np", "arange", "len", "p", "plot_data", "npt", "assert_array_equal", "y", "p", "statistic", "for", "got_color", "want_color", "in", "zip", "points", "get_facecolors", "p", "colors", "npt", "assert_array_equal", "got_color", "1", "want_color"], "doc_len": 87}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_draw_horizontal_points", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_draw_horizontal_points", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_draw_horizontal_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == len(p.plot_data) + 1\n        points = ax.collections[0]\n        assert len(points.get_offsets()) == len(p.plot_data)\n\n        x, y = points.get_offsets().T\n        npt.assert_array_equal(x, p.statistic)\n        npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n        for got_color, want_color in zip(points.get_facecolors(),\n                                         p.colors):\n            npt.assert_array_equal(got_color[:-1], want_color)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_draw_horizontal_points", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "y", "y", "g", "orient", "h", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "len", "p", "plot_data", "1", "points", "ax", "collections", "0", "assert", "len", "points", "get_offsets", "len", "p", "plot_data", "x", "y", "points", "get_offsets", "t", "npt", "assert_array_equal", "x", "p", "statistic", "npt", "assert_array_equal", "y", "np", "arange", "len", "p", "plot_data", "for", "got_color", "want_color", "in", "zip", "points", "get_facecolors", "p", "colors", "npt", "assert_array_equal", "got_color", "1", "want_color"], "doc_len": 89}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_draw_vertical_nested_points", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_draw_vertical_nested_points", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_draw_vertical_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        assert len(ax.collections) == 2\n        assert len(ax.lines) == len(p.plot_data) * len(p.hue_names) + len(p.hue_names)\n\n        for points, numbers, color in zip(ax.collections,\n                                          p.statistic.T,\n                                          p.colors):\n\n            assert len(points.get_offsets()) == len(p.plot_data)\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, np.arange(len(p.plot_data)))\n            npt.assert_array_equal(y, numbers)\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_draw_vertical_nested_points", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "assert", "len", "ax", "collections", "2", "assert", "len", "ax", "lines", "len", "p", "plot_data", "len", "p", "hue_names", "len", "p", "hue_names", "for", "points", "numbers", "color", "in", "zip", "ax", "collections", "p", "statistic", "t", "p", "colors", "assert", "len", "points", "get_offsets", "len", "p", "plot_data", "x", "y", "points", "get_offsets", "t", "npt", "assert_array_equal", "x", "np", "arange", "len", "p", "plot_data", "npt", "assert_array_equal", "y", "numbers", "for", "got_color", "in", "points", "get_facecolors", "npt", "assert_array_equal", "got_color", "1", "color"], "doc_len": 98}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_draw_horizontal_nested_points", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_draw_horizontal_nested_points", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_draw_horizontal_nested_points(self):\n\n        kws = self.default_kws.copy()\n        kws.update(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        assert len(ax.collections) == 2\n        assert len(ax.lines) == len(p.plot_data) * len(p.hue_names) + len(p.hue_names)\n\n        for points, numbers, color in zip(ax.collections,\n                                          p.statistic.T,\n                                          p.colors):\n\n            assert len(points.get_offsets()) == len(p.plot_data)\n\n            x, y = points.get_offsets().T\n            npt.assert_array_equal(x, numbers)\n            npt.assert_array_equal(y, np.arange(len(p.plot_data)))\n\n            for got_color in points.get_facecolors():\n                npt.assert_array_equal(got_color[:-1], color)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_draw_horizontal_nested_points", "self", "kws", "self", "default_kws", "copy", "kws", "update", "x", "y", "y", "g", "hue", "h", "orient", "h", "data", "self", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "assert", "len", "ax", "collections", "2", "assert", "len", "ax", "lines", "len", "p", "plot_data", "len", "p", "hue_names", "len", "p", "hue_names", "for", "points", "numbers", "color", "in", "zip", "ax", "collections", "p", "statistic", "t", "p", "colors", "assert", "len", "points", "get_offsets", "len", "p", "plot_data", "x", "y", "points", "get_offsets", "t", "npt", "assert_array_equal", "x", "numbers", "npt", "assert_array_equal", "y", "np", "arange", "len", "p", "plot_data", "for", "got_color", "in", "points", "get_facecolors", "npt", "assert_array_equal", "got_color", "1", "color"], "doc_len": 100}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_draw_missing_points", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_draw_missing_points", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_draw_missing_points(self):\n\n        kws = self.default_kws.copy()\n        df = self.df.copy()\n\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", hue_order=[\"x\", \"y\"], data=df)\n        p = cat._PointPlotter(**kws)\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        df.loc[df[\"h\"] == \"m\", \"y\"] = np.nan\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=df)\n        p = cat._PointPlotter(**kws)\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_draw_missing_points", "self", "kws", "self", "default_kws", "copy", "df", "self", "df", "copy", "kws", "update", "x", "g", "y", "y", "hue", "h", "hue_order", "x", "y", "data", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "df", "loc", "df", "h", "m", "y", "np", "nan", "kws", "update", "x", "g", "y", "y", "hue", "h", "data", "df", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax"], "doc_len": 68}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_unaligned_index", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_unaligned_index", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_unaligned_index(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        cat.pointplot(x=self.g, y=self.y, errorbar=\"sd\", ax=ax1)\n        cat.pointplot(x=self.g, y=self.y_perm, errorbar=\"sd\", ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert approx(l1.get_xydata()) == l2.get_xydata()\n        for p1, p2 in zip(ax1.collections, ax2.collections):\n            assert approx(p1.get_offsets()) == p2.get_offsets()\n\n        f, (ax1, ax2) = plt.subplots(2)\n        hue_order = self.h.unique()\n        cat.pointplot(x=self.g, y=self.y, hue=self.h,\n                      hue_order=hue_order, errorbar=\"sd\", ax=ax1)\n        cat.pointplot(x=self.g, y=self.y_perm, hue=self.h,\n                      hue_order=hue_order, errorbar=\"sd\", ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert approx(l1.get_xydata()) == l2.get_xydata()\n        for p1, p2 in zip(ax1.collections, ax2.collections):\n            assert approx(p1.get_offsets()) == p2.get_offsets()\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_unaligned_index", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "cat", "pointplot", "x", "self", "g", "y", "self", "y", "errorbar", "sd", "ax", "ax1", "cat", "pointplot", "x", "self", "g", "y", "self", "y_perm", "errorbar", "sd", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "approx", "l1", "get_xydata", "l2", "get_xydata", "for", "p1", "p2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert", "approx", "p1", "get_offsets", "p2", "get_offsets", "f", "ax1", "ax2", "plt", "subplots", "2", "hue_order", "self", "h", "unique", "cat", "pointplot", "x", "self", "g", "y", "self", "y", "hue", "self", "h", "hue_order", "hue_order", "errorbar", "sd", "ax", "ax1", "cat", "pointplot", "x", "self", "g", "y", "self", "y_perm", "hue", "self", "h", "hue_order", "hue_order", "errorbar", "sd", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "approx", "l1", "get_xydata", "l2", "get_xydata", "for", "p1", "p2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert", "approx", "p1", "get_offsets", "p2", "get_offsets"], "doc_len": 141}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_pointplot_colors", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_pointplot_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_pointplot_colors(self):\n\n        # Test a single-color unnested plot\n        color = (.2, .2, .3, 1)\n        kws = self.default_kws.copy()\n        kws.update(x=\"g\", y=\"y\", data=self.df, color=color)\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines:\n            assert line.get_color() == color[:-1]\n\n        for got_color in ax.collections[0].get_facecolors():\n            npt.assert_array_equal(rgb2hex(got_color), rgb2hex(color))\n\n        plt.close(\"all\")\n\n        # Test a multi-color unnested plot\n        palette = palettes.color_palette(\"Set1\", 3)\n        kws.update(x=\"g\", y=\"y\", data=self.df, palette=\"Set1\")\n        p = cat._PointPlotter(**kws)\n\n        assert not p.join\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line, pal_color in zip(ax.lines, palette):\n            npt.assert_array_equal(line.get_color(), pal_color)\n\n        for point_color, pal_color in zip(ax.collections[0].get_facecolors(),\n                                          palette):\n            npt.assert_array_equal(rgb2hex(point_color), rgb2hex(pal_color))\n\n        plt.close(\"all\")\n\n        # Test a multi-colored nested plot\n        palette = palettes.color_palette(\"dark\", 2)\n        kws.update(x=\"g\", y=\"y\", hue=\"h\", data=self.df, palette=\"dark\")\n        p = cat._PointPlotter(**kws)\n\n        f, ax = plt.subplots()\n        p.draw_points(ax)\n\n        for line in ax.lines[:(len(p.plot_data) + 1)]:\n            assert line.get_color() == palette[0]\n        for line in ax.lines[(len(p.plot_data) + 1):]:\n            assert line.get_color() == palette[1]\n\n        for i, pal_color in enumerate(palette):\n            for point_color in ax.collections[i].get_facecolors():\n                npt.assert_array_equal(point_color[:-1], pal_color)\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_pointplot_colors", "self", "test", "a", "single", "color", "unnested", "plot", "color", "2", "2", "3", "1", "kws", "self", "default_kws", "copy", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "color", "color", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "for", "line", "in", "ax", "lines", "assert", "line", "get_color", "color", "1", "for", "got_color", "in", "ax", "collections", "0", "get_facecolors", "npt", "assert_array_equal", "rgb2hex", "got_color", "rgb2hex", "color", "plt", "close", "all", "test", "a", "multi", "color", "unnested", "plot", "palette", "palettes", "color_palette", "set1", "3", "kws", "update", "x", "g", "y", "y", "data", "self", "df", "palette", "set1", "p", "cat", "_pointplotter", "kws", "assert", "not", "p", "join", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "for", "line", "pal_color", "in", "zip", "ax", "lines", "palette", "npt", "assert_array_equal", "line", "get_color", "pal_color", "for", "point_color", "pal_color", "in", "zip", "ax", "collections", "0", "get_facecolors", "palette", "npt", "assert_array_equal", "rgb2hex", "point_color", "rgb2hex", "pal_color", "plt", "close", "all", "test", "a", "multi", "colored", "nested", "plot", "palette", "palettes", "color_palette", "dark", "2", "kws", "update", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "palette", "dark", "p", "cat", "_pointplotter", "kws", "f", "ax", "plt", "subplots", "p", "draw_points", "ax", "for", "line", "in", "ax", "lines", "len", "p", "plot_data", "1", "assert", "line", "get_color", "palette", "0", "for", "line", "in", "ax", "lines", "len", "p", "plot_data", "1", "assert", "line", "get_color", "palette", "1", "for", "i", "pal_color", "in", "enumerate", "palette", "for", "point_color", "in", "ax", "collections", "i", "get_facecolors", "npt", "assert_array_equal", "point_color", "1", "pal_color", "plt", "close", "all"], "doc_len": 223}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_simple_pointplots", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_simple_pointplots", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_simple_pointplots(self):\n\n        ax = cat.pointplot(x=\"g\", y=\"y\", data=self.df)\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == len(self.g.unique()) + 1\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"y\", y=\"g\", orient=\"h\", data=self.df)\n        assert len(ax.collections) == 1\n        assert len(ax.lines) == len(self.g.unique()) + 1\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        assert len(ax.collections) == len(self.h.unique())\n        assert len(ax.lines) == (\n            len(self.g.unique()) * len(self.h.unique()) + len(self.h.unique())\n        )\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"y\", y=\"g\", hue=\"h\", orient=\"h\", data=self.df)\n        assert len(ax.collections) == len(self.h.unique())\n        assert len(ax.lines) == (\n            len(self.g.unique()) * len(self.h.unique()) + len(self.h.unique())\n        )\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_simple_pointplots", "self", "ax", "cat", "pointplot", "x", "g", "y", "y", "data", "self", "df", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "len", "self", "g", "unique", "1", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "plt", "close", "all", "ax", "cat", "pointplot", "x", "y", "y", "g", "orient", "h", "data", "self", "df", "assert", "len", "ax", "collections", "1", "assert", "len", "ax", "lines", "len", "self", "g", "unique", "1", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "plt", "close", "all", "ax", "cat", "pointplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "assert", "len", "ax", "collections", "len", "self", "h", "unique", "assert", "len", "ax", "lines", "len", "self", "g", "unique", "len", "self", "h", "unique", "len", "self", "h", "unique", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "plt", "close", "all", "ax", "cat", "pointplot", "x", "y", "y", "g", "hue", "h", "orient", "h", "data", "self", "df", "assert", "len", "ax", "collections", "len", "self", "h", "unique", "assert", "len", "ax", "lines", "len", "self", "g", "unique", "len", "self", "h", "unique", "len", "self", "h", "unique", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "plt", "close", "all"], "doc_len": 175}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_errorbar", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_errorbar", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_errorbar(self, long_df):\n\n        ax = cat.pointplot(\n            data=long_df, x=\"a\", y=\"y\", errorbar=(\"sd\", 2), join=False\n        )\n        order = categorical_order(long_df[\"a\"])\n\n        for i, line in enumerate(ax.lines):\n            sub_df = long_df.loc[long_df[\"a\"] == order[i], \"y\"]\n            mean = sub_df.mean()\n            sd = sub_df.std()\n            expected = mean - 2 * sd, mean + 2 * sd\n            assert_array_equal(line.get_ydata(), expected)\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_errorbar", "self", "long_df", "ax", "cat", "pointplot", "data", "long_df", "x", "a", "y", "y", "errorbar", "sd", "2", "join", "false", "order", "categorical_order", "long_df", "a", "for", "i", "line", "in", "enumerate", "ax", "lines", "sub_df", "long_df", "loc", "long_df", "a", "order", "i", "y", "mean", "sub_df", "mean", "sd", "sub_df", "std", "expected", "mean", "2", "sd", "mean", "2", "sd", "assert_array_equal", "line", "get_ydata", "expected"], "doc_len": 58}
{"doc_id": "tests/test_categorical.py::TestPointPlotter.test_on_facetgrid", "file_path": "tests/test_categorical.py", "class_name": "TestPointPlotter", "func_name": "test_on_facetgrid", "text": "文件路径: tests/test_categorical.py, 类名: TestPointPlotter\n    def test_on_facetgrid(self, long_df):\n\n        g = FacetGrid(long_df, hue=\"a\")\n        g.map(pointplot, \"a\", \"y\")\n        g.add_legend()\n\n        order = categorical_order(long_df[\"a\"])\n        legend_texts = [t.get_text() for t in g.legend.texts]\n        assert legend_texts == order\n", "tokens": ["tests", "test_categorical", "py", "testpointplotter", "def", "test_on_facetgrid", "self", "long_df", "g", "facetgrid", "long_df", "hue", "a", "g", "map", "pointplot", "a", "y", "g", "add_legend", "order", "categorical_order", "long_df", "a", "legend_texts", "t", "get_text", "for", "t", "in", "g", "legend", "texts", "assert", "legend_texts", "order"], "doc_len": 36}
{"doc_id": "tests/test_categorical.py::TestCountPlot.test_plot_elements", "file_path": "tests/test_categorical.py", "class_name": "TestCountPlot", "func_name": "test_plot_elements", "text": "文件路径: tests/test_categorical.py, 类名: TestCountPlot\n    def test_plot_elements(self):\n\n        ax = cat.countplot(x=\"g\", data=self.df)\n        assert len(ax.patches) == self.g.unique().size\n        for p in ax.patches:\n            assert p.get_y() == 0\n            assert p.get_height() == self.g.size / self.g.unique().size\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", data=self.df)\n        assert len(ax.patches) == self.g.unique().size\n        for p in ax.patches:\n            assert p.get_x() == 0\n            assert p.get_width() == self.g.size / self.g.unique().size\n        plt.close(\"all\")\n\n        ax = cat.countplot(x=\"g\", hue=\"h\", data=self.df)\n        assert len(ax.patches) == self.g.unique().size * self.h.unique().size\n        plt.close(\"all\")\n\n        ax = cat.countplot(y=\"g\", hue=\"h\", data=self.df)\n        assert len(ax.patches) == self.g.unique().size * self.h.unique().size\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testcountplot", "def", "test_plot_elements", "self", "ax", "cat", "countplot", "x", "g", "data", "self", "df", "assert", "len", "ax", "patches", "self", "g", "unique", "size", "for", "p", "in", "ax", "patches", "assert", "p", "get_y", "0", "assert", "p", "get_height", "self", "g", "size", "self", "g", "unique", "size", "plt", "close", "all", "ax", "cat", "countplot", "y", "g", "data", "self", "df", "assert", "len", "ax", "patches", "self", "g", "unique", "size", "for", "p", "in", "ax", "patches", "assert", "p", "get_x", "0", "assert", "p", "get_width", "self", "g", "size", "self", "g", "unique", "size", "plt", "close", "all", "ax", "cat", "countplot", "x", "g", "hue", "h", "data", "self", "df", "assert", "len", "ax", "patches", "self", "g", "unique", "size", "self", "h", "unique", "size", "plt", "close", "all", "ax", "cat", "countplot", "y", "g", "hue", "h", "data", "self", "df", "assert", "len", "ax", "patches", "self", "g", "unique", "size", "self", "h", "unique", "size", "plt", "close", "all"], "doc_len": 133}
{"doc_id": "tests/test_categorical.py::TestCountPlot.test_input_error", "file_path": "tests/test_categorical.py", "class_name": "TestCountPlot", "func_name": "test_input_error", "text": "文件路径: tests/test_categorical.py, 类名: TestCountPlot\n    def test_input_error(self):\n\n        with pytest.raises(ValueError):\n            cat.countplot(x=\"g\", y=\"h\", data=self.df)\n", "tokens": ["tests", "test_categorical", "py", "testcountplot", "def", "test_input_error", "self", "with", "pytest", "raises", "valueerror", "cat", "countplot", "x", "g", "y", "h", "data", "self", "df"], "doc_len": 20}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_facet_organization", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_facet_organization", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_facet_organization(self):\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df)\n        assert g.axes.shape == (1, 1)\n\n        g = cat.catplot(x=\"g\", y=\"y\", col=\"h\", data=self.df)\n        assert g.axes.shape == (1, 2)\n\n        g = cat.catplot(x=\"g\", y=\"y\", row=\"h\", data=self.df)\n        assert g.axes.shape == (2, 1)\n\n        g = cat.catplot(x=\"g\", y=\"y\", col=\"u\", row=\"h\", data=self.df)\n        assert g.axes.shape == (2, 3)\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_facet_organization", "self", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "assert", "g", "axes", "shape", "1", "1", "g", "cat", "catplot", "x", "g", "y", "y", "col", "h", "data", "self", "df", "assert", "g", "axes", "shape", "1", "2", "g", "cat", "catplot", "x", "g", "y", "y", "row", "h", "data", "self", "df", "assert", "g", "axes", "shape", "2", "1", "g", "cat", "catplot", "x", "g", "y", "y", "col", "u", "row", "h", "data", "self", "df", "assert", "g", "axes", "shape", "2", "3"], "doc_len": 79}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_plot_elements", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_plot_elements", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_plot_elements(self):\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"point\")\n        assert len(g.ax.collections) == 1\n        want_lines = self.g.unique().size + 1\n        assert len(g.ax.lines) == want_lines\n\n        g = cat.catplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, kind=\"point\")\n        want_collections = self.h.unique().size\n        assert len(g.ax.collections) == want_collections\n        want_lines = (self.g.unique().size + 1) * self.h.unique().size\n        assert len(g.ax.lines) == want_lines\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size\n        assert len(g.ax.patches) == want_elements\n        assert len(g.ax.lines) == want_elements\n\n        g = cat.catplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, kind=\"bar\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        assert len(g.ax.patches) == want_elements\n        assert len(g.ax.lines) == want_elements\n\n        g = cat.catplot(x=\"g\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size\n        assert len(g.ax.patches) == want_elements\n        assert len(g.ax.lines) == 0\n\n        g = cat.catplot(x=\"g\", hue=\"h\", data=self.df, kind=\"count\")\n        want_elements = self.g.unique().size * self.h.unique().size\n        assert len(g.ax.patches) == want_elements\n        assert len(g.ax.lines) == 0\n\n        g = cat.catplot(y=\"y\", data=self.df, kind=\"box\")\n        want_artists = 1\n        assert len(self.get_box_artists(g.ax)) == want_artists\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size\n        assert len(self.get_box_artists(g.ax)) == want_artists\n\n        g = cat.catplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, kind=\"box\")\n        want_artists = self.g.unique().size * self.h.unique().size\n        assert len(self.get_box_artists(g.ax)) == want_artists\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df,\n                        kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size\n        assert len(g.ax.collections) == want_elements\n\n        g = cat.catplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df,\n                        kind=\"violin\", inner=None)\n        want_elements = self.g.unique().size * self.h.unique().size\n        assert len(g.ax.collections) == want_elements\n\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size\n        assert len(g.ax.collections) == want_elements\n        for strip in g.ax.collections:\n            assert same_color(strip.get_facecolors(), \"C0\")\n\n        g = cat.catplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df, kind=\"strip\")\n        want_elements = self.g.unique().size + self.h.unique().size\n        assert len(g.ax.collections) == want_elements\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_plot_elements", "self", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "point", "assert", "len", "g", "ax", "collections", "1", "want_lines", "self", "g", "unique", "size", "1", "assert", "len", "g", "ax", "lines", "want_lines", "g", "cat", "catplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "kind", "point", "want_collections", "self", "h", "unique", "size", "assert", "len", "g", "ax", "collections", "want_collections", "want_lines", "self", "g", "unique", "size", "1", "self", "h", "unique", "size", "assert", "len", "g", "ax", "lines", "want_lines", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "bar", "want_elements", "self", "g", "unique", "size", "assert", "len", "g", "ax", "patches", "want_elements", "assert", "len", "g", "ax", "lines", "want_elements", "g", "cat", "catplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "kind", "bar", "want_elements", "self", "g", "unique", "size", "self", "h", "unique", "size", "assert", "len", "g", "ax", "patches", "want_elements", "assert", "len", "g", "ax", "lines", "want_elements", "g", "cat", "catplot", "x", "g", "data", "self", "df", "kind", "count", "want_elements", "self", "g", "unique", "size", "assert", "len", "g", "ax", "patches", "want_elements", "assert", "len", "g", "ax", "lines", "0", "g", "cat", "catplot", "x", "g", "hue", "h", "data", "self", "df", "kind", "count", "want_elements", "self", "g", "unique", "size", "self", "h", "unique", "size", "assert", "len", "g", "ax", "patches", "want_elements", "assert", "len", "g", "ax", "lines", "0", "g", "cat", "catplot", "y", "y", "data", "self", "df", "kind", "box", "want_artists", "1", "assert", "len", "self", "get_box_artists", "g", "ax", "want_artists", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "box", "want_artists", "self", "g", "unique", "size", "assert", "len", "self", "get_box_artists", "g", "ax", "want_artists", "g", "cat", "catplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "kind", "box", "want_artists", "self", "g", "unique", "size", "self", "h", "unique", "size", "assert", "len", "self", "get_box_artists", "g", "ax", "want_artists", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "violin", "inner", "none", "want_elements", "self", "g", "unique", "size", "assert", "len", "g", "ax", "collections", "want_elements", "g", "cat", "catplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "kind", "violin", "inner", "none", "want_elements", "self", "g", "unique", "size", "self", "h", "unique", "size", "assert", "len", "g", "ax", "collections", "want_elements", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "strip", "want_elements", "self", "g", "unique", "size", "assert", "len", "g", "ax", "collections", "want_elements", "for", "strip", "in", "g", "ax", "collections", "assert", "same_color", "strip", "get_facecolors", "c0", "g", "cat", "catplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "kind", "strip", "want_elements", "self", "g", "unique", "size", "self", "h", "unique", "size", "assert", "len", "g", "ax", "collections", "want_elements"], "doc_len": 394}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_bad_plot_kind_error", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_bad_plot_kind_error", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_bad_plot_kind_error(self):\n\n        with pytest.raises(ValueError):\n            cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"not_a_kind\")\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_bad_plot_kind_error", "self", "with", "pytest", "raises", "valueerror", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "not_a_kind"], "doc_len": 22}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_count_x_and_y", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_count_x_and_y", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_count_x_and_y(self):\n\n        with pytest.raises(ValueError):\n            cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"count\")\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_count_x_and_y", "self", "with", "pytest", "raises", "valueerror", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "count"], "doc_len": 22}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_plot_colors", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_plot_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_plot_colors(self):\n\n        ax = cat.barplot(x=\"g\", y=\"y\", data=self.df)\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, kind=\"bar\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            assert p1.get_facecolor() == p2.get_facecolor()\n        plt.close(\"all\")\n\n        ax = cat.barplot(x=\"g\", y=\"y\", data=self.df, color=\"purple\")\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df,\n                        kind=\"bar\", color=\"purple\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            assert p1.get_facecolor() == p2.get_facecolor()\n        plt.close(\"all\")\n\n        ax = cat.barplot(x=\"g\", y=\"y\", data=self.df, palette=\"Set2\", hue=\"h\")\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df,\n                        kind=\"bar\", palette=\"Set2\", hue=\"h\")\n        for p1, p2 in zip(ax.patches, g.ax.patches):\n            assert p1.get_facecolor() == p2.get_facecolor()\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"g\", y=\"y\", data=self.df)\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df)\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            assert l1.get_color() == l2.get_color()\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"g\", y=\"y\", data=self.df, color=\"purple\")\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, color=\"purple\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            assert l1.get_color() == l2.get_color()\n        plt.close(\"all\")\n\n        ax = cat.pointplot(x=\"g\", y=\"y\", data=self.df, palette=\"Set2\", hue=\"h\")\n        g = cat.catplot(x=\"g\", y=\"y\", data=self.df, palette=\"Set2\", hue=\"h\")\n        for l1, l2 in zip(ax.lines, g.ax.lines):\n            assert l1.get_color() == l2.get_color()\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_plot_colors", "self", "ax", "cat", "barplot", "x", "g", "y", "y", "data", "self", "df", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "bar", "for", "p1", "p2", "in", "zip", "ax", "patches", "g", "ax", "patches", "assert", "p1", "get_facecolor", "p2", "get_facecolor", "plt", "close", "all", "ax", "cat", "barplot", "x", "g", "y", "y", "data", "self", "df", "color", "purple", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "bar", "color", "purple", "for", "p1", "p2", "in", "zip", "ax", "patches", "g", "ax", "patches", "assert", "p1", "get_facecolor", "p2", "get_facecolor", "plt", "close", "all", "ax", "cat", "barplot", "x", "g", "y", "y", "data", "self", "df", "palette", "set2", "hue", "h", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "kind", "bar", "palette", "set2", "hue", "h", "for", "p1", "p2", "in", "zip", "ax", "patches", "g", "ax", "patches", "assert", "p1", "get_facecolor", "p2", "get_facecolor", "plt", "close", "all", "ax", "cat", "pointplot", "x", "g", "y", "y", "data", "self", "df", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "for", "l1", "l2", "in", "zip", "ax", "lines", "g", "ax", "lines", "assert", "l1", "get_color", "l2", "get_color", "plt", "close", "all", "ax", "cat", "pointplot", "x", "g", "y", "y", "data", "self", "df", "color", "purple", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "color", "purple", "for", "l1", "l2", "in", "zip", "ax", "lines", "g", "ax", "lines", "assert", "l1", "get_color", "l2", "get_color", "plt", "close", "all", "ax", "cat", "pointplot", "x", "g", "y", "y", "data", "self", "df", "palette", "set2", "hue", "h", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "palette", "set2", "hue", "h", "for", "l1", "l2", "in", "zip", "ax", "lines", "g", "ax", "lines", "assert", "l1", "get_color", "l2", "get_color", "plt", "close", "all"], "doc_len": 265}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_ax_kwarg_removal", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_ax_kwarg_removal", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_ax_kwarg_removal(self):\n\n        f, ax = plt.subplots()\n        with pytest.warns(UserWarning, match=\"catplot is a figure-level\"):\n            g = cat.catplot(x=\"g\", y=\"y\", data=self.df, ax=ax)\n        assert len(ax.collections) == 0\n        assert len(g.ax.collections) > 0\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_ax_kwarg_removal", "self", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "userwarning", "match", "catplot", "is", "a", "figure", "level", "g", "cat", "catplot", "x", "g", "y", "y", "data", "self", "df", "ax", "ax", "assert", "len", "ax", "collections", "0", "assert", "len", "g", "ax", "collections", "0"], "doc_len": 44}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_share_xy", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_share_xy", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_share_xy(self):\n\n        # Test default behavior works\n        g = cat.catplot(x=\"g\", y=\"y\", col=\"g\", data=self.df, sharex=True)\n        for ax in g.axes.flat:\n            assert len(ax.collections) == len(self.df.g.unique())\n\n        g = cat.catplot(x=\"y\", y=\"g\", col=\"g\", data=self.df, sharey=True)\n        for ax in g.axes.flat:\n            assert len(ax.collections) == len(self.df.g.unique())\n\n        # Test unsharing workscol\n        with pytest.warns(UserWarning):\n            g = cat.catplot(\n                x=\"g\", y=\"y\", col=\"g\", data=self.df, sharex=False, kind=\"bar\",\n            )\n            for ax in g.axes.flat:\n                assert len(ax.patches) == 1\n\n        with pytest.warns(UserWarning):\n            g = cat.catplot(\n                x=\"y\", y=\"g\", col=\"g\", data=self.df, sharey=False, kind=\"bar\",\n            )\n            for ax in g.axes.flat:\n                assert len(ax.patches) == 1\n\n        # Make sure no warning is raised if color is provided on unshared plot\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\")\n            g = cat.catplot(\n                x=\"g\", y=\"y\", col=\"g\", data=self.df, sharex=False, color=\"b\"\n            )\n        for ax in g.axes.flat:\n            assert ax.get_xlim() == (-.5, .5)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\")\n            g = cat.catplot(\n                x=\"y\", y=\"g\", col=\"g\", data=self.df, sharey=False, color=\"r\"\n            )\n        for ax in g.axes.flat:\n            assert ax.get_ylim() == (.5, -.5)\n\n        # Make sure order is used if given, regardless of sharex value\n        order = self.df.g.unique()\n        g = cat.catplot(x=\"g\", y=\"y\", col=\"g\", data=self.df, sharex=False, order=order)\n        for ax in g.axes.flat:\n            assert len(ax.collections) == len(self.df.g.unique())\n\n        g = cat.catplot(x=\"y\", y=\"g\", col=\"g\", data=self.df, sharey=False, order=order)\n        for ax in g.axes.flat:\n            assert len(ax.collections) == len(self.df.g.unique())\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_share_xy", "self", "test", "default", "behavior", "works", "g", "cat", "catplot", "x", "g", "y", "y", "col", "g", "data", "self", "df", "sharex", "true", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "collections", "len", "self", "df", "g", "unique", "g", "cat", "catplot", "x", "y", "y", "g", "col", "g", "data", "self", "df", "sharey", "true", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "collections", "len", "self", "df", "g", "unique", "test", "unsharing", "workscol", "with", "pytest", "warns", "userwarning", "g", "cat", "catplot", "x", "g", "y", "y", "col", "g", "data", "self", "df", "sharex", "false", "kind", "bar", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "patches", "1", "with", "pytest", "warns", "userwarning", "g", "cat", "catplot", "x", "y", "y", "g", "col", "g", "data", "self", "df", "sharey", "false", "kind", "bar", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "patches", "1", "make", "sure", "no", "warning", "is", "raised", "if", "color", "is", "provided", "on", "unshared", "plot", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "g", "cat", "catplot", "x", "g", "y", "y", "col", "g", "data", "self", "df", "sharex", "false", "color", "b", "for", "ax", "in", "g", "axes", "flat", "assert", "ax", "get_xlim", "5", "5", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "g", "cat", "catplot", "x", "y", "y", "g", "col", "g", "data", "self", "df", "sharey", "false", "color", "r", "for", "ax", "in", "g", "axes", "flat", "assert", "ax", "get_ylim", "5", "5", "make", "sure", "order", "is", "used", "if", "given", "regardless", "of", "sharex", "value", "order", "self", "df", "g", "unique", "g", "cat", "catplot", "x", "g", "y", "y", "col", "g", "data", "self", "df", "sharex", "false", "order", "order", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "collections", "len", "self", "df", "g", "unique", "g", "cat", "catplot", "x", "y", "y", "g", "col", "g", "data", "self", "df", "sharey", "false", "order", "order", "for", "ax", "in", "g", "axes", "flat", "assert", "len", "ax", "collections", "len", "self", "df", "g", "unique"], "doc_len": 291}
{"doc_id": "tests/test_categorical.py::TestCatPlot.test_array_faceter", "file_path": "tests/test_categorical.py", "class_name": "TestCatPlot", "func_name": "test_array_faceter", "text": "文件路径: tests/test_categorical.py, 类名: TestCatPlot\n    def test_array_faceter(self, long_df, var):\n\n        g1 = catplot(data=long_df, x=\"y\", **{var: \"a\"})\n        g2 = catplot(data=long_df, x=\"y\", **{var: long_df[\"a\"].to_numpy()})\n\n        for ax1, ax2 in zip(g1.axes.flat, g2.axes.flat):\n            assert_plots_equal(ax1, ax2)\n", "tokens": ["tests", "test_categorical", "py", "testcatplot", "def", "test_array_faceter", "self", "long_df", "var", "g1", "catplot", "data", "long_df", "x", "y", "var", "a", "g2", "catplot", "data", "long_df", "x", "y", "var", "long_df", "a", "to_numpy", "for", "ax1", "ax2", "in", "zip", "g1", "axes", "flat", "g2", "axes", "flat", "assert_plots_equal", "ax1", "ax2"], "doc_len": 41}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.ispatch", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "ispatch", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def ispatch(self, c):\n\n        return isinstance(c, mpl.collections.PatchCollection)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "ispatch", "self", "c", "return", "isinstance", "c", "mpl", "collections", "patchcollection"], "doc_len": 14}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.ispath", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "ispath", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def ispath(self, c):\n\n        return isinstance(c, mpl.collections.PathCollection)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "ispath", "self", "c", "return", "isinstance", "c", "mpl", "collections", "pathcollection"], "doc_len": 14}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.edge_calc", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "edge_calc", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def edge_calc(self, n, data):\n\n        q = np.asanyarray([0.5 ** n, 1 - 0.5 ** n]) * 100\n        q = list(np.unique(q))\n        return np.percentile(data, q)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "edge_calc", "self", "n", "data", "q", "np", "asanyarray", "0", "5", "n", "1", "0", "5", "n", "100", "q", "list", "np", "unique", "q", "return", "np", "percentile", "data", "q"], "doc_len": 30}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_ends_finite", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_ends_finite", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_ends_finite(self):\n\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", data=self.df)\n        box_ends = []\n        k_vals = []\n        for s in p.plot_data:\n            b, k = p._lv_box_ends(s)\n            box_ends.append(b)\n            k_vals.append(k)\n\n        # Check that all the box ends are finite and are within\n        # the bounds of the data\n        b_e = map(lambda a: np.all(np.isfinite(a)), box_ends)\n        assert np.sum(list(b_e)) == len(box_ends)\n\n        def within(t):\n            a, d = t\n            return ((np.ravel(a) <= d.max())\n                    & (np.ravel(a) >= d.min())).all()\n\n        b_w = map(within, zip(box_ends, p.plot_data))\n        assert np.sum(list(b_w)) == len(box_ends)\n\n        k_f = map(lambda k: (k > 0.) & np.isfinite(k), k_vals)\n        assert np.sum(list(k_f)) == len(k_vals)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_ends_finite", "self", "p", "cat", "_lvplotter", "self", "default_kws", "p", "establish_variables", "g", "y", "data", "self", "df", "box_ends", "k_vals", "for", "s", "in", "p", "plot_data", "b", "k", "p", "_lv_box_ends", "s", "box_ends", "append", "b", "k_vals", "append", "k", "check", "that", "all", "the", "box", "ends", "are", "finite", "and", "are", "within", "the", "bounds", "of", "the", "data", "b_e", "map", "lambda", "a", "np", "all", "np", "isfinite", "a", "box_ends", "assert", "np", "sum", "list", "b_e", "len", "box_ends", "def", "within", "t", "a", "d", "t", "return", "np", "ravel", "a", "d", "max", "np", "ravel", "a", "d", "min", "all", "b_w", "map", "within", "zip", "box_ends", "p", "plot_data", "assert", "np", "sum", "list", "b_w", "len", "box_ends", "k_f", "map", "lambda", "k", "k", "0", "np", "isfinite", "k", "k_vals", "assert", "np", "sum", "list", "k_f", "len", "k_vals"], "doc_len": 119}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_ends_correct_tukey", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_ends_correct_tukey", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_ends_correct_tukey(self):\n\n        n = 100\n        linear_data = np.arange(n)\n        expected_k = max(int(np.log2(n)) - 3, 1)\n        expected_edges = [self.edge_calc(i, linear_data)\n                          for i in range(expected_k + 1, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(linear_data)\n\n        npt.assert_array_equal(expected_edges, calc_edges)\n        assert expected_k == calc_k\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_ends_correct_tukey", "self", "n", "100", "linear_data", "np", "arange", "n", "expected_k", "max", "int", "np", "log2", "n", "3", "1", "expected_edges", "self", "edge_calc", "i", "linear_data", "for", "i", "in", "range", "expected_k", "1", "1", "1", "p", "cat", "_lvplotter", "self", "default_kws", "calc_edges", "calc_k", "p", "_lv_box_ends", "linear_data", "npt", "assert_array_equal", "expected_edges", "calc_edges", "assert", "expected_k", "calc_k"], "doc_len": 51}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_ends_correct_proportion", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_ends_correct_proportion", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_ends_correct_proportion(self):\n\n        n = 100\n        linear_data = np.arange(n)\n        expected_k = int(np.log2(n)) - int(np.log2(n * 0.007)) + 1\n        expected_edges = [self.edge_calc(i, linear_data)\n                          for i in range(expected_k + 1, 1, -1)]\n\n        kws = self.default_kws.copy()\n        kws[\"k_depth\"] = \"proportion\"\n        p = cat._LVPlotter(**kws)\n        calc_edges, calc_k = p._lv_box_ends(linear_data)\n\n        npt.assert_array_equal(expected_edges, calc_edges)\n        assert expected_k == calc_k\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_ends_correct_proportion", "self", "n", "100", "linear_data", "np", "arange", "n", "expected_k", "int", "np", "log2", "n", "int", "np", "log2", "n", "0", "007", "1", "expected_edges", "self", "edge_calc", "i", "linear_data", "for", "i", "in", "range", "expected_k", "1", "1", "1", "kws", "self", "default_kws", "copy", "kws", "k_depth", "proportion", "p", "cat", "_lvplotter", "kws", "calc_edges", "calc_k", "p", "_lv_box_ends", "linear_data", "npt", "assert_array_equal", "expected_edges", "calc_edges", "assert", "expected_k", "calc_k"], "doc_len": 61}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_ends_correct_trustworthy", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_ends_correct_trustworthy", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_ends_correct_trustworthy(self, n, exp_k):\n\n        linear_data = np.arange(n)\n        kws = self.default_kws.copy()\n        kws[\"k_depth\"] = \"trustworthy\"\n        p = cat._LVPlotter(**kws)\n        _, calc_k = p._lv_box_ends(linear_data)\n\n        assert exp_k == calc_k\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_ends_correct_trustworthy", "self", "n", "exp_k", "linear_data", "np", "arange", "n", "kws", "self", "default_kws", "copy", "kws", "k_depth", "trustworthy", "p", "cat", "_lvplotter", "kws", "_", "calc_k", "p", "_lv_box_ends", "linear_data", "assert", "exp_k", "calc_k"], "doc_len": 32}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_outliers", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_outliers", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_outliers(self):\n\n        n = 100\n        outlier_data = np.append(np.arange(n - 1), 2 * n)\n        expected_k = max(int(np.log2(n)) - 3, 1)\n        expected_edges = [self.edge_calc(i, outlier_data)\n                          for i in range(expected_k + 1, 1, -1)]\n\n        p = cat._LVPlotter(**self.default_kws)\n        calc_edges, calc_k = p._lv_box_ends(outlier_data)\n\n        npt.assert_array_equal(calc_edges, expected_edges)\n        assert calc_k == expected_k\n\n        out_calc = p._lv_outliers(outlier_data, calc_k)\n        out_exp = p._lv_outliers(outlier_data, expected_k)\n\n        npt.assert_equal(out_calc, out_exp)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_outliers", "self", "n", "100", "outlier_data", "np", "append", "np", "arange", "n", "1", "2", "n", "expected_k", "max", "int", "np", "log2", "n", "3", "1", "expected_edges", "self", "edge_calc", "i", "outlier_data", "for", "i", "in", "range", "expected_k", "1", "1", "1", "p", "cat", "_lvplotter", "self", "default_kws", "calc_edges", "calc_k", "p", "_lv_box_ends", "outlier_data", "npt", "assert_array_equal", "calc_edges", "expected_edges", "assert", "calc_k", "expected_k", "out_calc", "p", "_lv_outliers", "outlier_data", "calc_k", "out_exp", "p", "_lv_outliers", "outlier_data", "expected_k", "npt", "assert_equal", "out_calc", "out_exp"], "doc_len": 70}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_showfliers", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_showfliers", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_showfliers(self):\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", data=self.df, k_depth=\"proportion\",\n                           showfliers=True)\n        ax_collections = list(filter(self.ispath, ax.collections))\n        for c in ax_collections:\n            assert len(c.get_offsets()) == 2\n\n        # Test that all data points are in the plot\n        assert ax.get_ylim()[0] < self.df[\"y\"].min()\n        assert ax.get_ylim()[1] > self.df[\"y\"].max()\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", data=self.df, showfliers=False)\n        assert len(list(filter(self.ispath, ax.collections))) == 0\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_showfliers", "self", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "k_depth", "proportion", "showfliers", "true", "ax_collections", "list", "filter", "self", "ispath", "ax", "collections", "for", "c", "in", "ax_collections", "assert", "len", "c", "get_offsets", "2", "test", "that", "all", "data", "points", "are", "in", "the", "plot", "assert", "ax", "get_ylim", "0", "self", "df", "y", "min", "assert", "ax", "get_ylim", "1", "self", "df", "y", "max", "plt", "close", "all", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "showfliers", "false", "assert", "len", "list", "filter", "self", "ispath", "ax", "collections", "0", "plt", "close", "all"], "doc_len": 89}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_invalid_depths", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_invalid_depths", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_invalid_depths(self):\n\n        kws = self.default_kws.copy()\n\n        # Make sure illegal depth raises\n        kws[\"k_depth\"] = \"nosuchdepth\"\n        with pytest.raises(ValueError):\n            cat._LVPlotter(**kws)\n\n        # Make sure illegal outlier_prop raises\n        kws[\"k_depth\"] = \"proportion\"\n        for p in (-13, 37):\n            kws[\"outlier_prop\"] = p\n            with pytest.raises(ValueError):\n                cat._LVPlotter(**kws)\n\n        kws[\"k_depth\"] = \"trustworthy\"\n        for alpha in (-13, 37):\n            kws[\"trust_alpha\"] = alpha\n            with pytest.raises(ValueError):\n                cat._LVPlotter(**kws)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_invalid_depths", "self", "kws", "self", "default_kws", "copy", "make", "sure", "illegal", "depth", "raises", "kws", "k_depth", "nosuchdepth", "with", "pytest", "raises", "valueerror", "cat", "_lvplotter", "kws", "make", "sure", "illegal", "outlier_prop", "raises", "kws", "k_depth", "proportion", "for", "p", "in", "13", "37", "kws", "outlier_prop", "p", "with", "pytest", "raises", "valueerror", "cat", "_lvplotter", "kws", "kws", "k_depth", "trustworthy", "for", "alpha", "in", "13", "37", "kws", "trust_alpha", "alpha", "with", "pytest", "raises", "valueerror", "cat", "_lvplotter", "kws"], "doc_len": 67}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_valid_depths", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_valid_depths", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_valid_depths(self, power):\n\n        x = np.random.standard_t(10, 2 ** power)\n\n        valid_depths = [\"proportion\", \"tukey\", \"trustworthy\", \"full\"]\n        kws = self.default_kws.copy()\n\n        for depth in valid_depths + [4]:\n            kws[\"k_depth\"] = depth\n            box_ends, k = cat._LVPlotter(**kws)._lv_box_ends(x)\n\n            if depth == \"full\":\n                assert k == int(np.log2(len(x))) + 1\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_valid_depths", "self", "power", "x", "np", "random", "standard_t", "10", "2", "power", "valid_depths", "proportion", "tukey", "trustworthy", "full", "kws", "self", "default_kws", "copy", "for", "depth", "in", "valid_depths", "4", "kws", "k_depth", "depth", "box_ends", "k", "cat", "_lvplotter", "kws", "_lv_box_ends", "x", "if", "depth", "full", "assert", "k", "int", "np", "log2", "len", "x", "1"], "doc_len": 50}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_valid_scales", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_valid_scales", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_valid_scales(self):\n\n        valid_scales = [\"linear\", \"exponential\", \"area\"]\n        kws = self.default_kws.copy()\n\n        for scale in valid_scales + [\"unknown_scale\"]:\n            kws[\"scale\"] = scale\n            if scale not in valid_scales:\n                with pytest.raises(ValueError):\n                    cat._LVPlotter(**kws)\n            else:\n                cat._LVPlotter(**kws)\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_valid_scales", "self", "valid_scales", "linear", "exponential", "area", "kws", "self", "default_kws", "copy", "for", "scale", "in", "valid_scales", "unknown_scale", "kws", "scale", "scale", "if", "scale", "not", "in", "valid_scales", "with", "pytest", "raises", "valueerror", "cat", "_lvplotter", "kws", "else", "cat", "_lvplotter", "kws"], "doc_len": 39}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_hue_offsets", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_hue_offsets", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_hue_offsets(self):\n\n        p = cat._LVPlotter(**self.default_kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.2, .2])\n\n        kws = self.default_kws.copy()\n        kws[\"width\"] = .6\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"g\", \"y\", hue=\"h\", data=self.df)\n        npt.assert_array_equal(p.hue_offsets, [-.15, .15])\n\n        p = cat._LVPlotter(**kws)\n        p.establish_variables(\"h\", \"y\", \"g\", data=self.df)\n        npt.assert_array_almost_equal(p.hue_offsets, [-.2, 0, .2])\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_hue_offsets", "self", "p", "cat", "_lvplotter", "self", "default_kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "npt", "assert_array_equal", "p", "hue_offsets", "2", "2", "kws", "self", "default_kws", "copy", "kws", "width", "6", "p", "cat", "_lvplotter", "kws", "p", "establish_variables", "g", "y", "hue", "h", "data", "self", "df", "npt", "assert_array_equal", "p", "hue_offsets", "15", "15", "p", "cat", "_lvplotter", "kws", "p", "establish_variables", "h", "y", "g", "data", "self", "df", "npt", "assert_array_almost_equal", "p", "hue_offsets", "2", "0", "2"], "doc_len": 72}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_axes_data", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_axes_data", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_axes_data(self):\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        assert len(list(patches)) == 3\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        patches = filter(self.ispatch, ax.collections)\n        assert len(list(patches)) == 6\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_axes_data", "self", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "patches", "filter", "self", "ispatch", "ax", "collections", "assert", "len", "list", "patches", "3", "plt", "close", "all", "ax", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "patches", "filter", "self", "ispatch", "ax", "collections", "assert", "len", "list", "patches", "6", "plt", "close", "all"], "doc_len": 57}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_colors", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_colors", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_colors(self):\n\n        pal = palettes.color_palette()\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i])\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(\n            x=\"g\", y=\"y\", hue=\"h\", data=self.df, saturation=1, showfliers=False\n        )\n        ax.figure.canvas.draw()\n        for i, box in enumerate(ax.collections):\n            assert same_color(box.get_facecolor()[0], pal[i % 2])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_colors", "self", "pal", "palettes", "color_palette", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "saturation", "1", "showfliers", "false", "ax", "figure", "canvas", "draw", "for", "i", "box", "in", "enumerate", "ax", "collections", "assert", "same_color", "box", "get_facecolor", "0", "pal", "i", "plt", "close", "all", "ax", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "saturation", "1", "showfliers", "false", "ax", "figure", "canvas", "draw", "for", "i", "box", "in", "enumerate", "ax", "collections", "assert", "same_color", "box", "get_facecolor", "0", "pal", "i", "2", "plt", "close", "all"], "doc_len": 83}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_draw_missing_boxes", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_draw_missing_boxes", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_draw_missing_boxes(self):\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", data=self.df,\n                           order=[\"a\", \"b\", \"c\", \"d\"])\n\n        patches = filter(self.ispatch, ax.collections)\n        assert len(list(patches)) == 3\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_draw_missing_boxes", "self", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "order", "a", "b", "c", "d", "patches", "filter", "self", "ispatch", "ax", "collections", "assert", "len", "list", "patches", "3", "plt", "close", "all"], "doc_len": 36}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_unaligned_index", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_unaligned_index", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_unaligned_index(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        cat.boxenplot(x=self.g, y=self.y, ax=ax1)\n        cat.boxenplot(x=self.g, y=self.y_perm, ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert np.array_equal(l1.get_xydata(), l2.get_xydata())\n\n        f, (ax1, ax2) = plt.subplots(2)\n        hue_order = self.h.unique()\n        cat.boxenplot(x=self.g, y=self.y, hue=self.h,\n                      hue_order=hue_order, ax=ax1)\n        cat.boxenplot(x=self.g, y=self.y_perm, hue=self.h,\n                      hue_order=hue_order, ax=ax2)\n        for l1, l2 in zip(ax1.lines, ax2.lines):\n            assert np.array_equal(l1.get_xydata(), l2.get_xydata())\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_unaligned_index", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "cat", "boxenplot", "x", "self", "g", "y", "self", "y", "ax", "ax1", "cat", "boxenplot", "x", "self", "g", "y", "self", "y_perm", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "np", "array_equal", "l1", "get_xydata", "l2", "get_xydata", "f", "ax1", "ax2", "plt", "subplots", "2", "hue_order", "self", "h", "unique", "cat", "boxenplot", "x", "self", "g", "y", "self", "y", "hue", "self", "h", "hue_order", "hue_order", "ax", "ax1", "cat", "boxenplot", "x", "self", "g", "y", "self", "y_perm", "hue", "self", "h", "hue_order", "hue_order", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "ax2", "lines", "assert", "np", "array_equal", "l1", "get_xydata", "l2", "get_xydata"], "doc_len": 105}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_missing_data", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_missing_data", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_missing_data(self):\n\n        x = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"d\", \"d\"]\n        h = [\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\"]\n        y = self.rs.randn(8)\n        y[-2:] = np.nan\n\n        ax = cat.boxenplot(x=x, y=y)\n        assert len(ax.lines) == 3\n\n        plt.close(\"all\")\n\n        y[-1] = 0\n        ax = cat.boxenplot(x=x, y=y, hue=h)\n        assert len(ax.lines) == 7\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_missing_data", "self", "x", "a", "a", "b", "b", "c", "c", "d", "d", "h", "x", "y", "x", "y", "x", "y", "x", "y", "y", "self", "rs", "randn", "8", "y", "2", "np", "nan", "ax", "cat", "boxenplot", "x", "x", "y", "y", "assert", "len", "ax", "lines", "3", "plt", "close", "all", "y", "1", "0", "ax", "cat", "boxenplot", "x", "x", "y", "y", "hue", "h", "assert", "len", "ax", "lines", "7", "plt", "close", "all"], "doc_len": 69}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_boxenplots", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_boxenplots", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_boxenplots(self):\n\n        # Smoke test the high level boxenplot options\n\n        cat.boxenplot(x=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxenplot(y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"g\", y=\"y\", data=self.df)\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"y\", y=\"g\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        plt.close(\"all\")\n\n        for scale in (\"linear\", \"area\", \"exponential\"):\n            cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", scale=scale, data=self.df)\n            plt.close(\"all\")\n\n        for depth in (\"proportion\", \"tukey\", \"trustworthy\"):\n            cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", k_depth=depth, data=self.df)\n            plt.close(\"all\")\n\n        order = list(\"nabc\")\n        cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", order=order, data=self.df)\n        plt.close(\"all\")\n\n        order = list(\"omn\")\n        cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", hue_order=order, data=self.df)\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"y\", y=\"g\", hue=\"h\", data=self.df, orient=\"h\")\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"y\", y=\"g\", hue=\"h\", data=self.df, orient=\"h\",\n                      palette=\"Set2\")\n        plt.close(\"all\")\n\n        cat.boxenplot(x=\"y\", y=\"g\", hue=\"h\", data=self.df,\n                      orient=\"h\", color=\"b\")\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_boxenplots", "self", "smoke", "test", "the", "high", "level", "boxenplot", "options", "cat", "boxenplot", "x", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxenplot", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "plt", "close", "all", "cat", "boxenplot", "x", "y", "y", "g", "data", "self", "df", "orient", "h", "plt", "close", "all", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "plt", "close", "all", "for", "scale", "in", "linear", "area", "exponential", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "scale", "scale", "data", "self", "df", "plt", "close", "all", "for", "depth", "in", "proportion", "tukey", "trustworthy", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "k_depth", "depth", "data", "self", "df", "plt", "close", "all", "order", "list", "nabc", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "order", "order", "data", "self", "df", "plt", "close", "all", "order", "list", "omn", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "hue_order", "order", "data", "self", "df", "plt", "close", "all", "cat", "boxenplot", "x", "y", "y", "g", "hue", "h", "data", "self", "df", "orient", "h", "plt", "close", "all", "cat", "boxenplot", "x", "y", "y", "g", "hue", "h", "data", "self", "df", "orient", "h", "palette", "set2", "plt", "close", "all", "cat", "boxenplot", "x", "y", "y", "g", "hue", "h", "data", "self", "df", "orient", "h", "color", "b", "plt", "close", "all"], "doc_len": 208}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_axes_annotation", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_axes_annotation", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_axes_annotation(self):\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", data=self.df)\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        assert ax.get_xlim() == (-.5, 2.5)\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n        assert ax.get_xlabel() == \"g\"\n        assert ax.get_ylabel() == \"y\"\n        npt.assert_array_equal(ax.get_xticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_xticklabels()],\n                               [\"a\", \"b\", \"c\"])\n        npt.assert_array_equal([l.get_text() for l in ax.legend_.get_texts()],\n                               [\"m\", \"n\"])\n\n        plt.close(\"all\")\n\n        ax = cat.boxenplot(x=\"y\", y=\"g\", data=self.df, orient=\"h\")\n        assert ax.get_xlabel() == \"y\"\n        assert ax.get_ylabel() == \"g\"\n        assert ax.get_ylim() == (2.5, -.5)\n        npt.assert_array_equal(ax.get_yticks(), [0, 1, 2])\n        npt.assert_array_equal([l.get_text() for l in ax.get_yticklabels()],\n                               [\"a\", \"b\", \"c\"])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_axes_annotation", "self", "ax", "cat", "boxenplot", "x", "g", "y", "y", "data", "self", "df", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "assert", "ax", "get_xlim", "5", "2", "5", "npt", "assert_array_equal", "ax", "get_xticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "a", "b", "c", "plt", "close", "all", "ax", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "assert", "ax", "get_xlabel", "g", "assert", "ax", "get_ylabel", "y", "npt", "assert_array_equal", "ax", "get_xticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "a", "b", "c", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "legend_", "get_texts", "m", "n", "plt", "close", "all", "ax", "cat", "boxenplot", "x", "y", "y", "g", "data", "self", "df", "orient", "h", "assert", "ax", "get_xlabel", "y", "assert", "ax", "get_ylabel", "g", "assert", "ax", "get_ylim", "2", "5", "5", "npt", "assert_array_equal", "ax", "get_yticks", "0", "1", "2", "npt", "assert_array_equal", "l", "get_text", "for", "l", "in", "ax", "get_yticklabels", "a", "b", "c", "plt", "close", "all"], "doc_len": 155}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_legend_titlesize", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_legend_titlesize", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_legend_titlesize(self, size):\n\n        rc_ctx = {\"legend.title_fontsize\": size}\n        exp = mpl.font_manager.FontProperties(size=size).get_size()\n\n        with plt.rc_context(rc=rc_ctx):\n            ax = cat.boxenplot(x=\"g\", y=\"y\", hue=\"h\", data=self.df)\n            obs = ax.get_legend().get_title().get_fontproperties().get_size()\n            assert obs == exp\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_legend_titlesize", "self", "size", "rc_ctx", "legend", "title_fontsize", "size", "exp", "mpl", "font_manager", "fontproperties", "size", "size", "get_size", "with", "plt", "rc_context", "rc", "rc_ctx", "ax", "cat", "boxenplot", "x", "g", "y", "y", "hue", "h", "data", "self", "df", "obs", "ax", "get_legend", "get_title", "get_fontproperties", "get_size", "assert", "obs", "exp", "plt", "close", "all"], "doc_len": 48}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_Float64_input", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_Float64_input", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_Float64_input(self):\n        data = pd.DataFrame(\n            {\"x\": np.random.choice([\"a\", \"b\"], 20), \"y\": np.random.random(20)}\n        )\n        data['y'] = data['y'].astype(pd.Float64Dtype())\n        _ = cat.boxenplot(x=\"x\", y=\"y\", data=data)\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_float64_input", "self", "data", "pd", "dataframe", "x", "np", "random", "choice", "a", "b", "20", "y", "np", "random", "random", "20", "data", "y", "data", "y", "astype", "pd", "float64dtype", "_", "cat", "boxenplot", "x", "x", "y", "y", "data", "data", "plt", "close", "all"], "doc_len": 41}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_line_kws", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_line_kws", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_line_kws(self):\n        line_kws = {'linewidth': 5, 'color': 'purple',\n                    'linestyle': '-.'}\n\n        ax = cat.boxenplot(data=self.df, y='y', line_kws=line_kws)\n\n        median_line = ax.lines[0]\n\n        assert median_line.get_linewidth() == line_kws['linewidth']\n        assert median_line.get_linestyle() == line_kws['linestyle']\n        assert median_line.get_color() == line_kws['color']\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_line_kws", "self", "line_kws", "linewidth", "5", "color", "purple", "linestyle", "ax", "cat", "boxenplot", "data", "self", "df", "y", "y", "line_kws", "line_kws", "median_line", "ax", "lines", "0", "assert", "median_line", "get_linewidth", "line_kws", "linewidth", "assert", "median_line", "get_linestyle", "line_kws", "linestyle", "assert", "median_line", "get_color", "line_kws", "color", "plt", "close", "all"], "doc_len": 45}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_flier_kws", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_flier_kws", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_flier_kws(self):\n        flier_kws = {\n            'marker': 'v',\n            'color': np.array([[1, 0, 0, 1]]),\n            's': 5,\n        }\n\n        ax = cat.boxenplot(data=self.df, y='y', x='g', flier_kws=flier_kws)\n\n        outliers_scatter = ax.findobj(mpl.collections.PathCollection)[0]\n\n        # The number of vertices for a triangle is 3, the length of Path\n        # collection objects is defined as n + 1 vertices.\n        assert len(outliers_scatter.get_paths()[0]) == 4\n        assert len(outliers_scatter.get_paths()[-1]) == 4\n\n        assert (outliers_scatter.get_facecolor() == flier_kws['color']).all()\n\n        assert np.unique(outliers_scatter.get_sizes()) == flier_kws['s']\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_flier_kws", "self", "flier_kws", "marker", "v", "color", "np", "array", "1", "0", "0", "1", "s", "5", "ax", "cat", "boxenplot", "data", "self", "df", "y", "y", "x", "g", "flier_kws", "flier_kws", "outliers_scatter", "ax", "findobj", "mpl", "collections", "pathcollection", "0", "the", "number", "of", "vertices", "for", "a", "triangle", "is", "3", "the", "length", "of", "path", "collection", "objects", "is", "defined", "as", "n", "1", "vertices", "assert", "len", "outliers_scatter", "get_paths", "0", "4", "assert", "len", "outliers_scatter", "get_paths", "1", "4", "assert", "outliers_scatter", "get_facecolor", "flier_kws", "color", "all", "assert", "np", "unique", "outliers_scatter", "get_sizes", "flier_kws", "s", "plt", "close", "all"], "doc_len": 87}
{"doc_id": "tests/test_categorical.py::TestBoxenPlotter.test_box_kws", "file_path": "tests/test_categorical.py", "class_name": "TestBoxenPlotter", "func_name": "test_box_kws", "text": "文件路径: tests/test_categorical.py, 类名: TestBoxenPlotter\n    def test_box_kws(self):\n\n        box_kws = {'linewidth': 5, 'edgecolor': np.array([[0, 1, 0, 1]])}\n\n        ax = cat.boxenplot(data=self.df, y='y', x='g',\n                           box_kws=box_kws)\n\n        boxes = ax.findobj(mpl.collections.PatchCollection)[0]\n\n        # The number of vertices for a triangle is 3, the length of Path\n        # collection objects is defined as n + 1 vertices.\n        assert len(boxes.get_paths()[0]) == 5\n        assert len(boxes.get_paths()[-1]) == 5\n\n        assert np.unique(boxes.get_linewidth() == box_kws['linewidth'])\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_categorical", "py", "testboxenplotter", "def", "test_box_kws", "self", "box_kws", "linewidth", "5", "edgecolor", "np", "array", "0", "1", "0", "1", "ax", "cat", "boxenplot", "data", "self", "df", "y", "y", "x", "g", "box_kws", "box_kws", "boxes", "ax", "findobj", "mpl", "collections", "patchcollection", "0", "the", "number", "of", "vertices", "for", "a", "triangle", "is", "3", "the", "length", "of", "path", "collection", "objects", "is", "defined", "as", "n", "1", "vertices", "assert", "len", "boxes", "get_paths", "0", "5", "assert", "len", "boxes", "get_paths", "1", "5", "assert", "np", "unique", "boxes", "get_linewidth", "box_kws", "linewidth", "plt", "close", "all"], "doc_len": 79}
{"doc_id": "tests/test_categorical.py::TestBeeswarm.test_could_overlap", "file_path": "tests/test_categorical.py", "class_name": "TestBeeswarm", "func_name": "test_could_overlap", "text": "文件路径: tests/test_categorical.py, 类名: TestBeeswarm\n    def test_could_overlap(self):\n\n        p = Beeswarm()\n        neighbors = p.could_overlap(\n            (1, 1, .5),\n            [(0, 0, .5),\n             (1, .1, .2),\n             (.5, .5, .5)]\n        )\n        assert_array_equal(neighbors, [(.5, .5, .5)])\n", "tokens": ["tests", "test_categorical", "py", "testbeeswarm", "def", "test_could_overlap", "self", "p", "beeswarm", "neighbors", "p", "could_overlap", "1", "1", "5", "0", "0", "5", "1", "1", "2", "5", "5", "5", "assert_array_equal", "neighbors", "5", "5", "5"], "doc_len": 29}
{"doc_id": "tests/test_categorical.py::TestBeeswarm.test_position_candidates", "file_path": "tests/test_categorical.py", "class_name": "TestBeeswarm", "func_name": "test_position_candidates", "text": "文件路径: tests/test_categorical.py, 类名: TestBeeswarm\n    def test_position_candidates(self):\n\n        p = Beeswarm()\n        xy_i = (0, 1, .5)\n        neighbors = [(0, 1, .5), (0, 1.5, .5)]\n        candidates = p.position_candidates(xy_i, neighbors)\n        dx1 = 1.05\n        dx2 = np.sqrt(1 - .5 ** 2) * 1.05\n        assert_array_equal(\n            candidates,\n            [(0, 1, .5), (-dx1, 1, .5), (dx1, 1, .5), (dx2, 1, .5), (-dx2, 1, .5)]\n        )\n", "tokens": ["tests", "test_categorical", "py", "testbeeswarm", "def", "test_position_candidates", "self", "p", "beeswarm", "xy_i", "0", "1", "5", "neighbors", "0", "1", "5", "0", "1", "5", "5", "candidates", "p", "position_candidates", "xy_i", "neighbors", "dx1", "1", "05", "dx2", "np", "sqrt", "1", "5", "2", "1", "05", "assert_array_equal", "candidates", "0", "1", "5", "dx1", "1", "5", "dx1", "1", "5", "dx2", "1", "5", "dx2", "1", "5"], "doc_len": 54}
{"doc_id": "tests/test_categorical.py::TestBeeswarm.test_find_first_non_overlapping_candidate", "file_path": "tests/test_categorical.py", "class_name": "TestBeeswarm", "func_name": "test_find_first_non_overlapping_candidate", "text": "文件路径: tests/test_categorical.py, 类名: TestBeeswarm\n    def test_find_first_non_overlapping_candidate(self):\n\n        p = Beeswarm()\n        candidates = [(.5, 1, .5), (1, 1, .5), (1.5, 1, .5)]\n        neighbors = np.array([(0, 1, .5)])\n\n        first = p.first_non_overlapping_candidate(candidates, neighbors)\n        assert_array_equal(first, (1, 1, .5))\n", "tokens": ["tests", "test_categorical", "py", "testbeeswarm", "def", "test_find_first_non_overlapping_candidate", "self", "p", "beeswarm", "candidates", "5", "1", "5", "1", "1", "5", "1", "5", "1", "5", "neighbors", "np", "array", "0", "1", "5", "first", "p", "first_non_overlapping_candidate", "candidates", "neighbors", "assert_array_equal", "first", "1", "1", "5"], "doc_len": 36}
{"doc_id": "tests/test_categorical.py::TestBeeswarm.test_beeswarm", "file_path": "tests/test_categorical.py", "class_name": "TestBeeswarm", "func_name": "test_beeswarm", "text": "文件路径: tests/test_categorical.py, 类名: TestBeeswarm\n    def test_beeswarm(self, long_df):\n\n        p = Beeswarm()\n        data = long_df[\"y\"]\n        d = data.diff().mean() * 1.5\n        x = np.zeros(data.size)\n        y = np.sort(data)\n        r = np.full_like(y, d)\n        orig_xyr = np.c_[x, y, r]\n        swarm = p.beeswarm(orig_xyr)[:, :2]\n        dmat = np.sqrt(np.sum(np.square(swarm[:, np.newaxis] - swarm), axis=-1))\n        triu = dmat[np.triu_indices_from(dmat, 1)]\n        assert_array_less(d, triu)\n        assert_array_equal(y, swarm[:, 1])\n", "tokens": ["tests", "test_categorical", "py", "testbeeswarm", "def", "test_beeswarm", "self", "long_df", "p", "beeswarm", "data", "long_df", "y", "d", "data", "diff", "mean", "1", "5", "x", "np", "zeros", "data", "size", "y", "np", "sort", "data", "r", "np", "full_like", "y", "d", "orig_xyr", "np", "c_", "x", "y", "r", "swarm", "p", "beeswarm", "orig_xyr", "2", "dmat", "np", "sqrt", "np", "sum", "np", "square", "swarm", "np", "newaxis", "swarm", "axis", "1", "triu", "dmat", "np", "triu_indices_from", "dmat", "1", "assert_array_less", "d", "triu", "assert_array_equal", "y", "swarm", "1"], "doc_len": 70}
{"doc_id": "tests/test_categorical.py::TestBeeswarm.test_add_gutters", "file_path": "tests/test_categorical.py", "class_name": "TestBeeswarm", "func_name": "test_add_gutters", "text": "文件路径: tests/test_categorical.py, 类名: TestBeeswarm\n    def test_add_gutters(self):\n\n        p = Beeswarm(width=1)\n\n        points = np.zeros(10)\n        assert_array_equal(points, p.add_gutters(points, 0))\n\n        points = np.array([0, -1, .4, .8])\n        msg = r\"50.0% of the points cannot be placed.+$\"\n        with pytest.warns(UserWarning, match=msg):\n            new_points = p.add_gutters(points, 0)\n        assert_array_equal(new_points, np.array([0, -.5, .4, .5]))\n", "tokens": ["tests", "test_categorical", "py", "testbeeswarm", "def", "test_add_gutters", "self", "p", "beeswarm", "width", "1", "points", "np", "zeros", "10", "assert_array_equal", "points", "p", "add_gutters", "points", "0", "points", "np", "array", "0", "1", "4", "8", "msg", "r", "50", "0", "of", "the", "points", "cannot", "be", "placed", "with", "pytest", "warns", "userwarning", "match", "msg", "new_points", "p", "add_gutters", "points", "0", "assert_array_equal", "new_points", "np", "array", "0", "5", "4", "5"], "doc_len": 57}
{"doc_id": "tests/test_core.py::long_variables", "file_path": "tests/test_core.py", "class_name": null, "func_name": "long_variables", "text": "文件路径: tests/test_core.py\ndef long_variables(request):\n    return request.param\n", "tokens": ["tests", "test_core", "py", "def", "long_variables", "request", "return", "request", "param"], "doc_len": 9}
{"doc_id": "tests/test_core.py::TestSemanticMapping.test_call_lookup", "file_path": "tests/test_core.py", "class_name": "TestSemanticMapping", "func_name": "test_call_lookup", "text": "文件路径: tests/test_core.py, 类名: TestSemanticMapping\n    def test_call_lookup(self):\n\n        m = SemanticMapping(VectorPlotter())\n        lookup_table = dict(zip(\"abc\", (1, 2, 3)))\n        m.lookup_table = lookup_table\n        for key, val in lookup_table.items():\n            assert m(key) == val\n", "tokens": ["tests", "test_core", "py", "testsemanticmapping", "def", "test_call_lookup", "self", "m", "semanticmapping", "vectorplotter", "lookup_table", "dict", "zip", "abc", "1", "2", "3", "m", "lookup_table", "lookup_table", "for", "key", "val", "in", "lookup_table", "items", "assert", "m", "key", "val"], "doc_len": 30}
{"doc_id": "tests/test_core.py::TestHueMapping.test_init_from_map", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_init_from_map", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_init_from_map(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\")\n        )\n        palette = \"Set2\"\n        p = HueMapping.map(p_orig, palette=palette)\n        assert p is p_orig\n        assert isinstance(p._hue_map, HueMapping)\n        assert p._hue_map.palette == palette\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_init_from_map", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "palette", "set2", "p", "huemapping", "map", "p_orig", "palette", "palette", "assert", "p", "is", "p_orig", "assert", "isinstance", "p", "_hue_map", "huemapping", "assert", "p", "_hue_map", "palette", "palette"], "doc_len": 42}
{"doc_id": "tests/test_core.py::TestHueMapping.test_plotter_default_init", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_plotter_default_init", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_plotter_default_init(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n        assert isinstance(p._hue_map, HueMapping)\n        assert p._hue_map.map_type is None\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n        )\n        assert isinstance(p._hue_map, HueMapping)\n        assert p._hue_map.map_type == p.var_types[\"hue\"]\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_plotter_default_init", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "assert", "isinstance", "p", "_hue_map", "huemapping", "assert", "p", "_hue_map", "map_type", "is", "none", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "assert", "isinstance", "p", "_hue_map", "huemapping", "assert", "p", "_hue_map", "map_type", "p", "var_types", "hue"], "doc_len": 53}
{"doc_id": "tests/test_core.py::TestHueMapping.test_plotter_reinit", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_plotter_reinit", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_plotter_reinit(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n        )\n        palette = \"muted\"\n        hue_order = [\"b\", \"a\", \"c\"]\n        p = p_orig.map_hue(palette=palette, order=hue_order)\n        assert p is p_orig\n        assert p._hue_map.palette == palette\n        assert p._hue_map.levels == hue_order\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_plotter_reinit", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "palette", "muted", "hue_order", "b", "a", "c", "p", "p_orig", "map_hue", "palette", "palette", "order", "hue_order", "assert", "p", "is", "p_orig", "assert", "p", "_hue_map", "palette", "palette", "assert", "p", "_hue_map", "levels", "hue_order"], "doc_len": 47}
{"doc_id": "tests/test_core.py::TestHueMapping.test_hue_map_null", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_hue_map_null", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_hue_map_null(self, flat_series, null_series):\n\n        p = VectorPlotter(variables=dict(x=flat_series, hue=null_series))\n        m = HueMapping(p)\n        assert m.levels is None\n        assert m.map_type is None\n        assert m.palette is None\n        assert m.cmap is None\n        assert m.norm is None\n        assert m.lookup_table is None\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_hue_map_null", "self", "flat_series", "null_series", "p", "vectorplotter", "variables", "dict", "x", "flat_series", "hue", "null_series", "m", "huemapping", "p", "assert", "m", "levels", "is", "none", "assert", "m", "map_type", "is", "none", "assert", "m", "palette", "is", "none", "assert", "m", "cmap", "is", "none", "assert", "m", "norm", "is", "none", "assert", "m", "lookup_table", "is", "none"], "doc_len": 50}
{"doc_id": "tests/test_core.py::TestHueMapping.test_hue_map_categorical", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_hue_map_categorical", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_hue_map_categorical(self, wide_df, long_df):\n\n        p = VectorPlotter(data=wide_df)\n        m = HueMapping(p)\n        assert m.levels == wide_df.columns.to_list()\n        assert m.map_type == \"categorical\"\n        assert m.cmap is None\n\n        # Test named palette\n        palette = \"Blues\"\n        expected_colors = color_palette(palette, wide_df.shape[1])\n        expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n        m = HueMapping(p, palette=palette)\n        assert m.palette == \"Blues\"\n        assert m.lookup_table == expected_lookup_table\n\n        # Test list palette\n        palette = color_palette(\"Reds\", wide_df.shape[1])\n        expected_lookup_table = dict(zip(wide_df.columns, palette))\n        m = HueMapping(p, palette=palette)\n        assert m.palette == palette\n        assert m.lookup_table == expected_lookup_table\n\n        # Test dict palette\n        colors = color_palette(\"Set1\", 8)\n        palette = dict(zip(wide_df.columns, colors))\n        m = HueMapping(p, palette=palette)\n        assert m.palette == palette\n        assert m.lookup_table == palette\n\n        # Test dict with missing keys\n        palette = dict(zip(wide_df.columns[:-1], colors))\n        with pytest.raises(ValueError):\n            HueMapping(p, palette=palette)\n\n        # Test list with wrong number of colors\n        palette = colors[:-1]\n        with pytest.warns(UserWarning):\n            HueMapping(p, palette=palette)\n\n        # Test hue order\n        hue_order = [\"a\", \"c\", \"d\"]\n        m = HueMapping(p, order=hue_order)\n        assert m.levels == hue_order\n\n        # Test long data\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\", hue=\"a\"))\n        m = HueMapping(p)\n        assert m.levels == categorical_order(long_df[\"a\"])\n        assert m.map_type == \"categorical\"\n        assert m.cmap is None\n\n        # Test default palette\n        m = HueMapping(p)\n        hue_levels = categorical_order(long_df[\"a\"])\n        expected_colors = color_palette(n_colors=len(hue_levels))\n        expected_lookup_table = dict(zip(hue_levels, expected_colors))\n        assert m.lookup_table == expected_lookup_table\n\n        # Test missing data\n        m = HueMapping(p)\n        assert m(np.nan) == (0, 0, 0, 0)\n\n        # Test default palette with many levels\n        x = y = np.arange(26)\n        hue = pd.Series(list(\"abcdefghijklmnopqrstuvwxyz\"))\n        p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n        m = HueMapping(p)\n        expected_colors = color_palette(\"husl\", n_colors=len(hue))\n        expected_lookup_table = dict(zip(hue, expected_colors))\n        assert m.lookup_table == expected_lookup_table\n\n        # Test binary data\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\", hue=\"c\"))\n        m = HueMapping(p)\n        assert m.levels == [0, 1]\n        assert m.map_type == \"categorical\"\n\n        for val in [0, 1]:\n            p = VectorPlotter(\n                data=long_df[long_df[\"c\"] == val],\n                variables=dict(x=\"x\", y=\"y\", hue=\"c\"),\n            )\n            m = HueMapping(p)\n            assert m.levels == [val]\n            assert m.map_type == \"categorical\"\n\n        # Test Timestamp data\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\", hue=\"t\"))\n        m = HueMapping(p)\n        assert m.levels == [pd.Timestamp(t) for t in long_df[\"t\"].unique()]\n        assert m.map_type == \"datetime\"\n\n        # Test explicit categories\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", hue=\"a_cat\"))\n        m = HueMapping(p)\n        assert m.levels == long_df[\"a_cat\"].cat.categories.to_list()\n        assert m.map_type == \"categorical\"\n\n        # Test numeric data with category type\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"s_cat\")\n        )\n        m = HueMapping(p)\n        assert m.levels == categorical_order(long_df[\"s_cat\"])\n        assert m.map_type == \"categorical\"\n        assert m.cmap is None\n\n        # Test categorical palette specified for numeric data\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"s\")\n        )\n        palette = \"deep\"\n        levels = categorical_order(long_df[\"s\"])\n        expected_colors = color_palette(palette, n_colors=len(levels))\n        expected_lookup_table = dict(zip(levels, expected_colors))\n        m = HueMapping(p, palette=palette)\n        assert m.lookup_table == expected_lookup_table\n        assert m.map_type == \"categorical\"\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_hue_map_categorical", "self", "wide_df", "long_df", "p", "vectorplotter", "data", "wide_df", "m", "huemapping", "p", "assert", "m", "levels", "wide_df", "columns", "to_list", "assert", "m", "map_type", "categorical", "assert", "m", "cmap", "is", "none", "test", "named", "palette", "palette", "blues", "expected_colors", "color_palette", "palette", "wide_df", "shape", "1", "expected_lookup_table", "dict", "zip", "wide_df", "columns", "expected_colors", "m", "huemapping", "p", "palette", "palette", "assert", "m", "palette", "blues", "assert", "m", "lookup_table", "expected_lookup_table", "test", "list", "palette", "palette", "color_palette", "reds", "wide_df", "shape", "1", "expected_lookup_table", "dict", "zip", "wide_df", "columns", "palette", "m", "huemapping", "p", "palette", "palette", "assert", "m", "palette", "palette", "assert", "m", "lookup_table", "expected_lookup_table", "test", "dict", "palette", "colors", "color_palette", "set1", "8", "palette", "dict", "zip", "wide_df", "columns", "colors", "m", "huemapping", "p", "palette", "palette", "assert", "m", "palette", "palette", "assert", "m", "lookup_table", "palette", "test", "dict", "with", "missing", "keys", "palette", "dict", "zip", "wide_df", "columns", "1", "colors", "with", "pytest", "raises", "valueerror", "huemapping", "p", "palette", "palette", "test", "list", "with", "wrong", "number", "of", "colors", "palette", "colors", "1", "with", "pytest", "warns", "userwarning", "huemapping", "p", "palette", "palette", "test", "hue", "order", "hue_order", "a", "c", "d", "m", "huemapping", "p", "order", "hue_order", "assert", "m", "levels", "hue_order", "test", "long", "data", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "m", "huemapping", "p", "assert", "m", "levels", "categorical_order", "long_df", "a", "assert", "m", "map_type", "categorical", "assert", "m", "cmap", "is", "none", "test", "default", "palette", "m", "huemapping", "p", "hue_levels", "categorical_order", "long_df", "a", "expected_colors", "color_palette", "n_colors", "len", "hue_levels", "expected_lookup_table", "dict", "zip", "hue_levels", "expected_colors", "assert", "m", "lookup_table", "expected_lookup_table", "test", "missing", "data", "m", "huemapping", "p", "assert", "m", "np", "nan", "0", "0", "0", "0", "test", "default", "palette", "with", "many", "levels", "x", "y", "np", "arange", "26", "hue", "pd", "series", "list", "abcdefghijklmnopqrstuvwxyz", "p", "vectorplotter", "variables", "dict", "x", "x", "y", "y", "hue", "hue", "m", "huemapping", "p", "expected_colors", "color_palette", "husl", "n_colors", "len", "hue", "expected_lookup_table", "dict", "zip", "hue", "expected_colors", "assert", "m", "lookup_table", "expected_lookup_table", "test", "binary", "data", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "c", "m", "huemapping", "p", "assert", "m", "levels", "0", "1", "assert", "m", "map_type", "categorical", "for", "val", "in", "0", "1", "p", "vectorplotter", "data", "long_df", "long_df", "c", "val", "variables", "dict", "x", "x", "y", "y", "hue", "c", "m", "huemapping", "p", "assert", "m", "levels", "val", "assert", "m", "map_type", "categorical", "test", "timestamp", "data", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "t", "m", "huemapping", "p", "assert", "m", "levels", "pd", "timestamp", "t", "for", "t", "in", "long_df", "t", "unique", "assert", "m", "map_type", "datetime", "test", "explicit", "categories", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "hue", "a_cat", "m", "huemapping", "p", "assert", "m", "levels", "long_df", "a_cat", "cat", "categories", "to_list", "assert", "m", "map_type", "categorical", "test", "numeric", "data", "with", "category", "type", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "s_cat", "m", "huemapping", "p", "assert", "m", "levels", "categorical_order", "long_df", "s_cat", "assert", "m", "map_type", "categorical", "assert", "m", "cmap", "is", "none", "test", "categorical", "palette", "specified", "for", "numeric", "data", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "s", "palette", "deep", "levels", "categorical_order", "long_df", "s", "expected_colors", "color_palette", "palette", "n_colors", "len", "levels", "expected_lookup_table", "dict", "zip", "levels", "expected_colors", "m", "huemapping", "p", "palette", "palette", "assert", "m", "lookup_table", "expected_lookup_table", "assert", "m", "map_type", "categorical"], "doc_len": 489}
{"doc_id": "tests/test_core.py::TestHueMapping.test_hue_map_numeric", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_hue_map_numeric", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_hue_map_numeric(self, long_df):\n\n        vals = np.concatenate([np.linspace(0, 1, 256), [-.1, 1.1, np.nan]])\n\n        # Test default colormap\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"s\")\n        )\n        hue_levels = list(np.sort(long_df[\"s\"].unique()))\n        m = HueMapping(p)\n        assert m.levels == hue_levels\n        assert m.map_type == \"numeric\"\n        assert m.cmap.name == \"seaborn_cubehelix\"\n\n        # Test named colormap\n        palette = \"Purples\"\n        m = HueMapping(p, palette=palette)\n        assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n\n        # Test colormap object\n        palette = get_colormap(\"Greens\")\n        m = HueMapping(p, palette=palette)\n        assert_array_equal(m.cmap(vals), palette(vals))\n\n        # Test cubehelix shorthand\n        palette = \"ch:2,0,light=.2\"\n        m = HueMapping(p, palette=palette)\n        assert isinstance(m.cmap, mpl.colors.ListedColormap)\n\n        # Test specified hue limits\n        hue_norm = 1, 4\n        m = HueMapping(p, norm=hue_norm)\n        assert isinstance(m.norm, mpl.colors.Normalize)\n        assert m.norm.vmin == hue_norm[0]\n        assert m.norm.vmax == hue_norm[1]\n\n        # Test Normalize object\n        hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n        m = HueMapping(p, norm=hue_norm)\n        assert m.norm is hue_norm\n\n        # Test default colormap values\n        hmin, hmax = p.plot_data[\"hue\"].min(), p.plot_data[\"hue\"].max()\n        m = HueMapping(p)\n        assert m.lookup_table[hmin] == pytest.approx(m.cmap(0.0))\n        assert m.lookup_table[hmax] == pytest.approx(m.cmap(1.0))\n\n        # Test specified colormap values\n        hue_norm = hmin - 1, hmax - 1\n        m = HueMapping(p, norm=hue_norm)\n        norm_min = (hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0])\n        assert m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min))\n        assert m.lookup_table[hmax] == pytest.approx(m.cmap(1.0))\n\n        # Test list of colors\n        hue_levels = list(np.sort(long_df[\"s\"].unique()))\n        palette = color_palette(\"Blues\", len(hue_levels))\n        m = HueMapping(p, palette=palette)\n        assert m.lookup_table == dict(zip(hue_levels, palette))\n\n        palette = color_palette(\"Blues\", len(hue_levels) + 1)\n        with pytest.warns(UserWarning):\n            HueMapping(p, palette=palette)\n\n        # Test dictionary of colors\n        palette = dict(zip(hue_levels, color_palette(\"Reds\")))\n        m = HueMapping(p, palette=palette)\n        assert m.lookup_table == palette\n\n        palette.pop(hue_levels[0])\n        with pytest.raises(ValueError):\n            HueMapping(p, palette=palette)\n\n        # Test invalid palette\n        with pytest.raises(ValueError):\n            HueMapping(p, palette=\"not a valid palette\")\n\n        # Test bad norm argument\n        with pytest.raises(ValueError):\n            HueMapping(p, norm=\"not a norm\")\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_hue_map_numeric", "self", "long_df", "vals", "np", "concatenate", "np", "linspace", "0", "1", "256", "1", "1", "1", "np", "nan", "test", "default", "colormap", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "s", "hue_levels", "list", "np", "sort", "long_df", "s", "unique", "m", "huemapping", "p", "assert", "m", "levels", "hue_levels", "assert", "m", "map_type", "numeric", "assert", "m", "cmap", "name", "seaborn_cubehelix", "test", "named", "colormap", "palette", "purples", "m", "huemapping", "p", "palette", "palette", "assert_array_equal", "m", "cmap", "vals", "get_colormap", "palette", "vals", "test", "colormap", "object", "palette", "get_colormap", "greens", "m", "huemapping", "p", "palette", "palette", "assert_array_equal", "m", "cmap", "vals", "palette", "vals", "test", "cubehelix", "shorthand", "palette", "ch", "2", "0", "light", "2", "m", "huemapping", "p", "palette", "palette", "assert", "isinstance", "m", "cmap", "mpl", "colors", "listedcolormap", "test", "specified", "hue", "limits", "hue_norm", "1", "4", "m", "huemapping", "p", "norm", "hue_norm", "assert", "isinstance", "m", "norm", "mpl", "colors", "normalize", "assert", "m", "norm", "vmin", "hue_norm", "0", "assert", "m", "norm", "vmax", "hue_norm", "1", "test", "normalize", "object", "hue_norm", "mpl", "colors", "powernorm", "2", "vmin", "1", "vmax", "10", "m", "huemapping", "p", "norm", "hue_norm", "assert", "m", "norm", "is", "hue_norm", "test", "default", "colormap", "values", "hmin", "hmax", "p", "plot_data", "hue", "min", "p", "plot_data", "hue", "max", "m", "huemapping", "p", "assert", "m", "lookup_table", "hmin", "pytest", "approx", "m", "cmap", "0", "0", "assert", "m", "lookup_table", "hmax", "pytest", "approx", "m", "cmap", "1", "0", "test", "specified", "colormap", "values", "hue_norm", "hmin", "1", "hmax", "1", "m", "huemapping", "p", "norm", "hue_norm", "norm_min", "hmin", "hue_norm", "0", "hue_norm", "1", "hue_norm", "0", "assert", "m", "lookup_table", "hmin", "pytest", "approx", "m", "cmap", "norm_min", "assert", "m", "lookup_table", "hmax", "pytest", "approx", "m", "cmap", "1", "0", "test", "list", "of", "colors", "hue_levels", "list", "np", "sort", "long_df", "s", "unique", "palette", "color_palette", "blues", "len", "hue_levels", "m", "huemapping", "p", "palette", "palette", "assert", "m", "lookup_table", "dict", "zip", "hue_levels", "palette", "palette", "color_palette", "blues", "len", "hue_levels", "1", "with", "pytest", "warns", "userwarning", "huemapping", "p", "palette", "palette", "test", "dictionary", "of", "colors", "palette", "dict", "zip", "hue_levels", "color_palette", "reds", "m", "huemapping", "p", "palette", "palette", "assert", "m", "lookup_table", "palette", "palette", "pop", "hue_levels", "0", "with", "pytest", "raises", "valueerror", "huemapping", "p", "palette", "palette", "test", "invalid", "palette", "with", "pytest", "raises", "valueerror", "huemapping", "p", "palette", "not", "a", "valid", "palette", "test", "bad", "norm", "argument", "with", "pytest", "raises", "valueerror", "huemapping", "p", "norm", "not", "a", "norm"], "doc_len": 346}
{"doc_id": "tests/test_core.py::TestHueMapping.test_hue_map_without_hue_dataa", "file_path": "tests/test_core.py", "class_name": "TestHueMapping", "func_name": "test_hue_map_without_hue_dataa", "text": "文件路径: tests/test_core.py, 类名: TestHueMapping\n    def test_hue_map_without_hue_dataa(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\"))\n        with pytest.warns(UserWarning, match=\"Ignoring `palette`\"):\n            HueMapping(p, palette=\"viridis\")\n", "tokens": ["tests", "test_core", "py", "testhuemapping", "def", "test_hue_map_without_hue_dataa", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "with", "pytest", "warns", "userwarning", "match", "ignoring", "palette", "huemapping", "p", "palette", "viridis"], "doc_len": 29}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_init_from_map", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_init_from_map", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_init_from_map(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"a\")\n        )\n        sizes = 1, 6\n        p = SizeMapping.map(p_orig, sizes=sizes)\n        assert p is p_orig\n        assert isinstance(p._size_map, SizeMapping)\n        assert min(p._size_map.lookup_table.values()) == sizes[0]\n        assert max(p._size_map.lookup_table.values()) == sizes[1]\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_init_from_map", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "sizes", "1", "6", "p", "sizemapping", "map", "p_orig", "sizes", "sizes", "assert", "p", "is", "p_orig", "assert", "isinstance", "p", "_size_map", "sizemapping", "assert", "min", "p", "_size_map", "lookup_table", "values", "sizes", "0", "assert", "max", "p", "_size_map", "lookup_table", "values", "sizes", "1"], "doc_len": 54}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_plotter_default_init", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_plotter_default_init", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_plotter_default_init(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n        assert isinstance(p._size_map, SizeMapping)\n        assert p._size_map.map_type is None\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"a\"),\n        )\n        assert isinstance(p._size_map, SizeMapping)\n        assert p._size_map.map_type == p.var_types[\"size\"]\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_plotter_default_init", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "assert", "isinstance", "p", "_size_map", "sizemapping", "assert", "p", "_size_map", "map_type", "is", "none", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "assert", "isinstance", "p", "_size_map", "sizemapping", "assert", "p", "_size_map", "map_type", "p", "var_types", "size"], "doc_len": 53}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_plotter_reinit", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_plotter_reinit", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_plotter_reinit(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"a\"),\n        )\n        sizes = [1, 4, 2]\n        size_order = [\"b\", \"a\", \"c\"]\n        p = p_orig.map_size(sizes=sizes, order=size_order)\n        assert p is p_orig\n        assert p._size_map.lookup_table == dict(zip(size_order, sizes))\n        assert p._size_map.levels == size_order\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_plotter_reinit", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "sizes", "1", "4", "2", "size_order", "b", "a", "c", "p", "p_orig", "map_size", "sizes", "sizes", "order", "size_order", "assert", "p", "is", "p_orig", "assert", "p", "_size_map", "lookup_table", "dict", "zip", "size_order", "sizes", "assert", "p", "_size_map", "levels", "size_order"], "doc_len": 52}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_size_map_null", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_size_map_null", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_size_map_null(self, flat_series, null_series):\n\n        p = VectorPlotter(variables=dict(x=flat_series, size=null_series))\n        m = HueMapping(p)\n        assert m.levels is None\n        assert m.map_type is None\n        assert m.norm is None\n        assert m.lookup_table is None\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_size_map_null", "self", "flat_series", "null_series", "p", "vectorplotter", "variables", "dict", "x", "flat_series", "size", "null_series", "m", "huemapping", "p", "assert", "m", "levels", "is", "none", "assert", "m", "map_type", "is", "none", "assert", "m", "norm", "is", "none", "assert", "m", "lookup_table", "is", "none"], "doc_len": 40}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_map_size_numeric", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_map_size_numeric", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_map_size_numeric(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"s\"),\n        )\n\n        # Test default range of keys in the lookup table values\n        m = SizeMapping(p)\n        size_values = m.lookup_table.values()\n        value_range = min(size_values), max(size_values)\n        assert value_range == p._default_size_range\n\n        # Test specified range of size values\n        sizes = 1, 5\n        m = SizeMapping(p, sizes=sizes)\n        size_values = m.lookup_table.values()\n        assert min(size_values), max(size_values) == sizes\n\n        # Test size values with normalization range\n        norm = 1, 10\n        m = SizeMapping(p, sizes=sizes, norm=norm)\n        normalize = mpl.colors.Normalize(*norm, clip=True)\n        for key, val in m.lookup_table.items():\n            assert val == sizes[0] + (sizes[1] - sizes[0]) * normalize(key)\n\n        # Test size values with normalization object\n        norm = mpl.colors.LogNorm(1, 10, clip=False)\n        m = SizeMapping(p, sizes=sizes, norm=norm)\n        assert m.norm.clip\n        for key, val in m.lookup_table.items():\n            assert val == sizes[0] + (sizes[1] - sizes[0]) * norm(key)\n\n        # Test bad sizes argument\n        with pytest.raises(ValueError):\n            SizeMapping(p, sizes=\"bad_sizes\")\n\n        # Test bad sizes argument\n        with pytest.raises(ValueError):\n            SizeMapping(p, sizes=(1, 2, 3))\n\n        # Test bad norm argument\n        with pytest.raises(ValueError):\n            SizeMapping(p, norm=\"bad_norm\")\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_map_size_numeric", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "s", "test", "default", "range", "of", "keys", "in", "the", "lookup", "table", "values", "m", "sizemapping", "p", "size_values", "m", "lookup_table", "values", "value_range", "min", "size_values", "max", "size_values", "assert", "value_range", "p", "_default_size_range", "test", "specified", "range", "of", "size", "values", "sizes", "1", "5", "m", "sizemapping", "p", "sizes", "sizes", "size_values", "m", "lookup_table", "values", "assert", "min", "size_values", "max", "size_values", "sizes", "test", "size", "values", "with", "normalization", "range", "norm", "1", "10", "m", "sizemapping", "p", "sizes", "sizes", "norm", "norm", "normalize", "mpl", "colors", "normalize", "norm", "clip", "true", "for", "key", "val", "in", "m", "lookup_table", "items", "assert", "val", "sizes", "0", "sizes", "1", "sizes", "0", "normalize", "key", "test", "size", "values", "with", "normalization", "object", "norm", "mpl", "colors", "lognorm", "1", "10", "clip", "false", "m", "sizemapping", "p", "sizes", "sizes", "norm", "norm", "assert", "m", "norm", "clip", "for", "key", "val", "in", "m", "lookup_table", "items", "assert", "val", "sizes", "0", "sizes", "1", "sizes", "0", "norm", "key", "test", "bad", "sizes", "argument", "with", "pytest", "raises", "valueerror", "sizemapping", "p", "sizes", "bad_sizes", "test", "bad", "sizes", "argument", "with", "pytest", "raises", "valueerror", "sizemapping", "p", "sizes", "1", "2", "3", "test", "bad", "norm", "argument", "with", "pytest", "raises", "valueerror", "sizemapping", "p", "norm", "bad_norm"], "doc_len": 190}
{"doc_id": "tests/test_core.py::TestSizeMapping.test_map_size_categorical", "file_path": "tests/test_core.py", "class_name": "TestSizeMapping", "func_name": "test_map_size_categorical", "text": "文件路径: tests/test_core.py, 类名: TestSizeMapping\n    def test_map_size_categorical(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"a\"),\n        )\n\n        # Test specified size order\n        levels = p.plot_data[\"size\"].unique()\n        sizes = [1, 4, 6]\n        order = [levels[1], levels[2], levels[0]]\n        m = SizeMapping(p, sizes=sizes, order=order)\n        assert m.lookup_table == dict(zip(order, sizes))\n\n        # Test list of sizes\n        order = categorical_order(p.plot_data[\"size\"])\n        sizes = list(np.random.rand(len(levels)))\n        m = SizeMapping(p, sizes=sizes)\n        assert m.lookup_table == dict(zip(order, sizes))\n\n        # Test dict of sizes\n        sizes = dict(zip(levels, np.random.rand(len(levels))))\n        m = SizeMapping(p, sizes=sizes)\n        assert m.lookup_table == sizes\n\n        # Test specified size range\n        sizes = (2, 5)\n        m = SizeMapping(p, sizes=sizes)\n        values = np.linspace(*sizes, len(m.levels))[::-1]\n        assert m.lookup_table == dict(zip(m.levels, values))\n\n        # Test explicit categories\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", size=\"a_cat\"))\n        m = SizeMapping(p)\n        assert m.levels == long_df[\"a_cat\"].cat.categories.to_list()\n        assert m.map_type == \"categorical\"\n\n        # Test sizes list with wrong length\n        sizes = list(np.random.rand(len(levels) + 1))\n        with pytest.warns(UserWarning):\n            SizeMapping(p, sizes=sizes)\n\n        # Test sizes dict with missing levels\n        sizes = dict(zip(levels, np.random.rand(len(levels) - 1)))\n        with pytest.raises(ValueError):\n            SizeMapping(p, sizes=sizes)\n\n        # Test bad sizes argument\n        with pytest.raises(ValueError):\n            SizeMapping(p, sizes=\"bad_size\")\n", "tokens": ["tests", "test_core", "py", "testsizemapping", "def", "test_map_size_categorical", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "test", "specified", "size", "order", "levels", "p", "plot_data", "size", "unique", "sizes", "1", "4", "6", "order", "levels", "1", "levels", "2", "levels", "0", "m", "sizemapping", "p", "sizes", "sizes", "order", "order", "assert", "m", "lookup_table", "dict", "zip", "order", "sizes", "test", "list", "of", "sizes", "order", "categorical_order", "p", "plot_data", "size", "sizes", "list", "np", "random", "rand", "len", "levels", "m", "sizemapping", "p", "sizes", "sizes", "assert", "m", "lookup_table", "dict", "zip", "order", "sizes", "test", "dict", "of", "sizes", "sizes", "dict", "zip", "levels", "np", "random", "rand", "len", "levels", "m", "sizemapping", "p", "sizes", "sizes", "assert", "m", "lookup_table", "sizes", "test", "specified", "size", "range", "sizes", "2", "5", "m", "sizemapping", "p", "sizes", "sizes", "values", "np", "linspace", "sizes", "len", "m", "levels", "1", "assert", "m", "lookup_table", "dict", "zip", "m", "levels", "values", "test", "explicit", "categories", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "size", "a_cat", "m", "sizemapping", "p", "assert", "m", "levels", "long_df", "a_cat", "cat", "categories", "to_list", "assert", "m", "map_type", "categorical", "test", "sizes", "list", "with", "wrong", "length", "sizes", "list", "np", "random", "rand", "len", "levels", "1", "with", "pytest", "warns", "userwarning", "sizemapping", "p", "sizes", "sizes", "test", "sizes", "dict", "with", "missing", "levels", "sizes", "dict", "zip", "levels", "np", "random", "rand", "len", "levels", "1", "with", "pytest", "raises", "valueerror", "sizemapping", "p", "sizes", "sizes", "test", "bad", "sizes", "argument", "with", "pytest", "raises", "valueerror", "sizemapping", "p", "sizes", "bad_size"], "doc_len": 218}
{"doc_id": "tests/test_core.py::TestStyleMapping.test_init_from_map", "file_path": "tests/test_core.py", "class_name": "TestStyleMapping", "func_name": "test_init_from_map", "text": "文件路径: tests/test_core.py, 类名: TestStyleMapping\n    def test_init_from_map(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", style=\"a\")\n        )\n        markers = [\"s\", \"p\", \"h\"]\n        p = StyleMapping.map(p_orig, markers=markers)\n        assert p is p_orig\n        assert isinstance(p._style_map, StyleMapping)\n        assert p._style_map(p._style_map.levels, \"marker\") == markers\n", "tokens": ["tests", "test_core", "py", "teststylemapping", "def", "test_init_from_map", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "style", "a", "markers", "s", "p", "h", "p", "stylemapping", "map", "p_orig", "markers", "markers", "assert", "p", "is", "p_orig", "assert", "isinstance", "p", "_style_map", "stylemapping", "assert", "p", "_style_map", "p", "_style_map", "levels", "marker", "markers"], "doc_len": 47}
{"doc_id": "tests/test_core.py::TestStyleMapping.test_plotter_default_init", "file_path": "tests/test_core.py", "class_name": "TestStyleMapping", "func_name": "test_plotter_default_init", "text": "文件路径: tests/test_core.py, 类名: TestStyleMapping\n    def test_plotter_default_init(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n        assert isinstance(p._style_map, StyleMapping)\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", style=\"a\"),\n        )\n        assert isinstance(p._style_map, StyleMapping)\n", "tokens": ["tests", "test_core", "py", "teststylemapping", "def", "test_plotter_default_init", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "assert", "isinstance", "p", "_style_map", "stylemapping", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "style", "a", "assert", "isinstance", "p", "_style_map", "stylemapping"], "doc_len": 40}
{"doc_id": "tests/test_core.py::TestStyleMapping.test_plotter_reinit", "file_path": "tests/test_core.py", "class_name": "TestStyleMapping", "func_name": "test_plotter_reinit", "text": "文件路径: tests/test_core.py, 类名: TestStyleMapping\n    def test_plotter_reinit(self, long_df):\n\n        p_orig = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", style=\"a\"),\n        )\n        markers = [\"s\", \"p\", \"h\"]\n        style_order = [\"b\", \"a\", \"c\"]\n        p = p_orig.map_style(markers=markers, order=style_order)\n        assert p is p_orig\n        assert p._style_map.levels == style_order\n        assert p._style_map(style_order, \"marker\") == markers\n", "tokens": ["tests", "test_core", "py", "teststylemapping", "def", "test_plotter_reinit", "self", "long_df", "p_orig", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "style", "a", "markers", "s", "p", "h", "style_order", "b", "a", "c", "p", "p_orig", "map_style", "markers", "markers", "order", "style_order", "assert", "p", "is", "p_orig", "assert", "p", "_style_map", "levels", "style_order", "assert", "p", "_style_map", "style_order", "marker", "markers"], "doc_len": 50}
{"doc_id": "tests/test_core.py::TestStyleMapping.test_style_map_null", "file_path": "tests/test_core.py", "class_name": "TestStyleMapping", "func_name": "test_style_map_null", "text": "文件路径: tests/test_core.py, 类名: TestStyleMapping\n    def test_style_map_null(self, flat_series, null_series):\n\n        p = VectorPlotter(variables=dict(x=flat_series, style=null_series))\n        m = HueMapping(p)\n        assert m.levels is None\n        assert m.map_type is None\n        assert m.lookup_table is None\n", "tokens": ["tests", "test_core", "py", "teststylemapping", "def", "test_style_map_null", "self", "flat_series", "null_series", "p", "vectorplotter", "variables", "dict", "x", "flat_series", "style", "null_series", "m", "huemapping", "p", "assert", "m", "levels", "is", "none", "assert", "m", "map_type", "is", "none", "assert", "m", "lookup_table", "is", "none"], "doc_len": 35}
{"doc_id": "tests/test_core.py::TestStyleMapping.test_map_style", "file_path": "tests/test_core.py", "class_name": "TestStyleMapping", "func_name": "test_map_style", "text": "文件路径: tests/test_core.py, 类名: TestStyleMapping\n    def test_map_style(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", style=\"a\"),\n        )\n\n        # Test defaults\n        m = StyleMapping(p, markers=True, dashes=True)\n\n        n = len(m.levels)\n        for key, dashes in zip(m.levels, unique_dashes(n)):\n            assert m(key, \"dashes\") == dashes\n\n        actual_marker_paths = {\n            k: mpl.markers.MarkerStyle(m(k, \"marker\")).get_path()\n            for k in m.levels\n        }\n        expected_marker_paths = {\n            k: mpl.markers.MarkerStyle(m).get_path()\n            for k, m in zip(m.levels, unique_markers(n))\n        }\n        assert actual_marker_paths == expected_marker_paths\n\n        # Test lists\n        markers, dashes = [\"o\", \"s\", \"d\"], [(1, 0), (1, 1), (2, 1, 3, 1)]\n        m = StyleMapping(p, markers=markers, dashes=dashes)\n        for key, mark, dash in zip(m.levels, markers, dashes):\n            assert m(key, \"marker\") == mark\n            assert m(key, \"dashes\") == dash\n\n        # Test dicts\n        markers = dict(zip(p.plot_data[\"style\"].unique(), markers))\n        dashes = dict(zip(p.plot_data[\"style\"].unique(), dashes))\n        m = StyleMapping(p, markers=markers, dashes=dashes)\n        for key in m.levels:\n            assert m(key, \"marker\") == markers[key]\n            assert m(key, \"dashes\") == dashes[key]\n\n        # Test explicit categories\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", style=\"a_cat\"))\n        m = StyleMapping(p)\n        assert m.levels == long_df[\"a_cat\"].cat.categories.to_list()\n\n        # Test style order with defaults\n        order = p.plot_data[\"style\"].unique()[[1, 2, 0]]\n        m = StyleMapping(p, markers=True, dashes=True, order=order)\n        n = len(order)\n        for key, mark, dash in zip(order, unique_markers(n), unique_dashes(n)):\n            assert m(key, \"dashes\") == dash\n            assert m(key, \"marker\") == mark\n            obj = mpl.markers.MarkerStyle(mark)\n            path = obj.get_path().transformed(obj.get_transform())\n            assert_array_equal(m(key, \"path\").vertices, path.vertices)\n\n        # Test too many levels with style lists\n        with pytest.warns(UserWarning):\n            StyleMapping(p, markers=[\"o\", \"s\"], dashes=False)\n\n        with pytest.warns(UserWarning):\n            StyleMapping(p, markers=False, dashes=[(2, 1)])\n\n        # Test missing keys with style dicts\n        markers, dashes = {\"a\": \"o\", \"b\": \"s\"}, False\n        with pytest.raises(ValueError):\n            StyleMapping(p, markers=markers, dashes=dashes)\n\n        markers, dashes = False, {\"a\": (1, 0), \"b\": (2, 1)}\n        with pytest.raises(ValueError):\n            StyleMapping(p, markers=markers, dashes=dashes)\n\n        # Test mixture of filled and unfilled markers\n        markers, dashes = [\"o\", \"x\", \"s\"], None\n        with pytest.raises(ValueError):\n            StyleMapping(p, markers=markers, dashes=dashes)\n", "tokens": ["tests", "test_core", "py", "teststylemapping", "def", "test_map_style", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "style", "a", "test", "defaults", "m", "stylemapping", "p", "markers", "true", "dashes", "true", "n", "len", "m", "levels", "for", "key", "dashes", "in", "zip", "m", "levels", "unique_dashes", "n", "assert", "m", "key", "dashes", "dashes", "actual_marker_paths", "k", "mpl", "markers", "markerstyle", "m", "k", "marker", "get_path", "for", "k", "in", "m", "levels", "expected_marker_paths", "k", "mpl", "markers", "markerstyle", "m", "get_path", "for", "k", "m", "in", "zip", "m", "levels", "unique_markers", "n", "assert", "actual_marker_paths", "expected_marker_paths", "test", "lists", "markers", "dashes", "o", "s", "d", "1", "0", "1", "1", "2", "1", "3", "1", "m", "stylemapping", "p", "markers", "markers", "dashes", "dashes", "for", "key", "mark", "dash", "in", "zip", "m", "levels", "markers", "dashes", "assert", "m", "key", "marker", "mark", "assert", "m", "key", "dashes", "dash", "test", "dicts", "markers", "dict", "zip", "p", "plot_data", "style", "unique", "markers", "dashes", "dict", "zip", "p", "plot_data", "style", "unique", "dashes", "m", "stylemapping", "p", "markers", "markers", "dashes", "dashes", "for", "key", "in", "m", "levels", "assert", "m", "key", "marker", "markers", "key", "assert", "m", "key", "dashes", "dashes", "key", "test", "explicit", "categories", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "style", "a_cat", "m", "stylemapping", "p", "assert", "m", "levels", "long_df", "a_cat", "cat", "categories", "to_list", "test", "style", "order", "with", "defaults", "order", "p", "plot_data", "style", "unique", "1", "2", "0", "m", "stylemapping", "p", "markers", "true", "dashes", "true", "order", "order", "n", "len", "order", "for", "key", "mark", "dash", "in", "zip", "order", "unique_markers", "n", "unique_dashes", "n", "assert", "m", "key", "dashes", "dash", "assert", "m", "key", "marker", "mark", "obj", "mpl", "markers", "markerstyle", "mark", "path", "obj", "get_path", "transformed", "obj", "get_transform", "assert_array_equal", "m", "key", "path", "vertices", "path", "vertices", "test", "too", "many", "levels", "with", "style", "lists", "with", "pytest", "warns", "userwarning", "stylemapping", "p", "markers", "o", "s", "dashes", "false", "with", "pytest", "warns", "userwarning", "stylemapping", "p", "markers", "false", "dashes", "2", "1", "test", "missing", "keys", "with", "style", "dicts", "markers", "dashes", "a", "o", "b", "s", "false", "with", "pytest", "raises", "valueerror", "stylemapping", "p", "markers", "markers", "dashes", "dashes", "markers", "dashes", "false", "a", "1", "0", "b", "2", "1", "with", "pytest", "raises", "valueerror", "stylemapping", "p", "markers", "markers", "dashes", "dashes", "test", "mixture", "of", "filled", "and", "unfilled", "markers", "markers", "dashes", "o", "x", "s", "none", "with", "pytest", "raises", "valueerror", "stylemapping", "p", "markers", "markers", "dashes", "dashes"], "doc_len": 346}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_flat_variables", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_flat_variables", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_flat_variables(self, flat_data):\n\n        p = VectorPlotter()\n        p.assign_variables(data=flat_data)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\"]\n        assert len(p.plot_data) == len(flat_data)\n\n        try:\n            expected_x = flat_data.index\n            expected_x_name = flat_data.index.name\n        except AttributeError:\n            expected_x = np.arange(len(flat_data))\n            expected_x_name = None\n\n        x = p.plot_data[\"x\"]\n        assert_array_equal(x, expected_x)\n\n        expected_y = flat_data\n        expected_y_name = getattr(flat_data, \"name\", None)\n\n        y = p.plot_data[\"y\"]\n        assert_array_equal(y, expected_y)\n\n        assert p.variables[\"x\"] == expected_x_name\n        assert p.variables[\"y\"] == expected_y_name\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_flat_variables", "self", "flat_data", "p", "vectorplotter", "p", "assign_variables", "data", "flat_data", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "assert", "len", "p", "plot_data", "len", "flat_data", "try", "expected_x", "flat_data", "index", "expected_x_name", "flat_data", "index", "name", "except", "attributeerror", "expected_x", "np", "arange", "len", "flat_data", "expected_x_name", "none", "x", "p", "plot_data", "x", "assert_array_equal", "x", "expected_x", "expected_y", "flat_data", "expected_y_name", "getattr", "flat_data", "name", "none", "y", "p", "plot_data", "y", "assert_array_equal", "y", "expected_y", "assert", "p", "variables", "x", "expected_x_name", "assert", "p", "variables", "y", "expected_y_name"], "doc_len": 78}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_df", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_df", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_df(self, long_df, long_variables):\n\n        p = VectorPlotter()\n        p.assign_variables(data=long_df, variables=long_variables)\n        assert p.input_format == \"long\"\n        assert p.variables == long_variables\n\n        for key, val in long_variables.items():\n            assert_array_equal(p.plot_data[key], long_df[val])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_df", "self", "long_df", "long_variables", "p", "vectorplotter", "p", "assign_variables", "data", "long_df", "variables", "long_variables", "assert", "p", "input_format", "long", "assert", "p", "variables", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert_array_equal", "p", "plot_data", "key", "long_df", "val"], "doc_len": 37}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_df_with_index", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_df_with_index", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_df_with_index(self, long_df, long_variables):\n\n        p = VectorPlotter()\n        p.assign_variables(\n            data=long_df.set_index(\"a\"),\n            variables=long_variables,\n        )\n        assert p.input_format == \"long\"\n        assert p.variables == long_variables\n\n        for key, val in long_variables.items():\n            assert_array_equal(p.plot_data[key], long_df[val])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_df_with_index", "self", "long_df", "long_variables", "p", "vectorplotter", "p", "assign_variables", "data", "long_df", "set_index", "a", "variables", "long_variables", "assert", "p", "input_format", "long", "assert", "p", "variables", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert_array_equal", "p", "plot_data", "key", "long_df", "val"], "doc_len": 39}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_df_with_multiindex", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_df_with_multiindex", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_df_with_multiindex(self, long_df, long_variables):\n\n        p = VectorPlotter()\n        p.assign_variables(\n            data=long_df.set_index([\"a\", \"x\"]),\n            variables=long_variables,\n        )\n        assert p.input_format == \"long\"\n        assert p.variables == long_variables\n\n        for key, val in long_variables.items():\n            assert_array_equal(p.plot_data[key], long_df[val])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_df_with_multiindex", "self", "long_df", "long_variables", "p", "vectorplotter", "p", "assign_variables", "data", "long_df", "set_index", "a", "x", "variables", "long_variables", "assert", "p", "input_format", "long", "assert", "p", "variables", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert_array_equal", "p", "plot_data", "key", "long_df", "val"], "doc_len": 40}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_dict", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_dict", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_dict(self, long_dict, long_variables):\n\n        p = VectorPlotter()\n        p.assign_variables(\n            data=long_dict,\n            variables=long_variables,\n        )\n        assert p.input_format == \"long\"\n        assert p.variables == long_variables\n\n        for key, val in long_variables.items():\n            assert_array_equal(p.plot_data[key], pd.Series(long_dict[val]))\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_dict", "self", "long_dict", "long_variables", "p", "vectorplotter", "p", "assign_variables", "data", "long_dict", "variables", "long_variables", "assert", "p", "input_format", "long", "assert", "p", "variables", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert_array_equal", "p", "plot_data", "key", "pd", "series", "long_dict", "val"], "doc_len": 39}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_vectors", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_vectors", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_vectors(self, long_df, long_variables, vector_type):\n\n        variables = {key: long_df[val] for key, val in long_variables.items()}\n        if vector_type == \"numpy\":\n            variables = {key: val.to_numpy() for key, val in variables.items()}\n        elif vector_type == \"list\":\n            variables = {key: val.to_list() for key, val in variables.items()}\n\n        p = VectorPlotter()\n        p.assign_variables(variables=variables)\n        assert p.input_format == \"long\"\n\n        assert list(p.variables) == list(long_variables)\n        if vector_type == \"series\":\n            assert p.variables == long_variables\n\n        for key, val in long_variables.items():\n            assert_array_equal(p.plot_data[key], long_df[val])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_vectors", "self", "long_df", "long_variables", "vector_type", "variables", "key", "long_df", "val", "for", "key", "val", "in", "long_variables", "items", "if", "vector_type", "numpy", "variables", "key", "val", "to_numpy", "for", "key", "val", "in", "variables", "items", "elif", "vector_type", "list", "variables", "key", "val", "to_list", "for", "key", "val", "in", "variables", "items", "p", "vectorplotter", "p", "assign_variables", "variables", "variables", "assert", "p", "input_format", "long", "assert", "list", "p", "variables", "list", "long_variables", "if", "vector_type", "series", "assert", "p", "variables", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert_array_equal", "p", "plot_data", "key", "long_df", "val"], "doc_len": 81}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_undefined_variables", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_undefined_variables", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_undefined_variables(self, long_df):\n\n        p = VectorPlotter()\n\n        with pytest.raises(ValueError):\n            p.assign_variables(\n                data=long_df, variables=dict(x=\"not_in_df\"),\n            )\n\n        with pytest.raises(ValueError):\n            p.assign_variables(\n                data=long_df, variables=dict(x=\"x\", y=\"not_in_df\"),\n            )\n\n        with pytest.raises(ValueError):\n            p.assign_variables(\n                data=long_df, variables=dict(x=\"x\", y=\"y\", hue=\"not_in_df\"),\n            )\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_undefined_variables", "self", "long_df", "p", "vectorplotter", "with", "pytest", "raises", "valueerror", "p", "assign_variables", "data", "long_df", "variables", "dict", "x", "not_in_df", "with", "pytest", "raises", "valueerror", "p", "assign_variables", "data", "long_df", "variables", "dict", "x", "x", "y", "not_in_df", "with", "pytest", "raises", "valueerror", "p", "assign_variables", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "not_in_df"], "doc_len": 52}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_empty_data_input", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_empty_data_input", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_empty_data_input(self, arg):\n\n        p = VectorPlotter()\n        p.assign_variables(data=arg)\n        assert not p.variables\n\n        if not isinstance(arg, pd.DataFrame):\n            p = VectorPlotter()\n            p.assign_variables(variables=dict(x=arg, y=arg))\n            assert not p.variables\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_empty_data_input", "self", "arg", "p", "vectorplotter", "p", "assign_variables", "data", "arg", "assert", "not", "p", "variables", "if", "not", "isinstance", "arg", "pd", "dataframe", "p", "vectorplotter", "p", "assign_variables", "variables", "dict", "x", "arg", "y", "arg", "assert", "not", "p", "variables"], "doc_len": 38}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_units", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_units", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_units(self, repeated_df):\n\n        p = VectorPlotter()\n        p.assign_variables(\n            data=repeated_df,\n            variables=dict(x=\"x\", y=\"y\", units=\"u\"),\n        )\n        assert_array_equal(p.plot_data[\"units\"], repeated_df[\"u\"])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_units", "self", "repeated_df", "p", "vectorplotter", "p", "assign_variables", "data", "repeated_df", "variables", "dict", "x", "x", "y", "y", "units", "u", "assert_array_equal", "p", "plot_data", "units", "repeated_df", "u"], "doc_len": 28}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_numeric_name", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_numeric_name", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_numeric_name(self, long_df, name):\n\n        long_df[name] = long_df[\"x\"]\n        p = VectorPlotter()\n        p.assign_variables(data=long_df, variables={\"x\": name})\n        assert_array_equal(p.plot_data[\"x\"], long_df[name])\n        assert p.variables[\"x\"] == name\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_numeric_name", "self", "long_df", "name", "long_df", "name", "long_df", "x", "p", "vectorplotter", "p", "assign_variables", "data", "long_df", "variables", "x", "name", "assert_array_equal", "p", "plot_data", "x", "long_df", "name", "assert", "p", "variables", "x", "name"], "doc_len": 33}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_hierarchical_index", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_hierarchical_index", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_hierarchical_index(self, rng):\n\n        cols = pd.MultiIndex.from_product([[\"a\"], [\"x\", \"y\"]])\n        data = rng.uniform(size=(50, 2))\n        df = pd.DataFrame(data, columns=cols)\n\n        name = (\"a\", \"y\")\n        var = \"y\"\n\n        p = VectorPlotter()\n        p.assign_variables(data=df, variables={var: name})\n        assert_array_equal(p.plot_data[var], df[name])\n        assert p.variables[var] == name\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_hierarchical_index", "self", "rng", "cols", "pd", "multiindex", "from_product", "a", "x", "y", "data", "rng", "uniform", "size", "50", "2", "df", "pd", "dataframe", "data", "columns", "cols", "name", "a", "y", "var", "y", "p", "vectorplotter", "p", "assign_variables", "data", "df", "variables", "var", "name", "assert_array_equal", "p", "plot_data", "var", "df", "name", "assert", "p", "variables", "var", "name"], "doc_len": 52}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_scalar_and_data", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_scalar_and_data", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_scalar_and_data(self, long_df):\n\n        val = 22\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": val})\n        assert (p.plot_data[\"y\"] == val).all()\n        assert p.variables[\"y\"] is None\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_scalar_and_data", "self", "long_df", "val", "22", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "val", "assert", "p", "plot_data", "y", "val", "all", "assert", "p", "variables", "y", "is", "none"], "doc_len": 31}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_wide_semantic_error", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_wide_semantic_error", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_wide_semantic_error(self, wide_df):\n\n        err = \"The following variable cannot be assigned with wide-form data: `hue`\"\n        with pytest.raises(ValueError, match=err):\n            VectorPlotter(data=wide_df, variables={\"hue\": \"a\"})\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_wide_semantic_error", "self", "wide_df", "err", "the", "following", "variable", "cannot", "be", "assigned", "with", "wide", "form", "data", "hue", "with", "pytest", "raises", "valueerror", "match", "err", "vectorplotter", "data", "wide_df", "variables", "hue", "a"], "doc_len": 32}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_unknown_error", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_unknown_error", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_unknown_error(self, long_df):\n\n        err = \"Could not interpret value `what` for parameter `hue`\"\n        with pytest.raises(ValueError, match=err):\n            VectorPlotter(data=long_df, variables={\"x\": \"x\", \"hue\": \"what\"})\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_unknown_error", "self", "long_df", "err", "could", "not", "interpret", "value", "what", "for", "parameter", "hue", "with", "pytest", "raises", "valueerror", "match", "err", "vectorplotter", "data", "long_df", "variables", "x", "x", "hue", "what"], "doc_len": 31}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_long_unmatched_size_error", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_long_unmatched_size_error", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_long_unmatched_size_error(self, long_df, flat_array):\n\n        err = \"Length of ndarray vectors must match length of `data`\"\n        with pytest.raises(ValueError, match=err):\n            VectorPlotter(data=long_df, variables={\"x\": \"x\", \"hue\": flat_array})\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_long_unmatched_size_error", "self", "long_df", "flat_array", "err", "length", "of", "ndarray", "vectors", "must", "match", "length", "of", "data", "with", "pytest", "raises", "valueerror", "match", "err", "vectorplotter", "data", "long_df", "variables", "x", "x", "hue", "flat_array"], "doc_len": 33}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_wide_categorical_columns", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_wide_categorical_columns", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_wide_categorical_columns(self, wide_df):\n\n        wide_df.columns = pd.CategoricalIndex(wide_df.columns)\n        p = VectorPlotter(data=wide_df)\n        assert_array_equal(p.plot_data[\"hue\"].unique(), [\"a\", \"b\", \"c\"])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_wide_categorical_columns", "self", "wide_df", "wide_df", "columns", "pd", "categoricalindex", "wide_df", "columns", "p", "vectorplotter", "data", "wide_df", "assert_array_equal", "p", "plot_data", "hue", "unique", "a", "b", "c"], "doc_len": 26}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_iter_data_quantitites", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_iter_data_quantitites", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_iter_data_quantitites(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n        out = p.iter_data(\"hue\")\n        assert len(list(out)) == 1\n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        semantics = [\"hue\", \"size\", \"style\"]\n        for semantic in semantics:\n\n            p = VectorPlotter(\n                data=long_df,\n                variables={\"x\": \"x\", \"y\": \"y\", semantic: var},\n            )\n            out = p.iter_data(semantics)\n            assert len(list(out)) == n_subsets\n\n        var = \"a\"\n        n_subsets = len(long_df[var].unique())\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var, style=var),\n        )\n        out = p.iter_data(semantics)\n        assert len(list(out)) == n_subsets\n\n        # --\n\n        out = p.iter_data(semantics, reverse=True)\n        assert len(list(out)) == n_subsets\n\n        # --\n\n        var1, var2 = \"a\", \"s\"\n\n        n_subsets = len(long_df[var1].unique())\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, style=var2),\n        )\n        out = p.iter_data([\"hue\"])\n        assert len(list(out)) == n_subsets\n\n        n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, style=var2),\n        )\n        out = p.iter_data(semantics)\n        assert len(list(out)) == n_subsets\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, size=var2, style=var1),\n        )\n        out = p.iter_data(semantics)\n        assert len(list(out)) == n_subsets\n\n        # --\n\n        var1, var2, var3 = \"a\", \"s\", \"b\"\n        cols = [var1, var2, var3]\n        n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, size=var2, style=var3),\n        )\n        out = p.iter_data(semantics)\n        assert len(list(out)) == n_subsets\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_iter_data_quantitites", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "out", "p", "iter_data", "hue", "assert", "len", "list", "out", "1", "var", "a", "n_subsets", "len", "long_df", "var", "unique", "semantics", "hue", "size", "style", "for", "semantic", "in", "semantics", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "semantic", "var", "out", "p", "iter_data", "semantics", "assert", "len", "list", "out", "n_subsets", "var", "a", "n_subsets", "len", "long_df", "var", "unique", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var", "style", "var", "out", "p", "iter_data", "semantics", "assert", "len", "list", "out", "n_subsets", "out", "p", "iter_data", "semantics", "reverse", "true", "assert", "len", "list", "out", "n_subsets", "var1", "var2", "a", "s", "n_subsets", "len", "long_df", "var1", "unique", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "style", "var2", "out", "p", "iter_data", "hue", "assert", "len", "list", "out", "n_subsets", "n_subsets", "len", "set", "list", "map", "tuple", "long_df", "var1", "var2", "values", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "style", "var2", "out", "p", "iter_data", "semantics", "assert", "len", "list", "out", "n_subsets", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "size", "var2", "style", "var1", "out", "p", "iter_data", "semantics", "assert", "len", "list", "out", "n_subsets", "var1", "var2", "var3", "a", "s", "b", "cols", "var1", "var2", "var3", "n_subsets", "len", "set", "list", "map", "tuple", "long_df", "cols", "values", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "size", "var2", "style", "var3", "out", "p", "iter_data", "semantics", "assert", "len", "list", "out", "n_subsets"], "doc_len": 237}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_iter_data_keys", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_iter_data_keys", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_iter_data_keys(self, long_df):\n\n        semantics = [\"hue\", \"size\", \"style\"]\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n        for sub_vars, _ in p.iter_data(\"hue\"):\n            assert sub_vars == {}\n\n        # --\n\n        var = \"a\"\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var),\n        )\n        for sub_vars, _ in p.iter_data(\"hue\"):\n            assert list(sub_vars) == [\"hue\"]\n            assert sub_vars[\"hue\"] in long_df[var].values\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=var),\n        )\n        for sub_vars, _ in p.iter_data(\"size\"):\n            assert list(sub_vars) == [\"size\"]\n            assert sub_vars[\"size\"] in long_df[var].values\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var, style=var),\n        )\n        for sub_vars, _ in p.iter_data(semantics):\n            assert list(sub_vars) == [\"hue\", \"style\"]\n            assert sub_vars[\"hue\"] in long_df[var].values\n            assert sub_vars[\"style\"] in long_df[var].values\n            assert sub_vars[\"hue\"] == sub_vars[\"style\"]\n\n        var1, var2 = \"a\", \"s\"\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, size=var2),\n        )\n        for sub_vars, _ in p.iter_data(semantics):\n            assert list(sub_vars) == [\"hue\", \"size\"]\n            assert sub_vars[\"hue\"] in long_df[var1].values\n            assert sub_vars[\"size\"] in long_df[var2].values\n\n        semantics = [\"hue\", \"col\", \"row\"]\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=var1, col=var2),\n        )\n        for sub_vars, _ in p.iter_data(\"hue\"):\n            assert list(sub_vars) == [\"hue\", \"col\"]\n            assert sub_vars[\"hue\"] in long_df[var1].values\n            assert sub_vars[\"col\"] in long_df[var2].values\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_iter_data_keys", "self", "long_df", "semantics", "hue", "size", "style", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "for", "sub_vars", "_", "in", "p", "iter_data", "hue", "assert", "sub_vars", "var", "a", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var", "for", "sub_vars", "_", "in", "p", "iter_data", "hue", "assert", "list", "sub_vars", "hue", "assert", "sub_vars", "hue", "in", "long_df", "var", "values", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "var", "for", "sub_vars", "_", "in", "p", "iter_data", "size", "assert", "list", "sub_vars", "size", "assert", "sub_vars", "size", "in", "long_df", "var", "values", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var", "style", "var", "for", "sub_vars", "_", "in", "p", "iter_data", "semantics", "assert", "list", "sub_vars", "hue", "style", "assert", "sub_vars", "hue", "in", "long_df", "var", "values", "assert", "sub_vars", "style", "in", "long_df", "var", "values", "assert", "sub_vars", "hue", "sub_vars", "style", "var1", "var2", "a", "s", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "size", "var2", "for", "sub_vars", "_", "in", "p", "iter_data", "semantics", "assert", "list", "sub_vars", "hue", "size", "assert", "sub_vars", "hue", "in", "long_df", "var1", "values", "assert", "sub_vars", "size", "in", "long_df", "var2", "values", "semantics", "hue", "col", "row", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "var1", "col", "var2", "for", "sub_vars", "_", "in", "p", "iter_data", "hue", "assert", "list", "sub_vars", "hue", "col", "assert", "sub_vars", "hue", "in", "long_df", "var1", "values", "assert", "sub_vars", "col", "in", "long_df", "var2", "values"], "doc_len": 226}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_iter_data_values", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_iter_data_values", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_iter_data_values(self, long_df):\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n\n        p.sort = True\n        _, sub_data = next(p.iter_data(\"hue\"))\n        assert_frame_equal(sub_data, p.plot_data)\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n        )\n\n        for sub_vars, sub_data in p.iter_data(\"hue\"):\n            rows = p.plot_data[\"hue\"] == sub_vars[\"hue\"]\n            assert_frame_equal(sub_data, p.plot_data[rows])\n\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", size=\"s\"),\n        )\n        for sub_vars, sub_data in p.iter_data([\"hue\", \"size\"]):\n            rows = p.plot_data[\"hue\"] == sub_vars[\"hue\"]\n            rows &= p.plot_data[\"size\"] == sub_vars[\"size\"]\n            assert_frame_equal(sub_data, p.plot_data[rows])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_iter_data_values", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "p", "sort", "true", "_", "sub_data", "next", "p", "iter_data", "hue", "assert_frame_equal", "sub_data", "p", "plot_data", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "for", "sub_vars", "sub_data", "in", "p", "iter_data", "hue", "rows", "p", "plot_data", "hue", "sub_vars", "hue", "assert_frame_equal", "sub_data", "p", "plot_data", "rows", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "size", "s", "for", "sub_vars", "sub_data", "in", "p", "iter_data", "hue", "size", "rows", "p", "plot_data", "hue", "sub_vars", "hue", "rows", "p", "plot_data", "size", "sub_vars", "size", "assert_frame_equal", "sub_data", "p", "plot_data", "rows"], "doc_len": 100}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_iter_data_reverse", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_iter_data_reverse", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_iter_data_reverse(self, long_df):\n\n        reversed_order = categorical_order(long_df[\"a\"])[::-1]\n        p = VectorPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\")\n        )\n        iterator = p.iter_data(\"hue\", reverse=True)\n        for i, (sub_vars, _) in enumerate(iterator):\n            assert sub_vars[\"hue\"] == reversed_order[i]\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_iter_data_reverse", "self", "long_df", "reversed_order", "categorical_order", "long_df", "a", "1", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "iterator", "p", "iter_data", "hue", "reverse", "true", "for", "i", "sub_vars", "_", "in", "enumerate", "iterator", "assert", "sub_vars", "hue", "reversed_order", "i"], "doc_len": 43}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_iter_data_dropna", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_iter_data_dropna", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_iter_data_dropna(self, missing_df):\n\n        p = VectorPlotter(\n            data=missing_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\")\n        )\n        for _, sub_df in p.iter_data(\"hue\"):\n            assert not sub_df.isna().any().any()\n\n        some_missing = False\n        for _, sub_df in p.iter_data(\"hue\", dropna=False):\n            some_missing |= sub_df.isna().any().any()\n        assert some_missing\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_iter_data_dropna", "self", "missing_df", "p", "vectorplotter", "data", "missing_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "for", "_", "sub_df", "in", "p", "iter_data", "hue", "assert", "not", "sub_df", "isna", "any", "any", "some_missing", "false", "for", "_", "sub_df", "in", "p", "iter_data", "hue", "dropna", "false", "some_missing", "sub_df", "isna", "any", "any", "assert", "some_missing"], "doc_len": 51}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_axis_labels", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_axis_labels", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_axis_labels(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = VectorPlotter(data=long_df, variables=dict(x=\"a\"))\n\n        p._add_axis_labels(ax)\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"\"\n        ax.clear()\n\n        p = VectorPlotter(data=long_df, variables=dict(y=\"a\"))\n        p._add_axis_labels(ax)\n        assert ax.get_xlabel() == \"\"\n        assert ax.get_ylabel() == \"a\"\n        ax.clear()\n\n        p = VectorPlotter(data=long_df, variables=dict(x=\"a\"))\n\n        p._add_axis_labels(ax, default_y=\"default\")\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"default\"\n        ax.clear()\n\n        p = VectorPlotter(data=long_df, variables=dict(y=\"a\"))\n        p._add_axis_labels(ax, default_x=\"default\", default_y=\"default\")\n        assert ax.get_xlabel() == \"default\"\n        assert ax.get_ylabel() == \"a\"\n        ax.clear()\n\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"a\"))\n        ax.set(xlabel=\"existing\", ylabel=\"also existing\")\n        p._add_axis_labels(ax)\n        assert ax.get_xlabel() == \"existing\"\n        assert ax.get_ylabel() == \"also existing\"\n\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n        p = VectorPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\"))\n\n        p._add_axis_labels(ax1)\n        p._add_axis_labels(ax2)\n\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"y\"\n        assert ax1.yaxis.label.get_visible()\n\n        assert ax2.get_xlabel() == \"x\"\n        assert ax2.get_ylabel() == \"y\"\n        assert not ax2.yaxis.label.get_visible()\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_axis_labels", "self", "long_df", "f", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "a", "p", "_add_axis_labels", "ax", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel", "ax", "clear", "p", "vectorplotter", "data", "long_df", "variables", "dict", "y", "a", "p", "_add_axis_labels", "ax", "assert", "ax", "get_xlabel", "assert", "ax", "get_ylabel", "a", "ax", "clear", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "a", "p", "_add_axis_labels", "ax", "default_y", "default", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel", "default", "ax", "clear", "p", "vectorplotter", "data", "long_df", "variables", "dict", "y", "a", "p", "_add_axis_labels", "ax", "default_x", "default", "default_y", "default", "assert", "ax", "get_xlabel", "default", "assert", "ax", "get_ylabel", "a", "ax", "clear", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "a", "ax", "set", "xlabel", "existing", "ylabel", "also", "existing", "p", "_add_axis_labels", "ax", "assert", "ax", "get_xlabel", "existing", "assert", "ax", "get_ylabel", "also", "existing", "f", "ax1", "ax2", "plt", "subplots", "1", "2", "sharey", "true", "p", "vectorplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "p", "_add_axis_labels", "ax1", "p", "_add_axis_labels", "ax2", "assert", "ax1", "get_xlabel", "x", "assert", "ax1", "get_ylabel", "y", "assert", "ax1", "yaxis", "label", "get_visible", "assert", "ax2", "get_xlabel", "x", "assert", "ax2", "get_ylabel", "y", "assert", "not", "ax2", "yaxis", "label", "get_visible"], "doc_len": 181}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_basics", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_basics", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_basics(self, long_df, variables):\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables=variables)\n        p._attach(ax)\n        assert p.ax is ax\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_basics", "self", "long_df", "variables", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "variables", "p", "_attach", "ax", "assert", "p", "ax", "is", "ax"], "doc_len": 27}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_disallowed", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_disallowed", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_disallowed(self, long_df):\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a\"})\n\n        with pytest.raises(TypeError):\n            p._attach(ax, allowed_types=\"numeric\")\n\n        with pytest.raises(TypeError):\n            p._attach(ax, allowed_types=[\"datetime\", \"numeric\"])\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\"})\n\n        with pytest.raises(TypeError):\n            p._attach(ax, allowed_types=\"categorical\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"t\"})\n\n        with pytest.raises(TypeError):\n            p._attach(ax, allowed_types=[\"numeric\", \"categorical\"])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_disallowed", "self", "long_df", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "a", "with", "pytest", "raises", "typeerror", "p", "_attach", "ax", "allowed_types", "numeric", "with", "pytest", "raises", "typeerror", "p", "_attach", "ax", "allowed_types", "datetime", "numeric", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "with", "pytest", "raises", "typeerror", "p", "_attach", "ax", "allowed_types", "categorical", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "t", "with", "pytest", "raises", "typeerror", "p", "_attach", "ax", "allowed_types", "numeric", "categorical"], "doc_len": 81}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_log_scale", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_log_scale", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_log_scale(self, long_df):\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\"})\n        p._attach(ax, log_scale=True)\n        assert ax.xaxis.get_scale() == \"log\"\n        assert ax.yaxis.get_scale() == \"linear\"\n        assert p._log_scaled(\"x\")\n        assert not p._log_scaled(\"y\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\"})\n        p._attach(ax, log_scale=2)\n        assert ax.xaxis.get_scale() == \"log\"\n        assert ax.yaxis.get_scale() == \"linear\"\n        assert p._log_scaled(\"x\")\n        assert not p._log_scaled(\"y\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"y\": \"y\"})\n        p._attach(ax, log_scale=True)\n        assert ax.xaxis.get_scale() == \"linear\"\n        assert ax.yaxis.get_scale() == \"log\"\n        assert not p._log_scaled(\"x\")\n        assert p._log_scaled(\"y\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\"})\n        p._attach(ax, log_scale=True)\n        assert ax.xaxis.get_scale() == \"log\"\n        assert ax.yaxis.get_scale() == \"log\"\n        assert p._log_scaled(\"x\")\n        assert p._log_scaled(\"y\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\"})\n        p._attach(ax, log_scale=(True, False))\n        assert ax.xaxis.get_scale() == \"log\"\n        assert ax.yaxis.get_scale() == \"linear\"\n        assert p._log_scaled(\"x\")\n        assert not p._log_scaled(\"y\")\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\"})\n        p._attach(ax, log_scale=(False, 2))\n        assert ax.xaxis.get_scale() == \"linear\"\n        assert ax.yaxis.get_scale() == \"log\"\n        assert not p._log_scaled(\"x\")\n        assert p._log_scaled(\"y\")\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_log_scale", "self", "long_df", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "p", "_attach", "ax", "log_scale", "true", "assert", "ax", "xaxis", "get_scale", "log", "assert", "ax", "yaxis", "get_scale", "linear", "assert", "p", "_log_scaled", "x", "assert", "not", "p", "_log_scaled", "y", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "p", "_attach", "ax", "log_scale", "2", "assert", "ax", "xaxis", "get_scale", "log", "assert", "ax", "yaxis", "get_scale", "linear", "assert", "p", "_log_scaled", "x", "assert", "not", "p", "_log_scaled", "y", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "y", "y", "p", "_attach", "ax", "log_scale", "true", "assert", "ax", "xaxis", "get_scale", "linear", "assert", "ax", "yaxis", "get_scale", "log", "assert", "not", "p", "_log_scaled", "x", "assert", "p", "_log_scaled", "y", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "p", "_attach", "ax", "log_scale", "true", "assert", "ax", "xaxis", "get_scale", "log", "assert", "ax", "yaxis", "get_scale", "log", "assert", "p", "_log_scaled", "x", "assert", "p", "_log_scaled", "y", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "p", "_attach", "ax", "log_scale", "true", "false", "assert", "ax", "xaxis", "get_scale", "log", "assert", "ax", "yaxis", "get_scale", "linear", "assert", "p", "_log_scaled", "x", "assert", "not", "p", "_log_scaled", "y", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "p", "_attach", "ax", "log_scale", "false", "2", "assert", "ax", "xaxis", "get_scale", "linear", "assert", "ax", "yaxis", "get_scale", "log", "assert", "not", "p", "_log_scaled", "x", "assert", "p", "_log_scaled", "y"], "doc_len": 225}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_converters", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_converters", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_converters(self, long_df):\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"t\"})\n        p._attach(ax)\n        assert ax.xaxis.converter is None\n        assert \"Date\" in ax.yaxis.converter.__class__.__name__\n\n        _, ax = plt.subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a\", \"y\": \"y\"})\n        p._attach(ax)\n        assert \"CategoryConverter\" in ax.xaxis.converter.__class__.__name__\n        assert ax.yaxis.converter is None\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_converters", "self", "long_df", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "t", "p", "_attach", "ax", "assert", "ax", "xaxis", "converter", "is", "none", "assert", "date", "in", "ax", "yaxis", "converter", "__class__", "__name__", "_", "ax", "plt", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "a", "y", "y", "p", "_attach", "ax", "assert", "categoryconverter", "in", "ax", "xaxis", "converter", "__class__", "__name__", "assert", "ax", "yaxis", "converter", "is", "none"], "doc_len": 68}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_facets", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_facets", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_facets(self, long_df):\n\n        g = FacetGrid(long_df, col=\"a\")\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"col\": \"a\"})\n        p._attach(g)\n        assert p.ax is None\n        assert p.facets == g\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_facets", "self", "long_df", "g", "facetgrid", "long_df", "col", "a", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "col", "a", "p", "_attach", "g", "assert", "p", "ax", "is", "none", "assert", "p", "facets", "g"], "doc_len": 34}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_attach_shared_axes", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_attach_shared_axes", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_attach_shared_axes(self, long_df):\n\n        g = FacetGrid(long_df)\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\"})\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\")\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\"})\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == 1\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", sharex=False)\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\"})\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == p.plot_data[\"col\"].nunique()\n        assert p.converters[\"x\"].groupby(p.plot_data[\"col\"]).nunique().max() == 1\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", sharex=False, col_wrap=2)\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\"})\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == p.plot_data[\"col\"].nunique()\n        assert p.converters[\"x\"].groupby(p.plot_data[\"col\"]).nunique().max() == 1\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", row=\"b\")\n        p = VectorPlotter(\n            data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\", \"row\": \"b\"},\n        )\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == 1\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", row=\"b\", sharex=False)\n        p = VectorPlotter(\n            data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\", \"row\": \"b\"},\n        )\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == len(g.axes.flat)\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", row=\"b\", sharex=\"col\")\n        p = VectorPlotter(\n            data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\", \"row\": \"b\"},\n        )\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == p.plot_data[\"col\"].nunique()\n        assert p.converters[\"x\"].groupby(p.plot_data[\"col\"]).nunique().max() == 1\n        assert p.converters[\"y\"].nunique() == 1\n\n        g = FacetGrid(long_df, col=\"a\", row=\"b\", sharey=\"row\")\n        p = VectorPlotter(\n            data=long_df, variables={\"x\": \"x\", \"y\": \"y\", \"col\": \"a\", \"row\": \"b\"},\n        )\n        p._attach(g)\n        assert p.converters[\"x\"].nunique() == 1\n        assert p.converters[\"y\"].nunique() == p.plot_data[\"row\"].nunique()\n        assert p.converters[\"y\"].groupby(p.plot_data[\"row\"]).nunique().max() == 1\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_attach_shared_axes", "self", "long_df", "g", "facetgrid", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "1", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "sharex", "false", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "p", "plot_data", "col", "nunique", "assert", "p", "converters", "x", "groupby", "p", "plot_data", "col", "nunique", "max", "1", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "sharex", "false", "col_wrap", "2", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "p", "plot_data", "col", "nunique", "assert", "p", "converters", "x", "groupby", "p", "plot_data", "col", "nunique", "max", "1", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "row", "b", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "row", "b", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "1", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "row", "b", "sharex", "false", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "row", "b", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "len", "g", "axes", "flat", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "row", "b", "sharex", "col", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "row", "b", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "p", "plot_data", "col", "nunique", "assert", "p", "converters", "x", "groupby", "p", "plot_data", "col", "nunique", "max", "1", "assert", "p", "converters", "y", "nunique", "1", "g", "facetgrid", "long_df", "col", "a", "row", "b", "sharey", "row", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "y", "col", "a", "row", "b", "p", "_attach", "g", "assert", "p", "converters", "x", "nunique", "1", "assert", "p", "converters", "y", "nunique", "p", "plot_data", "row", "nunique", "assert", "p", "converters", "y", "groupby", "p", "plot_data", "row", "nunique", "max", "1"], "doc_len": 333}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_get_axes_single", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_get_axes_single", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_get_axes_single(self, long_df):\n\n        ax = plt.figure().subplots()\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"hue\": \"a\"})\n        p._attach(ax)\n        assert p._get_axes({\"hue\": \"a\"}) is ax\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_get_axes_single", "self", "long_df", "ax", "plt", "figure", "subplots", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "hue", "a", "p", "_attach", "ax", "assert", "p", "_get_axes", "hue", "a", "is", "ax"], "doc_len": 31}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_get_axes_facets", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_get_axes_facets", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_get_axes_facets(self, long_df):\n\n        g = FacetGrid(long_df, col=\"a\")\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"col\": \"a\"})\n        p._attach(g)\n        assert p._get_axes({\"col\": \"b\"}) is g.axes_dict[\"b\"]\n\n        g = FacetGrid(long_df, col=\"a\", row=\"c\")\n        p = VectorPlotter(\n            data=long_df, variables={\"x\": \"x\", \"col\": \"a\", \"row\": \"c\"}\n        )\n        p._attach(g)\n        assert p._get_axes({\"row\": 1, \"col\": \"b\"}) is g.axes_dict[(1, \"b\")]\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_get_axes_facets", "self", "long_df", "g", "facetgrid", "long_df", "col", "a", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "col", "a", "p", "_attach", "g", "assert", "p", "_get_axes", "col", "b", "is", "g", "axes_dict", "b", "g", "facetgrid", "long_df", "col", "a", "row", "c", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "col", "a", "row", "c", "p", "_attach", "g", "assert", "p", "_get_axes", "row", "1", "col", "b", "is", "g", "axes_dict", "1", "b"], "doc_len": 67}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_comp_data", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_comp_data", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_comp_data(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\", \"y\": \"t\"})\n\n        # We have disabled this check for now, while it remains part of\n        # the internal API, because it will require updating a number of tests\n        # with pytest.raises(AttributeError):\n        #     p.comp_data\n\n        _, ax = plt.subplots()\n        p._attach(ax)\n\n        assert_array_equal(p.comp_data[\"x\"], p.plot_data[\"x\"])\n        assert_array_equal(\n            p.comp_data[\"y\"], ax.yaxis.convert_units(p.plot_data[\"y\"])\n        )\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a\"})\n\n        _, ax = plt.subplots()\n        p._attach(ax)\n\n        assert_array_equal(\n            p.comp_data[\"x\"], ax.xaxis.convert_units(p.plot_data[\"x\"])\n        )\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_comp_data", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "y", "t", "we", "have", "disabled", "this", "check", "for", "now", "while", "it", "remains", "part", "of", "the", "internal", "api", "because", "it", "will", "require", "updating", "a", "number", "of", "tests", "with", "pytest", "raises", "attributeerror", "p", "comp_data", "_", "ax", "plt", "subplots", "p", "_attach", "ax", "assert_array_equal", "p", "comp_data", "x", "p", "plot_data", "x", "assert_array_equal", "p", "comp_data", "y", "ax", "yaxis", "convert_units", "p", "plot_data", "y", "p", "vectorplotter", "data", "long_df", "variables", "x", "a", "_", "ax", "plt", "subplots", "p", "_attach", "ax", "assert_array_equal", "p", "comp_data", "x", "ax", "xaxis", "convert_units", "p", "plot_data", "x"], "doc_len": 95}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_comp_data_log", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_comp_data_log", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_comp_data_log(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"z\", \"y\": \"y\"})\n        _, ax = plt.subplots()\n        p._attach(ax, log_scale=(True, False))\n\n        assert_array_equal(\n            p.comp_data[\"x\"], np.log10(p.plot_data[\"x\"])\n        )\n        assert_array_equal(p.comp_data[\"y\"], p.plot_data[\"y\"])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_comp_data_log", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "z", "y", "y", "_", "ax", "plt", "subplots", "p", "_attach", "ax", "log_scale", "true", "false", "assert_array_equal", "p", "comp_data", "x", "np", "log10", "p", "plot_data", "x", "assert_array_equal", "p", "comp_data", "y", "p", "plot_data", "y"], "doc_len": 43}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_comp_data_category_order", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_comp_data_category_order", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_comp_data_category_order(self):\n\n        s = (pd.Series([\"a\", \"b\", \"c\", \"a\"], dtype=\"category\")\n             .cat.set_categories([\"b\", \"c\", \"a\"], ordered=True))\n\n        p = VectorPlotter(variables={\"x\": s})\n        _, ax = plt.subplots()\n        p._attach(ax)\n        assert_array_equal(\n            p.comp_data[\"x\"],\n            [2, 0, 1, 2],\n        )\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_comp_data_category_order", "self", "s", "pd", "series", "a", "b", "c", "a", "dtype", "category", "cat", "set_categories", "b", "c", "a", "ordered", "true", "p", "vectorplotter", "variables", "x", "s", "_", "ax", "plt", "subplots", "p", "_attach", "ax", "assert_array_equal", "p", "comp_data", "x", "2", "0", "1", "2"], "doc_len": 43}
{"doc_id": "tests/test_core.py::TestVectorPlotter.comp_data_missing_fixture", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "comp_data_missing_fixture", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def comp_data_missing_fixture(self, request):\n\n        # This fixture holds the logic for parameterizing\n        # the following test (test_comp_data_missing)\n\n        NA, var_type = request.param\n\n        if NA is None:\n            pytest.skip(\"No pandas.NA available\")\n\n        comp_data = [0, 1, np.nan, 2, np.nan, 1]\n        if var_type == \"numeric\":\n            orig_data = [0, 1, NA, 2, np.inf, 1]\n        elif var_type == \"category\":\n            orig_data = [\"a\", \"b\", NA, \"c\", NA, \"b\"]\n        elif var_type == \"datetime\":\n            # Use 1-based numbers to avoid issue on matplotlib<3.2\n            # Could simplify the test a bit when we roll off that version\n            comp_data = [1, 2, np.nan, 3, np.nan, 2]\n            numbers = [1, 2, 3, 2]\n\n            orig_data = mpl.dates.num2date(numbers)\n            orig_data.insert(2, NA)\n            orig_data.insert(4, np.inf)\n\n        return orig_data, comp_data\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "comp_data_missing_fixture", "self", "request", "this", "fixture", "holds", "the", "logic", "for", "parameterizing", "the", "following", "test", "test_comp_data_missing", "na", "var_type", "request", "param", "if", "na", "is", "none", "pytest", "skip", "no", "pandas", "na", "available", "comp_data", "0", "1", "np", "nan", "2", "np", "nan", "1", "if", "var_type", "numeric", "orig_data", "0", "1", "na", "2", "np", "inf", "1", "elif", "var_type", "category", "orig_data", "a", "b", "na", "c", "na", "b", "elif", "var_type", "datetime", "use", "1", "based", "numbers", "to", "avoid", "issue", "on", "matplotlib", "3", "2", "could", "simplify", "the", "test", "a", "bit", "when", "we", "roll", "off", "that", "version", "comp_data", "1", "2", "np", "nan", "3", "np", "nan", "2", "numbers", "1", "2", "3", "2", "orig_data", "mpl", "dates", "num2date", "numbers", "orig_data", "insert", "2", "na", "orig_data", "insert", "4", "np", "inf", "return", "orig_data", "comp_data"], "doc_len": 120}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_comp_data_missing", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_comp_data_missing", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_comp_data_missing(self, comp_data_missing_fixture):\n\n        orig_data, comp_data = comp_data_missing_fixture\n        p = VectorPlotter(variables={\"x\": orig_data})\n        ax = plt.figure().subplots()\n        p._attach(ax)\n        assert_array_equal(p.comp_data[\"x\"], comp_data)\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_comp_data_missing", "self", "comp_data_missing_fixture", "orig_data", "comp_data", "comp_data_missing_fixture", "p", "vectorplotter", "variables", "x", "orig_data", "ax", "plt", "figure", "subplots", "p", "_attach", "ax", "assert_array_equal", "p", "comp_data", "x", "comp_data"], "doc_len": 28}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_comp_data_duplicate_index", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_comp_data_duplicate_index", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_comp_data_duplicate_index(self):\n\n        x = pd.Series([1, 2, 3, 4, 5], [1, 1, 1, 2, 2])\n        p = VectorPlotter(variables={\"x\": x})\n        ax = plt.figure().subplots()\n        p._attach(ax)\n        assert_array_equal(p.comp_data[\"x\"], x)\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_comp_data_duplicate_index", "self", "x", "pd", "series", "1", "2", "3", "4", "5", "1", "1", "1", "2", "2", "p", "vectorplotter", "variables", "x", "x", "ax", "plt", "figure", "subplots", "p", "_attach", "ax", "assert_array_equal", "p", "comp_data", "x", "x"], "doc_len": 37}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_var_order", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_var_order", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_var_order(self, long_df):\n\n        order = [\"c\", \"b\", \"a\"]\n        for var in [\"hue\", \"size\", \"style\"]:\n            p = VectorPlotter(data=long_df, variables={\"x\": \"x\", var: \"a\"})\n\n            mapper = getattr(p, f\"map_{var}\")\n            mapper(order=order)\n\n            assert p.var_levels[var] == order\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_var_order", "self", "long_df", "order", "c", "b", "a", "for", "var", "in", "hue", "size", "style", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "var", "a", "mapper", "getattr", "p", "f", "map_", "var", "mapper", "order", "order", "assert", "p", "var_levels", "var", "order"], "doc_len": 41}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_scale_native", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_scale_native", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_scale_native(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\"})\n        with pytest.raises(NotImplementedError):\n            p.scale_native(\"x\")\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_scale_native", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "with", "pytest", "raises", "notimplementederror", "p", "scale_native", "x"], "doc_len": 22}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_scale_numeric", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_scale_numeric", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_scale_numeric(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"y\": \"y\"})\n        with pytest.raises(NotImplementedError):\n            p.scale_numeric(\"y\")\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_scale_numeric", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "y", "y", "with", "pytest", "raises", "notimplementederror", "p", "scale_numeric", "y"], "doc_len": 22}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_scale_datetime", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_scale_datetime", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_scale_datetime(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"t\"})\n        with pytest.raises(NotImplementedError):\n            p.scale_datetime(\"x\")\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_scale_datetime", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "t", "with", "pytest", "raises", "notimplementederror", "p", "scale_datetime", "x"], "doc_len": 22}
{"doc_id": "tests/test_core.py::TestVectorPlotter.test_scale_categorical", "file_path": "tests/test_core.py", "class_name": "TestVectorPlotter", "func_name": "test_scale_categorical", "text": "文件路径: tests/test_core.py, 类名: TestVectorPlotter\n    def test_scale_categorical(self, long_df):\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"x\"})\n        p.scale_categorical(\"y\")\n        assert p.variables[\"y\"] is None\n        assert p.var_types[\"y\"] == \"categorical\"\n        assert (p.plot_data[\"y\"] == \"\").all()\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"s\"})\n        p.scale_categorical(\"x\")\n        assert p.var_types[\"x\"] == \"categorical\"\n        assert hasattr(p.plot_data[\"x\"], \"str\")\n        assert not p._var_ordered[\"x\"]\n        assert p.plot_data[\"x\"].is_monotonic_increasing\n        assert_array_equal(p.var_levels[\"x\"], p.plot_data[\"x\"].unique())\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a\"})\n        p.scale_categorical(\"x\")\n        assert not p._var_ordered[\"x\"]\n        assert_array_equal(p.var_levels[\"x\"], categorical_order(long_df[\"a\"]))\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a_cat\"})\n        p.scale_categorical(\"x\")\n        assert p._var_ordered[\"x\"]\n        assert_array_equal(p.var_levels[\"x\"], categorical_order(long_df[\"a_cat\"]))\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"a\"})\n        order = np.roll(long_df[\"a\"].unique(), 1)\n        p.scale_categorical(\"x\", order=order)\n        assert p._var_ordered[\"x\"]\n        assert_array_equal(p.var_levels[\"x\"], order)\n\n        p = VectorPlotter(data=long_df, variables={\"x\": \"s\"})\n        p.scale_categorical(\"x\", formatter=lambda x: f\"{x:%}\")\n        assert p.plot_data[\"x\"].str.endswith(\"%\").all()\n        assert all(s.endswith(\"%\") for s in p.var_levels[\"x\"])\n", "tokens": ["tests", "test_core", "py", "testvectorplotter", "def", "test_scale_categorical", "self", "long_df", "p", "vectorplotter", "data", "long_df", "variables", "x", "x", "p", "scale_categorical", "y", "assert", "p", "variables", "y", "is", "none", "assert", "p", "var_types", "y", "categorical", "assert", "p", "plot_data", "y", "all", "p", "vectorplotter", "data", "long_df", "variables", "x", "s", "p", "scale_categorical", "x", "assert", "p", "var_types", "x", "categorical", "assert", "hasattr", "p", "plot_data", "x", "str", "assert", "not", "p", "_var_ordered", "x", "assert", "p", "plot_data", "x", "is_monotonic_increasing", "assert_array_equal", "p", "var_levels", "x", "p", "plot_data", "x", "unique", "p", "vectorplotter", "data", "long_df", "variables", "x", "a", "p", "scale_categorical", "x", "assert", "not", "p", "_var_ordered", "x", "assert_array_equal", "p", "var_levels", "x", "categorical_order", "long_df", "a", "p", "vectorplotter", "data", "long_df", "variables", "x", "a_cat", "p", "scale_categorical", "x", "assert", "p", "_var_ordered", "x", "assert_array_equal", "p", "var_levels", "x", "categorical_order", "long_df", "a_cat", "p", "vectorplotter", "data", "long_df", "variables", "x", "a", "order", "np", "roll", "long_df", "a", "unique", "1", "p", "scale_categorical", "x", "order", "order", "assert", "p", "_var_ordered", "x", "assert_array_equal", "p", "var_levels", "x", "order", "p", "vectorplotter", "data", "long_df", "variables", "x", "s", "p", "scale_categorical", "x", "formatter", "lambda", "x", "f", "x", "assert", "p", "plot_data", "x", "str", "endswith", "all", "assert", "all", "s", "endswith", "for", "s", "in", "p", "var_levels", "x"], "doc_len": 176}
{"doc_id": "tests/test_core.py::TestCoreFunc.test_unique_dashes", "file_path": "tests/test_core.py", "class_name": "TestCoreFunc", "func_name": "test_unique_dashes", "text": "文件路径: tests/test_core.py, 类名: TestCoreFunc\n    def test_unique_dashes(self):\n\n        n = 24\n        dashes = unique_dashes(n)\n\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == \"\"\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n", "tokens": ["tests", "test_core", "py", "testcorefunc", "def", "test_unique_dashes", "self", "n", "24", "dashes", "unique_dashes", "n", "assert", "len", "dashes", "n", "assert", "len", "set", "dashes", "n", "assert", "dashes", "0", "for", "spec", "in", "dashes", "1", "assert", "isinstance", "spec", "tuple", "assert", "not", "len", "spec", "2"], "doc_len": 38}
{"doc_id": "tests/test_core.py::TestCoreFunc.test_unique_markers", "file_path": "tests/test_core.py", "class_name": "TestCoreFunc", "func_name": "test_unique_markers", "text": "文件路径: tests/test_core.py, 类名: TestCoreFunc\n    def test_unique_markers(self):\n\n        n = 24\n        markers = unique_markers(n)\n\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n", "tokens": ["tests", "test_core", "py", "testcorefunc", "def", "test_unique_markers", "self", "n", "24", "markers", "unique_markers", "n", "assert", "len", "markers", "n", "assert", "len", "set", "markers", "n", "for", "m", "in", "markers", "assert", "mpl", "markers", "markerstyle", "m", "is_filled"], "doc_len": 31}
{"doc_id": "tests/test_core.py::TestCoreFunc.test_variable_type", "file_path": "tests/test_core.py", "class_name": "TestCoreFunc", "func_name": "test_variable_type", "text": "文件路径: tests/test_core.py, 类名: TestCoreFunc\n    def test_variable_type(self):\n\n        s = pd.Series([1., 2., 3.])\n        assert variable_type(s) == \"numeric\"\n        assert variable_type(s.astype(int)) == \"numeric\"\n        assert variable_type(s.astype(object)) == \"numeric\"\n        assert variable_type(s.to_numpy()) == \"numeric\"\n        assert variable_type(s.to_list()) == \"numeric\"\n\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == \"numeric\"\n\n        s = pd.Series([np.nan, np.nan])\n        # s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == \"numeric\"\n\n        s = pd.Series([\"1\", \"2\", \"3\"])\n        assert variable_type(s) == \"categorical\"\n        assert variable_type(s.to_numpy()) == \"categorical\"\n        assert variable_type(s.to_list()) == \"categorical\"\n\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == \"numeric\"\n        assert variable_type(s, boolean_type=\"categorical\") == \"categorical\"\n        s_cat = s.astype(\"category\")\n        assert variable_type(s_cat, boolean_type=\"categorical\") == \"categorical\"\n        assert variable_type(s_cat, boolean_type=\"numeric\") == \"categorical\"\n\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == \"datetime\"\n        assert variable_type(s.astype(object)) == \"datetime\"\n        assert variable_type(s.to_numpy()) == \"datetime\"\n        assert variable_type(s.to_list()) == \"datetime\"\n", "tokens": ["tests", "test_core", "py", "testcorefunc", "def", "test_variable_type", "self", "s", "pd", "series", "1", "2", "3", "assert", "variable_type", "s", "numeric", "assert", "variable_type", "s", "astype", "int", "numeric", "assert", "variable_type", "s", "astype", "object", "numeric", "assert", "variable_type", "s", "to_numpy", "numeric", "assert", "variable_type", "s", "to_list", "numeric", "s", "pd", "series", "1", "2", "3", "np", "nan", "dtype", "object", "assert", "variable_type", "s", "numeric", "s", "pd", "series", "np", "nan", "np", "nan", "s", "pd", "series", "pd", "na", "pd", "na", "assert", "variable_type", "s", "numeric", "s", "pd", "series", "1", "2", "3", "assert", "variable_type", "s", "categorical", "assert", "variable_type", "s", "to_numpy", "categorical", "assert", "variable_type", "s", "to_list", "categorical", "s", "pd", "series", "true", "false", "false", "assert", "variable_type", "s", "numeric", "assert", "variable_type", "s", "boolean_type", "categorical", "categorical", "s_cat", "s", "astype", "category", "assert", "variable_type", "s_cat", "boolean_type", "categorical", "categorical", "assert", "variable_type", "s_cat", "boolean_type", "numeric", "categorical", "s", "pd", "series", "pd", "timestamp", "1", "pd", "timestamp", "2", "assert", "variable_type", "s", "datetime", "assert", "variable_type", "s", "astype", "object", "datetime", "assert", "variable_type", "s", "to_numpy", "datetime", "assert", "variable_type", "s", "to_list", "datetime"], "doc_len": 152}
{"doc_id": "tests/test_core.py::TestCoreFunc.test_infer_orient", "file_path": "tests/test_core.py", "class_name": "TestCoreFunc", "func_name": "test_infer_orient", "text": "文件路径: tests/test_core.py, 类名: TestCoreFunc\n    def test_infer_orient(self):\n\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series([\"a\", \"b\"] * 3)\n        dates = pd.date_range(\"1999-09-22\", \"2006-05-14\", 6)\n\n        assert infer_orient(cats, nums) == \"v\"\n        assert infer_orient(nums, cats) == \"h\"\n\n        assert infer_orient(cats, dates, require_numeric=False) == \"v\"\n        assert infer_orient(dates, cats, require_numeric=False) == \"h\"\n\n        assert infer_orient(nums, None) == \"h\"\n        with pytest.warns(UserWarning, match=\"Vertical .+ `x`\"):\n            assert infer_orient(nums, None, \"v\") == \"h\"\n\n        assert infer_orient(None, nums) == \"v\"\n        with pytest.warns(UserWarning, match=\"Horizontal .+ `y`\"):\n            assert infer_orient(None, nums, \"h\") == \"v\"\n\n        infer_orient(cats, None, require_numeric=False) == \"h\"\n        with pytest.raises(TypeError, match=\"Horizontal .+ `x`\"):\n            infer_orient(cats, None)\n\n        infer_orient(cats, None, require_numeric=False) == \"v\"\n        with pytest.raises(TypeError, match=\"Vertical .+ `y`\"):\n            infer_orient(None, cats)\n\n        assert infer_orient(nums, nums, \"vert\") == \"v\"\n        assert infer_orient(nums, nums, \"hori\") == \"h\"\n\n        assert infer_orient(cats, cats, \"h\", require_numeric=False) == \"h\"\n        assert infer_orient(cats, cats, \"v\", require_numeric=False) == \"v\"\n        assert infer_orient(cats, cats, require_numeric=False) == \"v\"\n\n        with pytest.raises(TypeError, match=\"Vertical .+ `y`\"):\n            infer_orient(cats, cats, \"v\")\n        with pytest.raises(TypeError, match=\"Horizontal .+ `x`\"):\n            infer_orient(cats, cats, \"h\")\n        with pytest.raises(TypeError, match=\"Neither\"):\n            infer_orient(cats, cats)\n\n        with pytest.raises(ValueError, match=\"`orient` must start with\"):\n            infer_orient(cats, nums, orient=\"bad value\")\n", "tokens": ["tests", "test_core", "py", "testcorefunc", "def", "test_infer_orient", "self", "nums", "pd", "series", "np", "arange", "6", "cats", "pd", "series", "a", "b", "3", "dates", "pd", "date_range", "1999", "09", "22", "2006", "05", "14", "6", "assert", "infer_orient", "cats", "nums", "v", "assert", "infer_orient", "nums", "cats", "h", "assert", "infer_orient", "cats", "dates", "require_numeric", "false", "v", "assert", "infer_orient", "dates", "cats", "require_numeric", "false", "h", "assert", "infer_orient", "nums", "none", "h", "with", "pytest", "warns", "userwarning", "match", "vertical", "x", "assert", "infer_orient", "nums", "none", "v", "h", "assert", "infer_orient", "none", "nums", "v", "with", "pytest", "warns", "userwarning", "match", "horizontal", "y", "assert", "infer_orient", "none", "nums", "h", "v", "infer_orient", "cats", "none", "require_numeric", "false", "h", "with", "pytest", "raises", "typeerror", "match", "horizontal", "x", "infer_orient", "cats", "none", "infer_orient", "cats", "none", "require_numeric", "false", "v", "with", "pytest", "raises", "typeerror", "match", "vertical", "y", "infer_orient", "none", "cats", "assert", "infer_orient", "nums", "nums", "vert", "v", "assert", "infer_orient", "nums", "nums", "hori", "h", "assert", "infer_orient", "cats", "cats", "h", "require_numeric", "false", "h", "assert", "infer_orient", "cats", "cats", "v", "require_numeric", "false", "v", "assert", "infer_orient", "cats", "cats", "require_numeric", "false", "v", "with", "pytest", "raises", "typeerror", "match", "vertical", "y", "infer_orient", "cats", "cats", "v", "with", "pytest", "raises", "typeerror", "match", "horizontal", "x", "infer_orient", "cats", "cats", "h", "with", "pytest", "raises", "typeerror", "match", "neither", "infer_orient", "cats", "cats", "with", "pytest", "raises", "valueerror", "match", "orient", "must", "start", "with", "infer_orient", "cats", "nums", "orient", "bad", "value"], "doc_len": 202}
{"doc_id": "tests/test_core.py::TestCoreFunc.test_categorical_order", "file_path": "tests/test_core.py", "class_name": "TestCoreFunc", "func_name": "test_categorical_order", "text": "文件路径: tests/test_core.py, 类名: TestCoreFunc\n    def test_categorical_order(self):\n\n        x = [\"a\", \"c\", \"c\", \"b\", \"a\", \"d\"]\n        y = [3, 2, 5, 1, 4]\n        order = [\"a\", \"b\", \"c\", \"d\"]\n\n        out = categorical_order(x)\n        assert out == [\"a\", \"c\", \"b\", \"d\"]\n\n        out = categorical_order(x, order)\n        assert out == order\n\n        out = categorical_order(x, [\"b\", \"a\"])\n        assert out == [\"b\", \"a\"]\n\n        out = categorical_order(np.array(x))\n        assert out == [\"a\", \"c\", \"b\", \"d\"]\n\n        out = categorical_order(pd.Series(x))\n        assert out == [\"a\", \"c\", \"b\", \"d\"]\n\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n\n        out = categorical_order(x, [\"b\", \"a\"])\n        assert out == [\"b\", \"a\"]\n\n        x = [\"a\", np.nan, \"c\", \"c\", \"b\", \"a\", \"d\"]\n        out = categorical_order(x)\n        assert out == [\"a\", \"c\", \"b\", \"d\"]\n", "tokens": ["tests", "test_core", "py", "testcorefunc", "def", "test_categorical_order", "self", "x", "a", "c", "c", "b", "a", "d", "y", "3", "2", "5", "1", "4", "order", "a", "b", "c", "d", "out", "categorical_order", "x", "assert", "out", "a", "c", "b", "d", "out", "categorical_order", "x", "order", "assert", "out", "order", "out", "categorical_order", "x", "b", "a", "assert", "out", "b", "a", "out", "categorical_order", "np", "array", "x", "assert", "out", "a", "c", "b", "d", "out", "categorical_order", "pd", "series", "x", "assert", "out", "a", "c", "b", "d", "out", "categorical_order", "y", "assert", "out", "1", "2", "3", "4", "5", "out", "categorical_order", "np", "array", "y", "assert", "out", "1", "2", "3", "4", "5", "out", "categorical_order", "pd", "series", "y", "assert", "out", "1", "2", "3", "4", "5", "x", "pd", "categorical", "x", "order", "out", "categorical_order", "x", "assert", "out", "list", "x", "categories", "x", "pd", "series", "x", "out", "categorical_order", "x", "assert", "out", "list", "x", "cat", "categories", "out", "categorical_order", "x", "b", "a", "assert", "out", "b", "a", "x", "a", "np", "nan", "c", "c", "b", "a", "d", "out", "categorical_order", "x", "assert", "out", "a", "c", "b", "d"], "doc_len": 159}
{"doc_id": "tests/test_decorators.py::test_share_init_params_with_map", "file_path": "tests/test_decorators.py", "class_name": null, "func_name": "test_share_init_params_with_map", "text": "文件路径: tests/test_decorators.py\ndef test_share_init_params_with_map():\n\n    @share_init_params_with_map\n    class Thingie:\n\n        def map(cls, *args, **kwargs):\n            return cls(*args, **kwargs)\n\n        def __init__(self, a, b=1):\n            \"\"\"Make a new thingie.\"\"\"\n            self.a = a\n            self.b = b\n\n    thingie = Thingie.map(1, b=2)\n    assert thingie.a == 1\n    assert thingie.b == 2\n\n    assert \"a\" in inspect.signature(Thingie.map).parameters\n    assert \"b\" in inspect.signature(Thingie.map).parameters\n\n    assert Thingie.map.__doc__ == Thingie.__init__.__doc__\n", "tokens": ["tests", "test_decorators", "py", "def", "test_share_init_params_with_map", "share_init_params_with_map", "class", "thingie", "def", "map", "cls", "args", "kwargs", "return", "cls", "args", "kwargs", "def", "__init__", "self", "a", "b", "1", "make", "a", "new", "thingie", "self", "a", "a", "self", "b", "b", "thingie", "thingie", "map", "1", "b", "2", "assert", "thingie", "a", "1", "assert", "thingie", "b", "2", "assert", "a", "in", "inspect", "signature", "thingie", "map", "parameters", "assert", "b", "in", "inspect", "signature", "thingie", "map", "parameters", "assert", "thingie", "map", "__doc__", "thingie", "__init__", "__doc__"], "doc_len": 70}
{"doc_id": "tests/test_distributions.py::get_contour_coords", "file_path": "tests/test_distributions.py", "class_name": null, "func_name": "get_contour_coords", "text": "文件路径: tests/test_distributions.py\ndef get_contour_coords(c):\n    \"\"\"Provide compatability for change in contour artist type in mpl3.5.\"\"\"\n    # See https://github.com/matplotlib/matplotlib/issues/20906\n    if isinstance(c, mpl.collections.LineCollection):\n        return c.get_segments()\n    elif isinstance(c, mpl.collections.PathCollection):\n        return [p.vertices[:np.argmax(p.codes) + 1] for p in c.get_paths()]\n", "tokens": ["tests", "test_distributions", "py", "def", "get_contour_coords", "c", "provide", "compatability", "for", "change", "in", "contour", "artist", "type", "in", "mpl3", "5", "see", "https", "github", "com", "matplotlib", "matplotlib", "issues", "20906", "if", "isinstance", "c", "mpl", "collections", "linecollection", "return", "c", "get_segments", "elif", "isinstance", "c", "mpl", "collections", "pathcollection", "return", "p", "vertices", "np", "argmax", "p", "codes", "1", "for", "p", "in", "c", "get_paths"], "doc_len": 53}
{"doc_id": "tests/test_distributions.py::get_contour_color", "file_path": "tests/test_distributions.py", "class_name": null, "func_name": "get_contour_color", "text": "文件路径: tests/test_distributions.py\ndef get_contour_color(c):\n    \"\"\"Provide compatability for change in contour artist type in mpl3.5.\"\"\"\n    # See https://github.com/matplotlib/matplotlib/issues/20906\n    if isinstance(c, mpl.collections.LineCollection):\n        return c.get_color()\n    elif isinstance(c, mpl.collections.PathCollection):\n        if c.get_facecolor().size:\n            return c.get_facecolor()\n        else:\n            return c.get_edgecolor()\n", "tokens": ["tests", "test_distributions", "py", "def", "get_contour_color", "c", "provide", "compatability", "for", "change", "in", "contour", "artist", "type", "in", "mpl3", "5", "see", "https", "github", "com", "matplotlib", "matplotlib", "issues", "20906", "if", "isinstance", "c", "mpl", "collections", "linecollection", "return", "c", "get_color", "elif", "isinstance", "c", "mpl", "collections", "pathcollection", "if", "c", "get_facecolor", "size", "return", "c", "get_facecolor", "else", "return", "c", "get_edgecolor"], "doc_len": 51}
{"doc_id": "tests/test_distributions.py::TestDistPlot.test_hist_bins", "file_path": "tests/test_distributions.py", "class_name": "TestDistPlot", "func_name": "test_hist_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestDistPlot\n    def test_hist_bins(self):\n\n        fd_edges = np.histogram_bin_edges(self.x, \"fd\")\n        with pytest.warns(UserWarning):\n            ax = distplot(self.x)\n        for edge, bar in zip(fd_edges, ax.patches):\n            assert pytest.approx(edge) == bar.get_x()\n\n        plt.close(ax.figure)\n        n = 25\n        n_edges = np.histogram_bin_edges(self.x, n)\n        with pytest.warns(UserWarning):\n            ax = distplot(self.x, bins=n)\n        for edge, bar in zip(n_edges, ax.patches):\n            assert pytest.approx(edge) == bar.get_x()\n", "tokens": ["tests", "test_distributions", "py", "testdistplot", "def", "test_hist_bins", "self", "fd_edges", "np", "histogram_bin_edges", "self", "x", "fd", "with", "pytest", "warns", "userwarning", "ax", "distplot", "self", "x", "for", "edge", "bar", "in", "zip", "fd_edges", "ax", "patches", "assert", "pytest", "approx", "edge", "bar", "get_x", "plt", "close", "ax", "figure", "n", "25", "n_edges", "np", "histogram_bin_edges", "self", "x", "n", "with", "pytest", "warns", "userwarning", "ax", "distplot", "self", "x", "bins", "n", "for", "edge", "bar", "in", "zip", "n_edges", "ax", "patches", "assert", "pytest", "approx", "edge", "bar", "get_x"], "doc_len": 71}
{"doc_id": "tests/test_distributions.py::TestDistPlot.test_elements", "file_path": "tests/test_distributions.py", "class_name": "TestDistPlot", "func_name": "test_elements", "text": "文件路径: tests/test_distributions.py, 类名: TestDistPlot\n    def test_elements(self):\n\n        with pytest.warns(UserWarning):\n\n            n = 10\n            ax = distplot(self.x, bins=n,\n                          hist=True, kde=False, rug=False, fit=None)\n            assert len(ax.patches) == 10\n            assert len(ax.lines) == 0\n            assert len(ax.collections) == 0\n\n            plt.close(ax.figure)\n            ax = distplot(self.x,\n                          hist=False, kde=True, rug=False, fit=None)\n            assert len(ax.patches) == 0\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 0\n\n            plt.close(ax.figure)\n            ax = distplot(self.x,\n                          hist=False, kde=False, rug=True, fit=None)\n            assert len(ax.patches) == 0\n            assert len(ax.lines) == 0\n            assert len(ax.collections) == 1\n\n            class Norm:\n                \"\"\"Dummy object that looks like a scipy RV\"\"\"\n                def fit(self, x):\n                    return ()\n\n                def pdf(self, x, *params):\n                    return np.zeros_like(x)\n\n            plt.close(ax.figure)\n            ax = distplot(\n                self.x, hist=False, kde=False, rug=False, fit=Norm())\n            assert len(ax.patches) == 0\n            assert len(ax.lines) == 1\n            assert len(ax.collections) == 0\n", "tokens": ["tests", "test_distributions", "py", "testdistplot", "def", "test_elements", "self", "with", "pytest", "warns", "userwarning", "n", "10", "ax", "distplot", "self", "x", "bins", "n", "hist", "true", "kde", "false", "rug", "false", "fit", "none", "assert", "len", "ax", "patches", "10", "assert", "len", "ax", "lines", "0", "assert", "len", "ax", "collections", "0", "plt", "close", "ax", "figure", "ax", "distplot", "self", "x", "hist", "false", "kde", "true", "rug", "false", "fit", "none", "assert", "len", "ax", "patches", "0", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "0", "plt", "close", "ax", "figure", "ax", "distplot", "self", "x", "hist", "false", "kde", "false", "rug", "true", "fit", "none", "assert", "len", "ax", "patches", "0", "assert", "len", "ax", "lines", "0", "assert", "len", "ax", "collections", "1", "class", "norm", "dummy", "object", "that", "looks", "like", "a", "scipy", "rv", "def", "fit", "self", "x", "return", "def", "pdf", "self", "x", "params", "return", "np", "zeros_like", "x", "plt", "close", "ax", "figure", "ax", "distplot", "self", "x", "hist", "false", "kde", "false", "rug", "false", "fit", "norm", "assert", "len", "ax", "patches", "0", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "0"], "doc_len": 159}
{"doc_id": "tests/test_distributions.py::TestDistPlot.test_distplot_with_nans", "file_path": "tests/test_distributions.py", "class_name": "TestDistPlot", "func_name": "test_distplot_with_nans", "text": "文件路径: tests/test_distributions.py, 类名: TestDistPlot\n    def test_distplot_with_nans(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        x_null = np.append(self.x, [np.nan])\n\n        with pytest.warns(UserWarning):\n            distplot(self.x, ax=ax1)\n            distplot(x_null, ax=ax2)\n\n        line1 = ax1.lines[0]\n        line2 = ax2.lines[0]\n        assert np.array_equal(line1.get_xydata(), line2.get_xydata())\n\n        for bar1, bar2 in zip(ax1.patches, ax2.patches):\n            assert bar1.get_xy() == bar2.get_xy()\n            assert bar1.get_height() == bar2.get_height()\n", "tokens": ["tests", "test_distributions", "py", "testdistplot", "def", "test_distplot_with_nans", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "x_null", "np", "append", "self", "x", "np", "nan", "with", "pytest", "warns", "userwarning", "distplot", "self", "x", "ax", "ax1", "distplot", "x_null", "ax", "ax2", "line1", "ax1", "lines", "0", "line2", "ax2", "lines", "0", "assert", "np", "array_equal", "line1", "get_xydata", "line2", "get_xydata", "for", "bar1", "bar2", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "bar1", "get_xy", "bar2", "get_xy", "assert", "bar1", "get_height", "bar2", "get_height"], "doc_len": 67}
{"doc_id": "tests/test_distributions.py::SharedAxesLevelTests.test_color", "file_path": "tests/test_distributions.py", "class_name": "SharedAxesLevelTests", "func_name": "test_color", "text": "文件路径: tests/test_distributions.py, 类名: SharedAxesLevelTests\n    def test_color(self, long_df, **kwargs):\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"y\", ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), \"C0\", check_alpha=False)\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"y\", ax=ax, **kwargs)\n        self.func(data=long_df, x=\"y\", ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), \"C1\", check_alpha=False)\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"y\", color=\"C2\", ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), \"C2\", check_alpha=False)\n", "tokens": ["tests", "test_distributions", "py", "sharedaxesleveltests", "def", "test_color", "self", "long_df", "kwargs", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "y", "ax", "ax", "kwargs", "assert_colors_equal", "self", "get_last_color", "ax", "kwargs", "c0", "check_alpha", "false", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "y", "ax", "ax", "kwargs", "self", "func", "data", "long_df", "x", "y", "ax", "ax", "kwargs", "assert_colors_equal", "self", "get_last_color", "ax", "kwargs", "c1", "check_alpha", "false", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "y", "color", "c2", "ax", "ax", "kwargs", "assert_colors_equal", "self", "get_last_color", "ax", "kwargs", "c2", "check_alpha", "false"], "doc_len": 83}
{"doc_id": "tests/test_distributions.py::TestRugPlot.get_last_color", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "get_last_color", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def get_last_color(self, ax, **kwargs):\n\n        return ax.collections[-1].get_color()\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "get_last_color", "self", "ax", "kwargs", "return", "ax", "collections", "1", "get_color"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestRugPlot.assert_rug_equal", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "assert_rug_equal", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def assert_rug_equal(self, a, b):\n\n        assert_array_equal(a.get_segments(), b.get_segments())\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "assert_rug_equal", "self", "a", "b", "assert_array_equal", "a", "get_segments", "b", "get_segments"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_long_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_long_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_long_data(self, long_df, variable):\n\n        vector = long_df[variable]\n        vectors = [\n            variable, vector, np.asarray(vector), vector.to_list(),\n        ]\n\n        f, ax = plt.subplots()\n        for vector in vectors:\n            rugplot(data=long_df, **{variable: vector})\n\n        for a, b in itertools.product(ax.collections, ax.collections):\n            self.assert_rug_equal(a, b)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_long_data", "self", "long_df", "variable", "vector", "long_df", "variable", "vectors", "variable", "vector", "np", "asarray", "vector", "vector", "to_list", "f", "ax", "plt", "subplots", "for", "vector", "in", "vectors", "rugplot", "data", "long_df", "variable", "vector", "for", "a", "b", "in", "itertools", "product", "ax", "collections", "ax", "collections", "self", "assert_rug_equal", "a", "b"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_bivariate_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_bivariate_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_bivariate_data(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        rugplot(data=long_df, x=\"x\", y=\"y\", ax=ax1)\n        rugplot(data=long_df, x=\"x\", ax=ax2)\n        rugplot(data=long_df, y=\"y\", ax=ax2)\n\n        self.assert_rug_equal(ax1.collections[0], ax2.collections[0])\n        self.assert_rug_equal(ax1.collections[1], ax2.collections[1])\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_bivariate_data", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "rugplot", "data", "long_df", "x", "x", "y", "y", "ax", "ax1", "rugplot", "data", "long_df", "x", "x", "ax", "ax2", "rugplot", "data", "long_df", "y", "y", "ax", "ax2", "self", "assert_rug_equal", "ax1", "collections", "0", "ax2", "collections", "0", "self", "assert_rug_equal", "ax1", "collections", "1", "ax2", "collections", "1"], "doc_len": 54}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_wide_vs_long_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_wide_vs_long_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_wide_vs_long_data(self, wide_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        rugplot(data=wide_df, ax=ax1)\n        for col in wide_df:\n            rugplot(data=wide_df, x=col, ax=ax2)\n\n        wide_segments = np.sort(\n            np.array(ax1.collections[0].get_segments())\n        )\n        long_segments = np.sort(\n            np.concatenate([c.get_segments() for c in ax2.collections])\n        )\n\n        assert_array_equal(wide_segments, long_segments)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_wide_vs_long_data", "self", "wide_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "rugplot", "data", "wide_df", "ax", "ax1", "for", "col", "in", "wide_df", "rugplot", "data", "wide_df", "x", "col", "ax", "ax2", "wide_segments", "np", "sort", "np", "array", "ax1", "collections", "0", "get_segments", "long_segments", "np", "sort", "np", "concatenate", "c", "get_segments", "for", "c", "in", "ax2", "collections", "assert_array_equal", "wide_segments", "long_segments"], "doc_len": 55}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_flat_vector", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_flat_vector", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_flat_vector(self, long_df):\n\n        f, ax = plt.subplots()\n        rugplot(data=long_df[\"x\"])\n        rugplot(x=long_df[\"x\"])\n        self.assert_rug_equal(*ax.collections)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_flat_vector", "self", "long_df", "f", "ax", "plt", "subplots", "rugplot", "data", "long_df", "x", "rugplot", "x", "long_df", "x", "self", "assert_rug_equal", "ax", "collections"], "doc_len": 24}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_datetime_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_datetime_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_datetime_data(self, long_df):\n\n        ax = rugplot(data=long_df[\"t\"])\n        vals = np.stack(ax.collections[0].get_segments())[:, 0, 0]\n        assert_array_equal(vals, mpl.dates.date2num(long_df[\"t\"]))\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_datetime_data", "self", "long_df", "ax", "rugplot", "data", "long_df", "t", "vals", "np", "stack", "ax", "collections", "0", "get_segments", "0", "0", "assert_array_equal", "vals", "mpl", "dates", "date2num", "long_df", "t"], "doc_len": 29}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_empty_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_empty_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_empty_data(self):\n\n        ax = rugplot(x=[])\n        assert not ax.collections\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_empty_data", "self", "ax", "rugplot", "x", "assert", "not", "ax", "collections"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_a_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_a_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_a_deprecation(self, flat_series):\n\n        f, ax = plt.subplots()\n\n        with pytest.warns(UserWarning):\n            rugplot(a=flat_series)\n        rugplot(x=flat_series)\n\n        self.assert_rug_equal(*ax.collections)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_a_deprecation", "self", "flat_series", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "userwarning", "rugplot", "a", "flat_series", "rugplot", "x", "flat_series", "self", "assert_rug_equal", "ax", "collections"], "doc_len": 26}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_axis_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_axis_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_axis_deprecation(self, flat_series, variable):\n\n        f, ax = plt.subplots()\n\n        with pytest.warns(UserWarning):\n            rugplot(flat_series, axis=variable)\n        rugplot(**{variable: flat_series})\n\n        self.assert_rug_equal(*ax.collections)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_axis_deprecation", "self", "flat_series", "variable", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "userwarning", "rugplot", "flat_series", "axis", "variable", "rugplot", "variable", "flat_series", "self", "assert_rug_equal", "ax", "collections"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_vertical_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_vertical_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_vertical_deprecation(self, flat_series):\n\n        f, ax = plt.subplots()\n\n        with pytest.warns(UserWarning):\n            rugplot(flat_series, vertical=True)\n        rugplot(y=flat_series)\n\n        self.assert_rug_equal(*ax.collections)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_vertical_deprecation", "self", "flat_series", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "userwarning", "rugplot", "flat_series", "vertical", "true", "rugplot", "y", "flat_series", "self", "assert_rug_equal", "ax", "collections"], "doc_len": 27}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_rug_data", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_rug_data", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_rug_data(self, flat_array):\n\n        height = .05\n        ax = rugplot(x=flat_array, height=height)\n        segments = np.stack(ax.collections[0].get_segments())\n\n        n = flat_array.size\n        assert_array_equal(segments[:, 0, 1], np.zeros(n))\n        assert_array_equal(segments[:, 1, 1], np.full(n, height))\n        assert_array_equal(segments[:, 1, 0], flat_array)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_rug_data", "self", "flat_array", "height", "05", "ax", "rugplot", "x", "flat_array", "height", "height", "segments", "np", "stack", "ax", "collections", "0", "get_segments", "n", "flat_array", "size", "assert_array_equal", "segments", "0", "1", "np", "zeros", "n", "assert_array_equal", "segments", "1", "1", "np", "full", "n", "height", "assert_array_equal", "segments", "1", "0", "flat_array"], "doc_len": 46}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_rug_colors", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_rug_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_rug_colors(self, long_df):\n\n        ax = rugplot(data=long_df, x=\"x\", hue=\"a\")\n\n        order = categorical_order(long_df[\"a\"])\n        palette = color_palette()\n\n        expected_colors = np.ones((len(long_df), 4))\n        for i, val in enumerate(long_df[\"a\"]):\n            expected_colors[i, :3] = palette[order.index(val)]\n\n        assert_array_equal(ax.collections[0].get_color(), expected_colors)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_rug_colors", "self", "long_df", "ax", "rugplot", "data", "long_df", "x", "x", "hue", "a", "order", "categorical_order", "long_df", "a", "palette", "color_palette", "expected_colors", "np", "ones", "len", "long_df", "4", "for", "i", "val", "in", "enumerate", "long_df", "a", "expected_colors", "i", "3", "palette", "order", "index", "val", "assert_array_equal", "ax", "collections", "0", "get_color", "expected_colors"], "doc_len": 48}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_expand_margins", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_expand_margins", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_expand_margins(self, flat_array):\n\n        f, ax = plt.subplots()\n        x1, y1 = ax.margins()\n        rugplot(x=flat_array, expand_margins=False)\n        x2, y2 = ax.margins()\n        assert x1 == x2\n        assert y1 == y2\n\n        f, ax = plt.subplots()\n        x1, y1 = ax.margins()\n        height = .05\n        rugplot(x=flat_array, height=height)\n        x2, y2 = ax.margins()\n        assert x1 == x2\n        assert y1 + height * 2 == pytest.approx(y2)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_expand_margins", "self", "flat_array", "f", "ax", "plt", "subplots", "x1", "y1", "ax", "margins", "rugplot", "x", "flat_array", "expand_margins", "false", "x2", "y2", "ax", "margins", "assert", "x1", "x2", "assert", "y1", "y2", "f", "ax", "plt", "subplots", "x1", "y1", "ax", "margins", "height", "05", "rugplot", "x", "flat_array", "height", "height", "x2", "y2", "ax", "margins", "assert", "x1", "x2", "assert", "y1", "height", "2", "pytest", "approx", "y2"], "doc_len": 60}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_multiple_rugs", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_multiple_rugs", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_multiple_rugs(self):\n\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n\n        rugplot(x=values, ax=ax, expand_margins=False)\n\n        assert ylim == ax.get_ylim()\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_multiple_rugs", "self", "values", "np", "linspace", "start", "0", "stop", "1", "num", "5", "ax", "rugplot", "x", "values", "ylim", "ax", "get_ylim", "rugplot", "x", "values", "ax", "ax", "expand_margins", "false", "assert", "ylim", "ax", "get_ylim"], "doc_len": 34}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_matplotlib_kwargs", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_matplotlib_kwargs", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_matplotlib_kwargs(self, flat_series):\n\n        lw = 2\n        alpha = .2\n        ax = rugplot(y=flat_series, linewidth=lw, alpha=alpha)\n        rug = ax.collections[0]\n        assert np.all(rug.get_alpha() == alpha)\n        assert np.all(rug.get_linewidth() == lw)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_matplotlib_kwargs", "self", "flat_series", "lw", "2", "alpha", "2", "ax", "rugplot", "y", "flat_series", "linewidth", "lw", "alpha", "alpha", "rug", "ax", "collections", "0", "assert", "np", "all", "rug", "get_alpha", "alpha", "assert", "np", "all", "rug", "get_linewidth", "lw"], "doc_len": 36}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_axis_labels", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_axis_labels", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_axis_labels(self, flat_series):\n\n        ax = rugplot(x=flat_series)\n        assert ax.get_xlabel() == flat_series.name\n        assert not ax.get_ylabel()\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_axis_labels", "self", "flat_series", "ax", "rugplot", "x", "flat_series", "assert", "ax", "get_xlabel", "flat_series", "name", "assert", "not", "ax", "get_ylabel"], "doc_len": 21}
{"doc_id": "tests/test_distributions.py::TestRugPlot.test_log_scale", "file_path": "tests/test_distributions.py", "class_name": "TestRugPlot", "func_name": "test_log_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestRugPlot\n    def test_log_scale(self, long_df):\n\n        ax1, ax2 = plt.figure().subplots(2)\n\n        ax2.set_xscale(\"log\")\n\n        rugplot(data=long_df, x=\"z\", ax=ax1)\n        rugplot(data=long_df, x=\"z\", ax=ax2)\n\n        rug1 = np.stack(ax1.collections[0].get_segments())\n        rug2 = np.stack(ax2.collections[0].get_segments())\n\n        assert_array_almost_equal(rug1, rug2)\n", "tokens": ["tests", "test_distributions", "py", "testrugplot", "def", "test_log_scale", "self", "long_df", "ax1", "ax2", "plt", "figure", "subplots", "2", "ax2", "set_xscale", "log", "rugplot", "data", "long_df", "x", "z", "ax", "ax1", "rugplot", "data", "long_df", "x", "z", "ax", "ax2", "rug1", "np", "stack", "ax1", "collections", "0", "get_segments", "rug2", "np", "stack", "ax2", "collections", "0", "get_segments", "assert_array_almost_equal", "rug1", "rug2"], "doc_len": 48}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.get_last_color", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "get_last_color", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def get_last_color(self, ax, fill=True):\n\n        if fill:\n            return ax.collections[-1].get_facecolor()\n        else:\n            return ax.lines[-1].get_color()\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "get_last_color", "self", "ax", "fill", "true", "if", "fill", "return", "ax", "collections", "1", "get_facecolor", "else", "return", "ax", "lines", "1", "get_color"], "doc_len": 23}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_color", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_color", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_color(self, long_df, fill):\n\n        super().test_color(long_df, fill=fill)\n\n        if fill:\n\n            ax = plt.figure().subplots()\n            self.func(data=long_df, x=\"y\", facecolor=\"C3\", fill=True, ax=ax)\n            assert_colors_equal(self.get_last_color(ax), \"C3\", check_alpha=False)\n\n            ax = plt.figure().subplots()\n            self.func(data=long_df, x=\"y\", fc=\"C4\", fill=True, ax=ax)\n            assert_colors_equal(self.get_last_color(ax), \"C4\", check_alpha=False)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_color", "self", "long_df", "fill", "super", "test_color", "long_df", "fill", "fill", "if", "fill", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "y", "facecolor", "c3", "fill", "true", "ax", "ax", "assert_colors_equal", "self", "get_last_color", "ax", "c3", "check_alpha", "false", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "y", "fc", "c4", "fill", "true", "ax", "ax", "assert_colors_equal", "self", "get_last_color", "ax", "c4", "check_alpha", "false"], "doc_len": 62}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_long_vectors", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_long_vectors", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_long_vectors(self, long_df, variable):\n\n        vector = long_df[variable]\n        vectors = [\n            variable, vector, vector.to_numpy(), vector.to_list(),\n        ]\n\n        f, ax = plt.subplots()\n        for vector in vectors:\n            kdeplot(data=long_df, **{variable: vector})\n\n        xdata = [l.get_xdata() for l in ax.lines]\n        for a, b in itertools.product(xdata, xdata):\n            assert_array_equal(a, b)\n\n        ydata = [l.get_ydata() for l in ax.lines]\n        for a, b in itertools.product(ydata, ydata):\n            assert_array_equal(a, b)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_long_vectors", "self", "long_df", "variable", "vector", "long_df", "variable", "vectors", "variable", "vector", "vector", "to_numpy", "vector", "to_list", "f", "ax", "plt", "subplots", "for", "vector", "in", "vectors", "kdeplot", "data", "long_df", "variable", "vector", "xdata", "l", "get_xdata", "for", "l", "in", "ax", "lines", "for", "a", "b", "in", "itertools", "product", "xdata", "xdata", "assert_array_equal", "a", "b", "ydata", "l", "get_ydata", "for", "l", "in", "ax", "lines", "for", "a", "b", "in", "itertools", "product", "ydata", "ydata", "assert_array_equal", "a", "b"], "doc_len": 70}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_wide_vs_long_data", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_wide_vs_long_data", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_wide_vs_long_data(self, wide_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        kdeplot(data=wide_df, ax=ax1, common_norm=False, common_grid=False)\n        for col in wide_df:\n            kdeplot(data=wide_df, x=col, ax=ax2)\n\n        for l1, l2 in zip(ax1.lines[::-1], ax2.lines):\n            assert_array_equal(l1.get_xydata(), l2.get_xydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_wide_vs_long_data", "self", "wide_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "wide_df", "ax", "ax1", "common_norm", "false", "common_grid", "false", "for", "col", "in", "wide_df", "kdeplot", "data", "wide_df", "x", "col", "ax", "ax2", "for", "l1", "l2", "in", "zip", "ax1", "lines", "1", "ax2", "lines", "assert_array_equal", "l1", "get_xydata", "l2", "get_xydata"], "doc_len": 50}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_flat_vector", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_flat_vector", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_flat_vector(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df[\"x\"])\n        kdeplot(x=long_df[\"x\"])\n        assert_array_equal(ax.lines[0].get_xydata(), ax.lines[1].get_xydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_flat_vector", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "kdeplot", "x", "long_df", "x", "assert_array_equal", "ax", "lines", "0", "get_xydata", "ax", "lines", "1", "get_xydata"], "doc_len": 29}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_empty_data", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_empty_data", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_empty_data(self):\n\n        ax = kdeplot(x=[])\n        assert not ax.lines\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_empty_data", "self", "ax", "kdeplot", "x", "assert", "not", "ax", "lines"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_singular_data", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_singular_data", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_singular_data(self):\n\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n\n        with pytest.warns(UserWarning):\n            # https://github.com/mwaskom/seaborn/issues/2762\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\", UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_singular_data", "self", "with", "pytest", "warns", "userwarning", "ax", "kdeplot", "x", "np", "ones", "10", "assert", "not", "ax", "lines", "with", "pytest", "warns", "userwarning", "ax", "kdeplot", "x", "5", "assert", "not", "ax", "lines", "with", "pytest", "warns", "userwarning", "https", "github", "com", "mwaskom", "seaborn", "issues", "2762", "ax", "kdeplot", "x", "1929245168", "06679", "18", "assert", "not", "ax", "lines", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "userwarning", "ax", "kdeplot", "x", "5", "warn_singular", "false", "assert", "not", "ax", "lines"], "doc_len": 71}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_variable_assignment", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_variable_assignment", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_variable_assignment(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, x=\"x\", fill=True)\n        kdeplot(data=long_df, y=\"x\", fill=True)\n\n        v0 = ax.collections[0].get_paths()[0].vertices\n        v1 = ax.collections[1].get_paths()[0].vertices[:, [1, 0]]\n\n        assert_array_equal(v0, v1)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_variable_assignment", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "fill", "true", "kdeplot", "data", "long_df", "y", "x", "fill", "true", "v0", "ax", "collections", "0", "get_paths", "0", "vertices", "v1", "ax", "collections", "1", "get_paths", "0", "vertices", "1", "0", "assert_array_equal", "v0", "v1"], "doc_len": 45}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_vertical_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_vertical_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_vertical_deprecation(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, y=\"x\")\n\n        with pytest.warns(UserWarning):\n            kdeplot(data=long_df, x=\"x\", vertical=True)\n\n        assert_array_equal(ax.lines[0].get_xydata(), ax.lines[1].get_xydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_vertical_deprecation", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "y", "x", "with", "pytest", "warns", "userwarning", "kdeplot", "data", "long_df", "x", "x", "vertical", "true", "assert_array_equal", "ax", "lines", "0", "get_xydata", "ax", "lines", "1", "get_xydata"], "doc_len": 37}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_bw_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_bw_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_bw_deprecation(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, x=\"x\", bw_method=\"silverman\")\n\n        with pytest.warns(UserWarning):\n            kdeplot(data=long_df, x=\"x\", bw=\"silverman\")\n\n        assert_array_equal(ax.lines[0].get_xydata(), ax.lines[1].get_xydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_bw_deprecation", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "bw_method", "silverman", "with", "pytest", "warns", "userwarning", "kdeplot", "data", "long_df", "x", "x", "bw", "silverman", "assert_array_equal", "ax", "lines", "0", "get_xydata", "ax", "lines", "1", "get_xydata"], "doc_len": 39}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_kernel_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_kernel_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_kernel_deprecation(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, x=\"x\")\n\n        with pytest.warns(UserWarning):\n            kdeplot(data=long_df, x=\"x\", kernel=\"epi\")\n\n        assert_array_equal(ax.lines[0].get_xydata(), ax.lines[1].get_xydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_kernel_deprecation", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "with", "pytest", "warns", "userwarning", "kdeplot", "data", "long_df", "x", "x", "kernel", "epi", "assert_array_equal", "ax", "lines", "0", "get_xydata", "ax", "lines", "1", "get_xydata"], "doc_len": 37}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_shade_deprecation", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_shade_deprecation", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_shade_deprecation(self, long_df):\n\n        f, ax = plt.subplots()\n        with pytest.warns(FutureWarning):\n            kdeplot(data=long_df, x=\"x\", shade=True)\n        kdeplot(data=long_df, x=\"x\", fill=True)\n        fill1, fill2 = ax.collections\n        assert_array_equal(\n            fill1.get_paths()[0].vertices, fill2.get_paths()[0].vertices\n        )\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_shade_deprecation", "self", "long_df", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "futurewarning", "kdeplot", "data", "long_df", "x", "x", "shade", "true", "kdeplot", "data", "long_df", "x", "x", "fill", "true", "fill1", "fill2", "ax", "collections", "assert_array_equal", "fill1", "get_paths", "0", "vertices", "fill2", "get_paths", "0", "vertices"], "doc_len": 43}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_hue_colors", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_hue_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_hue_colors(self, long_df, multiple):\n\n        ax = kdeplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=multiple,\n            fill=True, legend=False\n        )\n\n        # Note that hue order is reversed in the plot\n        lines = ax.lines[::-1]\n        fills = ax.collections[::-1]\n\n        palette = color_palette()\n\n        for line, fill, color in zip(lines, fills, palette):\n            assert_colors_equal(line.get_color(), color)\n            assert_colors_equal(fill.get_facecolor(), to_rgba(color, .25))\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_hue_colors", "self", "long_df", "multiple", "ax", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "multiple", "fill", "true", "legend", "false", "note", "that", "hue", "order", "is", "reversed", "in", "the", "plot", "lines", "ax", "lines", "1", "fills", "ax", "collections", "1", "palette", "color_palette", "for", "line", "fill", "color", "in", "zip", "lines", "fills", "palette", "assert_colors_equal", "line", "get_color", "color", "assert_colors_equal", "fill", "get_facecolor", "to_rgba", "color", "25"], "doc_len": 61}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_hue_stacking", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_hue_stacking", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_hue_stacking(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=\"layer\", common_grid=True,\n            legend=False, ax=ax1,\n        )\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=\"stack\", fill=False,\n            legend=False, ax=ax2,\n        )\n\n        layered_densities = np.stack([\n            l.get_ydata() for l in ax1.lines\n        ])\n        stacked_densities = np.stack([\n            l.get_ydata() for l in ax2.lines\n        ])\n\n        assert_array_equal(layered_densities.cumsum(axis=0), stacked_densities)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_hue_stacking", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "layer", "common_grid", "true", "legend", "false", "ax", "ax1", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "stack", "fill", "false", "legend", "false", "ax", "ax2", "layered_densities", "np", "stack", "l", "get_ydata", "for", "l", "in", "ax1", "lines", "stacked_densities", "np", "stack", "l", "get_ydata", "for", "l", "in", "ax2", "lines", "assert_array_equal", "layered_densities", "cumsum", "axis", "0", "stacked_densities"], "doc_len": 71}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_hue_filling", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_hue_filling", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_hue_filling(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=\"layer\", common_grid=True,\n            legend=False, ax=ax1,\n        )\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=\"fill\", fill=False,\n            legend=False, ax=ax2,\n        )\n\n        layered = np.stack([l.get_ydata() for l in ax1.lines])\n        filled = np.stack([l.get_ydata() for l in ax2.lines])\n\n        assert_array_almost_equal(\n            (layered / layered.sum(axis=0)).cumsum(axis=0),\n            filled,\n        )\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_hue_filling", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "layer", "common_grid", "true", "legend", "false", "ax", "ax1", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "fill", "fill", "false", "legend", "false", "ax", "ax2", "layered", "np", "stack", "l", "get_ydata", "for", "l", "in", "ax1", "lines", "filled", "np", "stack", "l", "get_ydata", "for", "l", "in", "ax2", "lines", "assert_array_almost_equal", "layered", "layered", "sum", "axis", "0", "cumsum", "axis", "0", "filled"], "doc_len": 75}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_fill_default", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_fill_default", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_fill_default(self, long_df, multiple):\n\n        ax = kdeplot(\n            data=long_df, x=\"x\", hue=\"a\", multiple=multiple, fill=None\n        )\n\n        assert len(ax.collections) > 0\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_fill_default", "self", "long_df", "multiple", "ax", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "multiple", "fill", "none", "assert", "len", "ax", "collections", "0"], "doc_len": 26}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_fill_nondefault", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_fill_nondefault", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_fill_nondefault(self, long_df, multiple):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kws = dict(data=long_df, x=\"x\", hue=\"a\")\n        kdeplot(**kws, multiple=multiple, fill=False, ax=ax1)\n        kdeplot(**kws, multiple=multiple, fill=True, ax=ax2)\n\n        assert len(ax1.collections) == 0\n        assert len(ax2.collections) > 0\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_fill_nondefault", "self", "long_df", "multiple", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kws", "dict", "data", "long_df", "x", "x", "hue", "a", "kdeplot", "kws", "multiple", "multiple", "fill", "false", "ax", "ax1", "kdeplot", "kws", "multiple", "multiple", "fill", "true", "ax", "ax2", "assert", "len", "ax1", "collections", "0", "assert", "len", "ax2", "collections", "0"], "doc_len": 50}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_color_cycle_interaction", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_color_cycle_interaction", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_color_cycle_interaction(self, flat_series):\n\n        color = (.2, 1, .6)\n\n        f, ax = plt.subplots()\n        kdeplot(flat_series)\n        kdeplot(flat_series)\n        assert_colors_equal(ax.lines[0].get_color(), \"C0\")\n        assert_colors_equal(ax.lines[1].get_color(), \"C1\")\n        plt.close(f)\n\n        f, ax = plt.subplots()\n        kdeplot(flat_series, color=color)\n        kdeplot(flat_series)\n        assert_colors_equal(ax.lines[0].get_color(), color)\n        assert_colors_equal(ax.lines[1].get_color(), \"C0\")\n        plt.close(f)\n\n        f, ax = plt.subplots()\n        kdeplot(flat_series, fill=True)\n        kdeplot(flat_series, fill=True)\n        assert_colors_equal(ax.collections[0].get_facecolor(), to_rgba(\"C0\", .25))\n        assert_colors_equal(ax.collections[1].get_facecolor(), to_rgba(\"C1\", .25))\n        plt.close(f)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_color_cycle_interaction", "self", "flat_series", "color", "2", "1", "6", "f", "ax", "plt", "subplots", "kdeplot", "flat_series", "kdeplot", "flat_series", "assert_colors_equal", "ax", "lines", "0", "get_color", "c0", "assert_colors_equal", "ax", "lines", "1", "get_color", "c1", "plt", "close", "f", "f", "ax", "plt", "subplots", "kdeplot", "flat_series", "color", "color", "kdeplot", "flat_series", "assert_colors_equal", "ax", "lines", "0", "get_color", "color", "assert_colors_equal", "ax", "lines", "1", "get_color", "c0", "plt", "close", "f", "f", "ax", "plt", "subplots", "kdeplot", "flat_series", "fill", "true", "kdeplot", "flat_series", "fill", "true", "assert_colors_equal", "ax", "collections", "0", "get_facecolor", "to_rgba", "c0", "25", "assert_colors_equal", "ax", "collections", "1", "get_facecolor", "to_rgba", "c1", "25", "plt", "close", "f"], "doc_len": 91}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_artist_color", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_artist_color", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_artist_color(self, long_df, fill):\n\n        color = (.2, 1, .6)\n        alpha = .5\n\n        f, ax = plt.subplots()\n\n        kdeplot(long_df[\"x\"], fill=fill, color=color)\n        if fill:\n            artist_color = ax.collections[-1].get_facecolor().squeeze()\n        else:\n            artist_color = ax.lines[-1].get_color()\n        default_alpha = .25 if fill else 1\n        assert_colors_equal(artist_color, to_rgba(color, default_alpha))\n\n        kdeplot(long_df[\"x\"], fill=fill, color=color, alpha=alpha)\n        if fill:\n            artist_color = ax.collections[-1].get_facecolor().squeeze()\n        else:\n            artist_color = ax.lines[-1].get_color()\n        assert_colors_equal(artist_color, to_rgba(color, alpha))\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_artist_color", "self", "long_df", "fill", "color", "2", "1", "6", "alpha", "5", "f", "ax", "plt", "subplots", "kdeplot", "long_df", "x", "fill", "fill", "color", "color", "if", "fill", "artist_color", "ax", "collections", "1", "get_facecolor", "squeeze", "else", "artist_color", "ax", "lines", "1", "get_color", "default_alpha", "25", "if", "fill", "else", "1", "assert_colors_equal", "artist_color", "to_rgba", "color", "default_alpha", "kdeplot", "long_df", "x", "fill", "fill", "color", "color", "alpha", "alpha", "if", "fill", "artist_color", "ax", "collections", "1", "get_facecolor", "squeeze", "else", "artist_color", "ax", "lines", "1", "get_color", "assert_colors_equal", "artist_color", "to_rgba", "color", "alpha"], "doc_len": 79}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_datetime_scale", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_datetime_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_datetime_scale(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        kdeplot(x=long_df[\"t\"], fill=True, ax=ax1)\n        kdeplot(x=long_df[\"t\"], fill=False, ax=ax2)\n        assert ax1.get_xlim() == ax2.get_xlim()\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_datetime_scale", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "kdeplot", "x", "long_df", "t", "fill", "true", "ax", "ax1", "kdeplot", "x", "long_df", "t", "fill", "false", "ax", "ax2", "assert", "ax1", "get_xlim", "ax2", "get_xlim"], "doc_len": 35}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_multiple_argument_check", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_multiple_argument_check", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_multiple_argument_check(self, long_df):\n\n        with pytest.raises(ValueError, match=\"`multiple` must be\"):\n            kdeplot(data=long_df, x=\"x\", hue=\"a\", multiple=\"bad_input\")\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_multiple_argument_check", "self", "long_df", "with", "pytest", "raises", "valueerror", "match", "multiple", "must", "be", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "bad_input"], "doc_len": 25}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_cut", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_cut", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_cut(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n\n        f, ax = plt.subplots()\n        kdeplot(x=x, cut=0, legend=False)\n\n        xdata_0 = ax.lines[0].get_xdata()\n        assert xdata_0.min() == x.min()\n        assert xdata_0.max() == x.max()\n\n        kdeplot(x=x, cut=2, legend=False)\n\n        xdata_2 = ax.lines[1].get_xdata()\n        assert xdata_2.min() < xdata_0.min()\n        assert xdata_2.max() > xdata_0.max()\n\n        assert len(xdata_0) == len(xdata_2)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_cut", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "f", "ax", "plt", "subplots", "kdeplot", "x", "x", "cut", "0", "legend", "false", "xdata_0", "ax", "lines", "0", "get_xdata", "assert", "xdata_0", "min", "x", "min", "assert", "xdata_0", "max", "x", "max", "kdeplot", "x", "x", "cut", "2", "legend", "false", "xdata_2", "ax", "lines", "1", "get_xdata", "assert", "xdata_2", "min", "xdata_0", "min", "assert", "xdata_2", "max", "xdata_0", "max", "assert", "len", "xdata_0", "len", "xdata_2"], "doc_len": 67}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_clip", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_clip", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_clip(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n\n        clip = -1, 1\n        ax = kdeplot(x=x, clip=clip)\n\n        xdata = ax.lines[0].get_xdata()\n\n        assert xdata.min() >= clip[0]\n        assert xdata.max() <= clip[1]\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_clip", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "clip", "1", "1", "ax", "kdeplot", "x", "x", "clip", "clip", "xdata", "ax", "lines", "0", "get_xdata", "assert", "xdata", "min", "clip", "0", "assert", "xdata", "max", "clip", "1"], "doc_len": 38}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_line_is_density", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_line_is_density", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_line_is_density(self, long_df):\n\n        ax = kdeplot(data=long_df, x=\"x\", cut=5)\n        x, y = ax.lines[0].get_xydata().T\n        assert integrate(y, x) == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_line_is_density", "self", "long_df", "ax", "kdeplot", "data", "long_df", "x", "x", "cut", "5", "x", "y", "ax", "lines", "0", "get_xydata", "t", "assert", "integrate", "y", "x", "pytest", "approx", "1"], "doc_len": 30}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_cumulative", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_cumulative", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_cumulative(self, long_df):\n\n        ax = kdeplot(data=long_df, x=\"x\", cut=5, cumulative=True)\n        y = ax.lines[0].get_ydata()\n        assert y[0] == pytest.approx(0)\n        assert y[-1] == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_cumulative", "self", "long_df", "ax", "kdeplot", "data", "long_df", "x", "x", "cut", "5", "cumulative", "true", "y", "ax", "lines", "0", "get_ydata", "assert", "y", "0", "pytest", "approx", "0", "assert", "y", "1", "pytest", "approx", "1"], "doc_len": 35}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_cumulative_requires_scipy", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_cumulative_requires_scipy", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_cumulative_requires_scipy(self, long_df):\n\n        with pytest.raises(RuntimeError):\n            kdeplot(data=long_df, x=\"x\", cut=5, cumulative=True)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_cumulative_requires_scipy", "self", "long_df", "with", "pytest", "raises", "runtimeerror", "kdeplot", "data", "long_df", "x", "x", "cut", "5", "cumulative", "true"], "doc_len": 21}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_common_norm", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_common_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_common_norm(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"c\", common_norm=True, cut=10, ax=ax1\n        )\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"c\", common_norm=False, cut=10, ax=ax2\n        )\n\n        total_area = 0\n        for line in ax1.lines:\n            xdata, ydata = line.get_xydata().T\n            total_area += integrate(ydata, xdata)\n        assert total_area == pytest.approx(1)\n\n        for line in ax2.lines:\n            xdata, ydata = line.get_xydata().T\n            assert integrate(ydata, xdata) == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_common_norm", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "long_df", "x", "x", "hue", "c", "common_norm", "true", "cut", "10", "ax", "ax1", "kdeplot", "data", "long_df", "x", "x", "hue", "c", "common_norm", "false", "cut", "10", "ax", "ax2", "total_area", "0", "for", "line", "in", "ax1", "lines", "xdata", "ydata", "line", "get_xydata", "t", "total_area", "integrate", "ydata", "xdata", "assert", "total_area", "pytest", "approx", "1", "for", "line", "in", "ax2", "lines", "xdata", "ydata", "line", "get_xydata", "t", "assert", "integrate", "ydata", "xdata", "pytest", "approx", "1"], "doc_len": 79}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_common_grid", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_common_grid", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_common_grid(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        order = \"a\", \"b\", \"c\"\n\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\", hue_order=order,\n            common_grid=False, cut=0, ax=ax1,\n        )\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\", hue_order=order,\n            common_grid=True, cut=0, ax=ax2,\n        )\n\n        for line, level in zip(ax1.lines[::-1], order):\n            xdata = line.get_xdata()\n            assert xdata.min() == long_df.loc[long_df[\"a\"] == level, \"x\"].min()\n            assert xdata.max() == long_df.loc[long_df[\"a\"] == level, \"x\"].max()\n\n        for line in ax2.lines:\n            xdata = line.get_xdata().T\n            assert xdata.min() == long_df[\"x\"].min()\n            assert xdata.max() == long_df[\"x\"].max()\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_common_grid", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "order", "a", "b", "c", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "hue_order", "order", "common_grid", "false", "cut", "0", "ax", "ax1", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "hue_order", "order", "common_grid", "true", "cut", "0", "ax", "ax2", "for", "line", "level", "in", "zip", "ax1", "lines", "1", "order", "xdata", "line", "get_xdata", "assert", "xdata", "min", "long_df", "loc", "long_df", "a", "level", "x", "min", "assert", "xdata", "max", "long_df", "loc", "long_df", "a", "level", "x", "max", "for", "line", "in", "ax2", "lines", "xdata", "line", "get_xdata", "t", "assert", "xdata", "min", "long_df", "x", "min", "assert", "xdata", "max", "long_df", "x", "max"], "doc_len": 102}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_bw_method", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_bw_method", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_bw_method(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, x=\"x\", bw_method=0.2, legend=False)\n        kdeplot(data=long_df, x=\"x\", bw_method=1.0, legend=False)\n        kdeplot(data=long_df, x=\"x\", bw_method=3.0, legend=False)\n\n        l1, l2, l3 = ax.lines\n\n        assert (\n            np.abs(np.diff(l1.get_ydata())).mean()\n            > np.abs(np.diff(l2.get_ydata())).mean()\n        )\n\n        assert (\n            np.abs(np.diff(l2.get_ydata())).mean()\n            > np.abs(np.diff(l3.get_ydata())).mean()\n        )\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_bw_method", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "bw_method", "0", "2", "legend", "false", "kdeplot", "data", "long_df", "x", "x", "bw_method", "1", "0", "legend", "false", "kdeplot", "data", "long_df", "x", "x", "bw_method", "3", "0", "legend", "false", "l1", "l2", "l3", "ax", "lines", "assert", "np", "abs", "np", "diff", "l1", "get_ydata", "mean", "np", "abs", "np", "diff", "l2", "get_ydata", "mean", "assert", "np", "abs", "np", "diff", "l2", "get_ydata", "mean", "np", "abs", "np", "diff", "l3", "get_ydata", "mean"], "doc_len": 77}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_bw_adjust", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_bw_adjust", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_bw_adjust(self, long_df):\n\n        f, ax = plt.subplots()\n        kdeplot(data=long_df, x=\"x\", bw_adjust=0.2, legend=False)\n        kdeplot(data=long_df, x=\"x\", bw_adjust=1.0, legend=False)\n        kdeplot(data=long_df, x=\"x\", bw_adjust=3.0, legend=False)\n\n        l1, l2, l3 = ax.lines\n\n        assert (\n            np.abs(np.diff(l1.get_ydata())).mean()\n            > np.abs(np.diff(l2.get_ydata())).mean()\n        )\n\n        assert (\n            np.abs(np.diff(l2.get_ydata())).mean()\n            > np.abs(np.diff(l3.get_ydata())).mean()\n        )\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_bw_adjust", "self", "long_df", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "bw_adjust", "0", "2", "legend", "false", "kdeplot", "data", "long_df", "x", "x", "bw_adjust", "1", "0", "legend", "false", "kdeplot", "data", "long_df", "x", "x", "bw_adjust", "3", "0", "legend", "false", "l1", "l2", "l3", "ax", "lines", "assert", "np", "abs", "np", "diff", "l1", "get_ydata", "mean", "np", "abs", "np", "diff", "l2", "get_ydata", "mean", "assert", "np", "abs", "np", "diff", "l2", "get_ydata", "mean", "np", "abs", "np", "diff", "l3", "get_ydata", "mean"], "doc_len": 77}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_log_scale_implicit", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_log_scale_implicit", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_log_scale_implicit(self, rng):\n\n        x = rng.lognormal(0, 1, 100)\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        ax1.set_xscale(\"log\")\n\n        kdeplot(x=x, ax=ax1)\n        kdeplot(x=x, ax=ax1)\n\n        xdata_log = ax1.lines[0].get_xdata()\n        assert (xdata_log > 0).all()\n        assert (np.diff(xdata_log, 2) > 0).all()\n        assert np.allclose(np.diff(np.log(xdata_log), 2), 0)\n\n        f, ax = plt.subplots()\n        ax.set_yscale(\"log\")\n        kdeplot(y=x, ax=ax)\n        assert_array_equal(ax.lines[0].get_xdata(), ax1.lines[0].get_ydata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_log_scale_implicit", "self", "rng", "x", "rng", "lognormal", "0", "1", "100", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "ax1", "set_xscale", "log", "kdeplot", "x", "x", "ax", "ax1", "kdeplot", "x", "x", "ax", "ax1", "xdata_log", "ax1", "lines", "0", "get_xdata", "assert", "xdata_log", "0", "all", "assert", "np", "diff", "xdata_log", "2", "0", "all", "assert", "np", "allclose", "np", "diff", "np", "log", "xdata_log", "2", "0", "f", "ax", "plt", "subplots", "ax", "set_yscale", "log", "kdeplot", "y", "x", "ax", "ax", "assert_array_equal", "ax", "lines", "0", "get_xdata", "ax1", "lines", "0", "get_ydata"], "doc_len": 81}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_log_scale_explicit", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_log_scale_explicit", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_log_scale_explicit(self, rng):\n\n        x = rng.lognormal(0, 1, 100)\n\n        f, (ax1, ax2, ax3) = plt.subplots(ncols=3)\n\n        ax1.set_xscale(\"log\")\n        kdeplot(x=x, ax=ax1)\n        kdeplot(x=x, log_scale=True, ax=ax2)\n        kdeplot(x=x, log_scale=10, ax=ax3)\n\n        for ax in f.axes:\n            assert ax.get_xscale() == \"log\"\n\n        supports = [ax.lines[0].get_xdata() for ax in f.axes]\n        for a, b in itertools.product(supports, supports):\n            assert_array_equal(a, b)\n\n        densities = [ax.lines[0].get_ydata() for ax in f.axes]\n        for a, b in itertools.product(densities, densities):\n            assert_array_equal(a, b)\n\n        f, ax = plt.subplots()\n        kdeplot(y=x, log_scale=True, ax=ax)\n        assert ax.get_yscale() == \"log\"\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_log_scale_explicit", "self", "rng", "x", "rng", "lognormal", "0", "1", "100", "f", "ax1", "ax2", "ax3", "plt", "subplots", "ncols", "3", "ax1", "set_xscale", "log", "kdeplot", "x", "x", "ax", "ax1", "kdeplot", "x", "x", "log_scale", "true", "ax", "ax2", "kdeplot", "x", "x", "log_scale", "10", "ax", "ax3", "for", "ax", "in", "f", "axes", "assert", "ax", "get_xscale", "log", "supports", "ax", "lines", "0", "get_xdata", "for", "ax", "in", "f", "axes", "for", "a", "b", "in", "itertools", "product", "supports", "supports", "assert_array_equal", "a", "b", "densities", "ax", "lines", "0", "get_ydata", "for", "ax", "in", "f", "axes", "for", "a", "b", "in", "itertools", "product", "densities", "densities", "assert_array_equal", "a", "b", "f", "ax", "plt", "subplots", "kdeplot", "y", "x", "log_scale", "true", "ax", "ax", "assert", "ax", "get_yscale", "log"], "doc_len": 110}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_log_scale_with_hue", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_log_scale_with_hue", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_log_scale_with_hue(self, rng):\n\n        data = rng.lognormal(0, 1, 50), rng.lognormal(0, 2, 100)\n        ax = kdeplot(data=data, log_scale=True, common_grid=True)\n        assert_array_equal(ax.lines[0].get_xdata(), ax.lines[1].get_xdata())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_log_scale_with_hue", "self", "rng", "data", "rng", "lognormal", "0", "1", "50", "rng", "lognormal", "0", "2", "100", "ax", "kdeplot", "data", "data", "log_scale", "true", "common_grid", "true", "assert_array_equal", "ax", "lines", "0", "get_xdata", "ax", "lines", "1", "get_xdata"], "doc_len": 36}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_log_scale_normalization", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_log_scale_normalization", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_log_scale_normalization(self, rng):\n\n        x = rng.lognormal(0, 1, 100)\n        ax = kdeplot(x=x, log_scale=True, cut=10)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        integral = integrate(ydata, np.log10(xdata))\n        assert integral == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_log_scale_normalization", "self", "rng", "x", "rng", "lognormal", "0", "1", "100", "ax", "kdeplot", "x", "x", "log_scale", "true", "cut", "10", "xdata", "ydata", "ax", "lines", "0", "get_xydata", "t", "integral", "integrate", "ydata", "np", "log10", "xdata", "assert", "integral", "pytest", "approx", "1"], "doc_len": 40}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_weights", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_weights", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_weights(self):\n\n        x = [1, 2]\n        weights = [2, 1]\n\n        ax = kdeplot(x=x, weights=weights, bw_method=.1)\n\n        xdata, ydata = ax.lines[0].get_xydata().T\n\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n\n        assert y1 == pytest.approx(2 * y2)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_weights", "self", "x", "1", "2", "weights", "2", "1", "ax", "kdeplot", "x", "x", "weights", "weights", "bw_method", "1", "xdata", "ydata", "ax", "lines", "0", "get_xydata", "t", "y1", "ydata", "np", "abs", "xdata", "1", "argmin", "y2", "ydata", "np", "abs", "xdata", "2", "argmin", "assert", "y1", "pytest", "approx", "2", "y2"], "doc_len": 48}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_weight_norm", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_weight_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_weight_norm(self, rng):\n\n        vals = rng.normal(0, 1, 50)\n        x = np.concatenate([vals, vals])\n        w = np.repeat([1, 2], 50)\n        ax = kdeplot(x=x, weights=w, hue=w, common_norm=True)\n\n        # Recall that artists are added in reverse of hue order\n        x1, y1 = ax.lines[0].get_xydata().T\n        x2, y2 = ax.lines[1].get_xydata().T\n\n        assert integrate(y1, x1) == pytest.approx(2 * integrate(y2, x2))\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_weight_norm", "self", "rng", "vals", "rng", "normal", "0", "1", "50", "x", "np", "concatenate", "vals", "vals", "w", "np", "repeat", "1", "2", "50", "ax", "kdeplot", "x", "x", "weights", "w", "hue", "w", "common_norm", "true", "recall", "that", "artists", "are", "added", "in", "reverse", "of", "hue", "order", "x1", "y1", "ax", "lines", "0", "get_xydata", "t", "x2", "y2", "ax", "lines", "1", "get_xydata", "t", "assert", "integrate", "y1", "x1", "pytest", "approx", "2", "integrate", "y2", "x2"], "doc_len": 69}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_sticky_edges", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_sticky_edges", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_sticky_edges(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(data=long_df, x=\"x\", fill=True, ax=ax1)\n        assert ax1.collections[0].sticky_edges.y[:] == [0, np.inf]\n\n        kdeplot(\n            data=long_df, x=\"x\", hue=\"a\", multiple=\"fill\", fill=True, ax=ax2\n        )\n        assert ax2.collections[0].sticky_edges.y[:] == [0, 1]\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_sticky_edges", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "long_df", "x", "x", "fill", "true", "ax", "ax1", "assert", "ax1", "collections", "0", "sticky_edges", "y", "0", "np", "inf", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "fill", "fill", "true", "ax", "ax2", "assert", "ax2", "collections", "0", "sticky_edges", "y", "0", "1"], "doc_len": 54}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_line_kws", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_line_kws", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_line_kws(self, flat_array):\n\n        lw = 3\n        color = (.2, .5, .8)\n        ax = kdeplot(x=flat_array, linewidth=lw, color=color)\n        line, = ax.lines\n        assert line.get_linewidth() == lw\n        assert_colors_equal(line.get_color(), color)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_line_kws", "self", "flat_array", "lw", "3", "color", "2", "5", "8", "ax", "kdeplot", "x", "flat_array", "linewidth", "lw", "color", "color", "line", "ax", "lines", "assert", "line", "get_linewidth", "lw", "assert_colors_equal", "line", "get_color", "color"], "doc_len": 33}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_input_checking", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_input_checking", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_input_checking(self, long_df):\n\n        err = \"The x variable is categorical,\"\n        with pytest.raises(TypeError, match=err):\n            kdeplot(data=long_df, x=\"a\")\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_input_checking", "self", "long_df", "err", "the", "x", "variable", "is", "categorical", "with", "pytest", "raises", "typeerror", "match", "err", "kdeplot", "data", "long_df", "x", "a"], "doc_len": 25}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_axis_labels", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_axis_labels", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_axis_labels(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(data=long_df, x=\"x\", ax=ax1)\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"Density\"\n\n        kdeplot(data=long_df, y=\"y\", ax=ax2)\n        assert ax2.get_xlabel() == \"Density\"\n        assert ax2.get_ylabel() == \"y\"\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_axis_labels", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "data", "long_df", "x", "x", "ax", "ax1", "assert", "ax1", "get_xlabel", "x", "assert", "ax1", "get_ylabel", "density", "kdeplot", "data", "long_df", "y", "y", "ax", "ax2", "assert", "ax2", "get_xlabel", "density", "assert", "ax2", "get_ylabel", "y"], "doc_len": 45}
{"doc_id": "tests/test_distributions.py::TestKDEPlotUnivariate.test_legend", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotUnivariate", "func_name": "test_legend", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotUnivariate\n    def test_legend(self, long_df):\n\n        ax = kdeplot(data=long_df, x=\"x\", hue=\"a\")\n\n        assert ax.legend_.get_title().get_text() == \"a\"\n\n        legend_labels = ax.legend_.get_texts()\n        order = categorical_order(long_df[\"a\"])\n        for label, level in zip(legend_labels, order):\n            assert label.get_text() == level\n\n        legend_artists = ax.legend_.findobj(mpl.lines.Line2D)\n        if Version(mpl.__version__) < Version(\"3.5.0b0\"):\n            # https://github.com/matplotlib/matplotlib/pull/20699\n            legend_artists = legend_artists[::2]\n        palette = color_palette()\n        for artist, color in zip(legend_artists, palette):\n            assert_colors_equal(artist.get_color(), color)\n\n        ax.clear()\n\n        kdeplot(data=long_df, x=\"x\", hue=\"a\", legend=False)\n\n        assert ax.legend_ is None\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotunivariate", "def", "test_legend", "self", "long_df", "ax", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "assert", "ax", "legend_", "get_title", "get_text", "a", "legend_labels", "ax", "legend_", "get_texts", "order", "categorical_order", "long_df", "a", "for", "label", "level", "in", "zip", "legend_labels", "order", "assert", "label", "get_text", "level", "legend_artists", "ax", "legend_", "findobj", "mpl", "lines", "line2d", "if", "version", "mpl", "__version__", "version", "3", "5", "0b0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "20699", "legend_artists", "legend_artists", "2", "palette", "color_palette", "for", "artist", "color", "in", "zip", "legend_artists", "palette", "assert_colors_equal", "artist", "get_color", "color", "ax", "clear", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "legend", "false", "assert", "ax", "legend_", "is", "none"], "doc_len": 95}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_long_vectors", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_long_vectors", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_long_vectors(self, long_df):\n\n        ax1 = kdeplot(data=long_df, x=\"x\", y=\"y\")\n\n        x = long_df[\"x\"]\n        x_values = [x, x.to_numpy(), x.to_list()]\n\n        y = long_df[\"y\"]\n        y_values = [y, y.to_numpy(), y.to_list()]\n\n        for x, y in zip(x_values, y_values):\n            f, ax2 = plt.subplots()\n            kdeplot(x=x, y=y, ax=ax2)\n\n            for c1, c2 in zip(ax1.collections, ax2.collections):\n                assert_array_equal(c1.get_offsets(), c2.get_offsets())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_long_vectors", "self", "long_df", "ax1", "kdeplot", "data", "long_df", "x", "x", "y", "y", "x", "long_df", "x", "x_values", "x", "x", "to_numpy", "x", "to_list", "y", "long_df", "y", "y_values", "y", "y", "to_numpy", "y", "to_list", "for", "x", "y", "in", "zip", "x_values", "y_values", "f", "ax2", "plt", "subplots", "kdeplot", "x", "x", "y", "y", "ax", "ax2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert_array_equal", "c1", "get_offsets", "c2", "get_offsets"], "doc_len": 66}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_singular_data", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_singular_data", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_singular_data(self):\n\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\", UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_singular_data", "self", "with", "pytest", "warns", "userwarning", "ax", "dist", "kdeplot", "x", "np", "ones", "10", "y", "np", "arange", "10", "assert", "not", "ax", "lines", "with", "pytest", "warns", "userwarning", "ax", "dist", "kdeplot", "x", "5", "y", "6", "assert", "not", "ax", "lines", "with", "pytest", "warns", "userwarning", "ax", "kdeplot", "x", "1929245168", "06679", "18", "y", "np", "arange", "18", "assert", "not", "ax", "lines", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "userwarning", "ax", "kdeplot", "x", "5", "y", "7", "warn_singular", "false", "assert", "not", "ax", "lines"], "doc_len": 78}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_fill_artists", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_fill_artists", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_fill_artists(self, long_df):\n\n        for fill in [True, False]:\n            f, ax = plt.subplots()\n            kdeplot(data=long_df, x=\"x\", y=\"y\", hue=\"c\", fill=fill)\n            for c in ax.collections:\n                if fill or Version(mpl.__version__) >= Version(\"3.5.0b0\"):\n                    assert isinstance(c, mpl.collections.PathCollection)\n                else:\n                    assert isinstance(c, mpl.collections.LineCollection)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_fill_artists", "self", "long_df", "for", "fill", "in", "true", "false", "f", "ax", "plt", "subplots", "kdeplot", "data", "long_df", "x", "x", "y", "y", "hue", "c", "fill", "fill", "for", "c", "in", "ax", "collections", "if", "fill", "or", "version", "mpl", "__version__", "version", "3", "5", "0b0", "assert", "isinstance", "c", "mpl", "collections", "pathcollection", "else", "assert", "isinstance", "c", "mpl", "collections", "linecollection"], "doc_len": 56}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_common_norm", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_common_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_common_norm(self, rng):\n\n        hue = np.repeat([\"a\", \"a\", \"a\", \"b\"], 40)\n        x, y = rng.multivariate_normal([0, 0], [(.2, .5), (.5, 2)], len(hue)).T\n        x[hue == \"a\"] -= 2\n        x[hue == \"b\"] += 2\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        kdeplot(x=x, y=y, hue=hue, common_norm=True, ax=ax1)\n        kdeplot(x=x, y=y, hue=hue, common_norm=False, ax=ax2)\n\n        n_seg_1 = sum(len(get_contour_coords(c)) > 0 for c in ax1.collections)\n        n_seg_2 = sum(len(get_contour_coords(c)) > 0 for c in ax2.collections)\n        assert n_seg_2 > n_seg_1\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_common_norm", "self", "rng", "hue", "np", "repeat", "a", "a", "a", "b", "40", "x", "y", "rng", "multivariate_normal", "0", "0", "2", "5", "5", "2", "len", "hue", "t", "x", "hue", "a", "2", "x", "hue", "b", "2", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "x", "x", "y", "y", "hue", "hue", "common_norm", "true", "ax", "ax1", "kdeplot", "x", "x", "y", "y", "hue", "hue", "common_norm", "false", "ax", "ax2", "n_seg_1", "sum", "len", "get_contour_coords", "c", "0", "for", "c", "in", "ax1", "collections", "n_seg_2", "sum", "len", "get_contour_coords", "c", "0", "for", "c", "in", "ax2", "collections", "assert", "n_seg_2", "n_seg_1"], "doc_len": 91}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_log_scale", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_log_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_log_scale(self, rng):\n\n        x = rng.lognormal(0, 1, 100)\n        y = rng.uniform(0, 1, 100)\n\n        levels = .2, .5, 1\n\n        f, ax = plt.subplots()\n        kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n        assert ax.get_xscale() == \"log\"\n        assert ax.get_yscale() == \"log\"\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n        assert ax1.get_xscale() == \"log\"\n        assert ax1.get_yscale() == \"linear\"\n\n        p = _DistributionPlotter()\n        kde = KDE()\n        density, (xx, yy) = kde(np.log10(x), y)\n        levels = p._quantile_to_level(density, levels)\n        ax2.contour(10 ** xx, yy, density, levels=levels)\n\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            assert_array_equal(get_contour_coords(c1), get_contour_coords(c2))\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_log_scale", "self", "rng", "x", "rng", "lognormal", "0", "1", "100", "y", "rng", "uniform", "0", "1", "100", "levels", "2", "5", "1", "f", "ax", "plt", "subplots", "kdeplot", "x", "x", "y", "y", "log_scale", "true", "levels", "levels", "ax", "ax", "assert", "ax", "get_xscale", "log", "assert", "ax", "get_yscale", "log", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "x", "x", "y", "y", "log_scale", "10", "false", "levels", "levels", "ax", "ax1", "assert", "ax1", "get_xscale", "log", "assert", "ax1", "get_yscale", "linear", "p", "_distributionplotter", "kde", "kde", "density", "xx", "yy", "kde", "np", "log10", "x", "y", "levels", "p", "_quantile_to_level", "density", "levels", "ax2", "contour", "10", "xx", "yy", "density", "levels", "levels", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert_array_equal", "get_contour_coords", "c1", "get_contour_coords", "c2"], "doc_len": 113}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_bandwidth", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_bandwidth", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_bandwidth(self, rng):\n\n        n = 100\n        x, y = rng.multivariate_normal([0, 0], [(.2, .5), (.5, 2)], n).T\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        kdeplot(x=x, y=y, ax=ax1)\n        kdeplot(x=x, y=y, bw_adjust=2, ax=ax2)\n\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            seg1, seg2 = get_contour_coords(c1), get_contour_coords(c2)\n            if seg1 + seg2:\n                x1 = seg1[0][:, 0]\n                x2 = seg2[0][:, 0]\n                assert np.abs(x2).max() > np.abs(x1).max()\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_bandwidth", "self", "rng", "n", "100", "x", "y", "rng", "multivariate_normal", "0", "0", "2", "5", "5", "2", "n", "t", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "x", "x", "y", "y", "ax", "ax1", "kdeplot", "x", "x", "y", "y", "bw_adjust", "2", "ax", "ax2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "seg1", "seg2", "get_contour_coords", "c1", "get_contour_coords", "c2", "if", "seg1", "seg2", "x1", "seg1", "0", "0", "x2", "seg2", "0", "0", "assert", "np", "abs", "x2", "max", "np", "abs", "x1", "max"], "doc_len": 80}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_weights", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_weights", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_weights(self, rng):\n\n        import warnings\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n\n        n = 100\n        x, y = rng.multivariate_normal([1, 3], [(.2, .5), (.5, 2)], n).T\n        hue = np.repeat([0, 1], n // 2)\n        weights = rng.uniform(0, 1, n)\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n        kdeplot(x=x, y=y, hue=hue, ax=ax1)\n        kdeplot(x=x, y=y, hue=hue, weights=weights, ax=ax2)\n\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            if get_contour_coords(c1) and get_contour_coords(c2):\n                seg1 = np.concatenate(get_contour_coords(c1), axis=0)\n                seg2 = np.concatenate(get_contour_coords(c2), axis=0)\n                assert not np.array_equal(seg1, seg2)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_weights", "self", "rng", "import", "warnings", "warnings", "simplefilter", "error", "np", "visibledeprecationwarning", "n", "100", "x", "y", "rng", "multivariate_normal", "1", "3", "2", "5", "5", "2", "n", "t", "hue", "np", "repeat", "0", "1", "n", "2", "weights", "rng", "uniform", "0", "1", "n", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "kdeplot", "x", "x", "y", "y", "hue", "hue", "ax", "ax1", "kdeplot", "x", "x", "y", "y", "hue", "hue", "weights", "weights", "ax", "ax2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "if", "get_contour_coords", "c1", "and", "get_contour_coords", "c2", "seg1", "np", "concatenate", "get_contour_coords", "c1", "axis", "0", "seg2", "np", "concatenate", "get_contour_coords", "c2", "axis", "0", "assert", "not", "np", "array_equal", "seg1", "seg2"], "doc_len": 104}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_hue_ignores_cmap", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_hue_ignores_cmap", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_hue_ignores_cmap(self, long_df):\n\n        with pytest.warns(UserWarning, match=\"cmap parameter ignored\"):\n            ax = kdeplot(data=long_df, x=\"x\", y=\"y\", hue=\"c\", cmap=\"viridis\")\n\n        assert_colors_equal(get_contour_color(ax.collections[0]), \"C0\")\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_hue_ignores_cmap", "self", "long_df", "with", "pytest", "warns", "userwarning", "match", "cmap", "parameter", "ignored", "ax", "kdeplot", "data", "long_df", "x", "x", "y", "y", "hue", "c", "cmap", "viridis", "assert_colors_equal", "get_contour_color", "ax", "collections", "0", "c0"], "doc_len": 34}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_contour_line_colors", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_contour_line_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_contour_line_colors(self, long_df):\n\n        color = (.2, .9, .8, 1)\n        ax = kdeplot(data=long_df, x=\"x\", y=\"y\", color=color)\n\n        for c in ax.collections:\n            assert_colors_equal(get_contour_color(c), color)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_contour_line_colors", "self", "long_df", "color", "2", "9", "8", "1", "ax", "kdeplot", "data", "long_df", "x", "x", "y", "y", "color", "color", "for", "c", "in", "ax", "collections", "assert_colors_equal", "get_contour_color", "c", "color"], "doc_len": 32}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_contour_line_cmap", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_contour_line_cmap", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_contour_line_cmap(self, long_df):\n\n        color_list = color_palette(\"Blues\", 12)\n        cmap = mpl.colors.ListedColormap(color_list)\n        ax = kdeplot(data=long_df, x=\"x\", y=\"y\", cmap=cmap)\n        for c in ax.collections:\n            color = to_rgb(get_contour_color(c).squeeze())\n            assert color in color_list\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_contour_line_cmap", "self", "long_df", "color_list", "color_palette", "blues", "12", "cmap", "mpl", "colors", "listedcolormap", "color_list", "ax", "kdeplot", "data", "long_df", "x", "x", "y", "y", "cmap", "cmap", "for", "c", "in", "ax", "collections", "color", "to_rgb", "get_contour_color", "c", "squeeze", "assert", "color", "in", "color_list"], "doc_len": 41}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_contour_fill_colors", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_contour_fill_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_contour_fill_colors(self, long_df):\n\n        n = 6\n        color = (.2, .9, .8, 1)\n        ax = kdeplot(\n            data=long_df, x=\"x\", y=\"y\", fill=True, color=color, levels=n,\n        )\n\n        cmap = light_palette(color, reverse=True, as_cmap=True)\n        lut = cmap(np.linspace(0, 1, 256))\n        for c in ax.collections:\n            color = c.get_facecolor().squeeze()\n            assert color in lut\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_contour_fill_colors", "self", "long_df", "n", "6", "color", "2", "9", "8", "1", "ax", "kdeplot", "data", "long_df", "x", "x", "y", "y", "fill", "true", "color", "color", "levels", "n", "cmap", "light_palette", "color", "reverse", "true", "as_cmap", "true", "lut", "cmap", "np", "linspace", "0", "1", "256", "for", "c", "in", "ax", "collections", "color", "c", "get_facecolor", "squeeze", "assert", "color", "in", "lut"], "doc_len": 56}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_colorbar", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_colorbar", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_colorbar(self, long_df):\n\n        ax = kdeplot(data=long_df, x=\"x\", y=\"y\", fill=True, cbar=True)\n        assert len(ax.figure.axes) == 2\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_colorbar", "self", "long_df", "ax", "kdeplot", "data", "long_df", "x", "x", "y", "y", "fill", "true", "cbar", "true", "assert", "len", "ax", "figure", "axes", "2"], "doc_len": 26}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_levels_and_thresh", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_levels_and_thresh", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_levels_and_thresh(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(ncols=2)\n\n        n = 8\n        thresh = .1\n        plot_kws = dict(data=long_df, x=\"x\", y=\"y\")\n        kdeplot(**plot_kws, levels=n, thresh=thresh, ax=ax1)\n        kdeplot(**plot_kws, levels=np.linspace(thresh, 1, n), ax=ax2)\n\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            assert_array_equal(get_contour_coords(c1), get_contour_coords(c2))\n\n        with pytest.raises(ValueError):\n            kdeplot(**plot_kws, levels=[0, 1, 2])\n\n        ax1.clear()\n        ax2.clear()\n\n        kdeplot(**plot_kws, levels=n, thresh=None, ax=ax1)\n        kdeplot(**plot_kws, levels=n, thresh=0, ax=ax2)\n\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            assert_array_equal(get_contour_coords(c1), get_contour_coords(c2))\n        for c1, c2 in zip(ax1.collections, ax2.collections):\n            assert_array_equal(c1.get_facecolors(), c2.get_facecolors())\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_levels_and_thresh", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "ncols", "2", "n", "8", "thresh", "1", "plot_kws", "dict", "data", "long_df", "x", "x", "y", "y", "kdeplot", "plot_kws", "levels", "n", "thresh", "thresh", "ax", "ax1", "kdeplot", "plot_kws", "levels", "np", "linspace", "thresh", "1", "n", "ax", "ax2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert_array_equal", "get_contour_coords", "c1", "get_contour_coords", "c2", "with", "pytest", "raises", "valueerror", "kdeplot", "plot_kws", "levels", "0", "1", "2", "ax1", "clear", "ax2", "clear", "kdeplot", "plot_kws", "levels", "n", "thresh", "none", "ax", "ax1", "kdeplot", "plot_kws", "levels", "n", "thresh", "0", "ax", "ax2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert_array_equal", "get_contour_coords", "c1", "get_contour_coords", "c2", "for", "c1", "c2", "in", "zip", "ax1", "collections", "ax2", "collections", "assert_array_equal", "c1", "get_facecolors", "c2", "get_facecolors"], "doc_len": 117}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_quantile_to_level", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_quantile_to_level", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_quantile_to_level(self, rng):\n\n        x = rng.uniform(0, 1, 100000)\n        isoprop = np.linspace(.1, 1, 6)\n\n        levels = _DistributionPlotter()._quantile_to_level(x, isoprop)\n        for h, p in zip(levels, isoprop):\n            assert (x[x <= h].sum() / x.sum()) == pytest.approx(p, abs=1e-4)\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_quantile_to_level", "self", "rng", "x", "rng", "uniform", "0", "1", "100000", "isoprop", "np", "linspace", "1", "1", "6", "levels", "_distributionplotter", "_quantile_to_level", "x", "isoprop", "for", "h", "p", "in", "zip", "levels", "isoprop", "assert", "x", "x", "h", "sum", "x", "sum", "pytest", "approx", "p", "abs", "1e", "4"], "doc_len": 45}
{"doc_id": "tests/test_distributions.py::TestKDEPlotBivariate.test_input_checking", "file_path": "tests/test_distributions.py", "class_name": "TestKDEPlotBivariate", "func_name": "test_input_checking", "text": "文件路径: tests/test_distributions.py, 类名: TestKDEPlotBivariate\n    def test_input_checking(self, long_df):\n\n        with pytest.raises(TypeError, match=\"The x variable is categorical,\"):\n            kdeplot(data=long_df, x=\"a\", y=\"y\")\n", "tokens": ["tests", "test_distributions", "py", "testkdeplotbivariate", "def", "test_input_checking", "self", "long_df", "with", "pytest", "raises", "typeerror", "match", "the", "x", "variable", "is", "categorical", "kdeplot", "data", "long_df", "x", "a", "y", "y"], "doc_len": 25}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.get_last_color", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "get_last_color", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def get_last_color(self, ax, element=\"bars\", fill=True):\n\n        if element == \"bars\":\n            if fill:\n                return ax.patches[-1].get_facecolor()\n            else:\n                return ax.patches[-1].get_edgecolor()\n        else:\n            if fill:\n                artist = ax.collections[-1]\n                facecolor = artist.get_facecolor()\n                edgecolor = artist.get_edgecolor()\n                assert_colors_equal(facecolor, edgecolor, check_alpha=False)\n                return facecolor\n            else:\n                return ax.lines[-1].get_color()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "get_last_color", "self", "ax", "element", "bars", "fill", "true", "if", "element", "bars", "if", "fill", "return", "ax", "patches", "1", "get_facecolor", "else", "return", "ax", "patches", "1", "get_edgecolor", "else", "if", "fill", "artist", "ax", "collections", "1", "facecolor", "artist", "get_facecolor", "edgecolor", "artist", "get_edgecolor", "assert_colors_equal", "facecolor", "edgecolor", "check_alpha", "false", "return", "facecolor", "else", "return", "ax", "lines", "1", "get_color"], "doc_len": 54}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_color", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_color", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_color(self, long_df, element, fill):\n\n        super().test_color(long_df, element=element, fill=fill)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_color", "self", "long_df", "element", "fill", "super", "test_color", "long_df", "element", "element", "fill", "fill"], "doc_len": 17}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_long_vectors", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_long_vectors", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_long_vectors(self, long_df, variable):\n\n        vector = long_df[variable]\n        vectors = [\n            variable, vector, vector.to_numpy(), vector.to_list(),\n        ]\n\n        f, axs = plt.subplots(3)\n        for vector, ax in zip(vectors, axs):\n            histplot(data=long_df, ax=ax, **{variable: vector})\n\n        bars = [ax.patches for ax in axs]\n        for a_bars, b_bars in itertools.product(bars, bars):\n            for a, b in zip(a_bars, b_bars):\n                assert_array_equal(a.get_height(), b.get_height())\n                assert_array_equal(a.get_xy(), b.get_xy())\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_long_vectors", "self", "long_df", "variable", "vector", "long_df", "variable", "vectors", "variable", "vector", "vector", "to_numpy", "vector", "to_list", "f", "axs", "plt", "subplots", "3", "for", "vector", "ax", "in", "zip", "vectors", "axs", "histplot", "data", "long_df", "ax", "ax", "variable", "vector", "bars", "ax", "patches", "for", "ax", "in", "axs", "for", "a_bars", "b_bars", "in", "itertools", "product", "bars", "bars", "for", "a", "b", "in", "zip", "a_bars", "b_bars", "assert_array_equal", "a", "get_height", "b", "get_height", "assert_array_equal", "a", "get_xy", "b", "get_xy"], "doc_len": 70}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_wide_vs_long_data", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_wide_vs_long_data", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_wide_vs_long_data(self, wide_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        histplot(data=wide_df, ax=ax1, common_bins=False)\n\n        for col in wide_df.columns[::-1]:\n            histplot(data=wide_df, x=col, ax=ax2)\n\n        for a, b in zip(ax1.patches, ax2.patches):\n            assert a.get_height() == b.get_height()\n            assert a.get_xy() == b.get_xy()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_wide_vs_long_data", "self", "wide_df", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "data", "wide_df", "ax", "ax1", "common_bins", "false", "for", "col", "in", "wide_df", "columns", "1", "histplot", "data", "wide_df", "x", "col", "ax", "ax2", "for", "a", "b", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "a", "get_height", "b", "get_height", "assert", "a", "get_xy", "b", "get_xy"], "doc_len": 53}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_flat_vector", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_flat_vector", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_flat_vector(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        histplot(data=long_df[\"x\"], ax=ax1)\n        histplot(data=long_df, x=\"x\", ax=ax2)\n\n        for a, b in zip(ax1.patches, ax2.patches):\n            assert a.get_height() == b.get_height()\n            assert a.get_xy() == b.get_xy()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_flat_vector", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "data", "long_df", "x", "ax", "ax1", "histplot", "data", "long_df", "x", "x", "ax", "ax2", "for", "a", "b", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "a", "get_height", "b", "get_height", "assert", "a", "get_xy", "b", "get_xy"], "doc_len": 46}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_empty_data", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_empty_data", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_empty_data(self):\n\n        ax = histplot(x=[])\n        assert not ax.patches\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_empty_data", "self", "ax", "histplot", "x", "assert", "not", "ax", "patches"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_variable_assignment", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_variable_assignment", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_variable_assignment(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        histplot(data=long_df, x=\"x\", ax=ax1)\n        histplot(data=long_df, y=\"x\", ax=ax2)\n\n        for a, b in zip(ax1.patches, ax2.patches):\n            assert a.get_height() == b.get_width()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_variable_assignment", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "data", "long_df", "x", "x", "ax", "ax1", "histplot", "data", "long_df", "y", "x", "ax", "ax2", "for", "a", "b", "in", "zip", "ax1", "patches", "ax2", "patches", "assert", "a", "get_height", "b", "get_width"], "doc_len": 42}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_hue_fill_colors", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_hue_fill_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_hue_fill_colors(self, long_df, multiple, element):\n\n        ax = histplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            multiple=multiple, bins=1,\n            fill=True, element=element, legend=False,\n        )\n\n        palette = color_palette()\n\n        if multiple == \"layer\":\n            if element == \"bars\":\n                a = .5\n            else:\n                a = .25\n        else:\n            a = .75\n\n        for bar, color in zip(ax.patches[::-1], palette):\n            assert_colors_equal(bar.get_facecolor(), to_rgba(color, a))\n\n        for poly, color in zip(ax.collections[::-1], palette):\n            assert_colors_equal(poly.get_facecolor(), to_rgba(color, a))\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_hue_fill_colors", "self", "long_df", "multiple", "element", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "multiple", "multiple", "bins", "1", "fill", "true", "element", "element", "legend", "false", "palette", "color_palette", "if", "multiple", "layer", "if", "element", "bars", "a", "5", "else", "a", "25", "else", "a", "75", "for", "bar", "color", "in", "zip", "ax", "patches", "1", "palette", "assert_colors_equal", "bar", "get_facecolor", "to_rgba", "color", "a", "for", "poly", "color", "in", "zip", "ax", "collections", "1", "palette", "assert_colors_equal", "poly", "get_facecolor", "to_rgba", "color", "a"], "doc_len": 74}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_hue_stack", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_hue_stack", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_hue_stack(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        n = 10\n\n        kws = dict(data=long_df, x=\"x\", hue=\"a\", bins=n, element=\"bars\")\n\n        histplot(**kws, multiple=\"layer\", ax=ax1)\n        histplot(**kws, multiple=\"stack\", ax=ax2)\n\n        layer_heights = np.reshape([b.get_height() for b in ax1.patches], (-1, n))\n        stack_heights = np.reshape([b.get_height() for b in ax2.patches], (-1, n))\n        assert_array_equal(layer_heights, stack_heights)\n\n        stack_xys = np.reshape([b.get_xy() for b in ax2.patches], (-1, n, 2))\n        assert_array_equal(\n            stack_xys[..., 1] + stack_heights,\n            stack_heights.cumsum(axis=0),\n        )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_hue_stack", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "n", "10", "kws", "dict", "data", "long_df", "x", "x", "hue", "a", "bins", "n", "element", "bars", "histplot", "kws", "multiple", "layer", "ax", "ax1", "histplot", "kws", "multiple", "stack", "ax", "ax2", "layer_heights", "np", "reshape", "b", "get_height", "for", "b", "in", "ax1", "patches", "1", "n", "stack_heights", "np", "reshape", "b", "get_height", "for", "b", "in", "ax2", "patches", "1", "n", "assert_array_equal", "layer_heights", "stack_heights", "stack_xys", "np", "reshape", "b", "get_xy", "for", "b", "in", "ax2", "patches", "1", "n", "2", "assert_array_equal", "stack_xys", "1", "stack_heights", "stack_heights", "cumsum", "axis", "0"], "doc_len": 88}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_hue_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_hue_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_hue_fill(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        n = 10\n\n        kws = dict(data=long_df, x=\"x\", hue=\"a\", bins=n, element=\"bars\")\n\n        histplot(**kws, multiple=\"layer\", ax=ax1)\n        histplot(**kws, multiple=\"fill\", ax=ax2)\n\n        layer_heights = np.reshape([b.get_height() for b in ax1.patches], (-1, n))\n        stack_heights = np.reshape([b.get_height() for b in ax2.patches], (-1, n))\n        assert_array_almost_equal(\n            layer_heights / layer_heights.sum(axis=0), stack_heights\n        )\n\n        stack_xys = np.reshape([b.get_xy() for b in ax2.patches], (-1, n, 2))\n        assert_array_almost_equal(\n            (stack_xys[..., 1] + stack_heights) / stack_heights.sum(axis=0),\n            stack_heights.cumsum(axis=0),\n        )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_hue_fill", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "n", "10", "kws", "dict", "data", "long_df", "x", "x", "hue", "a", "bins", "n", "element", "bars", "histplot", "kws", "multiple", "layer", "ax", "ax1", "histplot", "kws", "multiple", "fill", "ax", "ax2", "layer_heights", "np", "reshape", "b", "get_height", "for", "b", "in", "ax1", "patches", "1", "n", "stack_heights", "np", "reshape", "b", "get_height", "for", "b", "in", "ax2", "patches", "1", "n", "assert_array_almost_equal", "layer_heights", "layer_heights", "sum", "axis", "0", "stack_heights", "stack_xys", "np", "reshape", "b", "get_xy", "for", "b", "in", "ax2", "patches", "1", "n", "2", "assert_array_almost_equal", "stack_xys", "1", "stack_heights", "stack_heights", "sum", "axis", "0", "stack_heights", "cumsum", "axis", "0"], "doc_len": 96}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_hue_dodge", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_hue_dodge", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_hue_dodge(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        bw = 2\n\n        kws = dict(data=long_df, x=\"x\", hue=\"c\", binwidth=bw, element=\"bars\")\n\n        histplot(**kws, multiple=\"layer\", ax=ax1)\n        histplot(**kws, multiple=\"dodge\", ax=ax2)\n\n        layer_heights = [b.get_height() for b in ax1.patches]\n        dodge_heights = [b.get_height() for b in ax2.patches]\n        assert_array_equal(layer_heights, dodge_heights)\n\n        layer_xs = np.reshape([b.get_x() for b in ax1.patches], (2, -1))\n        dodge_xs = np.reshape([b.get_x() for b in ax2.patches], (2, -1))\n        assert_array_almost_equal(layer_xs[1], dodge_xs[1])\n        assert_array_almost_equal(layer_xs[0], dodge_xs[0] - bw / 2)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_hue_dodge", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "bw", "2", "kws", "dict", "data", "long_df", "x", "x", "hue", "c", "binwidth", "bw", "element", "bars", "histplot", "kws", "multiple", "layer", "ax", "ax1", "histplot", "kws", "multiple", "dodge", "ax", "ax2", "layer_heights", "b", "get_height", "for", "b", "in", "ax1", "patches", "dodge_heights", "b", "get_height", "for", "b", "in", "ax2", "patches", "assert_array_equal", "layer_heights", "dodge_heights", "layer_xs", "np", "reshape", "b", "get_x", "for", "b", "in", "ax1", "patches", "2", "1", "dodge_xs", "np", "reshape", "b", "get_x", "for", "b", "in", "ax2", "patches", "2", "1", "assert_array_almost_equal", "layer_xs", "1", "dodge_xs", "1", "assert_array_almost_equal", "layer_xs", "0", "dodge_xs", "0", "bw", "2"], "doc_len": 95}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_hue_as_numpy_dodged", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_hue_as_numpy_dodged", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_hue_as_numpy_dodged(self, long_df):\n        # https://github.com/mwaskom/seaborn/issues/2452\n\n        ax = histplot(\n            long_df,\n            x=\"y\", hue=long_df[\"a\"].to_numpy(),\n            multiple=\"dodge\", bins=1,\n        )\n        # Note hue order reversal\n        assert ax.patches[1].get_x() < ax.patches[0].get_x()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_hue_as_numpy_dodged", "self", "long_df", "https", "github", "com", "mwaskom", "seaborn", "issues", "2452", "ax", "histplot", "long_df", "x", "y", "hue", "long_df", "a", "to_numpy", "multiple", "dodge", "bins", "1", "note", "hue", "order", "reversal", "assert", "ax", "patches", "1", "get_x", "ax", "patches", "0", "get_x"], "doc_len": 41}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_multiple_input_check", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_multiple_input_check", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_multiple_input_check(self, flat_series):\n\n        with pytest.raises(ValueError, match=\"`multiple` must be\"):\n            histplot(flat_series, multiple=\"invalid\")\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_multiple_input_check", "self", "flat_series", "with", "pytest", "raises", "valueerror", "match", "multiple", "must", "be", "histplot", "flat_series", "multiple", "invalid"], "doc_len": 20}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_element_input_check", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_element_input_check", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_element_input_check(self, flat_series):\n\n        with pytest.raises(ValueError, match=\"`element` must be\"):\n            histplot(flat_series, element=\"invalid\")\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_element_input_check", "self", "flat_series", "with", "pytest", "raises", "valueerror", "match", "element", "must", "be", "histplot", "flat_series", "element", "invalid"], "doc_len": 20}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_count_stat", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_count_stat", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_count_stat(self, flat_series):\n\n        ax = histplot(flat_series, stat=\"count\")\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert sum(bar_heights) == len(flat_series)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_count_stat", "self", "flat_series", "ax", "histplot", "flat_series", "stat", "count", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "assert", "sum", "bar_heights", "len", "flat_series"], "doc_len": 26}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_density_stat", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_density_stat", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_density_stat(self, flat_series):\n\n        ax = histplot(flat_series, stat=\"density\")\n        bar_heights = [b.get_height() for b in ax.patches]\n        bar_widths = [b.get_width() for b in ax.patches]\n        assert np.multiply(bar_heights, bar_widths).sum() == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_density_stat", "self", "flat_series", "ax", "histplot", "flat_series", "stat", "density", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "bar_widths", "b", "get_width", "for", "b", "in", "ax", "patches", "assert", "np", "multiply", "bar_heights", "bar_widths", "sum", "pytest", "approx", "1"], "doc_len": 38}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_density_stat_common_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_density_stat_common_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_density_stat_common_norm(self, long_df):\n\n        ax = histplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            stat=\"density\", common_norm=True, element=\"bars\",\n        )\n        bar_heights = [b.get_height() for b in ax.patches]\n        bar_widths = [b.get_width() for b in ax.patches]\n        assert np.multiply(bar_heights, bar_widths).sum() == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_density_stat_common_norm", "self", "long_df", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "stat", "density", "common_norm", "true", "element", "bars", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "bar_widths", "b", "get_width", "for", "b", "in", "ax", "patches", "assert", "np", "multiply", "bar_heights", "bar_widths", "sum", "pytest", "approx", "1"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_density_stat_unique_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_density_stat_unique_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_density_stat_unique_norm(self, long_df):\n\n        n = 10\n        ax = histplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            stat=\"density\", bins=n, common_norm=False, element=\"bars\",\n        )\n\n        bar_groups = ax.patches[:n], ax.patches[-n:]\n\n        for bars in bar_groups:\n            bar_heights = [b.get_height() for b in bars]\n            bar_widths = [b.get_width() for b in bars]\n            bar_areas = np.multiply(bar_heights, bar_widths)\n            assert bar_areas.sum() == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_density_stat_unique_norm", "self", "long_df", "n", "10", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "stat", "density", "bins", "n", "common_norm", "false", "element", "bars", "bar_groups", "ax", "patches", "n", "ax", "patches", "n", "for", "bars", "in", "bar_groups", "bar_heights", "b", "get_height", "for", "b", "in", "bars", "bar_widths", "b", "get_width", "for", "b", "in", "bars", "bar_areas", "np", "multiply", "bar_heights", "bar_widths", "assert", "bar_areas", "sum", "pytest", "approx", "1"], "doc_len": 62}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.height_norm_arg", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "height_norm_arg", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def height_norm_arg(self, request):\n        return request.param\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "height_norm_arg", "self", "request", "return", "request", "param"], "doc_len": 11}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_probability_stat", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_probability_stat", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_probability_stat(self, flat_series, height_norm_arg):\n\n        ax = histplot(flat_series, stat=height_norm_arg)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert sum(bar_heights) == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_probability_stat", "self", "flat_series", "height_norm_arg", "ax", "histplot", "flat_series", "stat", "height_norm_arg", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "assert", "sum", "bar_heights", "pytest", "approx", "1"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_probability_stat_common_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_probability_stat_common_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_probability_stat_common_norm(self, long_df, height_norm_arg):\n\n        ax = histplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            stat=height_norm_arg, common_norm=True, element=\"bars\",\n        )\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert sum(bar_heights) == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_probability_stat_common_norm", "self", "long_df", "height_norm_arg", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "stat", "height_norm_arg", "common_norm", "true", "element", "bars", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "assert", "sum", "bar_heights", "pytest", "approx", "1"], "doc_len": 37}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_probability_stat_unique_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_probability_stat_unique_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_probability_stat_unique_norm(self, long_df, height_norm_arg):\n\n        n = 10\n        ax = histplot(\n            data=long_df, x=\"x\", hue=\"a\",\n            stat=height_norm_arg, bins=n, common_norm=False, element=\"bars\",\n        )\n\n        bar_groups = ax.patches[:n], ax.patches[-n:]\n\n        for bars in bar_groups:\n            bar_heights = [b.get_height() for b in bars]\n            assert sum(bar_heights) == pytest.approx(1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_probability_stat_unique_norm", "self", "long_df", "height_norm_arg", "n", "10", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "stat", "height_norm_arg", "bins", "n", "common_norm", "false", "element", "bars", "bar_groups", "ax", "patches", "n", "ax", "patches", "n", "for", "bars", "in", "bar_groups", "bar_heights", "b", "get_height", "for", "b", "in", "bars", "assert", "sum", "bar_heights", "pytest", "approx", "1"], "doc_len": 51}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_percent_stat", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_percent_stat", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_percent_stat(self, flat_series):\n\n        ax = histplot(flat_series, stat=\"percent\")\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert sum(bar_heights) == 100\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_percent_stat", "self", "flat_series", "ax", "histplot", "flat_series", "stat", "percent", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "assert", "sum", "bar_heights", "100"], "doc_len": 25}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_common_bins", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_common_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_common_bins(self, long_df):\n\n        n = 10\n        ax = histplot(\n            long_df, x=\"x\", hue=\"a\", common_bins=True, bins=n, element=\"bars\",\n        )\n\n        bar_groups = ax.patches[:n], ax.patches[-n:]\n        assert_array_equal(\n            [b.get_xy() for b in bar_groups[0]],\n            [b.get_xy() for b in bar_groups[1]]\n        )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_common_bins", "self", "long_df", "n", "10", "ax", "histplot", "long_df", "x", "x", "hue", "a", "common_bins", "true", "bins", "n", "element", "bars", "bar_groups", "ax", "patches", "n", "ax", "patches", "n", "assert_array_equal", "b", "get_xy", "for", "b", "in", "bar_groups", "0", "b", "get_xy", "for", "b", "in", "bar_groups", "1"], "doc_len": 45}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_unique_bins", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_unique_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_unique_bins(self, wide_df):\n\n        ax = histplot(wide_df, common_bins=False, bins=10, element=\"bars\")\n\n        bar_groups = np.split(np.array(ax.patches), len(wide_df.columns))\n\n        for i, col in enumerate(wide_df.columns[::-1]):\n            bars = bar_groups[i]\n            start = bars[0].get_x()\n            stop = bars[-1].get_x() + bars[-1].get_width()\n            assert_array_almost_equal(start, wide_df[col].min())\n            assert_array_almost_equal(stop, wide_df[col].max())\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_unique_bins", "self", "wide_df", "ax", "histplot", "wide_df", "common_bins", "false", "bins", "10", "element", "bars", "bar_groups", "np", "split", "np", "array", "ax", "patches", "len", "wide_df", "columns", "for", "i", "col", "in", "enumerate", "wide_df", "columns", "1", "bars", "bar_groups", "i", "start", "bars", "0", "get_x", "stop", "bars", "1", "get_x", "bars", "1", "get_width", "assert_array_almost_equal", "start", "wide_df", "col", "min", "assert_array_almost_equal", "stop", "wide_df", "col", "max"], "doc_len": 59}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_weights_with_missing", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_weights_with_missing", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_weights_with_missing(self, missing_df):\n\n        ax = histplot(missing_df, x=\"x\", weights=\"s\", bins=5)\n\n        bar_heights = [bar.get_height() for bar in ax.patches]\n        total_weight = missing_df[[\"x\", \"s\"]].dropna()[\"s\"].sum()\n        assert sum(bar_heights) == pytest.approx(total_weight)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_weights_with_missing", "self", "missing_df", "ax", "histplot", "missing_df", "x", "x", "weights", "s", "bins", "5", "bar_heights", "bar", "get_height", "for", "bar", "in", "ax", "patches", "total_weight", "missing_df", "x", "s", "dropna", "s", "sum", "assert", "sum", "bar_heights", "pytest", "approx", "total_weight"], "doc_len": 38}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_weight_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_weight_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_weight_norm(self, rng):\n\n        vals = rng.normal(0, 1, 50)\n        x = np.concatenate([vals, vals])\n        w = np.repeat([1, 2], 50)\n        ax = histplot(\n            x=x, weights=w, hue=w, common_norm=True, stat=\"density\", bins=5\n        )\n\n        # Recall that artists are added in reverse of hue order\n        y1 = [bar.get_height() for bar in ax.patches[:5]]\n        y2 = [bar.get_height() for bar in ax.patches[5:]]\n\n        assert sum(y1) == 2 * sum(y2)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_weight_norm", "self", "rng", "vals", "rng", "normal", "0", "1", "50", "x", "np", "concatenate", "vals", "vals", "w", "np", "repeat", "1", "2", "50", "ax", "histplot", "x", "x", "weights", "w", "hue", "w", "common_norm", "true", "stat", "density", "bins", "5", "recall", "that", "artists", "are", "added", "in", "reverse", "of", "hue", "order", "y1", "bar", "get_height", "for", "bar", "in", "ax", "patches", "5", "y2", "bar", "get_height", "for", "bar", "in", "ax", "patches", "5", "assert", "sum", "y1", "2", "sum", "y2"], "doc_len": 73}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_discrete", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_discrete", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_discrete(self, long_df):\n\n        ax = histplot(long_df, x=\"s\", discrete=True)\n\n        data_min = long_df[\"s\"].min()\n        data_max = long_df[\"s\"].max()\n        assert len(ax.patches) == (data_max - data_min + 1)\n\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_width() == 1\n            assert bar.get_x() == (data_min + i - .5)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_discrete", "self", "long_df", "ax", "histplot", "long_df", "x", "s", "discrete", "true", "data_min", "long_df", "s", "min", "data_max", "long_df", "s", "max", "assert", "len", "ax", "patches", "data_max", "data_min", "1", "for", "i", "bar", "in", "enumerate", "ax", "patches", "assert", "bar", "get_width", "1", "assert", "bar", "get_x", "data_min", "i", "5"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_discrete_categorical_default", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_discrete_categorical_default", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_discrete_categorical_default(self, long_df):\n\n        ax = histplot(long_df, x=\"a\")\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_width() == 1\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_discrete_categorical_default", "self", "long_df", "ax", "histplot", "long_df", "x", "a", "for", "i", "bar", "in", "enumerate", "ax", "patches", "assert", "bar", "get_width", "1"], "doc_len": 24}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_categorical_yaxis_inversion", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_categorical_yaxis_inversion", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_categorical_yaxis_inversion(self, long_df):\n\n        ax = histplot(long_df, y=\"a\")\n        ymax, ymin = ax.get_ylim()\n        assert ymax > ymin\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_categorical_yaxis_inversion", "self", "long_df", "ax", "histplot", "long_df", "y", "a", "ymax", "ymin", "ax", "get_ylim", "assert", "ymax", "ymin"], "doc_len": 20}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_datetime_scale", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_datetime_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_datetime_scale(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        histplot(x=long_df[\"t\"], fill=True, ax=ax1)\n        histplot(x=long_df[\"t\"], fill=False, ax=ax2)\n        assert ax1.get_xlim() == ax2.get_xlim()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_datetime_scale", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "x", "long_df", "t", "fill", "true", "ax", "ax1", "histplot", "x", "long_df", "t", "fill", "false", "ax", "ax2", "assert", "ax1", "get_xlim", "ax2", "get_xlim"], "doc_len": 35}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde(self, flat_series, stat):\n\n        ax = histplot(\n            flat_series, kde=True, stat=stat, kde_kws={\"cut\": 10}\n        )\n\n        bar_widths = [b.get_width() for b in ax.patches]\n        bar_heights = [b.get_height() for b in ax.patches]\n        hist_area = np.multiply(bar_widths, bar_heights).sum()\n\n        density, = ax.lines\n        kde_area = integrate(density.get_ydata(), density.get_xdata())\n\n        assert kde_area == pytest.approx(hist_area)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde", "self", "flat_series", "stat", "ax", "histplot", "flat_series", "kde", "true", "stat", "stat", "kde_kws", "cut", "10", "bar_widths", "b", "get_width", "for", "b", "in", "ax", "patches", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "hist_area", "np", "multiply", "bar_widths", "bar_heights", "sum", "density", "ax", "lines", "kde_area", "integrate", "density", "get_ydata", "density", "get_xdata", "assert", "kde_area", "pytest", "approx", "hist_area"], "doc_len": 55}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_with_hue", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_with_hue", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_with_hue(self, long_df, stat, multiple):\n\n        n = 10\n        ax = histplot(\n            long_df, x=\"x\", hue=\"c\", multiple=multiple,\n            kde=True, stat=stat, element=\"bars\",\n            kde_kws={\"cut\": 10}, bins=n,\n        )\n\n        bar_groups = ax.patches[:n], ax.patches[-n:]\n\n        for i, bars in enumerate(bar_groups):\n            bar_widths = [b.get_width() for b in bars]\n            bar_heights = [b.get_height() for b in bars]\n            hist_area = np.multiply(bar_widths, bar_heights).sum()\n\n            x, y = ax.lines[i].get_xydata().T\n            kde_area = integrate(y, x)\n\n            if multiple == \"layer\":\n                assert kde_area == pytest.approx(hist_area)\n            elif multiple == \"dodge\":\n                assert kde_area == pytest.approx(hist_area * 2)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_with_hue", "self", "long_df", "stat", "multiple", "n", "10", "ax", "histplot", "long_df", "x", "x", "hue", "c", "multiple", "multiple", "kde", "true", "stat", "stat", "element", "bars", "kde_kws", "cut", "10", "bins", "n", "bar_groups", "ax", "patches", "n", "ax", "patches", "n", "for", "i", "bars", "in", "enumerate", "bar_groups", "bar_widths", "b", "get_width", "for", "b", "in", "bars", "bar_heights", "b", "get_height", "for", "b", "in", "bars", "hist_area", "np", "multiply", "bar_widths", "bar_heights", "sum", "x", "y", "ax", "lines", "i", "get_xydata", "t", "kde_area", "integrate", "y", "x", "if", "multiple", "layer", "assert", "kde_area", "pytest", "approx", "hist_area", "elif", "multiple", "dodge", "assert", "kde_area", "pytest", "approx", "hist_area", "2"], "doc_len": 93}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_default_cut", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_default_cut", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_default_cut(self, flat_series):\n\n        ax = histplot(flat_series, kde=True)\n        support = ax.lines[0].get_xdata()\n        assert support.min() == flat_series.min()\n        assert support.max() == flat_series.max()\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_default_cut", "self", "flat_series", "ax", "histplot", "flat_series", "kde", "true", "support", "ax", "lines", "0", "get_xdata", "assert", "support", "min", "flat_series", "min", "assert", "support", "max", "flat_series", "max"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_hue", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_hue", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_hue(self, long_df):\n\n        n = 10\n        ax = histplot(data=long_df, x=\"x\", hue=\"a\", kde=True, bins=n)\n\n        for bar, line in zip(ax.patches[::n], ax.lines):\n            assert_colors_equal(\n                bar.get_facecolor(), line.get_color(), check_alpha=False\n            )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_hue", "self", "long_df", "n", "10", "ax", "histplot", "data", "long_df", "x", "x", "hue", "a", "kde", "true", "bins", "n", "for", "bar", "line", "in", "zip", "ax", "patches", "n", "ax", "lines", "assert_colors_equal", "bar", "get_facecolor", "line", "get_color", "check_alpha", "false"], "doc_len": 39}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_yaxis", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_yaxis", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_yaxis(self, flat_series):\n\n        f, ax = plt.subplots()\n        histplot(x=flat_series, kde=True)\n        histplot(y=flat_series, kde=True)\n\n        x, y = ax.lines\n        assert_array_equal(x.get_xdata(), y.get_ydata())\n        assert_array_equal(x.get_ydata(), y.get_xdata())\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_yaxis", "self", "flat_series", "f", "ax", "plt", "subplots", "histplot", "x", "flat_series", "kde", "true", "histplot", "y", "flat_series", "kde", "true", "x", "y", "ax", "lines", "assert_array_equal", "x", "get_xdata", "y", "get_ydata", "assert_array_equal", "x", "get_ydata", "y", "get_xdata"], "doc_len": 36}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_line_kws", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_line_kws", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_line_kws(self, flat_series):\n\n        lw = 5\n        ax = histplot(flat_series, kde=True, line_kws=dict(lw=lw))\n        assert ax.lines[0].get_linewidth() == lw\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_line_kws", "self", "flat_series", "lw", "5", "ax", "histplot", "flat_series", "kde", "true", "line_kws", "dict", "lw", "lw", "assert", "ax", "lines", "0", "get_linewidth", "lw"], "doc_len": 25}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_kde_singular_data", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_kde_singular_data", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_kde_singular_data(self):\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\")\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\")\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_kde_singular_data", "self", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "ax", "histplot", "x", "np", "ones", "10", "kde", "true", "assert", "not", "ax", "lines", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "ax", "histplot", "x", "5", "kde", "true", "assert", "not", "ax", "lines"], "doc_len": 41}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_element_default", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_element_default", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_element_default(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        histplot(long_df, x=\"x\", ax=ax1)\n        histplot(long_df, x=\"x\", ax=ax2, element=\"bars\")\n        assert len(ax1.patches) == len(ax2.patches)\n\n        f, (ax1, ax2) = plt.subplots(2)\n        histplot(long_df, x=\"x\", hue=\"a\", ax=ax1)\n        histplot(long_df, x=\"x\", hue=\"a\", ax=ax2, element=\"bars\")\n        assert len(ax1.patches) == len(ax2.patches)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_element_default", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "long_df", "x", "x", "ax", "ax1", "histplot", "long_df", "x", "x", "ax", "ax2", "element", "bars", "assert", "len", "ax1", "patches", "len", "ax2", "patches", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "long_df", "x", "x", "hue", "a", "ax", "ax1", "histplot", "long_df", "x", "x", "hue", "a", "ax", "ax2", "element", "bars", "assert", "len", "ax1", "patches", "len", "ax2", "patches"], "doc_len": 66}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_bars_no_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_bars_no_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_bars_no_fill(self, flat_series):\n\n        alpha = .5\n        ax = histplot(flat_series, element=\"bars\", fill=False, alpha=alpha)\n        for bar in ax.patches:\n            assert bar.get_facecolor() == (0, 0, 0, 0)\n            assert bar.get_edgecolor()[-1] == alpha\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_bars_no_fill", "self", "flat_series", "alpha", "5", "ax", "histplot", "flat_series", "element", "bars", "fill", "false", "alpha", "alpha", "for", "bar", "in", "ax", "patches", "assert", "bar", "get_facecolor", "0", "0", "0", "0", "assert", "bar", "get_edgecolor", "1", "alpha"], "doc_len": 36}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_fill(self, flat_series):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        n = 10\n        histplot(flat_series, element=\"bars\", fill=True, bins=n, ax=ax1)\n        histplot(flat_series, element=\"step\", fill=True, bins=n, ax=ax2)\n\n        bar_heights = [b.get_height() for b in ax1.patches]\n        bar_widths = [b.get_width() for b in ax1.patches]\n        bar_edges = [b.get_x() for b in ax1.patches]\n\n        fill = ax2.collections[0]\n        x, y = fill.get_paths()[0].vertices[::-1].T\n\n        assert_array_equal(x[1:2 * n:2], bar_edges)\n        assert_array_equal(y[1:2 * n:2], bar_heights)\n\n        assert x[n * 2] == bar_edges[-1] + bar_widths[-1]\n        assert y[n * 2] == bar_heights[-1]\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_fill", "self", "flat_series", "f", "ax1", "ax2", "plt", "subplots", "2", "n", "10", "histplot", "flat_series", "element", "bars", "fill", "true", "bins", "n", "ax", "ax1", "histplot", "flat_series", "element", "step", "fill", "true", "bins", "n", "ax", "ax2", "bar_heights", "b", "get_height", "for", "b", "in", "ax1", "patches", "bar_widths", "b", "get_width", "for", "b", "in", "ax1", "patches", "bar_edges", "b", "get_x", "for", "b", "in", "ax1", "patches", "fill", "ax2", "collections", "0", "x", "y", "fill", "get_paths", "0", "vertices", "1", "t", "assert_array_equal", "x", "1", "2", "n", "2", "bar_edges", "assert_array_equal", "y", "1", "2", "n", "2", "bar_heights", "assert", "x", "n", "2", "bar_edges", "1", "bar_widths", "1", "assert", "y", "n", "2", "bar_heights", "1"], "doc_len": 100}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_poly_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_poly_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_poly_fill(self, flat_series):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        n = 10\n        histplot(flat_series, element=\"bars\", fill=True, bins=n, ax=ax1)\n        histplot(flat_series, element=\"poly\", fill=True, bins=n, ax=ax2)\n\n        bar_heights = np.array([b.get_height() for b in ax1.patches])\n        bar_widths = np.array([b.get_width() for b in ax1.patches])\n        bar_edges = np.array([b.get_x() for b in ax1.patches])\n\n        fill = ax2.collections[0]\n        x, y = fill.get_paths()[0].vertices[::-1].T\n\n        assert_array_equal(x[1:n + 1], bar_edges + bar_widths / 2)\n        assert_array_equal(y[1:n + 1], bar_heights)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_poly_fill", "self", "flat_series", "f", "ax1", "ax2", "plt", "subplots", "2", "n", "10", "histplot", "flat_series", "element", "bars", "fill", "true", "bins", "n", "ax", "ax1", "histplot", "flat_series", "element", "poly", "fill", "true", "bins", "n", "ax", "ax2", "bar_heights", "np", "array", "b", "get_height", "for", "b", "in", "ax1", "patches", "bar_widths", "np", "array", "b", "get_width", "for", "b", "in", "ax1", "patches", "bar_edges", "np", "array", "b", "get_x", "for", "b", "in", "ax1", "patches", "fill", "ax2", "collections", "0", "x", "y", "fill", "get_paths", "0", "vertices", "1", "t", "assert_array_equal", "x", "1", "n", "1", "bar_edges", "bar_widths", "2", "assert_array_equal", "y", "1", "n", "1", "bar_heights"], "doc_len": 92}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_poly_no_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_poly_no_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_poly_no_fill(self, flat_series):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        n = 10\n        histplot(flat_series, element=\"bars\", fill=False, bins=n, ax=ax1)\n        histplot(flat_series, element=\"poly\", fill=False, bins=n, ax=ax2)\n\n        bar_heights = np.array([b.get_height() for b in ax1.patches])\n        bar_widths = np.array([b.get_width() for b in ax1.patches])\n        bar_edges = np.array([b.get_x() for b in ax1.patches])\n\n        x, y = ax2.lines[0].get_xydata().T\n\n        assert_array_equal(x, bar_edges + bar_widths / 2)\n        assert_array_equal(y, bar_heights)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_poly_no_fill", "self", "flat_series", "f", "ax1", "ax2", "plt", "subplots", "2", "n", "10", "histplot", "flat_series", "element", "bars", "fill", "false", "bins", "n", "ax", "ax1", "histplot", "flat_series", "element", "poly", "fill", "false", "bins", "n", "ax", "ax2", "bar_heights", "np", "array", "b", "get_height", "for", "b", "in", "ax1", "patches", "bar_widths", "np", "array", "b", "get_width", "for", "b", "in", "ax1", "patches", "bar_edges", "np", "array", "b", "get_x", "for", "b", "in", "ax1", "patches", "x", "y", "ax2", "lines", "0", "get_xydata", "t", "assert_array_equal", "x", "bar_edges", "bar_widths", "2", "assert_array_equal", "y", "bar_heights"], "doc_len": 81}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_no_fill", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_no_fill", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_no_fill(self, flat_series):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        histplot(flat_series, element=\"bars\", fill=False, ax=ax1)\n        histplot(flat_series, element=\"step\", fill=False, ax=ax2)\n\n        bar_heights = [b.get_height() for b in ax1.patches]\n        bar_widths = [b.get_width() for b in ax1.patches]\n        bar_edges = [b.get_x() for b in ax1.patches]\n\n        x, y = ax2.lines[0].get_xydata().T\n\n        assert_array_equal(x[:-1], bar_edges)\n        assert_array_equal(y[:-1], bar_heights)\n        assert x[-1] == bar_edges[-1] + bar_widths[-1]\n        assert y[-1] == y[-2]\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_no_fill", "self", "flat_series", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "flat_series", "element", "bars", "fill", "false", "ax", "ax1", "histplot", "flat_series", "element", "step", "fill", "false", "ax", "ax2", "bar_heights", "b", "get_height", "for", "b", "in", "ax1", "patches", "bar_widths", "b", "get_width", "for", "b", "in", "ax1", "patches", "bar_edges", "b", "get_x", "for", "b", "in", "ax1", "patches", "x", "y", "ax2", "lines", "0", "get_xydata", "t", "assert_array_equal", "x", "1", "bar_edges", "assert_array_equal", "y", "1", "bar_heights", "assert", "x", "1", "bar_edges", "1", "bar_widths", "1", "assert", "y", "1", "y", "2"], "doc_len": 81}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_fill_xy", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_fill_xy", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_fill_xy(self, flat_series):\n\n        f, ax = plt.subplots()\n\n        histplot(x=flat_series, element=\"step\", fill=True)\n        histplot(y=flat_series, element=\"step\", fill=True)\n\n        xverts = ax.collections[0].get_paths()[0].vertices\n        yverts = ax.collections[1].get_paths()[0].vertices\n\n        assert_array_equal(xverts, yverts[:, ::-1])\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_fill_xy", "self", "flat_series", "f", "ax", "plt", "subplots", "histplot", "x", "flat_series", "element", "step", "fill", "true", "histplot", "y", "flat_series", "element", "step", "fill", "true", "xverts", "ax", "collections", "0", "get_paths", "0", "vertices", "yverts", "ax", "collections", "1", "get_paths", "0", "vertices", "assert_array_equal", "xverts", "yverts", "1"], "doc_len": 44}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_no_fill_xy", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_no_fill_xy", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_no_fill_xy(self, flat_series):\n\n        f, ax = plt.subplots()\n\n        histplot(x=flat_series, element=\"step\", fill=False)\n        histplot(y=flat_series, element=\"step\", fill=False)\n\n        xline, yline = ax.lines\n\n        assert_array_equal(xline.get_xdata(), yline.get_ydata())\n        assert_array_equal(xline.get_ydata(), yline.get_xdata())\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_no_fill_xy", "self", "flat_series", "f", "ax", "plt", "subplots", "histplot", "x", "flat_series", "element", "step", "fill", "false", "histplot", "y", "flat_series", "element", "step", "fill", "false", "xline", "yline", "ax", "lines", "assert_array_equal", "xline", "get_xdata", "yline", "get_ydata", "assert_array_equal", "xline", "get_ydata", "yline", "get_xdata"], "doc_len": 40}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_weighted_histogram", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_weighted_histogram", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_weighted_histogram(self):\n\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_weighted_histogram", "self", "ax", "histplot", "x", "0", "1", "2", "weights", "1", "2", "3", "discrete", "true", "bar_heights", "b", "get_height", "for", "b", "in", "ax", "patches", "assert", "bar_heights", "1", "2", "3"], "doc_len": 32}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_weights_with_auto_bins", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_weights_with_auto_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_weights_with_auto_bins(self, long_df):\n\n        with pytest.warns(UserWarning):\n            ax = histplot(long_df, x=\"x\", weights=\"f\")\n        assert len(ax.patches) == 10\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_weights_with_auto_bins", "self", "long_df", "with", "pytest", "warns", "userwarning", "ax", "histplot", "long_df", "x", "x", "weights", "f", "assert", "len", "ax", "patches", "10"], "doc_len": 24}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_shrink", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_shrink", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_shrink(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(2)\n\n        bw = 2\n        shrink = .4\n\n        histplot(long_df, x=\"x\", binwidth=bw, ax=ax1)\n        histplot(long_df, x=\"x\", binwidth=bw, shrink=shrink, ax=ax2)\n\n        for p1, p2 in zip(ax1.patches, ax2.patches):\n\n            w1, w2 = p1.get_width(), p2.get_width()\n            assert w2 == pytest.approx(shrink * w1)\n\n            x1, x2 = p1.get_x(), p2.get_x()\n            assert (x2 + w2 / 2) == pytest.approx(x1 + w1 / 2)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_shrink", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "2", "bw", "2", "shrink", "4", "histplot", "long_df", "x", "x", "binwidth", "bw", "ax", "ax1", "histplot", "long_df", "x", "x", "binwidth", "bw", "shrink", "shrink", "ax", "ax2", "for", "p1", "p2", "in", "zip", "ax1", "patches", "ax2", "patches", "w1", "w2", "p1", "get_width", "p2", "get_width", "assert", "w2", "pytest", "approx", "shrink", "w1", "x1", "x2", "p1", "get_x", "p2", "get_x", "assert", "x2", "w2", "2", "pytest", "approx", "x1", "w1", "2"], "doc_len": 72}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_log_scale_explicit", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_log_scale_explicit", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_log_scale_explicit(self, rng):\n\n        x = rng.lognormal(0, 2, 1000)\n        ax = histplot(x, log_scale=True, binwidth=1)\n\n        bar_widths = [b.get_width() for b in ax.patches]\n        steps = np.divide(bar_widths[1:], bar_widths[:-1])\n        assert np.allclose(steps, 10)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_log_scale_explicit", "self", "rng", "x", "rng", "lognormal", "0", "2", "1000", "ax", "histplot", "x", "log_scale", "true", "binwidth", "1", "bar_widths", "b", "get_width", "for", "b", "in", "ax", "patches", "steps", "np", "divide", "bar_widths", "1", "bar_widths", "1", "assert", "np", "allclose", "steps", "10"], "doc_len": 41}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_log_scale_implicit", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_log_scale_implicit", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_log_scale_implicit(self, rng):\n\n        x = rng.lognormal(0, 2, 1000)\n\n        f, ax = plt.subplots()\n        ax.set_xscale(\"log\")\n        histplot(x, binwidth=1, ax=ax)\n\n        bar_widths = [b.get_width() for b in ax.patches]\n        steps = np.divide(bar_widths[1:], bar_widths[:-1])\n        assert np.allclose(steps, 10)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_log_scale_implicit", "self", "rng", "x", "rng", "lognormal", "0", "2", "1000", "f", "ax", "plt", "subplots", "ax", "set_xscale", "log", "histplot", "x", "binwidth", "1", "ax", "ax", "bar_widths", "b", "get_width", "for", "b", "in", "ax", "patches", "steps", "np", "divide", "bar_widths", "1", "bar_widths", "1", "assert", "np", "allclose", "steps", "10"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_log_scale_dodge", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_log_scale_dodge", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_log_scale_dodge(self, rng):\n\n        x = rng.lognormal(0, 2, 100)\n        hue = np.repeat([\"a\", \"b\"], 50)\n        ax = histplot(x=x, hue=hue, bins=5, log_scale=True, multiple=\"dodge\")\n        x_min = np.log([b.get_x() for b in ax.patches])\n        x_max = np.log([b.get_x() + b.get_width() for b in ax.patches])\n        assert np.unique(np.round(x_max - x_min, 10)).size == 1\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_log_scale_dodge", "self", "rng", "x", "rng", "lognormal", "0", "2", "100", "hue", "np", "repeat", "a", "b", "50", "ax", "histplot", "x", "x", "hue", "hue", "bins", "5", "log_scale", "true", "multiple", "dodge", "x_min", "np", "log", "b", "get_x", "for", "b", "in", "ax", "patches", "x_max", "np", "log", "b", "get_x", "b", "get_width", "for", "b", "in", "ax", "patches", "assert", "np", "unique", "np", "round", "x_max", "x_min", "10", "size", "1"], "doc_len": 64}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_log_scale_kde", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_log_scale_kde", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_log_scale_kde(self, rng):\n\n        x = rng.lognormal(0, 1, 1000)\n        ax = histplot(x=x, log_scale=True, kde=True, bins=20)\n        bar_height = max(p.get_height() for p in ax.patches)\n        kde_height = max(ax.lines[0].get_ydata())\n        assert bar_height == pytest.approx(kde_height, rel=.1)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_log_scale_kde", "self", "rng", "x", "rng", "lognormal", "0", "1", "1000", "ax", "histplot", "x", "x", "log_scale", "true", "kde", "true", "bins", "20", "bar_height", "max", "p", "get_height", "for", "p", "in", "ax", "patches", "kde_height", "max", "ax", "lines", "0", "get_ydata", "assert", "bar_height", "pytest", "approx", "kde_height", "rel", "1"], "doc_len": 46}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_auto_linewidth", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_auto_linewidth", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_auto_linewidth(self, flat_series, fill):\n\n        get_lw = lambda ax: ax.patches[0].get_linewidth()  # noqa: E731\n\n        kws = dict(element=\"bars\", fill=fill)\n\n        f, (ax1, ax2) = plt.subplots(2)\n        histplot(flat_series, **kws, bins=10, ax=ax1)\n        histplot(flat_series, **kws, bins=100, ax=ax2)\n        assert get_lw(ax1) > get_lw(ax2)\n\n        f, ax1 = plt.subplots(figsize=(10, 5))\n        f, ax2 = plt.subplots(figsize=(2, 5))\n        histplot(flat_series, **kws, bins=30, ax=ax1)\n        histplot(flat_series, **kws, bins=30, ax=ax2)\n        assert get_lw(ax1) > get_lw(ax2)\n\n        f, ax1 = plt.subplots(figsize=(4, 5))\n        f, ax2 = plt.subplots(figsize=(4, 5))\n        histplot(flat_series, **kws, bins=30, ax=ax1)\n        histplot(10 ** flat_series, **kws, bins=30, log_scale=True, ax=ax2)\n        assert get_lw(ax1) == pytest.approx(get_lw(ax2))\n\n        f, ax1 = plt.subplots(figsize=(4, 5))\n        f, ax2 = plt.subplots(figsize=(4, 5))\n        histplot(y=[0, 1, 1], **kws, discrete=True, ax=ax1)\n        histplot(y=[\"a\", \"b\", \"b\"], **kws, ax=ax2)\n        assert get_lw(ax1) == pytest.approx(get_lw(ax2))\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_auto_linewidth", "self", "flat_series", "fill", "get_lw", "lambda", "ax", "ax", "patches", "0", "get_linewidth", "noqa", "e731", "kws", "dict", "element", "bars", "fill", "fill", "f", "ax1", "ax2", "plt", "subplots", "2", "histplot", "flat_series", "kws", "bins", "10", "ax", "ax1", "histplot", "flat_series", "kws", "bins", "100", "ax", "ax2", "assert", "get_lw", "ax1", "get_lw", "ax2", "f", "ax1", "plt", "subplots", "figsize", "10", "5", "f", "ax2", "plt", "subplots", "figsize", "2", "5", "histplot", "flat_series", "kws", "bins", "30", "ax", "ax1", "histplot", "flat_series", "kws", "bins", "30", "ax", "ax2", "assert", "get_lw", "ax1", "get_lw", "ax2", "f", "ax1", "plt", "subplots", "figsize", "4", "5", "f", "ax2", "plt", "subplots", "figsize", "4", "5", "histplot", "flat_series", "kws", "bins", "30", "ax", "ax1", "histplot", "10", "flat_series", "kws", "bins", "30", "log_scale", "true", "ax", "ax2", "assert", "get_lw", "ax1", "pytest", "approx", "get_lw", "ax2", "f", "ax1", "plt", "subplots", "figsize", "4", "5", "f", "ax2", "plt", "subplots", "figsize", "4", "5", "histplot", "y", "0", "1", "1", "kws", "discrete", "true", "ax", "ax1", "histplot", "y", "a", "b", "b", "kws", "ax", "ax2", "assert", "get_lw", "ax1", "pytest", "approx", "get_lw", "ax2"], "doc_len": 159}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_bar_kwargs", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_bar_kwargs", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_bar_kwargs(self, flat_series):\n\n        lw = 2\n        ec = (1, .2, .9, .5)\n        ax = histplot(flat_series, binwidth=1, ec=ec, lw=lw)\n        for bar in ax.patches:\n            assert_colors_equal(bar.get_edgecolor(), ec)\n            assert bar.get_linewidth() == lw\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_bar_kwargs", "self", "flat_series", "lw", "2", "ec", "1", "2", "9", "5", "ax", "histplot", "flat_series", "binwidth", "1", "ec", "ec", "lw", "lw", "for", "bar", "in", "ax", "patches", "assert_colors_equal", "bar", "get_edgecolor", "ec", "assert", "bar", "get_linewidth", "lw"], "doc_len": 37}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_fill_kwargs", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_fill_kwargs", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_fill_kwargs(self, flat_series):\n\n        lw = 2\n        ec = (1, .2, .9, .5)\n        ax = histplot(flat_series, element=\"step\", ec=ec, lw=lw)\n        poly = ax.collections[0]\n        assert_colors_equal(poly.get_edgecolor(), ec)\n        assert poly.get_linewidth() == lw\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_fill_kwargs", "self", "flat_series", "lw", "2", "ec", "1", "2", "9", "5", "ax", "histplot", "flat_series", "element", "step", "ec", "ec", "lw", "lw", "poly", "ax", "collections", "0", "assert_colors_equal", "poly", "get_edgecolor", "ec", "assert", "poly", "get_linewidth", "lw"], "doc_len": 36}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_step_line_kwargs", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_step_line_kwargs", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_step_line_kwargs(self, flat_series):\n\n        lw = 2\n        ls = \"--\"\n        ax = histplot(flat_series, element=\"step\", fill=False, lw=lw, ls=ls)\n        line = ax.lines[0]\n        assert line.get_linewidth() == lw\n        assert line.get_linestyle() == ls\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_step_line_kwargs", "self", "flat_series", "lw", "2", "ls", "ax", "histplot", "flat_series", "element", "step", "fill", "false", "lw", "lw", "ls", "ls", "line", "ax", "lines", "0", "assert", "line", "get_linewidth", "lw", "assert", "line", "get_linestyle", "ls"], "doc_len": 34}
{"doc_id": "tests/test_distributions.py::TestHistPlotUnivariate.test_label", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotUnivariate", "func_name": "test_label", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotUnivariate\n    def test_label(self, flat_series):\n\n        ax = histplot(flat_series, label=\"a label\")\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(handles) == 1\n        assert labels == [\"a label\"]\n", "tokens": ["tests", "test_distributions", "py", "testhistplotunivariate", "def", "test_label", "self", "flat_series", "ax", "histplot", "flat_series", "label", "a", "label", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "handles", "1", "assert", "labels", "a", "label"], "doc_len": 26}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh(self, long_df):\n\n        hist = Histogram()\n        counts, (x_edges, y_edges) = hist(long_df[\"x\"], long_df[\"y\"])\n\n        ax = histplot(long_df, x=\"x\", y=\"y\")\n        mesh = ax.collections[0]\n        mesh_data = mesh.get_array()\n\n        assert_array_equal(mesh_data.data, counts.T.flat)\n        assert_array_equal(mesh_data.mask, counts.T.flat == 0)\n\n        edges = itertools.product(y_edges[:-1], x_edges[:-1])\n        for i, (y, x) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert path.vertices[0, 0] == x\n            assert path.vertices[0, 1] == y\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh", "self", "long_df", "hist", "histogram", "counts", "x_edges", "y_edges", "hist", "long_df", "x", "long_df", "y", "ax", "histplot", "long_df", "x", "x", "y", "y", "mesh", "ax", "collections", "0", "mesh_data", "mesh", "get_array", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "assert_array_equal", "mesh_data", "mask", "counts", "t", "flat", "0", "edges", "itertools", "product", "y_edges", "1", "x_edges", "1", "for", "i", "y", "x", "in", "enumerate", "edges", "path", "mesh", "get_paths", "i", "assert", "path", "vertices", "0", "0", "x", "assert", "path", "vertices", "0", "1", "y"], "doc_len": 75}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_with_hue", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_with_hue", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_with_hue(self, long_df):\n\n        ax = histplot(long_df, x=\"x\", y=\"y\", hue=\"c\")\n\n        hist = Histogram()\n        hist.define_bin_params(long_df[\"x\"], long_df[\"y\"])\n\n        for i, sub_df in long_df.groupby(\"c\"):\n\n            mesh = ax.collections[i]\n            mesh_data = mesh.get_array()\n\n            counts, (x_edges, y_edges) = hist(sub_df[\"x\"], sub_df[\"y\"])\n\n            assert_array_equal(mesh_data.data, counts.T.flat)\n            assert_array_equal(mesh_data.mask, counts.T.flat == 0)\n\n            edges = itertools.product(y_edges[:-1], x_edges[:-1])\n            for i, (y, x) in enumerate(edges):\n                path = mesh.get_paths()[i]\n                assert path.vertices[0, 0] == x\n                assert path.vertices[0, 1] == y\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_with_hue", "self", "long_df", "ax", "histplot", "long_df", "x", "x", "y", "y", "hue", "c", "hist", "histogram", "hist", "define_bin_params", "long_df", "x", "long_df", "y", "for", "i", "sub_df", "in", "long_df", "groupby", "c", "mesh", "ax", "collections", "i", "mesh_data", "mesh", "get_array", "counts", "x_edges", "y_edges", "hist", "sub_df", "x", "sub_df", "y", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "assert_array_equal", "mesh_data", "mask", "counts", "t", "flat", "0", "edges", "itertools", "product", "y_edges", "1", "x_edges", "1", "for", "i", "y", "x", "in", "enumerate", "edges", "path", "mesh", "get_paths", "i", "assert", "path", "vertices", "0", "0", "x", "assert", "path", "vertices", "0", "1", "y"], "doc_len": 90}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_with_hue_unique_bins", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_with_hue_unique_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_with_hue_unique_bins(self, long_df):\n\n        ax = histplot(long_df, x=\"x\", y=\"y\", hue=\"c\", common_bins=False)\n\n        for i, sub_df in long_df.groupby(\"c\"):\n\n            hist = Histogram()\n\n            mesh = ax.collections[i]\n            mesh_data = mesh.get_array()\n\n            counts, (x_edges, y_edges) = hist(sub_df[\"x\"], sub_df[\"y\"])\n\n            assert_array_equal(mesh_data.data, counts.T.flat)\n            assert_array_equal(mesh_data.mask, counts.T.flat == 0)\n\n            edges = itertools.product(y_edges[:-1], x_edges[:-1])\n            for i, (y, x) in enumerate(edges):\n                path = mesh.get_paths()[i]\n                assert path.vertices[0, 0] == x\n                assert path.vertices[0, 1] == y\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_with_hue_unique_bins", "self", "long_df", "ax", "histplot", "long_df", "x", "x", "y", "y", "hue", "c", "common_bins", "false", "for", "i", "sub_df", "in", "long_df", "groupby", "c", "hist", "histogram", "mesh", "ax", "collections", "i", "mesh_data", "mesh", "get_array", "counts", "x_edges", "y_edges", "hist", "sub_df", "x", "sub_df", "y", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "assert_array_equal", "mesh_data", "mask", "counts", "t", "flat", "0", "edges", "itertools", "product", "y_edges", "1", "x_edges", "1", "for", "i", "y", "x", "in", "enumerate", "edges", "path", "mesh", "get_paths", "i", "assert", "path", "vertices", "0", "0", "x", "assert", "path", "vertices", "0", "1", "y"], "doc_len": 86}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_with_col_unique_bins", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_with_col_unique_bins", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_with_col_unique_bins(self, long_df):\n\n        g = displot(long_df, x=\"x\", y=\"y\", col=\"c\", common_bins=False)\n\n        for i, sub_df in long_df.groupby(\"c\"):\n\n            hist = Histogram()\n\n            mesh = g.axes.flat[i].collections[0]\n            mesh_data = mesh.get_array()\n\n            counts, (x_edges, y_edges) = hist(sub_df[\"x\"], sub_df[\"y\"])\n\n            assert_array_equal(mesh_data.data, counts.T.flat)\n            assert_array_equal(mesh_data.mask, counts.T.flat == 0)\n\n            edges = itertools.product(y_edges[:-1], x_edges[:-1])\n            for i, (y, x) in enumerate(edges):\n                path = mesh.get_paths()[i]\n                assert path.vertices[0, 0] == x\n                assert path.vertices[0, 1] == y\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_with_col_unique_bins", "self", "long_df", "g", "displot", "long_df", "x", "x", "y", "y", "col", "c", "common_bins", "false", "for", "i", "sub_df", "in", "long_df", "groupby", "c", "hist", "histogram", "mesh", "g", "axes", "flat", "i", "collections", "0", "mesh_data", "mesh", "get_array", "counts", "x_edges", "y_edges", "hist", "sub_df", "x", "sub_df", "y", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "assert_array_equal", "mesh_data", "mask", "counts", "t", "flat", "0", "edges", "itertools", "product", "y_edges", "1", "x_edges", "1", "for", "i", "y", "x", "in", "enumerate", "edges", "path", "mesh", "get_paths", "i", "assert", "path", "vertices", "0", "0", "x", "assert", "path", "vertices", "0", "1", "y"], "doc_len": 89}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_log_scale", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_log_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_log_scale(self, rng):\n\n        x, y = rng.lognormal(0, 1, (2, 1000))\n        hist = Histogram()\n        counts, (x_edges, y_edges) = hist(np.log10(x), np.log10(y))\n\n        ax = histplot(x=x, y=y, log_scale=True)\n        mesh = ax.collections[0]\n        mesh_data = mesh.get_array()\n\n        assert_array_equal(mesh_data.data, counts.T.flat)\n\n        edges = itertools.product(y_edges[:-1], x_edges[:-1])\n        for i, (y_i, x_i) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert path.vertices[0, 0] == pytest.approx(10 ** x_i)\n            assert path.vertices[0, 1] == pytest.approx(10 ** y_i)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_log_scale", "self", "rng", "x", "y", "rng", "lognormal", "0", "1", "2", "1000", "hist", "histogram", "counts", "x_edges", "y_edges", "hist", "np", "log10", "x", "np", "log10", "y", "ax", "histplot", "x", "x", "y", "y", "log_scale", "true", "mesh", "ax", "collections", "0", "mesh_data", "mesh", "get_array", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "edges", "itertools", "product", "y_edges", "1", "x_edges", "1", "for", "i", "y_i", "x_i", "in", "enumerate", "edges", "path", "mesh", "get_paths", "i", "assert", "path", "vertices", "0", "0", "pytest", "approx", "10", "x_i", "assert", "path", "vertices", "0", "1", "pytest", "approx", "10", "y_i"], "doc_len": 85}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_thresh", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_thresh", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_thresh(self, long_df):\n\n        hist = Histogram()\n        counts, (x_edges, y_edges) = hist(long_df[\"x\"], long_df[\"y\"])\n\n        thresh = 5\n        ax = histplot(long_df, x=\"x\", y=\"y\", thresh=thresh)\n        mesh = ax.collections[0]\n        mesh_data = mesh.get_array()\n\n        assert_array_equal(mesh_data.data, counts.T.flat)\n        assert_array_equal(mesh_data.mask, (counts <= thresh).T.flat)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_thresh", "self", "long_df", "hist", "histogram", "counts", "x_edges", "y_edges", "hist", "long_df", "x", "long_df", "y", "thresh", "5", "ax", "histplot", "long_df", "x", "x", "y", "y", "thresh", "thresh", "mesh", "ax", "collections", "0", "mesh_data", "mesh", "get_array", "assert_array_equal", "mesh_data", "data", "counts", "t", "flat", "assert_array_equal", "mesh_data", "mask", "counts", "thresh", "t", "flat"], "doc_len": 49}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_sticky_edges", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_sticky_edges", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_sticky_edges(self, long_df):\n\n        ax = histplot(long_df, x=\"x\", y=\"y\", thresh=None)\n        mesh = ax.collections[0]\n        assert mesh.sticky_edges.x == [long_df[\"x\"].min(), long_df[\"x\"].max()]\n        assert mesh.sticky_edges.y == [long_df[\"y\"].min(), long_df[\"y\"].max()]\n\n        ax.clear()\n        ax = histplot(long_df, x=\"x\", y=\"y\")\n        mesh = ax.collections[0]\n        assert not mesh.sticky_edges.x\n        assert not mesh.sticky_edges.y\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_sticky_edges", "self", "long_df", "ax", "histplot", "long_df", "x", "x", "y", "y", "thresh", "none", "mesh", "ax", "collections", "0", "assert", "mesh", "sticky_edges", "x", "long_df", "x", "min", "long_df", "x", "max", "assert", "mesh", "sticky_edges", "y", "long_df", "y", "min", "long_df", "y", "max", "ax", "clear", "ax", "histplot", "long_df", "x", "x", "y", "y", "mesh", "ax", "collections", "0", "assert", "not", "mesh", "sticky_edges", "x", "assert", "not", "mesh", "sticky_edges", "y"], "doc_len": 64}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_common_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_common_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_common_norm(self, long_df):\n\n        stat = \"density\"\n        ax = histplot(\n            long_df, x=\"x\", y=\"y\", hue=\"c\", common_norm=True, stat=stat,\n        )\n\n        hist = Histogram(stat=\"density\")\n        hist.define_bin_params(long_df[\"x\"], long_df[\"y\"])\n\n        for i, sub_df in long_df.groupby(\"c\"):\n\n            mesh = ax.collections[i]\n            mesh_data = mesh.get_array()\n\n            density, (x_edges, y_edges) = hist(sub_df[\"x\"], sub_df[\"y\"])\n\n            scale = len(sub_df) / len(long_df)\n            assert_array_equal(mesh_data.data, (density * scale).T.flat)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_common_norm", "self", "long_df", "stat", "density", "ax", "histplot", "long_df", "x", "x", "y", "y", "hue", "c", "common_norm", "true", "stat", "stat", "hist", "histogram", "stat", "density", "hist", "define_bin_params", "long_df", "x", "long_df", "y", "for", "i", "sub_df", "in", "long_df", "groupby", "c", "mesh", "ax", "collections", "i", "mesh_data", "mesh", "get_array", "density", "x_edges", "y_edges", "hist", "sub_df", "x", "sub_df", "y", "scale", "len", "sub_df", "len", "long_df", "assert_array_equal", "mesh_data", "data", "density", "scale", "t", "flat"], "doc_len": 67}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_unique_norm", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_unique_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_unique_norm(self, long_df):\n\n        stat = \"density\"\n        ax = histplot(\n            long_df, x=\"x\", y=\"y\", hue=\"c\", common_norm=False, stat=stat,\n        )\n\n        hist = Histogram()\n        bin_kws = hist.define_bin_params(long_df[\"x\"], long_df[\"y\"])\n\n        for i, sub_df in long_df.groupby(\"c\"):\n\n            sub_hist = Histogram(bins=bin_kws[\"bins\"], stat=stat)\n\n            mesh = ax.collections[i]\n            mesh_data = mesh.get_array()\n\n            density, (x_edges, y_edges) = sub_hist(sub_df[\"x\"], sub_df[\"y\"])\n            assert_array_equal(mesh_data.data, density.T.flat)\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_unique_norm", "self", "long_df", "stat", "density", "ax", "histplot", "long_df", "x", "x", "y", "y", "hue", "c", "common_norm", "false", "stat", "stat", "hist", "histogram", "bin_kws", "hist", "define_bin_params", "long_df", "x", "long_df", "y", "for", "i", "sub_df", "in", "long_df", "groupby", "c", "sub_hist", "histogram", "bins", "bin_kws", "bins", "stat", "stat", "mesh", "ax", "collections", "i", "mesh_data", "mesh", "get_array", "density", "x_edges", "y_edges", "sub_hist", "sub_df", "x", "sub_df", "y", "assert_array_equal", "mesh_data", "data", "density", "t", "flat"], "doc_len": 67}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_normalization", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_normalization", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_normalization(self, long_df, stat):\n\n        ax = histplot(\n            long_df, x=\"x\", y=\"y\", stat=stat,\n        )\n\n        mesh_data = ax.collections[0].get_array()\n        expected_sum = {\"percent\": 100}.get(stat, 1)\n        assert mesh_data.data.sum() == expected_sum\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_normalization", "self", "long_df", "stat", "ax", "histplot", "long_df", "x", "x", "y", "y", "stat", "stat", "mesh_data", "ax", "collections", "0", "get_array", "expected_sum", "percent", "100", "get", "stat", "1", "assert", "mesh_data", "data", "sum", "expected_sum"], "doc_len": 34}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_mesh_colors", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_mesh_colors", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_mesh_colors(self, long_df):\n\n        color = \"r\"\n        f, ax = plt.subplots()\n        histplot(\n            long_df, x=\"x\", y=\"y\", color=color,\n        )\n        mesh = ax.collections[0]\n        assert_array_equal(\n            mesh.get_cmap().colors,\n            _DistributionPlotter()._cmap_from_color(color).colors,\n        )\n\n        f, ax = plt.subplots()\n        histplot(\n            long_df, x=\"x\", y=\"y\", hue=\"c\",\n        )\n        colors = color_palette()\n        for i, mesh in enumerate(ax.collections):\n            assert_array_equal(\n                mesh.get_cmap().colors,\n                _DistributionPlotter()._cmap_from_color(colors[i]).colors,\n            )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_mesh_colors", "self", "long_df", "color", "r", "f", "ax", "plt", "subplots", "histplot", "long_df", "x", "x", "y", "y", "color", "color", "mesh", "ax", "collections", "0", "assert_array_equal", "mesh", "get_cmap", "colors", "_distributionplotter", "_cmap_from_color", "color", "colors", "f", "ax", "plt", "subplots", "histplot", "long_df", "x", "x", "y", "y", "hue", "c", "colors", "color_palette", "for", "i", "mesh", "in", "enumerate", "ax", "collections", "assert_array_equal", "mesh", "get_cmap", "colors", "_distributionplotter", "_cmap_from_color", "colors", "i", "colors"], "doc_len": 64}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_color_limits", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_color_limits", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_color_limits(self, long_df):\n\n        f, (ax1, ax2, ax3) = plt.subplots(3)\n        kws = dict(data=long_df, x=\"x\", y=\"y\")\n        hist = Histogram()\n        counts, _ = hist(long_df[\"x\"], long_df[\"y\"])\n\n        histplot(**kws, ax=ax1)\n        assert ax1.collections[0].get_clim() == (0, counts.max())\n\n        vmax = 10\n        histplot(**kws, vmax=vmax, ax=ax2)\n        counts, _ = hist(long_df[\"x\"], long_df[\"y\"])\n        assert ax2.collections[0].get_clim() == (0, vmax)\n\n        pmax = .8\n        pthresh = .1\n        f = _DistributionPlotter()._quantile_to_level\n\n        histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n        counts, _ = hist(long_df[\"x\"], long_df[\"y\"])\n        mesh = ax3.collections[0]\n        assert mesh.get_clim() == (0, f(counts, pmax))\n        assert_array_equal(\n            mesh.get_array().mask,\n            (counts <= f(counts, pthresh)).T.flat,\n        )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_color_limits", "self", "long_df", "f", "ax1", "ax2", "ax3", "plt", "subplots", "3", "kws", "dict", "data", "long_df", "x", "x", "y", "y", "hist", "histogram", "counts", "_", "hist", "long_df", "x", "long_df", "y", "histplot", "kws", "ax", "ax1", "assert", "ax1", "collections", "0", "get_clim", "0", "counts", "max", "vmax", "10", "histplot", "kws", "vmax", "vmax", "ax", "ax2", "counts", "_", "hist", "long_df", "x", "long_df", "y", "assert", "ax2", "collections", "0", "get_clim", "0", "vmax", "pmax", "8", "pthresh", "1", "f", "_distributionplotter", "_quantile_to_level", "histplot", "kws", "pmax", "pmax", "pthresh", "pthresh", "ax", "ax3", "counts", "_", "hist", "long_df", "x", "long_df", "y", "mesh", "ax3", "collections", "0", "assert", "mesh", "get_clim", "0", "f", "counts", "pmax", "assert_array_equal", "mesh", "get_array", "mask", "counts", "f", "counts", "pthresh", "t", "flat"], "doc_len": 109}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_hue_color_limits", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_hue_color_limits", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_hue_color_limits(self, long_df):\n\n        _, (ax1, ax2, ax3, ax4) = plt.subplots(4)\n        kws = dict(data=long_df, x=\"x\", y=\"y\", hue=\"c\", bins=4)\n\n        hist = Histogram(bins=kws[\"bins\"])\n        hist.define_bin_params(long_df[\"x\"], long_df[\"y\"])\n        full_counts, _ = hist(long_df[\"x\"], long_df[\"y\"])\n\n        sub_counts = []\n        for _, sub_df in long_df.groupby(kws[\"hue\"]):\n            c, _ = hist(sub_df[\"x\"], sub_df[\"y\"])\n            sub_counts.append(c)\n\n        pmax = .8\n        pthresh = .05\n        f = _DistributionPlotter()._quantile_to_level\n\n        histplot(**kws, common_norm=True, ax=ax1)\n        for i, mesh in enumerate(ax1.collections):\n            assert mesh.get_clim() == (0, full_counts.max())\n\n        histplot(**kws, common_norm=False, ax=ax2)\n        for i, mesh in enumerate(ax2.collections):\n            assert mesh.get_clim() == (0, sub_counts[i].max())\n\n        histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n        for i, mesh in enumerate(ax3.collections):\n            assert mesh.get_clim() == (0, f(full_counts, pmax))\n            assert_array_equal(\n                mesh.get_array().mask,\n                (sub_counts[i] <= f(full_counts, pthresh)).T.flat,\n            )\n\n        histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n        for i, mesh in enumerate(ax4.collections):\n            assert mesh.get_clim() == (0, f(sub_counts[i], pmax))\n            assert_array_equal(\n                mesh.get_array().mask,\n                (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat,\n            )\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_hue_color_limits", "self", "long_df", "_", "ax1", "ax2", "ax3", "ax4", "plt", "subplots", "4", "kws", "dict", "data", "long_df", "x", "x", "y", "y", "hue", "c", "bins", "4", "hist", "histogram", "bins", "kws", "bins", "hist", "define_bin_params", "long_df", "x", "long_df", "y", "full_counts", "_", "hist", "long_df", "x", "long_df", "y", "sub_counts", "for", "_", "sub_df", "in", "long_df", "groupby", "kws", "hue", "c", "_", "hist", "sub_df", "x", "sub_df", "y", "sub_counts", "append", "c", "pmax", "8", "pthresh", "05", "f", "_distributionplotter", "_quantile_to_level", "histplot", "kws", "common_norm", "true", "ax", "ax1", "for", "i", "mesh", "in", "enumerate", "ax1", "collections", "assert", "mesh", "get_clim", "0", "full_counts", "max", "histplot", "kws", "common_norm", "false", "ax", "ax2", "for", "i", "mesh", "in", "enumerate", "ax2", "collections", "assert", "mesh", "get_clim", "0", "sub_counts", "i", "max", "histplot", "kws", "common_norm", "true", "pmax", "pmax", "pthresh", "pthresh", "ax", "ax3", "for", "i", "mesh", "in", "enumerate", "ax3", "collections", "assert", "mesh", "get_clim", "0", "f", "full_counts", "pmax", "assert_array_equal", "mesh", "get_array", "mask", "sub_counts", "i", "f", "full_counts", "pthresh", "t", "flat", "histplot", "kws", "common_norm", "false", "pmax", "pmax", "pthresh", "pthresh", "ax", "ax4", "for", "i", "mesh", "in", "enumerate", "ax4", "collections", "assert", "mesh", "get_clim", "0", "f", "sub_counts", "i", "pmax", "assert_array_equal", "mesh", "get_array", "mask", "sub_counts", "i", "f", "sub_counts", "i", "pthresh", "t", "flat"], "doc_len": 183}
{"doc_id": "tests/test_distributions.py::TestHistPlotBivariate.test_colorbar", "file_path": "tests/test_distributions.py", "class_name": "TestHistPlotBivariate", "func_name": "test_colorbar", "text": "文件路径: tests/test_distributions.py, 类名: TestHistPlotBivariate\n    def test_colorbar(self, long_df):\n\n        f, ax = plt.subplots()\n        histplot(long_df, x=\"x\", y=\"y\", cbar=True, ax=ax)\n        assert len(ax.figure.axes) == 2\n\n        f, (ax, cax) = plt.subplots(2)\n        histplot(long_df, x=\"x\", y=\"y\", cbar=True, cbar_ax=cax, ax=ax)\n        assert len(ax.figure.axes) == 2\n", "tokens": ["tests", "test_distributions", "py", "testhistplotbivariate", "def", "test_colorbar", "self", "long_df", "f", "ax", "plt", "subplots", "histplot", "long_df", "x", "x", "y", "y", "cbar", "true", "ax", "ax", "assert", "len", "ax", "figure", "axes", "2", "f", "ax", "cax", "plt", "subplots", "2", "histplot", "long_df", "x", "x", "y", "y", "cbar", "true", "cbar_ax", "cax", "ax", "ax", "assert", "len", "ax", "figure", "axes", "2"], "doc_len": 52}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.get_last_color", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "get_last_color", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def get_last_color(self, ax):\n\n        return to_rgb(ax.lines[-1].get_color())\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "get_last_color", "self", "ax", "return", "to_rgb", "ax", "lines", "1", "get_color"], "doc_len": 14}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_long_vectors", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_long_vectors", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_long_vectors(self, long_df, variable):\n\n        vector = long_df[variable]\n        vectors = [\n            variable, vector, vector.to_numpy(), vector.to_list(),\n        ]\n\n        f, ax = plt.subplots()\n        for vector in vectors:\n            ecdfplot(data=long_df, ax=ax, **{variable: vector})\n\n        xdata = [l.get_xdata() for l in ax.lines]\n        for a, b in itertools.product(xdata, xdata):\n            assert_array_equal(a, b)\n\n        ydata = [l.get_ydata() for l in ax.lines]\n        for a, b in itertools.product(ydata, ydata):\n            assert_array_equal(a, b)\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_long_vectors", "self", "long_df", "variable", "vector", "long_df", "variable", "vectors", "variable", "vector", "vector", "to_numpy", "vector", "to_list", "f", "ax", "plt", "subplots", "for", "vector", "in", "vectors", "ecdfplot", "data", "long_df", "ax", "ax", "variable", "vector", "xdata", "l", "get_xdata", "for", "l", "in", "ax", "lines", "for", "a", "b", "in", "itertools", "product", "xdata", "xdata", "assert_array_equal", "a", "b", "ydata", "l", "get_ydata", "for", "l", "in", "ax", "lines", "for", "a", "b", "in", "itertools", "product", "ydata", "ydata", "assert_array_equal", "a", "b"], "doc_len": 72}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_hue", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_hue", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_hue(self, long_df):\n\n        ax = ecdfplot(long_df, x=\"x\", hue=\"a\")\n\n        for line, color in zip(ax.lines[::-1], color_palette()):\n            assert_colors_equal(line.get_color(), color)\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_hue", "self", "long_df", "ax", "ecdfplot", "long_df", "x", "x", "hue", "a", "for", "line", "color", "in", "zip", "ax", "lines", "1", "color_palette", "assert_colors_equal", "line", "get_color", "color"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_line_kwargs", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_line_kwargs", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_line_kwargs(self, long_df):\n\n        color = \"r\"\n        ls = \"--\"\n        lw = 3\n        ax = ecdfplot(long_df, x=\"x\", color=color, ls=ls, lw=lw)\n\n        for line in ax.lines:\n            assert_colors_equal(line.get_color(), color)\n            assert line.get_linestyle() == ls\n            assert line.get_linewidth() == lw\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_line_kwargs", "self", "long_df", "color", "r", "ls", "lw", "3", "ax", "ecdfplot", "long_df", "x", "x", "color", "color", "ls", "ls", "lw", "lw", "for", "line", "in", "ax", "lines", "assert_colors_equal", "line", "get_color", "color", "assert", "line", "get_linestyle", "ls", "assert", "line", "get_linewidth", "lw"], "doc_len": 41}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_drawstyle", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_drawstyle", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_drawstyle(self, flat_series, data_var):\n\n        ax = ecdfplot(**{data_var: flat_series})\n        drawstyles = dict(x=\"steps-post\", y=\"steps-pre\")\n        assert ax.lines[0].get_drawstyle() == drawstyles[data_var]\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_drawstyle", "self", "flat_series", "data_var", "ax", "ecdfplot", "data_var", "flat_series", "drawstyles", "dict", "x", "steps", "post", "y", "steps", "pre", "assert", "ax", "lines", "0", "get_drawstyle", "drawstyles", "data_var"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_proportion_limits", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_proportion_limits", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_proportion_limits(self, flat_series, data_var, stat_var):\n\n        ax = ecdfplot(**{data_var: flat_series})\n        data = getattr(ax.lines[0], f\"get_{stat_var}data\")()\n        assert data[0] == 0\n        assert data[-1] == 1\n        sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n        assert sticky_edges[:] == [0, 1]\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_proportion_limits", "self", "flat_series", "data_var", "stat_var", "ax", "ecdfplot", "data_var", "flat_series", "data", "getattr", "ax", "lines", "0", "f", "get_", "stat_var", "data", "assert", "data", "0", "0", "assert", "data", "1", "1", "sticky_edges", "getattr", "ax", "lines", "0", "sticky_edges", "stat_var", "assert", "sticky_edges", "0", "1"], "doc_len": 42}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_proportion_limits_complementary", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_proportion_limits_complementary", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_proportion_limits_complementary(self, flat_series, data_var, stat_var):\n\n        ax = ecdfplot(**{data_var: flat_series}, complementary=True)\n        data = getattr(ax.lines[0], f\"get_{stat_var}data\")()\n        assert data[0] == 1\n        assert data[-1] == 0\n        sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n        assert sticky_edges[:] == [0, 1]\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_proportion_limits_complementary", "self", "flat_series", "data_var", "stat_var", "ax", "ecdfplot", "data_var", "flat_series", "complementary", "true", "data", "getattr", "ax", "lines", "0", "f", "get_", "stat_var", "data", "assert", "data", "0", "1", "assert", "data", "1", "0", "sticky_edges", "getattr", "ax", "lines", "0", "sticky_edges", "stat_var", "assert", "sticky_edges", "0", "1"], "doc_len": 44}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_proportion_count", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_proportion_count", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_proportion_count(self, flat_series, data_var, stat_var):\n\n        n = len(flat_series)\n        ax = ecdfplot(**{data_var: flat_series}, stat=\"count\")\n        data = getattr(ax.lines[0], f\"get_{stat_var}data\")()\n        assert data[0] == 0\n        assert data[-1] == n\n        sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n        assert sticky_edges[:] == [0, n]\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_proportion_count", "self", "flat_series", "data_var", "stat_var", "n", "len", "flat_series", "ax", "ecdfplot", "data_var", "flat_series", "stat", "count", "data", "getattr", "ax", "lines", "0", "f", "get_", "stat_var", "data", "assert", "data", "0", "0", "assert", "data", "1", "n", "sticky_edges", "getattr", "ax", "lines", "0", "sticky_edges", "stat_var", "assert", "sticky_edges", "0", "n"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_weights", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_weights", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_weights(self):\n\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, .25, .5, 1])\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_weights", "self", "ax", "ecdfplot", "x", "1", "2", "3", "weights", "1", "1", "2", "y", "ax", "lines", "0", "get_ydata", "assert_array_equal", "y", "0", "25", "5", "1"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_bivariate_error", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_bivariate_error", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_bivariate_error(self, long_df):\n\n        with pytest.raises(NotImplementedError, match=\"Bivariate ECDF plots\"):\n            ecdfplot(data=long_df, x=\"x\", y=\"y\")\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_bivariate_error", "self", "long_df", "with", "pytest", "raises", "notimplementederror", "match", "bivariate", "ecdf", "plots", "ecdfplot", "data", "long_df", "x", "x", "y", "y"], "doc_len": 23}
{"doc_id": "tests/test_distributions.py::TestECDFPlotUnivariate.test_log_scale", "file_path": "tests/test_distributions.py", "class_name": "TestECDFPlotUnivariate", "func_name": "test_log_scale", "text": "文件路径: tests/test_distributions.py, 类名: TestECDFPlotUnivariate\n    def test_log_scale(self, long_df):\n\n        ax1, ax2 = plt.figure().subplots(2)\n\n        ecdfplot(data=long_df, x=\"z\", ax=ax1)\n        ecdfplot(data=long_df, x=\"z\", log_scale=True, ax=ax2)\n\n        # Ignore first point, which either -inf (in linear) or 0 (in log)\n        line1 = ax1.lines[0].get_xydata()[1:]\n        line2 = ax2.lines[0].get_xydata()[1:]\n\n        assert_array_almost_equal(line1, line2)\n", "tokens": ["tests", "test_distributions", "py", "testecdfplotunivariate", "def", "test_log_scale", "self", "long_df", "ax1", "ax2", "plt", "figure", "subplots", "2", "ecdfplot", "data", "long_df", "x", "z", "ax", "ax1", "ecdfplot", "data", "long_df", "x", "z", "log_scale", "true", "ax", "ax2", "ignore", "first", "point", "which", "either", "inf", "in", "linear", "or", "0", "in", "log", "line1", "ax1", "lines", "0", "get_xydata", "1", "line2", "ax2", "lines", "0", "get_xydata", "1", "assert_array_almost_equal", "line1", "line2"], "doc_len": 57}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_versus_single_histplot", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_versus_single_histplot", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_versus_single_histplot(self, long_df, kwargs):\n\n        ax = histplot(long_df, **kwargs)\n        g = displot(long_df, **kwargs)\n        assert_plots_equal(ax, g.ax)\n\n        if ax.legend_ is not None:\n            assert_legends_equal(ax.legend_, g._legend)\n\n        if kwargs:\n            long_df[\"_\"] = \"_\"\n            g2 = displot(long_df, col=\"_\", **kwargs)\n            assert_plots_equal(ax, g2.ax)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_versus_single_histplot", "self", "long_df", "kwargs", "ax", "histplot", "long_df", "kwargs", "g", "displot", "long_df", "kwargs", "assert_plots_equal", "ax", "g", "ax", "if", "ax", "legend_", "is", "not", "none", "assert_legends_equal", "ax", "legend_", "g", "_legend", "if", "kwargs", "long_df", "_", "_", "g2", "displot", "long_df", "col", "_", "kwargs", "assert_plots_equal", "ax", "g2", "ax"], "doc_len": 47}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_versus_single_kdeplot", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_versus_single_kdeplot", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_versus_single_kdeplot(self, long_df, kwargs):\n\n        ax = kdeplot(data=long_df, **kwargs)\n        g = displot(long_df, kind=\"kde\", **kwargs)\n        assert_plots_equal(ax, g.ax)\n\n        if ax.legend_ is not None:\n            assert_legends_equal(ax.legend_, g._legend)\n\n        if kwargs:\n            long_df[\"_\"] = \"_\"\n            g2 = displot(long_df, kind=\"kde\", col=\"_\", **kwargs)\n            assert_plots_equal(ax, g2.ax)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_versus_single_kdeplot", "self", "long_df", "kwargs", "ax", "kdeplot", "data", "long_df", "kwargs", "g", "displot", "long_df", "kind", "kde", "kwargs", "assert_plots_equal", "ax", "g", "ax", "if", "ax", "legend_", "is", "not", "none", "assert_legends_equal", "ax", "legend_", "g", "_legend", "if", "kwargs", "long_df", "_", "_", "g2", "displot", "long_df", "kind", "kde", "col", "_", "kwargs", "assert_plots_equal", "ax", "g2", "ax"], "doc_len": 52}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_versus_single_ecdfplot", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_versus_single_ecdfplot", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_versus_single_ecdfplot(self, long_df, kwargs):\n\n        ax = ecdfplot(data=long_df, **kwargs)\n        g = displot(long_df, kind=\"ecdf\", **kwargs)\n        assert_plots_equal(ax, g.ax)\n\n        if ax.legend_ is not None:\n            assert_legends_equal(ax.legend_, g._legend)\n\n        if kwargs:\n            long_df[\"_\"] = \"_\"\n            g2 = displot(long_df, kind=\"ecdf\", col=\"_\", **kwargs)\n            assert_plots_equal(ax, g2.ax)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_versus_single_ecdfplot", "self", "long_df", "kwargs", "ax", "ecdfplot", "data", "long_df", "kwargs", "g", "displot", "long_df", "kind", "ecdf", "kwargs", "assert_plots_equal", "ax", "g", "ax", "if", "ax", "legend_", "is", "not", "none", "assert_legends_equal", "ax", "legend_", "g", "_legend", "if", "kwargs", "long_df", "_", "_", "g2", "displot", "long_df", "kind", "ecdf", "col", "_", "kwargs", "assert_plots_equal", "ax", "g2", "ax"], "doc_len": 52}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_with_rug", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_with_rug", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_with_rug(self, long_df, kwargs):\n\n        ax = plt.figure().subplots()\n        histplot(data=long_df, **kwargs, ax=ax)\n        rugplot(data=long_df, **kwargs, ax=ax)\n\n        g = displot(long_df, rug=True, **kwargs)\n\n        assert_plots_equal(ax, g.ax, labels=False)\n\n        long_df[\"_\"] = \"_\"\n        g2 = displot(long_df, col=\"_\", rug=True, **kwargs)\n\n        assert_plots_equal(ax, g2.ax, labels=False)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_with_rug", "self", "long_df", "kwargs", "ax", "plt", "figure", "subplots", "histplot", "data", "long_df", "kwargs", "ax", "ax", "rugplot", "data", "long_df", "kwargs", "ax", "ax", "g", "displot", "long_df", "rug", "true", "kwargs", "assert_plots_equal", "ax", "g", "ax", "labels", "false", "long_df", "_", "_", "g2", "displot", "long_df", "col", "_", "rug", "true", "kwargs", "assert_plots_equal", "ax", "g2", "ax", "labels", "false"], "doc_len": 54}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_facets", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_facets", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_facets(self, long_df, facet_var):\n\n        kwargs = {facet_var: \"a\"}\n        ax = kdeplot(data=long_df, x=\"x\", hue=\"a\")\n        g = displot(long_df, x=\"x\", kind=\"kde\", **kwargs)\n\n        legend_texts = ax.legend_.get_texts()\n\n        for i, line in enumerate(ax.lines[::-1]):\n            facet_ax = g.axes.flat[i]\n            facet_line = facet_ax.lines[0]\n            assert_array_equal(line.get_xydata(), facet_line.get_xydata())\n\n            text = legend_texts[i].get_text()\n            assert text in facet_ax.get_title()\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_facets", "self", "long_df", "facet_var", "kwargs", "facet_var", "a", "ax", "kdeplot", "data", "long_df", "x", "x", "hue", "a", "g", "displot", "long_df", "x", "x", "kind", "kde", "kwargs", "legend_texts", "ax", "legend_", "get_texts", "for", "i", "line", "in", "enumerate", "ax", "lines", "1", "facet_ax", "g", "axes", "flat", "i", "facet_line", "facet_ax", "lines", "0", "assert_array_equal", "line", "get_xydata", "facet_line", "get_xydata", "text", "legend_texts", "i", "get_text", "assert", "text", "in", "facet_ax", "get_title"], "doc_len": 63}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_facet_multiple", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_facet_multiple", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_facet_multiple(self, long_df, multiple):\n\n        bins = np.linspace(0, 20, 5)\n        ax = histplot(\n            data=long_df[long_df[\"c\"] == 0],\n            x=\"x\", hue=\"a\", hue_order=[\"a\", \"b\", \"c\"],\n            multiple=multiple, bins=bins,\n        )\n\n        g = displot(\n            data=long_df, x=\"x\", hue=\"a\", col=\"c\", hue_order=[\"a\", \"b\", \"c\"],\n            multiple=multiple, bins=bins,\n        )\n\n        assert_plots_equal(ax, g.axes_dict[0])\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_facet_multiple", "self", "long_df", "multiple", "bins", "np", "linspace", "0", "20", "5", "ax", "histplot", "data", "long_df", "long_df", "c", "0", "x", "x", "hue", "a", "hue_order", "a", "b", "c", "multiple", "multiple", "bins", "bins", "g", "displot", "data", "long_df", "x", "x", "hue", "a", "col", "c", "hue_order", "a", "b", "c", "multiple", "multiple", "bins", "bins", "assert_plots_equal", "ax", "g", "axes_dict", "0"], "doc_len": 57}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_ax_warning", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_ax_warning", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_ax_warning(self, long_df):\n\n        ax = plt.figure().subplots()\n        with pytest.warns(UserWarning, match=\"`displot` is a figure-level\"):\n            displot(long_df, x=\"x\", ax=ax)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_ax_warning", "self", "long_df", "ax", "plt", "figure", "subplots", "with", "pytest", "warns", "userwarning", "match", "displot", "is", "a", "figure", "level", "displot", "long_df", "x", "x", "ax", "ax"], "doc_len": 28}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_array_faceting", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_array_faceting", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_array_faceting(self, long_df, key):\n\n        a = long_df[\"a\"].to_numpy()\n        vals = categorical_order(a)\n        g = displot(long_df, x=\"x\", **{key: a})\n        assert len(g.axes.flat) == len(vals)\n        for ax, val in zip(g.axes.flat, vals):\n            assert val in ax.get_title()\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_array_faceting", "self", "long_df", "key", "a", "long_df", "a", "to_numpy", "vals", "categorical_order", "a", "g", "displot", "long_df", "x", "x", "key", "a", "assert", "len", "g", "axes", "flat", "len", "vals", "for", "ax", "val", "in", "zip", "g", "axes", "flat", "vals", "assert", "val", "in", "ax", "get_title"], "doc_len": 44}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_legend", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_legend", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_legend(self, long_df):\n\n        g = displot(long_df, x=\"x\", hue=\"a\")\n        assert g._legend is not None\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_legend", "self", "long_df", "g", "displot", "long_df", "x", "x", "hue", "a", "assert", "g", "_legend", "is", "not", "none"], "doc_len": 21}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_empty", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_empty", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_empty(self):\n\n        g = displot(x=[], y=[])\n        assert isinstance(g, FacetGrid)\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_empty", "self", "g", "displot", "x", "y", "assert", "isinstance", "g", "facetgrid"], "doc_len": 15}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_bivariate_ecdf_error", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_bivariate_ecdf_error", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_bivariate_ecdf_error(self, long_df):\n\n        with pytest.raises(NotImplementedError):\n            displot(long_df, x=\"x\", y=\"y\", kind=\"ecdf\")\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_bivariate_ecdf_error", "self", "long_df", "with", "pytest", "raises", "notimplementederror", "displot", "long_df", "x", "x", "y", "y", "kind", "ecdf"], "doc_len": 20}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_bivariate_kde_norm", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_bivariate_kde_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_bivariate_kde_norm(self, rng):\n\n        x, y = rng.normal(0, 1, (2, 100))\n        z = [0] * 80 + [1] * 20\n\n        g = displot(x=x, y=y, col=z, kind=\"kde\", levels=10)\n        l1 = sum(bool(get_contour_coords(c)) for c in g.axes.flat[0].collections)\n        l2 = sum(bool(get_contour_coords(c)) for c in g.axes.flat[1].collections)\n        assert l1 > l2\n\n        g = displot(x=x, y=y, col=z, kind=\"kde\", levels=10, common_norm=False)\n        l1 = sum(bool(get_contour_coords(c)) for c in g.axes.flat[0].collections)\n        l2 = sum(bool(get_contour_coords(c)) for c in g.axes.flat[1].collections)\n        assert l1 == l2\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_bivariate_kde_norm", "self", "rng", "x", "y", "rng", "normal", "0", "1", "2", "100", "z", "0", "80", "1", "20", "g", "displot", "x", "x", "y", "y", "col", "z", "kind", "kde", "levels", "10", "l1", "sum", "bool", "get_contour_coords", "c", "for", "c", "in", "g", "axes", "flat", "0", "collections", "l2", "sum", "bool", "get_contour_coords", "c", "for", "c", "in", "g", "axes", "flat", "1", "collections", "assert", "l1", "l2", "g", "displot", "x", "x", "y", "y", "col", "z", "kind", "kde", "levels", "10", "common_norm", "false", "l1", "sum", "bool", "get_contour_coords", "c", "for", "c", "in", "g", "axes", "flat", "0", "collections", "l2", "sum", "bool", "get_contour_coords", "c", "for", "c", "in", "g", "axes", "flat", "1", "collections", "assert", "l1", "l2"], "doc_len": 105}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_bivariate_hist_norm", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_bivariate_hist_norm", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_bivariate_hist_norm(self, rng):\n\n        x, y = rng.normal(0, 1, (2, 100))\n        z = [0] * 80 + [1] * 20\n\n        g = displot(x=x, y=y, col=z, kind=\"hist\")\n        clim1 = g.axes.flat[0].collections[0].get_clim()\n        clim2 = g.axes.flat[1].collections[0].get_clim()\n        assert clim1 == clim2\n\n        g = displot(x=x, y=y, col=z, kind=\"hist\", common_norm=False)\n        clim1 = g.axes.flat[0].collections[0].get_clim()\n        clim2 = g.axes.flat[1].collections[0].get_clim()\n        assert clim1[1] > clim2[1]\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_bivariate_hist_norm", "self", "rng", "x", "y", "rng", "normal", "0", "1", "2", "100", "z", "0", "80", "1", "20", "g", "displot", "x", "x", "y", "y", "col", "z", "kind", "hist", "clim1", "g", "axes", "flat", "0", "collections", "0", "get_clim", "clim2", "g", "axes", "flat", "1", "collections", "0", "get_clim", "assert", "clim1", "clim2", "g", "displot", "x", "x", "y", "y", "col", "z", "kind", "hist", "common_norm", "false", "clim1", "g", "axes", "flat", "0", "collections", "0", "get_clim", "clim2", "g", "axes", "flat", "1", "collections", "0", "get_clim", "assert", "clim1", "1", "clim2", "1"], "doc_len": 83}
{"doc_id": "tests/test_distributions.py::TestDisPlot.test_facetgrid_data", "file_path": "tests/test_distributions.py", "class_name": "TestDisPlot", "func_name": "test_facetgrid_data", "text": "文件路径: tests/test_distributions.py, 类名: TestDisPlot\n    def test_facetgrid_data(self, long_df):\n\n        g = displot(\n            data=long_df.to_dict(orient=\"list\"),\n            x=\"z\",\n            hue=long_df[\"a\"].rename(\"hue_var\"),\n            col=long_df[\"c\"].to_numpy(),\n        )\n        expected_cols = set(long_df.columns.to_list() + [\"hue_var\", \"_col_\"])\n        assert set(g.data.columns) == expected_cols\n        assert_array_equal(g.data[\"hue_var\"], long_df[\"a\"])\n        assert_array_equal(g.data[\"_col_\"], long_df[\"c\"])\n", "tokens": ["tests", "test_distributions", "py", "testdisplot", "def", "test_facetgrid_data", "self", "long_df", "g", "displot", "data", "long_df", "to_dict", "orient", "list", "x", "z", "hue", "long_df", "a", "rename", "hue_var", "col", "long_df", "c", "to_numpy", "expected_cols", "set", "long_df", "columns", "to_list", "hue_var", "_col_", "assert", "set", "g", "data", "columns", "expected_cols", "assert_array_equal", "g", "data", "hue_var", "long_df", "a", "assert_array_equal", "g", "data", "_col_", "long_df", "c"], "doc_len": 51}
{"doc_id": "tests/test_distributions.py::integrate", "file_path": "tests/test_distributions.py", "class_name": null, "func_name": "integrate", "text": "文件路径: tests/test_distributions.py\ndef integrate(y, x):\n    \"\"\"\"Simple numerical integration for testing KDE code.\"\"\"\n    y = np.asarray(y)\n    x = np.asarray(x)\n    dx = np.diff(x)\n    return (dx * y[:-1] + dx * y[1:]).sum() / 2\n", "tokens": ["tests", "test_distributions", "py", "def", "integrate", "y", "x", "simple", "numerical", "integration", "for", "testing", "kde", "code", "y", "np", "asarray", "y", "x", "np", "asarray", "x", "dx", "np", "diff", "x", "return", "dx", "y", "1", "dx", "y", "1", "sum", "2"], "doc_len": 35}
{"doc_id": "tests/test_docstrings.py::ExampleClass.example_method", "file_path": "tests/test_docstrings.py", "class_name": "ExampleClass", "func_name": "example_method", "text": "文件路径: tests/test_docstrings.py, 类名: ExampleClass\n    def example_method(self):\n        \"\"\"An example method.\n\n        Parameters\n        ----------\n        a : str\n           A method parameter.\n\n        \"\"\"\n", "tokens": ["tests", "test_docstrings", "py", "exampleclass", "def", "example_method", "self", "an", "example", "method", "parameters", "a", "str", "a", "method", "parameter"], "doc_len": 16}
{"doc_id": "tests/test_docstrings.py::example_func", "file_path": "tests/test_docstrings.py", "class_name": null, "func_name": "example_func", "text": "文件路径: tests/test_docstrings.py\ndef example_func():\n    \"\"\"An example function.\n\n    Parameters\n    ----------\n    a : str\n        A function parameter.\n\n    \"\"\"\n", "tokens": ["tests", "test_docstrings", "py", "def", "example_func", "an", "example", "function", "parameters", "a", "str", "a", "function", "parameter"], "doc_len": 14}
{"doc_id": "tests/test_docstrings.py::TestDocstringComponents.test_from_dict", "file_path": "tests/test_docstrings.py", "class_name": "TestDocstringComponents", "func_name": "test_from_dict", "text": "文件路径: tests/test_docstrings.py, 类名: TestDocstringComponents\n    def test_from_dict(self):\n\n        obj = DocstringComponents(EXAMPLE_DICT)\n        assert obj.param_a == \"a : str\\n    The first parameter.\"\n", "tokens": ["tests", "test_docstrings", "py", "testdocstringcomponents", "def", "test_from_dict", "self", "obj", "docstringcomponents", "example_dict", "assert", "obj", "param_a", "a", "str", "n", "the", "first", "parameter"], "doc_len": 19}
{"doc_id": "tests/test_docstrings.py::TestDocstringComponents.test_from_nested_components", "file_path": "tests/test_docstrings.py", "class_name": "TestDocstringComponents", "func_name": "test_from_nested_components", "text": "文件路径: tests/test_docstrings.py, 类名: TestDocstringComponents\n    def test_from_nested_components(self):\n\n        obj_inner = DocstringComponents(EXAMPLE_DICT)\n        obj_outer = DocstringComponents.from_nested_components(inner=obj_inner)\n        assert obj_outer.inner.param_a == \"a : str\\n    The first parameter.\"\n", "tokens": ["tests", "test_docstrings", "py", "testdocstringcomponents", "def", "test_from_nested_components", "self", "obj_inner", "docstringcomponents", "example_dict", "obj_outer", "docstringcomponents", "from_nested_components", "inner", "obj_inner", "assert", "obj_outer", "inner", "param_a", "a", "str", "n", "the", "first", "parameter"], "doc_len": 25}
{"doc_id": "tests/test_docstrings.py::TestDocstringComponents.test_from_function", "file_path": "tests/test_docstrings.py", "class_name": "TestDocstringComponents", "func_name": "test_from_function", "text": "文件路径: tests/test_docstrings.py, 类名: TestDocstringComponents\n    def test_from_function(self):\n\n        obj = DocstringComponents.from_function_params(example_func)\n        assert obj.a == \"a : str\\n    A function parameter.\"\n", "tokens": ["tests", "test_docstrings", "py", "testdocstringcomponents", "def", "test_from_function", "self", "obj", "docstringcomponents", "from_function_params", "example_func", "assert", "obj", "a", "a", "str", "n", "a", "function", "parameter"], "doc_len": 20}
{"doc_id": "tests/test_docstrings.py::TestDocstringComponents.test_from_method", "file_path": "tests/test_docstrings.py", "class_name": "TestDocstringComponents", "func_name": "test_from_method", "text": "文件路径: tests/test_docstrings.py, 类名: TestDocstringComponents\n    def test_from_method(self):\n\n        obj = DocstringComponents.from_function_params(\n            ExampleClass.example_method\n        )\n        assert obj.a == \"a : str\\n    A method parameter.\"\n", "tokens": ["tests", "test_docstrings", "py", "testdocstringcomponents", "def", "test_from_method", "self", "obj", "docstringcomponents", "from_function_params", "exampleclass", "example_method", "assert", "obj", "a", "a", "str", "n", "a", "method", "parameter"], "doc_len": 21}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_ndarray_input", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_ndarray_input", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_ndarray_input(self):\n\n        p = mat._HeatMapper(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, np.arange(4))\n\n        assert p.xlabel == \"\"\n        assert p.ylabel == \"\"\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_ndarray_input", "self", "p", "mat", "_heatmapper", "self", "x_norm", "self", "default_kws", "npt", "assert_array_equal", "p", "plot_data", "self", "x_norm", "pdt", "assert_frame_equal", "p", "data", "pd", "dataframe", "self", "x_norm", "npt", "assert_array_equal", "p", "xticklabels", "np", "arange", "8", "npt", "assert_array_equal", "p", "yticklabels", "np", "arange", "4", "assert", "p", "xlabel", "assert", "p", "ylabel"], "doc_len": 48}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_df_input", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_df_input", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_df_input(self):\n\n        p = mat._HeatMapper(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.plot_data, self.x_norm)\n        pdt.assert_frame_equal(p.data, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, np.arange(8))\n        npt.assert_array_equal(p.yticklabels, self.letters.values)\n\n        assert p.xlabel == \"\"\n        assert p.ylabel == \"letters\"\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_df_input", "self", "p", "mat", "_heatmapper", "self", "df_norm", "self", "default_kws", "npt", "assert_array_equal", "p", "plot_data", "self", "x_norm", "pdt", "assert_frame_equal", "p", "data", "self", "df_norm", "npt", "assert_array_equal", "p", "xticklabels", "np", "arange", "8", "npt", "assert_array_equal", "p", "yticklabels", "self", "letters", "values", "assert", "p", "xlabel", "assert", "p", "ylabel", "letters"], "doc_len": 47}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_df_multindex_input", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_df_multindex_input", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n\n        p = mat._HeatMapper(df, **self.default_kws)\n\n        combined_tick_labels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n        assert p.ylabel == \"letter-number\"\n\n        p = mat._HeatMapper(df.T, **self.default_kws)\n\n        npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n        assert p.xlabel == \"letter-number\"\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_df_multindex_input", "self", "df", "self", "df_norm", "copy", "index", "pd", "multiindex", "from_tuples", "a", "1", "b", "2", "c", "3", "d", "4", "names", "letter", "number", "index", "name", "letter", "number", "df", "index", "index", "p", "mat", "_heatmapper", "df", "self", "default_kws", "combined_tick_labels", "a", "1", "b", "2", "c", "3", "d", "4", "npt", "assert_array_equal", "p", "yticklabels", "combined_tick_labels", "assert", "p", "ylabel", "letter", "number", "p", "mat", "_heatmapper", "df", "t", "self", "default_kws", "npt", "assert_array_equal", "p", "xticklabels", "combined_tick_labels", "assert", "p", "xlabel", "letter", "number"], "doc_len": 75}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_mask_input", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_mask_input", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_mask_input(self, dtype):\n        kws = self.default_kws.copy()\n\n        mask = self.x_norm > 0\n        kws['mask'] = mask\n        data = self.x_norm.astype(dtype)\n        p = mat._HeatMapper(data, **kws)\n        plot_data = np.ma.masked_where(mask, data)\n\n        npt.assert_array_equal(p.plot_data, plot_data)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_mask_input", "self", "dtype", "kws", "self", "default_kws", "copy", "mask", "self", "x_norm", "0", "kws", "mask", "mask", "data", "self", "x_norm", "astype", "dtype", "p", "mat", "_heatmapper", "data", "kws", "plot_data", "np", "ma", "masked_where", "mask", "data", "npt", "assert_array_equal", "p", "plot_data", "plot_data"], "doc_len": 40}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_mask_limits", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_mask_limits", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_mask_limits(self):\n        \"\"\"Make sure masked cells are not used to calculate extremes\"\"\"\n\n        kws = self.default_kws.copy()\n\n        mask = self.x_norm > 0\n        kws['mask'] = mask\n        p = mat._HeatMapper(self.x_norm, **kws)\n\n        assert p.vmax == np.ma.array(self.x_norm, mask=mask).max()\n        assert p.vmin == np.ma.array(self.x_norm, mask=mask).min()\n\n        mask = self.x_norm < 0\n        kws['mask'] = mask\n        p = mat._HeatMapper(self.x_norm, **kws)\n\n        assert p.vmin == np.ma.array(self.x_norm, mask=mask).min()\n        assert p.vmax == np.ma.array(self.x_norm, mask=mask).max()\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_mask_limits", "self", "make", "sure", "masked", "cells", "are", "not", "used", "to", "calculate", "extremes", "kws", "self", "default_kws", "copy", "mask", "self", "x_norm", "0", "kws", "mask", "mask", "p", "mat", "_heatmapper", "self", "x_norm", "kws", "assert", "p", "vmax", "np", "ma", "array", "self", "x_norm", "mask", "mask", "max", "assert", "p", "vmin", "np", "ma", "array", "self", "x_norm", "mask", "mask", "min", "mask", "self", "x_norm", "0", "kws", "mask", "mask", "p", "mat", "_heatmapper", "self", "x_norm", "kws", "assert", "p", "vmin", "np", "ma", "array", "self", "x_norm", "mask", "mask", "min", "assert", "p", "vmax", "np", "ma", "array", "self", "x_norm", "mask", "mask", "max"], "doc_len": 91}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_default_vlims", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_default_vlims", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_default_vlims(self):\n\n        p = mat._HeatMapper(self.df_unif, **self.default_kws)\n        assert p.vmin == self.x_unif.min()\n        assert p.vmax == self.x_unif.max()\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_default_vlims", "self", "p", "mat", "_heatmapper", "self", "df_unif", "self", "default_kws", "assert", "p", "vmin", "self", "x_unif", "min", "assert", "p", "vmax", "self", "x_unif", "max"], "doc_len": 26}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_robust_vlims", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_robust_vlims", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_robust_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"robust\"] = True\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        assert p.vmin == np.percentile(self.x_unif, 2)\n        assert p.vmax == np.percentile(self.x_unif, 98)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_robust_vlims", "self", "kws", "self", "default_kws", "copy", "kws", "robust", "true", "p", "mat", "_heatmapper", "self", "df_unif", "kws", "assert", "p", "vmin", "np", "percentile", "self", "x_unif", "2", "assert", "p", "vmax", "np", "percentile", "self", "x_unif", "98"], "doc_len": 36}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_sequential_vlims", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_sequential_vlims", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_sequential_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = 0\n        kws[\"vmax\"] = 1\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        assert p.vmin == 0\n        assert p.vmax == 1\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_sequential_vlims", "self", "kws", "self", "default_kws", "copy", "kws", "vmin", "0", "kws", "vmax", "1", "p", "mat", "_heatmapper", "self", "df_unif", "kws", "assert", "p", "vmin", "0", "assert", "p", "vmax", "1"], "doc_len": 31}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_diverging_vlims", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_diverging_vlims", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_diverging_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"vmin\"] = -4\n        kws[\"vmax\"] = 5\n        kws[\"center\"] = 0\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        assert p.vmin == -4\n        assert p.vmax == 5\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_diverging_vlims", "self", "kws", "self", "default_kws", "copy", "kws", "vmin", "4", "kws", "vmax", "5", "kws", "center", "0", "p", "mat", "_heatmapper", "self", "df_norm", "kws", "assert", "p", "vmin", "4", "assert", "p", "vmax", "5"], "doc_len": 34}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_array_with_nans", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_array_with_nans", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_array_with_nans(self):\n\n        x1 = self.rs.rand(10, 10)\n        nulls = np.zeros(10) * np.nan\n        x2 = np.c_[x1, nulls]\n\n        m1 = mat._HeatMapper(x1, **self.default_kws)\n        m2 = mat._HeatMapper(x2, **self.default_kws)\n\n        assert m1.vmin == m2.vmin\n        assert m1.vmax == m2.vmax\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_array_with_nans", "self", "x1", "self", "rs", "rand", "10", "10", "nulls", "np", "zeros", "10", "np", "nan", "x2", "np", "c_", "x1", "nulls", "m1", "mat", "_heatmapper", "x1", "self", "default_kws", "m2", "mat", "_heatmapper", "x2", "self", "default_kws", "assert", "m1", "vmin", "m2", "vmin", "assert", "m1", "vmax", "m2", "vmax"], "doc_len": 46}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_mask", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_mask", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = np.isnan(df.values)\n\n        m = mat._HeatMapper(df, **kws)\n\n        npt.assert_array_equal(np.isnan(m.plot_data.data),\n                               m.plot_data.mask)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_mask", "self", "df", "pd", "dataframe", "data", "a", "1", "1", "1", "b", "2", "np", "nan", "2", "c", "3", "3", "np", "nan", "kws", "self", "default_kws", "copy", "kws", "mask", "np", "isnan", "df", "values", "m", "mat", "_heatmapper", "df", "kws", "npt", "assert_array_equal", "np", "isnan", "m", "plot_data", "data", "m", "plot_data", "mask"], "doc_len": 50}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_cmap", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_cmap", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_cmap(self):\n\n        kws = self.default_kws.copy()\n        kws[\"cmap\"] = \"BuGn\"\n        p = mat._HeatMapper(self.df_unif, **kws)\n        assert p.cmap == mpl.cm.BuGn\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_cmap", "self", "kws", "self", "default_kws", "copy", "kws", "cmap", "bugn", "p", "mat", "_heatmapper", "self", "df_unif", "kws", "assert", "p", "cmap", "mpl", "cm", "bugn"], "doc_len": 26}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_centered_vlims", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_centered_vlims", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_centered_vlims(self):\n\n        kws = self.default_kws.copy()\n        kws[\"center\"] = .5\n\n        p = mat._HeatMapper(self.df_unif, **kws)\n\n        assert p.vmin == self.df_unif.values.min()\n        assert p.vmax == self.df_unif.values.max()\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_centered_vlims", "self", "kws", "self", "default_kws", "copy", "kws", "center", "5", "p", "mat", "_heatmapper", "self", "df_unif", "kws", "assert", "p", "vmin", "self", "df_unif", "values", "min", "assert", "p", "vmax", "self", "df_unif", "values", "max"], "doc_len": 34}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_default_colors", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_default_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_default_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        cvals = np.linspace(0, 1, 9)\n        npt.assert_array_almost_equal(fc, cmap(cvals), 2)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_default_colors", "self", "vals", "np", "linspace", "2", "1", "9", "cmap", "mpl", "cm", "binary", "ax", "mat", "heatmap", "vals", "cmap", "cmap", "fc", "ax", "collections", "0", "get_facecolors", "cvals", "np", "linspace", "0", "1", "9", "npt", "assert_array_almost_equal", "fc", "cmap", "cvals", "2"], "doc_len": 40}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_vlim_colors", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_vlim_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_vlim_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], vmin=0, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_vlim_colors", "self", "vals", "np", "linspace", "2", "1", "9", "cmap", "mpl", "cm", "binary", "ax", "mat", "heatmap", "vals", "vmin", "0", "cmap", "cmap", "fc", "ax", "collections", "0", "get_facecolors", "npt", "assert_array_almost_equal", "fc", "cmap", "vals", "2"], "doc_len": 36}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_center_colors", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_center_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_center_colors(self):\n\n        vals = np.linspace(.2, 1, 9)\n        cmap = mpl.cm.binary\n        ax = mat.heatmap([vals], center=.5, cmap=cmap)\n        fc = ax.collections[0].get_facecolors()\n        npt.assert_array_almost_equal(fc, cmap(vals), 2)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_center_colors", "self", "vals", "np", "linspace", "2", "1", "9", "cmap", "mpl", "cm", "binary", "ax", "mat", "heatmap", "vals", "center", "5", "cmap", "cmap", "fc", "ax", "collections", "0", "get_facecolors", "npt", "assert_array_almost_equal", "fc", "cmap", "vals", "2"], "doc_len": 36}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_cmap_with_properties", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_cmap_with_properties", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_cmap_with_properties(self):\n\n        kws = self.default_kws.copy()\n        cmap = copy.copy(get_colormap(\"BrBG\"))\n        cmap.set_bad(\"red\")\n        kws[\"cmap\"] = cmap\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(\n            cmap(np.ma.masked_invalid([np.nan])),\n            hm.cmap(np.ma.masked_invalid([np.nan])))\n\n        kws[\"center\"] = 0.5\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(\n            cmap(np.ma.masked_invalid([np.nan])),\n            hm.cmap(np.ma.masked_invalid([np.nan])))\n\n        kws = self.default_kws.copy()\n        cmap = copy.copy(get_colormap(\"BrBG\"))\n        cmap.set_under(\"red\")\n        kws[\"cmap\"] = cmap\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(cmap(-np.inf), hm.cmap(-np.inf))\n\n        kws[\"center\"] = .5\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(cmap(-np.inf), hm.cmap(-np.inf))\n\n        kws = self.default_kws.copy()\n        cmap = copy.copy(get_colormap(\"BrBG\"))\n        cmap.set_over(\"red\")\n        kws[\"cmap\"] = cmap\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(cmap(-np.inf), hm.cmap(-np.inf))\n\n        kws[\"center\"] = .5\n        hm = mat._HeatMapper(self.df_unif, **kws)\n        npt.assert_array_equal(cmap(np.inf), hm.cmap(np.inf))\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_cmap_with_properties", "self", "kws", "self", "default_kws", "copy", "cmap", "copy", "copy", "get_colormap", "brbg", "cmap", "set_bad", "red", "kws", "cmap", "cmap", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "ma", "masked_invalid", "np", "nan", "hm", "cmap", "np", "ma", "masked_invalid", "np", "nan", "kws", "center", "0", "5", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "ma", "masked_invalid", "np", "nan", "hm", "cmap", "np", "ma", "masked_invalid", "np", "nan", "kws", "self", "default_kws", "copy", "cmap", "copy", "copy", "get_colormap", "brbg", "cmap", "set_under", "red", "kws", "cmap", "cmap", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "inf", "hm", "cmap", "np", "inf", "kws", "center", "5", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "inf", "hm", "cmap", "np", "inf", "kws", "self", "default_kws", "copy", "cmap", "copy", "copy", "get_colormap", "brbg", "cmap", "set_over", "red", "kws", "cmap", "cmap", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "inf", "hm", "cmap", "np", "inf", "kws", "center", "5", "hm", "mat", "_heatmapper", "self", "df_unif", "kws", "npt", "assert_array_equal", "cmap", "np", "inf", "hm", "cmap", "np", "inf"], "doc_len": 164}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_ticklabels_off", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_ticklabels_off", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_ticklabels_off(self):\n        kws = self.default_kws.copy()\n        kws['xticklabels'] = False\n        kws['yticklabels'] = False\n        p = mat._HeatMapper(self.df_norm, **kws)\n        assert p.xticklabels == []\n        assert p.yticklabels == []\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_ticklabels_off", "self", "kws", "self", "default_kws", "copy", "kws", "xticklabels", "false", "kws", "yticklabels", "false", "p", "mat", "_heatmapper", "self", "df_norm", "kws", "assert", "p", "xticklabels", "assert", "p", "yticklabels"], "doc_len": 29}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_ticklabels", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_ticklabels", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_ticklabels(self):\n        kws = self.default_kws.copy()\n        xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n        yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n        kws['xticklabels'] = xticklabels\n        kws['yticklabels'] = yticklabels\n        p = mat._HeatMapper(self.df_norm, **kws)\n        assert p.xticklabels == xticklabels\n        assert p.yticklabels == yticklabels\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_ticklabels", "self", "kws", "self", "default_kws", "copy", "xticklabels", "list", "iheartheatmaps", "self", "df_norm", "shape", "1", "yticklabels", "list", "heatmapsarecool", "self", "df_norm", "shape", "0", "kws", "xticklabels", "xticklabels", "kws", "yticklabels", "yticklabels", "p", "mat", "_heatmapper", "self", "df_norm", "kws", "assert", "p", "xticklabels", "xticklabels", "assert", "p", "yticklabels", "yticklabels"], "doc_len": 45}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_custom_ticklabel_interval", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_custom_ticklabel_interval", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_custom_ticklabel_interval(self):\n\n        kws = self.default_kws.copy()\n        xstep, ystep = 2, 3\n        kws['xticklabels'] = xstep\n        kws['yticklabels'] = ystep\n        p = mat._HeatMapper(self.df_norm, **kws)\n\n        nx, ny = self.df_norm.T.shape\n        npt.assert_array_equal(p.xticks, np.arange(0, nx, xstep) + .5)\n        npt.assert_array_equal(p.yticks, np.arange(0, ny, ystep) + .5)\n        npt.assert_array_equal(p.xticklabels,\n                               self.df_norm.columns[0:nx:xstep])\n        npt.assert_array_equal(p.yticklabels,\n                               self.df_norm.index[0:ny:ystep])\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_custom_ticklabel_interval", "self", "kws", "self", "default_kws", "copy", "xstep", "ystep", "2", "3", "kws", "xticklabels", "xstep", "kws", "yticklabels", "ystep", "p", "mat", "_heatmapper", "self", "df_norm", "kws", "nx", "ny", "self", "df_norm", "t", "shape", "npt", "assert_array_equal", "p", "xticks", "np", "arange", "0", "nx", "xstep", "5", "npt", "assert_array_equal", "p", "yticks", "np", "arange", "0", "ny", "ystep", "5", "npt", "assert_array_equal", "p", "xticklabels", "self", "df_norm", "columns", "0", "nx", "xstep", "npt", "assert_array_equal", "p", "yticklabels", "self", "df_norm", "index", "0", "ny", "ystep"], "doc_len": 73}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            assert text.get_text() == f\"{val:.1f}\"\n            assert text.get_fontsize() == 14\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation", "self", "ax", "mat", "heatmap", "self", "df_norm", "annot", "true", "fmt", "1f", "annot_kws", "fontsize", "14", "for", "val", "text", "in", "zip", "self", "x_norm", "flat", "ax", "texts", "assert", "text", "get_text", "f", "val", "1f", "assert", "text", "get_fontsize", "14"], "doc_len": 39}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_overwrite_kws", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_overwrite_kws", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_overwrite_kws(self):\n\n        annot_kws = dict(color=\"0.3\", va=\"bottom\", ha=\"left\")\n        ax = mat.heatmap(self.df_norm, annot=True, fmt=\".1f\",\n                         annot_kws=annot_kws)\n        for text in ax.texts:\n            assert text.get_color() == \"0.3\"\n            assert text.get_ha() == \"left\"\n            assert text.get_va() == \"bottom\"\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_overwrite_kws", "self", "annot_kws", "dict", "color", "0", "3", "va", "bottom", "ha", "left", "ax", "mat", "heatmap", "self", "df_norm", "annot", "true", "fmt", "1f", "annot_kws", "annot_kws", "for", "text", "in", "ax", "texts", "assert", "text", "get_color", "0", "3", "assert", "text", "get_ha", "left", "assert", "text", "get_va", "bottom"], "doc_len": 45}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_with_mask", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_with_mask", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_with_mask(self):\n\n        df = pd.DataFrame(data={'a': [1, 1, 1],\n                                'b': [2, np.nan, 2],\n                                'c': [3, 3, np.nan]})\n        mask = np.isnan(df.values)\n        df_masked = np.ma.masked_where(mask, df)\n        ax = mat.heatmap(df, annot=True, fmt='.1f', mask=mask)\n        assert len(df_masked.compressed()) == len(ax.texts)\n        for val, text in zip(df_masked.compressed(), ax.texts):\n            assert f\"{val:.1f}\" == text.get_text()\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_with_mask", "self", "df", "pd", "dataframe", "data", "a", "1", "1", "1", "b", "2", "np", "nan", "2", "c", "3", "3", "np", "nan", "mask", "np", "isnan", "df", "values", "df_masked", "np", "ma", "masked_where", "mask", "df", "ax", "mat", "heatmap", "df", "annot", "true", "fmt", "1f", "mask", "mask", "assert", "len", "df_masked", "compressed", "len", "ax", "texts", "for", "val", "text", "in", "zip", "df_masked", "compressed", "ax", "texts", "assert", "f", "val", "1f", "text", "get_text"], "doc_len": 68}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_mesh_colors", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_mesh_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_mesh_colors(self):\n\n        ax = mat.heatmap(self.df_norm, annot=True)\n        mesh = ax.collections[0]\n        assert len(mesh.get_facecolors()) == self.df_norm.values.size\n\n        plt.close(\"all\")\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_mesh_colors", "self", "ax", "mat", "heatmap", "self", "df_norm", "annot", "true", "mesh", "ax", "collections", "0", "assert", "len", "mesh", "get_facecolors", "self", "df_norm", "values", "size", "plt", "close", "all"], "doc_len": 29}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_other_data", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_other_data", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_other_data(self):\n        annot_data = self.df_norm + 10\n\n        ax = mat.heatmap(self.df_norm, annot=annot_data, fmt=\".1f\",\n                         annot_kws={\"fontsize\": 14})\n\n        for val, text in zip(annot_data.values.flat, ax.texts):\n            assert text.get_text() == f\"{val:.1f}\"\n            assert text.get_fontsize() == 14\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_other_data", "self", "annot_data", "self", "df_norm", "10", "ax", "mat", "heatmap", "self", "df_norm", "annot", "annot_data", "fmt", "1f", "annot_kws", "fontsize", "14", "for", "val", "text", "in", "zip", "annot_data", "values", "flat", "ax", "texts", "assert", "text", "get_text", "f", "val", "1f", "assert", "text", "get_fontsize", "14"], "doc_len": 43}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_different_shapes", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_different_shapes", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_different_shapes(self):\n\n        annot_data = self.df_norm.iloc[:-1]\n        with pytest.raises(ValueError):\n            mat.heatmap(self.df_norm, annot=annot_data)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_different_shapes", "self", "annot_data", "self", "df_norm", "iloc", "1", "with", "pytest", "raises", "valueerror", "mat", "heatmap", "self", "df_norm", "annot", "annot_data"], "doc_len": 22}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_annotation_with_limited_ticklabels", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_annotation_with_limited_ticklabels", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_annotation_with_limited_ticklabels(self):\n        ax = mat.heatmap(self.df_norm, fmt=\".2f\", annot=True,\n                         xticklabels=False, yticklabels=False)\n        for val, text in zip(self.x_norm.flat, ax.texts):\n            assert text.get_text() == f\"{val:.2f}\"\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_annotation_with_limited_ticklabels", "self", "ax", "mat", "heatmap", "self", "df_norm", "fmt", "2f", "annot", "true", "xticklabels", "false", "yticklabels", "false", "for", "val", "text", "in", "zip", "self", "x_norm", "flat", "ax", "texts", "assert", "text", "get_text", "f", "val", "2f"], "doc_len": 36}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_cbar", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_cbar", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_cbar(self):\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm)\n        assert len(f.axes) == 2\n        plt.close(f)\n\n        f = plt.figure()\n        mat.heatmap(self.df_norm, cbar=False)\n        assert len(f.axes) == 1\n        plt.close(f)\n\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2)\n        assert len(f.axes) == 2\n        plt.close(f)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_cbar", "self", "f", "plt", "figure", "mat", "heatmap", "self", "df_norm", "assert", "len", "f", "axes", "2", "plt", "close", "f", "f", "plt", "figure", "mat", "heatmap", "self", "df_norm", "cbar", "false", "assert", "len", "f", "axes", "1", "plt", "close", "f", "f", "ax1", "ax2", "plt", "subplots", "2", "mat", "heatmap", "self", "df_norm", "ax", "ax1", "cbar_ax", "ax2", "assert", "len", "f", "axes", "2", "plt", "close", "f"], "doc_len": 61}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_axes", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_axes", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_axes(self):\n\n        ax = mat.heatmap(self.df_norm)\n\n        xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n        assert xtl == list(self.df_norm.columns)\n        ytl = [l.get_text() for l in ax.get_yticklabels()]\n        assert ytl == list(self.df_norm.index)\n\n        assert ax.get_xlabel() == \"\"\n        assert ax.get_ylabel() == \"letters\"\n\n        assert ax.get_xlim() == (0, 8)\n        assert ax.get_ylim() == (4, 0)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_axes", "self", "ax", "mat", "heatmap", "self", "df_norm", "xtl", "int", "l", "get_text", "for", "l", "in", "ax", "get_xticklabels", "assert", "xtl", "list", "self", "df_norm", "columns", "ytl", "l", "get_text", "for", "l", "in", "ax", "get_yticklabels", "assert", "ytl", "list", "self", "df_norm", "index", "assert", "ax", "get_xlabel", "assert", "ax", "get_ylabel", "letters", "assert", "ax", "get_xlim", "0", "8", "assert", "ax", "get_ylim", "4", "0"], "doc_len": 58}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_ticklabel_rotation", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_ticklabel_rotation", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_ticklabel_rotation(self):\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            assert t.get_rotation() == 0\n\n        for t in ax.get_yticklabels():\n            assert t.get_rotation() == 90\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n\n        for t in ax.get_xticklabels():\n            assert t.get_rotation() == 90\n\n        for t in ax.get_yticklabels():\n            assert t.get_rotation() == 0\n\n        plt.close(f)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_ticklabel_rotation", "self", "f", "ax", "plt", "subplots", "figsize", "2", "2", "mat", "heatmap", "self", "df_norm", "xticklabels", "1", "yticklabels", "1", "ax", "ax", "for", "t", "in", "ax", "get_xticklabels", "assert", "t", "get_rotation", "0", "for", "t", "in", "ax", "get_yticklabels", "assert", "t", "get_rotation", "90", "plt", "close", "f", "df", "self", "df_norm", "copy", "df", "columns", "str", "c", "10", "for", "c", "in", "df", "columns", "df", "index", "i", "10", "for", "i", "in", "df", "index", "f", "ax", "plt", "subplots", "figsize", "2", "2", "mat", "heatmap", "df", "xticklabels", "1", "yticklabels", "1", "ax", "ax", "for", "t", "in", "ax", "get_xticklabels", "assert", "t", "get_rotation", "90", "for", "t", "in", "ax", "get_yticklabels", "assert", "t", "get_rotation", "0", "plt", "close", "f"], "doc_len": 105}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_heatmap_inner_lines", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_heatmap_inner_lines", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_heatmap_inner_lines(self):\n\n        c = (0, 0, 1, 1)\n        ax = mat.heatmap(self.df_norm, linewidths=2, linecolor=c)\n        mesh = ax.collections[0]\n        assert mesh.get_linewidths()[0] == 2\n        assert tuple(mesh.get_edgecolor()[0]) == c\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_heatmap_inner_lines", "self", "c", "0", "0", "1", "1", "ax", "mat", "heatmap", "self", "df_norm", "linewidths", "2", "linecolor", "c", "mesh", "ax", "collections", "0", "assert", "mesh", "get_linewidths", "0", "2", "assert", "tuple", "mesh", "get_edgecolor", "0", "c"], "doc_len": 36}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_square_aspect", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_square_aspect", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_square_aspect(self):\n\n        ax = mat.heatmap(self.df_norm, square=True)\n        obs_aspect = ax.get_aspect()\n        # mpl>3.3 returns 1 for setting \"equal\" aspect\n        # so test for the two possible equal outcomes\n        assert obs_aspect == \"equal\" or obs_aspect == 1\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_square_aspect", "self", "ax", "mat", "heatmap", "self", "df_norm", "square", "true", "obs_aspect", "ax", "get_aspect", "mpl", "3", "3", "returns", "1", "for", "setting", "equal", "aspect", "so", "test", "for", "the", "two", "possible", "equal", "outcomes", "assert", "obs_aspect", "equal", "or", "obs_aspect", "1"], "doc_len": 40}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_mask_validation", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_mask_validation", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_mask_validation(self):\n\n        mask = mat._matrix_mask(self.df_norm, None)\n        assert mask.shape == self.df_norm.shape\n        assert mask.values.sum() == 0\n\n        with pytest.raises(ValueError):\n            bad_array_mask = self.rs.randn(3, 6) > 0\n            mat._matrix_mask(self.df_norm, bad_array_mask)\n\n        with pytest.raises(ValueError):\n            bad_df_mask = pd.DataFrame(self.rs.randn(4, 8) > 0)\n            mat._matrix_mask(self.df_norm, bad_df_mask)\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_mask_validation", "self", "mask", "mat", "_matrix_mask", "self", "df_norm", "none", "assert", "mask", "shape", "self", "df_norm", "shape", "assert", "mask", "values", "sum", "0", "with", "pytest", "raises", "valueerror", "bad_array_mask", "self", "rs", "randn", "3", "6", "0", "mat", "_matrix_mask", "self", "df_norm", "bad_array_mask", "with", "pytest", "raises", "valueerror", "bad_df_mask", "pd", "dataframe", "self", "rs", "randn", "4", "8", "0", "mat", "_matrix_mask", "self", "df_norm", "bad_df_mask"], "doc_len": 58}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_missing_data_mask", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_missing_data_mask", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_missing_data_mask(self):\n\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = mat._matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = mat._matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_missing_data_mask", "self", "data", "pd", "dataframe", "np", "arange", "4", "dtype", "float", "reshape", "2", "2", "data", "loc", "0", "0", "np", "nan", "mask", "mat", "_matrix_mask", "data", "none", "npt", "assert_array_equal", "mask", "true", "false", "false", "false", "mask_in", "np", "array", "false", "true", "false", "false", "mask_out", "mat", "_matrix_mask", "data", "mask_in", "npt", "assert_array_equal", "mask_out", "true", "true", "false", "false"], "doc_len": 55}
{"doc_id": "tests/test_matrix.py::TestHeatmap.test_cbar_ticks", "file_path": "tests/test_matrix.py", "class_name": "TestHeatmap", "func_name": "test_cbar_ticks", "text": "文件路径: tests/test_matrix.py, 类名: TestHeatmap\n    def test_cbar_ticks(self):\n\n        f, (ax1, ax2) = plt.subplots(2)\n        mat.heatmap(self.df_norm, ax=ax1, cbar_ax=ax2,\n                    cbar_kws=dict(drawedges=True))\n        assert len(ax2.collections) == 2\n", "tokens": ["tests", "test_matrix", "py", "testheatmap", "def", "test_cbar_ticks", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "mat", "heatmap", "self", "df_norm", "ax", "ax1", "cbar_ax", "ax2", "cbar_kws", "dict", "drawedges", "true", "assert", "len", "ax2", "collections", "2"], "doc_len": 30}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_ndarray_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_ndarray_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_ndarray_input(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, self.x_norm)\n        pdt.assert_frame_equal(p.data.T, pd.DataFrame(self.x_norm))\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        assert p.dendrogram == self.x_norm_dendrogram\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n\n        npt.assert_array_equal(p.xticklabels, self.x_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        assert p.xlabel is None\n        assert p.ylabel == ''\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_ndarray_input", "self", "p", "mat", "_dendrogramplotter", "self", "x_norm", "self", "default_kws", "npt", "assert_array_equal", "p", "array", "t", "self", "x_norm", "pdt", "assert_frame_equal", "p", "data", "t", "pd", "dataframe", "self", "x_norm", "npt", "assert_array_equal", "p", "linkage", "self", "x_norm_linkage", "assert", "p", "dendrogram", "self", "x_norm_dendrogram", "npt", "assert_array_equal", "p", "reordered_ind", "self", "x_norm_leaves", "npt", "assert_array_equal", "p", "xticklabels", "self", "x_norm_leaves", "npt", "assert_array_equal", "p", "yticklabels", "assert", "p", "xlabel", "is", "none", "assert", "p", "ylabel"], "doc_len": 65}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_df_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_df_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_df_input(self):\n        p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        assert p.dendrogram == self.x_norm_dendrogram\n\n        npt.assert_array_equal(p.xticklabels,\n                               np.asarray(self.df_norm.columns)[\n                                   self.x_norm_leaves])\n        npt.assert_array_equal(p.yticklabels, [])\n\n        assert p.xlabel == 'letters'\n        assert p.ylabel == ''\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_df_input", "self", "p", "mat", "_dendrogramplotter", "self", "df_norm", "self", "default_kws", "npt", "assert_array_equal", "p", "array", "t", "np", "asarray", "self", "df_norm", "pdt", "assert_frame_equal", "p", "data", "t", "self", "df_norm", "npt", "assert_array_equal", "p", "linkage", "self", "x_norm_linkage", "assert", "p", "dendrogram", "self", "x_norm_dendrogram", "npt", "assert_array_equal", "p", "xticklabels", "np", "asarray", "self", "df_norm", "columns", "self", "x_norm_leaves", "npt", "assert_array_equal", "p", "yticklabels", "assert", "p", "xlabel", "letters", "assert", "p", "ylabel"], "doc_len": 63}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_df_multindex_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_df_multindex_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_df_multindex_input(self):\n\n        df = self.df_norm.copy()\n        index = pd.MultiIndex.from_tuples([(\"A\", 1), (\"B\", 2),\n                                           (\"C\", 3), (\"D\", 4)],\n                                          names=[\"letter\", \"number\"])\n        index.name = \"letter-number\"\n        df.index = index\n        kws = self.default_kws.copy()\n        kws['label'] = True\n\n        p = mat._DendrogramPlotter(df.T, **kws)\n\n        xticklabels = [\"A-1\", \"B-2\", \"C-3\", \"D-4\"]\n        xticklabels = [xticklabels[i] for i in p.reordered_ind]\n        npt.assert_array_equal(p.xticklabels, xticklabels)\n        npt.assert_array_equal(p.yticklabels, [])\n        assert p.xlabel == \"letter-number\"\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_df_multindex_input", "self", "df", "self", "df_norm", "copy", "index", "pd", "multiindex", "from_tuples", "a", "1", "b", "2", "c", "3", "d", "4", "names", "letter", "number", "index", "name", "letter", "number", "df", "index", "index", "kws", "self", "default_kws", "copy", "kws", "label", "true", "p", "mat", "_dendrogramplotter", "df", "t", "kws", "xticklabels", "a", "1", "b", "2", "c", "3", "d", "4", "xticklabels", "xticklabels", "i", "for", "i", "in", "p", "reordered_ind", "npt", "assert_array_equal", "p", "xticklabels", "xticklabels", "npt", "assert_array_equal", "p", "yticklabels", "assert", "p", "xlabel", "letter", "number"], "doc_len": 77}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_axis0_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_axis0_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n        pdt.assert_frame_equal(p.data, self.df_norm.T)\n\n        npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n        assert p.dendrogram == self.x_norm_dendrogram\n\n        npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n        npt.assert_array_equal(p.yticklabels, [])\n\n        assert p.xlabel == 'letters'\n        assert p.ylabel == ''\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_axis0_input", "self", "kws", "self", "default_kws", "copy", "kws", "axis", "0", "p", "mat", "_dendrogramplotter", "self", "df_norm", "t", "kws", "npt", "assert_array_equal", "p", "array", "np", "asarray", "self", "df_norm", "t", "pdt", "assert_frame_equal", "p", "data", "self", "df_norm", "t", "npt", "assert_array_equal", "p", "linkage", "self", "x_norm_linkage", "assert", "p", "dendrogram", "self", "x_norm_dendrogram", "npt", "assert_array_equal", "p", "xticklabels", "self", "df_norm_leaves", "npt", "assert_array_equal", "p", "yticklabels", "assert", "p", "xlabel", "letters", "assert", "p", "ylabel"], "doc_len": 65}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_rotate_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_rotate_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_rotate_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n        pdt.assert_frame_equal(p.data.T, self.df_norm)\n\n        npt.assert_array_equal(p.xticklabels, [])\n        npt.assert_array_equal(p.yticklabels, self.df_norm_leaves)\n\n        assert p.xlabel == ''\n        assert p.ylabel == 'letters'\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_rotate_input", "self", "kws", "self", "default_kws", "copy", "kws", "rotate", "true", "p", "mat", "_dendrogramplotter", "self", "df_norm", "kws", "npt", "assert_array_equal", "p", "array", "t", "np", "asarray", "self", "df_norm", "pdt", "assert_frame_equal", "p", "data", "t", "self", "df_norm", "npt", "assert_array_equal", "p", "xticklabels", "npt", "assert_array_equal", "p", "yticklabels", "self", "df_norm_leaves", "assert", "p", "xlabel", "assert", "p", "ylabel", "letters"], "doc_len": 53}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_rotate_axis0_input", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_rotate_axis0_input", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_rotate_axis0_input(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n        kws['axis'] = 0\n        p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n\n        npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_rotate_axis0_input", "self", "kws", "self", "default_kws", "copy", "kws", "rotate", "true", "kws", "axis", "0", "p", "mat", "_dendrogramplotter", "self", "df_norm", "t", "kws", "npt", "assert_array_equal", "p", "reordered_ind", "self", "x_norm_leaves"], "doc_len": 30}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_custom_linkage", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_custom_linkage", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_custom_linkage(self):\n        kws = self.default_kws.copy()\n\n        try:\n            import fastcluster\n\n            linkage = fastcluster.linkage_vector(self.x_norm, method='single',\n                                                 metric='euclidean')\n        except ImportError:\n            d = distance.pdist(self.x_norm, metric='euclidean')\n            linkage = hierarchy.linkage(d, method='single')\n        dendrogram = hierarchy.dendrogram(linkage, no_plot=True,\n                                          color_threshold=-np.inf)\n        kws['linkage'] = linkage\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n\n        npt.assert_array_equal(p.linkage, linkage)\n        assert p.dendrogram == dendrogram\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_custom_linkage", "self", "kws", "self", "default_kws", "copy", "try", "import", "fastcluster", "linkage", "fastcluster", "linkage_vector", "self", "x_norm", "method", "single", "metric", "euclidean", "except", "importerror", "d", "distance", "pdist", "self", "x_norm", "metric", "euclidean", "linkage", "hierarchy", "linkage", "d", "method", "single", "dendrogram", "hierarchy", "dendrogram", "linkage", "no_plot", "true", "color_threshold", "np", "inf", "kws", "linkage", "linkage", "p", "mat", "_dendrogramplotter", "self", "df_norm", "kws", "npt", "assert_array_equal", "p", "linkage", "linkage", "assert", "p", "dendrogram", "dendrogram"], "doc_len": 65}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_label_false", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_label_false", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_label_false(self):\n        kws = self.default_kws.copy()\n        kws['label'] = False\n        p = mat._DendrogramPlotter(self.df_norm, **kws)\n        assert p.xticks == []\n        assert p.yticks == []\n        assert p.xticklabels == []\n        assert p.yticklabels == []\n        assert p.xlabel == \"\"\n        assert p.ylabel == \"\"\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_label_false", "self", "kws", "self", "default_kws", "copy", "kws", "label", "false", "p", "mat", "_dendrogramplotter", "self", "df_norm", "kws", "assert", "p", "xticks", "assert", "p", "yticks", "assert", "p", "xticklabels", "assert", "p", "yticklabels", "assert", "p", "xlabel", "assert", "p", "ylabel"], "doc_len": 38}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_linkage_scipy", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_linkage_scipy", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_linkage_scipy(self):\n        p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n\n        scipy_linkage = p._calculate_linkage_scipy()\n\n        from scipy.spatial import distance\n        from scipy.cluster import hierarchy\n\n        dists = distance.pdist(self.x_norm.T,\n                               metric=self.default_kws['metric'])\n        linkage = hierarchy.linkage(dists, method=self.default_kws['method'])\n\n        npt.assert_array_equal(scipy_linkage, linkage)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_linkage_scipy", "self", "p", "mat", "_dendrogramplotter", "self", "x_norm", "self", "default_kws", "scipy_linkage", "p", "_calculate_linkage_scipy", "from", "scipy", "spatial", "import", "distance", "from", "scipy", "cluster", "import", "hierarchy", "dists", "distance", "pdist", "self", "x_norm", "t", "metric", "self", "default_kws", "metric", "linkage", "hierarchy", "linkage", "dists", "method", "self", "default_kws", "method", "npt", "assert_array_equal", "scipy_linkage", "linkage"], "doc_len": 49}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_fastcluster_other_method", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_fastcluster_other_method", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_fastcluster_other_method(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method='average',\n                                      metric='euclidean')\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_fastcluster_other_method", "self", "import", "fastcluster", "kws", "self", "default_kws", "copy", "kws", "method", "average", "linkage", "fastcluster", "linkage", "self", "x_norm", "t", "method", "average", "metric", "euclidean", "p", "mat", "_dendrogramplotter", "self", "x_norm", "kws", "npt", "assert_array_equal", "p", "linkage", "linkage"], "doc_len": 37}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_fastcluster_non_euclidean", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_fastcluster_non_euclidean", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_fastcluster_non_euclidean(self):\n        import fastcluster\n\n        kws = self.default_kws.copy()\n        kws['metric'] = 'cosine'\n        kws['method'] = 'average'\n        linkage = fastcluster.linkage(self.x_norm.T, method=kws['method'],\n                                      metric=kws['metric'])\n        p = mat._DendrogramPlotter(self.x_norm, **kws)\n        npt.assert_array_equal(p.linkage, linkage)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_fastcluster_non_euclidean", "self", "import", "fastcluster", "kws", "self", "default_kws", "copy", "kws", "metric", "cosine", "kws", "method", "average", "linkage", "fastcluster", "linkage", "self", "x_norm", "t", "method", "kws", "method", "metric", "kws", "metric", "p", "mat", "_dendrogramplotter", "self", "x_norm", "kws", "npt", "assert_array_equal", "p", "linkage", "linkage"], "doc_len": 42}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_dendrogram_plot", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_dendrogram_plot", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_dendrogram_plot(self):\n        d = mat.dendrogram(self.x_norm, **self.default_kws)\n\n        ax = plt.gca()\n        xlim = ax.get_xlim()\n        # 10 comes from _plot_dendrogram in scipy.cluster.hierarchy\n        xmax = len(d.reordered_ind) * 10\n\n        assert xlim[0] == 0\n        assert xlim[1] == xmax\n\n        assert len(ax.collections[0].get_paths()) == len(d.dependent_coord)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_dendrogram_plot", "self", "d", "mat", "dendrogram", "self", "x_norm", "self", "default_kws", "ax", "plt", "gca", "xlim", "ax", "get_xlim", "10", "comes", "from", "_plot_dendrogram", "in", "scipy", "cluster", "hierarchy", "xmax", "len", "d", "reordered_ind", "10", "assert", "xlim", "0", "0", "assert", "xlim", "1", "xmax", "assert", "len", "ax", "collections", "0", "get_paths", "len", "d", "dependent_coord"], "doc_len": 50}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_dendrogram_rotate", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_dendrogram_rotate", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_dendrogram_rotate(self):\n        kws = self.default_kws.copy()\n        kws['rotate'] = True\n\n        d = mat.dendrogram(self.x_norm, **kws)\n\n        ax = plt.gca()\n        ylim = ax.get_ylim()\n\n        # 10 comes from _plot_dendrogram in scipy.cluster.hierarchy\n        ymax = len(d.reordered_ind) * 10\n\n        # Since y axis is inverted, ylim is (80, 0)\n        # and therefore not (0, 80) as usual:\n        assert ylim[1] == 0\n        assert ylim[0] == ymax\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_dendrogram_rotate", "self", "kws", "self", "default_kws", "copy", "kws", "rotate", "true", "d", "mat", "dendrogram", "self", "x_norm", "kws", "ax", "plt", "gca", "ylim", "ax", "get_ylim", "10", "comes", "from", "_plot_dendrogram", "in", "scipy", "cluster", "hierarchy", "ymax", "len", "d", "reordered_ind", "10", "since", "y", "axis", "is", "inverted", "ylim", "is", "80", "0", "and", "therefore", "not", "0", "80", "as", "usual", "assert", "ylim", "1", "0", "assert", "ylim", "0", "ymax"], "doc_len": 63}
{"doc_id": "tests/test_matrix.py::TestDendrogram.test_dendrogram_ticklabel_rotation", "file_path": "tests/test_matrix.py", "class_name": "TestDendrogram", "func_name": "test_dendrogram_ticklabel_rotation", "text": "文件路径: tests/test_matrix.py, 类名: TestDendrogram\n    def test_dendrogram_ticklabel_rotation(self):\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(self.df_norm, ax=ax)\n\n        for t in ax.get_xticklabels():\n            assert t.get_rotation() == 0\n\n        plt.close(f)\n\n        df = self.df_norm.copy()\n        df.columns = [str(c) * 10 for c in df.columns]\n        df.index = [i * 10 for i in df.index]\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df, ax=ax)\n\n        for t in ax.get_xticklabels():\n            assert t.get_rotation() == 90\n\n        plt.close(f)\n\n        f, ax = plt.subplots(figsize=(2, 2))\n        mat.dendrogram(df.T, axis=0, rotate=True)\n        for t in ax.get_yticklabels():\n            assert t.get_rotation() == 0\n        plt.close(f)\n", "tokens": ["tests", "test_matrix", "py", "testdendrogram", "def", "test_dendrogram_ticklabel_rotation", "self", "f", "ax", "plt", "subplots", "figsize", "2", "2", "mat", "dendrogram", "self", "df_norm", "ax", "ax", "for", "t", "in", "ax", "get_xticklabels", "assert", "t", "get_rotation", "0", "plt", "close", "f", "df", "self", "df_norm", "copy", "df", "columns", "str", "c", "10", "for", "c", "in", "df", "columns", "df", "index", "i", "10", "for", "i", "in", "df", "index", "f", "ax", "plt", "subplots", "figsize", "2", "2", "mat", "dendrogram", "df", "ax", "ax", "for", "t", "in", "ax", "get_xticklabels", "assert", "t", "get_rotation", "90", "plt", "close", "f", "f", "ax", "plt", "subplots", "figsize", "2", "2", "mat", "dendrogram", "df", "t", "axis", "0", "rotate", "true", "for", "t", "in", "ax", "get_yticklabels", "assert", "t", "get_rotation", "0", "plt", "close", "f"], "doc_len": 106}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_ndarray_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_ndarray_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_ndarray_input(self):\n        cg = mat.ClusterGrid(self.x_norm, **self.default_kws)\n        pdt.assert_frame_equal(cg.data, pd.DataFrame(self.x_norm))\n        assert len(cg.fig.axes) == 4\n        assert cg.ax_row_colors is None\n        assert cg.ax_col_colors is None\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_ndarray_input", "self", "cg", "mat", "clustergrid", "self", "x_norm", "self", "default_kws", "pdt", "assert_frame_equal", "cg", "data", "pd", "dataframe", "self", "x_norm", "assert", "len", "cg", "fig", "axes", "4", "assert", "cg", "ax_row_colors", "is", "none", "assert", "cg", "ax_col_colors", "is", "none"], "doc_len": 38}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_df_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_df_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_df_input(self):\n        cg = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        pdt.assert_frame_equal(cg.data, self.df_norm)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_df_input", "self", "cg", "mat", "clustergrid", "self", "df_norm", "self", "default_kws", "pdt", "assert_frame_equal", "cg", "data", "self", "df_norm"], "doc_len": 20}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_corr_df_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_corr_df_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_corr_df_input(self):\n        df = self.df_norm.corr()\n        cg = mat.ClusterGrid(df, **self.default_kws)\n        cg.plot(**self.default_plot_kws)\n        diag = cg.data2d.values[np.diag_indices_from(cg.data2d)]\n        npt.assert_array_almost_equal(diag, np.ones(cg.data2d.shape[0]))\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_corr_df_input", "self", "df", "self", "df_norm", "corr", "cg", "mat", "clustergrid", "df", "self", "default_kws", "cg", "plot", "self", "default_plot_kws", "diag", "cg", "data2d", "values", "np", "diag_indices_from", "cg", "data2d", "npt", "assert_array_almost_equal", "diag", "np", "ones", "cg", "data2d", "shape", "0"], "doc_len": 38}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_pivot_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_pivot_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_pivot_input(self):\n        df_norm = self.df_norm.copy()\n        df_norm.index.name = 'numbers'\n        df_long = pd.melt(df_norm.reset_index(), var_name='letters',\n                          id_vars='numbers')\n        kws = self.default_kws.copy()\n        kws['pivot_kws'] = dict(index='numbers', columns='letters',\n                                values='value')\n        cg = mat.ClusterGrid(df_long, **kws)\n\n        pdt.assert_frame_equal(cg.data2d, df_norm)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_pivot_input", "self", "df_norm", "self", "df_norm", "copy", "df_norm", "index", "name", "numbers", "df_long", "pd", "melt", "df_norm", "reset_index", "var_name", "letters", "id_vars", "numbers", "kws", "self", "default_kws", "copy", "kws", "pivot_kws", "dict", "index", "numbers", "columns", "letters", "values", "value", "cg", "mat", "clustergrid", "df_long", "kws", "pdt", "assert_frame_equal", "cg", "data2d", "df_norm"], "doc_len": 47}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_colors_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_colors_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_colors_input(self):\n        kws = self.default_kws.copy()\n\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cg.row_colors, self.row_colors)\n        npt.assert_array_equal(cg.col_colors, self.col_colors)\n\n        assert len(cg.fig.axes) == 6\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_colors_input", "self", "kws", "self", "default_kws", "copy", "kws", "row_colors", "self", "row_colors", "kws", "col_colors", "self", "col_colors", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "npt", "assert_array_equal", "cg", "row_colors", "self", "row_colors", "npt", "assert_array_equal", "cg", "col_colors", "self", "col_colors", "assert", "len", "cg", "fig", "axes", "6"], "doc_len": 43}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_categorical_colors_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_categorical_colors_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_categorical_colors_input(self):\n        kws = self.default_kws.copy()\n\n        row_colors = pd.Series(self.row_colors, dtype=\"category\")\n        col_colors = pd.Series(\n            self.col_colors, dtype=\"category\", index=self.df_norm.columns\n        )\n\n        kws['row_colors'] = row_colors\n        kws['col_colors'] = col_colors\n\n        exp_row_colors = list(map(mpl.colors.to_rgb, row_colors))\n        exp_col_colors = list(map(mpl.colors.to_rgb, col_colors))\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cg.row_colors, exp_row_colors)\n        npt.assert_array_equal(cg.col_colors, exp_col_colors)\n\n        assert len(cg.fig.axes) == 6\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_categorical_colors_input", "self", "kws", "self", "default_kws", "copy", "row_colors", "pd", "series", "self", "row_colors", "dtype", "category", "col_colors", "pd", "series", "self", "col_colors", "dtype", "category", "index", "self", "df_norm", "columns", "kws", "row_colors", "row_colors", "kws", "col_colors", "col_colors", "exp_row_colors", "list", "map", "mpl", "colors", "to_rgb", "row_colors", "exp_col_colors", "list", "map", "mpl", "colors", "to_rgb", "col_colors", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "npt", "assert_array_equal", "cg", "row_colors", "exp_row_colors", "npt", "assert_array_equal", "cg", "col_colors", "exp_col_colors", "assert", "len", "cg", "fig", "axes", "6"], "doc_len": 71}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_nested_colors_input", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_nested_colors_input", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_nested_colors_input(self):\n        kws = self.default_kws.copy()\n\n        row_colors = [self.row_colors, self.row_colors]\n        col_colors = [self.col_colors, self.col_colors]\n        kws['row_colors'] = row_colors\n        kws['col_colors'] = col_colors\n\n        cm = mat.ClusterGrid(self.df_norm, **kws)\n        npt.assert_array_equal(cm.row_colors, row_colors)\n        npt.assert_array_equal(cm.col_colors, col_colors)\n\n        assert len(cm.fig.axes) == 6\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_nested_colors_input", "self", "kws", "self", "default_kws", "copy", "row_colors", "self", "row_colors", "self", "row_colors", "col_colors", "self", "col_colors", "self", "col_colors", "kws", "row_colors", "row_colors", "kws", "col_colors", "col_colors", "cm", "mat", "clustergrid", "self", "df_norm", "kws", "npt", "assert_array_equal", "cm", "row_colors", "row_colors", "npt", "assert_array_equal", "cm", "col_colors", "col_colors", "assert", "len", "cm", "fig", "axes", "6"], "doc_len": 49}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_colors_input_custom_cmap", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_colors_input_custom_cmap", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_colors_input_custom_cmap(self):\n        kws = self.default_kws.copy()\n\n        kws['cmap'] = mpl.cm.PRGn\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cg = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(cg.row_colors, self.row_colors)\n        npt.assert_array_equal(cg.col_colors, self.col_colors)\n\n        assert len(cg.fig.axes) == 6\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_colors_input_custom_cmap", "self", "kws", "self", "default_kws", "copy", "kws", "cmap", "mpl", "cm", "prgn", "kws", "row_colors", "self", "row_colors", "kws", "col_colors", "self", "col_colors", "cg", "mat", "clustermap", "self", "df_norm", "kws", "npt", "assert_array_equal", "cg", "row_colors", "self", "row_colors", "npt", "assert_array_equal", "cg", "col_colors", "self", "col_colors", "assert", "len", "cg", "fig", "axes", "6"], "doc_len": 48}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_z_score", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_z_score", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_z_score(self):\n        df = self.df_norm.copy()\n        df = (df - df.mean()) / df.std()\n        kws = self.default_kws.copy()\n        kws['z_score'] = 1\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cg.data2d, df)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_z_score", "self", "df", "self", "df_norm", "copy", "df", "df", "df", "mean", "df", "std", "kws", "self", "default_kws", "copy", "kws", "z_score", "1", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "pdt", "assert_frame_equal", "cg", "data2d", "df"], "doc_len": 35}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_z_score_axis0", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_z_score_axis0", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_z_score_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.mean()) / df.std()\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['z_score'] = 0\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cg.data2d, df)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_z_score_axis0", "self", "df", "self", "df_norm", "copy", "df", "df", "t", "df", "df", "df", "mean", "df", "std", "df", "df", "t", "kws", "self", "default_kws", "copy", "kws", "z_score", "0", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "pdt", "assert_frame_equal", "cg", "data2d", "df"], "doc_len": 41}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_standard_scale", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_standard_scale", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_standard_scale(self):\n        df = self.df_norm.copy()\n        df = (df - df.min()) / (df.max() - df.min())\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 1\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cg.data2d, df)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_standard_scale", "self", "df", "self", "df_norm", "copy", "df", "df", "df", "min", "df", "max", "df", "min", "kws", "self", "default_kws", "copy", "kws", "standard_scale", "1", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "pdt", "assert_frame_equal", "cg", "data2d", "df"], "doc_len": 37}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_standard_scale_axis0", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_standard_scale_axis0", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_standard_scale_axis0(self):\n        df = self.df_norm.copy()\n        df = df.T\n        df = (df - df.min()) / (df.max() - df.min())\n        df = df.T\n        kws = self.default_kws.copy()\n        kws['standard_scale'] = 0\n\n        cg = mat.ClusterGrid(self.df_norm, **kws)\n        pdt.assert_frame_equal(cg.data2d, df)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_standard_scale_axis0", "self", "df", "self", "df_norm", "copy", "df", "df", "t", "df", "df", "df", "min", "df", "max", "df", "min", "df", "df", "t", "kws", "self", "default_kws", "copy", "kws", "standard_scale", "0", "cg", "mat", "clustergrid", "self", "df_norm", "kws", "pdt", "assert_frame_equal", "cg", "data2d", "df"], "doc_len": 43}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_z_score_standard_scale", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_z_score_standard_scale", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_z_score_standard_scale(self):\n        kws = self.default_kws.copy()\n        kws['z_score'] = True\n        kws['standard_scale'] = True\n        with pytest.raises(ValueError):\n            mat.ClusterGrid(self.df_norm, **kws)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_z_score_standard_scale", "self", "kws", "self", "default_kws", "copy", "kws", "z_score", "true", "kws", "standard_scale", "true", "with", "pytest", "raises", "valueerror", "mat", "clustergrid", "self", "df_norm", "kws"], "doc_len": 26}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_color_list_to_matrix_and_cmap", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_color_list_to_matrix_and_cmap", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_color_list_to_matrix_and_cmap(self):\n        # Note this uses the attribute named col_colors but tests row colors\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves, axis=0)\n\n        for i, leaf in enumerate(self.x_norm_leaves):\n            color = self.col_colors[leaf]\n            assert_colors_equal(cmap(matrix[i, 0]), color)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_color_list_to_matrix_and_cmap", "self", "note", "this", "uses", "the", "attribute", "named", "col_colors", "but", "tests", "row", "colors", "matrix", "cmap", "mat", "clustergrid", "color_list_to_matrix_and_cmap", "self", "col_colors", "self", "x_norm_leaves", "axis", "0", "for", "i", "leaf", "in", "enumerate", "self", "x_norm_leaves", "color", "self", "col_colors", "leaf", "assert_colors_equal", "cmap", "matrix", "i", "0", "color"], "doc_len": 46}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_nested_color_list_to_matrix_and_cmap", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_nested_color_list_to_matrix_and_cmap", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_nested_color_list_to_matrix_and_cmap(self):\n        # Note this uses the attribute named col_colors but tests row colors\n        colors = [self.col_colors, self.col_colors[::-1]]\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            colors, self.x_norm_leaves, axis=0)\n\n        for i, leaf in enumerate(self.x_norm_leaves):\n            for j, color_row in enumerate(colors):\n                color = color_row[leaf]\n                assert_colors_equal(cmap(matrix[i, j]), color)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_nested_color_list_to_matrix_and_cmap", "self", "note", "this", "uses", "the", "attribute", "named", "col_colors", "but", "tests", "row", "colors", "colors", "self", "col_colors", "self", "col_colors", "1", "matrix", "cmap", "mat", "clustergrid", "color_list_to_matrix_and_cmap", "colors", "self", "x_norm_leaves", "axis", "0", "for", "i", "leaf", "in", "enumerate", "self", "x_norm_leaves", "for", "j", "color_row", "in", "enumerate", "colors", "color", "color_row", "leaf", "assert_colors_equal", "cmap", "matrix", "i", "j", "color"], "doc_len": 56}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_color_list_to_matrix_and_cmap_axis1", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_color_list_to_matrix_and_cmap_axis1", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_color_list_to_matrix_and_cmap_axis1(self):\n        matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n            self.col_colors, self.x_norm_leaves, axis=1)\n\n        for j, leaf in enumerate(self.x_norm_leaves):\n            color = self.col_colors[leaf]\n            assert_colors_equal(cmap(matrix[0, j]), color)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_color_list_to_matrix_and_cmap_axis1", "self", "matrix", "cmap", "mat", "clustergrid", "color_list_to_matrix_and_cmap", "self", "col_colors", "self", "x_norm_leaves", "axis", "1", "for", "j", "leaf", "in", "enumerate", "self", "x_norm_leaves", "color", "self", "col_colors", "leaf", "assert_colors_equal", "cmap", "matrix", "0", "j", "color"], "doc_len": 35}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_color_list_to_matrix_and_cmap_different_sizes", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_color_list_to_matrix_and_cmap_different_sizes", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_color_list_to_matrix_and_cmap_different_sizes(self):\n        colors = [self.col_colors, self.col_colors * 2]\n        with pytest.raises(ValueError):\n            matrix, cmap = mat.ClusterGrid.color_list_to_matrix_and_cmap(\n                colors, self.x_norm_leaves, axis=1)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_color_list_to_matrix_and_cmap_different_sizes", "self", "colors", "self", "col_colors", "self", "col_colors", "2", "with", "pytest", "raises", "valueerror", "matrix", "cmap", "mat", "clustergrid", "color_list_to_matrix_and_cmap", "colors", "self", "x_norm_leaves", "axis", "1"], "doc_len": 27}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_savefig", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_savefig", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_savefig(self):\n        # Not sure if this is the right way to test....\n        cg = mat.ClusterGrid(self.df_norm, **self.default_kws)\n        cg.plot(**self.default_plot_kws)\n        cg.savefig(tempfile.NamedTemporaryFile(), format='png')\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_savefig", "self", "not", "sure", "if", "this", "is", "the", "right", "way", "to", "test", "cg", "mat", "clustergrid", "self", "df_norm", "self", "default_kws", "cg", "plot", "self", "default_plot_kws", "cg", "savefig", "tempfile", "namedtemporaryfile", "format", "png"], "doc_len": 34}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_plot_dendrograms", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_plot_dendrograms", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_plot_dendrograms(self):\n        cm = mat.clustermap(self.df_norm, **self.default_kws)\n\n        assert len(cm.ax_row_dendrogram.collections[0].get_paths()) == len(\n            cm.dendrogram_row.independent_coord\n        )\n        assert len(cm.ax_col_dendrogram.collections[0].get_paths()) == len(\n            cm.dendrogram_col.independent_coord\n        )\n        data2d = self.df_norm.iloc[cm.dendrogram_row.reordered_ind,\n                                   cm.dendrogram_col.reordered_ind]\n        pdt.assert_frame_equal(cm.data2d, data2d)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_plot_dendrograms", "self", "cm", "mat", "clustermap", "self", "df_norm", "self", "default_kws", "assert", "len", "cm", "ax_row_dendrogram", "collections", "0", "get_paths", "len", "cm", "dendrogram_row", "independent_coord", "assert", "len", "cm", "ax_col_dendrogram", "collections", "0", "get_paths", "len", "cm", "dendrogram_col", "independent_coord", "data2d", "self", "df_norm", "iloc", "cm", "dendrogram_row", "reordered_ind", "cm", "dendrogram_col", "reordered_ind", "pdt", "assert_frame_equal", "cm", "data2d", "data2d"], "doc_len": 51}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_cluster_false", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_cluster_false", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_cluster_false(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        assert len(cm.ax_row_dendrogram.lines) == 0\n        assert len(cm.ax_col_dendrogram.lines) == 0\n\n        assert len(cm.ax_row_dendrogram.get_xticks()) == 0\n        assert len(cm.ax_row_dendrogram.get_yticks()) == 0\n        assert len(cm.ax_col_dendrogram.get_xticks()) == 0\n        assert len(cm.ax_col_dendrogram.get_yticks()) == 0\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_cluster_false", "self", "kws", "self", "default_kws", "copy", "kws", "row_cluster", "false", "kws", "col_cluster", "false", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "len", "cm", "ax_row_dendrogram", "lines", "0", "assert", "len", "cm", "ax_col_dendrogram", "lines", "0", "assert", "len", "cm", "ax_row_dendrogram", "get_xticks", "0", "assert", "len", "cm", "ax_row_dendrogram", "get_yticks", "0", "assert", "len", "cm", "ax_col_dendrogram", "get_xticks", "0", "assert", "len", "cm", "ax_col_dendrogram", "get_yticks", "0", "pdt", "assert_frame_equal", "cm", "data2d", "self", "df_norm"], "doc_len": 65}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        assert len(cm.ax_row_colors.collections) == 1\n        assert len(cm.ax_col_colors.collections) == 1\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors", "self", "kws", "self", "default_kws", "copy", "kws", "row_colors", "self", "row_colors", "kws", "col_colors", "self", "col_colors", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "len", "cm", "ax_row_colors", "collections", "1", "assert", "len", "cm", "ax_col_colors", "collections", "1"], "doc_len": 37}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_cluster_false_row_col_colors", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_cluster_false_row_col_colors", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_cluster_false_row_col_colors(self):\n        kws = self.default_kws.copy()\n        kws['row_cluster'] = False\n        kws['col_cluster'] = False\n        kws['row_colors'] = self.row_colors\n        kws['col_colors'] = self.col_colors\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        assert len(cm.ax_row_dendrogram.lines) == 0\n        assert len(cm.ax_col_dendrogram.lines) == 0\n\n        assert len(cm.ax_row_dendrogram.get_xticks()) == 0\n        assert len(cm.ax_row_dendrogram.get_yticks()) == 0\n        assert len(cm.ax_col_dendrogram.get_xticks()) == 0\n        assert len(cm.ax_col_dendrogram.get_yticks()) == 0\n        assert len(cm.ax_row_colors.collections) == 1\n        assert len(cm.ax_col_colors.collections) == 1\n\n        pdt.assert_frame_equal(cm.data2d, self.df_norm)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_cluster_false_row_col_colors", "self", "kws", "self", "default_kws", "copy", "kws", "row_cluster", "false", "kws", "col_cluster", "false", "kws", "row_colors", "self", "row_colors", "kws", "col_colors", "self", "col_colors", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "len", "cm", "ax_row_dendrogram", "lines", "0", "assert", "len", "cm", "ax_col_dendrogram", "lines", "0", "assert", "len", "cm", "ax_row_dendrogram", "get_xticks", "0", "assert", "len", "cm", "ax_row_dendrogram", "get_yticks", "0", "assert", "len", "cm", "ax_col_dendrogram", "get_xticks", "0", "assert", "len", "cm", "ax_col_dendrogram", "get_yticks", "0", "assert", "len", "cm", "ax_row_colors", "collections", "1", "assert", "len", "cm", "ax_col_colors", "collections", "1", "pdt", "assert_frame_equal", "cm", "data2d", "self", "df_norm"], "doc_len": 85}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_df", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_df", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_df(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                          'row_2': list(self.row_colors)},\n                                         index=self.df_norm.index,\n                                         columns=['row_1', 'row_2'])\n        kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                          'col_2': list(self.col_colors)},\n                                         index=self.df_norm.columns,\n                                         columns=['col_1', 'col_2'])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in\n                      cm.ax_row_colors.get_xticklabels()]\n        assert cm.row_color_labels == ['row_1', 'row_2']\n        assert row_labels == cm.row_color_labels\n\n        col_labels = [l.get_text() for l in\n                      cm.ax_col_colors.get_yticklabels()]\n        assert cm.col_color_labels == ['col_1', 'col_2']\n        assert col_labels == cm.col_color_labels\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_df", "self", "kws", "self", "default_kws", "copy", "kws", "row_colors", "pd", "dataframe", "row_1", "list", "self", "row_colors", "row_2", "list", "self", "row_colors", "index", "self", "df_norm", "index", "columns", "row_1", "row_2", "kws", "col_colors", "pd", "dataframe", "col_1", "list", "self", "col_colors", "col_2", "list", "self", "col_colors", "index", "self", "df_norm", "columns", "columns", "col_1", "col_2", "cm", "mat", "clustermap", "self", "df_norm", "kws", "row_labels", "l", "get_text", "for", "l", "in", "cm", "ax_row_colors", "get_xticklabels", "assert", "cm", "row_color_labels", "row_1", "row_2", "assert", "row_labels", "cm", "row_color_labels", "col_labels", "l", "get_text", "for", "l", "in", "cm", "ax_col_colors", "get_yticklabels", "assert", "cm", "col_color_labels", "col_1", "col_2", "assert", "col_labels", "cm", "col_color_labels"], "doc_len": 91}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_df_shuffled", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_df_shuffled", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_df_shuffled(self):\n        # Tests if colors are properly matched, even if given in wrong order\n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.loc[shuffled_inds]\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.loc[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        assert list(cm.col_colors)[0] == list(self.col_colors)\n        assert list(cm.row_colors)[0] == list(self.row_colors)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_df_shuffled", "self", "tests", "if", "colors", "are", "properly", "matched", "even", "if", "given", "in", "wrong", "order", "m", "n", "self", "df_norm", "shape", "shuffled_inds", "self", "df_norm", "index", "i", "for", "i", "in", "list", "range", "0", "m", "2", "list", "range", "1", "m", "2", "shuffled_cols", "self", "df_norm", "columns", "i", "for", "i", "in", "list", "range", "0", "n", "2", "list", "range", "1", "n", "2", "kws", "self", "default_kws", "copy", "row_colors", "pd", "dataframe", "row_annot", "list", "self", "row_colors", "index", "self", "df_norm", "index", "kws", "row_colors", "row_colors", "loc", "shuffled_inds", "col_colors", "pd", "dataframe", "col_annot", "list", "self", "col_colors", "index", "self", "df_norm", "columns", "kws", "col_colors", "col_colors", "loc", "shuffled_cols", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "list", "cm", "col_colors", "0", "list", "self", "col_colors", "assert", "list", "cm", "row_colors", "0", "list", "self", "row_colors"], "doc_len": 118}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_df_missing", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_df_missing", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_df_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.DataFrame({'row_annot': list(self.row_colors)},\n                                  index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.DataFrame({'col_annot': list(self.col_colors)},\n                                  index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        assert list(cm.col_colors)[0] == [(1.0, 1.0, 1.0)] + list(self.col_colors[1:])\n        assert list(cm.row_colors)[0] == [(1.0, 1.0, 1.0)] + list(self.row_colors[1:])\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_df_missing", "self", "kws", "self", "default_kws", "copy", "row_colors", "pd", "dataframe", "row_annot", "list", "self", "row_colors", "index", "self", "df_norm", "index", "kws", "row_colors", "row_colors", "drop", "self", "df_norm", "index", "0", "col_colors", "pd", "dataframe", "col_annot", "list", "self", "col_colors", "index", "self", "df_norm", "columns", "kws", "col_colors", "col_colors", "drop", "self", "df_norm", "columns", "0", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "list", "cm", "col_colors", "0", "1", "0", "1", "0", "1", "0", "list", "self", "col_colors", "1", "assert", "list", "cm", "row_colors", "0", "1", "0", "1", "0", "1", "0", "list", "self", "row_colors", "1"], "doc_len": 85}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_df_one_axis", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_df_one_axis", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_df_one_axis(self):\n        # Test case with only row annotation.\n        kws1 = self.default_kws.copy()\n        kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors),\n                                           'row_2': list(self.row_colors)},\n                                          index=self.df_norm.index,\n                                          columns=['row_1', 'row_2'])\n\n        cm1 = mat.clustermap(self.df_norm, **kws1)\n\n        row_labels = [l.get_text() for l in\n                      cm1.ax_row_colors.get_xticklabels()]\n        assert cm1.row_color_labels == ['row_1', 'row_2']\n        assert row_labels == cm1.row_color_labels\n\n        # Test case with only col annotation.\n        kws2 = self.default_kws.copy()\n        kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors),\n                                           'col_2': list(self.col_colors)},\n                                          index=self.df_norm.columns,\n                                          columns=['col_1', 'col_2'])\n\n        cm2 = mat.clustermap(self.df_norm, **kws2)\n\n        col_labels = [l.get_text() for l in\n                      cm2.ax_col_colors.get_yticklabels()]\n        assert cm2.col_color_labels == ['col_1', 'col_2']\n        assert col_labels == cm2.col_color_labels\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_df_one_axis", "self", "test", "case", "with", "only", "row", "annotation", "kws1", "self", "default_kws", "copy", "kws1", "row_colors", "pd", "dataframe", "row_1", "list", "self", "row_colors", "row_2", "list", "self", "row_colors", "index", "self", "df_norm", "index", "columns", "row_1", "row_2", "cm1", "mat", "clustermap", "self", "df_norm", "kws1", "row_labels", "l", "get_text", "for", "l", "in", "cm1", "ax_row_colors", "get_xticklabels", "assert", "cm1", "row_color_labels", "row_1", "row_2", "assert", "row_labels", "cm1", "row_color_labels", "test", "case", "with", "only", "col", "annotation", "kws2", "self", "default_kws", "copy", "kws2", "col_colors", "pd", "dataframe", "col_1", "list", "self", "col_colors", "col_2", "list", "self", "col_colors", "index", "self", "df_norm", "columns", "columns", "col_1", "col_2", "cm2", "mat", "clustermap", "self", "df_norm", "kws2", "col_labels", "l", "get_text", "for", "l", "in", "cm2", "ax_col_colors", "get_yticklabels", "assert", "cm2", "col_color_labels", "col_1", "col_2", "assert", "col_labels", "cm2", "col_color_labels"], "doc_len": 113}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_series", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_series", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_series(self):\n        kws = self.default_kws.copy()\n        kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot',\n                                      index=self.df_norm.index)\n        kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot',\n                                      index=self.df_norm.columns)\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n        assert cm.row_color_labels == ['row_annot']\n        assert row_labels == cm.row_color_labels\n\n        col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n        assert cm.col_color_labels == ['col_annot']\n        assert col_labels == cm.col_color_labels\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_series", "self", "kws", "self", "default_kws", "copy", "kws", "row_colors", "pd", "series", "list", "self", "row_colors", "name", "row_annot", "index", "self", "df_norm", "index", "kws", "col_colors", "pd", "series", "list", "self", "col_colors", "name", "col_annot", "index", "self", "df_norm", "columns", "cm", "mat", "clustermap", "self", "df_norm", "kws", "row_labels", "l", "get_text", "for", "l", "in", "cm", "ax_row_colors", "get_xticklabels", "assert", "cm", "row_color_labels", "row_annot", "assert", "row_labels", "cm", "row_color_labels", "col_labels", "l", "get_text", "for", "l", "in", "cm", "ax_col_colors", "get_yticklabels", "assert", "cm", "col_color_labels", "col_annot", "assert", "col_labels", "cm", "col_color_labels"], "doc_len": 77}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_series_shuffled", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_series_shuffled", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_series_shuffled(self):\n        # Tests if colors are properly matched, even if given in wrong order\n\n        m, n = self.df_norm.shape\n        shuffled_inds = [self.df_norm.index[i] for i in\n                         list(range(0, m, 2)) + list(range(1, m, 2))]\n        shuffled_cols = [self.df_norm.columns[i] for i in\n                         list(range(0, n, 2)) + list(range(1, n, 2))]\n\n        kws = self.default_kws.copy()\n\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.loc[shuffled_inds]\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.loc[shuffled_cols]\n\n        cm = mat.clustermap(self.df_norm, **kws)\n\n        assert list(cm.col_colors) == list(self.col_colors)\n        assert list(cm.row_colors) == list(self.row_colors)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_series_shuffled", "self", "tests", "if", "colors", "are", "properly", "matched", "even", "if", "given", "in", "wrong", "order", "m", "n", "self", "df_norm", "shape", "shuffled_inds", "self", "df_norm", "index", "i", "for", "i", "in", "list", "range", "0", "m", "2", "list", "range", "1", "m", "2", "shuffled_cols", "self", "df_norm", "columns", "i", "for", "i", "in", "list", "range", "0", "n", "2", "list", "range", "1", "n", "2", "kws", "self", "default_kws", "copy", "row_colors", "pd", "series", "list", "self", "row_colors", "name", "row_annot", "index", "self", "df_norm", "index", "kws", "row_colors", "row_colors", "loc", "shuffled_inds", "col_colors", "pd", "series", "list", "self", "col_colors", "name", "col_annot", "index", "self", "df_norm", "columns", "kws", "col_colors", "col_colors", "loc", "shuffled_cols", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "list", "cm", "col_colors", "list", "self", "col_colors", "assert", "list", "cm", "row_colors", "list", "self", "row_colors"], "doc_len": 118}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_series_missing", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_series_missing", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_series_missing(self):\n        kws = self.default_kws.copy()\n        row_colors = pd.Series(list(self.row_colors), name='row_annot',\n                               index=self.df_norm.index)\n        kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n\n        col_colors = pd.Series(list(self.col_colors), name='col_annot',\n                               index=self.df_norm.columns)\n        kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n\n        cm = mat.clustermap(self.df_norm, **kws)\n        assert list(cm.col_colors) == [(1.0, 1.0, 1.0)] + list(self.col_colors[1:])\n        assert list(cm.row_colors) == [(1.0, 1.0, 1.0)] + list(self.row_colors[1:])\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_series_missing", "self", "kws", "self", "default_kws", "copy", "row_colors", "pd", "series", "list", "self", "row_colors", "name", "row_annot", "index", "self", "df_norm", "index", "kws", "row_colors", "row_colors", "drop", "self", "df_norm", "index", "0", "col_colors", "pd", "series", "list", "self", "col_colors", "name", "col_annot", "index", "self", "df_norm", "columns", "kws", "col_colors", "col_colors", "drop", "self", "df_norm", "columns", "0", "cm", "mat", "clustermap", "self", "df_norm", "kws", "assert", "list", "cm", "col_colors", "1", "0", "1", "0", "1", "0", "list", "self", "col_colors", "1", "assert", "list", "cm", "row_colors", "1", "0", "1", "0", "1", "0", "list", "self", "row_colors", "1"], "doc_len": 85}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_ignore_heatmap_kwargs", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_ignore_heatmap_kwargs", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_ignore_heatmap_kwargs(self):\n\n        g = mat.clustermap(self.rs.uniform(0, 200, self.df_norm.shape),\n                           row_colors=self.row_colors,\n                           col_colors=self.col_colors,\n                           cmap=\"Spectral\",\n                           norm=mpl.colors.LogNorm(),\n                           vmax=100)\n\n        assert np.array_equal(\n            np.array(self.row_colors)[g.dendrogram_row.reordered_ind],\n            g.ax_row_colors.collections[0].get_facecolors()[:, :3]\n        )\n\n        assert np.array_equal(\n            np.array(self.col_colors)[g.dendrogram_col.reordered_ind],\n            g.ax_col_colors.collections[0].get_facecolors()[:, :3]\n        )\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_ignore_heatmap_kwargs", "self", "g", "mat", "clustermap", "self", "rs", "uniform", "0", "200", "self", "df_norm", "shape", "row_colors", "self", "row_colors", "col_colors", "self", "col_colors", "cmap", "spectral", "norm", "mpl", "colors", "lognorm", "vmax", "100", "assert", "np", "array_equal", "np", "array", "self", "row_colors", "g", "dendrogram_row", "reordered_ind", "g", "ax_row_colors", "collections", "0", "get_facecolors", "3", "assert", "np", "array_equal", "np", "array", "self", "col_colors", "g", "dendrogram_col", "reordered_ind", "g", "ax_col_colors", "collections", "0", "get_facecolors", "3"], "doc_len": 64}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_row_col_colors_raise_on_mixed_index_types", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_row_col_colors_raise_on_mixed_index_types", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_row_col_colors_raise_on_mixed_index_types(self):\n\n        row_colors = pd.Series(\n            list(self.row_colors), name=\"row_annot\", index=self.df_norm.index\n        )\n\n        col_colors = pd.Series(\n            list(self.col_colors), name=\"col_annot\", index=self.df_norm.columns\n        )\n\n        with pytest.raises(TypeError):\n            mat.clustermap(self.x_norm, row_colors=row_colors)\n\n        with pytest.raises(TypeError):\n            mat.clustermap(self.x_norm, col_colors=col_colors)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_row_col_colors_raise_on_mixed_index_types", "self", "row_colors", "pd", "series", "list", "self", "row_colors", "name", "row_annot", "index", "self", "df_norm", "index", "col_colors", "pd", "series", "list", "self", "col_colors", "name", "col_annot", "index", "self", "df_norm", "columns", "with", "pytest", "raises", "typeerror", "mat", "clustermap", "self", "x_norm", "row_colors", "row_colors", "with", "pytest", "raises", "typeerror", "mat", "clustermap", "self", "x_norm", "col_colors", "col_colors"], "doc_len": 51}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_mask_reorganization", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_mask_reorganization", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_mask_reorganization(self):\n\n        kws = self.default_kws.copy()\n        kws[\"mask\"] = self.df_norm > 0\n\n        g = mat.clustermap(self.df_norm, **kws)\n        npt.assert_array_equal(g.data2d.index, g.mask.index)\n        npt.assert_array_equal(g.data2d.columns, g.mask.columns)\n\n        npt.assert_array_equal(g.mask.index,\n                               self.df_norm.index[\n                                   g.dendrogram_row.reordered_ind])\n        npt.assert_array_equal(g.mask.columns,\n                               self.df_norm.columns[\n                                   g.dendrogram_col.reordered_ind])\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_mask_reorganization", "self", "kws", "self", "default_kws", "copy", "kws", "mask", "self", "df_norm", "0", "g", "mat", "clustermap", "self", "df_norm", "kws", "npt", "assert_array_equal", "g", "data2d", "index", "g", "mask", "index", "npt", "assert_array_equal", "g", "data2d", "columns", "g", "mask", "columns", "npt", "assert_array_equal", "g", "mask", "index", "self", "df_norm", "index", "g", "dendrogram_row", "reordered_ind", "npt", "assert_array_equal", "g", "mask", "columns", "self", "df_norm", "columns", "g", "dendrogram_col", "reordered_ind"], "doc_len": 60}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_ticklabel_reorganization", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_ticklabel_reorganization", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_ticklabel_reorganization(self):\n\n        kws = self.default_kws.copy()\n        xtl = np.arange(self.df_norm.shape[1])\n        kws[\"xticklabels\"] = list(xtl)\n        ytl = self.letters.loc[:self.df_norm.shape[0]]\n        kws[\"yticklabels\"] = ytl\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n\n        xtl_want = xtl[g.dendrogram_col.reordered_ind].astype(\"<U1\")\n        ytl_want = ytl[g.dendrogram_row.reordered_ind].astype(\"<U1\")\n\n        npt.assert_array_equal(xtl_actual, xtl_want)\n        npt.assert_array_equal(ytl_actual, ytl_want)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_ticklabel_reorganization", "self", "kws", "self", "default_kws", "copy", "xtl", "np", "arange", "self", "df_norm", "shape", "1", "kws", "xticklabels", "list", "xtl", "ytl", "self", "letters", "loc", "self", "df_norm", "shape", "0", "kws", "yticklabels", "ytl", "g", "mat", "clustermap", "self", "df_norm", "kws", "xtl_actual", "t", "get_text", "for", "t", "in", "g", "ax_heatmap", "get_xticklabels", "ytl_actual", "t", "get_text", "for", "t", "in", "g", "ax_heatmap", "get_yticklabels", "xtl_want", "xtl", "g", "dendrogram_col", "reordered_ind", "astype", "u1", "ytl_want", "ytl", "g", "dendrogram_row", "reordered_ind", "astype", "u1", "npt", "assert_array_equal", "xtl_actual", "xtl_want", "npt", "assert_array_equal", "ytl_actual", "ytl_want"], "doc_len": 79}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_noticklabels", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_noticklabels", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_noticklabels(self):\n\n        kws = self.default_kws.copy()\n        kws[\"xticklabels\"] = False\n        kws[\"yticklabels\"] = False\n\n        g = mat.clustermap(self.df_norm, **kws)\n\n        xtl_actual = [t.get_text() for t in g.ax_heatmap.get_xticklabels()]\n        ytl_actual = [t.get_text() for t in g.ax_heatmap.get_yticklabels()]\n        assert xtl_actual == []\n        assert ytl_actual == []\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_noticklabels", "self", "kws", "self", "default_kws", "copy", "kws", "xticklabels", "false", "kws", "yticklabels", "false", "g", "mat", "clustermap", "self", "df_norm", "kws", "xtl_actual", "t", "get_text", "for", "t", "in", "g", "ax_heatmap", "get_xticklabels", "ytl_actual", "t", "get_text", "for", "t", "in", "g", "ax_heatmap", "get_yticklabels", "assert", "xtl_actual", "assert", "ytl_actual"], "doc_len": 45}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_size_ratios", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_size_ratios", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_size_ratios(self):\n\n        # The way that wspace/hspace work in GridSpec, the mapping from input\n        # ratio to actual width/height of each axes is complicated, so this\n        # test is just going to assert comparative relationships\n\n        kws1 = self.default_kws.copy()\n        kws1.update(dendrogram_ratio=.2, colors_ratio=.03,\n                    col_colors=self.col_colors, row_colors=self.row_colors)\n\n        kws2 = kws1.copy()\n        kws2.update(dendrogram_ratio=.3, colors_ratio=.05)\n\n        g1 = mat.clustermap(self.df_norm, **kws1)\n        g2 = mat.clustermap(self.df_norm, **kws2)\n\n        assert (g2.ax_col_dendrogram.get_position().height\n                > g1.ax_col_dendrogram.get_position().height)\n\n        assert (g2.ax_col_colors.get_position().height\n                > g1.ax_col_colors.get_position().height)\n\n        assert (g2.ax_heatmap.get_position().height\n                < g1.ax_heatmap.get_position().height)\n\n        assert (g2.ax_row_dendrogram.get_position().width\n                > g1.ax_row_dendrogram.get_position().width)\n\n        assert (g2.ax_row_colors.get_position().width\n                > g1.ax_row_colors.get_position().width)\n\n        assert (g2.ax_heatmap.get_position().width\n                < g1.ax_heatmap.get_position().width)\n\n        kws1 = self.default_kws.copy()\n        kws1.update(col_colors=self.col_colors)\n        kws2 = kws1.copy()\n        kws2.update(col_colors=[self.col_colors, self.col_colors])\n\n        g1 = mat.clustermap(self.df_norm, **kws1)\n        g2 = mat.clustermap(self.df_norm, **kws2)\n\n        assert (g2.ax_col_colors.get_position().height\n                > g1.ax_col_colors.get_position().height)\n\n        kws1 = self.default_kws.copy()\n        kws1.update(dendrogram_ratio=(.2, .2))\n\n        kws2 = kws1.copy()\n        kws2.update(dendrogram_ratio=(.2, .3))\n\n        g1 = mat.clustermap(self.df_norm, **kws1)\n        g2 = mat.clustermap(self.df_norm, **kws2)\n\n        # Fails on pinned matplotlib?\n        # assert (g2.ax_row_dendrogram.get_position().width\n        #         == g1.ax_row_dendrogram.get_position().width)\n        assert g1.gs.get_width_ratios() == g2.gs.get_width_ratios()\n\n        assert (g2.ax_col_dendrogram.get_position().height\n                > g1.ax_col_dendrogram.get_position().height)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_size_ratios", "self", "the", "way", "that", "wspace", "hspace", "work", "in", "gridspec", "the", "mapping", "from", "input", "ratio", "to", "actual", "width", "height", "of", "each", "axes", "is", "complicated", "so", "this", "test", "is", "just", "going", "to", "assert", "comparative", "relationships", "kws1", "self", "default_kws", "copy", "kws1", "update", "dendrogram_ratio", "2", "colors_ratio", "03", "col_colors", "self", "col_colors", "row_colors", "self", "row_colors", "kws2", "kws1", "copy", "kws2", "update", "dendrogram_ratio", "3", "colors_ratio", "05", "g1", "mat", "clustermap", "self", "df_norm", "kws1", "g2", "mat", "clustermap", "self", "df_norm", "kws2", "assert", "g2", "ax_col_dendrogram", "get_position", "height", "g1", "ax_col_dendrogram", "get_position", "height", "assert", "g2", "ax_col_colors", "get_position", "height", "g1", "ax_col_colors", "get_position", "height", "assert", "g2", "ax_heatmap", "get_position", "height", "g1", "ax_heatmap", "get_position", "height", "assert", "g2", "ax_row_dendrogram", "get_position", "width", "g1", "ax_row_dendrogram", "get_position", "width", "assert", "g2", "ax_row_colors", "get_position", "width", "g1", "ax_row_colors", "get_position", "width", "assert", "g2", "ax_heatmap", "get_position", "width", "g1", "ax_heatmap", "get_position", "width", "kws1", "self", "default_kws", "copy", "kws1", "update", "col_colors", "self", "col_colors", "kws2", "kws1", "copy", "kws2", "update", "col_colors", "self", "col_colors", "self", "col_colors", "g1", "mat", "clustermap", "self", "df_norm", "kws1", "g2", "mat", "clustermap", "self", "df_norm", "kws2", "assert", "g2", "ax_col_colors", "get_position", "height", "g1", "ax_col_colors", "get_position", "height", "kws1", "self", "default_kws", "copy", "kws1", "update", "dendrogram_ratio", "2", "2", "kws2", "kws1", "copy", "kws2", "update", "dendrogram_ratio", "2", "3", "g1", "mat", "clustermap", "self", "df_norm", "kws1", "g2", "mat", "clustermap", "self", "df_norm", "kws2", "fails", "on", "pinned", "matplotlib", "assert", "g2", "ax_row_dendrogram", "get_position", "width", "g1", "ax_row_dendrogram", "get_position", "width", "assert", "g1", "gs", "get_width_ratios", "g2", "gs", "get_width_ratios", "assert", "g2", "ax_col_dendrogram", "get_position", "height", "g1", "ax_col_dendrogram", "get_position", "height"], "doc_len": 228}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_cbar_pos", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_cbar_pos", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_cbar_pos(self):\n\n        kws = self.default_kws.copy()\n        kws[\"cbar_pos\"] = (.2, .1, .4, .3)\n\n        g = mat.clustermap(self.df_norm, **kws)\n        pos = g.ax_cbar.get_position()\n        assert pytest.approx(tuple(pos.p0)) == kws[\"cbar_pos\"][:2]\n        assert pytest.approx(pos.width) == kws[\"cbar_pos\"][2]\n        assert pytest.approx(pos.height) == kws[\"cbar_pos\"][3]\n\n        kws[\"cbar_pos\"] = None\n        g = mat.clustermap(self.df_norm, **kws)\n        assert g.ax_cbar is None\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_cbar_pos", "self", "kws", "self", "default_kws", "copy", "kws", "cbar_pos", "2", "1", "4", "3", "g", "mat", "clustermap", "self", "df_norm", "kws", "pos", "g", "ax_cbar", "get_position", "assert", "pytest", "approx", "tuple", "pos", "p0", "kws", "cbar_pos", "2", "assert", "pytest", "approx", "pos", "width", "kws", "cbar_pos", "2", "assert", "pytest", "approx", "pos", "height", "kws", "cbar_pos", "3", "kws", "cbar_pos", "none", "g", "mat", "clustermap", "self", "df_norm", "kws", "assert", "g", "ax_cbar", "is", "none"], "doc_len": 66}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_square_warning", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_square_warning", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_square_warning(self):\n\n        kws = self.default_kws.copy()\n        g1 = mat.clustermap(self.df_norm, **kws)\n\n        with pytest.warns(UserWarning):\n            kws[\"square\"] = True\n            g2 = mat.clustermap(self.df_norm, **kws)\n\n        g1_shape = g1.ax_heatmap.get_position().get_points()\n        g2_shape = g2.ax_heatmap.get_position().get_points()\n        assert np.array_equal(g1_shape, g2_shape)\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_square_warning", "self", "kws", "self", "default_kws", "copy", "g1", "mat", "clustermap", "self", "df_norm", "kws", "with", "pytest", "warns", "userwarning", "kws", "square", "true", "g2", "mat", "clustermap", "self", "df_norm", "kws", "g1_shape", "g1", "ax_heatmap", "get_position", "get_points", "g2_shape", "g2", "ax_heatmap", "get_position", "get_points", "assert", "np", "array_equal", "g1_shape", "g2_shape"], "doc_len": 45}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_clustermap_annotation", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_clustermap_annotation", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_clustermap_annotation(self):\n\n        g = mat.clustermap(self.df_norm, annot=True, fmt=\".1f\")\n        for val, text in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n            assert text.get_text() == f\"{val:.1f}\"\n\n        g = mat.clustermap(self.df_norm, annot=self.df_norm, fmt=\".1f\")\n        for val, text in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n            assert text.get_text() == f\"{val:.1f}\"\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_clustermap_annotation", "self", "g", "mat", "clustermap", "self", "df_norm", "annot", "true", "fmt", "1f", "for", "val", "text", "in", "zip", "np", "asarray", "g", "data2d", "flat", "g", "ax_heatmap", "texts", "assert", "text", "get_text", "f", "val", "1f", "g", "mat", "clustermap", "self", "df_norm", "annot", "self", "df_norm", "fmt", "1f", "for", "val", "text", "in", "zip", "np", "asarray", "g", "data2d", "flat", "g", "ax_heatmap", "texts", "assert", "text", "get_text", "f", "val", "1f"], "doc_len": 64}
{"doc_id": "tests/test_matrix.py::TestClustermap.test_tree_kws", "file_path": "tests/test_matrix.py", "class_name": "TestClustermap", "func_name": "test_tree_kws", "text": "文件路径: tests/test_matrix.py, 类名: TestClustermap\n    def test_tree_kws(self):\n\n        rgb = (1, .5, .2)\n        g = mat.clustermap(self.df_norm, tree_kws=dict(color=rgb))\n        for ax in [g.ax_col_dendrogram, g.ax_row_dendrogram]:\n            tree, = ax.collections\n            assert tuple(tree.get_color().squeeze())[:3] == rgb\n", "tokens": ["tests", "test_matrix", "py", "testclustermap", "def", "test_tree_kws", "self", "rgb", "1", "5", "2", "g", "mat", "clustermap", "self", "df_norm", "tree_kws", "dict", "color", "rgb", "for", "ax", "in", "g", "ax_col_dendrogram", "g", "ax_row_dendrogram", "tree", "ax", "collections", "assert", "tuple", "tree", "get_color", "squeeze", "3", "rgb"], "doc_len": 37}
{"doc_id": "tests/test_miscplot.py::TestPalPlot.test_palplot_size", "file_path": "tests/test_miscplot.py", "class_name": "TestPalPlot", "func_name": "test_palplot_size", "text": "文件路径: tests/test_miscplot.py, 类名: TestPalPlot\n    def test_palplot_size(self):\n\n        pal4 = color_palette(\"husl\", 4)\n        misc.palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n\n        pal5 = color_palette(\"husl\", 5)\n        misc.palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n\n        palbig = color_palette(\"husl\", 3)\n        misc.palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n", "tokens": ["tests", "test_miscplot", "py", "testpalplot", "def", "test_palplot_size", "self", "pal4", "color_palette", "husl", "4", "misc", "palplot", "pal4", "size4", "plt", "gcf", "get_size_inches", "assert", "tuple", "size4", "4", "1", "pal5", "color_palette", "husl", "5", "misc", "palplot", "pal5", "size5", "plt", "gcf", "get_size_inches", "assert", "tuple", "size5", "5", "1", "palbig", "color_palette", "husl", "3", "misc", "palplot", "palbig", "2", "sizebig", "plt", "gcf", "get_size_inches", "assert", "tuple", "sizebig", "6", "2"], "doc_len": 56}
{"doc_id": "tests/test_miscplot.py::TestDogPlot.test_dogplot", "file_path": "tests/test_miscplot.py", "class_name": "TestDogPlot", "func_name": "test_dogplot", "text": "文件路径: tests/test_miscplot.py, 类名: TestDogPlot\n    def test_dogplot(self):\n        misc.dogplot()\n        ax = plt.gca()\n        assert len(ax.images) == 1\n", "tokens": ["tests", "test_miscplot", "py", "testdogplot", "def", "test_dogplot", "self", "misc", "dogplot", "ax", "plt", "gca", "assert", "len", "ax", "images", "1"], "doc_len": 17}
{"doc_id": "tests/test_objects.py::test_objects_namespace", "file_path": "tests/test_objects.py", "class_name": null, "func_name": "test_objects_namespace", "text": "文件路径: tests/test_objects.py\ndef test_objects_namespace():\n\n    for name in dir(seaborn.objects):\n        if not name.startswith(\"__\"):\n            obj = getattr(seaborn.objects, name)\n            assert issubclass(obj, (Plot, Mark, Stat, Move, Scale))\n", "tokens": ["tests", "test_objects", "py", "def", "test_objects_namespace", "for", "name", "in", "dir", "seaborn", "objects", "if", "not", "name", "startswith", "__", "obj", "getattr", "seaborn", "objects", "name", "assert", "issubclass", "obj", "plot", "mark", "stat", "move", "scale"], "doc_len": 29}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_current_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_current_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_current_palette(self):\n\n        pal = palettes.color_palette([\"red\", \"blue\", \"green\"])\n        rcmod.set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_current_palette", "self", "pal", "palettes", "color_palette", "red", "blue", "green", "rcmod", "set_palette", "pal", "assert", "pal", "utils", "get_color_cycle", "rcmod", "set"], "doc_len": 22}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_palette_context", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_palette_context", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_palette_context(self):\n\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette(\"muted\")\n\n        with palettes.color_palette(context_pal):\n            assert utils.get_color_cycle() == context_pal\n\n        assert utils.get_color_cycle() == default_pal\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_palette_context", "self", "default_pal", "palettes", "color_palette", "context_pal", "palettes", "color_palette", "muted", "with", "palettes", "color_palette", "context_pal", "assert", "utils", "get_color_cycle", "context_pal", "assert", "utils", "get_color_cycle", "default_pal"], "doc_len": 26}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_big_palette_context", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_big_palette_context", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_big_palette_context(self):\n\n        original_pal = palettes.color_palette(\"deep\", n_colors=8)\n        context_pal = palettes.color_palette(\"husl\", 10)\n\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n\n        assert utils.get_color_cycle() == original_pal\n\n        # Reset default\n        rcmod.set()\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_big_palette_context", "self", "original_pal", "palettes", "color_palette", "deep", "n_colors", "8", "context_pal", "palettes", "color_palette", "husl", "10", "rcmod", "set_palette", "original_pal", "with", "palettes", "color_palette", "context_pal", "10", "assert", "utils", "get_color_cycle", "context_pal", "assert", "utils", "get_color_cycle", "original_pal", "reset", "default", "rcmod", "set"], "doc_len": 38}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_palette_size", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_palette_size", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_palette_size(self):\n\n        pal = palettes.color_palette(\"deep\")\n        assert len(pal) == palettes.QUAL_PALETTE_SIZES[\"deep\"]\n\n        pal = palettes.color_palette(\"pastel6\")\n        assert len(pal) == palettes.QUAL_PALETTE_SIZES[\"pastel6\"]\n\n        pal = palettes.color_palette(\"Set3\")\n        assert len(pal) == palettes.QUAL_PALETTE_SIZES[\"Set3\"]\n\n        pal = palettes.color_palette(\"husl\")\n        assert len(pal) == 6\n\n        pal = palettes.color_palette(\"Greens\")\n        assert len(pal) == 6\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_palette_size", "self", "pal", "palettes", "color_palette", "deep", "assert", "len", "pal", "palettes", "qual_palette_sizes", "deep", "pal", "palettes", "color_palette", "pastel6", "assert", "len", "pal", "palettes", "qual_palette_sizes", "pastel6", "pal", "palettes", "color_palette", "set3", "assert", "len", "pal", "palettes", "qual_palette_sizes", "set3", "pal", "palettes", "color_palette", "husl", "assert", "len", "pal", "6", "pal", "palettes", "color_palette", "greens", "assert", "len", "pal", "6"], "doc_len": 53}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_seaborn_palettes", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_seaborn_palettes", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_seaborn_palettes(self):\n\n        pals = \"deep\", \"muted\", \"pastel\", \"bright\", \"dark\", \"colorblind\"\n        for name in pals:\n            full = palettes.color_palette(name, 10).as_hex()\n            short = palettes.color_palette(name + \"6\", 6).as_hex()\n            b, _, g, r, m, _, _, _, y, c = full\n            assert [b, g, r, m, y, c] == list(short)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_seaborn_palettes", "self", "pals", "deep", "muted", "pastel", "bright", "dark", "colorblind", "for", "name", "in", "pals", "full", "palettes", "color_palette", "name", "10", "as_hex", "short", "palettes", "color_palette", "name", "6", "6", "as_hex", "b", "_", "g", "r", "m", "_", "_", "_", "y", "c", "full", "assert", "b", "g", "r", "m", "y", "c", "list", "short"], "doc_len": 51}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_hls_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_hls_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_hls_palette(self):\n\n        pal1 = palettes.hls_palette()\n        pal2 = palettes.color_palette(\"hls\")\n        npt.assert_array_equal(pal1, pal2)\n\n        cmap1 = palettes.hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette(\"hls\", as_cmap=True)\n        npt.assert_array_equal(cmap1([.2, .8]), cmap2([.2, .8]))\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_hls_palette", "self", "pal1", "palettes", "hls_palette", "pal2", "palettes", "color_palette", "hls", "npt", "assert_array_equal", "pal1", "pal2", "cmap1", "palettes", "hls_palette", "as_cmap", "true", "cmap2", "palettes", "color_palette", "hls", "as_cmap", "true", "npt", "assert_array_equal", "cmap1", "2", "8", "cmap2", "2", "8"], "doc_len": 37}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_husl_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_husl_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_husl_palette(self):\n\n        pal1 = palettes.husl_palette()\n        pal2 = palettes.color_palette(\"husl\")\n        npt.assert_array_equal(pal1, pal2)\n\n        cmap1 = palettes.husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette(\"husl\", as_cmap=True)\n        npt.assert_array_equal(cmap1([.2, .8]), cmap2([.2, .8]))\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_husl_palette", "self", "pal1", "palettes", "husl_palette", "pal2", "palettes", "color_palette", "husl", "npt", "assert_array_equal", "pal1", "pal2", "cmap1", "palettes", "husl_palette", "as_cmap", "true", "cmap2", "palettes", "color_palette", "husl", "as_cmap", "true", "npt", "assert_array_equal", "cmap1", "2", "8", "cmap2", "2", "8"], "doc_len": 37}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_mpl_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_mpl_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_mpl_palette(self):\n\n        pal1 = palettes.mpl_palette(\"Reds\")\n        pal2 = palettes.color_palette(\"Reds\")\n        npt.assert_array_equal(pal1, pal2)\n\n        cmap1 = get_colormap(\"Reds\")\n        cmap2 = palettes.mpl_palette(\"Reds\", as_cmap=True)\n        cmap3 = palettes.color_palette(\"Reds\", as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_mpl_palette", "self", "pal1", "palettes", "mpl_palette", "reds", "pal2", "palettes", "color_palette", "reds", "npt", "assert_array_equal", "pal1", "pal2", "cmap1", "get_colormap", "reds", "cmap2", "palettes", "mpl_palette", "reds", "as_cmap", "true", "cmap3", "palettes", "color_palette", "reds", "as_cmap", "true", "npt", "assert_array_equal", "cmap1", "cmap2", "npt", "assert_array_equal", "cmap1", "cmap3"], "doc_len": 42}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_mpl_dark_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_mpl_dark_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_mpl_dark_palette(self):\n\n        mpl_pal1 = palettes.mpl_palette(\"Blues_d\")\n        mpl_pal2 = palettes.color_palette(\"Blues_d\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n\n        mpl_pal1 = palettes.mpl_palette(\"Blues_r_d\")\n        mpl_pal2 = palettes.color_palette(\"Blues_r_d\")\n        npt.assert_array_equal(mpl_pal1, mpl_pal2)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_mpl_dark_palette", "self", "mpl_pal1", "palettes", "mpl_palette", "blues_d", "mpl_pal2", "palettes", "color_palette", "blues_d", "npt", "assert_array_equal", "mpl_pal1", "mpl_pal2", "mpl_pal1", "palettes", "mpl_palette", "blues_r_d", "mpl_pal2", "palettes", "color_palette", "blues_r_d", "npt", "assert_array_equal", "mpl_pal1", "mpl_pal2"], "doc_len": 31}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_bad_palette_name", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_bad_palette_name", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_bad_palette_name(self):\n\n        with pytest.raises(ValueError):\n            palettes.color_palette(\"IAmNotAPalette\")\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_bad_palette_name", "self", "with", "pytest", "raises", "valueerror", "palettes", "color_palette", "iamnotapalette"], "doc_len": 14}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_terrible_palette_name", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_terrible_palette_name", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_terrible_palette_name(self):\n\n        with pytest.raises(ValueError):\n            palettes.color_palette(\"jet\")\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_terrible_palette_name", "self", "with", "pytest", "raises", "valueerror", "palettes", "color_palette", "jet"], "doc_len": 14}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_bad_palette_colors", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_bad_palette_colors", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_bad_palette_colors(self):\n\n        pal = [\"red\", \"blue\", \"iamnotacolor\"]\n        with pytest.raises(ValueError):\n            palettes.color_palette(pal)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_bad_palette_colors", "self", "pal", "red", "blue", "iamnotacolor", "with", "pytest", "raises", "valueerror", "palettes", "color_palette", "pal"], "doc_len": 18}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_palette_desat", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_palette_desat", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_palette_desat(self):\n\n        pal1 = palettes.husl_palette(6)\n        pal1 = [utils.desaturate(c, .5) for c in pal1]\n        pal2 = palettes.color_palette(\"husl\", desat=.5)\n        npt.assert_array_equal(pal1, pal2)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_palette_desat", "self", "pal1", "palettes", "husl_palette", "6", "pal1", "utils", "desaturate", "c", "5", "for", "c", "in", "pal1", "pal2", "palettes", "color_palette", "husl", "desat", "5", "npt", "assert_array_equal", "pal1", "pal2"], "doc_len": 30}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_palette_is_list_of_tuples", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_palette_is_list_of_tuples", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_palette_is_list_of_tuples(self):\n\n        pal_in = np.array([\"red\", \"blue\", \"green\"])\n        pal_out = palettes.color_palette(pal_in, 3)\n\n        assert isinstance(pal_out, list)\n        assert isinstance(pal_out[0], tuple)\n        assert isinstance(pal_out[0][0], float)\n        assert len(pal_out[0]) == 3\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_palette_is_list_of_tuples", "self", "pal_in", "np", "array", "red", "blue", "green", "pal_out", "palettes", "color_palette", "pal_in", "3", "assert", "isinstance", "pal_out", "list", "assert", "isinstance", "pal_out", "0", "tuple", "assert", "isinstance", "pal_out", "0", "0", "float", "assert", "len", "pal_out", "0", "3"], "doc_len": 38}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_palette_cycles", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_palette_cycles", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_palette_cycles(self):\n\n        deep = palettes.color_palette(\"deep6\")\n        double_deep = palettes.color_palette(\"deep6\", 12)\n        assert double_deep == deep + deep\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_palette_cycles", "self", "deep", "palettes", "color_palette", "deep6", "double_deep", "palettes", "color_palette", "deep6", "12", "assert", "double_deep", "deep", "deep"], "doc_len": 20}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_hls_values", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_hls_values", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_hls_values(self):\n\n        pal1 = palettes.hls_palette(6, h=0)\n        pal2 = palettes.hls_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.hls_palette(5, l=.2)  # noqa\n        pal_bright = palettes.hls_palette(5, l=.8)  # noqa\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.hls_palette(5, s=.1)\n        pal_bold = palettes.hls_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_hls_values", "self", "pal1", "palettes", "hls_palette", "6", "h", "0", "pal2", "palettes", "hls_palette", "6", "h", "5", "pal2", "pal2", "3", "pal2", "3", "npt", "assert_array_almost_equal", "pal1", "pal2", "pal_dark", "palettes", "hls_palette", "5", "l", "2", "noqa", "pal_bright", "palettes", "hls_palette", "5", "l", "8", "noqa", "npt", "assert_array_less", "list", "map", "sum", "pal_dark", "list", "map", "sum", "pal_bright", "pal_flat", "palettes", "hls_palette", "5", "s", "1", "pal_bold", "palettes", "hls_palette", "5", "s", "9", "npt", "assert_array_less", "list", "map", "np", "std", "pal_flat", "list", "map", "np", "std", "pal_bold"], "doc_len": 76}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_husl_values", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_husl_values", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_husl_values(self):\n\n        pal1 = palettes.husl_palette(6, h=0)\n        pal2 = palettes.husl_palette(6, h=.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n\n        pal_dark = palettes.husl_palette(5, l=.2)  # noqa\n        pal_bright = palettes.husl_palette(5, l=.8)  # noqa\n        npt.assert_array_less(list(map(sum, pal_dark)),\n                              list(map(sum, pal_bright)))\n\n        pal_flat = palettes.husl_palette(5, s=.1)\n        pal_bold = palettes.husl_palette(5, s=.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)),\n                              list(map(np.std, pal_bold)))\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_husl_values", "self", "pal1", "palettes", "husl_palette", "6", "h", "0", "pal2", "palettes", "husl_palette", "6", "h", "5", "pal2", "pal2", "3", "pal2", "3", "npt", "assert_array_almost_equal", "pal1", "pal2", "pal_dark", "palettes", "husl_palette", "5", "l", "2", "noqa", "pal_bright", "palettes", "husl_palette", "5", "l", "8", "noqa", "npt", "assert_array_less", "list", "map", "sum", "pal_dark", "list", "map", "sum", "pal_bright", "pal_flat", "palettes", "husl_palette", "5", "s", "1", "pal_bold", "palettes", "husl_palette", "5", "s", "9", "npt", "assert_array_less", "list", "map", "np", "std", "pal_flat", "list", "map", "np", "std", "pal_bold"], "doc_len": 76}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cbrewer_qual", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cbrewer_qual", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cbrewer_qual(self):\n\n        pal_short = palettes.mpl_palette(\"Set1\", 4)\n        pal_long = palettes.mpl_palette(\"Set1\", 6)\n        assert pal_short == pal_long[:4]\n\n        pal_full = palettes.mpl_palette(\"Set2\", 8)\n        pal_long = palettes.mpl_palette(\"Set2\", 10)\n        assert pal_full == pal_long[:8]\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cbrewer_qual", "self", "pal_short", "palettes", "mpl_palette", "set1", "4", "pal_long", "palettes", "mpl_palette", "set1", "6", "assert", "pal_short", "pal_long", "4", "pal_full", "palettes", "mpl_palette", "set2", "8", "pal_long", "palettes", "mpl_palette", "set2", "10", "assert", "pal_full", "pal_long", "8"], "doc_len": 35}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_mpl_reversal", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_mpl_reversal", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_mpl_reversal(self):\n\n        pal_forward = palettes.mpl_palette(\"BuPu\", 6)\n        pal_reverse = palettes.mpl_palette(\"BuPu_r\", 6)\n        npt.assert_array_almost_equal(pal_forward, pal_reverse[::-1])\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_mpl_reversal", "self", "pal_forward", "palettes", "mpl_palette", "bupu", "6", "pal_reverse", "palettes", "mpl_palette", "bupu_r", "6", "npt", "assert_array_almost_equal", "pal_forward", "pal_reverse", "1"], "doc_len": 22}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_rgb_from_hls", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_rgb_from_hls", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_rgb_from_hls(self):\n\n        color = .5, .8, .4\n        rgb_got = palettes._color_to_rgb(color, \"hls\")\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_rgb_from_hls", "self", "color", "5", "8", "4", "rgb_got", "palettes", "_color_to_rgb", "color", "hls", "rgb_want", "colorsys", "hls_to_rgb", "color", "assert", "rgb_got", "rgb_want"], "doc_len": 23}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_rgb_from_husl", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_rgb_from_husl", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_rgb_from_husl(self):\n\n        color = 120, 50, 40\n        rgb_got = palettes._color_to_rgb(color, \"husl\")\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = palettes._color_to_rgb(color, \"husl\")\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_rgb_from_husl", "self", "color", "120", "50", "40", "rgb_got", "palettes", "_color_to_rgb", "color", "husl", "rgb_want", "tuple", "husl", "husl_to_rgb", "color", "assert", "rgb_got", "rgb_want", "for", "h", "in", "range", "0", "360", "color", "h", "100", "100", "rgb", "palettes", "_color_to_rgb", "color", "husl", "assert", "min", "rgb", "0", "assert", "max", "rgb", "1"], "doc_len": 47}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_rgb_from_xkcd", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_rgb_from_xkcd", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_rgb_from_xkcd(self):\n\n        color = \"dull red\"\n        rgb_got = palettes._color_to_rgb(color, \"xkcd\")\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_rgb_from_xkcd", "self", "color", "dull", "red", "rgb_got", "palettes", "_color_to_rgb", "color", "xkcd", "rgb_want", "mpl", "colors", "to_rgb", "xkcd_rgb", "color", "assert", "rgb_got", "rgb_want"], "doc_len": 24}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_light_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_light_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_light_palette(self):\n\n        n = 4\n        pal_forward = palettes.light_palette(\"red\", n)\n        pal_reverse = palettes.light_palette(\"red\", n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n\n        red = mpl.colors.colorConverter.to_rgb(\"red\")\n        assert pal_forward[-1] == red\n\n        pal_f_from_string = palettes.color_palette(\"light:red\", n)\n        assert pal_forward[3] == pal_f_from_string[3]\n\n        pal_r_from_string = palettes.color_palette(\"light:red_r\", n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n\n        pal_cmap = palettes.light_palette(\"blue\", as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n        pal_cmap_from_string = palettes.color_palette(\"light:blue\", as_cmap=True)\n        assert pal_cmap(.8) == pal_cmap_from_string(.8)\n\n        pal_cmap = palettes.light_palette(\"blue\", as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette(\"light:blue_r\", as_cmap=True)\n        assert pal_cmap(.8) == pal_cmap_from_string(.8)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_light_palette", "self", "n", "4", "pal_forward", "palettes", "light_palette", "red", "n", "pal_reverse", "palettes", "light_palette", "red", "n", "reverse", "true", "assert", "np", "allclose", "pal_forward", "pal_reverse", "1", "red", "mpl", "colors", "colorconverter", "to_rgb", "red", "assert", "pal_forward", "1", "red", "pal_f_from_string", "palettes", "color_palette", "light", "red", "n", "assert", "pal_forward", "3", "pal_f_from_string", "3", "pal_r_from_string", "palettes", "color_palette", "light", "red_r", "n", "assert", "pal_reverse", "3", "pal_r_from_string", "3", "pal_cmap", "palettes", "light_palette", "blue", "as_cmap", "true", "assert", "isinstance", "pal_cmap", "mpl", "colors", "linearsegmentedcolormap", "pal_cmap_from_string", "palettes", "color_palette", "light", "blue", "as_cmap", "true", "assert", "pal_cmap", "8", "pal_cmap_from_string", "8", "pal_cmap", "palettes", "light_palette", "blue", "as_cmap", "true", "reverse", "true", "pal_cmap_from_string", "palettes", "color_palette", "light", "blue_r", "as_cmap", "true", "assert", "pal_cmap", "8", "pal_cmap_from_string", "8"], "doc_len": 103}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_dark_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_dark_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_dark_palette(self):\n\n        n = 4\n        pal_forward = palettes.dark_palette(\"red\", n)\n        pal_reverse = palettes.dark_palette(\"red\", n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n\n        red = mpl.colors.colorConverter.to_rgb(\"red\")\n        assert pal_forward[-1] == red\n\n        pal_f_from_string = palettes.color_palette(\"dark:red\", n)\n        assert pal_forward[3] == pal_f_from_string[3]\n\n        pal_r_from_string = palettes.color_palette(\"dark:red_r\", n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n\n        pal_cmap = palettes.dark_palette(\"blue\", as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n        pal_cmap_from_string = palettes.color_palette(\"dark:blue\", as_cmap=True)\n        assert pal_cmap(.8) == pal_cmap_from_string(.8)\n\n        pal_cmap = palettes.dark_palette(\"blue\", as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette(\"dark:blue_r\", as_cmap=True)\n        assert pal_cmap(.8) == pal_cmap_from_string(.8)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_dark_palette", "self", "n", "4", "pal_forward", "palettes", "dark_palette", "red", "n", "pal_reverse", "palettes", "dark_palette", "red", "n", "reverse", "true", "assert", "np", "allclose", "pal_forward", "pal_reverse", "1", "red", "mpl", "colors", "colorconverter", "to_rgb", "red", "assert", "pal_forward", "1", "red", "pal_f_from_string", "palettes", "color_palette", "dark", "red", "n", "assert", "pal_forward", "3", "pal_f_from_string", "3", "pal_r_from_string", "palettes", "color_palette", "dark", "red_r", "n", "assert", "pal_reverse", "3", "pal_r_from_string", "3", "pal_cmap", "palettes", "dark_palette", "blue", "as_cmap", "true", "assert", "isinstance", "pal_cmap", "mpl", "colors", "linearsegmentedcolormap", "pal_cmap_from_string", "palettes", "color_palette", "dark", "blue", "as_cmap", "true", "assert", "pal_cmap", "8", "pal_cmap_from_string", "8", "pal_cmap", "palettes", "dark_palette", "blue", "as_cmap", "true", "reverse", "true", "pal_cmap_from_string", "palettes", "color_palette", "dark", "blue_r", "as_cmap", "true", "assert", "pal_cmap", "8", "pal_cmap_from_string", "8"], "doc_len": 103}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_diverging_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_diverging_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_diverging_palette(self):\n\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = palettes.light_palette((h_neg, sat, lum), int(n // 2),\n                                         input=\"husl\")\n        pos_pal = palettes.light_palette((h_pos, sat, lum), int(n // 2),\n                                         input=\"husl\")\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n\n        pal_dark = palettes.diverging_palette(*args, n=n, center=\"dark\")\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_diverging_palette", "self", "h_neg", "h_pos", "100", "200", "sat", "lum", "70", "50", "args", "h_neg", "h_pos", "sat", "lum", "n", "12", "pal", "palettes", "diverging_palette", "args", "n", "n", "neg_pal", "palettes", "light_palette", "h_neg", "sat", "lum", "int", "n", "2", "input", "husl", "pos_pal", "palettes", "light_palette", "h_pos", "sat", "lum", "int", "n", "2", "input", "husl", "assert", "len", "pal", "n", "assert", "pal", "0", "neg_pal", "1", "assert", "pal", "1", "pos_pal", "1", "pal_dark", "palettes", "diverging_palette", "args", "n", "n", "center", "dark", "assert", "np", "mean", "pal", "int", "n", "2", "np", "mean", "pal_dark", "int", "n", "2", "pal_cmap", "palettes", "diverging_palette", "args", "as_cmap", "true", "assert", "isinstance", "pal_cmap", "mpl", "colors", "linearsegmentedcolormap"], "doc_len": 97}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_blend_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_blend_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_blend_palette(self):\n\n        colors = [\"red\", \"yellow\", \"white\"]\n        pal_cmap = palettes.blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n\n        colors = [\"red\", \"blue\"]\n        pal = palettes.blend_palette(colors)\n        pal_str = \"blend:\" + \",\".join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_blend_palette", "self", "colors", "red", "yellow", "white", "pal_cmap", "palettes", "blend_palette", "colors", "as_cmap", "true", "assert", "isinstance", "pal_cmap", "mpl", "colors", "linearsegmentedcolormap", "colors", "red", "blue", "pal", "palettes", "blend_palette", "colors", "pal_str", "blend", "join", "colors", "pal_from_str", "palettes", "color_palette", "pal_str", "assert", "pal", "pal_from_str"], "doc_len": 41}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cubehelix_against_matplotlib", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cubehelix_against_matplotlib", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cubehelix_against_matplotlib(self):\n\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n\n        sns_pal = palettes.cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n                                             dark=0, light=1, reverse=True)\n\n        assert sns_pal == mpl_pal\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cubehelix_against_matplotlib", "self", "x", "np", "linspace", "0", "1", "8", "mpl_pal", "mpl", "cm", "cubehelix", "x", "3", "tolist", "sns_pal", "palettes", "cubehelix_palette", "8", "start", "0", "5", "rot", "1", "5", "hue", "1", "dark", "0", "light", "1", "reverse", "true", "assert", "sns_pal", "mpl_pal"], "doc_len": 41}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cubehelix_n_colors", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cubehelix_n_colors", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cubehelix_n_colors(self):\n\n        for n in [3, 5, 8]:\n            pal = palettes.cubehelix_palette(n)\n            assert len(pal) == n\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cubehelix_n_colors", "self", "for", "n", "in", "3", "5", "8", "pal", "palettes", "cubehelix_palette", "n", "assert", "len", "pal", "n"], "doc_len": 21}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cubehelix_reverse", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cubehelix_reverse", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cubehelix_reverse(self):\n\n        pal_forward = palettes.cubehelix_palette()\n        pal_reverse = palettes.cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cubehelix_reverse", "self", "pal_forward", "palettes", "cubehelix_palette", "pal_reverse", "palettes", "cubehelix_palette", "reverse", "true", "assert", "pal_forward", "pal_reverse", "1"], "doc_len": 19}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cubehelix_cmap", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cubehelix_cmap", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cubehelix_cmap(self):\n\n        cmap = palettes.cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = palettes.cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n\n        cmap_rev = palettes.cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cubehelix_cmap", "self", "cmap", "palettes", "cubehelix_palette", "as_cmap", "true", "assert", "isinstance", "cmap", "mpl", "colors", "listedcolormap", "pal", "palettes", "cubehelix_palette", "x", "np", "linspace", "0", "1", "6", "npt", "assert_array_equal", "cmap", "x", "3", "pal", "cmap_rev", "palettes", "cubehelix_palette", "as_cmap", "true", "reverse", "true", "x", "np", "linspace", "0", "1", "6", "pal_forward", "cmap", "x", "tolist", "pal_reverse", "cmap_rev", "x", "1", "tolist", "assert", "pal_forward", "pal_reverse"], "doc_len": 58}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_cubehelix_code", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_cubehelix_code", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_cubehelix_code(self):\n\n        color_palette = palettes.color_palette\n        cubehelix_palette = palettes.cubehelix_palette\n\n        pal1 = color_palette(\"ch:\", 8)\n        pal2 = color_palette(cubehelix_palette(8))\n        assert pal1 == pal2\n\n        pal1 = color_palette(\"ch:.5, -.25,hue = .5,light=.75\", 8)\n        pal2 = color_palette(cubehelix_palette(8, .5, -.25, hue=.5, light=.75))\n        assert pal1 == pal2\n\n        pal1 = color_palette(\"ch:h=1,r=.5\", 9)\n        pal2 = color_palette(cubehelix_palette(9, hue=1, rot=.5))\n        assert pal1 == pal2\n\n        pal1 = color_palette(\"ch:_r\", 6)\n        pal2 = color_palette(cubehelix_palette(6, reverse=True))\n        assert pal1 == pal2\n\n        pal1 = color_palette(\"ch:_r\", as_cmap=True)\n        pal2 = cubehelix_palette(6, reverse=True, as_cmap=True)\n        assert pal1(.5) == pal2(.5)\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_cubehelix_code", "self", "color_palette", "palettes", "color_palette", "cubehelix_palette", "palettes", "cubehelix_palette", "pal1", "color_palette", "ch", "8", "pal2", "color_palette", "cubehelix_palette", "8", "assert", "pal1", "pal2", "pal1", "color_palette", "ch", "5", "25", "hue", "5", "light", "75", "8", "pal2", "color_palette", "cubehelix_palette", "8", "5", "25", "hue", "5", "light", "75", "assert", "pal1", "pal2", "pal1", "color_palette", "ch", "h", "1", "r", "5", "9", "pal2", "color_palette", "cubehelix_palette", "9", "hue", "1", "rot", "5", "assert", "pal1", "pal2", "pal1", "color_palette", "ch", "_r", "6", "pal2", "color_palette", "cubehelix_palette", "6", "reverse", "true", "assert", "pal1", "pal2", "pal1", "color_palette", "ch", "_r", "as_cmap", "true", "pal2", "cubehelix_palette", "6", "reverse", "true", "as_cmap", "true", "assert", "pal1", "5", "pal2", "5"], "doc_len": 98}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_xkcd_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_xkcd_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_xkcd_palette(self):\n\n        names = list(xkcd_rgb.keys())[10:15]\n        colors = palettes.xkcd_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            assert as_hex == xkcd_rgb[name]\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_xkcd_palette", "self", "names", "list", "xkcd_rgb", "keys", "10", "15", "colors", "palettes", "xkcd_palette", "names", "for", "name", "color", "in", "zip", "names", "colors", "as_hex", "mpl", "colors", "rgb2hex", "color", "assert", "as_hex", "xkcd_rgb", "name"], "doc_len": 33}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_crayon_palette", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_crayon_palette", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_crayon_palette(self):\n\n        names = list(crayons.keys())[10:15]\n        colors = palettes.crayon_palette(names)\n        for name, color in zip(names, colors):\n            as_hex = mpl.colors.rgb2hex(color)\n            assert as_hex == crayons[name].lower()\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_crayon_palette", "self", "names", "list", "crayons", "keys", "10", "15", "colors", "palettes", "crayon_palette", "names", "for", "name", "color", "in", "zip", "names", "colors", "as_hex", "mpl", "colors", "rgb2hex", "color", "assert", "as_hex", "crayons", "name", "lower"], "doc_len": 34}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_color_codes", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_color_codes", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_color_codes(self):\n\n        palettes.set_color_codes(\"deep\")\n        colors = palettes.color_palette(\"deep6\") + [\".1\"]\n        for code, color in zip(\"bgrmyck\", colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        palettes.set_color_codes(\"reset\")\n\n        with pytest.raises(ValueError):\n            palettes.set_color_codes(\"Set1\")\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_color_codes", "self", "palettes", "set_color_codes", "deep", "colors", "palettes", "color_palette", "deep6", "1", "for", "code", "color", "in", "zip", "bgrmyck", "colors", "rgb_want", "mpl", "colors", "colorconverter", "to_rgb", "color", "rgb_got", "mpl", "colors", "colorconverter", "to_rgb", "code", "assert", "rgb_want", "rgb_got", "palettes", "set_color_codes", "reset", "with", "pytest", "raises", "valueerror", "palettes", "set_color_codes", "set1"], "doc_len": 47}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_as_hex", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_as_hex", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_as_hex(self):\n\n        pal = palettes.color_palette(\"deep\")\n        for rgb, hex in zip(pal, pal.as_hex()):\n            assert mpl.colors.rgb2hex(rgb) == hex\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_as_hex", "self", "pal", "palettes", "color_palette", "deep", "for", "rgb", "hex", "in", "zip", "pal", "pal", "as_hex", "assert", "mpl", "colors", "rgb2hex", "rgb", "hex"], "doc_len": 25}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_preserved_palette_length", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_preserved_palette_length", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_preserved_palette_length(self):\n\n        pal_in = palettes.color_palette(\"Set1\", 10)\n        pal_out = palettes.color_palette(pal_in)\n        assert pal_in == pal_out\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_preserved_palette_length", "self", "pal_in", "palettes", "color_palette", "set1", "10", "pal_out", "palettes", "color_palette", "pal_in", "assert", "pal_in", "pal_out"], "doc_len": 19}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_html_repr", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_html_repr", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_html_repr(self):\n\n        pal = palettes.color_palette()\n        html = pal._repr_html_()\n        for color in pal.as_hex():\n            assert color in html\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_html_repr", "self", "pal", "palettes", "color_palette", "html", "pal", "_repr_html_", "for", "color", "in", "pal", "as_hex", "assert", "color", "in", "html"], "doc_len": 22}
{"doc_id": "tests/test_palettes.py::TestColorPalettes.test_colormap_display_patch", "file_path": "tests/test_palettes.py", "class_name": "TestColorPalettes", "func_name": "test_colormap_display_patch", "text": "文件路径: tests/test_palettes.py, 类名: TestColorPalettes\n    def test_colormap_display_patch(self):\n\n        orig_repr_png = getattr(mpl.colors.Colormap, \"_repr_png_\", None)\n        orig_repr_html = getattr(mpl.colors.Colormap, \"_repr_html_\", None)\n\n        try:\n            palettes._patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n", "tokens": ["tests", "test_palettes", "py", "testcolorpalettes", "def", "test_colormap_display_patch", "self", "orig_repr_png", "getattr", "mpl", "colors", "colormap", "_repr_png_", "none", "orig_repr_html", "getattr", "mpl", "colors", "colormap", "_repr_html_", "none", "try", "palettes", "_patch_colormap_display", "cmap", "mpl", "cm", "reds", "assert", "cmap", "_repr_html_", "startswith", "img", "alt", "reds", "finally", "if", "orig_repr_png", "is", "not", "none", "mpl", "colors", "colormap", "_repr_png_", "orig_repr_png", "if", "orig_repr_html", "is", "not", "none", "mpl", "colors", "colormap", "_repr_html_", "orig_repr_html"], "doc_len": 56}
{"doc_id": "tests/test_rcmod.py::has_verdana", "file_path": "tests/test_rcmod.py", "class_name": null, "func_name": "has_verdana", "text": "文件路径: tests/test_rcmod.py\ndef has_verdana():\n    \"\"\"Helper to verify if Verdana font is present\"\"\"\n    # This import is relatively lengthy, so to prevent its import for\n    # testing other tests in this module not requiring this knowledge,\n    # import font_manager here\n    import matplotlib.font_manager as mplfm\n    try:\n        verdana_font = mplfm.findfont('Verdana', fallback_to_default=False)\n    except:  # noqa\n        # if https://github.com/matplotlib/matplotlib/pull/3435\n        # gets accepted\n        return False\n    # otherwise check if not matching the logic for a 'default' one\n    try:\n        unlikely_font = mplfm.findfont(\"very_unlikely_to_exist1234\",\n                                       fallback_to_default=False)\n    except:  # noqa\n        # if matched verdana but not unlikely, Verdana must exist\n        return True\n    # otherwise -- if they match, must be the same default\n    return verdana_font != unlikely_font\n", "tokens": ["tests", "test_rcmod", "py", "def", "has_verdana", "helper", "to", "verify", "if", "verdana", "font", "is", "present", "this", "import", "is", "relatively", "lengthy", "so", "to", "prevent", "its", "import", "for", "testing", "other", "tests", "in", "this", "module", "not", "requiring", "this", "knowledge", "import", "font_manager", "here", "import", "matplotlib", "font_manager", "as", "mplfm", "try", "verdana_font", "mplfm", "findfont", "verdana", "fallback_to_default", "false", "except", "noqa", "if", "https", "github", "com", "matplotlib", "matplotlib", "pull", "3435", "gets", "accepted", "return", "false", "otherwise", "check", "if", "not", "matching", "the", "logic", "for", "a", "default", "one", "try", "unlikely_font", "mplfm", "findfont", "very_unlikely_to_exist1234", "fallback_to_default", "false", "except", "noqa", "if", "matched", "verdana", "but", "not", "unlikely", "verdana", "must", "exist", "return", "true", "otherwise", "if", "they", "match", "must", "be", "the", "same", "default", "return", "verdana_font", "unlikely_font"], "doc_len": 106}
{"doc_id": "tests/test_rcmod.py::RCParamFixtures.reset_params", "file_path": "tests/test_rcmod.py", "class_name": "RCParamFixtures", "func_name": "reset_params", "text": "文件路径: tests/test_rcmod.py, 类名: RCParamFixtures\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n", "tokens": ["tests", "test_rcmod", "py", "rcparamfixtures", "def", "reset_params", "self", "yield", "rcmod", "reset_orig"], "doc_len": 10}
{"doc_id": "tests/test_rcmod.py::RCParamFixtures.flatten_list", "file_path": "tests/test_rcmod.py", "class_name": "RCParamFixtures", "func_name": "flatten_list", "text": "文件路径: tests/test_rcmod.py, 类名: RCParamFixtures\n    def flatten_list(self, orig_list):\n\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n", "tokens": ["tests", "test_rcmod", "py", "rcparamfixtures", "def", "flatten_list", "self", "orig_list", "iter_list", "map", "np", "atleast_1d", "orig_list", "flat_list", "item", "for", "sublist", "in", "iter_list", "for", "item", "in", "sublist", "return", "flat_list"], "doc_len": 25}
{"doc_id": "tests/test_rcmod.py::RCParamFixtures.assert_rc_params", "file_path": "tests/test_rcmod.py", "class_name": "RCParamFixtures", "func_name": "assert_rc_params", "text": "文件路径: tests/test_rcmod.py, 类名: RCParamFixtures\n    def assert_rc_params(self, params):\n\n        for k, v in params.items():\n            # Various subtle issues in matplotlib lead to unexpected\n            # values for the backend rcParam, which isn't relevant here\n            if k == \"backend\":\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n", "tokens": ["tests", "test_rcmod", "py", "rcparamfixtures", "def", "assert_rc_params", "self", "params", "for", "k", "v", "in", "params", "items", "various", "subtle", "issues", "in", "matplotlib", "lead", "to", "unexpected", "values", "for", "the", "backend", "rcparam", "which", "isn", "t", "relevant", "here", "if", "k", "backend", "continue", "if", "isinstance", "v", "np", "ndarray", "npt", "assert_array_equal", "mpl", "rcparams", "k", "v", "else", "assert", "mpl", "rcparams", "k", "v"], "doc_len": 53}
{"doc_id": "tests/test_rcmod.py::RCParamFixtures.assert_rc_params_equal", "file_path": "tests/test_rcmod.py", "class_name": "RCParamFixtures", "func_name": "assert_rc_params_equal", "text": "文件路径: tests/test_rcmod.py, 类名: RCParamFixtures\n    def assert_rc_params_equal(self, params1, params2):\n\n        for key, v1 in params1.items():\n            # Various subtle issues in matplotlib lead to unexpected\n            # values for the backend rcParam, which isn't relevant here\n            if key == \"backend\":\n                continue\n\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n", "tokens": ["tests", "test_rcmod", "py", "rcparamfixtures", "def", "assert_rc_params_equal", "self", "params1", "params2", "for", "key", "v1", "in", "params1", "items", "various", "subtle", "issues", "in", "matplotlib", "lead", "to", "unexpected", "values", "for", "the", "backend", "rcparam", "which", "isn", "t", "relevant", "here", "if", "key", "backend", "continue", "v2", "params2", "key", "if", "isinstance", "v1", "np", "ndarray", "npt", "assert_array_equal", "v1", "v2", "else", "assert", "v1", "v2"], "doc_len": 53}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_default_return", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_default_return", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_default_return(self):\n\n        current = rcmod.axes_style()\n        self.assert_rc_params(current)\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_default_return", "self", "current", "rcmod", "axes_style", "self", "assert_rc_params", "current"], "doc_len": 13}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_key_usage", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_key_usage", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_key_usage(self):\n\n        _style_keys = set(rcmod._style_keys)\n        for style in self.styles:\n            assert not set(rcmod.axes_style(style)) ^ _style_keys\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_key_usage", "self", "_style_keys", "set", "rcmod", "_style_keys", "for", "style", "in", "self", "styles", "assert", "not", "set", "rcmod", "axes_style", "style", "_style_keys"], "doc_len": 23}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_bad_style", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_bad_style", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_bad_style(self):\n\n        with pytest.raises(ValueError):\n            rcmod.axes_style(\"i_am_not_a_style\")\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_bad_style", "self", "with", "pytest", "raises", "valueerror", "rcmod", "axes_style", "i_am_not_a_style"], "doc_len": 14}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_rc_override", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_rc_override", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_rc_override(self):\n\n        rc = {\"axes.facecolor\": \"blue\", \"foo.notaparam\": \"bar\"}\n        out = rcmod.axes_style(\"darkgrid\", rc)\n        assert out[\"axes.facecolor\"] == \"blue\"\n        assert \"foo.notaparam\" not in out\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_rc_override", "self", "rc", "axes", "facecolor", "blue", "foo", "notaparam", "bar", "out", "rcmod", "axes_style", "darkgrid", "rc", "assert", "out", "axes", "facecolor", "blue", "assert", "foo", "notaparam", "not", "in", "out"], "doc_len": 30}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_set_style", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_set_style", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_set_style(self):\n\n        for style in self.styles:\n\n            style_dict = rcmod.axes_style(style)\n            rcmod.set_style(style)\n            self.assert_rc_params(style_dict)\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_set_style", "self", "for", "style", "in", "self", "styles", "style_dict", "rcmod", "axes_style", "style", "rcmod", "set_style", "style", "self", "assert_rc_params", "style_dict"], "doc_len": 22}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_style_context_manager", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_style_context_manager", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_style_context_manager(self):\n\n        rcmod.set_style(\"darkgrid\")\n        orig_params = rcmod.axes_style()\n        context_params = rcmod.axes_style(\"whitegrid\")\n\n        with rcmod.axes_style(\"whitegrid\"):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n\n        @rcmod.axes_style(\"whitegrid\")\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_style_context_manager", "self", "rcmod", "set_style", "darkgrid", "orig_params", "rcmod", "axes_style", "context_params", "rcmod", "axes_style", "whitegrid", "with", "rcmod", "axes_style", "whitegrid", "self", "assert_rc_params", "context_params", "self", "assert_rc_params", "orig_params", "rcmod", "axes_style", "whitegrid", "def", "func", "self", "assert_rc_params", "context_params", "func", "self", "assert_rc_params", "orig_params"], "doc_len": 39}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_style_context_independence", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_style_context_independence", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_style_context_independence(self):\n\n        assert set(rcmod._style_keys) ^ set(rcmod._context_keys)\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_style_context_independence", "self", "assert", "set", "rcmod", "_style_keys", "set", "rcmod", "_context_keys"], "doc_len": 14}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_set_rc", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_set_rc", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_set_rc(self):\n\n        rcmod.set_theme(rc={\"lines.linewidth\": 4})\n        assert mpl.rcParams[\"lines.linewidth\"] == 4\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_set_rc", "self", "rcmod", "set_theme", "rc", "lines", "linewidth", "4", "assert", "mpl", "rcparams", "lines", "linewidth", "4", "rcmod", "set_theme"], "doc_len": 21}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_set_with_palette", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_set_with_palette", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_set_with_palette(self):\n\n        rcmod.reset_orig()\n\n        rcmod.set_theme(palette=\"deep\")\n        assert utils.get_color_cycle() == palettes.color_palette(\"deep\", 10)\n        rcmod.reset_orig()\n\n        rcmod.set_theme(palette=\"deep\", color_codes=False)\n        assert utils.get_color_cycle() == palettes.color_palette(\"deep\", 10)\n        rcmod.reset_orig()\n\n        pal = palettes.color_palette(\"deep\")\n        rcmod.set_theme(palette=pal)\n        assert utils.get_color_cycle() == palettes.color_palette(\"deep\", 10)\n        rcmod.reset_orig()\n\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert utils.get_color_cycle() == palettes.color_palette(\"deep\", 10)\n        rcmod.reset_orig()\n\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_set_with_palette", "self", "rcmod", "reset_orig", "rcmod", "set_theme", "palette", "deep", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "deep", "10", "rcmod", "reset_orig", "rcmod", "set_theme", "palette", "deep", "color_codes", "false", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "deep", "10", "rcmod", "reset_orig", "pal", "palettes", "color_palette", "deep", "rcmod", "set_theme", "palette", "pal", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "deep", "10", "rcmod", "reset_orig", "rcmod", "set_theme", "palette", "pal", "color_codes", "false", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "deep", "10", "rcmod", "reset_orig", "rcmod", "set_theme"], "doc_len": 71}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_reset_defaults", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_reset_defaults", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_reset_defaults(self):\n\n        rcmod.reset_defaults()\n        self.assert_rc_params(mpl.rcParamsDefault)\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_reset_defaults", "self", "rcmod", "reset_defaults", "self", "assert_rc_params", "mpl", "rcparamsdefault", "rcmod", "set_theme"], "doc_len": 15}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_reset_orig", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_reset_orig", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_reset_orig(self):\n\n        rcmod.reset_orig()\n        self.assert_rc_params(mpl.rcParamsOrig)\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_reset_orig", "self", "rcmod", "reset_orig", "self", "assert_rc_params", "mpl", "rcparamsorig", "rcmod", "set_theme"], "doc_len": 15}
{"doc_id": "tests/test_rcmod.py::TestAxesStyle.test_set_is_alias", "file_path": "tests/test_rcmod.py", "class_name": "TestAxesStyle", "func_name": "test_set_is_alias", "text": "文件路径: tests/test_rcmod.py, 类名: TestAxesStyle\n    def test_set_is_alias(self):\n\n        rcmod.set_theme(context=\"paper\", style=\"white\")\n        params1 = mpl.rcParams.copy()\n        rcmod.reset_orig()\n\n        rcmod.set_theme(context=\"paper\", style=\"white\")\n        params2 = mpl.rcParams.copy()\n\n        self.assert_rc_params_equal(params1, params2)\n\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testaxesstyle", "def", "test_set_is_alias", "self", "rcmod", "set_theme", "context", "paper", "style", "white", "params1", "mpl", "rcparams", "copy", "rcmod", "reset_orig", "rcmod", "set_theme", "context", "paper", "style", "white", "params2", "mpl", "rcparams", "copy", "self", "assert_rc_params_equal", "params1", "params2", "rcmod", "set_theme"], "doc_len": 35}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_default_return", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_default_return", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_default_return(self):\n\n        current = rcmod.plotting_context()\n        self.assert_rc_params(current)\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_default_return", "self", "current", "rcmod", "plotting_context", "self", "assert_rc_params", "current"], "doc_len": 13}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_key_usage", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_key_usage", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_key_usage(self):\n\n        _context_keys = set(rcmod._context_keys)\n        for context in self.contexts:\n            missing = set(rcmod.plotting_context(context)) ^ _context_keys\n            assert not missing\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_key_usage", "self", "_context_keys", "set", "rcmod", "_context_keys", "for", "context", "in", "self", "contexts", "missing", "set", "rcmod", "plotting_context", "context", "_context_keys", "assert", "not", "missing"], "doc_len": 25}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_bad_context", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_bad_context", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_bad_context(self):\n\n        with pytest.raises(ValueError):\n            rcmod.plotting_context(\"i_am_not_a_context\")\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_bad_context", "self", "with", "pytest", "raises", "valueerror", "rcmod", "plotting_context", "i_am_not_a_context"], "doc_len": 14}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_font_scale", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_font_scale", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_font_scale(self):\n\n        notebook_ref = rcmod.plotting_context(\"notebook\")\n        notebook_big = rcmod.plotting_context(\"notebook\", 2)\n\n        font_keys = [\n            \"font.size\",\n            \"axes.labelsize\", \"axes.titlesize\",\n            \"xtick.labelsize\", \"ytick.labelsize\",\n            \"legend.fontsize\", \"legend.title_fontsize\",\n        ]\n\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_font_scale", "self", "notebook_ref", "rcmod", "plotting_context", "notebook", "notebook_big", "rcmod", "plotting_context", "notebook", "2", "font_keys", "font", "size", "axes", "labelsize", "axes", "titlesize", "xtick", "labelsize", "ytick", "labelsize", "legend", "fontsize", "legend", "title_fontsize", "for", "k", "in", "font_keys", "assert", "notebook_ref", "k", "2", "notebook_big", "k"], "doc_len": 41}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_rc_override", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_rc_override", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_rc_override(self):\n\n        key, val = \"grid.linewidth\", 5\n        rc = {key: val, \"foo\": \"bar\"}\n        out = rcmod.plotting_context(\"talk\", rc=rc)\n        assert out[key] == val\n        assert \"foo\" not in out\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_rc_override", "self", "key", "val", "grid", "linewidth", "5", "rc", "key", "val", "foo", "bar", "out", "rcmod", "plotting_context", "talk", "rc", "rc", "assert", "out", "key", "val", "assert", "foo", "not", "in", "out"], "doc_len": 32}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_set_context", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_set_context", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_set_context(self):\n\n        for context in self.contexts:\n\n            context_dict = rcmod.plotting_context(context)\n            rcmod.set_context(context)\n            self.assert_rc_params(context_dict)\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_set_context", "self", "for", "context", "in", "self", "contexts", "context_dict", "rcmod", "plotting_context", "context", "rcmod", "set_context", "context", "self", "assert_rc_params", "context_dict"], "doc_len": 22}
{"doc_id": "tests/test_rcmod.py::TestPlottingContext.test_context_context_manager", "file_path": "tests/test_rcmod.py", "class_name": "TestPlottingContext", "func_name": "test_context_context_manager", "text": "文件路径: tests/test_rcmod.py, 类名: TestPlottingContext\n    def test_context_context_manager(self):\n\n        rcmod.set_context(\"notebook\")\n        orig_params = rcmod.plotting_context()\n        context_params = rcmod.plotting_context(\"paper\")\n\n        with rcmod.plotting_context(\"paper\"):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n\n        @rcmod.plotting_context(\"paper\")\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n", "tokens": ["tests", "test_rcmod", "py", "testplottingcontext", "def", "test_context_context_manager", "self", "rcmod", "set_context", "notebook", "orig_params", "rcmod", "plotting_context", "context_params", "rcmod", "plotting_context", "paper", "with", "rcmod", "plotting_context", "paper", "self", "assert_rc_params", "context_params", "self", "assert_rc_params", "orig_params", "rcmod", "plotting_context", "paper", "def", "func", "self", "assert_rc_params", "context_params", "func", "self", "assert_rc_params", "orig_params"], "doc_len": 39}
{"doc_id": "tests/test_rcmod.py::TestPalette.test_set_palette", "file_path": "tests/test_rcmod.py", "class_name": "TestPalette", "func_name": "test_set_palette", "text": "文件路径: tests/test_rcmod.py, 类名: TestPalette\n    def test_set_palette(self):\n\n        rcmod.set_palette(\"deep\")\n        assert utils.get_color_cycle() == palettes.color_palette(\"deep\", 10)\n\n        rcmod.set_palette(\"pastel6\")\n        assert utils.get_color_cycle() == palettes.color_palette(\"pastel6\", 6)\n\n        rcmod.set_palette(\"dark\", 4)\n        assert utils.get_color_cycle() == palettes.color_palette(\"dark\", 4)\n\n        rcmod.set_palette(\"Set2\", color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette(\"Set2\", 8)\n\n        assert mpl.colors.same_color(\n            mpl.rcParams[\"patch.facecolor\"], palettes.color_palette()[0]\n        )\n", "tokens": ["tests", "test_rcmod", "py", "testpalette", "def", "test_set_palette", "self", "rcmod", "set_palette", "deep", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "deep", "10", "rcmod", "set_palette", "pastel6", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "pastel6", "6", "rcmod", "set_palette", "dark", "4", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "dark", "4", "rcmod", "set_palette", "set2", "color_codes", "true", "assert", "utils", "get_color_cycle", "palettes", "color_palette", "set2", "8", "assert", "mpl", "colors", "same_color", "mpl", "rcparams", "patch", "facecolor", "palettes", "color_palette", "0"], "doc_len": 61}
{"doc_id": "tests/test_rcmod.py::TestFonts.test_set_font", "file_path": "tests/test_rcmod.py", "class_name": "TestFonts", "func_name": "test_set_font", "text": "文件路径: tests/test_rcmod.py, 类名: TestFonts\n    def test_set_font(self):\n\n        rcmod.set_theme(font=\"Verdana\")\n\n        _, ax = plt.subplots()\n        ax.set_xlabel(\"foo\")\n\n        assert ax.xaxis.label.get_fontname() == \"Verdana\"\n\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testfonts", "def", "test_set_font", "self", "rcmod", "set_theme", "font", "verdana", "_", "ax", "plt", "subplots", "ax", "set_xlabel", "foo", "assert", "ax", "xaxis", "label", "get_fontname", "verdana", "rcmod", "set_theme"], "doc_len": 26}
{"doc_id": "tests/test_rcmod.py::TestFonts.test_set_serif_font", "file_path": "tests/test_rcmod.py", "class_name": "TestFonts", "func_name": "test_set_serif_font", "text": "文件路径: tests/test_rcmod.py, 类名: TestFonts\n    def test_set_serif_font(self):\n\n        rcmod.set_theme(font=\"serif\")\n\n        _, ax = plt.subplots()\n        ax.set_xlabel(\"foo\")\n\n        assert ax.xaxis.label.get_fontname() in mpl.rcParams[\"font.serif\"]\n\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testfonts", "def", "test_set_serif_font", "self", "rcmod", "set_theme", "font", "serif", "_", "ax", "plt", "subplots", "ax", "set_xlabel", "foo", "assert", "ax", "xaxis", "label", "get_fontname", "in", "mpl", "rcparams", "font", "serif", "rcmod", "set_theme"], "doc_len": 30}
{"doc_id": "tests/test_rcmod.py::TestFonts.test_different_sans_serif", "file_path": "tests/test_rcmod.py", "class_name": "TestFonts", "func_name": "test_different_sans_serif", "text": "文件路径: tests/test_rcmod.py, 类名: TestFonts\n    def test_different_sans_serif(self):\n\n        rcmod.set_theme()\n        rcmod.set_style(rc={\"font.sans-serif\": [\"Verdana\"]})\n\n        _, ax = plt.subplots()\n        ax.set_xlabel(\"foo\")\n\n        assert ax.xaxis.label.get_fontname() == \"Verdana\"\n\n        rcmod.set_theme()\n", "tokens": ["tests", "test_rcmod", "py", "testfonts", "def", "test_different_sans_serif", "self", "rcmod", "set_theme", "rcmod", "set_style", "rc", "font", "sans", "serif", "verdana", "_", "ax", "plt", "subplots", "ax", "set_xlabel", "foo", "assert", "ax", "xaxis", "label", "get_fontname", "verdana", "rcmod", "set_theme"], "doc_len": 31}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_frame", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_frame", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_frame(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(self.df, x=\"x\", y=\"y\")\n        pdt.assert_series_equal(p.x, self.df.x)\n        pdt.assert_series_equal(p.y, self.df.y)\n        pdt.assert_frame_equal(p.data, self.df)\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_frame", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "self", "df", "x", "x", "y", "y", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "pdt", "assert_series_equal", "p", "y", "self", "df", "y", "pdt", "assert_frame_equal", "p", "data", "self", "df"], "doc_len": 38}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_series", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_series", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_series(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(None, x=self.df.x, y=self.df.y)\n        pdt.assert_series_equal(p.x, self.df.x)\n        pdt.assert_series_equal(p.y, self.df.y)\n        assert p.data is None\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_series", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "none", "x", "self", "df", "x", "y", "self", "df", "y", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "pdt", "assert_series_equal", "p", "y", "self", "df", "y", "assert", "p", "data", "is", "none"], "doc_len": 40}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_array", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_array", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_array(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(None,\n                              x=self.df.x.values,\n                              y=self.df.y.values)\n        npt.assert_array_equal(p.x, self.df.x)\n        npt.assert_array_equal(p.y, self.df.y)\n        assert p.data is None\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_array", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "none", "x", "self", "df", "x", "values", "y", "self", "df", "y", "values", "npt", "assert_array_equal", "p", "x", "self", "df", "x", "npt", "assert_array_equal", "p", "y", "self", "df", "y", "assert", "p", "data", "is", "none"], "doc_len": 42}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_lists", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_lists", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_lists(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(None,\n                              x=self.df.x.values.tolist(),\n                              y=self.df.y.values.tolist())\n        npt.assert_array_equal(p.x, self.df.x)\n        npt.assert_array_equal(p.y, self.df.y)\n        assert p.data is None\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_lists", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "none", "x", "self", "df", "x", "values", "tolist", "y", "self", "df", "y", "values", "tolist", "npt", "assert_array_equal", "p", "x", "self", "df", "x", "npt", "assert_array_equal", "p", "y", "self", "df", "y", "assert", "p", "data", "is", "none"], "doc_len": 44}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_mix", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_mix", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_mix(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(self.df, x=\"x\", y=self.df.y)\n        pdt.assert_series_equal(p.x, self.df.x)\n        pdt.assert_series_equal(p.y, self.df.y)\n        pdt.assert_frame_equal(p.data, self.df)\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_mix", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "self", "df", "x", "x", "y", "self", "df", "y", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "pdt", "assert_series_equal", "p", "y", "self", "df", "y", "pdt", "assert_frame_equal", "p", "data", "self", "df"], "doc_len": 40}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_establish_variables_from_bad", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_establish_variables_from_bad", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_establish_variables_from_bad(self):\n\n        p = lm._LinearPlotter()\n        with pytest.raises(ValueError):\n            p.establish_variables(None, x=\"x\", y=self.df.y)\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_establish_variables_from_bad", "self", "p", "lm", "_linearplotter", "with", "pytest", "raises", "valueerror", "p", "establish_variables", "none", "x", "x", "y", "self", "df", "y"], "doc_len": 23}
{"doc_id": "tests/test_regression.py::TestLinearPlotter.test_dropna", "file_path": "tests/test_regression.py", "class_name": "TestLinearPlotter", "func_name": "test_dropna", "text": "文件路径: tests/test_regression.py, 类名: TestLinearPlotter\n    def test_dropna(self):\n\n        p = lm._LinearPlotter()\n        p.establish_variables(self.df, x=\"x\", y_na=\"y_na\")\n        pdt.assert_series_equal(p.x, self.df.x)\n        pdt.assert_series_equal(p.y_na, self.df.y_na)\n\n        p.dropna(\"x\", \"y_na\")\n        mask = self.df.y_na.notnull()\n        pdt.assert_series_equal(p.x, self.df.x[mask])\n        pdt.assert_series_equal(p.y_na, self.df.y_na[mask])\n", "tokens": ["tests", "test_regression", "py", "testlinearplotter", "def", "test_dropna", "self", "p", "lm", "_linearplotter", "p", "establish_variables", "self", "df", "x", "x", "y_na", "y_na", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "pdt", "assert_series_equal", "p", "y_na", "self", "df", "y_na", "p", "dropna", "x", "y_na", "mask", "self", "df", "y_na", "notnull", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "mask", "pdt", "assert_series_equal", "p", "y_na", "self", "df", "y_na", "mask"], "doc_len": 57}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_variables_from_frame", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_variables_from_frame", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_variables_from_frame(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, units=\"s\")\n\n        pdt.assert_series_equal(p.x, self.df.x)\n        pdt.assert_series_equal(p.y, self.df.y)\n        pdt.assert_series_equal(p.units, self.df.s)\n        pdt.assert_frame_equal(p.data, self.df)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_variables_from_frame", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "units", "s", "pdt", "assert_series_equal", "p", "x", "self", "df", "x", "pdt", "assert_series_equal", "p", "y", "self", "df", "y", "pdt", "assert_series_equal", "p", "units", "self", "df", "s", "pdt", "assert_frame_equal", "p", "data", "self", "df"], "doc_len": 44}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_variables_from_series", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_variables_from_series", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_variables_from_series(self):\n\n        p = lm._RegressionPlotter(self.df.x, self.df.y, units=self.df.s)\n\n        npt.assert_array_equal(p.x, self.df.x)\n        npt.assert_array_equal(p.y, self.df.y)\n        npt.assert_array_equal(p.units, self.df.s)\n        assert p.data is None\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_variables_from_series", "self", "p", "lm", "_regressionplotter", "self", "df", "x", "self", "df", "y", "units", "self", "df", "s", "npt", "assert_array_equal", "p", "x", "self", "df", "x", "npt", "assert_array_equal", "p", "y", "self", "df", "y", "npt", "assert_array_equal", "p", "units", "self", "df", "s", "assert", "p", "data", "is", "none"], "doc_len": 46}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_variables_from_mix", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_variables_from_mix", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_variables_from_mix(self):\n\n        p = lm._RegressionPlotter(\"x\", self.df.y + 1, data=self.df)\n\n        npt.assert_array_equal(p.x, self.df.x)\n        npt.assert_array_equal(p.y, self.df.y + 1)\n        pdt.assert_frame_equal(p.data, self.df)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_variables_from_mix", "self", "p", "lm", "_regressionplotter", "x", "self", "df", "y", "1", "data", "self", "df", "npt", "assert_array_equal", "p", "x", "self", "df", "x", "npt", "assert_array_equal", "p", "y", "self", "df", "y", "1", "pdt", "assert_frame_equal", "p", "data", "self", "df"], "doc_len": 39}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_variables_must_be_1d", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_variables_must_be_1d", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_variables_must_be_1d(self):\n\n        array_2d = np.random.randn(20, 2)\n        array_1d = np.random.randn(20)\n        with pytest.raises(ValueError):\n            lm._RegressionPlotter(array_2d, array_1d)\n        with pytest.raises(ValueError):\n            lm._RegressionPlotter(array_1d, array_2d)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_variables_must_be_1d", "self", "array_2d", "np", "random", "randn", "20", "2", "array_1d", "np", "random", "randn", "20", "with", "pytest", "raises", "valueerror", "lm", "_regressionplotter", "array_2d", "array_1d", "with", "pytest", "raises", "valueerror", "lm", "_regressionplotter", "array_1d", "array_2d"], "doc_len": 34}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_dropna", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_dropna", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_dropna(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y_na\", data=self.df)\n        assert len(p.x) == pd.notnull(self.df.y_na).sum()\n\n        p = lm._RegressionPlotter(\"x\", \"y_na\", data=self.df, dropna=False)\n        assert len(p.x) == len(self.df.y_na)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_dropna", "self", "p", "lm", "_regressionplotter", "x", "y_na", "data", "self", "df", "assert", "len", "p", "x", "pd", "notnull", "self", "df", "y_na", "sum", "p", "lm", "_regressionplotter", "x", "y_na", "data", "self", "df", "dropna", "false", "assert", "len", "p", "x", "len", "self", "df", "y_na"], "doc_len": 43}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_singleton", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_singleton", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_singleton(self, x, y):\n        p = lm._RegressionPlotter(x, y)\n        assert not p.fit_reg\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_singleton", "self", "x", "y", "p", "lm", "_regressionplotter", "x", "y", "assert", "not", "p", "fit_reg"], "doc_len": 18}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_ci", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_ci", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_ci(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, ci=95)\n        assert p.ci == 95\n        assert p.x_ci == 95\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, ci=95, x_ci=68)\n        assert p.ci == 95\n        assert p.x_ci == 68\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, ci=95, x_ci=\"sd\")\n        assert p.ci == 95\n        assert p.x_ci == \"sd\"\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_ci", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "ci", "95", "assert", "p", "ci", "95", "assert", "p", "x_ci", "95", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "ci", "95", "x_ci", "68", "assert", "p", "ci", "95", "assert", "p", "x_ci", "68", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "ci", "95", "x_ci", "sd", "assert", "p", "ci", "95", "assert", "p", "x_ci", "sd"], "doc_len": 65}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_fast_regression", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_fast_regression", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_fast_regression(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, n_boot=self.n_boot)\n\n        # Fit with the \"fast\" function, which just does linear algebra\n        yhat_fast, _ = p.fit_fast(self.grid)\n\n        # Fit using the statsmodels function with an OLS model\n        yhat_smod, _ = p.fit_statsmodels(self.grid, smlm.OLS)\n\n        # Compare the vector of y_hat values\n        npt.assert_array_almost_equal(yhat_fast, yhat_smod)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_fast_regression", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "fit", "with", "the", "fast", "function", "which", "just", "does", "linear", "algebra", "yhat_fast", "_", "p", "fit_fast", "self", "grid", "fit", "using", "the", "statsmodels", "function", "with", "an", "ols", "model", "yhat_smod", "_", "p", "fit_statsmodels", "self", "grid", "smlm", "ols", "compare", "the", "vector", "of", "y_hat", "values", "npt", "assert_array_almost_equal", "yhat_fast", "yhat_smod"], "doc_len": 61}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regress_poly", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regress_poly", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regress_poly(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, n_boot=self.n_boot)\n\n        # Fit an first-order polynomial\n        yhat_poly, _ = p.fit_poly(self.grid, 1)\n\n        # Fit using the statsmodels function with an OLS model\n        yhat_smod, _ = p.fit_statsmodels(self.grid, smlm.OLS)\n\n        # Compare the vector of y_hat values\n        npt.assert_array_almost_equal(yhat_poly, yhat_smod)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regress_poly", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "fit", "an", "first", "order", "polynomial", "yhat_poly", "_", "p", "fit_poly", "self", "grid", "1", "fit", "using", "the", "statsmodels", "function", "with", "an", "ols", "model", "yhat_smod", "_", "p", "fit_statsmodels", "self", "grid", "smlm", "ols", "compare", "the", "vector", "of", "y_hat", "values", "npt", "assert_array_almost_equal", "yhat_poly", "yhat_smod"], "doc_len": 57}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regress_logx", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regress_logx", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regress_logx(self):\n\n        x = np.arange(1, 10)\n        y = np.arange(1, 10)\n        grid = np.linspace(1, 10, 100)\n        p = lm._RegressionPlotter(x, y, n_boot=self.n_boot)\n\n        yhat_lin, _ = p.fit_fast(grid)\n        yhat_log, _ = p.fit_logx(grid)\n\n        assert yhat_lin[0] > yhat_log[0]\n        assert yhat_log[20] > yhat_lin[20]\n        assert yhat_lin[90] > yhat_log[90]\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regress_logx", "self", "x", "np", "arange", "1", "10", "y", "np", "arange", "1", "10", "grid", "np", "linspace", "1", "10", "100", "p", "lm", "_regressionplotter", "x", "y", "n_boot", "self", "n_boot", "yhat_lin", "_", "p", "fit_fast", "grid", "yhat_log", "_", "p", "fit_logx", "grid", "assert", "yhat_lin", "0", "yhat_log", "0", "assert", "yhat_log", "20", "yhat_lin", "20", "assert", "yhat_lin", "90", "yhat_log", "90"], "doc_len": 56}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regress_n_boot", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regress_n_boot", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regress_n_boot(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, n_boot=self.n_boot)\n\n        # Fast (linear algebra) version\n        _, boots_fast = p.fit_fast(self.grid)\n        npt.assert_equal(boots_fast.shape, (self.n_boot, self.grid.size))\n\n        # Slower (np.polyfit) version\n        _, boots_poly = p.fit_poly(self.grid, 1)\n        npt.assert_equal(boots_poly.shape, (self.n_boot, self.grid.size))\n\n        # Slowest (statsmodels) version\n        _, boots_smod = p.fit_statsmodels(self.grid, smlm.OLS)\n        npt.assert_equal(boots_smod.shape, (self.n_boot, self.grid.size))\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regress_n_boot", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "fast", "linear", "algebra", "version", "_", "boots_fast", "p", "fit_fast", "self", "grid", "npt", "assert_equal", "boots_fast", "shape", "self", "n_boot", "self", "grid", "size", "slower", "np", "polyfit", "version", "_", "boots_poly", "p", "fit_poly", "self", "grid", "1", "npt", "assert_equal", "boots_poly", "shape", "self", "n_boot", "self", "grid", "size", "slowest", "statsmodels", "version", "_", "boots_smod", "p", "fit_statsmodels", "self", "grid", "smlm", "ols", "npt", "assert_equal", "boots_smod", "shape", "self", "n_boot", "self", "grid", "size"], "doc_len": 77}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regress_without_bootstrap", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regress_without_bootstrap", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regress_without_bootstrap(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                  n_boot=self.n_boot, ci=None)\n\n        # Fast (linear algebra) version\n        _, boots_fast = p.fit_fast(self.grid)\n        assert boots_fast is None\n\n        # Slower (np.polyfit) version\n        _, boots_poly = p.fit_poly(self.grid, 1)\n        assert boots_poly is None\n\n        # Slowest (statsmodels) version\n        _, boots_smod = p.fit_statsmodels(self.grid, smlm.OLS)\n        assert boots_smod is None\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regress_without_bootstrap", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "ci", "none", "fast", "linear", "algebra", "version", "_", "boots_fast", "p", "fit_fast", "self", "grid", "assert", "boots_fast", "is", "none", "slower", "np", "polyfit", "version", "_", "boots_poly", "p", "fit_poly", "self", "grid", "1", "assert", "boots_poly", "is", "none", "slowest", "statsmodels", "version", "_", "boots_smod", "p", "fit_statsmodels", "self", "grid", "smlm", "ols", "assert", "boots_smod", "is", "none"], "doc_len": 64}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regress_bootstrap_seed", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regress_bootstrap_seed", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regress_bootstrap_seed(self):\n\n        seed = 200\n        p1 = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                   n_boot=self.n_boot, seed=seed)\n        p2 = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                   n_boot=self.n_boot, seed=seed)\n\n        _, boots1 = p1.fit_fast(self.grid)\n        _, boots2 = p2.fit_fast(self.grid)\n        npt.assert_array_equal(boots1, boots2)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regress_bootstrap_seed", "self", "seed", "200", "p1", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "seed", "seed", "p2", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "seed", "seed", "_", "boots1", "p1", "fit_fast", "self", "grid", "_", "boots2", "p2", "fit_fast", "self", "grid", "npt", "assert_array_equal", "boots1", "boots2"], "doc_len": 51}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_numeric_bins", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_numeric_bins", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_numeric_bins(self):\n\n        p = lm._RegressionPlotter(self.df.x, self.df.y)\n        x_binned, bins = p.bin_predictor(self.bins_numeric)\n        npt.assert_equal(len(bins), self.bins_numeric)\n        npt.assert_array_equal(np.unique(x_binned), bins)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_numeric_bins", "self", "p", "lm", "_regressionplotter", "self", "df", "x", "self", "df", "y", "x_binned", "bins", "p", "bin_predictor", "self", "bins_numeric", "npt", "assert_equal", "len", "bins", "self", "bins_numeric", "npt", "assert_array_equal", "np", "unique", "x_binned", "bins"], "doc_len": 34}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_provided_bins", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_provided_bins", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_provided_bins(self):\n\n        p = lm._RegressionPlotter(self.df.x, self.df.y)\n        x_binned, bins = p.bin_predictor(self.bins_given)\n        npt.assert_array_equal(np.unique(x_binned), self.bins_given)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_provided_bins", "self", "p", "lm", "_regressionplotter", "self", "df", "x", "self", "df", "y", "x_binned", "bins", "p", "bin_predictor", "self", "bins_given", "npt", "assert_array_equal", "np", "unique", "x_binned", "self", "bins_given"], "doc_len": 29}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_bin_results", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_bin_results", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_bin_results(self):\n\n        p = lm._RegressionPlotter(self.df.x, self.df.y)\n        x_binned, bins = p.bin_predictor(self.bins_given)\n        assert self.df.x[x_binned == 0].min() > self.df.x[x_binned == -1].max()\n        assert self.df.x[x_binned == 1].min() > self.df.x[x_binned == 0].max()\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_bin_results", "self", "p", "lm", "_regressionplotter", "self", "df", "x", "self", "df", "y", "x_binned", "bins", "p", "bin_predictor", "self", "bins_given", "assert", "self", "df", "x", "x_binned", "0", "min", "self", "df", "x", "x_binned", "1", "max", "assert", "self", "df", "x", "x_binned", "1", "min", "self", "df", "x", "x_binned", "0", "max"], "doc_len": 48}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_scatter_data", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_scatter_data", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_scatter_data(self):\n\n        p = lm._RegressionPlotter(self.df.x, self.df.y)\n        x, y = p.scatter_data\n        npt.assert_array_equal(x, self.df.x)\n        npt.assert_array_equal(y, self.df.y)\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y)\n        x, y = p.scatter_data\n        npt.assert_array_equal(x, self.df.d)\n        npt.assert_array_equal(y, self.df.y)\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y, x_jitter=.1)\n        x, y = p.scatter_data\n        assert (x != self.df.d).any()\n        npt.assert_array_less(np.abs(self.df.d - x), np.repeat(.1, len(x)))\n        npt.assert_array_equal(y, self.df.y)\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y, y_jitter=.05)\n        x, y = p.scatter_data\n        npt.assert_array_equal(x, self.df.d)\n        npt.assert_array_less(np.abs(self.df.y - y), np.repeat(.1, len(y)))\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_scatter_data", "self", "p", "lm", "_regressionplotter", "self", "df", "x", "self", "df", "y", "x", "y", "p", "scatter_data", "npt", "assert_array_equal", "x", "self", "df", "x", "npt", "assert_array_equal", "y", "self", "df", "y", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x", "y", "p", "scatter_data", "npt", "assert_array_equal", "x", "self", "df", "d", "npt", "assert_array_equal", "y", "self", "df", "y", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x_jitter", "1", "x", "y", "p", "scatter_data", "assert", "x", "self", "df", "d", "any", "npt", "assert_array_less", "np", "abs", "self", "df", "d", "x", "np", "repeat", "1", "len", "x", "npt", "assert_array_equal", "y", "self", "df", "y", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "y_jitter", "05", "x", "y", "p", "scatter_data", "npt", "assert_array_equal", "x", "self", "df", "d", "npt", "assert_array_less", "np", "abs", "self", "df", "y", "y", "np", "repeat", "1", "len", "y"], "doc_len": 131}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_estimate_data", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_estimate_data", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_estimate_data(self):\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y, x_estimator=np.mean)\n\n        x, y, ci = p.estimate_data\n\n        npt.assert_array_equal(x, np.sort(np.unique(self.df.d)))\n        npt.assert_array_almost_equal(y, self.df.groupby(\"d\").y.mean())\n        npt.assert_array_less(np.array(ci)[:, 0], y)\n        npt.assert_array_less(y, np.array(ci)[:, 1])\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_estimate_data", "self", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x_estimator", "np", "mean", "x", "y", "ci", "p", "estimate_data", "npt", "assert_array_equal", "x", "np", "sort", "np", "unique", "self", "df", "d", "npt", "assert_array_almost_equal", "y", "self", "df", "groupby", "d", "y", "mean", "npt", "assert_array_less", "np", "array", "ci", "0", "y", "npt", "assert_array_less", "y", "np", "array", "ci", "1"], "doc_len": 57}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_estimate_cis", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_estimate_cis", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_estimate_cis(self):\n\n        seed = 123\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y,\n                                  x_estimator=np.mean, ci=95, seed=seed)\n        _, _, ci_big = p.estimate_data\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y,\n                                  x_estimator=np.mean, ci=50, seed=seed)\n        _, _, ci_wee = p.estimate_data\n        npt.assert_array_less(np.diff(ci_wee), np.diff(ci_big))\n\n        p = lm._RegressionPlotter(self.df.d, self.df.y,\n                                  x_estimator=np.mean, ci=None)\n        _, _, ci_nil = p.estimate_data\n        npt.assert_array_equal(ci_nil, [None] * len(ci_nil))\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_estimate_cis", "self", "seed", "123", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x_estimator", "np", "mean", "ci", "95", "seed", "seed", "_", "_", "ci_big", "p", "estimate_data", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x_estimator", "np", "mean", "ci", "50", "seed", "seed", "_", "_", "ci_wee", "p", "estimate_data", "npt", "assert_array_less", "np", "diff", "ci_wee", "np", "diff", "ci_big", "p", "lm", "_regressionplotter", "self", "df", "d", "self", "df", "y", "x_estimator", "np", "mean", "ci", "none", "_", "_", "ci_nil", "p", "estimate_data", "npt", "assert_array_equal", "ci_nil", "none", "len", "ci_nil"], "doc_len": 84}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_estimate_units", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_estimate_units", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_estimate_units(self):\n\n        # Seed the RNG locally\n        seed = 345\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                  units=\"s\", seed=seed, x_bins=3)\n        _, _, ci_big = p.estimate_data\n        ci_big = np.diff(ci_big, axis=1)\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, seed=seed, x_bins=3)\n        _, _, ci_wee = p.estimate_data\n        ci_wee = np.diff(ci_wee, axis=1)\n\n        npt.assert_array_less(ci_wee, ci_big)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_estimate_units", "self", "seed", "the", "rng", "locally", "seed", "345", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "units", "s", "seed", "seed", "x_bins", "3", "_", "_", "ci_big", "p", "estimate_data", "ci_big", "np", "diff", "ci_big", "axis", "1", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "seed", "seed", "x_bins", "3", "_", "_", "ci_wee", "p", "estimate_data", "ci_wee", "np", "diff", "ci_wee", "axis", "1", "npt", "assert_array_less", "ci_wee", "ci_big"], "doc_len": 65}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_partial", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_partial", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_partial(self):\n\n        x = self.rs.randn(100)\n        y = x + self.rs.randn(100)\n        z = x + self.rs.randn(100)\n\n        p = lm._RegressionPlotter(y, z)\n        _, r_orig = np.corrcoef(p.x, p.y)[0]\n\n        p = lm._RegressionPlotter(y, z, y_partial=x)\n        _, r_semipartial = np.corrcoef(p.x, p.y)[0]\n        assert r_semipartial < r_orig\n\n        p = lm._RegressionPlotter(y, z, x_partial=x, y_partial=x)\n        _, r_partial = np.corrcoef(p.x, p.y)[0]\n        assert r_partial < r_orig\n\n        x = pd.Series(x)\n        y = pd.Series(y)\n        p = lm._RegressionPlotter(y, z, x_partial=x, y_partial=x)\n        _, r_partial = np.corrcoef(p.x, p.y)[0]\n        assert r_partial < r_orig\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_partial", "self", "x", "self", "rs", "randn", "100", "y", "x", "self", "rs", "randn", "100", "z", "x", "self", "rs", "randn", "100", "p", "lm", "_regressionplotter", "y", "z", "_", "r_orig", "np", "corrcoef", "p", "x", "p", "y", "0", "p", "lm", "_regressionplotter", "y", "z", "y_partial", "x", "_", "r_semipartial", "np", "corrcoef", "p", "x", "p", "y", "0", "assert", "r_semipartial", "r_orig", "p", "lm", "_regressionplotter", "y", "z", "x_partial", "x", "y_partial", "x", "_", "r_partial", "np", "corrcoef", "p", "x", "p", "y", "0", "assert", "r_partial", "r_orig", "x", "pd", "series", "x", "y", "pd", "series", "y", "p", "lm", "_regressionplotter", "y", "z", "x_partial", "x", "y_partial", "x", "_", "r_partial", "np", "corrcoef", "p", "x", "p", "y", "0", "assert", "r_partial", "r_orig"], "doc_len": 107}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_logistic_regression", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_logistic_regression", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_logistic_regression(self):\n\n        p = lm._RegressionPlotter(\"x\", \"c\", data=self.df,\n                                  logistic=True, n_boot=self.n_boot)\n        _, yhat, _ = p.fit_regression(x_range=(-3, 3))\n        npt.assert_array_less(yhat, 1)\n        npt.assert_array_less(0, yhat)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_logistic_regression", "self", "p", "lm", "_regressionplotter", "x", "c", "data", "self", "df", "logistic", "true", "n_boot", "self", "n_boot", "_", "yhat", "_", "p", "fit_regression", "x_range", "3", "3", "npt", "assert_array_less", "yhat", "1", "npt", "assert_array_less", "0", "yhat"], "doc_len": 36}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_logistic_perfect_separation", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_logistic_perfect_separation", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_logistic_perfect_separation(self):\n\n        y = self.df.x > self.df.x.mean()\n        p = lm._RegressionPlotter(\"x\", y, data=self.df,\n                                  logistic=True, n_boot=10)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", RuntimeWarning)\n            _, yhat, _ = p.fit_regression(x_range=(-3, 3))\n        assert np.isnan(yhat).all()\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_logistic_perfect_separation", "self", "y", "self", "df", "x", "self", "df", "x", "mean", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "logistic", "true", "n_boot", "10", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "ignore", "runtimewarning", "_", "yhat", "_", "p", "fit_regression", "x_range", "3", "3", "assert", "np", "isnan", "yhat", "all"], "doc_len": 47}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_robust_regression", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_robust_regression", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_robust_regression(self):\n\n        p_ols = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                      n_boot=self.n_boot)\n        _, ols_yhat, _ = p_ols.fit_regression(x_range=(-3, 3))\n\n        p_robust = lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                         robust=True, n_boot=self.n_boot)\n        _, robust_yhat, _ = p_robust.fit_regression(x_range=(-3, 3))\n\n        assert len(ols_yhat) == len(robust_yhat)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_robust_regression", "self", "p_ols", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "n_boot", "self", "n_boot", "_", "ols_yhat", "_", "p_ols", "fit_regression", "x_range", "3", "3", "p_robust", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "robust", "true", "n_boot", "self", "n_boot", "_", "robust_yhat", "_", "p_robust", "fit_regression", "x_range", "3", "3", "assert", "len", "ols_yhat", "len", "robust_yhat"], "doc_len": 52}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_lowess_regression", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_lowess_regression", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_lowess_regression(self):\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, lowess=True)\n        grid, yhat, err_bands = p.fit_regression(x_range=(-3, 3))\n\n        assert len(grid) == len(yhat)\n        assert err_bands is None\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_lowess_regression", "self", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "lowess", "true", "grid", "yhat", "err_bands", "p", "fit_regression", "x_range", "3", "3", "assert", "len", "grid", "len", "yhat", "assert", "err_bands", "is", "none"], "doc_len": 34}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regression_options", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regression_options", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regression_options(self):\n\n        with pytest.raises(ValueError):\n            lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                  lowess=True, order=2)\n\n        with pytest.raises(ValueError):\n            lm._RegressionPlotter(\"x\", \"y\", data=self.df,\n                                  lowess=True, logistic=True)\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regression_options", "self", "with", "pytest", "raises", "valueerror", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "lowess", "true", "order", "2", "with", "pytest", "raises", "valueerror", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "lowess", "true", "logistic", "true"], "doc_len": 37}
{"doc_id": "tests/test_regression.py::TestRegressionPlotter.test_regression_limits", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlotter", "func_name": "test_regression_limits", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlotter\n    def test_regression_limits(self):\n\n        f, ax = plt.subplots()\n        ax.scatter(self.df.x, self.df.y)\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df)\n        grid, _, _ = p.fit_regression(ax)\n        xlim = ax.get_xlim()\n        assert grid.min() == xlim[0]\n        assert grid.max() == xlim[1]\n\n        p = lm._RegressionPlotter(\"x\", \"y\", data=self.df, truncate=True)\n        grid, _, _ = p.fit_regression()\n        assert grid.min() == self.df.x.min()\n        assert grid.max() == self.df.x.max()\n", "tokens": ["tests", "test_regression", "py", "testregressionplotter", "def", "test_regression_limits", "self", "f", "ax", "plt", "subplots", "ax", "scatter", "self", "df", "x", "self", "df", "y", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "grid", "_", "_", "p", "fit_regression", "ax", "xlim", "ax", "get_xlim", "assert", "grid", "min", "xlim", "0", "assert", "grid", "max", "xlim", "1", "p", "lm", "_regressionplotter", "x", "y", "data", "self", "df", "truncate", "true", "grid", "_", "_", "p", "fit_regression", "assert", "grid", "min", "self", "df", "x", "min", "assert", "grid", "max", "self", "df", "x", "max"], "doc_len": 75}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_regplot_basic", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_regplot_basic", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_regplot_basic(self):\n\n        f, ax = plt.subplots()\n        lm.regplot(x=\"x\", y=\"y\", data=self.df)\n        assert len(ax.lines) == 1\n        assert len(ax.collections) == 2\n\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, self.df.x)\n        npt.assert_array_equal(y, self.df.y)\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_regplot_basic", "self", "f", "ax", "plt", "subplots", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "2", "x", "y", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x", "self", "df", "x", "npt", "assert_array_equal", "y", "self", "df", "y"], "doc_len": 49}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_regplot_selective", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_regplot_selective", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_regplot_selective(self):\n\n        f, ax = plt.subplots()\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df, scatter=False, ax=ax)\n        assert len(ax.lines) == 1\n        assert len(ax.collections) == 1\n        ax.clear()\n\n        f, ax = plt.subplots()\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df, fit_reg=False)\n        assert len(ax.lines) == 0\n        assert len(ax.collections) == 1\n        ax.clear()\n\n        f, ax = plt.subplots()\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df, ci=None)\n        assert len(ax.lines) == 1\n        assert len(ax.collections) == 1\n        ax.clear()\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_regplot_selective", "self", "f", "ax", "plt", "subplots", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "scatter", "false", "ax", "ax", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "1", "ax", "clear", "f", "ax", "plt", "subplots", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "fit_reg", "false", "assert", "len", "ax", "lines", "0", "assert", "len", "ax", "collections", "1", "ax", "clear", "f", "ax", "plt", "subplots", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "ci", "none", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "1", "ax", "clear"], "doc_len": 93}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_regplot_scatter_kws_alpha", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_regplot_scatter_kws_alpha", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_regplot_scatter_kws_alpha(self):\n\n        f, ax = plt.subplots()\n        color = np.array([[0.3, 0.8, 0.5, 0.5]])\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df,\n                        scatter_kws={'color': color})\n        assert ax.collections[0]._alpha is None\n        assert ax.collections[0]._facecolors[0, 3] == 0.5\n\n        f, ax = plt.subplots()\n        color = np.array([[0.3, 0.8, 0.5]])\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df,\n                        scatter_kws={'color': color})\n        assert ax.collections[0]._alpha == 0.8\n\n        f, ax = plt.subplots()\n        color = np.array([[0.3, 0.8, 0.5]])\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df,\n                        scatter_kws={'color': color, 'alpha': 0.4})\n        assert ax.collections[0]._alpha == 0.4\n\n        f, ax = plt.subplots()\n        color = 'r'\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df,\n                        scatter_kws={'color': color})\n        assert ax.collections[0]._alpha == 0.8\n\n        f, ax = plt.subplots()\n        alpha = .3\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df,\n                        x_bins=5, fit_reg=False,\n                        scatter_kws={\"alpha\": alpha})\n        for line in ax.lines:\n            assert line.get_alpha() == alpha\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_regplot_scatter_kws_alpha", "self", "f", "ax", "plt", "subplots", "color", "np", "array", "0", "3", "0", "8", "0", "5", "0", "5", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "scatter_kws", "color", "color", "assert", "ax", "collections", "0", "_alpha", "is", "none", "assert", "ax", "collections", "0", "_facecolors", "0", "3", "0", "5", "f", "ax", "plt", "subplots", "color", "np", "array", "0", "3", "0", "8", "0", "5", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "scatter_kws", "color", "color", "assert", "ax", "collections", "0", "_alpha", "0", "8", "f", "ax", "plt", "subplots", "color", "np", "array", "0", "3", "0", "8", "0", "5", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "scatter_kws", "color", "color", "alpha", "0", "4", "assert", "ax", "collections", "0", "_alpha", "0", "4", "f", "ax", "plt", "subplots", "color", "r", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "scatter_kws", "color", "color", "assert", "ax", "collections", "0", "_alpha", "0", "8", "f", "ax", "plt", "subplots", "alpha", "3", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "x_bins", "5", "fit_reg", "false", "scatter_kws", "alpha", "alpha", "for", "line", "in", "ax", "lines", "assert", "line", "get_alpha", "alpha"], "doc_len": 178}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_regplot_binned", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_regplot_binned", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_regplot_binned(self):\n\n        ax = lm.regplot(x=\"x\", y=\"y\", data=self.df, x_bins=5)\n        assert len(ax.lines) == 6\n        assert len(ax.collections) == 2\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_regplot_binned", "self", "ax", "lm", "regplot", "x", "x", "y", "y", "data", "self", "df", "x_bins", "5", "assert", "len", "ax", "lines", "6", "assert", "len", "ax", "collections", "2"], "doc_len": 29}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_no_data", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_no_data", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_no_data(self):\n\n        with pytest.raises(TypeError):\n            # keyword argument `data` is required\n            lm.lmplot(x=\"x\", y=\"y\")\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_no_data", "self", "with", "pytest", "raises", "typeerror", "keyword", "argument", "data", "is", "required", "lm", "lmplot", "x", "x", "y", "y"], "doc_len": 22}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_basic", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_basic", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_basic(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df)\n        ax = g.axes[0, 0]\n        assert len(ax.lines) == 1\n        assert len(ax.collections) == 2\n\n        x, y = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x, self.df.x)\n        npt.assert_array_equal(y, self.df.y)\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_basic", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "ax", "g", "axes", "0", "0", "assert", "len", "ax", "lines", "1", "assert", "len", "ax", "collections", "2", "x", "y", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x", "self", "df", "x", "npt", "assert_array_equal", "y", "self", "df", "y"], "doc_len": 51}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_hue", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_hue", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_hue(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\")\n        ax = g.axes[0, 0]\n\n        assert len(ax.lines) == 2\n        assert len(ax.collections) == 4\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_hue", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "ax", "g", "axes", "0", "0", "assert", "len", "ax", "lines", "2", "assert", "len", "ax", "collections", "4"], "doc_len": 34}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_markers", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_markers", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_markers(self):\n\n        g1 = lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\", markers=\"s\")\n        assert g1.hue_kws == {\"marker\": [\"s\", \"s\"]}\n\n        g2 = lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\", markers=[\"o\", \"s\"])\n        assert g2.hue_kws == {\"marker\": [\"o\", \"s\"]}\n\n        with pytest.raises(ValueError):\n            lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\",\n                      markers=[\"o\", \"s\", \"d\"])\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_markers", "self", "g1", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "markers", "s", "assert", "g1", "hue_kws", "marker", "s", "s", "g2", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "markers", "o", "s", "assert", "g2", "hue_kws", "marker", "o", "s", "with", "pytest", "raises", "valueerror", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "markers", "o", "s", "d"], "doc_len": 67}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_marker_linewidths", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_marker_linewidths", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_marker_linewidths(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\",\n                      fit_reg=False, markers=[\"o\", \"+\"])\n        c = g.axes[0, 0].collections\n        assert c[1].get_linewidths()[0] == mpl.rcParams[\"lines.linewidth\"]\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_marker_linewidths", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "fit_reg", "false", "markers", "o", "c", "g", "axes", "0", "0", "collections", "assert", "c", "1", "get_linewidths", "0", "mpl", "rcparams", "lines", "linewidth"], "doc_len": 38}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_facets", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_facets", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_facets(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, row=\"g\", col=\"h\")\n        assert g.axes.shape == (3, 2)\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, col=\"u\", col_wrap=4)\n        assert g.axes.shape == (6,)\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, hue=\"h\", col=\"u\")\n        assert g.axes.shape == (1, 6)\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_facets", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "row", "g", "col", "h", "assert", "g", "axes", "shape", "3", "2", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "col", "u", "col_wrap", "4", "assert", "g", "axes", "shape", "6", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "hue", "h", "col", "u", "assert", "g", "axes", "shape", "1", "6"], "doc_len": 66}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_hue_col_nolegend", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_hue_col_nolegend", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_hue_col_nolegend(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", data=self.df, col=\"h\", hue=\"h\")\n        assert g._legend is None\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_hue_col_nolegend", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "data", "self", "df", "col", "h", "hue", "h", "assert", "g", "_legend", "is", "none"], "doc_len": 26}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_scatter_kws", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_scatter_kws", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_scatter_kws(self):\n\n        g = lm.lmplot(x=\"x\", y=\"y\", hue=\"h\", data=self.df, ci=None)\n        red_scatter, blue_scatter = g.axes[0, 0].collections\n\n        red, blue = color_palette(n_colors=2)\n        npt.assert_array_equal(red, red_scatter.get_facecolors()[0, :3])\n        npt.assert_array_equal(blue, blue_scatter.get_facecolors()[0, :3])\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_scatter_kws", "self", "g", "lm", "lmplot", "x", "x", "y", "y", "hue", "h", "data", "self", "df", "ci", "none", "red_scatter", "blue_scatter", "g", "axes", "0", "0", "collections", "red", "blue", "color_palette", "n_colors", "2", "npt", "assert_array_equal", "red", "red_scatter", "get_facecolors", "0", "3", "npt", "assert_array_equal", "blue", "blue_scatter", "get_facecolors", "0", "3"], "doc_len": 47}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_facet_truncate", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_facet_truncate", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_facet_truncate(self, sharex):\n\n        g = lm.lmplot(\n            data=self.df, x=\"x\", y=\"y\", hue=\"g\", col=\"h\",\n            truncate=False, facet_kws=dict(sharex=sharex),\n        )\n\n        for ax in g.axes.flat:\n            for line in ax.lines:\n                xdata = line.get_xdata()\n                assert ax.get_xlim() == tuple(xdata[[0, -1]])\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_facet_truncate", "self", "sharex", "g", "lm", "lmplot", "data", "self", "df", "x", "x", "y", "y", "hue", "g", "col", "h", "truncate", "false", "facet_kws", "dict", "sharex", "sharex", "for", "ax", "in", "g", "axes", "flat", "for", "line", "in", "ax", "lines", "xdata", "line", "get_xdata", "assert", "ax", "get_xlim", "tuple", "xdata", "0", "1"], "doc_len": 49}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_sharey", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_sharey", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_sharey(self):\n\n        df = pd.DataFrame(dict(\n            x=[0, 1, 2, 0, 1, 2],\n            y=[1, -1, 0, -100, 200, 0],\n            z=[\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"],\n        ))\n\n        with pytest.warns(UserWarning):\n            g = lm.lmplot(data=df, x=\"x\", y=\"y\", col=\"z\", sharey=False)\n        ax1, ax2 = g.axes.flat\n        assert ax1.get_ylim()[0] > ax2.get_ylim()[0]\n        assert ax1.get_ylim()[1] < ax2.get_ylim()[1]\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_sharey", "self", "df", "pd", "dataframe", "dict", "x", "0", "1", "2", "0", "1", "2", "y", "1", "1", "0", "100", "200", "0", "z", "a", "a", "a", "b", "b", "b", "with", "pytest", "warns", "userwarning", "g", "lm", "lmplot", "data", "df", "x", "x", "y", "y", "col", "z", "sharey", "false", "ax1", "ax2", "g", "axes", "flat", "assert", "ax1", "get_ylim", "0", "ax2", "get_ylim", "0", "assert", "ax1", "get_ylim", "1", "ax2", "get_ylim", "1"], "doc_len": 68}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_lmplot_facet_kws", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_lmplot_facet_kws", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_lmplot_facet_kws(self):\n\n        xlim = -4, 20\n        g = lm.lmplot(\n            data=self.df, x=\"x\", y=\"y\", col=\"h\", facet_kws={\"xlim\": xlim}\n        )\n        for ax in g.axes.flat:\n            assert ax.get_xlim() == xlim\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_lmplot_facet_kws", "self", "xlim", "4", "20", "g", "lm", "lmplot", "data", "self", "df", "x", "x", "y", "y", "col", "h", "facet_kws", "xlim", "xlim", "for", "ax", "in", "g", "axes", "flat", "assert", "ax", "get_xlim", "xlim"], "doc_len": 35}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_residplot", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_residplot", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_residplot(self):\n\n        x, y = self.df.x, self.df.y\n        ax = lm.residplot(x=x, y=y)\n\n        resid = y - np.polyval(np.polyfit(x, y, 1), x)\n        x_plot, y_plot = ax.collections[0].get_offsets().T\n\n        npt.assert_array_equal(x, x_plot)\n        npt.assert_array_almost_equal(resid, y_plot)\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_residplot", "self", "x", "y", "self", "df", "x", "self", "df", "y", "ax", "lm", "residplot", "x", "x", "y", "y", "resid", "y", "np", "polyval", "np", "polyfit", "x", "y", "1", "x", "x_plot", "y_plot", "ax", "collections", "0", "get_offsets", "t", "npt", "assert_array_equal", "x", "x_plot", "npt", "assert_array_almost_equal", "resid", "y_plot"], "doc_len": 47}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_residplot_lowess", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_residplot_lowess", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_residplot_lowess(self):\n\n        ax = lm.residplot(x=\"x\", y=\"y\", data=self.df, lowess=True)\n        assert len(ax.lines) == 2\n\n        x, y = ax.lines[1].get_xydata().T\n        npt.assert_array_equal(x, np.sort(self.df.x))\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_residplot_lowess", "self", "ax", "lm", "residplot", "x", "x", "y", "y", "data", "self", "df", "lowess", "true", "assert", "len", "ax", "lines", "2", "x", "y", "ax", "lines", "1", "get_xydata", "t", "npt", "assert_array_equal", "x", "np", "sort", "self", "df", "x"], "doc_len": 39}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_three_point_colors", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_three_point_colors", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_three_point_colors(self):\n\n        x, y = np.random.randn(2, 3)\n        ax = lm.regplot(x=x, y=y, color=(1, 0, 0))\n        color = ax.collections[0].get_facecolors()\n        npt.assert_almost_equal(color[0, :3],\n                                (1, 0, 0))\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_three_point_colors", "self", "x", "y", "np", "random", "randn", "2", "3", "ax", "lm", "regplot", "x", "x", "y", "y", "color", "1", "0", "0", "color", "ax", "collections", "0", "get_facecolors", "npt", "assert_almost_equal", "color", "0", "3", "1", "0", "0"], "doc_len": 38}
{"doc_id": "tests/test_regression.py::TestRegressionPlots.test_regplot_xlim", "file_path": "tests/test_regression.py", "class_name": "TestRegressionPlots", "func_name": "test_regplot_xlim", "text": "文件路径: tests/test_regression.py, 类名: TestRegressionPlots\n    def test_regplot_xlim(self):\n\n        f, ax = plt.subplots()\n        x, y1, y2 = np.random.randn(3, 50)\n        lm.regplot(x=x, y=y1, truncate=False)\n        lm.regplot(x=x, y=y2, truncate=False)\n        line1, line2 = ax.lines\n        assert np.array_equal(line1.get_xdata(), line2.get_xdata())\n", "tokens": ["tests", "test_regression", "py", "testregressionplots", "def", "test_regplot_xlim", "self", "f", "ax", "plt", "subplots", "x", "y1", "y2", "np", "random", "randn", "3", "50", "lm", "regplot", "x", "x", "y", "y1", "truncate", "false", "lm", "regplot", "x", "x", "y", "y2", "truncate", "false", "line1", "line2", "ax", "lines", "assert", "np", "array_equal", "line1", "get_xdata", "line2", "get_xdata"], "doc_len": 46}
{"doc_id": "tests/test_relational.py::long_semantics", "file_path": "tests/test_relational.py", "class_name": null, "func_name": "long_semantics", "text": "文件路径: tests/test_relational.py\ndef long_semantics(request):\n    return request.param\n", "tokens": ["tests", "test_relational", "py", "def", "long_semantics", "request", "return", "request", "param"], "doc_len": 9}
{"doc_id": "tests/test_relational.py::Helpers.scatter_rgbs", "file_path": "tests/test_relational.py", "class_name": "Helpers", "func_name": "scatter_rgbs", "text": "文件路径: tests/test_relational.py, 类名: Helpers\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n", "tokens": ["tests", "test_relational", "py", "helpers", "def", "scatter_rgbs", "self", "collections", "rgbs", "for", "col", "in", "collections", "rgb", "tuple", "col", "get_facecolor", "squeeze", "3", "rgbs", "append", "rgb", "return", "rgbs"], "doc_len": 24}
{"doc_id": "tests/test_relational.py::Helpers.paths_equal", "file_path": "tests/test_relational.py", "class_name": "Helpers", "func_name": "paths_equal", "text": "文件路径: tests/test_relational.py, 类名: Helpers\n    def paths_equal(self, *args):\n\n        equal = all([len(a) == len(args[0]) for a in args])\n\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\n", "tokens": ["tests", "test_relational", "py", "helpers", "def", "paths_equal", "self", "args", "equal", "all", "len", "a", "len", "args", "0", "for", "a", "in", "args", "for", "p1", "p2", "in", "zip", "args", "equal", "np", "array_equal", "p1", "vertices", "p2", "vertices", "equal", "np", "array_equal", "p1", "codes", "p2", "codes", "return", "equal"], "doc_len": 41}
{"doc_id": "tests/test_relational.py::SharedAxesLevelTests.test_color", "file_path": "tests/test_relational.py", "class_name": "SharedAxesLevelTests", "func_name": "test_color", "text": "文件路径: tests/test_relational.py, 类名: SharedAxesLevelTests\n    def test_color(self, long_df):\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C0\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", ax=ax)\n        self.func(data=long_df, x=\"x\", y=\"y\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C1\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", color=\"C2\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C2\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", c=\"C2\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C2\")\n", "tokens": ["tests", "test_relational", "py", "sharedaxesleveltests", "def", "test_color", "self", "long_df", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c0", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "ax", "ax", "self", "func", "data", "long_df", "x", "x", "y", "y", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c1", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "color", "c2", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c2", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "c", "c2", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c2"], "doc_len": 102}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_df_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_df_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_df_variables(self, wide_df):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_df)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n        assert len(p.plot_data) == np.product(wide_df.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(wide_df.index, wide_df.shape[1])\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_df.to_numpy().ravel(order=\"f\")\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] == wide_df.index.name\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] == wide_df.columns.name\n        assert p.variables[\"style\"] == wide_df.columns.name\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_df_variables", "self", "wide_df", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_df", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "assert", "len", "p", "plot_data", "np", "product", "wide_df", "shape", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "wide_df", "index", "wide_df", "shape", "1", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "wide_df", "to_numpy", "ravel", "order", "f", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "wide_df", "columns", "to_numpy", "wide_df", "shape", "0", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "wide_df", "index", "name", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "wide_df", "columns", "name", "assert", "p", "variables", "style", "wide_df", "columns", "name"], "doc_len": 114}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_df_with_nonnumeric_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_df_with_nonnumeric_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_df_with_nonnumeric_variables(self, long_df):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=long_df)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        numeric_df = long_df.select_dtypes(\"number\")\n\n        assert len(p.plot_data) == np.product(numeric_df.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = numeric_df.to_numpy().ravel(order=\"f\")\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(\n            numeric_df.columns.to_numpy(), numeric_df.shape[0]\n        )\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] == numeric_df.index.name\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] == numeric_df.columns.name\n        assert p.variables[\"style\"] == numeric_df.columns.name\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_df_with_nonnumeric_variables", "self", "long_df", "p", "_relationalplotter", "p", "assign_variables", "data", "long_df", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "numeric_df", "long_df", "select_dtypes", "number", "assert", "len", "p", "plot_data", "np", "product", "numeric_df", "shape", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "numeric_df", "index", "numeric_df", "shape", "1", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "numeric_df", "to_numpy", "ravel", "order", "f", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "numeric_df", "columns", "to_numpy", "numeric_df", "shape", "0", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "numeric_df", "index", "name", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "numeric_df", "columns", "name", "assert", "p", "variables", "style", "numeric_df", "columns", "name"], "doc_len": 118}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_array_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_array_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_array_variables(self, wide_array):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_array)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n        assert len(p.plot_data) == np.product(wide_array.shape)\n\n        nrow, ncol = wide_array.shape\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(nrow), ncol)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = wide_array.ravel(order=\"f\")\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(np.arange(ncol), nrow)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_array_variables", "self", "wide_array", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_array", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "assert", "len", "p", "plot_data", "np", "product", "wide_array", "shape", "nrow", "ncol", "wide_array", "shape", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "nrow", "ncol", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "wide_array", "ravel", "order", "f", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "np", "arange", "ncol", "nrow", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 111}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_flat_array_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_flat_array_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_flat_array_variables(self, flat_array):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=flat_array)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\"]\n        assert len(p.plot_data) == np.product(flat_array.shape)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.arange(flat_array.shape[0])\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_array\n        assert_array_equal(y, expected_y)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_flat_array_variables", "self", "flat_array", "p", "_relationalplotter", "p", "assign_variables", "data", "flat_array", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "assert", "len", "p", "plot_data", "np", "product", "flat_array", "shape", "x", "p", "plot_data", "x", "expected_x", "np", "arange", "flat_array", "shape", "0", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "flat_array", "assert_array_equal", "y", "expected_y", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none"], "doc_len": 66}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_flat_list_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_flat_list_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_flat_list_variables(self, flat_list):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=flat_list)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\"]\n        assert len(p.plot_data) == len(flat_list)\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.arange(len(flat_list))\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_list\n        assert_array_equal(y, expected_y)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_flat_list_variables", "self", "flat_list", "p", "_relationalplotter", "p", "assign_variables", "data", "flat_list", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "assert", "len", "p", "plot_data", "len", "flat_list", "x", "p", "plot_data", "x", "expected_x", "np", "arange", "len", "flat_list", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "flat_list", "assert_array_equal", "y", "expected_y", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none"], "doc_len": 63}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_flat_series_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_flat_series_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_flat_series_variables(self, flat_series):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=flat_series)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\"]\n        assert len(p.plot_data) == len(flat_series)\n\n        x = p.plot_data[\"x\"]\n        expected_x = flat_series.index\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = flat_series\n        assert_array_equal(y, expected_y)\n\n        assert p.variables[\"x\"] is flat_series.index.name\n        assert p.variables[\"y\"] is flat_series.name\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_flat_series_variables", "self", "flat_series", "p", "_relationalplotter", "p", "assign_variables", "data", "flat_series", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "assert", "len", "p", "plot_data", "len", "flat_series", "x", "p", "plot_data", "x", "expected_x", "flat_series", "index", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "flat_series", "assert_array_equal", "y", "expected_y", "assert", "p", "variables", "x", "is", "flat_series", "index", "name", "assert", "p", "variables", "y", "is", "flat_series", "name"], "doc_len": 64}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_list_of_series_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_list_of_series_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_list_of_series_variables(self, wide_list_of_series):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_list_of_series)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_list_of_series)\n        chunk_size = max(len(l) for l in wide_list_of_series)\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        index_union = np.unique(\n            np.concatenate([s.index for s in wide_list_of_series])\n        )\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(index_union, chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"]\n        expected_y = np.concatenate([\n            s.reindex(index_union) for s in wide_list_of_series\n        ])\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        series_names = [s.name for s in wide_list_of_series]\n        expected_hue = np.repeat(series_names, chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_list_of_series_variables", "self", "wide_list_of_series", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_list_of_series", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_list_of_series", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_list_of_series", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "index_union", "np", "unique", "np", "concatenate", "s", "index", "for", "s", "in", "wide_list_of_series", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "index_union", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "expected_y", "np", "concatenate", "s", "reindex", "index_union", "for", "s", "in", "wide_list_of_series", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "series_names", "s", "name", "for", "s", "in", "wide_list_of_series", "expected_hue", "np", "repeat", "series_names", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 135}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_list_of_arrays_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_list_of_arrays_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_list_of_arrays)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_list_of_arrays)\n        chunk_size = max(len(l) for l in wide_list_of_arrays)\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(chunk_size), chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"].dropna()\n        expected_y = np.concatenate(wide_list_of_arrays)\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(np.arange(chunks), chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_list_of_arrays_variables", "self", "wide_list_of_arrays", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_list_of_arrays", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_list_of_arrays", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_list_of_arrays", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "chunk_size", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "dropna", "expected_y", "np", "concatenate", "wide_list_of_arrays", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "np", "arange", "chunks", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 116}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_list_of_list_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_list_of_list_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_list_of_list_variables(self, wide_list_of_lists):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_list_of_lists)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_list_of_lists)\n        chunk_size = max(len(l) for l in wide_list_of_lists)\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(chunk_size), chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"].dropna()\n        expected_y = np.concatenate(wide_list_of_lists)\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(np.arange(chunks), chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_list_of_list_variables", "self", "wide_list_of_lists", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_list_of_lists", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_list_of_lists", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_list_of_lists", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "chunk_size", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "dropna", "expected_y", "np", "concatenate", "wide_list_of_lists", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "np", "arange", "chunks", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 116}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_dict_of_series_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_dict_of_series_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_dict_of_series)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_dict_of_series)\n        chunk_size = max(len(l) for l in wide_dict_of_series.values())\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(chunk_size), chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"].dropna()\n        expected_y = np.concatenate(list(wide_dict_of_series.values()))\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_dict_of_series_variables", "self", "wide_dict_of_series", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_dict_of_series", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_dict_of_series", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_dict_of_series", "values", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "chunk_size", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "dropna", "expected_y", "np", "concatenate", "list", "wide_dict_of_series", "values", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "list", "wide_dict_of_series", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 118}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_dict_of_arrays_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_dict_of_arrays_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_dict_of_arrays)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_dict_of_arrays)\n        chunk_size = max(len(l) for l in wide_dict_of_arrays.values())\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(chunk_size), chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"].dropna()\n        expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_dict_of_arrays_variables", "self", "wide_dict_of_arrays", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_dict_of_arrays", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_dict_of_arrays", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_dict_of_arrays", "values", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "chunk_size", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "dropna", "expected_y", "np", "concatenate", "list", "wide_dict_of_arrays", "values", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "list", "wide_dict_of_arrays", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 118}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_wide_dict_of_lists_variables", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_wide_dict_of_lists_variables", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n\n        p = _RelationalPlotter()\n        p.assign_variables(data=wide_dict_of_lists)\n        assert p.input_format == \"wide\"\n        assert list(p.variables) == [\"x\", \"y\", \"hue\", \"style\"]\n\n        chunks = len(wide_dict_of_lists)\n        chunk_size = max(len(l) for l in wide_dict_of_lists.values())\n\n        assert len(p.plot_data) == chunks * chunk_size\n\n        x = p.plot_data[\"x\"]\n        expected_x = np.tile(np.arange(chunk_size), chunks)\n        assert_array_equal(x, expected_x)\n\n        y = p.plot_data[\"y\"].dropna()\n        expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n        assert_array_equal(y, expected_y)\n\n        hue = p.plot_data[\"hue\"]\n        expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n        assert_array_equal(hue, expected_hue)\n\n        style = p.plot_data[\"style\"]\n        expected_style = expected_hue\n        assert_array_equal(style, expected_style)\n\n        assert p.variables[\"x\"] is None\n        assert p.variables[\"y\"] is None\n        assert p.variables[\"hue\"] is None\n        assert p.variables[\"style\"] is None\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_wide_dict_of_lists_variables", "self", "wide_dict_of_lists", "p", "_relationalplotter", "p", "assign_variables", "data", "wide_dict_of_lists", "assert", "p", "input_format", "wide", "assert", "list", "p", "variables", "x", "y", "hue", "style", "chunks", "len", "wide_dict_of_lists", "chunk_size", "max", "len", "l", "for", "l", "in", "wide_dict_of_lists", "values", "assert", "len", "p", "plot_data", "chunks", "chunk_size", "x", "p", "plot_data", "x", "expected_x", "np", "tile", "np", "arange", "chunk_size", "chunks", "assert_array_equal", "x", "expected_x", "y", "p", "plot_data", "y", "dropna", "expected_y", "np", "concatenate", "list", "wide_dict_of_lists", "values", "assert_array_equal", "y", "expected_y", "hue", "p", "plot_data", "hue", "expected_hue", "np", "repeat", "list", "wide_dict_of_lists", "chunk_size", "assert_array_equal", "hue", "expected_hue", "style", "p", "plot_data", "style", "expected_style", "expected_hue", "assert_array_equal", "style", "expected_style", "assert", "p", "variables", "x", "is", "none", "assert", "p", "variables", "y", "is", "none", "assert", "p", "variables", "hue", "is", "none", "assert", "p", "variables", "style", "is", "none"], "doc_len": 118}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_simple", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_simple", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_simple(self, long_df):\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", kind=\"scatter\")\n        x, y = g.ax.collections[0].get_offsets().T\n        assert_array_equal(x, long_df[\"x\"])\n        assert_array_equal(y, long_df[\"y\"])\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", kind=\"line\")\n        x, y = g.ax.lines[0].get_xydata().T\n        expected = long_df.groupby(\"x\").y.mean()\n        assert_array_equal(x, expected.index)\n        assert y == pytest.approx(expected.values)\n\n        with pytest.raises(ValueError):\n            g = relplot(data=long_df, x=\"x\", y=\"y\", kind=\"not_a_kind\")\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_simple", "self", "long_df", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "kind", "scatter", "x", "y", "g", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "long_df", "x", "assert_array_equal", "y", "long_df", "y", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "kind", "line", "x", "y", "g", "ax", "lines", "0", "get_xydata", "t", "expected", "long_df", "groupby", "x", "y", "mean", "assert_array_equal", "x", "expected", "index", "assert", "y", "pytest", "approx", "expected", "values", "with", "pytest", "raises", "valueerror", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "kind", "not_a_kind"], "doc_len": 82}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_complex", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_complex", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_complex(self, long_df):\n\n        for sem in [\"hue\", \"size\", \"style\"]:\n            g = relplot(data=long_df, x=\"x\", y=\"y\", **{sem: \"a\"})\n            x, y = g.ax.collections[0].get_offsets().T\n            assert_array_equal(x, long_df[\"x\"])\n            assert_array_equal(y, long_df[\"y\"])\n\n        for sem in [\"hue\", \"size\", \"style\"]:\n            g = relplot(\n                data=long_df, x=\"x\", y=\"y\", col=\"c\", **{sem: \"a\"}\n            )\n            grouped = long_df.groupby(\"c\")\n            for (_, grp_df), ax in zip(grouped, g.axes.flat):\n                x, y = ax.collections[0].get_offsets().T\n                assert_array_equal(x, grp_df[\"x\"])\n                assert_array_equal(y, grp_df[\"y\"])\n\n        for sem in [\"size\", \"style\"]:\n            g = relplot(\n                data=long_df, x=\"x\", y=\"y\", hue=\"b\", col=\"c\", **{sem: \"a\"}\n            )\n            grouped = long_df.groupby(\"c\")\n            for (_, grp_df), ax in zip(grouped, g.axes.flat):\n                x, y = ax.collections[0].get_offsets().T\n                assert_array_equal(x, grp_df[\"x\"])\n                assert_array_equal(y, grp_df[\"y\"])\n\n        for sem in [\"hue\", \"size\", \"style\"]:\n            g = relplot(\n                data=long_df.sort_values([\"c\", \"b\"]),\n                x=\"x\", y=\"y\", col=\"b\", row=\"c\", **{sem: \"a\"}\n            )\n            grouped = long_df.groupby([\"c\", \"b\"])\n            for (_, grp_df), ax in zip(grouped, g.axes.flat):\n                x, y = ax.collections[0].get_offsets().T\n                assert_array_equal(x, grp_df[\"x\"])\n                assert_array_equal(y, grp_df[\"y\"])\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_complex", "self", "long_df", "for", "sem", "in", "hue", "size", "style", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "sem", "a", "x", "y", "g", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "long_df", "x", "assert_array_equal", "y", "long_df", "y", "for", "sem", "in", "hue", "size", "style", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "col", "c", "sem", "a", "grouped", "long_df", "groupby", "c", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "grp_df", "x", "assert_array_equal", "y", "grp_df", "y", "for", "sem", "in", "size", "style", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "b", "col", "c", "sem", "a", "grouped", "long_df", "groupby", "c", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "grp_df", "x", "assert_array_equal", "y", "grp_df", "y", "for", "sem", "in", "hue", "size", "style", "g", "relplot", "data", "long_df", "sort_values", "c", "b", "x", "x", "y", "y", "col", "b", "row", "c", "sem", "a", "grouped", "long_df", "groupby", "c", "b", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "grp_df", "x", "assert_array_equal", "y", "grp_df", "y"], "doc_len": 188}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_vectors", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_vectors", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_vectors(self, long_df, vector_type):\n\n        semantics = dict(x=\"x\", y=\"y\", hue=\"f\", col=\"c\")\n        kws = {key: long_df[val] for key, val in semantics.items()}\n        if vector_type == \"numpy\":\n            kws = {k: v.to_numpy() for k, v in kws.items()}\n        elif vector_type == \"list\":\n            kws = {k: v.to_list() for k, v in kws.items()}\n        g = relplot(data=long_df, **kws)\n        grouped = long_df.groupby(\"c\")\n        assert len(g.axes_dict) == len(grouped)\n        for (_, grp_df), ax in zip(grouped, g.axes.flat):\n            x, y = ax.collections[0].get_offsets().T\n            assert_array_equal(x, grp_df[\"x\"])\n            assert_array_equal(y, grp_df[\"y\"])\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_vectors", "self", "long_df", "vector_type", "semantics", "dict", "x", "x", "y", "y", "hue", "f", "col", "c", "kws", "key", "long_df", "val", "for", "key", "val", "in", "semantics", "items", "if", "vector_type", "numpy", "kws", "k", "v", "to_numpy", "for", "k", "v", "in", "kws", "items", "elif", "vector_type", "list", "kws", "k", "v", "to_list", "for", "k", "v", "in", "kws", "items", "g", "relplot", "data", "long_df", "kws", "grouped", "long_df", "groupby", "c", "assert", "len", "g", "axes_dict", "len", "grouped", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "x", "y", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "x", "grp_df", "x", "assert_array_equal", "y", "grp_df", "y"], "doc_len": 95}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_wide", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_wide", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_wide(self, wide_df):\n\n        g = relplot(data=wide_df)\n        x, y = g.ax.collections[0].get_offsets().T\n        assert_array_equal(y, wide_df.to_numpy().T.ravel())\n        assert not g.ax.get_ylabel()\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_wide", "self", "wide_df", "g", "relplot", "data", "wide_df", "x", "y", "g", "ax", "collections", "0", "get_offsets", "t", "assert_array_equal", "y", "wide_df", "to_numpy", "t", "ravel", "assert", "not", "g", "ax", "get_ylabel"], "doc_len": 31}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_hues", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_hues", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_hues(self, long_df):\n\n        palette = [\"r\", \"b\", \"g\"]\n        g = relplot(\n            x=\"x\", y=\"y\", hue=\"a\", style=\"b\", col=\"c\",\n            palette=palette, data=long_df\n        )\n\n        palette = dict(zip(long_df[\"a\"].unique(), palette))\n        grouped = long_df.groupby(\"c\")\n        for (_, grp_df), ax in zip(grouped, g.axes.flat):\n            points = ax.collections[0]\n            expected_hues = [palette[val] for val in grp_df[\"a\"]]\n            assert same_color(points.get_facecolors(), expected_hues)\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_hues", "self", "long_df", "palette", "r", "b", "g", "g", "relplot", "x", "x", "y", "y", "hue", "a", "style", "b", "col", "c", "palette", "palette", "data", "long_df", "palette", "dict", "zip", "long_df", "a", "unique", "palette", "grouped", "long_df", "groupby", "c", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "points", "ax", "collections", "0", "expected_hues", "palette", "val", "for", "val", "in", "grp_df", "a", "assert", "same_color", "points", "get_facecolors", "expected_hues"], "doc_len": 66}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_sizes", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_sizes", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_sizes(self, long_df):\n\n        sizes = [5, 12, 7]\n        g = relplot(\n            data=long_df,\n            x=\"x\", y=\"y\", size=\"a\", hue=\"b\", col=\"c\",\n            sizes=sizes,\n        )\n\n        sizes = dict(zip(long_df[\"a\"].unique(), sizes))\n        grouped = long_df.groupby(\"c\")\n        for (_, grp_df), ax in zip(grouped, g.axes.flat):\n            points = ax.collections[0]\n            expected_sizes = [sizes[val] for val in grp_df[\"a\"]]\n            assert_array_equal(points.get_sizes(), expected_sizes)\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_sizes", "self", "long_df", "sizes", "5", "12", "7", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "size", "a", "hue", "b", "col", "c", "sizes", "sizes", "sizes", "dict", "zip", "long_df", "a", "unique", "sizes", "grouped", "long_df", "groupby", "c", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "points", "ax", "collections", "0", "expected_sizes", "sizes", "val", "for", "val", "in", "grp_df", "a", "assert_array_equal", "points", "get_sizes", "expected_sizes"], "doc_len": 65}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_styles", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_styles", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_styles(self, long_df):\n\n        markers = [\"o\", \"d\", \"s\"]\n        g = relplot(\n            data=long_df,\n            x=\"x\", y=\"y\", style=\"a\", hue=\"b\", col=\"c\",\n            markers=markers,\n        )\n\n        paths = []\n        for m in markers:\n            m = mpl.markers.MarkerStyle(m)\n            paths.append(m.get_path().transformed(m.get_transform()))\n        paths = dict(zip(long_df[\"a\"].unique(), paths))\n\n        grouped = long_df.groupby(\"c\")\n        for (_, grp_df), ax in zip(grouped, g.axes.flat):\n            points = ax.collections[0]\n            expected_paths = [paths[val] for val in grp_df[\"a\"]]\n            assert self.paths_equal(points.get_paths(), expected_paths)\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_styles", "self", "long_df", "markers", "o", "d", "s", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "style", "a", "hue", "b", "col", "c", "markers", "markers", "paths", "for", "m", "in", "markers", "m", "mpl", "markers", "markerstyle", "m", "paths", "append", "m", "get_path", "transformed", "m", "get_transform", "paths", "dict", "zip", "long_df", "a", "unique", "paths", "grouped", "long_df", "groupby", "c", "for", "_", "grp_df", "ax", "in", "zip", "grouped", "g", "axes", "flat", "points", "ax", "collections", "0", "expected_paths", "paths", "val", "for", "val", "in", "grp_df", "a", "assert", "self", "paths_equal", "points", "get_paths", "expected_paths"], "doc_len": 84}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_stringy_numerics", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_stringy_numerics", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_stringy_numerics(self, long_df):\n\n        long_df[\"x_str\"] = long_df[\"x\"].astype(str)\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=\"x_str\")\n        points = g.ax.collections[0]\n        xys = points.get_offsets()\n        mask = np.ma.getmask(xys)\n        assert not mask.any()\n        assert_array_equal(xys, long_df[[\"x\", \"y\"]])\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", size=\"x_str\")\n        points = g.ax.collections[0]\n        xys = points.get_offsets()\n        mask = np.ma.getmask(xys)\n        assert not mask.any()\n        assert_array_equal(xys, long_df[[\"x\", \"y\"]])\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_stringy_numerics", "self", "long_df", "long_df", "x_str", "long_df", "x", "astype", "str", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "x_str", "points", "g", "ax", "collections", "0", "xys", "points", "get_offsets", "mask", "np", "ma", "getmask", "xys", "assert", "not", "mask", "any", "assert_array_equal", "xys", "long_df", "x", "y", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "size", "x_str", "points", "g", "ax", "collections", "0", "xys", "points", "get_offsets", "mask", "np", "ma", "getmask", "xys", "assert", "not", "mask", "any", "assert_array_equal", "xys", "long_df", "x", "y"], "doc_len": 78}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_legend", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_legend", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_legend(self, long_df):\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\")\n        assert g._legend is None\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\")\n        texts = [t.get_text() for t in g._legend.texts]\n        expected_texts = long_df[\"a\"].unique()\n        assert_array_equal(texts, expected_texts)\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=\"s\", size=\"s\")\n        texts = [t.get_text() for t in g._legend.texts]\n        assert_array_equal(texts, np.sort(texts))\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", legend=False)\n        assert g._legend is None\n\n        palette = color_palette(\"deep\", len(long_df[\"b\"].unique()))\n        a_like_b = dict(zip(long_df[\"a\"].unique(), long_df[\"b\"].unique()))\n        long_df[\"a_like_b\"] = long_df[\"a\"].map(a_like_b)\n        g = relplot(\n            data=long_df,\n            x=\"x\", y=\"y\", hue=\"b\", style=\"a_like_b\",\n            palette=palette, kind=\"line\", estimator=None,\n        )\n        lines = g._legend.get_lines()[1:]  # Chop off title dummy\n        for line, color in zip(lines, palette):\n            assert line.get_color() == color\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_legend", "self", "long_df", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "assert", "g", "_legend", "is", "none", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "texts", "t", "get_text", "for", "t", "in", "g", "_legend", "texts", "expected_texts", "long_df", "a", "unique", "assert_array_equal", "texts", "expected_texts", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "s", "size", "s", "texts", "t", "get_text", "for", "t", "in", "g", "_legend", "texts", "assert_array_equal", "texts", "np", "sort", "texts", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "legend", "false", "assert", "g", "_legend", "is", "none", "palette", "color_palette", "deep", "len", "long_df", "b", "unique", "a_like_b", "dict", "zip", "long_df", "a", "unique", "long_df", "b", "unique", "long_df", "a_like_b", "long_df", "a", "map", "a_like_b", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "b", "style", "a_like_b", "palette", "palette", "kind", "line", "estimator", "none", "lines", "g", "_legend", "get_lines", "1", "chop", "off", "title", "dummy", "for", "line", "color", "in", "zip", "lines", "palette", "assert", "line", "get_color", "color"], "doc_len": 150}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_unshared_axis_labels", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_unshared_axis_labels", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_unshared_axis_labels(self, long_df):\n\n        col, row = \"a\", \"b\"\n        g = relplot(\n            data=long_df, x=\"x\", y=\"y\", col=col, row=row,\n            facet_kws=dict(sharex=False, sharey=False),\n        )\n\n        for ax in g.axes[-1, :].flat:\n            assert ax.get_xlabel() == \"x\"\n        for ax in g.axes[:-1, :].flat:\n            assert ax.get_xlabel() == \"\"\n        for ax in g.axes[:, 0].flat:\n            assert ax.get_ylabel() == \"y\"\n        for ax in g.axes[:, 1:].flat:\n            assert ax.get_ylabel() == \"\"\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_unshared_axis_labels", "self", "long_df", "col", "row", "a", "b", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "col", "col", "row", "row", "facet_kws", "dict", "sharex", "false", "sharey", "false", "for", "ax", "in", "g", "axes", "1", "flat", "assert", "ax", "get_xlabel", "x", "for", "ax", "in", "g", "axes", "1", "flat", "assert", "ax", "get_xlabel", "for", "ax", "in", "g", "axes", "0", "flat", "assert", "ax", "get_ylabel", "y", "for", "ax", "in", "g", "axes", "1", "flat", "assert", "ax", "get_ylabel"], "doc_len": 72}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_relplot_data", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_relplot_data", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_relplot_data(self, long_df):\n\n        g = relplot(\n            data=long_df.to_dict(orient=\"list\"),\n            x=\"x\",\n            y=long_df[\"y\"].rename(\"y_var\"),\n            hue=long_df[\"a\"].to_numpy(),\n            col=\"c\",\n        )\n        expected_cols = set(long_df.columns.to_list() + [\"_hue_\", \"y_var\"])\n        assert set(g.data.columns) == expected_cols\n        assert_array_equal(g.data[\"y_var\"], long_df[\"y\"])\n        assert_array_equal(g.data[\"_hue_\"], long_df[\"a\"])\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_relplot_data", "self", "long_df", "g", "relplot", "data", "long_df", "to_dict", "orient", "list", "x", "x", "y", "long_df", "y", "rename", "y_var", "hue", "long_df", "a", "to_numpy", "col", "c", "expected_cols", "set", "long_df", "columns", "to_list", "_hue_", "y_var", "assert", "set", "g", "data", "columns", "expected_cols", "assert_array_equal", "g", "data", "y_var", "long_df", "y", "assert_array_equal", "g", "data", "_hue_", "long_df", "a"], "doc_len": 53}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_facet_variable_collision", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_facet_variable_collision", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_facet_variable_collision(self, long_df):\n\n        # https://github.com/mwaskom/seaborn/issues/2488\n        col_data = long_df[\"c\"]\n        long_df = long_df.assign(size=col_data)\n\n        g = relplot(\n            data=long_df,\n            x=\"x\", y=\"y\", col=\"size\",\n        )\n        assert g.axes.shape == (1, len(col_data.unique()))\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_facet_variable_collision", "self", "long_df", "https", "github", "com", "mwaskom", "seaborn", "issues", "2488", "col_data", "long_df", "c", "long_df", "long_df", "assign", "size", "col_data", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "col", "size", "assert", "g", "axes", "shape", "1", "len", "col_data", "unique"], "doc_len": 41}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_ax_kwarg_removal", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_ax_kwarg_removal", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_ax_kwarg_removal(self, long_df):\n\n        f, ax = plt.subplots()\n        with pytest.warns(UserWarning):\n            g = relplot(data=long_df, x=\"x\", y=\"y\", ax=ax)\n        assert len(ax.collections) == 0\n        assert len(g.ax.collections) > 0\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_ax_kwarg_removal", "self", "long_df", "f", "ax", "plt", "subplots", "with", "pytest", "warns", "userwarning", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "ax", "ax", "assert", "len", "ax", "collections", "0", "assert", "len", "g", "ax", "collections", "0"], "doc_len": 37}
{"doc_id": "tests/test_relational.py::TestRelationalPlotter.test_legend_has_no_offset", "file_path": "tests/test_relational.py", "class_name": "TestRelationalPlotter", "func_name": "test_legend_has_no_offset", "text": "文件路径: tests/test_relational.py, 类名: TestRelationalPlotter\n    def test_legend_has_no_offset(self, long_df):\n\n        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=long_df[\"z\"] + 1e8)\n        for text in g.legend.texts:\n            assert float(text.get_text()) > 1e7\n", "tokens": ["tests", "test_relational", "py", "testrelationalplotter", "def", "test_legend_has_no_offset", "self", "long_df", "g", "relplot", "data", "long_df", "x", "x", "y", "y", "hue", "long_df", "z", "1e8", "for", "text", "in", "g", "legend", "texts", "assert", "float", "text", "get_text", "1e7"], "doc_len": 31}
{"doc_id": "tests/test_relational.py::TestLinePlotter.get_last_color", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "get_last_color", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def get_last_color(self, ax):\n\n        return to_rgba(ax.lines[-1].get_color())\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "get_last_color", "self", "ax", "return", "to_rgba", "ax", "lines", "1", "get_color"], "doc_len": 14}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_legend_data", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_legend_data", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_legend_data(self, long_df):\n\n        f, ax = plt.subplots()\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n            legend=\"full\"\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert handles == []\n\n        # --\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            legend=\"full\",\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        assert labels == p._hue_map.levels\n        assert colors == p._hue_map(p._hue_map.levels)\n\n        # --\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"a\"),\n            legend=\"full\",\n        )\n        p.map_style(markers=True)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        assert labels == p._hue_map.levels\n        assert labels == p._style_map.levels\n        assert colors == p._hue_map(p._hue_map.levels)\n        assert markers == p._style_map(p._style_map.levels, \"marker\")\n\n        # --\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"b\"),\n            legend=\"full\",\n        )\n        p.map_style(markers=True)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        markers = [h.get_marker() for h in handles]\n        expected_labels = (\n            [\"a\"]\n            + p._hue_map.levels\n            + [\"b\"] + p._style_map.levels\n        )\n        expected_colors = (\n            [\"w\"] + p._hue_map(p._hue_map.levels)\n            + [\"w\"] + [\".2\" for _ in p._style_map.levels]\n        )\n        expected_markers = (\n            [\"\"] + [\"None\" for _ in p._hue_map.levels]\n            + [\"\"] + p._style_map(p._style_map.levels, \"marker\")\n        )\n        assert labels == expected_labels\n        assert colors == expected_colors\n        assert markers == expected_markers\n\n        # --\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", size=\"a\"),\n            legend=\"full\"\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_color() for h in handles]\n        widths = [h.get_linewidth() for h in handles]\n        assert labels == p._hue_map.levels\n        assert labels == p._size_map.levels\n        assert colors == p._hue_map(p._hue_map.levels)\n        assert widths == p._size_map(p._size_map.levels)\n\n        # --\n\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n\n        p = _LinePlotter(variables=dict(x=x, y=y, hue=z))\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p._hue_map.levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._hue_map.levels)\n\n        p = _LinePlotter(variables=dict(x=x, y=y, size=z))\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p._size_map.levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._size_map.levels)\n\n        ax.clear()\n        p.legend = \"auto\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._size_map.levels)\n\n        ax.clear()\n        p.legend = True\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._size_map.levels)\n\n        ax.clear()\n        p.legend = \"bad_value\"\n        with pytest.raises(ValueError):\n            p.add_legend_data(ax)\n\n        ax.clear()\n        p = _LinePlotter(\n            variables=dict(x=x, y=y, hue=z + 1),\n            legend=\"brief\"\n        )\n        p.map_hue(norm=mpl.colors.LogNorm()),\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert float(labels[1]) / float(labels[0]) == 10\n\n        ax.clear()\n        p = _LinePlotter(\n            variables=dict(x=x, y=y, hue=z % 2),\n            legend=\"auto\"\n        )\n        p.map_hue(norm=mpl.colors.LogNorm()),\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [\"0\", \"1\"]\n\n        ax.clear()\n        p = _LinePlotter(\n            variables=dict(x=x, y=y, size=z + 1),\n            legend=\"brief\"\n        )\n        p.map_size(norm=mpl.colors.LogNorm())\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert float(labels[1]) / float(labels[0]) == 10\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"f\"),\n            legend=\"brief\",\n        )\n        p.add_legend_data(ax)\n        expected_labels = ['0.20', '0.22', '0.24', '0.26', '0.28']\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == expected_labels\n\n        ax.clear()\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"f\"),\n            legend=\"brief\",\n        )\n        p.add_legend_data(ax)\n        expected_levels = ['0.20', '0.22', '0.24', '0.26', '0.28']\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == expected_levels\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_legend_data", "self", "long_df", "f", "ax", "plt", "subplots", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "handles", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_color", "for", "h", "in", "handles", "assert", "labels", "p", "_hue_map", "levels", "assert", "colors", "p", "_hue_map", "p", "_hue_map", "levels", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "a", "legend", "full", "p", "map_style", "markers", "true", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_color", "for", "h", "in", "handles", "markers", "h", "get_marker", "for", "h", "in", "handles", "assert", "labels", "p", "_hue_map", "levels", "assert", "labels", "p", "_style_map", "levels", "assert", "colors", "p", "_hue_map", "p", "_hue_map", "levels", "assert", "markers", "p", "_style_map", "p", "_style_map", "levels", "marker", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "b", "legend", "full", "p", "map_style", "markers", "true", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_color", "for", "h", "in", "handles", "markers", "h", "get_marker", "for", "h", "in", "handles", "expected_labels", "a", "p", "_hue_map", "levels", "b", "p", "_style_map", "levels", "expected_colors", "w", "p", "_hue_map", "p", "_hue_map", "levels", "w", "2", "for", "_", "in", "p", "_style_map", "levels", "expected_markers", "none", "for", "_", "in", "p", "_hue_map", "levels", "p", "_style_map", "p", "_style_map", "levels", "marker", "assert", "labels", "expected_labels", "assert", "colors", "expected_colors", "assert", "markers", "expected_markers", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "size", "a", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_color", "for", "h", "in", "handles", "widths", "h", "get_linewidth", "for", "h", "in", "handles", "assert", "labels", "p", "_hue_map", "levels", "assert", "labels", "p", "_size_map", "levels", "assert", "colors", "p", "_hue_map", "p", "_hue_map", "levels", "assert", "widths", "p", "_size_map", "p", "_size_map", "levels", "x", "y", "np", "random", "randn", "2", "40", "z", "np", "tile", "np", "arange", "20", "2", "p", "_lineplotter", "variables", "dict", "x", "x", "y", "y", "hue", "z", "ax", "clear", "p", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_hue_map", "levels", "ax", "clear", "p", "legend", "brief", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_hue_map", "levels", "p", "_lineplotter", "variables", "dict", "x", "x", "y", "y", "size", "z", "ax", "clear", "p", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "brief", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "auto", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "true", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "bad_value", "with", "pytest", "raises", "valueerror", "p", "add_legend_data", "ax", "ax", "clear", "p", "_lineplotter", "variables", "dict", "x", "x", "y", "y", "hue", "z", "1", "legend", "brief", "p", "map_hue", "norm", "mpl", "colors", "lognorm", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "float", "labels", "1", "float", "labels", "0", "10", "ax", "clear", "p", "_lineplotter", "variables", "dict", "x", "x", "y", "y", "hue", "z", "2", "legend", "auto", "p", "map_hue", "norm", "mpl", "colors", "lognorm", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "0", "1", "ax", "clear", "p", "_lineplotter", "variables", "dict", "x", "x", "y", "y", "size", "z", "1", "legend", "brief", "p", "map_size", "norm", "mpl", "colors", "lognorm", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "float", "labels", "1", "float", "labels", "0", "10", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "f", "legend", "brief", "p", "add_legend_data", "ax", "expected_labels", "0", "20", "0", "22", "0", "24", "0", "26", "0", "28", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "expected_labels", "ax", "clear", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "f", "legend", "brief", "p", "add_legend_data", "ax", "expected_levels", "0", "20", "0", "22", "0", "24", "0", "26", "0", "28", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "expected_levels"], "doc_len": 640}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_plot", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_plot", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_plot(self, long_df, repeated_df):\n\n        f, ax = plt.subplots()\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n            sort=False,\n            estimator=None\n        )\n        p.plot(ax, {})\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n        assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n\n        ax.clear()\n        p.plot(ax, {\"color\": \"k\", \"label\": \"test\"})\n        line, = ax.lines\n        assert line.get_color() == \"k\"\n        assert line.get_label() == \"test\"\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n            sort=True, estimator=None\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        sorted_data = long_df.sort_values([\"x\", \"y\"])\n        assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n        assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p._hue_map.levels)\n        for line, level in zip(ax.lines, p._hue_map.levels):\n            assert line.get_color() == p._hue_map(level)\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"a\"),\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p._size_map.levels)\n        for line, level in zip(ax.lines, p._size_map.levels):\n            assert line.get_linewidth() == p._size_map(level)\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"a\"),\n        )\n        p.map_style(markers=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(p._hue_map.levels)\n        assert len(ax.lines) == len(p._style_map.levels)\n        for line, level in zip(ax.lines, p._hue_map.levels):\n            assert line.get_color() == p._hue_map(level)\n            assert line.get_marker() == p._style_map(level, \"marker\")\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"b\"),\n        )\n        p.map_style(markers=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        levels = product(p._hue_map.levels, p._style_map.levels)\n        expected_line_count = len(p._hue_map.levels) * len(p._style_map.levels)\n        assert len(ax.lines) == expected_line_count\n        for line, (hue, style) in zip(ax.lines, levels):\n            assert line.get_color() == p._hue_map(hue)\n            assert line.get_marker() == p._style_map(style, \"marker\")\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n            estimator=\"mean\", err_style=\"band\", errorbar=\"sd\", sort=True\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        expected_data = long_df.groupby(\"x\").y.mean()\n        assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n        assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n        assert len(ax.collections) == 1\n\n        # Test that nans do not propagate to means or CIs\n\n        p = _LinePlotter(\n            variables=dict(\n                x=[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6],\n            ),\n            estimator=\"mean\", err_style=\"band\", errorbar=\"ci\", n_boot=100, sort=True,\n        )\n        ax.clear()\n        p.plot(ax, {})\n        line, = ax.lines\n        assert line.get_xdata().tolist() == [1, 2, 3]\n        err_band = ax.collections[0].get_paths()\n        assert len(err_band) == 1\n        assert len(err_band[0].vertices) == 9\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            estimator=\"mean\", err_style=\"band\", errorbar=\"sd\"\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        assert len(ax.lines) == len(ax.collections) == len(p._hue_map.levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.PolyCollection)\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            estimator=\"mean\", err_style=\"bars\", errorbar=\"sd\"\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        n_lines = len(ax.lines)\n        assert n_lines / 2 == len(ax.collections) == len(p._hue_map.levels)\n        assert len(ax.collections) == len(p._hue_map.levels)\n        for c in ax.collections:\n            assert isinstance(c, mpl.collections.LineCollection)\n\n        p = _LinePlotter(\n            data=repeated_df,\n            variables=dict(x=\"x\", y=\"y\", units=\"u\"),\n            estimator=None\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        n_units = len(repeated_df[\"u\"].unique())\n        assert len(ax.lines) == n_units\n\n        p = _LinePlotter(\n            data=repeated_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", units=\"u\"),\n            estimator=None\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        n_units *= len(repeated_df[\"a\"].unique())\n        assert len(ax.lines) == n_units\n\n        p.estimator = \"mean\"\n        with pytest.raises(ValueError):\n            p.plot(ax, {})\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            err_style=\"band\", err_kws={\"alpha\": .5},\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        for band in ax.collections:\n            assert band.get_alpha() == .5\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            err_style=\"bars\", err_kws={\"elinewidth\": 2},\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        for lines in ax.collections:\n            assert lines.get_linestyles() == 2\n\n        p.err_style = \"invalid\"\n        with pytest.raises(ValueError):\n            p.plot(ax, {})\n\n        x_str = long_df[\"x\"].astype(str)\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=x_str),\n        )\n        ax.clear()\n        p.plot(ax, {})\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=x_str),\n        )\n        ax.clear()\n        p.plot(ax, {})\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_plot", "self", "long_df", "repeated_df", "f", "ax", "plt", "subplots", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "sort", "false", "estimator", "none", "p", "plot", "ax", "line", "ax", "lines", "assert_array_equal", "line", "get_xdata", "long_df", "x", "to_numpy", "assert_array_equal", "line", "get_ydata", "long_df", "y", "to_numpy", "ax", "clear", "p", "plot", "ax", "color", "k", "label", "test", "line", "ax", "lines", "assert", "line", "get_color", "k", "assert", "line", "get_label", "test", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "sort", "true", "estimator", "none", "ax", "clear", "p", "plot", "ax", "line", "ax", "lines", "sorted_data", "long_df", "sort_values", "x", "y", "assert_array_equal", "line", "get_xdata", "sorted_data", "x", "to_numpy", "assert_array_equal", "line", "get_ydata", "sorted_data", "y", "to_numpy", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "ax", "clear", "p", "plot", "ax", "assert", "len", "ax", "lines", "len", "p", "_hue_map", "levels", "for", "line", "level", "in", "zip", "ax", "lines", "p", "_hue_map", "levels", "assert", "line", "get_color", "p", "_hue_map", "level", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "ax", "clear", "p", "plot", "ax", "assert", "len", "ax", "lines", "len", "p", "_size_map", "levels", "for", "line", "level", "in", "zip", "ax", "lines", "p", "_size_map", "levels", "assert", "line", "get_linewidth", "p", "_size_map", "level", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "a", "p", "map_style", "markers", "true", "ax", "clear", "p", "plot", "ax", "assert", "len", "ax", "lines", "len", "p", "_hue_map", "levels", "assert", "len", "ax", "lines", "len", "p", "_style_map", "levels", "for", "line", "level", "in", "zip", "ax", "lines", "p", "_hue_map", "levels", "assert", "line", "get_color", "p", "_hue_map", "level", "assert", "line", "get_marker", "p", "_style_map", "level", "marker", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "b", "p", "map_style", "markers", "true", "ax", "clear", "p", "plot", "ax", "levels", "product", "p", "_hue_map", "levels", "p", "_style_map", "levels", "expected_line_count", "len", "p", "_hue_map", "levels", "len", "p", "_style_map", "levels", "assert", "len", "ax", "lines", "expected_line_count", "for", "line", "hue", "style", "in", "zip", "ax", "lines", "levels", "assert", "line", "get_color", "p", "_hue_map", "hue", "assert", "line", "get_marker", "p", "_style_map", "style", "marker", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "estimator", "mean", "err_style", "band", "errorbar", "sd", "sort", "true", "ax", "clear", "p", "plot", "ax", "line", "ax", "lines", "expected_data", "long_df", "groupby", "x", "y", "mean", "assert_array_equal", "line", "get_xdata", "expected_data", "index", "to_numpy", "assert", "np", "allclose", "line", "get_ydata", "expected_data", "to_numpy", "assert", "len", "ax", "collections", "1", "test", "that", "nans", "do", "not", "propagate", "to", "means", "or", "cis", "p", "_lineplotter", "variables", "dict", "x", "1", "1", "1", "2", "2", "2", "3", "3", "3", "y", "1", "2", "3", "3", "np", "nan", "5", "4", "5", "6", "estimator", "mean", "err_style", "band", "errorbar", "ci", "n_boot", "100", "sort", "true", "ax", "clear", "p", "plot", "ax", "line", "ax", "lines", "assert", "line", "get_xdata", "tolist", "1", "2", "3", "err_band", "ax", "collections", "0", "get_paths", "assert", "len", "err_band", "1", "assert", "len", "err_band", "0", "vertices", "9", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "estimator", "mean", "err_style", "band", "errorbar", "sd", "ax", "clear", "p", "plot", "ax", "assert", "len", "ax", "lines", "len", "ax", "collections", "len", "p", "_hue_map", "levels", "for", "c", "in", "ax", "collections", "assert", "isinstance", "c", "mpl", "collections", "polycollection", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "estimator", "mean", "err_style", "bars", "errorbar", "sd", "ax", "clear", "p", "plot", "ax", "n_lines", "len", "ax", "lines", "assert", "n_lines", "2", "len", "ax", "collections", "len", "p", "_hue_map", "levels", "assert", "len", "ax", "collections", "len", "p", "_hue_map", "levels", "for", "c", "in", "ax", "collections", "assert", "isinstance", "c", "mpl", "collections", "linecollection", "p", "_lineplotter", "data", "repeated_df", "variables", "dict", "x", "x", "y", "y", "units", "u", "estimator", "none", "ax", "clear", "p", "plot", "ax", "n_units", "len", "repeated_df", "u", "unique", "assert", "len", "ax", "lines", "n_units", "p", "_lineplotter", "data", "repeated_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "units", "u", "estimator", "none", "ax", "clear", "p", "plot", "ax", "n_units", "len", "repeated_df", "a", "unique", "assert", "len", "ax", "lines", "n_units", "p", "estimator", "mean", "with", "pytest", "raises", "valueerror", "p", "plot", "ax", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "err_style", "band", "err_kws", "alpha", "5", "ax", "clear", "p", "plot", "ax", "for", "band", "in", "ax", "collections", "assert", "band", "get_alpha", "5", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "err_style", "bars", "err_kws", "elinewidth", "2", "ax", "clear", "p", "plot", "ax", "for", "lines", "in", "ax", "collections", "assert", "lines", "get_linestyles", "2", "p", "err_style", "invalid", "with", "pytest", "raises", "valueerror", "p", "plot", "ax", "x_str", "long_df", "x", "astype", "str", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "x_str", "ax", "clear", "p", "plot", "ax", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "x_str", "ax", "clear", "p", "plot", "ax"], "doc_len": 722}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_non_aggregated_data", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_non_aggregated_data", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_non_aggregated_data(self):\n\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_non_aggregated_data", "self", "x", "1", "2", "3", "4", "y", "2", "4", "6", "8", "ax", "lineplot", "x", "x", "y", "y", "line", "ax", "lines", "assert_array_equal", "line", "get_xdata", "x", "assert_array_equal", "line", "get_ydata", "y"], "doc_len": 34}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_orient", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_orient", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_orient(self, long_df):\n\n        long_df = long_df.drop(\"x\", axis=1).rename(columns={\"s\": \"y\", \"y\": \"x\"})\n\n        ax1 = plt.figure().subplots()\n        lineplot(data=long_df, x=\"x\", y=\"y\", orient=\"y\", errorbar=\"sd\")\n        assert len(ax1.lines) == len(ax1.collections)\n        line, = ax1.lines\n        expected = long_df.groupby(\"y\").agg({\"x\": \"mean\"}).reset_index()\n        assert_array_almost_equal(line.get_xdata(), expected[\"x\"])\n        assert_array_almost_equal(line.get_ydata(), expected[\"y\"])\n        ribbon_y = ax1.collections[0].get_paths()[0].vertices[:, 1]\n        assert_array_equal(np.unique(ribbon_y), long_df[\"y\"].sort_values().unique())\n\n        ax2 = plt.figure().subplots()\n        lineplot(\n            data=long_df, x=\"x\", y=\"y\", orient=\"y\", errorbar=\"sd\", err_style=\"bars\"\n        )\n        segments = ax2.collections[0].get_segments()\n        for i, val in enumerate(sorted(long_df[\"y\"].unique())):\n            assert (segments[i][:, 1] == val).all()\n\n        with pytest.raises(ValueError, match=\"`orient` must be either 'x' or 'y'\"):\n            lineplot(long_df, x=\"y\", y=\"x\", orient=\"bad\")\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_orient", "self", "long_df", "long_df", "long_df", "drop", "x", "axis", "1", "rename", "columns", "s", "y", "y", "x", "ax1", "plt", "figure", "subplots", "lineplot", "data", "long_df", "x", "x", "y", "y", "orient", "y", "errorbar", "sd", "assert", "len", "ax1", "lines", "len", "ax1", "collections", "line", "ax1", "lines", "expected", "long_df", "groupby", "y", "agg", "x", "mean", "reset_index", "assert_array_almost_equal", "line", "get_xdata", "expected", "x", "assert_array_almost_equal", "line", "get_ydata", "expected", "y", "ribbon_y", "ax1", "collections", "0", "get_paths", "0", "vertices", "1", "assert_array_equal", "np", "unique", "ribbon_y", "long_df", "y", "sort_values", "unique", "ax2", "plt", "figure", "subplots", "lineplot", "data", "long_df", "x", "x", "y", "y", "orient", "y", "errorbar", "sd", "err_style", "bars", "segments", "ax2", "collections", "0", "get_segments", "for", "i", "val", "in", "enumerate", "sorted", "long_df", "y", "unique", "assert", "segments", "i", "1", "val", "all", "with", "pytest", "raises", "valueerror", "match", "orient", "must", "be", "either", "x", "or", "y", "lineplot", "long_df", "x", "y", "y", "x", "orient", "bad"], "doc_len": 136}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_log_scale", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_log_scale", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_log_scale(self):\n\n        f, ax = plt.subplots()\n        ax.set_xscale(\"log\")\n\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n\n        f, ax = plt.subplots()\n        ax.set_xscale(\"log\")\n        ax.set_yscale(\"log\")\n\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n\n        lineplot(x=x, y=y, err_style=\"bars\", errorbar=(\"pi\", 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_log_scale", "self", "f", "ax", "plt", "subplots", "ax", "set_xscale", "log", "x", "1", "10", "100", "y", "1", "2", "3", "lineplot", "x", "x", "y", "y", "line", "ax", "lines", "0", "assert_array_equal", "line", "get_xdata", "x", "assert_array_equal", "line", "get_ydata", "y", "f", "ax", "plt", "subplots", "ax", "set_xscale", "log", "ax", "set_yscale", "log", "x", "1", "1", "2", "2", "y", "1", "10", "1", "100", "lineplot", "x", "x", "y", "y", "err_style", "bars", "errorbar", "pi", "100", "line", "ax", "lines", "0", "assert", "line", "get_ydata", "1", "10", "ebars", "ax", "collections", "0", "get_segments", "assert_array_equal", "ebars", "0", "1", "y", "2", "assert_array_equal", "ebars", "1", "1", "y", "2"], "doc_len": 95}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_axis_labels", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_axis_labels", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_axis_labels(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n\n        p = _LinePlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n        )\n\n        p.plot(ax1, {})\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"y\"\n\n        p.plot(ax2, {})\n        assert ax2.get_xlabel() == \"x\"\n        assert ax2.get_ylabel() == \"y\"\n        assert not ax2.yaxis.label.get_visible()\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_axis_labels", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "1", "2", "sharey", "true", "p", "_lineplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "p", "plot", "ax1", "assert", "ax1", "get_xlabel", "x", "assert", "ax1", "get_ylabel", "y", "p", "plot", "ax2", "assert", "ax2", "get_xlabel", "x", "assert", "ax2", "get_ylabel", "y", "assert", "not", "ax2", "yaxis", "label", "get_visible"], "doc_len": 55}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_matplotlib_kwargs", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_matplotlib_kwargs", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_matplotlib_kwargs(self, long_df):\n\n        kws = {\n            \"linestyle\": \"--\",\n            \"linewidth\": 3,\n            \"color\": (1, .5, .2),\n            \"markeredgecolor\": (.2, .5, .2),\n            \"markeredgewidth\": 1,\n        }\n        ax = lineplot(data=long_df, x=\"x\", y=\"y\", **kws)\n\n        line, *_ = ax.lines\n        for key, val in kws.items():\n            plot_val = getattr(line, f\"get_{key}\")()\n            assert plot_val == val\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_matplotlib_kwargs", "self", "long_df", "kws", "linestyle", "linewidth", "3", "color", "1", "5", "2", "markeredgecolor", "2", "5", "2", "markeredgewidth", "1", "ax", "lineplot", "data", "long_df", "x", "x", "y", "y", "kws", "line", "_", "ax", "lines", "for", "key", "val", "in", "kws", "items", "plot_val", "getattr", "line", "f", "get_", "key", "assert", "plot_val", "val"], "doc_len": 50}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_nonmapped_dashes", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_nonmapped_dashes", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_nonmapped_dashes(self):\n\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        # Not a great test, but lines don't expose the dash style publicly\n        assert line.get_linestyle() == \"--\"\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_nonmapped_dashes", "self", "ax", "lineplot", "x", "1", "2", "y", "1", "2", "dashes", "2", "1", "line", "ax", "lines", "0", "not", "a", "great", "test", "but", "lines", "don", "t", "expose", "the", "dash", "style", "publicly", "assert", "line", "get_linestyle"], "doc_len": 38}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_lineplot_axes", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_lineplot_axes", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_lineplot_axes(self, wide_df):\n\n        f1, ax1 = plt.subplots()\n        f2, ax2 = plt.subplots()\n\n        ax = lineplot(data=wide_df)\n        assert ax is ax2\n\n        ax = lineplot(data=wide_df, ax=ax1)\n        assert ax is ax1\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_lineplot_axes", "self", "wide_df", "f1", "ax1", "plt", "subplots", "f2", "ax2", "plt", "subplots", "ax", "lineplot", "data", "wide_df", "assert", "ax", "is", "ax2", "ax", "lineplot", "data", "wide_df", "ax", "ax1", "assert", "ax", "is", "ax1"], "doc_len": 34}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_lineplot_vs_relplot", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_lineplot_vs_relplot", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_lineplot_vs_relplot(self, long_df, long_semantics):\n\n        ax = lineplot(data=long_df, **long_semantics)\n        g = relplot(data=long_df, kind=\"line\", **long_semantics)\n\n        lin_lines = ax.lines\n        rel_lines = g.ax.lines\n\n        for l1, l2 in zip(lin_lines, rel_lines):\n            assert_array_equal(l1.get_xydata(), l2.get_xydata())\n            assert same_color(l1.get_color(), l2.get_color())\n            assert l1.get_linewidth() == l2.get_linewidth()\n            assert l1.get_linestyle() == l2.get_linestyle()\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_lineplot_vs_relplot", "self", "long_df", "long_semantics", "ax", "lineplot", "data", "long_df", "long_semantics", "g", "relplot", "data", "long_df", "kind", "line", "long_semantics", "lin_lines", "ax", "lines", "rel_lines", "g", "ax", "lines", "for", "l1", "l2", "in", "zip", "lin_lines", "rel_lines", "assert_array_equal", "l1", "get_xydata", "l2", "get_xydata", "assert", "same_color", "l1", "get_color", "l2", "get_color", "assert", "l1", "get_linewidth", "l2", "get_linewidth", "assert", "l1", "get_linestyle", "l2", "get_linestyle"], "doc_len": 56}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_lineplot_smoke", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_lineplot_smoke", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_lineplot_smoke(\n        self,\n        wide_df, wide_array,\n        wide_list_of_series, wide_list_of_arrays, wide_list_of_lists,\n        flat_array, flat_series, flat_list,\n        long_df, missing_df, object_df\n    ):\n\n        f, ax = plt.subplots()\n\n        lineplot(x=[], y=[])\n        ax.clear()\n\n        lineplot(data=wide_df)\n        ax.clear()\n\n        lineplot(data=wide_array)\n        ax.clear()\n\n        lineplot(data=wide_list_of_series)\n        ax.clear()\n\n        lineplot(data=wide_list_of_arrays)\n        ax.clear()\n\n        lineplot(data=wide_list_of_lists)\n        ax.clear()\n\n        lineplot(data=flat_series)\n        ax.clear()\n\n        lineplot(data=flat_array)\n        ax.clear()\n\n        lineplot(data=flat_list)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", data=long_df)\n        ax.clear()\n\n        lineplot(x=long_df.x, y=long_df.y)\n        ax.clear()\n\n        lineplot(x=long_df.x, y=\"y\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=long_df.y.to_numpy(), data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"t\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=missing_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=missing_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=missing_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=missing_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"f\", data=object_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"c\", size=\"f\", data=object_df)\n        ax.clear()\n\n        lineplot(x=\"x\", y=\"y\", hue=\"f\", size=\"s\", data=object_df)\n        ax.clear()\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_lineplot_smoke", "self", "wide_df", "wide_array", "wide_list_of_series", "wide_list_of_arrays", "wide_list_of_lists", "flat_array", "flat_series", "flat_list", "long_df", "missing_df", "object_df", "f", "ax", "plt", "subplots", "lineplot", "x", "y", "ax", "clear", "lineplot", "data", "wide_df", "ax", "clear", "lineplot", "data", "wide_array", "ax", "clear", "lineplot", "data", "wide_list_of_series", "ax", "clear", "lineplot", "data", "wide_list_of_arrays", "ax", "clear", "lineplot", "data", "wide_list_of_lists", "ax", "clear", "lineplot", "data", "flat_series", "ax", "clear", "lineplot", "data", "flat_array", "ax", "clear", "lineplot", "data", "flat_list", "ax", "clear", "lineplot", "x", "x", "y", "y", "data", "long_df", "ax", "clear", "lineplot", "x", "long_df", "x", "y", "long_df", "y", "ax", "clear", "lineplot", "x", "long_df", "x", "y", "y", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "long_df", "y", "to_numpy", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "t", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "style", "a", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "style", "b", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "style", "a", "data", "missing_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "style", "b", "data", "missing_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "size", "a", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "size", "s", "data", "long_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "size", "a", "data", "missing_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "a", "size", "s", "data", "missing_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "f", "data", "object_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "c", "size", "f", "data", "object_df", "ax", "clear", "lineplot", "x", "x", "y", "y", "hue", "f", "size", "s", "data", "object_df", "ax", "clear"], "doc_len": 267}
{"doc_id": "tests/test_relational.py::TestLinePlotter.test_ci_deprecation", "file_path": "tests/test_relational.py", "class_name": "TestLinePlotter", "func_name": "test_ci_deprecation", "text": "文件路径: tests/test_relational.py, 类名: TestLinePlotter\n    def test_ci_deprecation(self, long_df):\n\n        axs = plt.figure().subplots(2)\n        lineplot(data=long_df, x=\"x\", y=\"y\", errorbar=(\"ci\", 95), seed=0, ax=axs[0])\n        with pytest.warns(FutureWarning, match=\"\\n\\nThe `ci` parameter is deprecated\"):\n            lineplot(data=long_df, x=\"x\", y=\"y\", ci=95, seed=0, ax=axs[1])\n        assert_plots_equal(*axs)\n\n        axs = plt.figure().subplots(2)\n        lineplot(data=long_df, x=\"x\", y=\"y\", errorbar=\"sd\", ax=axs[0])\n        with pytest.warns(FutureWarning, match=\"\\n\\nThe `ci` parameter is deprecated\"):\n            lineplot(data=long_df, x=\"x\", y=\"y\", ci=\"sd\", ax=axs[1])\n        assert_plots_equal(*axs)\n", "tokens": ["tests", "test_relational", "py", "testlineplotter", "def", "test_ci_deprecation", "self", "long_df", "axs", "plt", "figure", "subplots", "2", "lineplot", "data", "long_df", "x", "x", "y", "y", "errorbar", "ci", "95", "seed", "0", "ax", "axs", "0", "with", "pytest", "warns", "futurewarning", "match", "n", "nthe", "ci", "parameter", "is", "deprecated", "lineplot", "data", "long_df", "x", "x", "y", "y", "ci", "95", "seed", "0", "ax", "axs", "1", "assert_plots_equal", "axs", "axs", "plt", "figure", "subplots", "2", "lineplot", "data", "long_df", "x", "x", "y", "y", "errorbar", "sd", "ax", "axs", "0", "with", "pytest", "warns", "futurewarning", "match", "n", "nthe", "ci", "parameter", "is", "deprecated", "lineplot", "data", "long_df", "x", "x", "y", "y", "ci", "sd", "ax", "axs", "1", "assert_plots_equal", "axs"], "doc_len": 97}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.get_last_color", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "get_last_color", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def get_last_color(self, ax):\n\n        colors = ax.collections[-1].get_facecolors()\n        unique_colors = np.unique(colors, axis=0)\n        assert len(unique_colors) == 1\n        return to_rgba(unique_colors.squeeze())\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "get_last_color", "self", "ax", "colors", "ax", "collections", "1", "get_facecolors", "unique_colors", "np", "unique", "colors", "axis", "0", "assert", "len", "unique_colors", "1", "return", "to_rgba", "unique_colors", "squeeze"], "doc_len": 27}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_color", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_color", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_color(self, long_df):\n\n        super().test_color(long_df)\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", facecolor=\"C5\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C5\")\n\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x=\"x\", y=\"y\", facecolors=\"C6\", ax=ax)\n        assert self.get_last_color(ax) == to_rgba(\"C6\")\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n\n            ax = plt.figure().subplots()\n            self.func(data=long_df, x=\"x\", y=\"y\", fc=\"C4\", ax=ax)\n            assert self.get_last_color(ax) == to_rgba(\"C4\")\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_color", "self", "long_df", "super", "test_color", "long_df", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "facecolor", "c5", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c5", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "facecolors", "c6", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c6", "if", "version", "mpl", "__version__", "version", "3", "1", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "12851", "ax", "plt", "figure", "subplots", "self", "func", "data", "long_df", "x", "x", "y", "y", "fc", "c4", "ax", "ax", "assert", "self", "get_last_color", "ax", "to_rgba", "c4"], "doc_len": 92}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_legend_data", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_legend_data", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_legend_data(self, long_df):\n\n        m = mpl.markers.MarkerStyle(\"o\")\n        default_mark = m.get_path().transformed(m.get_transform())\n\n        m = mpl.markers.MarkerStyle(\"\")\n        null = m.get_path().transformed(m.get_transform())\n\n        f, ax = plt.subplots()\n\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\"),\n            legend=\"full\",\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert handles == []\n\n        # --\n\n        ax.clear()\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\"),\n            legend=\"full\",\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_facecolors()[0] for h in handles]\n        expected_colors = p._hue_map(p._hue_map.levels)\n        assert labels == p._hue_map.levels\n        assert same_color(colors, expected_colors)\n\n        # --\n\n        ax.clear()\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"a\"),\n            legend=\"full\",\n        )\n        p.map_style(markers=True)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_facecolors()[0] for h in handles]\n        expected_colors = p._hue_map(p._hue_map.levels)\n        paths = [h.get_paths()[0] for h in handles]\n        expected_paths = p._style_map(p._style_map.levels, \"path\")\n        assert labels == p._hue_map.levels\n        assert labels == p._style_map.levels\n        assert same_color(colors, expected_colors)\n        assert self.paths_equal(paths, expected_paths)\n\n        # --\n\n        ax.clear()\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"b\"),\n            legend=\"full\",\n        )\n        p.map_style(markers=True)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_facecolors()[0] for h in handles]\n        paths = [h.get_paths()[0] for h in handles]\n        expected_colors = (\n            [\"w\"] + p._hue_map(p._hue_map.levels)\n            + [\"w\"] + [\".2\" for _ in p._style_map.levels]\n        )\n        expected_paths = (\n            [null] + [default_mark for _ in p._hue_map.levels]\n            + [null] + p._style_map(p._style_map.levels, \"path\")\n        )\n        assert labels == (\n            [\"a\"] + p._hue_map.levels + [\"b\"] + p._style_map.levels\n        )\n        assert same_color(colors, expected_colors)\n        assert self.paths_equal(paths, expected_paths)\n\n        # --\n\n        ax.clear()\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", size=\"a\"),\n            legend=\"full\"\n        )\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        colors = [h.get_facecolors()[0] for h in handles]\n        expected_colors = p._hue_map(p._hue_map.levels)\n        sizes = [h.get_sizes()[0] for h in handles]\n        expected_sizes = p._size_map(p._size_map.levels)\n        assert labels == p._hue_map.levels\n        assert labels == p._size_map.levels\n        assert same_color(colors, expected_colors)\n        assert sizes == expected_sizes\n\n        # --\n\n        ax.clear()\n        sizes_list = [10, 100, 200]\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"s\"),\n            legend=\"full\",\n        )\n        p.map_size(sizes=sizes_list)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        sizes = [h.get_sizes()[0] for h in handles]\n        expected_sizes = p._size_map(p._size_map.levels)\n        assert labels == [str(l) for l in p._size_map.levels]\n        assert sizes == expected_sizes\n\n        # --\n\n        ax.clear()\n        sizes_dict = {2: 10, 4: 100, 8: 200}\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", size=\"s\"),\n            legend=\"full\"\n        )\n        p.map_size(sizes=sizes_dict)\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        sizes = [h.get_sizes()[0] for h in handles]\n        expected_sizes = p._size_map(p._size_map.levels)\n        assert labels == [str(l) for l in p._size_map.levels]\n        assert sizes == expected_sizes\n\n        # --\n\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n\n        p = _ScatterPlotter(\n            variables=dict(x=x, y=y, hue=z),\n        )\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p._hue_map.levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._hue_map.levels)\n\n        p = _ScatterPlotter(\n            variables=dict(x=x, y=y, size=z),\n        )\n\n        ax.clear()\n        p.legend = \"full\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert labels == [str(l) for l in p._size_map.levels]\n\n        ax.clear()\n        p.legend = \"brief\"\n        p.add_legend_data(ax)\n        handles, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(p._size_map.levels)\n\n        ax.clear()\n        p.legend = \"bad_value\"\n        with pytest.raises(ValueError):\n            p.add_legend_data(ax)\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_legend_data", "self", "long_df", "m", "mpl", "markers", "markerstyle", "o", "default_mark", "m", "get_path", "transformed", "m", "get_transform", "m", "mpl", "markers", "markerstyle", "null", "m", "get_path", "transformed", "m", "get_transform", "f", "ax", "plt", "subplots", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "handles", "ax", "clear", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_facecolors", "0", "for", "h", "in", "handles", "expected_colors", "p", "_hue_map", "p", "_hue_map", "levels", "assert", "labels", "p", "_hue_map", "levels", "assert", "same_color", "colors", "expected_colors", "ax", "clear", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "a", "legend", "full", "p", "map_style", "markers", "true", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_facecolors", "0", "for", "h", "in", "handles", "expected_colors", "p", "_hue_map", "p", "_hue_map", "levels", "paths", "h", "get_paths", "0", "for", "h", "in", "handles", "expected_paths", "p", "_style_map", "p", "_style_map", "levels", "path", "assert", "labels", "p", "_hue_map", "levels", "assert", "labels", "p", "_style_map", "levels", "assert", "same_color", "colors", "expected_colors", "assert", "self", "paths_equal", "paths", "expected_paths", "ax", "clear", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "b", "legend", "full", "p", "map_style", "markers", "true", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_facecolors", "0", "for", "h", "in", "handles", "paths", "h", "get_paths", "0", "for", "h", "in", "handles", "expected_colors", "w", "p", "_hue_map", "p", "_hue_map", "levels", "w", "2", "for", "_", "in", "p", "_style_map", "levels", "expected_paths", "null", "default_mark", "for", "_", "in", "p", "_hue_map", "levels", "null", "p", "_style_map", "p", "_style_map", "levels", "path", "assert", "labels", "a", "p", "_hue_map", "levels", "b", "p", "_style_map", "levels", "assert", "same_color", "colors", "expected_colors", "assert", "self", "paths_equal", "paths", "expected_paths", "ax", "clear", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "size", "a", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "colors", "h", "get_facecolors", "0", "for", "h", "in", "handles", "expected_colors", "p", "_hue_map", "p", "_hue_map", "levels", "sizes", "h", "get_sizes", "0", "for", "h", "in", "handles", "expected_sizes", "p", "_size_map", "p", "_size_map", "levels", "assert", "labels", "p", "_hue_map", "levels", "assert", "labels", "p", "_size_map", "levels", "assert", "same_color", "colors", "expected_colors", "assert", "sizes", "expected_sizes", "ax", "clear", "sizes_list", "10", "100", "200", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "s", "legend", "full", "p", "map_size", "sizes", "sizes_list", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "sizes", "h", "get_sizes", "0", "for", "h", "in", "handles", "expected_sizes", "p", "_size_map", "p", "_size_map", "levels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_size_map", "levels", "assert", "sizes", "expected_sizes", "ax", "clear", "sizes_dict", "2", "10", "4", "100", "8", "200", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "s", "legend", "full", "p", "map_size", "sizes", "sizes_dict", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "sizes", "h", "get_sizes", "0", "for", "h", "in", "handles", "expected_sizes", "p", "_size_map", "p", "_size_map", "levels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_size_map", "levels", "assert", "sizes", "expected_sizes", "x", "y", "np", "random", "randn", "2", "40", "z", "np", "tile", "np", "arange", "20", "2", "p", "_scatterplotter", "variables", "dict", "x", "x", "y", "y", "hue", "z", "ax", "clear", "p", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_hue_map", "levels", "ax", "clear", "p", "legend", "brief", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_hue_map", "levels", "p", "_scatterplotter", "variables", "dict", "x", "x", "y", "y", "size", "z", "ax", "clear", "p", "legend", "full", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "labels", "str", "l", "for", "l", "in", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "brief", "p", "add_legend_data", "ax", "handles", "labels", "ax", "get_legend_handles_labels", "assert", "len", "labels", "len", "p", "_size_map", "levels", "ax", "clear", "p", "legend", "bad_value", "with", "pytest", "raises", "valueerror", "p", "add_legend_data", "ax"], "doc_len": 589}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_plot", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_plot", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_plot(self, long_df, repeated_df):\n\n        f, ax = plt.subplots()\n\n        p = _ScatterPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\"))\n\n        p.plot(ax, {})\n        points = ax.collections[0]\n        assert_array_equal(points.get_offsets(), long_df[[\"x\", \"y\"]].to_numpy())\n\n        ax.clear()\n        p.plot(ax, {\"color\": \"k\", \"label\": \"test\"})\n        points = ax.collections[0]\n        assert same_color(points.get_facecolor(), \"k\")\n        assert points.get_label() == \"test\"\n\n        p = _ScatterPlotter(\n            data=long_df, variables=dict(x=\"x\", y=\"y\", hue=\"a\")\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        points = ax.collections[0]\n        expected_colors = p._hue_map(p.plot_data[\"hue\"])\n        assert same_color(points.get_facecolors(), expected_colors)\n\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", style=\"c\"),\n        )\n        p.map_style(markers=[\"+\", \"x\"])\n\n        ax.clear()\n        color = (1, .3, .8)\n        p.plot(ax, {\"color\": color})\n        points = ax.collections[0]\n        assert same_color(points.get_edgecolors(), [color])\n\n        p = _ScatterPlotter(\n            data=long_df, variables=dict(x=\"x\", y=\"y\", size=\"a\"),\n        )\n\n        ax.clear()\n        p.plot(ax, {})\n        points = ax.collections[0]\n        expected_sizes = p._size_map(p.plot_data[\"size\"])\n        assert_array_equal(points.get_sizes(), expected_sizes)\n\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"a\"),\n        )\n        p.map_style(markers=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        points = ax.collections[0]\n        expected_colors = p._hue_map(p.plot_data[\"hue\"])\n        expected_paths = p._style_map(p.plot_data[\"style\"], \"path\")\n        assert same_color(points.get_facecolors(), expected_colors)\n        assert self.paths_equal(points.get_paths(), expected_paths)\n\n        p = _ScatterPlotter(\n            data=long_df,\n            variables=dict(x=\"x\", y=\"y\", hue=\"a\", style=\"b\"),\n        )\n        p.map_style(markers=True)\n\n        ax.clear()\n        p.plot(ax, {})\n        points = ax.collections[0]\n        expected_colors = p._hue_map(p.plot_data[\"hue\"])\n        expected_paths = p._style_map(p.plot_data[\"style\"], \"path\")\n        assert same_color(points.get_facecolors(), expected_colors)\n        assert self.paths_equal(points.get_paths(), expected_paths)\n\n        x_str = long_df[\"x\"].astype(str)\n        p = _ScatterPlotter(\n            data=long_df, variables=dict(x=\"x\", y=\"y\", hue=x_str),\n        )\n        ax.clear()\n        p.plot(ax, {})\n\n        p = _ScatterPlotter(\n            data=long_df, variables=dict(x=\"x\", y=\"y\", size=x_str),\n        )\n        ax.clear()\n        p.plot(ax, {})\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_plot", "self", "long_df", "repeated_df", "f", "ax", "plt", "subplots", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "p", "plot", "ax", "points", "ax", "collections", "0", "assert_array_equal", "points", "get_offsets", "long_df", "x", "y", "to_numpy", "ax", "clear", "p", "plot", "ax", "color", "k", "label", "test", "points", "ax", "collections", "0", "assert", "same_color", "points", "get_facecolor", "k", "assert", "points", "get_label", "test", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "ax", "clear", "p", "plot", "ax", "points", "ax", "collections", "0", "expected_colors", "p", "_hue_map", "p", "plot_data", "hue", "assert", "same_color", "points", "get_facecolors", "expected_colors", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "style", "c", "p", "map_style", "markers", "x", "ax", "clear", "color", "1", "3", "8", "p", "plot", "ax", "color", "color", "points", "ax", "collections", "0", "assert", "same_color", "points", "get_edgecolors", "color", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "a", "ax", "clear", "p", "plot", "ax", "points", "ax", "collections", "0", "expected_sizes", "p", "_size_map", "p", "plot_data", "size", "assert_array_equal", "points", "get_sizes", "expected_sizes", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "a", "p", "map_style", "markers", "true", "ax", "clear", "p", "plot", "ax", "points", "ax", "collections", "0", "expected_colors", "p", "_hue_map", "p", "plot_data", "hue", "expected_paths", "p", "_style_map", "p", "plot_data", "style", "path", "assert", "same_color", "points", "get_facecolors", "expected_colors", "assert", "self", "paths_equal", "points", "get_paths", "expected_paths", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "a", "style", "b", "p", "map_style", "markers", "true", "ax", "clear", "p", "plot", "ax", "points", "ax", "collections", "0", "expected_colors", "p", "_hue_map", "p", "plot_data", "hue", "expected_paths", "p", "_style_map", "p", "plot_data", "style", "path", "assert", "same_color", "points", "get_facecolors", "expected_colors", "assert", "self", "paths_equal", "points", "get_paths", "expected_paths", "x_str", "long_df", "x", "astype", "str", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "hue", "x_str", "ax", "clear", "p", "plot", "ax", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "size", "x_str", "ax", "clear", "p", "plot", "ax"], "doc_len": 299}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_axis_labels", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_axis_labels", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_axis_labels(self, long_df):\n\n        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n\n        p = _ScatterPlotter(data=long_df, variables=dict(x=\"x\", y=\"y\"))\n\n        p.plot(ax1, {})\n        assert ax1.get_xlabel() == \"x\"\n        assert ax1.get_ylabel() == \"y\"\n\n        p.plot(ax2, {})\n        assert ax2.get_xlabel() == \"x\"\n        assert ax2.get_ylabel() == \"y\"\n        assert not ax2.yaxis.label.get_visible()\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_axis_labels", "self", "long_df", "f", "ax1", "ax2", "plt", "subplots", "1", "2", "sharey", "true", "p", "_scatterplotter", "data", "long_df", "variables", "dict", "x", "x", "y", "y", "p", "plot", "ax1", "assert", "ax1", "get_xlabel", "x", "assert", "ax1", "get_ylabel", "y", "p", "plot", "ax2", "assert", "ax2", "get_xlabel", "x", "assert", "ax2", "get_ylabel", "y", "assert", "not", "ax2", "yaxis", "label", "get_visible"], "doc_len": 55}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_scatterplot_axes", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_scatterplot_axes", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_scatterplot_axes(self, wide_df):\n\n        f1, ax1 = plt.subplots()\n        f2, ax2 = plt.subplots()\n\n        ax = scatterplot(data=wide_df)\n        assert ax is ax2\n\n        ax = scatterplot(data=wide_df, ax=ax1)\n        assert ax is ax1\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_scatterplot_axes", "self", "wide_df", "f1", "ax1", "plt", "subplots", "f2", "ax2", "plt", "subplots", "ax", "scatterplot", "data", "wide_df", "assert", "ax", "is", "ax2", "ax", "scatterplot", "data", "wide_df", "ax", "ax1", "assert", "ax", "is", "ax1"], "doc_len": 34}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_literal_attribute_vectors", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_literal_attribute_vectors", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_literal_attribute_vectors(self):\n\n        f, ax = plt.subplots()\n\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, .5), (.5, 1, 0, 1)]\n\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n\n        points, = ax.collections\n\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_literal_attribute_vectors", "self", "f", "ax", "plt", "subplots", "x", "y", "1", "2", "3", "s", "5", "10", "15", "c", "1", "1", "0", "1", "1", "0", "1", "5", "5", "1", "0", "1", "scatterplot", "x", "x", "y", "y", "c", "c", "s", "s", "ax", "ax", "points", "ax", "collections", "assert_array_equal", "points", "get_sizes", "squeeze", "s", "assert_array_equal", "points", "get_facecolors", "c"], "doc_len": 56}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_supplied_color_array", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_supplied_color_array", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_supplied_color_array(self, long_df):\n\n        cmap = get_colormap(\"Blues\")\n        norm = mpl.colors.Normalize()\n        colors = cmap(norm(long_df[\"y\"].to_numpy()))\n\n        keys = [\"c\", \"facecolor\", \"facecolors\"]\n\n        if Version(mpl.__version__) >= Version(\"3.1.0\"):\n            # https://github.com/matplotlib/matplotlib/pull/12851\n            keys.append(\"fc\")\n\n        for key in keys:\n\n            ax = plt.figure().subplots()\n            scatterplot(data=long_df, x=\"x\", y=\"y\", **{key: colors})\n            _draw_figure(ax.figure)\n            assert_array_equal(ax.collections[0].get_facecolors(), colors)\n\n        ax = plt.figure().subplots()\n        scatterplot(data=long_df, x=\"x\", y=\"y\", c=long_df[\"y\"], cmap=cmap)\n        _draw_figure(ax.figure)\n        assert_array_equal(ax.collections[0].get_facecolors(), colors)\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_supplied_color_array", "self", "long_df", "cmap", "get_colormap", "blues", "norm", "mpl", "colors", "normalize", "colors", "cmap", "norm", "long_df", "y", "to_numpy", "keys", "c", "facecolor", "facecolors", "if", "version", "mpl", "__version__", "version", "3", "1", "0", "https", "github", "com", "matplotlib", "matplotlib", "pull", "12851", "keys", "append", "fc", "for", "key", "in", "keys", "ax", "plt", "figure", "subplots", "scatterplot", "data", "long_df", "x", "x", "y", "y", "key", "colors", "_draw_figure", "ax", "figure", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "colors", "ax", "plt", "figure", "subplots", "scatterplot", "data", "long_df", "x", "x", "y", "y", "c", "long_df", "y", "cmap", "cmap", "_draw_figure", "ax", "figure", "assert_array_equal", "ax", "collections", "0", "get_facecolors", "colors"], "doc_len": 94}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_hue_order", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_hue_order", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_hue_order(self, long_df):\n\n        order = categorical_order(long_df[\"a\"])\n        unused = order.pop()\n\n        ax = scatterplot(data=long_df, x=\"x\", y=\"y\", hue=\"a\", hue_order=order)\n        points = ax.collections[0]\n        assert (points.get_facecolors()[long_df[\"a\"] == unused] == 0).all()\n        assert [t.get_text() for t in ax.legend_.texts] == order\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_hue_order", "self", "long_df", "order", "categorical_order", "long_df", "a", "unused", "order", "pop", "ax", "scatterplot", "data", "long_df", "x", "x", "y", "y", "hue", "a", "hue_order", "order", "points", "ax", "collections", "0", "assert", "points", "get_facecolors", "long_df", "a", "unused", "0", "all", "assert", "t", "get_text", "for", "t", "in", "ax", "legend_", "texts", "order"], "doc_len": 49}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_linewidths", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_linewidths", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_linewidths(self, long_df):\n\n        f, ax = plt.subplots()\n\n        scatterplot(data=long_df, x=\"x\", y=\"y\", s=10)\n        scatterplot(data=long_df, x=\"x\", y=\"y\", s=20)\n        points1, points2 = ax.collections\n        assert (\n            points1.get_linewidths().item() < points2.get_linewidths().item()\n        )\n\n        ax.clear()\n        scatterplot(data=long_df, x=\"x\", y=\"y\", s=long_df[\"x\"])\n        scatterplot(data=long_df, x=\"x\", y=\"y\", s=long_df[\"x\"] * 2)\n        points1, points2 = ax.collections\n        assert (\n            points1.get_linewidths().item() < points2.get_linewidths().item()\n        )\n\n        ax.clear()\n        scatterplot(data=long_df, x=\"x\", y=\"y\", size=long_df[\"x\"])\n        scatterplot(data=long_df, x=\"x\", y=\"y\", size=long_df[\"x\"] * 2)\n        points1, points2, *_ = ax.collections\n        assert (\n            points1.get_linewidths().item() < points2.get_linewidths().item()\n        )\n\n        ax.clear()\n        lw = 2\n        scatterplot(data=long_df, x=\"x\", y=\"y\", linewidth=lw)\n        assert ax.collections[0].get_linewidths().item() == lw\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_linewidths", "self", "long_df", "f", "ax", "plt", "subplots", "scatterplot", "data", "long_df", "x", "x", "y", "y", "s", "10", "scatterplot", "data", "long_df", "x", "x", "y", "y", "s", "20", "points1", "points2", "ax", "collections", "assert", "points1", "get_linewidths", "item", "points2", "get_linewidths", "item", "ax", "clear", "scatterplot", "data", "long_df", "x", "x", "y", "y", "s", "long_df", "x", "scatterplot", "data", "long_df", "x", "x", "y", "y", "s", "long_df", "x", "2", "points1", "points2", "ax", "collections", "assert", "points1", "get_linewidths", "item", "points2", "get_linewidths", "item", "ax", "clear", "scatterplot", "data", "long_df", "x", "x", "y", "y", "size", "long_df", "x", "scatterplot", "data", "long_df", "x", "x", "y", "y", "size", "long_df", "x", "2", "points1", "points2", "_", "ax", "collections", "assert", "points1", "get_linewidths", "item", "points2", "get_linewidths", "item", "ax", "clear", "lw", "2", "scatterplot", "data", "long_df", "x", "x", "y", "y", "linewidth", "lw", "assert", "ax", "collections", "0", "get_linewidths", "item", "lw"], "doc_len": 130}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_size_norm_extrapolation", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_size_norm_extrapolation", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_size_norm_extrapolation(self):\n\n        # https://github.com/mwaskom/seaborn/issues/2539\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend=\"brief\")\n\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n\n        assert np.allclose(\n            axs[0].collections[0].get_sizes()[:slc],\n            axs[1].collections[0].get_sizes()\n        )\n\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [\n            {\n                label.get_text(): handle.get_sizes().item()\n                for label, handle in zip(legend.get_texts(), legend.legendHandles)\n            } for legend in legends\n        ]\n\n        for key in set(legend_data[0]) & set(legend_data[1]):\n            if key == \"y\":\n                # At some point (circa 3.0) matplotlib auto-added pandas series\n                # with a valid name into the legend, which messes up this test.\n                # I can't track down when that was added (or removed), so let's\n                # just anticipate and ignore it here.\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_size_norm_extrapolation", "self", "https", "github", "com", "mwaskom", "seaborn", "issues", "2539", "x", "np", "arange", "0", "20", "2", "f", "axs", "plt", "subplots", "1", "2", "sharex", "true", "sharey", "true", "slc", "5", "kws", "dict", "sizes", "50", "200", "size_norm", "0", "x", "max", "legend", "brief", "scatterplot", "x", "x", "y", "x", "size", "x", "ax", "axs", "0", "kws", "scatterplot", "x", "x", "slc", "y", "x", "slc", "size", "x", "slc", "ax", "axs", "1", "kws", "assert", "np", "allclose", "axs", "0", "collections", "0", "get_sizes", "slc", "axs", "1", "collections", "0", "get_sizes", "legends", "ax", "legend_", "for", "ax", "in", "axs", "legend_data", "label", "get_text", "handle", "get_sizes", "item", "for", "label", "handle", "in", "zip", "legend", "get_texts", "legend", "legendhandles", "for", "legend", "in", "legends", "for", "key", "in", "set", "legend_data", "0", "set", "legend_data", "1", "if", "key", "y", "at", "some", "point", "circa", "3", "0", "matplotlib", "auto", "added", "pandas", "series", "with", "a", "valid", "name", "into", "the", "legend", "which", "messes", "up", "this", "test", "i", "can", "t", "track", "down", "when", "that", "was", "added", "or", "removed", "so", "let", "s", "just", "anticipate", "and", "ignore", "it", "here", "continue", "assert", "legend_data", "0", "key", "legend_data", "1", "key"], "doc_len": 171}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_datetime_scale", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_datetime_scale", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_datetime_scale(self, long_df):\n\n        ax = scatterplot(data=long_df, x=\"t\", y=\"y\")\n        # Check that we avoid weird matplotlib default auto scaling\n        # https://github.com/matplotlib/matplotlib/issues/17586\n        ax.get_xlim()[0] > ax.xaxis.convert_units(np.datetime64(\"2002-01-01\"))\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_datetime_scale", "self", "long_df", "ax", "scatterplot", "data", "long_df", "x", "t", "y", "y", "check", "that", "we", "avoid", "weird", "matplotlib", "default", "auto", "scaling", "https", "github", "com", "matplotlib", "matplotlib", "issues", "17586", "ax", "get_xlim", "0", "ax", "xaxis", "convert_units", "np", "datetime64", "2002", "01", "01"], "doc_len": 43}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_unfilled_marker_edgecolor_warning", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_unfilled_marker_edgecolor_warning", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_unfilled_marker_edgecolor_warning(self, long_df):  # GH2636\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"error\")\n            scatterplot(data=long_df, x=\"x\", y=\"y\", marker=\"+\")\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_unfilled_marker_edgecolor_warning", "self", "long_df", "gh2636", "with", "warnings", "catch_warnings", "warnings", "simplefilter", "error", "scatterplot", "data", "long_df", "x", "x", "y", "y", "marker"], "doc_len": 23}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_scatterplot_vs_relplot", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_scatterplot_vs_relplot", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_scatterplot_vs_relplot(self, long_df, long_semantics):\n\n        ax = scatterplot(data=long_df, **long_semantics)\n        g = relplot(data=long_df, kind=\"scatter\", **long_semantics)\n\n        for s_pts, r_pts in zip(ax.collections, g.ax.collections):\n\n            assert_array_equal(s_pts.get_offsets(), r_pts.get_offsets())\n            assert_array_equal(s_pts.get_sizes(), r_pts.get_sizes())\n            assert_array_equal(s_pts.get_facecolors(), r_pts.get_facecolors())\n            assert self.paths_equal(s_pts.get_paths(), r_pts.get_paths())\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_scatterplot_vs_relplot", "self", "long_df", "long_semantics", "ax", "scatterplot", "data", "long_df", "long_semantics", "g", "relplot", "data", "long_df", "kind", "scatter", "long_semantics", "for", "s_pts", "r_pts", "in", "zip", "ax", "collections", "g", "ax", "collections", "assert_array_equal", "s_pts", "get_offsets", "r_pts", "get_offsets", "assert_array_equal", "s_pts", "get_sizes", "r_pts", "get_sizes", "assert_array_equal", "s_pts", "get_facecolors", "r_pts", "get_facecolors", "assert", "self", "paths_equal", "s_pts", "get_paths", "r_pts", "get_paths"], "doc_len": 53}
{"doc_id": "tests/test_relational.py::TestScatterPlotter.test_scatterplot_smoke", "file_path": "tests/test_relational.py", "class_name": "TestScatterPlotter", "func_name": "test_scatterplot_smoke", "text": "文件路径: tests/test_relational.py, 类名: TestScatterPlotter\n    def test_scatterplot_smoke(\n        self,\n        wide_df, wide_array,\n        flat_series, flat_array, flat_list,\n        wide_list_of_series, wide_list_of_arrays, wide_list_of_lists,\n        long_df, missing_df, object_df\n    ):\n\n        f, ax = plt.subplots()\n\n        scatterplot(x=[], y=[])\n        ax.clear()\n\n        scatterplot(data=wide_df)\n        ax.clear()\n\n        scatterplot(data=wide_array)\n        ax.clear()\n\n        scatterplot(data=wide_list_of_series)\n        ax.clear()\n\n        scatterplot(data=wide_list_of_arrays)\n        ax.clear()\n\n        scatterplot(data=wide_list_of_lists)\n        ax.clear()\n\n        scatterplot(data=flat_series)\n        ax.clear()\n\n        scatterplot(data=flat_array)\n        ax.clear()\n\n        scatterplot(data=flat_list)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=long_df.x, y=long_df.y)\n        ax.clear()\n\n        scatterplot(x=long_df.x, y=\"y\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=long_df.y.to_numpy(), data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", style=\"a\", data=missing_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", style=\"b\", data=missing_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=long_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", size=\"a\", data=missing_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"a\", size=\"s\", data=missing_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"f\", data=object_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"c\", size=\"f\", data=object_df)\n        ax.clear()\n\n        scatterplot(x=\"x\", y=\"y\", hue=\"f\", size=\"s\", data=object_df)\n        ax.clear()\n", "tokens": ["tests", "test_relational", "py", "testscatterplotter", "def", "test_scatterplot_smoke", "self", "wide_df", "wide_array", "flat_series", "flat_array", "flat_list", "wide_list_of_series", "wide_list_of_arrays", "wide_list_of_lists", "long_df", "missing_df", "object_df", "f", "ax", "plt", "subplots", "scatterplot", "x", "y", "ax", "clear", "scatterplot", "data", "wide_df", "ax", "clear", "scatterplot", "data", "wide_array", "ax", "clear", "scatterplot", "data", "wide_list_of_series", "ax", "clear", "scatterplot", "data", "wide_list_of_arrays", "ax", "clear", "scatterplot", "data", "wide_list_of_lists", "ax", "clear", "scatterplot", "data", "flat_series", "ax", "clear", "scatterplot", "data", "flat_array", "ax", "clear", "scatterplot", "data", "flat_list", "ax", "clear", "scatterplot", "x", "x", "y", "y", "data", "long_df", "ax", "clear", "scatterplot", "x", "long_df", "x", "y", "long_df", "y", "ax", "clear", "scatterplot", "x", "long_df", "x", "y", "y", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "long_df", "y", "to_numpy", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "style", "a", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "style", "b", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "style", "a", "data", "missing_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "style", "b", "data", "missing_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "size", "a", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "size", "s", "data", "long_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "size", "a", "data", "missing_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "a", "size", "s", "data", "missing_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "f", "data", "object_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "c", "size", "f", "data", "object_df", "ax", "clear", "scatterplot", "x", "x", "y", "y", "hue", "f", "size", "s", "data", "object_df", "ax", "clear"], "doc_len": 258}
{"doc_id": "tests/test_statistics.py::DistributionFixtures.x", "file_path": "tests/test_statistics.py", "class_name": "DistributionFixtures", "func_name": "x", "text": "文件路径: tests/test_statistics.py, 类名: DistributionFixtures\n    def x(self, rng):\n        return rng.normal(0, 1, 100)\n", "tokens": ["tests", "test_statistics", "py", "distributionfixtures", "def", "x", "self", "rng", "return", "rng", "normal", "0", "1", "100"], "doc_len": 14}
{"doc_id": "tests/test_statistics.py::DistributionFixtures.y", "file_path": "tests/test_statistics.py", "class_name": "DistributionFixtures", "func_name": "y", "text": "文件路径: tests/test_statistics.py, 类名: DistributionFixtures\n    def y(self, rng):\n        return rng.normal(0, 5, 100)\n", "tokens": ["tests", "test_statistics", "py", "distributionfixtures", "def", "y", "self", "rng", "return", "rng", "normal", "0", "5", "100"], "doc_len": 14}
{"doc_id": "tests/test_statistics.py::DistributionFixtures.weights", "file_path": "tests/test_statistics.py", "class_name": "DistributionFixtures", "func_name": "weights", "text": "文件路径: tests/test_statistics.py, 类名: DistributionFixtures\n    def weights(self, rng):\n        return rng.uniform(0, 5, 100)\n", "tokens": ["tests", "test_statistics", "py", "distributionfixtures", "def", "weights", "self", "rng", "return", "rng", "uniform", "0", "5", "100"], "doc_len": 14}
{"doc_id": "tests/test_statistics.py::TestKDE.integrate", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "integrate", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def integrate(self, y, x):\n        y = np.asarray(y)\n        x = np.asarray(x)\n        dx = np.diff(x)\n        return (dx * y[:-1] + dx * y[1:]).sum() / 2\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "integrate", "self", "y", "x", "y", "np", "asarray", "y", "x", "np", "asarray", "x", "dx", "np", "diff", "x", "return", "dx", "y", "1", "dx", "y", "1", "sum", "2"], "doc_len": 30}
{"doc_id": "tests/test_statistics.py::TestKDE.test_gridsize", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_gridsize", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_gridsize(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n\n        n = 200\n        kde = KDE(gridsize=n)\n        density, support = kde(x)\n        assert density.size == n\n        assert support.size == n\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_gridsize", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "n", "200", "kde", "kde", "gridsize", "n", "density", "support", "kde", "x", "assert", "density", "size", "n", "assert", "support", "size", "n"], "doc_len": 32}
{"doc_id": "tests/test_statistics.py::TestKDE.test_cut", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_cut", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_cut(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n\n        kde = KDE(cut=0)\n        _, support = kde(x)\n        assert support.min() == x.min()\n        assert support.max() == x.max()\n\n        cut = 2\n        bw_scale = .5\n        bw = x.std() * bw_scale\n        kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n        _, support = kde(x)\n        assert support.min() == pytest.approx(x.min() - bw * cut, abs=1e-2)\n        assert support.max() == pytest.approx(x.max() + bw * cut, abs=1e-2)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_cut", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "kde", "kde", "cut", "0", "_", "support", "kde", "x", "assert", "support", "min", "x", "min", "assert", "support", "max", "x", "max", "cut", "2", "bw_scale", "5", "bw", "x", "std", "bw_scale", "kde", "kde", "cut", "cut", "bw_method", "bw_scale", "gridsize", "1000", "_", "support", "kde", "x", "assert", "support", "min", "pytest", "approx", "x", "min", "bw", "cut", "abs", "1e", "2", "assert", "support", "max", "pytest", "approx", "x", "max", "bw", "cut", "abs", "1e", "2"], "doc_len": 76}
{"doc_id": "tests/test_statistics.py::TestKDE.test_clip", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_clip", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_clip(self, rng):\n\n        x = rng.normal(0, 3, 100)\n        clip = -1, 1\n        kde = KDE(clip=clip)\n        _, support = kde(x)\n\n        assert support.min() >= clip[0]\n        assert support.max() <= clip[1]\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_clip", "self", "rng", "x", "rng", "normal", "0", "3", "100", "clip", "1", "1", "kde", "kde", "clip", "clip", "_", "support", "kde", "x", "assert", "support", "min", "clip", "0", "assert", "support", "max", "clip", "1"], "doc_len": 35}
{"doc_id": "tests/test_statistics.py::TestKDE.test_density_normalization", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_density_normalization", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_density_normalization(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n        kde = KDE()\n        density, support = kde(x)\n        assert self.integrate(density, support) == pytest.approx(1, abs=1e-5)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_density_normalization", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "kde", "kde", "density", "support", "kde", "x", "assert", "self", "integrate", "density", "support", "pytest", "approx", "1", "abs", "1e", "5"], "doc_len": 31}
{"doc_id": "tests/test_statistics.py::TestKDE.test_cumulative", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_cumulative", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_cumulative(self, rng):\n\n        x = rng.normal(0, 3, 1000)\n        kde = KDE(cumulative=True)\n        density, _ = kde(x)\n        assert density[0] == pytest.approx(0, abs=1e-5)\n        assert density[-1] == pytest.approx(1, abs=1e-5)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_cumulative", "self", "rng", "x", "rng", "normal", "0", "3", "1000", "kde", "kde", "cumulative", "true", "density", "_", "kde", "x", "assert", "density", "0", "pytest", "approx", "0", "abs", "1e", "5", "assert", "density", "1", "pytest", "approx", "1", "abs", "1e", "5"], "doc_len": 40}
{"doc_id": "tests/test_statistics.py::TestKDE.test_cached_support", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_cached_support", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_cached_support(self, rng):\n\n        x = rng.normal(0, 3, 100)\n        kde = KDE()\n        kde.define_support(x)\n        _, support = kde(x[(x > -1) & (x < 1)])\n        assert_array_equal(support, kde.support)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_cached_support", "self", "rng", "x", "rng", "normal", "0", "3", "100", "kde", "kde", "kde", "define_support", "x", "_", "support", "kde", "x", "x", "1", "x", "1", "assert_array_equal", "support", "kde", "support"], "doc_len": 31}
{"doc_id": "tests/test_statistics.py::TestKDE.test_bw_method", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_bw_method", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_bw_method(self, rng):\n\n        x = rng.normal(0, 3, 100)\n        kde1 = KDE(bw_method=.2)\n        kde2 = KDE(bw_method=2)\n\n        d1, _ = kde1(x)\n        d2, _ = kde2(x)\n\n        assert np.abs(np.diff(d1)).mean() > np.abs(np.diff(d2)).mean()\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_bw_method", "self", "rng", "x", "rng", "normal", "0", "3", "100", "kde1", "kde", "bw_method", "2", "kde2", "kde", "bw_method", "2", "d1", "_", "kde1", "x", "d2", "_", "kde2", "x", "assert", "np", "abs", "np", "diff", "d1", "mean", "np", "abs", "np", "diff", "d2", "mean"], "doc_len": 43}
{"doc_id": "tests/test_statistics.py::TestKDE.test_bw_adjust", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_bw_adjust", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_bw_adjust(self, rng):\n\n        x = rng.normal(0, 3, 100)\n        kde1 = KDE(bw_adjust=.2)\n        kde2 = KDE(bw_adjust=2)\n\n        d1, _ = kde1(x)\n        d2, _ = kde2(x)\n\n        assert np.abs(np.diff(d1)).mean() > np.abs(np.diff(d2)).mean()\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_bw_adjust", "self", "rng", "x", "rng", "normal", "0", "3", "100", "kde1", "kde", "bw_adjust", "2", "kde2", "kde", "bw_adjust", "2", "d1", "_", "kde1", "x", "d2", "_", "kde2", "x", "assert", "np", "abs", "np", "diff", "d1", "mean", "np", "abs", "np", "diff", "d2", "mean"], "doc_len": 43}
{"doc_id": "tests/test_statistics.py::TestKDE.test_bivariate_grid", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_bivariate_grid", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_bivariate_grid(self, rng):\n\n        n = 100\n        x, y = rng.normal(0, 3, (2, 50))\n        kde = KDE(gridsize=n)\n        density, (xx, yy) = kde(x, y)\n\n        assert density.shape == (n, n)\n        assert xx.size == n\n        assert yy.size == n\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_bivariate_grid", "self", "rng", "n", "100", "x", "y", "rng", "normal", "0", "3", "2", "50", "kde", "kde", "gridsize", "n", "density", "xx", "yy", "kde", "x", "y", "assert", "density", "shape", "n", "n", "assert", "xx", "size", "n", "assert", "yy", "size", "n"], "doc_len": 41}
{"doc_id": "tests/test_statistics.py::TestKDE.test_bivariate_normalization", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_bivariate_normalization", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_bivariate_normalization(self, rng):\n\n        x, y = rng.normal(0, 3, (2, 50))\n        kde = KDE(gridsize=100)\n        density, (xx, yy) = kde(x, y)\n\n        dx = xx[1] - xx[0]\n        dy = yy[1] - yy[0]\n\n        total = density.sum() * (dx * dy)\n        assert total == pytest.approx(1, abs=1e-2)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_bivariate_normalization", "self", "rng", "x", "y", "rng", "normal", "0", "3", "2", "50", "kde", "kde", "gridsize", "100", "density", "xx", "yy", "kde", "x", "y", "dx", "xx", "1", "xx", "0", "dy", "yy", "1", "yy", "0", "total", "density", "sum", "dx", "dy", "assert", "total", "pytest", "approx", "1", "abs", "1e", "2"], "doc_len": 49}
{"doc_id": "tests/test_statistics.py::TestKDE.test_bivariate_cumulative", "file_path": "tests/test_statistics.py", "class_name": "TestKDE", "func_name": "test_bivariate_cumulative", "text": "文件路径: tests/test_statistics.py, 类名: TestKDE\n    def test_bivariate_cumulative(self, rng):\n\n        x, y = rng.normal(0, 3, (2, 50))\n        kde = KDE(gridsize=100, cumulative=True)\n        density, _ = kde(x, y)\n\n        assert density[0, 0] == pytest.approx(0, abs=1e-2)\n        assert density[-1, -1] == pytest.approx(1, abs=1e-2)\n", "tokens": ["tests", "test_statistics", "py", "testkde", "def", "test_bivariate_cumulative", "self", "rng", "x", "y", "rng", "normal", "0", "3", "2", "50", "kde", "kde", "gridsize", "100", "cumulative", "true", "density", "_", "kde", "x", "y", "assert", "density", "0", "0", "pytest", "approx", "0", "abs", "1e", "2", "assert", "density", "1", "1", "pytest", "approx", "1", "abs", "1e", "2"], "doc_len": 47}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_string_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_string_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_string_bins(self, x):\n\n        h = Histogram(bins=\"sqrt\")\n        bin_kws = h.define_bin_params(x)\n        assert bin_kws[\"range\"] == (x.min(), x.max())\n        assert bin_kws[\"bins\"] == int(np.sqrt(len(x)))\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_string_bins", "self", "x", "h", "histogram", "bins", "sqrt", "bin_kws", "h", "define_bin_params", "x", "assert", "bin_kws", "range", "x", "min", "x", "max", "assert", "bin_kws", "bins", "int", "np", "sqrt", "len", "x"], "doc_len": 31}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_int_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_int_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_int_bins(self, x):\n\n        n = 24\n        h = Histogram(bins=n)\n        bin_kws = h.define_bin_params(x)\n        assert bin_kws[\"range\"] == (x.min(), x.max())\n        assert bin_kws[\"bins\"] == n\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_int_bins", "self", "x", "n", "24", "h", "histogram", "bins", "n", "bin_kws", "h", "define_bin_params", "x", "assert", "bin_kws", "range", "x", "min", "x", "max", "assert", "bin_kws", "bins", "n"], "doc_len": 29}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_array_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_array_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_array_bins(self, x):\n\n        bins = [-3, -2, 1, 2, 3]\n        h = Histogram(bins=bins)\n        bin_kws = h.define_bin_params(x)\n        assert_array_equal(bin_kws[\"bins\"], bins)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_array_bins", "self", "x", "bins", "3", "2", "1", "2", "3", "h", "histogram", "bins", "bins", "bin_kws", "h", "define_bin_params", "x", "assert_array_equal", "bin_kws", "bins", "bins"], "doc_len": 26}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_string_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_string_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_string_bins(self, x, y):\n\n        s1, s2 = \"sqrt\", \"fd\"\n\n        h = Histogram(bins=s1)\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert_array_equal(e1, np.histogram_bin_edges(x, s1))\n        assert_array_equal(e2, np.histogram_bin_edges(y, s1))\n\n        h = Histogram(bins=(s1, s2))\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert_array_equal(e1, np.histogram_bin_edges(x, s1))\n        assert_array_equal(e2, np.histogram_bin_edges(y, s2))\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_string_bins", "self", "x", "y", "s1", "s2", "sqrt", "fd", "h", "histogram", "bins", "s1", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert_array_equal", "e1", "np", "histogram_bin_edges", "x", "s1", "assert_array_equal", "e2", "np", "histogram_bin_edges", "y", "s1", "h", "histogram", "bins", "s1", "s2", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert_array_equal", "e1", "np", "histogram_bin_edges", "x", "s1", "assert_array_equal", "e2", "np", "histogram_bin_edges", "y", "s2"], "doc_len": 60}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_int_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_int_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_int_bins(self, x, y):\n\n        b1, b2 = 5, 10\n\n        h = Histogram(bins=b1)\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert len(e1) == b1 + 1\n        assert len(e2) == b1 + 1\n\n        h = Histogram(bins=(b1, b2))\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert len(e1) == b1 + 1\n        assert len(e2) == b2 + 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_int_bins", "self", "x", "y", "b1", "b2", "5", "10", "h", "histogram", "bins", "b1", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "len", "e1", "b1", "1", "assert", "len", "e2", "b1", "1", "h", "histogram", "bins", "b1", "b2", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "len", "e1", "b1", "1", "assert", "len", "e2", "b2", "1"], "doc_len": 56}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_array_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_array_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_array_bins(self, x, y):\n\n        b1 = [-3, -2, 1, 2, 3]\n        b2 = [-5, -2, 3, 6]\n\n        h = Histogram(bins=b1)\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert_array_equal(e1, b1)\n        assert_array_equal(e2, b1)\n\n        h = Histogram(bins=(b1, b2))\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert_array_equal(e1, b1)\n        assert_array_equal(e2, b2)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_array_bins", "self", "x", "y", "b1", "3", "2", "1", "2", "3", "b2", "5", "2", "3", "6", "h", "histogram", "bins", "b1", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert_array_equal", "e1", "b1", "assert_array_equal", "e2", "b1", "h", "histogram", "bins", "b1", "b2", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert_array_equal", "e1", "b1", "assert_array_equal", "e2", "b2"], "doc_len": 55}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_binwidth", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_binwidth", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_binwidth(self, x):\n\n        binwidth = .5\n        h = Histogram(binwidth=binwidth)\n        bin_kws = h.define_bin_params(x)\n        n_bins = bin_kws[\"bins\"]\n        left, right = bin_kws[\"range\"]\n        assert (right - left) / n_bins == pytest.approx(binwidth)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_binwidth", "self", "x", "binwidth", "5", "h", "histogram", "binwidth", "binwidth", "bin_kws", "h", "define_bin_params", "x", "n_bins", "bin_kws", "bins", "left", "right", "bin_kws", "range", "assert", "right", "left", "n_bins", "pytest", "approx", "binwidth"], "doc_len": 32}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_binwidth", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_binwidth", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_binwidth(self, x, y):\n\n        w1, w2 = .5, 1\n\n        h = Histogram(binwidth=w1)\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert np.all(np.diff(e1) == w1)\n        assert np.all(np.diff(e2) == w1)\n\n        h = Histogram(binwidth=(w1, w2))\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert np.all(np.diff(e1) == w1)\n        assert np.all(np.diff(e2) == w2)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_binwidth", "self", "x", "y", "w1", "w2", "5", "1", "h", "histogram", "binwidth", "w1", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "np", "all", "np", "diff", "e1", "w1", "assert", "np", "all", "np", "diff", "e2", "w1", "h", "histogram", "binwidth", "w1", "w2", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "np", "all", "np", "diff", "e1", "w1", "assert", "np", "all", "np", "diff", "e2", "w2"], "doc_len": 64}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_binrange", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_binrange", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_binrange(self, x):\n\n        binrange = (-4, 4)\n        h = Histogram(binrange=binrange)\n        bin_kws = h.define_bin_params(x)\n        assert bin_kws[\"range\"] == binrange\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_binrange", "self", "x", "binrange", "4", "4", "h", "histogram", "binrange", "binrange", "bin_kws", "h", "define_bin_params", "x", "assert", "bin_kws", "range", "binrange"], "doc_len": 23}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_binrange", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_binrange", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_binrange(self, x, y):\n\n        r1, r2 = (-4, 4), (-10, 10)\n\n        h = Histogram(binrange=r1)\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert e1.min() == r1[0]\n        assert e1.max() == r1[1]\n        assert e2.min() == r1[0]\n        assert e2.max() == r1[1]\n\n        h = Histogram(binrange=(r1, r2))\n        e1, e2 = h.define_bin_params(x, y)[\"bins\"]\n        assert e1.min() == r1[0]\n        assert e1.max() == r1[1]\n        assert e2.min() == r2[0]\n        assert e2.max() == r2[1]\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_binrange", "self", "x", "y", "r1", "r2", "4", "4", "10", "10", "h", "histogram", "binrange", "r1", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "e1", "min", "r1", "0", "assert", "e1", "max", "r1", "1", "assert", "e2", "min", "r1", "0", "assert", "e2", "max", "r1", "1", "h", "histogram", "binrange", "r1", "r2", "e1", "e2", "h", "define_bin_params", "x", "y", "bins", "assert", "e1", "min", "r1", "0", "assert", "e1", "max", "r1", "1", "assert", "e2", "min", "r2", "0", "assert", "e2", "max", "r2", "1"], "doc_len": 78}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_discrete_bins", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_discrete_bins", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_discrete_bins(self, rng):\n\n        x = rng.binomial(20, .5, 100)\n        h = Histogram(discrete=True)\n        bin_kws = h.define_bin_params(x)\n        assert bin_kws[\"range\"] == (x.min() - .5, x.max() + .5)\n        assert bin_kws[\"bins\"] == (x.max() - x.min() + 1)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_discrete_bins", "self", "rng", "x", "rng", "binomial", "20", "5", "100", "h", "histogram", "discrete", "true", "bin_kws", "h", "define_bin_params", "x", "assert", "bin_kws", "range", "x", "min", "5", "x", "max", "5", "assert", "bin_kws", "bins", "x", "max", "x", "min", "1"], "doc_len": 39}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_odd_single_observation", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_odd_single_observation", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_odd_single_observation(self):\n        # GH2721\n        x = np.array([0.49928])\n        h, e = Histogram(binwidth=0.03)(x)\n        assert len(h) == 1\n        assert (e[1] - e[0]) == pytest.approx(.03)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_odd_single_observation", "self", "gh2721", "x", "np", "array", "0", "49928", "h", "e", "histogram", "binwidth", "0", "03", "x", "assert", "len", "h", "1", "assert", "e", "1", "e", "0", "pytest", "approx", "03"], "doc_len": 32}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_binwidth_roundoff", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_binwidth_roundoff", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_binwidth_roundoff(self):\n        # GH2785\n        x = np.array([2.4, 2.5, 2.6])\n        h, e = Histogram(binwidth=0.01)(x)\n        assert h.sum() == 3\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_binwidth_roundoff", "self", "gh2785", "x", "np", "array", "2", "4", "2", "5", "2", "6", "h", "e", "histogram", "binwidth", "0", "01", "x", "assert", "h", "sum", "3"], "doc_len": 28}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_histogram", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_histogram", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_histogram(self, x):\n\n        h = Histogram()\n        heights, edges = h(x)\n        heights_mpl, edges_mpl = np.histogram(x, bins=\"auto\")\n\n        assert_array_equal(heights, heights_mpl)\n        assert_array_equal(edges, edges_mpl)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_histogram", "self", "x", "h", "histogram", "heights", "edges", "h", "x", "heights_mpl", "edges_mpl", "np", "histogram", "x", "bins", "auto", "assert_array_equal", "heights", "heights_mpl", "assert_array_equal", "edges", "edges_mpl"], "doc_len": 27}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_count_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_count_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_count_stat(self, x):\n\n        h = Histogram(stat=\"count\")\n        heights, _ = h(x)\n        assert heights.sum() == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_count_stat", "self", "x", "h", "histogram", "stat", "count", "heights", "_", "h", "x", "assert", "heights", "sum", "len", "x"], "doc_len": 21}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_density_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_density_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_density_stat(self, x):\n\n        h = Histogram(stat=\"density\")\n        heights, edges = h(x)\n        assert (heights * np.diff(edges)).sum() == 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_density_stat", "self", "x", "h", "histogram", "stat", "density", "heights", "edges", "h", "x", "assert", "heights", "np", "diff", "edges", "sum", "1"], "doc_len": 23}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_probability_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_probability_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_probability_stat(self, x):\n\n        h = Histogram(stat=\"probability\")\n        heights, _ = h(x)\n        assert heights.sum() == 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_probability_stat", "self", "x", "h", "histogram", "stat", "probability", "heights", "_", "h", "x", "assert", "heights", "sum", "1"], "doc_len": 20}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_frequency_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_frequency_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_frequency_stat(self, x):\n\n        h = Histogram(stat=\"frequency\")\n        heights, edges = h(x)\n        assert (heights * np.diff(edges)).sum() == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_frequency_stat", "self", "x", "h", "histogram", "stat", "frequency", "heights", "edges", "h", "x", "assert", "heights", "np", "diff", "edges", "sum", "len", "x"], "doc_len": 24}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_cumulative_count", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_cumulative_count", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_cumulative_count(self, x):\n\n        h = Histogram(stat=\"count\", cumulative=True)\n        heights, _ = h(x)\n        assert heights[-1] == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_cumulative_count", "self", "x", "h", "histogram", "stat", "count", "cumulative", "true", "heights", "_", "h", "x", "assert", "heights", "1", "len", "x"], "doc_len": 23}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_cumulative_density", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_cumulative_density", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_cumulative_density(self, x):\n\n        h = Histogram(stat=\"density\", cumulative=True)\n        heights, _ = h(x)\n        assert heights[-1] == 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_cumulative_density", "self", "x", "h", "histogram", "stat", "density", "cumulative", "true", "heights", "_", "h", "x", "assert", "heights", "1", "1"], "doc_len": 22}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_cumulative_probability", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_cumulative_probability", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_cumulative_probability(self, x):\n\n        h = Histogram(stat=\"probability\", cumulative=True)\n        heights, _ = h(x)\n        assert heights[-1] == 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_cumulative_probability", "self", "x", "h", "histogram", "stat", "probability", "cumulative", "true", "heights", "_", "h", "x", "assert", "heights", "1", "1"], "doc_len": 22}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_cumulative_frequency", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_cumulative_frequency", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_cumulative_frequency(self, x):\n\n        h = Histogram(stat=\"frequency\", cumulative=True)\n        heights, _ = h(x)\n        assert heights[-1] == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_cumulative_frequency", "self", "x", "h", "histogram", "stat", "frequency", "cumulative", "true", "heights", "_", "h", "x", "assert", "heights", "1", "len", "x"], "doc_len": 23}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_histogram", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_histogram", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_histogram(self, x, y):\n\n        h = Histogram()\n        heights, edges = h(x, y)\n        bins_mpl = (\n            np.histogram_bin_edges(x, \"auto\"),\n            np.histogram_bin_edges(y, \"auto\"),\n        )\n        heights_mpl, *edges_mpl = np.histogram2d(x, y, bins_mpl)\n        assert_array_equal(heights, heights_mpl)\n        assert_array_equal(edges[0], edges_mpl[0])\n        assert_array_equal(edges[1], edges_mpl[1])\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_histogram", "self", "x", "y", "h", "histogram", "heights", "edges", "h", "x", "y", "bins_mpl", "np", "histogram_bin_edges", "x", "auto", "np", "histogram_bin_edges", "y", "auto", "heights_mpl", "edges_mpl", "np", "histogram2d", "x", "y", "bins_mpl", "assert_array_equal", "heights", "heights_mpl", "assert_array_equal", "edges", "0", "edges_mpl", "0", "assert_array_equal", "edges", "1", "edges_mpl", "1"], "doc_len": 45}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_count_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_count_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_count_stat(self, x, y):\n\n        h = Histogram(stat=\"count\")\n        heights, _ = h(x, y)\n        assert heights.sum() == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_count_stat", "self", "x", "y", "h", "histogram", "stat", "count", "heights", "_", "h", "x", "y", "assert", "heights", "sum", "len", "x"], "doc_len": 23}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_density_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_density_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_density_stat(self, x, y):\n\n        h = Histogram(stat=\"density\")\n        heights, (edges_x, edges_y) = h(x, y)\n        areas = np.outer(np.diff(edges_x), np.diff(edges_y))\n        assert (heights * areas).sum() == pytest.approx(1)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_density_stat", "self", "x", "y", "h", "histogram", "stat", "density", "heights", "edges_x", "edges_y", "h", "x", "y", "areas", "np", "outer", "np", "diff", "edges_x", "np", "diff", "edges_y", "assert", "heights", "areas", "sum", "pytest", "approx", "1"], "doc_len": 35}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_probability_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_probability_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_probability_stat(self, x, y):\n\n        h = Histogram(stat=\"probability\")\n        heights, _ = h(x, y)\n        assert heights.sum() == 1\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_probability_stat", "self", "x", "y", "h", "histogram", "stat", "probability", "heights", "_", "h", "x", "y", "assert", "heights", "sum", "1"], "doc_len": 22}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_frequency_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_frequency_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_frequency_stat(self, x, y):\n\n        h = Histogram(stat=\"frequency\")\n        heights, (x_edges, y_edges) = h(x, y)\n        area = np.outer(np.diff(x_edges), np.diff(y_edges))\n        assert (heights * area).sum() == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_frequency_stat", "self", "x", "y", "h", "histogram", "stat", "frequency", "heights", "x_edges", "y_edges", "h", "x", "y", "area", "np", "outer", "np", "diff", "x_edges", "np", "diff", "y_edges", "assert", "heights", "area", "sum", "len", "x"], "doc_len": 34}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_cumulative_count", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_cumulative_count", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_cumulative_count(self, x, y):\n\n        h = Histogram(stat=\"count\", cumulative=True)\n        heights, _ = h(x, y)\n        assert heights[-1, -1] == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_cumulative_count", "self", "x", "y", "h", "histogram", "stat", "count", "cumulative", "true", "heights", "_", "h", "x", "y", "assert", "heights", "1", "1", "len", "x"], "doc_len": 26}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_cumulative_density", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_cumulative_density", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_cumulative_density(self, x, y):\n\n        h = Histogram(stat=\"density\", cumulative=True)\n        heights, _ = h(x, y)\n        assert heights[-1, -1] == pytest.approx(1)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_cumulative_density", "self", "x", "y", "h", "histogram", "stat", "density", "cumulative", "true", "heights", "_", "h", "x", "y", "assert", "heights", "1", "1", "pytest", "approx", "1"], "doc_len": 27}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_cumulative_frequency", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_cumulative_frequency", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_cumulative_frequency(self, x, y):\n\n        h = Histogram(stat=\"frequency\", cumulative=True)\n        heights, _ = h(x, y)\n        assert heights[-1, -1] == len(x)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_cumulative_frequency", "self", "x", "y", "h", "histogram", "stat", "frequency", "cumulative", "true", "heights", "_", "h", "x", "y", "assert", "heights", "1", "1", "len", "x"], "doc_len": 26}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bivariate_cumulative_probability", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bivariate_cumulative_probability", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bivariate_cumulative_probability(self, x, y):\n\n        h = Histogram(stat=\"probability\", cumulative=True)\n        heights, _ = h(x, y)\n        assert heights[-1, -1] == pytest.approx(1)\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bivariate_cumulative_probability", "self", "x", "y", "h", "histogram", "stat", "probability", "cumulative", "true", "heights", "_", "h", "x", "y", "assert", "heights", "1", "1", "pytest", "approx", "1"], "doc_len": 27}
{"doc_id": "tests/test_statistics.py::TestHistogram.test_bad_stat", "file_path": "tests/test_statistics.py", "class_name": "TestHistogram", "func_name": "test_bad_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestHistogram\n    def test_bad_stat(self):\n\n        with pytest.raises(ValueError):\n            Histogram(stat=\"invalid\")\n", "tokens": ["tests", "test_statistics", "py", "testhistogram", "def", "test_bad_stat", "self", "with", "pytest", "raises", "valueerror", "histogram", "stat", "invalid"], "doc_len": 14}
{"doc_id": "tests/test_statistics.py::TestECDF.test_univariate_proportion", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_univariate_proportion", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_univariate_proportion(self, x):\n\n        ecdf = ECDF()\n        stat, vals = ecdf(x)\n        assert_array_equal(vals[1:], np.sort(x))\n        assert_array_almost_equal(stat[1:], np.linspace(0, 1, len(x) + 1)[1:])\n        assert stat[0] == 0\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_univariate_proportion", "self", "x", "ecdf", "ecdf", "stat", "vals", "ecdf", "x", "assert_array_equal", "vals", "1", "np", "sort", "x", "assert_array_almost_equal", "stat", "1", "np", "linspace", "0", "1", "len", "x", "1", "1", "assert", "stat", "0", "0"], "doc_len": 35}
{"doc_id": "tests/test_statistics.py::TestECDF.test_univariate_count", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_univariate_count", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_univariate_count(self, x):\n\n        ecdf = ECDF(stat=\"count\")\n        stat, vals = ecdf(x)\n\n        assert_array_equal(vals[1:], np.sort(x))\n        assert_array_almost_equal(stat[1:], np.arange(len(x)) + 1)\n        assert stat[0] == 0\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_univariate_count", "self", "x", "ecdf", "ecdf", "stat", "count", "stat", "vals", "ecdf", "x", "assert_array_equal", "vals", "1", "np", "sort", "x", "assert_array_almost_equal", "stat", "1", "np", "arange", "len", "x", "1", "assert", "stat", "0", "0"], "doc_len": 34}
{"doc_id": "tests/test_statistics.py::TestECDF.test_univariate_proportion_weights", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_univariate_proportion_weights", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_univariate_proportion_weights(self, x, weights):\n\n        ecdf = ECDF()\n        stat, vals = ecdf(x, weights=weights)\n        assert_array_equal(vals[1:], np.sort(x))\n        expected_stats = weights[x.argsort()].cumsum() / weights.sum()\n        assert_array_almost_equal(stat[1:], expected_stats)\n        assert stat[0] == 0\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_univariate_proportion_weights", "self", "x", "weights", "ecdf", "ecdf", "stat", "vals", "ecdf", "x", "weights", "weights", "assert_array_equal", "vals", "1", "np", "sort", "x", "expected_stats", "weights", "x", "argsort", "cumsum", "weights", "sum", "assert_array_almost_equal", "stat", "1", "expected_stats", "assert", "stat", "0", "0"], "doc_len": 38}
{"doc_id": "tests/test_statistics.py::TestECDF.test_univariate_count_weights", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_univariate_count_weights", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_univariate_count_weights(self, x, weights):\n\n        ecdf = ECDF(stat=\"count\")\n        stat, vals = ecdf(x, weights=weights)\n        assert_array_equal(vals[1:], np.sort(x))\n        assert_array_almost_equal(stat[1:], weights[x.argsort()].cumsum())\n        assert stat[0] == 0\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_univariate_count_weights", "self", "x", "weights", "ecdf", "ecdf", "stat", "count", "stat", "vals", "ecdf", "x", "weights", "weights", "assert_array_equal", "vals", "1", "np", "sort", "x", "assert_array_almost_equal", "stat", "1", "weights", "x", "argsort", "cumsum", "assert", "stat", "0", "0"], "doc_len": 36}
{"doc_id": "tests/test_statistics.py::TestECDF.test_against_statsmodels", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_against_statsmodels", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_against_statsmodels(self, x):\n\n        sm_ecdf = smdist.empirical_distribution.ECDF(x)\n\n        ecdf = ECDF()\n        stat, vals = ecdf(x)\n        assert_array_equal(vals, sm_ecdf.x)\n        assert_array_almost_equal(stat, sm_ecdf.y)\n\n        ecdf = ECDF(complementary=True)\n        stat, vals = ecdf(x)\n        assert_array_equal(vals, sm_ecdf.x)\n        assert_array_almost_equal(stat, sm_ecdf.y[::-1])\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_against_statsmodels", "self", "x", "sm_ecdf", "smdist", "empirical_distribution", "ecdf", "x", "ecdf", "ecdf", "stat", "vals", "ecdf", "x", "assert_array_equal", "vals", "sm_ecdf", "x", "assert_array_almost_equal", "stat", "sm_ecdf", "y", "ecdf", "ecdf", "complementary", "true", "stat", "vals", "ecdf", "x", "assert_array_equal", "vals", "sm_ecdf", "x", "assert_array_almost_equal", "stat", "sm_ecdf", "y", "1"], "doc_len": 44}
{"doc_id": "tests/test_statistics.py::TestECDF.test_invalid_stat", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_invalid_stat", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_invalid_stat(self, x):\n\n        with pytest.raises(ValueError, match=\"`stat` must be one of\"):\n            ECDF(stat=\"density\")\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_invalid_stat", "self", "x", "with", "pytest", "raises", "valueerror", "match", "stat", "must", "be", "one", "of", "ecdf", "stat", "density"], "doc_len": 21}
{"doc_id": "tests/test_statistics.py::TestECDF.test_bivariate_error", "file_path": "tests/test_statistics.py", "class_name": "TestECDF", "func_name": "test_bivariate_error", "text": "文件路径: tests/test_statistics.py, 类名: TestECDF\n    def test_bivariate_error(self, x, y):\n\n        with pytest.raises(NotImplementedError, match=\"Bivariate ECDF\"):\n            ecdf = ECDF()\n            ecdf(x, y)\n", "tokens": ["tests", "test_statistics", "py", "testecdf", "def", "test_bivariate_error", "self", "x", "y", "with", "pytest", "raises", "notimplementederror", "match", "bivariate", "ecdf", "ecdf", "ecdf", "ecdf", "x", "y"], "doc_len": 21}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_func_estimator", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_func_estimator", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_func_estimator(self, long_df):\n\n        func = np.mean\n        agg = EstimateAggregator(func)\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == func(long_df[\"x\"])\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_func_estimator", "self", "long_df", "func", "np", "mean", "agg", "estimateaggregator", "func", "out", "agg", "long_df", "x", "assert", "out", "x", "func", "long_df", "x"], "doc_len": 24}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_name_estimator", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_name_estimator", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_name_estimator(self, long_df):\n\n        agg = EstimateAggregator(\"mean\")\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == long_df[\"x\"].mean()\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_name_estimator", "self", "long_df", "agg", "estimateaggregator", "mean", "out", "agg", "long_df", "x", "assert", "out", "x", "long_df", "x", "mean"], "doc_len": 21}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_custom_func_estimator", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_custom_func_estimator", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_custom_func_estimator(self, long_df):\n\n        def func(x):\n            return np.asarray(x).min()\n\n        agg = EstimateAggregator(func)\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == func(long_df[\"x\"])\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_custom_func_estimator", "self", "long_df", "def", "func", "x", "return", "np", "asarray", "x", "min", "agg", "estimateaggregator", "func", "out", "agg", "long_df", "x", "assert", "out", "x", "func", "long_df", "x"], "doc_len": 29}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_se_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_se_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_se_errorbars(self, long_df):\n\n        agg = EstimateAggregator(\"mean\", \"se\")\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == long_df[\"x\"].mean()\n        assert out[\"xmin\"] == (long_df[\"x\"].mean() - long_df[\"x\"].sem())\n        assert out[\"xmax\"] == (long_df[\"x\"].mean() + long_df[\"x\"].sem())\n\n        agg = EstimateAggregator(\"mean\", (\"se\", 2))\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == long_df[\"x\"].mean()\n        assert out[\"xmin\"] == (long_df[\"x\"].mean() - 2 * long_df[\"x\"].sem())\n        assert out[\"xmax\"] == (long_df[\"x\"].mean() + 2 * long_df[\"x\"].sem())\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_se_errorbars", "self", "long_df", "agg", "estimateaggregator", "mean", "se", "out", "agg", "long_df", "x", "assert", "out", "x", "long_df", "x", "mean", "assert", "out", "xmin", "long_df", "x", "mean", "long_df", "x", "sem", "assert", "out", "xmax", "long_df", "x", "mean", "long_df", "x", "sem", "agg", "estimateaggregator", "mean", "se", "2", "out", "agg", "long_df", "x", "assert", "out", "x", "long_df", "x", "mean", "assert", "out", "xmin", "long_df", "x", "mean", "2", "long_df", "x", "sem", "assert", "out", "xmax", "long_df", "x", "mean", "2", "long_df", "x", "sem"], "doc_len": 75}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_sd_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_sd_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_sd_errorbars(self, long_df):\n\n        agg = EstimateAggregator(\"mean\", \"sd\")\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == long_df[\"x\"].mean()\n        assert out[\"xmin\"] == (long_df[\"x\"].mean() - long_df[\"x\"].std())\n        assert out[\"xmax\"] == (long_df[\"x\"].mean() + long_df[\"x\"].std())\n\n        agg = EstimateAggregator(\"mean\", (\"sd\", 2))\n        out = agg(long_df, \"x\")\n        assert out[\"x\"] == long_df[\"x\"].mean()\n        assert out[\"xmin\"] == (long_df[\"x\"].mean() - 2 * long_df[\"x\"].std())\n        assert out[\"xmax\"] == (long_df[\"x\"].mean() + 2 * long_df[\"x\"].std())\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_sd_errorbars", "self", "long_df", "agg", "estimateaggregator", "mean", "sd", "out", "agg", "long_df", "x", "assert", "out", "x", "long_df", "x", "mean", "assert", "out", "xmin", "long_df", "x", "mean", "long_df", "x", "std", "assert", "out", "xmax", "long_df", "x", "mean", "long_df", "x", "std", "agg", "estimateaggregator", "mean", "sd", "2", "out", "agg", "long_df", "x", "assert", "out", "x", "long_df", "x", "mean", "assert", "out", "xmin", "long_df", "x", "mean", "2", "long_df", "x", "std", "assert", "out", "xmax", "long_df", "x", "mean", "2", "long_df", "x", "std"], "doc_len": 75}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_pi_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_pi_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_pi_errorbars(self, long_df):\n\n        agg = EstimateAggregator(\"mean\", \"pi\")\n        out = agg(long_df, \"y\")\n        assert out[\"ymin\"] == np.percentile(long_df[\"y\"], 2.5)\n        assert out[\"ymax\"] == np.percentile(long_df[\"y\"], 97.5)\n\n        agg = EstimateAggregator(\"mean\", (\"pi\", 50))\n        out = agg(long_df, \"y\")\n        assert out[\"ymin\"] == np.percentile(long_df[\"y\"], 25)\n        assert out[\"ymax\"] == np.percentile(long_df[\"y\"], 75)\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_pi_errorbars", "self", "long_df", "agg", "estimateaggregator", "mean", "pi", "out", "agg", "long_df", "y", "assert", "out", "ymin", "np", "percentile", "long_df", "y", "2", "5", "assert", "out", "ymax", "np", "percentile", "long_df", "y", "97", "5", "agg", "estimateaggregator", "mean", "pi", "50", "out", "agg", "long_df", "y", "assert", "out", "ymin", "np", "percentile", "long_df", "y", "25", "assert", "out", "ymax", "np", "percentile", "long_df", "y", "75"], "doc_len": 59}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_ci_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_ci_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_ci_errorbars(self, long_df):\n\n        agg = EstimateAggregator(\"mean\", \"ci\", n_boot=100000, seed=0)\n        out = agg(long_df, \"y\")\n\n        agg_ref = EstimateAggregator(\"mean\", (\"se\", 1.96))\n        out_ref = agg_ref(long_df, \"y\")\n\n        assert out[\"ymin\"] == pytest.approx(out_ref[\"ymin\"], abs=1e-2)\n        assert out[\"ymax\"] == pytest.approx(out_ref[\"ymax\"], abs=1e-2)\n\n        agg = EstimateAggregator(\"mean\", (\"ci\", 68), n_boot=100000, seed=0)\n        out = agg(long_df, \"y\")\n\n        agg_ref = EstimateAggregator(\"mean\", (\"se\", 1))\n        out_ref = agg_ref(long_df, \"y\")\n\n        assert out[\"ymin\"] == pytest.approx(out_ref[\"ymin\"], abs=1e-2)\n        assert out[\"ymax\"] == pytest.approx(out_ref[\"ymax\"], abs=1e-2)\n\n        agg = EstimateAggregator(\"mean\", \"ci\", seed=0)\n        out_orig = agg_ref(long_df, \"y\")\n        out_test = agg_ref(long_df, \"y\")\n        assert_array_equal(out_orig, out_test)\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_ci_errorbars", "self", "long_df", "agg", "estimateaggregator", "mean", "ci", "n_boot", "100000", "seed", "0", "out", "agg", "long_df", "y", "agg_ref", "estimateaggregator", "mean", "se", "1", "96", "out_ref", "agg_ref", "long_df", "y", "assert", "out", "ymin", "pytest", "approx", "out_ref", "ymin", "abs", "1e", "2", "assert", "out", "ymax", "pytest", "approx", "out_ref", "ymax", "abs", "1e", "2", "agg", "estimateaggregator", "mean", "ci", "68", "n_boot", "100000", "seed", "0", "out", "agg", "long_df", "y", "agg_ref", "estimateaggregator", "mean", "se", "1", "out_ref", "agg_ref", "long_df", "y", "assert", "out", "ymin", "pytest", "approx", "out_ref", "ymin", "abs", "1e", "2", "assert", "out", "ymax", "pytest", "approx", "out_ref", "ymax", "abs", "1e", "2", "agg", "estimateaggregator", "mean", "ci", "seed", "0", "out_orig", "agg_ref", "long_df", "y", "out_test", "agg_ref", "long_df", "y", "assert_array_equal", "out_orig", "out_test"], "doc_len": 109}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_custom_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_custom_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_custom_errorbars(self, long_df):\n\n        f = lambda x: (x.min(), x.max())  # noqa: E731\n        agg = EstimateAggregator(\"mean\", f)\n        out = agg(long_df, \"y\")\n        assert out[\"ymin\"] == long_df[\"y\"].min()\n        assert out[\"ymax\"] == long_df[\"y\"].max()\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_custom_errorbars", "self", "long_df", "f", "lambda", "x", "x", "min", "x", "max", "noqa", "e731", "agg", "estimateaggregator", "mean", "f", "out", "agg", "long_df", "y", "assert", "out", "ymin", "long_df", "y", "min", "assert", "out", "ymax", "long_df", "y", "max"], "doc_len": 37}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_singleton_errorbars", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_singleton_errorbars", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_singleton_errorbars(self):\n\n        agg = EstimateAggregator(\"mean\", \"ci\")\n        val = 7\n        out = agg(pd.DataFrame(dict(y=[val])), \"y\")\n        assert out[\"y\"] == val\n        assert pd.isna(out[\"ymin\"])\n        assert pd.isna(out[\"ymax\"])\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_singleton_errorbars", "self", "agg", "estimateaggregator", "mean", "ci", "val", "7", "out", "agg", "pd", "dataframe", "dict", "y", "val", "y", "assert", "out", "y", "val", "assert", "pd", "isna", "out", "ymin", "assert", "pd", "isna", "out", "ymax"], "doc_len": 35}
{"doc_id": "tests/test_statistics.py::TestEstimateAggregator.test_errorbar_validation", "file_path": "tests/test_statistics.py", "class_name": "TestEstimateAggregator", "func_name": "test_errorbar_validation", "text": "文件路径: tests/test_statistics.py, 类名: TestEstimateAggregator\n    def test_errorbar_validation(self):\n\n        method, level = _validate_errorbar_arg((\"ci\", 99))\n        assert method == \"ci\"\n        assert level == 99\n\n        method, level = _validate_errorbar_arg(\"sd\")\n        assert method == \"sd\"\n        assert level == 1\n\n        f = lambda x: (x.min(), x.max())  # noqa: E731\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n\n        bad_args = [\n            (\"sem\", ValueError),\n            ((\"std\", 2), ValueError),\n            ((\"pi\", 5, 95), ValueError),\n            (95, TypeError),\n            ((\"ci\", \"large\"), TypeError),\n        ]\n\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match=\"`errorbar` must be\"):\n                _validate_errorbar_arg(arg)\n", "tokens": ["tests", "test_statistics", "py", "testestimateaggregator", "def", "test_errorbar_validation", "self", "method", "level", "_validate_errorbar_arg", "ci", "99", "assert", "method", "ci", "assert", "level", "99", "method", "level", "_validate_errorbar_arg", "sd", "assert", "method", "sd", "assert", "level", "1", "f", "lambda", "x", "x", "min", "x", "max", "noqa", "e731", "method", "level", "_validate_errorbar_arg", "f", "assert", "method", "is", "f", "assert", "level", "is", "none", "bad_args", "sem", "valueerror", "std", "2", "valueerror", "pi", "5", "95", "valueerror", "95", "typeerror", "ci", "large", "typeerror", "for", "arg", "exception", "in", "bad_args", "with", "pytest", "raises", "exception", "match", "errorbar", "must", "be", "_validate_errorbar_arg", "arg"], "doc_len": 79}
{"doc_id": "tests/test_utils.py::_network", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "_network", "text": "文件路径: tests/test_utils.py\ndef _network(t=None, url=\"https://github.com\"):\n    \"\"\"\n    Decorator that will skip a test if `url` is unreachable.\n\n    Parameters\n    ----------\n    t : function, optional\n    url : str, optional\n\n    \"\"\"\n    if t is None:\n        return lambda x: _network(x, url=url)\n\n    def wrapper(*args, **kwargs):\n        # attempt to connect\n        try:\n            f = urlopen(url)\n        except (OSError, HTTPException):\n            pytest.skip(\"No internet connection\")\n        else:\n            f.close()\n            return t(*args, **kwargs)\n    return wrapper\n", "tokens": ["tests", "test_utils", "py", "def", "_network", "t", "none", "url", "https", "github", "com", "decorator", "that", "will", "skip", "a", "test", "if", "url", "is", "unreachable", "parameters", "t", "function", "optional", "url", "str", "optional", "if", "t", "is", "none", "return", "lambda", "x", "_network", "x", "url", "url", "def", "wrapper", "args", "kwargs", "attempt", "to", "connect", "try", "f", "urlopen", "url", "except", "oserror", "httpexception", "pytest", "skip", "no", "internet", "connection", "else", "f", "close", "return", "t", "args", "kwargs", "return", "wrapper"], "doc_len": 67}
{"doc_id": "tests/test_utils.py::test_ci_to_errsize", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_ci_to_errsize", "text": "文件路径: tests/test_utils.py\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[.5, .5],\n           [1.25, 1.5]]\n\n    heights = [1, 1.5]\n\n    actual_errsize = np.array([[.5, 1],\n                               [.25, 0]])\n\n    test_errsize = utils.ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n", "tokens": ["tests", "test_utils", "py", "def", "test_ci_to_errsize", "test", "behavior", "of", "ci_to_errsize", "cis", "5", "5", "1", "25", "1", "5", "heights", "1", "1", "5", "actual_errsize", "np", "array", "5", "1", "25", "0", "test_errsize", "utils", "ci_to_errsize", "cis", "heights", "assert_array_equal", "actual_errsize", "test_errsize"], "doc_len": 35}
{"doc_id": "tests/test_utils.py::test_desaturate", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_desaturate", "text": "文件路径: tests/test_utils.py\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = utils.desaturate(\"red\", .5)\n    assert out1 == (.75, .25, .25)\n\n    out2 = utils.desaturate(\"#00FF00\", .5)\n    assert out2 == (.25, .75, .25)\n\n    out3 = utils.desaturate((0, 0, 1), .5)\n    assert out3 == (.25, .25, .75)\n\n    out4 = utils.desaturate(\"red\", .5)\n    assert out4 == (.75, .25, .25)\n", "tokens": ["tests", "test_utils", "py", "def", "test_desaturate", "test", "color", "desaturation", "out1", "utils", "desaturate", "red", "5", "assert", "out1", "75", "25", "25", "out2", "utils", "desaturate", "00ff00", "5", "assert", "out2", "25", "75", "25", "out3", "utils", "desaturate", "0", "0", "1", "5", "assert", "out3", "25", "25", "75", "out4", "utils", "desaturate", "red", "5", "assert", "out4", "75", "25", "25"], "doc_len": 50}
{"doc_id": "tests/test_utils.py::test_desaturation_prop", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_desaturation_prop", "text": "文件路径: tests/test_utils.py\ndef test_desaturation_prop():\n    \"\"\"Test that pct outside of [0, 1] raises exception.\"\"\"\n    with pytest.raises(ValueError):\n        utils.desaturate(\"blue\", 50)\n", "tokens": ["tests", "test_utils", "py", "def", "test_desaturation_prop", "test", "that", "pct", "outside", "of", "0", "1", "raises", "exception", "with", "pytest", "raises", "valueerror", "utils", "desaturate", "blue", "50"], "doc_len": 22}
{"doc_id": "tests/test_utils.py::test_saturate", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_saturate", "text": "文件路径: tests/test_utils.py\ndef test_saturate():\n    \"\"\"Test performance of saturation function.\"\"\"\n    out = utils.saturate((.75, .25, .25))\n    assert out == (1, 0, 0)\n", "tokens": ["tests", "test_utils", "py", "def", "test_saturate", "test", "performance", "of", "saturation", "function", "out", "utils", "saturate", "75", "25", "25", "assert", "out", "1", "0", "0"], "doc_len": 21}
{"doc_id": "tests/test_utils.py::test_to_utf8", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_to_utf8", "text": "文件路径: tests/test_utils.py\ndef test_to_utf8(s, exp):\n    \"\"\"Test the to_utf8 function: object to string\"\"\"\n    u = utils.to_utf8(s)\n    assert type(u) == str\n    assert u == exp\n", "tokens": ["tests", "test_utils", "py", "def", "test_to_utf8", "s", "exp", "test", "the", "to_utf8", "function", "object", "to", "string", "u", "utils", "to_utf8", "s", "assert", "type", "u", "str", "assert", "u", "exp"], "doc_len": 25}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine(self):\n        f, ax = plt.subplots()\n        for side in self.sides:\n            assert ax.spines[side].get_visible()\n\n        utils.despine()\n        for side in self.outer_sides:\n            assert ~ax.spines[side].get_visible()\n        for side in self.inner_sides:\n            assert ax.spines[side].get_visible()\n\n        utils.despine(**dict(zip(self.sides, [True] * 4)))\n        for side in self.sides:\n            assert ~ax.spines[side].get_visible()\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine", "self", "f", "ax", "plt", "subplots", "for", "side", "in", "self", "sides", "assert", "ax", "spines", "side", "get_visible", "utils", "despine", "for", "side", "in", "self", "outer_sides", "assert", "ax", "spines", "side", "get_visible", "for", "side", "in", "self", "inner_sides", "assert", "ax", "spines", "side", "get_visible", "utils", "despine", "dict", "zip", "self", "sides", "true", "4", "for", "side", "in", "self", "sides", "assert", "ax", "spines", "side", "get_visible"], "doc_len": 61}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_specific_axes", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_specific_axes", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_specific_axes(self):\n        f, (ax1, ax2) = plt.subplots(2, 1)\n\n        utils.despine(ax=ax2)\n\n        for side in self.sides:\n            assert ax1.spines[side].get_visible()\n\n        for side in self.outer_sides:\n            assert ~ax2.spines[side].get_visible()\n        for side in self.inner_sides:\n            assert ax2.spines[side].get_visible()\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_specific_axes", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "1", "utils", "despine", "ax", "ax2", "for", "side", "in", "self", "sides", "assert", "ax1", "spines", "side", "get_visible", "for", "side", "in", "self", "outer_sides", "assert", "ax2", "spines", "side", "get_visible", "for", "side", "in", "self", "inner_sides", "assert", "ax2", "spines", "side", "get_visible"], "doc_len": 48}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_with_offset", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_with_offset", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_with_offset(self):\n        f, ax = plt.subplots()\n\n        for side in self.sides:\n            pos = ax.spines[side].get_position()\n            assert pos == self.original_position\n\n        utils.despine(ax=ax, offset=self.offset)\n\n        for side in self.sides:\n            is_visible = ax.spines[side].get_visible()\n            new_position = ax.spines[side].get_position()\n            if is_visible:\n                assert new_position == self.offset_position\n            else:\n                assert new_position == self.original_position\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_with_offset", "self", "f", "ax", "plt", "subplots", "for", "side", "in", "self", "sides", "pos", "ax", "spines", "side", "get_position", "assert", "pos", "self", "original_position", "utils", "despine", "ax", "ax", "offset", "self", "offset", "for", "side", "in", "self", "sides", "is_visible", "ax", "spines", "side", "get_visible", "new_position", "ax", "spines", "side", "get_position", "if", "is_visible", "assert", "new_position", "self", "offset_position", "else", "assert", "new_position", "self", "original_position"], "doc_len": 58}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_side_specific_offset", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_side_specific_offset", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_side_specific_offset(self):\n\n        f, ax = plt.subplots()\n        utils.despine(ax=ax, offset=dict(left=self.offset))\n\n        for side in self.sides:\n            is_visible = ax.spines[side].get_visible()\n            new_position = ax.spines[side].get_position()\n            if is_visible and side == \"left\":\n                assert new_position == self.offset_position\n            else:\n                assert new_position == self.original_position\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_side_specific_offset", "self", "f", "ax", "plt", "subplots", "utils", "despine", "ax", "ax", "offset", "dict", "left", "self", "offset", "for", "side", "in", "self", "sides", "is_visible", "ax", "spines", "side", "get_visible", "new_position", "ax", "spines", "side", "get_position", "if", "is_visible", "and", "side", "left", "assert", "new_position", "self", "offset_position", "else", "assert", "new_position", "self", "original_position"], "doc_len": 49}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_with_offset_specific_axes", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_with_offset_specific_axes", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_with_offset_specific_axes(self):\n        f, (ax1, ax2) = plt.subplots(2, 1)\n\n        utils.despine(offset=self.offset, ax=ax2)\n\n        for side in self.sides:\n            pos1 = ax1.spines[side].get_position()\n            pos2 = ax2.spines[side].get_position()\n            assert pos1 == self.original_position\n            if ax2.spines[side].get_visible():\n                assert pos2 == self.offset_position\n            else:\n                assert pos2 == self.original_position\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_with_offset_specific_axes", "self", "f", "ax1", "ax2", "plt", "subplots", "2", "1", "utils", "despine", "offset", "self", "offset", "ax", "ax2", "for", "side", "in", "self", "sides", "pos1", "ax1", "spines", "side", "get_position", "pos2", "ax2", "spines", "side", "get_position", "assert", "pos1", "self", "original_position", "if", "ax2", "spines", "side", "get_visible", "assert", "pos2", "self", "offset_position", "else", "assert", "pos2", "self", "original_position"], "doc_len": 54}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_trim_spines", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_trim_spines", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_trim_spines(self):\n\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_xlim(.75, 3.25)\n\n        utils.despine(trim=True)\n        for side in self.inner_sides:\n            bounds = ax.spines[side].get_bounds()\n            assert bounds == (1, 3)\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_trim_spines", "self", "f", "ax", "plt", "subplots", "ax", "plot", "1", "2", "3", "1", "2", "3", "ax", "set_xlim", "75", "3", "25", "utils", "despine", "trim", "true", "for", "side", "in", "self", "inner_sides", "bounds", "ax", "spines", "side", "get_bounds", "assert", "bounds", "1", "3"], "doc_len": 42}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_trim_inverted", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_trim_inverted", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_trim_inverted(self):\n\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_ylim(.85, 3.15)\n        ax.invert_yaxis()\n\n        utils.despine(trim=True)\n        for side in self.inner_sides:\n            bounds = ax.spines[side].get_bounds()\n            assert bounds == (1, 3)\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_trim_inverted", "self", "f", "ax", "plt", "subplots", "ax", "plot", "1", "2", "3", "1", "2", "3", "ax", "set_ylim", "85", "3", "15", "ax", "invert_yaxis", "utils", "despine", "trim", "true", "for", "side", "in", "self", "inner_sides", "bounds", "ax", "spines", "side", "get_bounds", "assert", "bounds", "1", "3"], "doc_len": 44}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_trim_noticks", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_trim_noticks", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_trim_noticks(self):\n\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        utils.despine(trim=True)\n        assert ax.get_yticks().size == 0\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_trim_noticks", "self", "f", "ax", "plt", "subplots", "ax", "plot", "1", "2", "3", "1", "2", "3", "ax", "set_yticks", "utils", "despine", "trim", "true", "assert", "ax", "get_yticks", "size", "0"], "doc_len": 30}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_trim_categorical", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_trim_categorical", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_trim_categorical(self):\n\n        f, ax = plt.subplots()\n        ax.plot([\"a\", \"b\", \"c\"], [1, 2, 3])\n\n        utils.despine(trim=True)\n\n        bounds = ax.spines[\"left\"].get_bounds()\n        assert bounds == (1, 3)\n\n        bounds = ax.spines[\"bottom\"].get_bounds()\n        assert bounds == (0, 2)\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_trim_categorical", "self", "f", "ax", "plt", "subplots", "ax", "plot", "a", "b", "c", "1", "2", "3", "utils", "despine", "trim", "true", "bounds", "ax", "spines", "left", "get_bounds", "assert", "bounds", "1", "3", "bounds", "ax", "spines", "bottom", "get_bounds", "assert", "bounds", "0", "2"], "doc_len": 41}
{"doc_id": "tests/test_utils.py::TestSpineUtils.test_despine_moved_ticks", "file_path": "tests/test_utils.py", "class_name": "TestSpineUtils", "func_name": "test_despine_moved_ticks", "text": "文件路径: tests/test_utils.py, 类名: TestSpineUtils\n    def test_despine_moved_ticks(self):\n\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        utils.despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        utils.despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        utils.despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        utils.despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n", "tokens": ["tests", "test_utils", "py", "testspineutils", "def", "test_despine_moved_ticks", "self", "f", "ax", "plt", "subplots", "for", "t", "in", "ax", "yaxis", "majorticks", "t", "tick1line", "set_visible", "true", "utils", "despine", "ax", "ax", "left", "true", "right", "false", "for", "t", "in", "ax", "yaxis", "majorticks", "assert", "t", "tick2line", "get_visible", "plt", "close", "f", "f", "ax", "plt", "subplots", "for", "t", "in", "ax", "yaxis", "majorticks", "t", "tick1line", "set_visible", "false", "utils", "despine", "ax", "ax", "left", "true", "right", "false", "for", "t", "in", "ax", "yaxis", "majorticks", "assert", "not", "t", "tick2line", "get_visible", "plt", "close", "f", "f", "ax", "plt", "subplots", "for", "t", "in", "ax", "xaxis", "majorticks", "t", "tick1line", "set_visible", "true", "utils", "despine", "ax", "ax", "bottom", "true", "top", "false", "for", "t", "in", "ax", "xaxis", "majorticks", "assert", "t", "tick2line", "get_visible", "plt", "close", "f", "f", "ax", "plt", "subplots", "for", "t", "in", "ax", "xaxis", "majorticks", "t", "tick1line", "set_visible", "false", "utils", "despine", "ax", "ax", "bottom", "true", "top", "false", "for", "t", "in", "ax", "xaxis", "majorticks", "assert", "not", "t", "tick2line", "get_visible", "plt", "close", "f"], "doc_len": 149}
{"doc_id": "tests/test_utils.py::test_ticklabels_overlap", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_ticklabels_overlap", "text": "文件路径: tests/test_utils.py\ndef test_ticklabels_overlap():\n\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()  # This gets the Agg renderer working\n\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n\n    big_strings = \"abcdefgh\", \"ijklmnop\"\n    ax.set_xlim(-.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n", "tokens": ["tests", "test_utils", "py", "def", "test_ticklabels_overlap", "rcmod", "set", "f", "ax", "plt", "subplots", "figsize", "2", "2", "f", "tight_layout", "this", "gets", "the", "agg", "renderer", "working", "assert", "not", "utils", "axis_ticklabels_overlap", "ax", "get_xticklabels", "big_strings", "abcdefgh", "ijklmnop", "ax", "set_xlim", "5", "1", "5", "ax", "set_xticks", "0", "1", "ax", "set_xticklabels", "big_strings", "assert", "utils", "axis_ticklabels_overlap", "ax", "get_xticklabels", "x", "y", "utils", "axes_ticklabels_overlap", "ax", "assert", "x", "assert", "not", "y"], "doc_len": 58}
{"doc_id": "tests/test_utils.py::test_locator_to_legend_entries", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_locator_to_legend_entries", "text": "文件路径: tests/test_utils.py\ndef test_locator_to_legend_entries():\n\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = (0.09, 0.4)\n    levels, str_levels = utils.locator_to_legend_entries(\n        locator, limits, float\n    )\n    assert str_levels == [\"0.15\", \"0.30\"]\n\n    limits = (0.8, 0.9)\n    levels, str_levels = utils.locator_to_legend_entries(\n        locator, limits, float\n    )\n    assert str_levels == [\"0.80\", \"0.84\", \"0.88\"]\n\n    limits = (1, 6)\n    levels, str_levels = utils.locator_to_legend_entries(locator, limits, int)\n    assert str_levels == [\"2\", \"4\", \"6\"]\n\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = (5, 1425)\n    levels, str_levels = utils.locator_to_legend_entries(locator, limits, int)\n    if Version(mpl.__version__) >= Version(\"3.1\"):\n        assert str_levels == ['10', '100', '1000']\n\n    limits = (0.00003, 0.02)\n    _, str_levels = utils.locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        # Use regex as mpl switched to minus sign, not hyphen, in 3.6\n        assert re.match(f\"1e.0{exp}\", str_levels[i])\n", "tokens": ["tests", "test_utils", "py", "def", "test_locator_to_legend_entries", "locator", "mpl", "ticker", "maxnlocator", "nbins", "3", "limits", "0", "09", "0", "4", "levels", "str_levels", "utils", "locator_to_legend_entries", "locator", "limits", "float", "assert", "str_levels", "0", "15", "0", "30", "limits", "0", "8", "0", "9", "levels", "str_levels", "utils", "locator_to_legend_entries", "locator", "limits", "float", "assert", "str_levels", "0", "80", "0", "84", "0", "88", "limits", "1", "6", "levels", "str_levels", "utils", "locator_to_legend_entries", "locator", "limits", "int", "assert", "str_levels", "2", "4", "6", "locator", "mpl", "ticker", "loglocator", "numticks", "5", "limits", "5", "1425", "levels", "str_levels", "utils", "locator_to_legend_entries", "locator", "limits", "int", "if", "version", "mpl", "__version__", "version", "3", "1", "assert", "str_levels", "10", "100", "1000", "limits", "0", "00003", "0", "02", "_", "str_levels", "utils", "locator_to_legend_entries", "locator", "limits", "float", "for", "i", "exp", "in", "enumerate", "4", "3", "2", "use", "regex", "as", "mpl", "switched", "to", "minus", "sign", "not", "hyphen", "in", "3", "6", "assert", "re", "match", "f", "1e", "0", "exp", "str_levels", "i"], "doc_len": 134}
{"doc_id": "tests/test_utils.py::test_move_legend_matplotlib_objects", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_move_legend_matplotlib_objects", "text": "文件路径: tests/test_utils.py\ndef test_move_legend_matplotlib_objects():\n\n    fig, ax = plt.subplots()\n\n    colors = \"C2\", \"C5\"\n    labels = \"first label\", \"second label\"\n    title = \"the legend\"\n\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc=\"upper right\", title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n\n    # --- Test axes legend\n\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n\n    new_fontsize = 14\n    utils.move_legend(ax, \"lower left\", title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n\n    # --- Test title replacement\n\n    new_title = \"new title\"\n    utils.move_legend(ax, \"lower left\", title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n\n    # --- Test figure legend\n\n    fig.legend(loc=\"upper right\", title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n\n    utils.move_legend(fig, \"lower left\", title=new_title)\n    _draw_figure(fig)\n\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n", "tokens": ["tests", "test_utils", "py", "def", "test_move_legend_matplotlib_objects", "fig", "ax", "plt", "subplots", "colors", "c2", "c5", "labels", "first", "label", "second", "label", "title", "the", "legend", "for", "color", "label", "in", "zip", "colors", "labels", "ax", "plot", "0", "1", "color", "color", "label", "label", "ax", "legend", "loc", "upper", "right", "title", "title", "utils", "_draw_figure", "fig", "xfm", "ax", "transaxes", "inverted", "transform", "test", "axes", "legend", "old_pos", "xfm", "ax", "legend_", "legendpatch", "get_extents", "new_fontsize", "14", "utils", "move_legend", "ax", "lower", "left", "title_fontsize", "new_fontsize", "utils", "_draw_figure", "fig", "new_pos", "xfm", "ax", "legend_", "legendpatch", "get_extents", "assert", "new_pos", "old_pos", "all", "assert", "ax", "legend_", "get_title", "get_text", "title", "assert", "ax", "legend_", "get_title", "get_size", "new_fontsize", "test", "title", "replacement", "new_title", "new", "title", "utils", "move_legend", "ax", "lower", "left", "title", "new_title", "utils", "_draw_figure", "fig", "assert", "ax", "legend_", "get_title", "get_text", "new_title", "test", "figure", "legend", "fig", "legend", "loc", "upper", "right", "title", "title", "_draw_figure", "fig", "xfm", "fig", "transfigure", "inverted", "transform", "old_pos", "xfm", "fig", "legends", "0", "legendpatch", "get_extents", "utils", "move_legend", "fig", "lower", "left", "title", "new_title", "_draw_figure", "fig", "new_pos", "xfm", "fig", "legends", "0", "legendpatch", "get_extents", "assert", "new_pos", "old_pos", "all", "assert", "fig", "legends", "0", "get_title", "get_text", "new_title"], "doc_len": 166}
{"doc_id": "tests/test_utils.py::test_move_legend_grid_object", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_move_legend_grid_object", "text": "文件路径: tests/test_utils.py\ndef test_move_legend_grid_object(long_df):\n\n    from seaborn.axisgrid import FacetGrid\n\n    hue_var = \"a\"\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, \"x\", \"y\")\n\n    g.add_legend()\n    _draw_figure(g.figure)\n\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n\n    fontsize = 20\n    utils.move_legend(g, \"lower left\", title_fontsize=fontsize)\n    _draw_figure(g.figure)\n\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert g.legend.get_title().get_text() == hue_var\n    assert g.legend.get_title().get_size() == fontsize\n\n    assert g.legend.legendHandles\n    for i, h in enumerate(g.legend.legendHandles):\n        assert mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f\"C{i}\")\n", "tokens": ["tests", "test_utils", "py", "def", "test_move_legend_grid_object", "long_df", "from", "seaborn", "axisgrid", "import", "facetgrid", "hue_var", "a", "g", "facetgrid", "long_df", "hue", "hue_var", "g", "map", "plt", "plot", "x", "y", "g", "add_legend", "_draw_figure", "g", "figure", "xfm", "g", "figure", "transfigure", "inverted", "transform", "old_pos", "xfm", "g", "legend", "legendpatch", "get_extents", "fontsize", "20", "utils", "move_legend", "g", "lower", "left", "title_fontsize", "fontsize", "_draw_figure", "g", "figure", "new_pos", "xfm", "g", "legend", "legendpatch", "get_extents", "assert", "new_pos", "old_pos", "all", "assert", "g", "legend", "get_title", "get_text", "hue_var", "assert", "g", "legend", "get_title", "get_size", "fontsize", "assert", "g", "legend", "legendhandles", "for", "i", "h", "in", "enumerate", "g", "legend", "legendhandles", "assert", "mpl", "colors", "to_rgb", "h", "get_color", "mpl", "colors", "to_rgb", "f", "c", "i"], "doc_len": 99}
{"doc_id": "tests/test_utils.py::test_move_legend_input_checks", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_move_legend_input_checks", "text": "文件路径: tests/test_utils.py\ndef test_move_legend_input_checks():\n\n    ax = plt.figure().subplots()\n    with pytest.raises(TypeError):\n        utils.move_legend(ax.xaxis, \"best\")\n\n    with pytest.raises(ValueError):\n        utils.move_legend(ax, \"best\")\n\n    with pytest.raises(ValueError):\n        utils.move_legend(ax.figure, \"best\")\n", "tokens": ["tests", "test_utils", "py", "def", "test_move_legend_input_checks", "ax", "plt", "figure", "subplots", "with", "pytest", "raises", "typeerror", "utils", "move_legend", "ax", "xaxis", "best", "with", "pytest", "raises", "valueerror", "utils", "move_legend", "ax", "best", "with", "pytest", "raises", "valueerror", "utils", "move_legend", "ax", "figure", "best"], "doc_len": 35}
{"doc_id": "tests/test_utils.py::check_load_dataset", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "check_load_dataset", "text": "文件路径: tests/test_utils.py\ndef check_load_dataset(name):\n    ds = load_dataset(name, cache=False)\n    assert isinstance(ds, pd.DataFrame)\n", "tokens": ["tests", "test_utils", "py", "def", "check_load_dataset", "name", "ds", "load_dataset", "name", "cache", "false", "assert", "isinstance", "ds", "pd", "dataframe"], "doc_len": 16}
{"doc_id": "tests/test_utils.py::check_load_cached_dataset", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "check_load_cached_dataset", "text": "文件路径: tests/test_utils.py\ndef check_load_cached_dataset(name):\n    # Test the caching using a temporary file.\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # download and cache\n        ds = load_dataset(name, cache=True, data_home=tmpdir)\n\n        # use cached version\n        ds2 = load_dataset(name, cache=True, data_home=tmpdir)\n        assert_frame_equal(ds, ds2)\n", "tokens": ["tests", "test_utils", "py", "def", "check_load_cached_dataset", "name", "test", "the", "caching", "using", "a", "temporary", "file", "with", "tempfile", "temporarydirectory", "as", "tmpdir", "download", "and", "cache", "ds", "load_dataset", "name", "cache", "true", "data_home", "tmpdir", "use", "cached", "version", "ds2", "load_dataset", "name", "cache", "true", "data_home", "tmpdir", "assert_frame_equal", "ds", "ds2"], "doc_len": 41}
{"doc_id": "tests/test_utils.py::test_get_dataset_names", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_get_dataset_names", "text": "文件路径: tests/test_utils.py\ndef test_get_dataset_names():\n    names = get_dataset_names()\n    assert names\n    assert \"tips\" in names\n", "tokens": ["tests", "test_utils", "py", "def", "test_get_dataset_names", "names", "get_dataset_names", "assert", "names", "assert", "tips", "in", "names"], "doc_len": 13}
{"doc_id": "tests/test_utils.py::test_load_datasets", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_load_datasets", "text": "文件路径: tests/test_utils.py\ndef test_load_datasets():\n\n    # Heavy test to verify that we can load all available datasets\n    for name in get_dataset_names():\n        # unfortunately @network somehow obscures this generator so it\n        # does not get in effect, so we need to call explicitly\n        # yield check_load_dataset, name\n        check_load_dataset(name)\n", "tokens": ["tests", "test_utils", "py", "def", "test_load_datasets", "heavy", "test", "to", "verify", "that", "we", "can", "load", "all", "available", "datasets", "for", "name", "in", "get_dataset_names", "unfortunately", "network", "somehow", "obscures", "this", "generator", "so", "it", "does", "not", "get", "in", "effect", "so", "we", "need", "to", "call", "explicitly", "yield", "check_load_dataset", "name", "check_load_dataset", "name"], "doc_len": 44}
{"doc_id": "tests/test_utils.py::test_load_dataset_string_error", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_load_dataset_string_error", "text": "文件路径: tests/test_utils.py\ndef test_load_dataset_string_error():\n\n    name = \"bad_name\"\n    err = f\"'{name}' is not one of the example datasets.\"\n    with pytest.raises(ValueError, match=err):\n        load_dataset(name)\n", "tokens": ["tests", "test_utils", "py", "def", "test_load_dataset_string_error", "name", "bad_name", "err", "f", "name", "is", "not", "one", "of", "the", "example", "datasets", "with", "pytest", "raises", "valueerror", "match", "err", "load_dataset", "name"], "doc_len": 25}
{"doc_id": "tests/test_utils.py::test_load_dataset_passed_data_error", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_load_dataset_passed_data_error", "text": "文件路径: tests/test_utils.py\ndef test_load_dataset_passed_data_error():\n\n    df = pd.DataFrame()\n    err = \"This function accepts only strings\"\n    with pytest.raises(TypeError, match=err):\n        load_dataset(df)\n", "tokens": ["tests", "test_utils", "py", "def", "test_load_dataset_passed_data_error", "df", "pd", "dataframe", "err", "this", "function", "accepts", "only", "strings", "with", "pytest", "raises", "typeerror", "match", "err", "load_dataset", "df"], "doc_len": 22}
{"doc_id": "tests/test_utils.py::test_load_cached_datasets", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_load_cached_datasets", "text": "文件路径: tests/test_utils.py\ndef test_load_cached_datasets():\n\n    # Heavy test to verify that we can load all available datasets\n    for name in get_dataset_names():\n        # unfortunately @network somehow obscures this generator so it\n        # does not get in effect, so we need to call explicitly\n        # yield check_load_dataset, name\n        check_load_cached_dataset(name)\n", "tokens": ["tests", "test_utils", "py", "def", "test_load_cached_datasets", "heavy", "test", "to", "verify", "that", "we", "can", "load", "all", "available", "datasets", "for", "name", "in", "get_dataset_names", "unfortunately", "network", "somehow", "obscures", "this", "generator", "so", "it", "does", "not", "get", "in", "effect", "so", "we", "need", "to", "call", "explicitly", "yield", "check_load_dataset", "name", "check_load_cached_dataset", "name"], "doc_len": 44}
{"doc_id": "tests/test_utils.py::test_relative_luminance", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_relative_luminance", "text": "文件路径: tests/test_utils.py\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = utils.relative_luminance(\"white\")\n    assert out1 == 1\n\n    out2 = utils.relative_luminance(\"#000000\")\n    assert out2 == 0\n\n    out3 = utils.relative_luminance((.25, .5, .75))\n    assert out3 == pytest.approx(0.201624536)\n\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [utils.relative_luminance(rgb) for rgb in rgbs]\n    lums2 = utils.relative_luminance(rgbs)\n\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n", "tokens": ["tests", "test_utils", "py", "def", "test_relative_luminance", "test", "relative", "luminance", "out1", "utils", "relative_luminance", "white", "assert", "out1", "1", "out2", "utils", "relative_luminance", "000000", "assert", "out2", "0", "out3", "utils", "relative_luminance", "25", "5", "75", "assert", "out3", "pytest", "approx", "0", "201624536", "rgbs", "mpl", "cm", "rdbu", "np", "linspace", "0", "1", "10", "lums1", "utils", "relative_luminance", "rgb", "for", "rgb", "in", "rgbs", "lums2", "utils", "relative_luminance", "rgbs", "for", "lum1", "lum2", "in", "zip", "lums1", "lums2", "assert", "lum1", "pytest", "approx", "lum2"], "doc_len": 67}
{"doc_id": "tests/test_utils.py::test_get_color_cycle", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_get_color_cycle", "text": "文件路径: tests/test_utils.py\ndef test_get_color_cycle(cycler, result):\n    with mpl.rc_context(rc={\"axes.prop_cycle\": cycler}):\n        assert get_color_cycle() == result\n", "tokens": ["tests", "test_utils", "py", "def", "test_get_color_cycle", "cycler", "result", "with", "mpl", "rc_context", "rc", "axes", "prop_cycle", "cycler", "assert", "get_color_cycle", "result"], "doc_len": 17}
{"doc_id": "tests/test_utils.py::test_remove_na", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_remove_na", "text": "文件路径: tests/test_utils.py\ndef test_remove_na():\n\n    a_array = np.array([1, 2, np.nan, 3])\n    a_array_rm = remove_na(a_array)\n    assert_array_equal(a_array_rm, np.array([1, 2, 3]))\n\n    a_series = pd.Series([1, 2, np.nan, 3])\n    a_series_rm = remove_na(a_series)\n    assert_series_equal(a_series_rm, pd.Series([1., 2, 3], [0, 1, 3]))\n", "tokens": ["tests", "test_utils", "py", "def", "test_remove_na", "a_array", "np", "array", "1", "2", "np", "nan", "3", "a_array_rm", "remove_na", "a_array", "assert_array_equal", "a_array_rm", "np", "array", "1", "2", "3", "a_series", "pd", "series", "1", "2", "np", "nan", "3", "a_series_rm", "remove_na", "a_series", "assert_series_equal", "a_series_rm", "pd", "series", "1", "2", "3", "0", "1", "3"], "doc_len": 44}
{"doc_id": "tests/test_utils.py::test_assign_default_kwargs", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_assign_default_kwargs", "text": "文件路径: tests/test_utils.py\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n\n    kws = {\"c\": 3}\n\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {\"c\": 3, \"d\": 2}\n", "tokens": ["tests", "test_utils", "py", "def", "test_assign_default_kwargs", "def", "f", "a", "b", "c", "d", "pass", "def", "g", "c", "1", "d", "2", "pass", "kws", "c", "3", "kws", "_assign_default_kwargs", "kws", "f", "g", "assert", "kws", "c", "3", "d", "2"], "doc_len": 33}
{"doc_id": "tests/test_utils.py::test_draw_figure", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_draw_figure", "text": "文件路径: tests/test_utils.py\ndef test_draw_figure():\n\n    f, ax = plt.subplots()\n    ax.plot([\"a\", \"b\", \"c\"], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    # ticklabels are not populated until a draw, but this may change\n    assert ax.get_xticklabels()[0].get_text() == \"a\"\n", "tokens": ["tests", "test_utils", "py", "def", "test_draw_figure", "f", "ax", "plt", "subplots", "ax", "plot", "a", "b", "c", "1", "2", "3", "_draw_figure", "f", "assert", "not", "f", "stale", "ticklabels", "are", "not", "populated", "until", "a", "draw", "but", "this", "may", "change", "assert", "ax", "get_xticklabels", "0", "get_text", "a"], "doc_len": 40}
{"doc_id": "tests/test_utils.py::test_deprecate_ci", "file_path": "tests/test_utils.py", "class_name": null, "func_name": "test_deprecate_ci", "text": "文件路径: tests/test_utils.py\ndef test_deprecate_ci():\n\n    msg = \"\\n\\nThe `ci` parameter is deprecated. Use `errorbar=\"\n\n    with pytest.warns(FutureWarning, match=msg + \"None\"):\n        out = _deprecate_ci(None, None)\n    assert out is None\n\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, \"sd\")\n    assert out == \"sd\"\n\n    with pytest.warns(FutureWarning, match=msg + r\"\\('ci', 68\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == (\"ci\", 68)\n", "tokens": ["tests", "test_utils", "py", "def", "test_deprecate_ci", "msg", "n", "nthe", "ci", "parameter", "is", "deprecated", "use", "errorbar", "with", "pytest", "warns", "futurewarning", "match", "msg", "none", "out", "_deprecate_ci", "none", "none", "assert", "out", "is", "none", "with", "pytest", "warns", "futurewarning", "match", "msg", "sd", "out", "_deprecate_ci", "none", "sd", "assert", "out", "sd", "with", "pytest", "warns", "futurewarning", "match", "msg", "r", "ci", "68", "out", "_deprecate_ci", "none", "68", "assert", "out", "ci", "68"], "doc_len": 60}
{"doc_id": "tests/_core/test_data.py::TestPlotData.long_variables", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "long_variables", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def long_variables(self):\n        variables = dict(x=\"x\", y=\"y\", color=\"a\", size=\"z\", style=\"s_cat\")\n        return variables\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "long_variables", "self", "variables", "dict", "x", "x", "y", "y", "color", "a", "size", "z", "style", "s_cat", "return", "variables"], "doc_len": 22}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_named_vectors", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_named_vectors", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_named_vectors(self, long_df, long_variables):\n\n        p = PlotData(long_df, long_variables)\n        assert p.source_data is long_df\n        assert p.source_vars is long_variables\n        for key, val in long_variables.items():\n            assert p.names[key] == val\n            assert_vector_equal(p.frame[key], long_df[val])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_named_vectors", "self", "long_df", "long_variables", "p", "plotdata", "long_df", "long_variables", "assert", "p", "source_data", "is", "long_df", "assert", "p", "source_vars", "is", "long_variables", "for", "key", "val", "in", "long_variables", "items", "assert", "p", "names", "key", "val", "assert_vector_equal", "p", "frame", "key", "long_df", "val"], "doc_len": 41}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_named_and_given_vectors", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_named_and_given_vectors", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_named_and_given_vectors(self, long_df, long_variables):\n\n        long_variables[\"y\"] = long_df[\"b\"]\n        long_variables[\"size\"] = long_df[\"z\"].to_numpy()\n\n        p = PlotData(long_df, long_variables)\n\n        assert_vector_equal(p.frame[\"color\"], long_df[long_variables[\"color\"]])\n        assert_vector_equal(p.frame[\"y\"], long_df[\"b\"])\n        assert_vector_equal(p.frame[\"size\"], long_df[\"z\"])\n\n        assert p.names[\"color\"] == long_variables[\"color\"]\n        assert p.names[\"y\"] == \"b\"\n        assert p.names[\"size\"] is None\n\n        assert p.ids[\"color\"] == long_variables[\"color\"]\n        assert p.ids[\"y\"] == \"b\"\n        assert p.ids[\"size\"] == id(long_variables[\"size\"])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_named_and_given_vectors", "self", "long_df", "long_variables", "long_variables", "y", "long_df", "b", "long_variables", "size", "long_df", "z", "to_numpy", "p", "plotdata", "long_df", "long_variables", "assert_vector_equal", "p", "frame", "color", "long_df", "long_variables", "color", "assert_vector_equal", "p", "frame", "y", "long_df", "b", "assert_vector_equal", "p", "frame", "size", "long_df", "z", "assert", "p", "names", "color", "long_variables", "color", "assert", "p", "names", "y", "b", "assert", "p", "names", "size", "is", "none", "assert", "p", "ids", "color", "long_variables", "color", "assert", "p", "ids", "y", "b", "assert", "p", "ids", "size", "id", "long_variables", "size"], "doc_len": 77}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_index_as_variable", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_index_as_variable", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_index_as_variable(self, long_df, long_variables):\n\n        index = pd.Index(np.arange(len(long_df)) * 2 + 10, name=\"i\", dtype=int)\n        long_variables[\"x\"] = \"i\"\n        p = PlotData(long_df.set_index(index), long_variables)\n\n        assert p.names[\"x\"] == p.ids[\"x\"] == \"i\"\n        assert_vector_equal(p.frame[\"x\"], pd.Series(index, index))\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_index_as_variable", "self", "long_df", "long_variables", "index", "pd", "index", "np", "arange", "len", "long_df", "2", "10", "name", "i", "dtype", "int", "long_variables", "x", "i", "p", "plotdata", "long_df", "set_index", "index", "long_variables", "assert", "p", "names", "x", "p", "ids", "x", "i", "assert_vector_equal", "p", "frame", "x", "pd", "series", "index", "index"], "doc_len": 48}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_multiindex_as_variables", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_multiindex_as_variables", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_multiindex_as_variables(self, long_df, long_variables):\n\n        index_i = pd.Index(np.arange(len(long_df)) * 2 + 10, name=\"i\", dtype=int)\n        index_j = pd.Index(np.arange(len(long_df)) * 3 + 5, name=\"j\", dtype=int)\n        index = pd.MultiIndex.from_arrays([index_i, index_j])\n        long_variables.update({\"x\": \"i\", \"y\": \"j\"})\n\n        p = PlotData(long_df.set_index(index), long_variables)\n        assert_vector_equal(p.frame[\"x\"], pd.Series(index_i, index))\n        assert_vector_equal(p.frame[\"y\"], pd.Series(index_j, index))\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_multiindex_as_variables", "self", "long_df", "long_variables", "index_i", "pd", "index", "np", "arange", "len", "long_df", "2", "10", "name", "i", "dtype", "int", "index_j", "pd", "index", "np", "arange", "len", "long_df", "3", "5", "name", "j", "dtype", "int", "index", "pd", "multiindex", "from_arrays", "index_i", "index_j", "long_variables", "update", "x", "i", "y", "j", "p", "plotdata", "long_df", "set_index", "index", "long_variables", "assert_vector_equal", "p", "frame", "x", "pd", "series", "index_i", "index", "assert_vector_equal", "p", "frame", "y", "pd", "series", "index_j", "index"], "doc_len": 70}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_int_as_variable_key", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_int_as_variable_key", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_int_as_variable_key(self, rng):\n\n        df = pd.DataFrame(rng.uniform(size=(10, 3)))\n\n        var = \"x\"\n        key = 2\n\n        p = PlotData(df, {var: key})\n        assert_vector_equal(p.frame[var], df[key])\n        assert p.names[var] == p.ids[var] == str(key)\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_int_as_variable_key", "self", "rng", "df", "pd", "dataframe", "rng", "uniform", "size", "10", "3", "var", "x", "key", "2", "p", "plotdata", "df", "var", "key", "assert_vector_equal", "p", "frame", "var", "df", "key", "assert", "p", "names", "var", "p", "ids", "var", "str", "key"], "doc_len": 41}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_int_as_variable_value", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_int_as_variable_value", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_int_as_variable_value(self, long_df):\n\n        p = PlotData(long_df, {\"x\": 0, \"y\": \"y\"})\n        assert (p.frame[\"x\"] == 0).all()\n        assert p.names[\"x\"] is None\n        assert p.ids[\"x\"] == id(0)\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_int_as_variable_value", "self", "long_df", "p", "plotdata", "long_df", "x", "0", "y", "y", "assert", "p", "frame", "x", "0", "all", "assert", "p", "names", "x", "is", "none", "assert", "p", "ids", "x", "id", "0"], "doc_len": 34}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_tuple_as_variable_key", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_tuple_as_variable_key", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_tuple_as_variable_key(self, rng):\n\n        cols = pd.MultiIndex.from_product([(\"a\", \"b\", \"c\"), (\"x\", \"y\")])\n        df = pd.DataFrame(rng.uniform(size=(10, 6)), columns=cols)\n\n        var = \"color\"\n        key = (\"b\", \"y\")\n        p = PlotData(df, {var: key})\n        assert_vector_equal(p.frame[var], df[key])\n        assert p.names[var] == p.ids[var] == str(key)\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_tuple_as_variable_key", "self", "rng", "cols", "pd", "multiindex", "from_product", "a", "b", "c", "x", "y", "df", "pd", "dataframe", "rng", "uniform", "size", "10", "6", "columns", "cols", "var", "color", "key", "b", "y", "p", "plotdata", "df", "var", "key", "assert_vector_equal", "p", "frame", "var", "df", "key", "assert", "p", "names", "var", "p", "ids", "var", "str", "key"], "doc_len": 53}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_dict_as_data", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_dict_as_data", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_dict_as_data(self, long_dict, long_variables):\n\n        p = PlotData(long_dict, long_variables)\n        assert p.source_data is long_dict\n        for key, val in long_variables.items():\n            assert_vector_equal(p.frame[key], pd.Series(long_dict[val]))\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_dict_as_data", "self", "long_dict", "long_variables", "p", "plotdata", "long_dict", "long_variables", "assert", "p", "source_data", "is", "long_dict", "for", "key", "val", "in", "long_variables", "items", "assert_vector_equal", "p", "frame", "key", "pd", "series", "long_dict", "val"], "doc_len": 33}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_vectors_various_types", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_vectors_various_types", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_vectors_various_types(self, long_df, long_variables, vector_type):\n\n        variables = {key: long_df[val] for key, val in long_variables.items()}\n        if vector_type == \"numpy\":\n            variables = {key: val.to_numpy() for key, val in variables.items()}\n        elif vector_type == \"list\":\n            variables = {key: val.to_list() for key, val in variables.items()}\n\n        p = PlotData(None, variables)\n\n        assert list(p.names) == list(long_variables)\n        if vector_type == \"series\":\n            assert p.source_vars is variables\n            assert p.names == p.ids == {key: val.name for key, val in variables.items()}\n        else:\n            assert p.names == {key: None for key in variables}\n            assert p.ids == {key: id(val) for key, val in variables.items()}\n\n        for key, val in long_variables.items():\n            if vector_type == \"series\":\n                assert_vector_equal(p.frame[key], long_df[val])\n            else:\n                assert_array_equal(p.frame[key], long_df[val])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_vectors_various_types", "self", "long_df", "long_variables", "vector_type", "variables", "key", "long_df", "val", "for", "key", "val", "in", "long_variables", "items", "if", "vector_type", "numpy", "variables", "key", "val", "to_numpy", "for", "key", "val", "in", "variables", "items", "elif", "vector_type", "list", "variables", "key", "val", "to_list", "for", "key", "val", "in", "variables", "items", "p", "plotdata", "none", "variables", "assert", "list", "p", "names", "list", "long_variables", "if", "vector_type", "series", "assert", "p", "source_vars", "is", "variables", "assert", "p", "names", "p", "ids", "key", "val", "name", "for", "key", "val", "in", "variables", "items", "else", "assert", "p", "names", "key", "none", "for", "key", "in", "variables", "assert", "p", "ids", "key", "id", "val", "for", "key", "val", "in", "variables", "items", "for", "key", "val", "in", "long_variables", "items", "if", "vector_type", "series", "assert_vector_equal", "p", "frame", "key", "long_df", "val", "else", "assert_array_equal", "p", "frame", "key", "long_df", "val"], "doc_len": 123}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_none_as_variable_value", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_none_as_variable_value", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_none_as_variable_value(self, long_df):\n\n        p = PlotData(long_df, {\"x\": \"z\", \"y\": None})\n        assert list(p.frame.columns) == [\"x\"]\n        assert p.names == p.ids == {\"x\": \"z\"}\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_none_as_variable_value", "self", "long_df", "p", "plotdata", "long_df", "x", "z", "y", "none", "assert", "list", "p", "frame", "columns", "x", "assert", "p", "names", "p", "ids", "x", "z"], "doc_len": 29}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_frame_and_vector_mismatched_lengths", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_frame_and_vector_mismatched_lengths", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_frame_and_vector_mismatched_lengths(self, long_df):\n\n        vector = np.arange(len(long_df) * 2)\n        with pytest.raises(ValueError):\n            PlotData(long_df, {\"x\": \"x\", \"y\": vector})\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_frame_and_vector_mismatched_lengths", "self", "long_df", "vector", "np", "arange", "len", "long_df", "2", "with", "pytest", "raises", "valueerror", "plotdata", "long_df", "x", "x", "y", "vector"], "doc_len": 25}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_empty_data_input", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_empty_data_input", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_empty_data_input(self, arg):\n\n        p = PlotData(arg, {})\n        assert p.frame.empty\n        assert not p.names\n\n        if not isinstance(arg, pd.DataFrame):\n            p = PlotData(None, dict(x=arg, y=arg))\n            assert p.frame.empty\n            assert not p.names\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_empty_data_input", "self", "arg", "p", "plotdata", "arg", "assert", "p", "frame", "empty", "assert", "not", "p", "names", "if", "not", "isinstance", "arg", "pd", "dataframe", "p", "plotdata", "none", "dict", "x", "arg", "y", "arg", "assert", "p", "frame", "empty", "assert", "not", "p", "names"], "doc_len": 42}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_index_alignment_series_to_dataframe", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_index_alignment_series_to_dataframe", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_index_alignment_series_to_dataframe(self):\n\n        x = [1, 2, 3]\n        x_index = pd.Index(x, dtype=int)\n\n        y_values = [3, 4, 5]\n        y_index = pd.Index(y_values, dtype=int)\n        y = pd.Series(y_values, y_index, name=\"y\")\n\n        data = pd.DataFrame(dict(x=x), index=x_index)\n\n        p = PlotData(data, {\"x\": \"x\", \"y\": y})\n\n        x_col_expected = pd.Series([1, 2, 3, np.nan, np.nan], np.arange(1, 6))\n        y_col_expected = pd.Series([np.nan, np.nan, 3, 4, 5], np.arange(1, 6))\n        assert_vector_equal(p.frame[\"x\"], x_col_expected)\n        assert_vector_equal(p.frame[\"y\"], y_col_expected)\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_index_alignment_series_to_dataframe", "self", "x", "1", "2", "3", "x_index", "pd", "index", "x", "dtype", "int", "y_values", "3", "4", "5", "y_index", "pd", "index", "y_values", "dtype", "int", "y", "pd", "series", "y_values", "y_index", "name", "y", "data", "pd", "dataframe", "dict", "x", "x", "index", "x_index", "p", "plotdata", "data", "x", "x", "y", "y", "x_col_expected", "pd", "series", "1", "2", "3", "np", "nan", "np", "nan", "np", "arange", "1", "6", "y_col_expected", "pd", "series", "np", "nan", "np", "nan", "3", "4", "5", "np", "arange", "1", "6", "assert_vector_equal", "p", "frame", "x", "x_col_expected", "assert_vector_equal", "p", "frame", "y", "y_col_expected"], "doc_len": 88}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_index_alignment_between_series", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_index_alignment_between_series", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_index_alignment_between_series(self):\n\n        x_index = [1, 2, 3]\n        x_values = [10, 20, 30]\n        x = pd.Series(x_values, x_index, name=\"x\")\n\n        y_index = [3, 4, 5]\n        y_values = [300, 400, 500]\n        y = pd.Series(y_values, y_index, name=\"y\")\n\n        p = PlotData(None, {\"x\": x, \"y\": y})\n\n        x_col_expected = pd.Series([10, 20, 30, np.nan, np.nan], np.arange(1, 6))\n        y_col_expected = pd.Series([np.nan, np.nan, 300, 400, 500], np.arange(1, 6))\n        assert_vector_equal(p.frame[\"x\"], x_col_expected)\n        assert_vector_equal(p.frame[\"y\"], y_col_expected)\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_index_alignment_between_series", "self", "x_index", "1", "2", "3", "x_values", "10", "20", "30", "x", "pd", "series", "x_values", "x_index", "name", "x", "y_index", "3", "4", "5", "y_values", "300", "400", "500", "y", "pd", "series", "y_values", "y_index", "name", "y", "p", "plotdata", "none", "x", "x", "y", "y", "x_col_expected", "pd", "series", "10", "20", "30", "np", "nan", "np", "nan", "np", "arange", "1", "6", "y_col_expected", "pd", "series", "np", "nan", "np", "nan", "300", "400", "500", "np", "arange", "1", "6", "assert_vector_equal", "p", "frame", "x", "x_col_expected", "assert_vector_equal", "p", "frame", "y", "y_col_expected"], "doc_len": 83}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_key_not_in_data_raises", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_key_not_in_data_raises", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_key_not_in_data_raises(self, long_df):\n\n        var = \"x\"\n        key = \"what\"\n        msg = f\"Could not interpret value `{key}` for `{var}`. An entry with this name\"\n        with pytest.raises(ValueError, match=msg):\n            PlotData(long_df, {var: key})\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_key_not_in_data_raises", "self", "long_df", "var", "x", "key", "what", "msg", "f", "could", "not", "interpret", "value", "key", "for", "var", "an", "entry", "with", "this", "name", "with", "pytest", "raises", "valueerror", "match", "msg", "plotdata", "long_df", "var", "key"], "doc_len": 37}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_key_with_no_data_raises", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_key_with_no_data_raises", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_key_with_no_data_raises(self):\n\n        var = \"x\"\n        key = \"what\"\n        msg = f\"Could not interpret value `{key}` for `{var}`. Value is a string,\"\n        with pytest.raises(ValueError, match=msg):\n            PlotData(None, {var: key})\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_key_with_no_data_raises", "self", "var", "x", "key", "what", "msg", "f", "could", "not", "interpret", "value", "key", "for", "var", "value", "is", "a", "string", "with", "pytest", "raises", "valueerror", "match", "msg", "plotdata", "none", "var", "key"], "doc_len": 35}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_data_vector_different_lengths_raises", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_data_vector_different_lengths_raises", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_data_vector_different_lengths_raises(self, long_df):\n\n        vector = np.arange(len(long_df) - 5)\n        msg = \"Length of ndarray vectors must match length of `data`\"\n        with pytest.raises(ValueError, match=msg):\n            PlotData(long_df, {\"y\": vector})\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_data_vector_different_lengths_raises", "self", "long_df", "vector", "np", "arange", "len", "long_df", "5", "msg", "length", "of", "ndarray", "vectors", "must", "match", "length", "of", "data", "with", "pytest", "raises", "valueerror", "match", "msg", "plotdata", "long_df", "y", "vector"], "doc_len": 35}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_undefined_variables_raise", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_undefined_variables_raise", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_undefined_variables_raise(self, long_df):\n\n        with pytest.raises(ValueError):\n            PlotData(long_df, dict(x=\"not_in_df\"))\n\n        with pytest.raises(ValueError):\n            PlotData(long_df, dict(x=\"x\", y=\"not_in_df\"))\n\n        with pytest.raises(ValueError):\n            PlotData(long_df, dict(x=\"x\", y=\"y\", color=\"not_in_df\"))\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_undefined_variables_raise", "self", "long_df", "with", "pytest", "raises", "valueerror", "plotdata", "long_df", "dict", "x", "not_in_df", "with", "pytest", "raises", "valueerror", "plotdata", "long_df", "dict", "x", "x", "y", "not_in_df", "with", "pytest", "raises", "valueerror", "plotdata", "long_df", "dict", "x", "x", "y", "y", "color", "not_in_df"], "doc_len": 42}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_contains_operation", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_contains_operation", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_contains_operation(self, long_df):\n\n        p = PlotData(long_df, {\"x\": \"y\", \"color\": long_df[\"a\"]})\n        assert \"x\" in p\n        assert \"y\" not in p\n        assert \"color\" in p\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_contains_operation", "self", "long_df", "p", "plotdata", "long_df", "x", "y", "color", "long_df", "a", "assert", "x", "in", "p", "assert", "y", "not", "in", "p", "assert", "color", "in", "p"], "doc_len": 30}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_add_variable", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_add_variable", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_add_variable(self, long_df):\n\n        v1 = {\"x\": \"x\", \"y\": \"f\"}\n        v2 = {\"color\": \"a\"}\n\n        p1 = PlotData(long_df, v1)\n        p2 = p1.join(None, v2)\n\n        for var, key in dict(**v1, **v2).items():\n            assert var in p2\n            assert p2.names[var] == key\n            assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_add_variable", "self", "long_df", "v1", "x", "x", "y", "f", "v2", "color", "a", "p1", "plotdata", "long_df", "v1", "p2", "p1", "join", "none", "v2", "for", "var", "key", "in", "dict", "v1", "v2", "items", "assert", "var", "in", "p2", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 49}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_replace_variable", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_replace_variable", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_replace_variable(self, long_df):\n\n        v1 = {\"x\": \"x\", \"y\": \"y\"}\n        v2 = {\"y\": \"s\"}\n\n        p1 = PlotData(long_df, v1)\n        p2 = p1.join(None, v2)\n\n        variables = v1.copy()\n        variables.update(v2)\n\n        for var, key in variables.items():\n            assert var in p2\n            assert p2.names[var] == key\n            assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_replace_variable", "self", "long_df", "v1", "x", "x", "y", "y", "v2", "y", "s", "p1", "plotdata", "long_df", "v1", "p2", "p1", "join", "none", "v2", "variables", "v1", "copy", "variables", "update", "v2", "for", "var", "key", "in", "variables", "items", "assert", "var", "in", "p2", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 53}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_remove_variable", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_remove_variable", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_remove_variable(self, long_df):\n\n        variables = {\"x\": \"x\", \"y\": \"f\"}\n        drop_var = \"y\"\n\n        p1 = PlotData(long_df, variables)\n        p2 = p1.join(None, {drop_var: None})\n\n        assert drop_var in p1\n        assert drop_var not in p2\n        assert drop_var not in p2.frame\n        assert drop_var not in p2.names\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_remove_variable", "self", "long_df", "variables", "x", "x", "y", "f", "drop_var", "y", "p1", "plotdata", "long_df", "variables", "p2", "p1", "join", "none", "drop_var", "none", "assert", "drop_var", "in", "p1", "assert", "drop_var", "not", "in", "p2", "assert", "drop_var", "not", "in", "p2", "frame", "assert", "drop_var", "not", "in", "p2", "names"], "doc_len": 47}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_all_operations", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_all_operations", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_all_operations(self, long_df):\n\n        v1 = {\"x\": \"x\", \"y\": \"y\", \"color\": \"a\"}\n        v2 = {\"y\": \"s\", \"size\": \"s\", \"color\": None}\n\n        p1 = PlotData(long_df, v1)\n        p2 = p1.join(None, v2)\n\n        for var, key in v2.items():\n            if key is None:\n                assert var not in p2\n            else:\n                assert p2.names[var] == key\n                assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_all_operations", "self", "long_df", "v1", "x", "x", "y", "y", "color", "a", "v2", "y", "s", "size", "s", "color", "none", "p1", "plotdata", "long_df", "v1", "p2", "p1", "join", "none", "v2", "for", "var", "key", "in", "v2", "items", "if", "key", "is", "none", "assert", "var", "not", "in", "p2", "else", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 59}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_all_operations_same_data", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_all_operations_same_data", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_all_operations_same_data(self, long_df):\n\n        v1 = {\"x\": \"x\", \"y\": \"y\", \"color\": \"a\"}\n        v2 = {\"y\": \"s\", \"size\": \"s\", \"color\": None}\n\n        p1 = PlotData(long_df, v1)\n        p2 = p1.join(long_df, v2)\n\n        for var, key in v2.items():\n            if key is None:\n                assert var not in p2\n            else:\n                assert p2.names[var] == key\n                assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_all_operations_same_data", "self", "long_df", "v1", "x", "x", "y", "y", "color", "a", "v2", "y", "s", "size", "s", "color", "none", "p1", "plotdata", "long_df", "v1", "p2", "p1", "join", "long_df", "v2", "for", "var", "key", "in", "v2", "items", "if", "key", "is", "none", "assert", "var", "not", "in", "p2", "else", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 59}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_add_variable_new_data", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_add_variable_new_data", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_add_variable_new_data(self, long_df):\n\n        d1 = long_df[[\"x\", \"y\"]]\n        d2 = long_df[[\"a\", \"s\"]]\n\n        v1 = {\"x\": \"x\", \"y\": \"y\"}\n        v2 = {\"color\": \"a\"}\n\n        p1 = PlotData(d1, v1)\n        p2 = p1.join(d2, v2)\n\n        for var, key in dict(**v1, **v2).items():\n            assert p2.names[var] == key\n            assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_add_variable_new_data", "self", "long_df", "d1", "long_df", "x", "y", "d2", "long_df", "a", "s", "v1", "x", "x", "y", "y", "v2", "color", "a", "p1", "plotdata", "d1", "v1", "p2", "p1", "join", "d2", "v2", "for", "var", "key", "in", "dict", "v1", "v2", "items", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 53}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_replace_variable_new_data", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_replace_variable_new_data", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_replace_variable_new_data(self, long_df):\n\n        d1 = long_df[[\"x\", \"y\"]]\n        d2 = long_df[[\"a\", \"s\"]]\n\n        v1 = {\"x\": \"x\", \"y\": \"y\"}\n        v2 = {\"x\": \"a\"}\n\n        p1 = PlotData(d1, v1)\n        p2 = p1.join(d2, v2)\n\n        variables = v1.copy()\n        variables.update(v2)\n\n        for var, key in variables.items():\n            assert p2.names[var] == key\n            assert_vector_equal(p2.frame[var], long_df[key])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_replace_variable_new_data", "self", "long_df", "d1", "long_df", "x", "y", "d2", "long_df", "a", "s", "v1", "x", "x", "y", "y", "v2", "x", "a", "p1", "plotdata", "d1", "v1", "p2", "p1", "join", "d2", "v2", "variables", "v1", "copy", "variables", "update", "v2", "for", "var", "key", "in", "variables", "items", "assert", "p2", "names", "var", "key", "assert_vector_equal", "p2", "frame", "var", "long_df", "key"], "doc_len": 57}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_add_variable_different_index", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_add_variable_different_index", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_add_variable_different_index(self, long_df):\n\n        d1 = long_df.iloc[:70]\n        d2 = long_df.iloc[30:]\n\n        v1 = {\"x\": \"a\"}\n        v2 = {\"y\": \"z\"}\n\n        p1 = PlotData(d1, v1)\n        p2 = p1.join(d2, v2)\n\n        (var1, key1), = v1.items()\n        (var2, key2), = v2.items()\n\n        assert_vector_equal(p2.frame.loc[d1.index, var1], d1[key1])\n        assert_vector_equal(p2.frame.loc[d2.index, var2], d2[key2])\n\n        assert p2.frame.loc[d2.index.difference(d1.index), var1].isna().all()\n        assert p2.frame.loc[d1.index.difference(d2.index), var2].isna().all()\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_add_variable_different_index", "self", "long_df", "d1", "long_df", "iloc", "70", "d2", "long_df", "iloc", "30", "v1", "x", "a", "v2", "y", "z", "p1", "plotdata", "d1", "v1", "p2", "p1", "join", "d2", "v2", "var1", "key1", "v1", "items", "var2", "key2", "v2", "items", "assert_vector_equal", "p2", "frame", "loc", "d1", "index", "var1", "d1", "key1", "assert_vector_equal", "p2", "frame", "loc", "d2", "index", "var2", "d2", "key2", "assert", "p2", "frame", "loc", "d2", "index", "difference", "d1", "index", "var1", "isna", "all", "assert", "p2", "frame", "loc", "d1", "index", "difference", "d2", "index", "var2", "isna", "all"], "doc_len": 82}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_replace_variable_different_index", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_replace_variable_different_index", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_replace_variable_different_index(self, long_df):\n\n        d1 = long_df.iloc[:70]\n        d2 = long_df.iloc[30:]\n\n        var = \"x\"\n        k1, k2 = \"a\", \"z\"\n        v1 = {var: k1}\n        v2 = {var: k2}\n\n        p1 = PlotData(d1, v1)\n        p2 = p1.join(d2, v2)\n\n        (var1, key1), = v1.items()\n        (var2, key2), = v2.items()\n\n        assert_vector_equal(p2.frame.loc[d2.index, var], d2[k2])\n        assert p2.frame.loc[d1.index.difference(d2.index), var].isna().all()\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_replace_variable_different_index", "self", "long_df", "d1", "long_df", "iloc", "70", "d2", "long_df", "iloc", "30", "var", "x", "k1", "k2", "a", "z", "v1", "var", "k1", "v2", "var", "k2", "p1", "plotdata", "d1", "v1", "p2", "p1", "join", "d2", "v2", "var1", "key1", "v1", "items", "var2", "key2", "v2", "items", "assert_vector_equal", "p2", "frame", "loc", "d2", "index", "var", "d2", "k2", "assert", "p2", "frame", "loc", "d1", "index", "difference", "d2", "index", "var", "isna", "all"], "doc_len": 67}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_subset_data_inherit_variables", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_subset_data_inherit_variables", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_subset_data_inherit_variables(self, long_df):\n\n        sub_df = long_df[long_df[\"a\"] == \"b\"]\n\n        var = \"y\"\n        p1 = PlotData(long_df, {var: var})\n        p2 = p1.join(sub_df, None)\n\n        assert_vector_equal(p2.frame.loc[sub_df.index, var], sub_df[var])\n        assert p2.frame.loc[long_df.index.difference(sub_df.index), var].isna().all()\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_subset_data_inherit_variables", "self", "long_df", "sub_df", "long_df", "long_df", "a", "b", "var", "y", "p1", "plotdata", "long_df", "var", "var", "p2", "p1", "join", "sub_df", "none", "assert_vector_equal", "p2", "frame", "loc", "sub_df", "index", "var", "sub_df", "var", "assert", "p2", "frame", "loc", "long_df", "index", "difference", "sub_df", "index", "var", "isna", "all"], "doc_len": 47}
{"doc_id": "tests/_core/test_data.py::TestPlotData.test_join_multiple_inherits_from_orig", "file_path": "tests/_core/test_data.py", "class_name": "TestPlotData", "func_name": "test_join_multiple_inherits_from_orig", "text": "文件路径: tests/_core/test_data.py, 类名: TestPlotData\n    def test_join_multiple_inherits_from_orig(self, rng):\n\n        d1 = pd.DataFrame(dict(a=rng.normal(0, 1, 100), b=rng.normal(0, 1, 100)))\n        d2 = pd.DataFrame(dict(a=rng.normal(0, 1, 100)))\n\n        p = PlotData(d1, {\"x\": \"a\"}).join(d2, {\"y\": \"a\"}).join(None, {\"y\": \"a\"})\n        assert_vector_equal(p.frame[\"x\"], d1[\"a\"])\n        assert_vector_equal(p.frame[\"y\"], d1[\"a\"])\n", "tokens": ["tests", "_core", "test_data", "py", "testplotdata", "def", "test_join_multiple_inherits_from_orig", "self", "rng", "d1", "pd", "dataframe", "dict", "a", "rng", "normal", "0", "1", "100", "b", "rng", "normal", "0", "1", "100", "d2", "pd", "dataframe", "dict", "a", "rng", "normal", "0", "1", "100", "p", "plotdata", "d1", "x", "a", "join", "d2", "y", "a", "join", "none", "y", "a", "assert_vector_equal", "p", "frame", "x", "d1", "a", "assert_vector_equal", "p", "frame", "y", "d1", "a"], "doc_len": 60}
{"doc_id": "tests/_core/test_groupby.py::df", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "df", "text": "文件路径: tests/_core/test_groupby.py\ndef df():\n\n    return pd.DataFrame(\n        columns=[\"a\", \"b\", \"x\", \"y\"],\n        data=[\n            [\"a\", \"g\", 1, .2],\n            [\"b\", \"h\", 3, .5],\n            [\"a\", \"f\", 2, .8],\n            [\"a\", \"h\", 1, .3],\n            [\"b\", \"f\", 2, .4],\n        ]\n    )\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "df", "return", "pd", "dataframe", "columns", "a", "b", "x", "y", "data", "a", "g", "1", "2", "b", "h", "3", "5", "a", "f", "2", "8", "a", "h", "1", "3", "b", "f", "2", "4"], "doc_len": 35}
{"doc_id": "tests/_core/test_groupby.py::test_init_from_list", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_init_from_list", "text": "文件路径: tests/_core/test_groupby.py\ndef test_init_from_list():\n    g = GroupBy([\"a\", \"c\", \"b\"])\n    assert g.order == {\"a\": None, \"c\": None, \"b\": None}\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_init_from_list", "g", "groupby", "a", "c", "b", "assert", "g", "order", "a", "none", "c", "none", "b", "none"], "doc_len": 20}
{"doc_id": "tests/_core/test_groupby.py::test_init_from_dict", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_init_from_dict", "text": "文件路径: tests/_core/test_groupby.py\ndef test_init_from_dict():\n    order = {\"a\": [3, 2, 1], \"c\": None, \"b\": [\"x\", \"y\", \"z\"]}\n    g = GroupBy(order)\n    assert g.order == order\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_init_from_dict", "order", "a", "3", "2", "1", "c", "none", "b", "x", "y", "z", "g", "groupby", "order", "assert", "g", "order", "order"], "doc_len": 24}
{"doc_id": "tests/_core/test_groupby.py::test_init_requires_order", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_init_requires_order", "text": "文件路径: tests/_core/test_groupby.py\ndef test_init_requires_order():\n\n    with pytest.raises(ValueError, match=\"GroupBy requires at least one\"):\n        GroupBy([])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_init_requires_order", "with", "pytest", "raises", "valueerror", "match", "groupby", "requires", "at", "least", "one", "groupby"], "doc_len": 17}
{"doc_id": "tests/_core/test_groupby.py::test_at_least_one_grouping_variable_required", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_at_least_one_grouping_variable_required", "text": "文件路径: tests/_core/test_groupby.py\ndef test_at_least_one_grouping_variable_required(df):\n\n    with pytest.raises(ValueError, match=\"No grouping variables are present\"):\n        GroupBy([\"z\"]).agg(df, x=\"mean\")\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_at_least_one_grouping_variable_required", "df", "with", "pytest", "raises", "valueerror", "match", "no", "grouping", "variables", "are", "present", "groupby", "z", "agg", "df", "x", "mean"], "doc_len": 23}
{"doc_id": "tests/_core/test_groupby.py::test_agg_one_grouper", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_agg_one_grouper", "text": "文件路径: tests/_core/test_groupby.py\ndef test_agg_one_grouper(df):\n\n    res = GroupBy([\"a\"]).agg(df, {\"y\": \"max\"})\n    assert_array_equal(res.index, [0, 1])\n    assert_array_equal(res.columns, [\"a\", \"y\"])\n    assert_array_equal(res[\"a\"], [\"a\", \"b\"])\n    assert_array_equal(res[\"y\"], [.8, .5])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_agg_one_grouper", "df", "res", "groupby", "a", "agg", "df", "y", "max", "assert_array_equal", "res", "index", "0", "1", "assert_array_equal", "res", "columns", "a", "y", "assert_array_equal", "res", "a", "a", "b", "assert_array_equal", "res", "y", "8", "5"], "doc_len": 34}
{"doc_id": "tests/_core/test_groupby.py::test_agg_two_groupers", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_agg_two_groupers", "text": "文件路径: tests/_core/test_groupby.py\ndef test_agg_two_groupers(df):\n\n    res = GroupBy([\"a\", \"x\"]).agg(df, {\"y\": \"min\"})\n    assert_array_equal(res.index, [0, 1, 2, 3, 4, 5])\n    assert_array_equal(res.columns, [\"a\", \"x\", \"y\"])\n    assert_array_equal(res[\"a\"], [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"])\n    assert_array_equal(res[\"x\"], [1, 2, 3, 1, 2, 3])\n    assert_array_equal(res[\"y\"], [.2, .8, np.nan, np.nan, .4, .5])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_agg_two_groupers", "df", "res", "groupby", "a", "x", "agg", "df", "y", "min", "assert_array_equal", "res", "index", "0", "1", "2", "3", "4", "5", "assert_array_equal", "res", "columns", "a", "x", "y", "assert_array_equal", "res", "a", "a", "a", "a", "b", "b", "b", "assert_array_equal", "res", "x", "1", "2", "3", "1", "2", "3", "assert_array_equal", "res", "y", "2", "8", "np", "nan", "np", "nan", "4", "5"], "doc_len": 59}
{"doc_id": "tests/_core/test_groupby.py::test_agg_two_groupers_ordered", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_agg_two_groupers_ordered", "text": "文件路径: tests/_core/test_groupby.py\ndef test_agg_two_groupers_ordered(df):\n\n    order = {\"b\": [\"h\", \"g\", \"f\"], \"x\": [3, 2, 1]}\n    res = GroupBy(order).agg(df, {\"a\": \"min\", \"y\": lambda x: x.iloc[0]})\n    assert_array_equal(res.index, [0, 1, 2, 3, 4, 5, 6, 7, 8])\n    assert_array_equal(res.columns, [\"a\", \"b\", \"x\", \"y\"])\n    assert_array_equal(res[\"b\"], [\"h\", \"h\", \"h\", \"g\", \"g\", \"g\", \"f\", \"f\", \"f\"])\n    assert_array_equal(res[\"x\"], [3, 2, 1, 3, 2, 1, 3, 2, 1])\n\n    T, F = True, False\n    assert_array_equal(res[\"a\"].isna(), [F, T, F, T, T, F, T, F, T])\n    assert_array_equal(res[\"a\"].dropna(), [\"b\", \"a\", \"a\", \"a\"])\n    assert_array_equal(res[\"y\"].dropna(), [.5, .3, .2, .8])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_agg_two_groupers_ordered", "df", "order", "b", "h", "g", "f", "x", "3", "2", "1", "res", "groupby", "order", "agg", "df", "a", "min", "y", "lambda", "x", "x", "iloc", "0", "assert_array_equal", "res", "index", "0", "1", "2", "3", "4", "5", "6", "7", "8", "assert_array_equal", "res", "columns", "a", "b", "x", "y", "assert_array_equal", "res", "b", "h", "h", "h", "g", "g", "g", "f", "f", "f", "assert_array_equal", "res", "x", "3", "2", "1", "3", "2", "1", "3", "2", "1", "t", "f", "true", "false", "assert_array_equal", "res", "a", "isna", "f", "t", "f", "t", "t", "f", "t", "f", "t", "assert_array_equal", "res", "a", "dropna", "b", "a", "a", "a", "assert_array_equal", "res", "y", "dropna", "5", "3", "2", "8"], "doc_len": 105}
{"doc_id": "tests/_core/test_groupby.py::test_apply_no_grouper", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_apply_no_grouper", "text": "文件路径: tests/_core/test_groupby.py\ndef test_apply_no_grouper(df):\n\n    df = df[[\"x\", \"y\"]]\n    res = GroupBy([\"a\"]).apply(df, lambda x: x.sort_values(\"x\"))\n    assert_array_equal(res.columns, [\"x\", \"y\"])\n    assert_array_equal(res[\"x\"], df[\"x\"].sort_values())\n    assert_array_equal(res[\"y\"], df.loc[np.argsort(df[\"x\"]), \"y\"])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_apply_no_grouper", "df", "df", "df", "x", "y", "res", "groupby", "a", "apply", "df", "lambda", "x", "x", "sort_values", "x", "assert_array_equal", "res", "columns", "x", "y", "assert_array_equal", "res", "x", "df", "x", "sort_values", "assert_array_equal", "res", "y", "df", "loc", "np", "argsort", "df", "x", "y"], "doc_len": 42}
{"doc_id": "tests/_core/test_groupby.py::test_apply_one_grouper", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_apply_one_grouper", "text": "文件路径: tests/_core/test_groupby.py\ndef test_apply_one_grouper(df):\n\n    res = GroupBy([\"a\"]).apply(df, lambda x: x.sort_values(\"x\"))\n    assert_array_equal(res.index, [0, 1, 2, 3, 4])\n    assert_array_equal(res.columns, [\"a\", \"b\", \"x\", \"y\"])\n    assert_array_equal(res[\"a\"], [\"a\", \"a\", \"a\", \"b\", \"b\"])\n    assert_array_equal(res[\"b\"], [\"g\", \"h\", \"f\", \"f\", \"h\"])\n    assert_array_equal(res[\"x\"], [1, 1, 2, 2, 3])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_apply_one_grouper", "df", "res", "groupby", "a", "apply", "df", "lambda", "x", "x", "sort_values", "x", "assert_array_equal", "res", "index", "0", "1", "2", "3", "4", "assert_array_equal", "res", "columns", "a", "b", "x", "y", "assert_array_equal", "res", "a", "a", "a", "a", "b", "b", "assert_array_equal", "res", "b", "g", "h", "f", "f", "h", "assert_array_equal", "res", "x", "1", "1", "2", "2", "3"], "doc_len": 56}
{"doc_id": "tests/_core/test_groupby.py::test_apply_mutate_columns", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_apply_mutate_columns", "text": "文件路径: tests/_core/test_groupby.py\ndef test_apply_mutate_columns(df):\n\n    xx = np.arange(0, 5)\n    hats = []\n\n    def polyfit(df):\n        fit = np.polyfit(df[\"x\"], df[\"y\"], 1)\n        hat = np.polyval(fit, xx)\n        hats.append(hat)\n        return pd.DataFrame(dict(x=xx, y=hat))\n\n    res = GroupBy([\"a\"]).apply(df, polyfit)\n    assert_array_equal(res.index, np.arange(xx.size * 2))\n    assert_array_equal(res.columns, [\"a\", \"x\", \"y\"])\n    assert_array_equal(res[\"a\"], [\"a\"] * xx.size + [\"b\"] * xx.size)\n    assert_array_equal(res[\"x\"], xx.tolist() + xx.tolist())\n    assert_array_equal(res[\"y\"], np.concatenate(hats))\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_apply_mutate_columns", "df", "xx", "np", "arange", "0", "5", "hats", "def", "polyfit", "df", "fit", "np", "polyfit", "df", "x", "df", "y", "1", "hat", "np", "polyval", "fit", "xx", "hats", "append", "hat", "return", "pd", "dataframe", "dict", "x", "xx", "y", "hat", "res", "groupby", "a", "apply", "df", "polyfit", "assert_array_equal", "res", "index", "np", "arange", "xx", "size", "2", "assert_array_equal", "res", "columns", "a", "x", "y", "assert_array_equal", "res", "a", "a", "xx", "size", "b", "xx", "size", "assert_array_equal", "res", "x", "xx", "tolist", "xx", "tolist", "assert_array_equal", "res", "y", "np", "concatenate", "hats"], "doc_len": 82}
{"doc_id": "tests/_core/test_groupby.py::test_apply_replace_columns", "file_path": "tests/_core/test_groupby.py", "class_name": null, "func_name": "test_apply_replace_columns", "text": "文件路径: tests/_core/test_groupby.py\ndef test_apply_replace_columns(df):\n\n    def add_sorted_cumsum(df):\n\n        x = df[\"x\"].sort_values()\n        z = df.loc[x.index, \"y\"].cumsum()\n        return pd.DataFrame(dict(x=x.values, z=z.values))\n\n    res = GroupBy([\"a\"]).apply(df, add_sorted_cumsum)\n    assert_array_equal(res.index, df.index)\n    assert_array_equal(res.columns, [\"a\", \"x\", \"z\"])\n    assert_array_equal(res[\"a\"], [\"a\", \"a\", \"a\", \"b\", \"b\"])\n    assert_array_equal(res[\"x\"], [1, 1, 2, 2, 3])\n    assert_array_equal(res[\"z\"], [.2, .5, 1.3, .4, .9])\n", "tokens": ["tests", "_core", "test_groupby", "py", "def", "test_apply_replace_columns", "df", "def", "add_sorted_cumsum", "df", "x", "df", "x", "sort_values", "z", "df", "loc", "x", "index", "y", "cumsum", "return", "pd", "dataframe", "dict", "x", "x", "values", "z", "z", "values", "res", "groupby", "a", "apply", "df", "add_sorted_cumsum", "assert_array_equal", "res", "index", "df", "index", "assert_array_equal", "res", "columns", "a", "x", "z", "assert_array_equal", "res", "a", "a", "a", "a", "b", "b", "assert_array_equal", "res", "x", "1", "1", "2", "2", "3", "assert_array_equal", "res", "z", "2", "5", "1", "3", "4", "9"], "doc_len": 73}
{"doc_id": "tests/_core/test_moves.py::MoveFixtures.df", "file_path": "tests/_core/test_moves.py", "class_name": "MoveFixtures", "func_name": "df", "text": "文件路径: tests/_core/test_moves.py, 类名: MoveFixtures\n    def df(self, rng):\n\n        n = 50\n        data = {\n            \"x\": rng.choice([0., 1., 2., 3.], n),\n            \"y\": rng.normal(0, 1, n),\n            \"grp2\": rng.choice([\"a\", \"b\"], n),\n            \"grp3\": rng.choice([\"x\", \"y\", \"z\"], n),\n            \"width\": 0.8,\n            \"baseline\": 0,\n        }\n        return pd.DataFrame(data)\n", "tokens": ["tests", "_core", "test_moves", "py", "movefixtures", "def", "df", "self", "rng", "n", "50", "data", "x", "rng", "choice", "0", "1", "2", "3", "n", "y", "rng", "normal", "0", "1", "n", "grp2", "rng", "choice", "a", "b", "n", "grp3", "rng", "choice", "x", "y", "z", "n", "width", "0", "8", "baseline", "0", "return", "pd", "dataframe", "data"], "doc_len": 48}
{"doc_id": "tests/_core/test_moves.py::MoveFixtures.toy_df", "file_path": "tests/_core/test_moves.py", "class_name": "MoveFixtures", "func_name": "toy_df", "text": "文件路径: tests/_core/test_moves.py, 类名: MoveFixtures\n    def toy_df(self):\n\n        data = {\n            \"x\": [0, 0, 1],\n            \"y\": [1, 2, 3],\n            \"grp\": [\"a\", \"b\", \"b\"],\n            \"width\": .8,\n            \"baseline\": 0,\n        }\n        return pd.DataFrame(data)\n", "tokens": ["tests", "_core", "test_moves", "py", "movefixtures", "def", "toy_df", "self", "data", "x", "0", "0", "1", "y", "1", "2", "3", "grp", "a", "b", "b", "width", "8", "baseline", "0", "return", "pd", "dataframe", "data"], "doc_len": 29}
{"doc_id": "tests/_core/test_moves.py::MoveFixtures.toy_df_widths", "file_path": "tests/_core/test_moves.py", "class_name": "MoveFixtures", "func_name": "toy_df_widths", "text": "文件路径: tests/_core/test_moves.py, 类名: MoveFixtures\n    def toy_df_widths(self, toy_df):\n\n        toy_df[\"width\"] = [.8, .2, .4]\n        return toy_df\n", "tokens": ["tests", "_core", "test_moves", "py", "movefixtures", "def", "toy_df_widths", "self", "toy_df", "toy_df", "width", "8", "2", "4", "return", "toy_df"], "doc_len": 16}
{"doc_id": "tests/_core/test_moves.py::MoveFixtures.toy_df_facets", "file_path": "tests/_core/test_moves.py", "class_name": "MoveFixtures", "func_name": "toy_df_facets", "text": "文件路径: tests/_core/test_moves.py, 类名: MoveFixtures\n    def toy_df_facets(self):\n\n        data = {\n            \"x\": [0, 0, 1, 0, 1, 2],\n            \"y\": [1, 2, 3, 1, 2, 3],\n            \"grp\": [\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"],\n            \"col\": [\"x\", \"x\", \"x\", \"y\", \"y\", \"y\"],\n            \"width\": .8,\n            \"baseline\": 0,\n        }\n        return pd.DataFrame(data)\n", "tokens": ["tests", "_core", "test_moves", "py", "movefixtures", "def", "toy_df_facets", "self", "data", "x", "0", "0", "1", "0", "1", "2", "y", "1", "2", "3", "1", "2", "3", "grp", "a", "b", "a", "b", "a", "b", "col", "x", "x", "x", "y", "y", "y", "width", "8", "baseline", "0", "return", "pd", "dataframe", "data"], "doc_len": 45}
{"doc_id": "tests/_core/test_moves.py::TestJitter.get_groupby", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "get_groupby", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def get_groupby(self, data, orient):\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        variables = [v for v in data if v not in [other, \"width\"]]\n        return GroupBy(variables)\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "get_groupby", "self", "data", "orient", "other", "x", "y", "y", "x", "orient", "variables", "v", "for", "v", "in", "data", "if", "v", "not", "in", "other", "width", "return", "groupby", "variables"], "doc_len": 31}
{"doc_id": "tests/_core/test_moves.py::TestJitter.check_same", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "check_same", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def check_same(self, res, df, *cols):\n        for col in cols:\n            assert_series_equal(res[col], df[col])\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "check_same", "self", "res", "df", "cols", "for", "col", "in", "cols", "assert_series_equal", "res", "col", "df", "col"], "doc_len": 20}
{"doc_id": "tests/_core/test_moves.py::TestJitter.check_pos", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "check_pos", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def check_pos(self, res, df, var, limit):\n\n        assert (res[var] != df[var]).all()\n        assert (res[var] < df[var] + limit / 2).all()\n        assert (res[var] > df[var] - limit / 2).all()\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "check_pos", "self", "res", "df", "var", "limit", "assert", "res", "var", "df", "var", "all", "assert", "res", "var", "df", "var", "limit", "2", "all", "assert", "res", "var", "df", "var", "limit", "2", "all"], "doc_len": 34}
{"doc_id": "tests/_core/test_moves.py::TestJitter.test_default", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "test_default", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def test_default(self, df):\n\n        orient = \"x\"\n        groupby = self.get_groupby(df, orient)\n        res = Jitter()(df, groupby, orient, {})\n        self.check_same(res, df, \"y\", \"grp2\", \"width\")\n        self.check_pos(res, df, \"x\", 0.2 * df[\"width\"])\n        assert (res[\"x\"] - df[\"x\"]).abs().min() > 0\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "test_default", "self", "df", "orient", "x", "groupby", "self", "get_groupby", "df", "orient", "res", "jitter", "df", "groupby", "orient", "self", "check_same", "res", "df", "y", "grp2", "width", "self", "check_pos", "res", "df", "x", "0", "2", "df", "width", "assert", "res", "x", "df", "x", "abs", "min", "0"], "doc_len": 45}
{"doc_id": "tests/_core/test_moves.py::TestJitter.test_width", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "test_width", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def test_width(self, df):\n\n        width = .4\n        orient = \"x\"\n        groupby = self.get_groupby(df, orient)\n        res = Jitter(width=width)(df, groupby, orient, {})\n        self.check_same(res, df, \"y\", \"grp2\", \"width\")\n        self.check_pos(res, df, \"x\", width * df[\"width\"])\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "test_width", "self", "df", "width", "4", "orient", "x", "groupby", "self", "get_groupby", "df", "orient", "res", "jitter", "width", "width", "df", "groupby", "orient", "self", "check_same", "res", "df", "y", "grp2", "width", "self", "check_pos", "res", "df", "x", "width", "df", "width"], "doc_len": 40}
{"doc_id": "tests/_core/test_moves.py::TestJitter.test_x", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "test_x", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def test_x(self, df):\n\n        val = .2\n        orient = \"x\"\n        groupby = self.get_groupby(df, orient)\n        res = Jitter(x=val)(df, groupby, orient, {})\n        self.check_same(res, df, \"y\", \"grp2\", \"width\")\n        self.check_pos(res, df, \"x\", val)\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "test_x", "self", "df", "val", "2", "orient", "x", "groupby", "self", "get_groupby", "df", "orient", "res", "jitter", "x", "val", "df", "groupby", "orient", "self", "check_same", "res", "df", "y", "grp2", "width", "self", "check_pos", "res", "df", "x", "val"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestJitter.test_y", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "test_y", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def test_y(self, df):\n\n        val = .2\n        orient = \"x\"\n        groupby = self.get_groupby(df, orient)\n        res = Jitter(y=val)(df, groupby, orient, {})\n        self.check_same(res, df, \"x\", \"grp2\", \"width\")\n        self.check_pos(res, df, \"y\", val)\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "test_y", "self", "df", "val", "2", "orient", "x", "groupby", "self", "get_groupby", "df", "orient", "res", "jitter", "y", "val", "df", "groupby", "orient", "self", "check_same", "res", "df", "x", "grp2", "width", "self", "check_pos", "res", "df", "y", "val"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestJitter.test_seed", "file_path": "tests/_core/test_moves.py", "class_name": "TestJitter", "func_name": "test_seed", "text": "文件路径: tests/_core/test_moves.py, 类名: TestJitter\n    def test_seed(self, df):\n\n        kws = dict(width=.2, y=.1, seed=0)\n        orient = \"x\"\n        groupby = self.get_groupby(df, orient)\n        res1 = Jitter(**kws)(df, groupby, orient, {})\n        res2 = Jitter(**kws)(df, groupby, orient, {})\n        for var in \"xy\":\n            assert_series_equal(res1[var], res2[var])\n", "tokens": ["tests", "_core", "test_moves", "py", "testjitter", "def", "test_seed", "self", "df", "kws", "dict", "width", "2", "y", "1", "seed", "0", "orient", "x", "groupby", "self", "get_groupby", "df", "orient", "res1", "jitter", "kws", "df", "groupby", "orient", "res2", "jitter", "kws", "df", "groupby", "orient", "for", "var", "in", "xy", "assert_series_equal", "res1", "var", "res2", "var"], "doc_len": 45}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_default", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_default", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_default(self, toy_df):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge()(toy_df, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3]),\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1.2])\n        assert_array_almost_equal(res[\"width\"], [.4, .4, .4])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_default", "self", "toy_df", "groupby", "groupby", "x", "grp", "res", "dodge", "toy_df", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "2", "assert_array_almost_equal", "res", "width", "4", "4", "4"], "doc_len": 37}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_fill", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_fill", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_fill(self, toy_df):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge(empty=\"fill\")(toy_df, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3]),\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1])\n        assert_array_almost_equal(res[\"width\"], [.4, .4, .8])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_fill", "self", "toy_df", "groupby", "groupby", "x", "grp", "res", "dodge", "empty", "fill", "toy_df", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "assert_array_almost_equal", "res", "width", "4", "4", "8"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_drop", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_drop", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_drop(self, toy_df):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge(\"drop\")(toy_df, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1])\n        assert_array_almost_equal(res[\"width\"], [.4, .4, .4])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_drop", "self", "toy_df", "groupby", "groupby", "x", "grp", "res", "dodge", "drop", "toy_df", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "assert_array_almost_equal", "res", "width", "4", "4", "4"], "doc_len": 37}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_gap", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_gap", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_gap(self, toy_df):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge(gap=.25)(toy_df, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1.2])\n        assert_array_almost_equal(res[\"width\"], [.3, .3, .3])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_gap", "self", "toy_df", "groupby", "groupby", "x", "grp", "res", "dodge", "gap", "25", "toy_df", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "2", "assert_array_almost_equal", "res", "width", "3", "3", "3"], "doc_len": 39}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_widths_default", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_widths_default", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_widths_default(self, toy_df_widths):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge()(toy_df_widths, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.08, .32, 1.1])\n        assert_array_almost_equal(res[\"width\"], [.64, .16, .2])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_widths_default", "self", "toy_df_widths", "groupby", "groupby", "x", "grp", "res", "dodge", "toy_df_widths", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "08", "32", "1", "1", "assert_array_almost_equal", "res", "width", "64", "16", "2"], "doc_len": 37}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_widths_fill", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_widths_fill", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_widths_fill(self, toy_df_widths):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge(empty=\"fill\")(toy_df_widths, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.08, .32, 1])\n        assert_array_almost_equal(res[\"width\"], [.64, .16, .4])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_widths_fill", "self", "toy_df_widths", "groupby", "groupby", "x", "grp", "res", "dodge", "empty", "fill", "toy_df_widths", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "08", "32", "1", "assert_array_almost_equal", "res", "width", "64", "16", "4"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_widths_drop", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_widths_drop", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_widths_drop(self, toy_df_widths):\n\n        groupby = GroupBy([\"x\", \"grp\"])\n        res = Dodge(empty=\"drop\")(toy_df_widths, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.08, .32, 1])\n        assert_array_almost_equal(res[\"width\"], [.64, .16, .2])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_widths_drop", "self", "toy_df_widths", "groupby", "groupby", "x", "grp", "res", "dodge", "empty", "drop", "toy_df_widths", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "assert_array_almost_equal", "res", "x", "08", "32", "1", "assert_array_almost_equal", "res", "width", "64", "16", "2"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_faceted_default", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_faceted_default", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_faceted_default(self, toy_df_facets):\n\n        groupby = GroupBy([\"x\", \"grp\", \"col\"])\n        res = Dodge()(toy_df_facets, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3, 1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, .8, .2, .8, 2.2])\n        assert_array_almost_equal(res[\"width\"], [.4] * 6)\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_faceted_default", "self", "toy_df_facets", "groupby", "groupby", "x", "grp", "col", "res", "dodge", "toy_df_facets", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "8", "2", "8", "2", "2", "assert_array_almost_equal", "res", "width", "4", "6"], "doc_len": 43}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_faceted_fill", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_faceted_fill", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_faceted_fill(self, toy_df_facets):\n\n        groupby = GroupBy([\"x\", \"grp\", \"col\"])\n        res = Dodge(empty=\"fill\")(toy_df_facets, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3, 1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1, 0, 1, 2])\n        assert_array_almost_equal(res[\"width\"], [.4, .4, .8, .8, .8, .8])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_faceted_fill", "self", "toy_df_facets", "groupby", "groupby", "x", "grp", "col", "res", "dodge", "empty", "fill", "toy_df_facets", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "0", "1", "2", "assert_array_almost_equal", "res", "width", "4", "4", "8", "8", "8", "8"], "doc_len": 48}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_faceted_drop", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_faceted_drop", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_faceted_drop(self, toy_df_facets):\n\n        groupby = GroupBy([\"x\", \"grp\", \"col\"])\n        res = Dodge(empty=\"drop\")(toy_df_facets, groupby, \"x\", {})\n\n        assert_array_equal(res[\"y\"], [1, 2, 3, 1, 2, 3])\n        assert_array_almost_equal(res[\"x\"], [-.2, .2, 1, 0, 1, 2])\n        assert_array_almost_equal(res[\"width\"], [.4] * 6)\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_faceted_drop", "self", "toy_df_facets", "groupby", "groupby", "x", "grp", "col", "res", "dodge", "empty", "drop", "toy_df_facets", "groupby", "x", "assert_array_equal", "res", "y", "1", "2", "3", "1", "2", "3", "assert_array_almost_equal", "res", "x", "2", "2", "1", "0", "1", "2", "assert_array_almost_equal", "res", "width", "4", "6"], "doc_len": 44}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_orient", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_orient", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_orient(self, toy_df):\n\n        df = toy_df.assign(x=toy_df[\"y\"], y=toy_df[\"x\"])\n\n        groupby = GroupBy([\"y\", \"grp\"])\n        res = Dodge(\"drop\")(df, groupby, \"y\", {})\n\n        assert_array_equal(res[\"x\"], [1, 2, 3])\n        assert_array_almost_equal(res[\"y\"], [-.2, .2, 1])\n        assert_array_almost_equal(res[\"width\"], [.4, .4, .4])\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_orient", "self", "toy_df", "df", "toy_df", "assign", "x", "toy_df", "y", "y", "toy_df", "x", "groupby", "groupby", "y", "grp", "res", "dodge", "drop", "df", "groupby", "y", "assert_array_equal", "res", "x", "1", "2", "3", "assert_array_almost_equal", "res", "y", "2", "2", "1", "assert_array_almost_equal", "res", "width", "4", "4", "4"], "doc_len": 46}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_single_semantic", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_single_semantic", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_single_semantic(self, df, grp):\n\n        groupby = GroupBy([\"x\", grp])\n        res = Dodge()(df, groupby, \"x\", {})\n\n        levels = categorical_order(df[grp])\n        w, n = 0.8, len(levels)\n\n        shifts = np.linspace(0, w - w / n, n)\n        shifts -= shifts.mean()\n\n        assert_series_equal(res[\"y\"], df[\"y\"])\n        assert_series_equal(res[\"width\"], df[\"width\"] / n)\n\n        for val, shift in zip(levels, shifts):\n            rows = df[grp] == val\n            assert_series_equal(res.loc[rows, \"x\"], df.loc[rows, \"x\"] + shift)\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_single_semantic", "self", "df", "grp", "groupby", "groupby", "x", "grp", "res", "dodge", "df", "groupby", "x", "levels", "categorical_order", "df", "grp", "w", "n", "0", "8", "len", "levels", "shifts", "np", "linspace", "0", "w", "w", "n", "n", "shifts", "shifts", "mean", "assert_series_equal", "res", "y", "df", "y", "assert_series_equal", "res", "width", "df", "width", "n", "for", "val", "shift", "in", "zip", "levels", "shifts", "rows", "df", "grp", "val", "assert_series_equal", "res", "loc", "rows", "x", "df", "loc", "rows", "x", "shift"], "doc_len": 72}
{"doc_id": "tests/_core/test_moves.py::TestDodge.test_two_semantics", "file_path": "tests/_core/test_moves.py", "class_name": "TestDodge", "func_name": "test_two_semantics", "text": "文件路径: tests/_core/test_moves.py, 类名: TestDodge\n    def test_two_semantics(self, df):\n\n        groupby = GroupBy([\"x\", \"grp2\", \"grp3\"])\n        res = Dodge()(df, groupby, \"x\", {})\n\n        levels = categorical_order(df[\"grp2\"]), categorical_order(df[\"grp3\"])\n        w, n = 0.8, len(levels[0]) * len(levels[1])\n\n        shifts = np.linspace(0, w - w / n, n)\n        shifts -= shifts.mean()\n\n        assert_series_equal(res[\"y\"], df[\"y\"])\n        assert_series_equal(res[\"width\"], df[\"width\"] / n)\n\n        for (v2, v3), shift in zip(product(*levels), shifts):\n            rows = (df[\"grp2\"] == v2) & (df[\"grp3\"] == v3)\n            assert_series_equal(res.loc[rows, \"x\"], df.loc[rows, \"x\"] + shift)\n", "tokens": ["tests", "_core", "test_moves", "py", "testdodge", "def", "test_two_semantics", "self", "df", "groupby", "groupby", "x", "grp2", "grp3", "res", "dodge", "df", "groupby", "x", "levels", "categorical_order", "df", "grp2", "categorical_order", "df", "grp3", "w", "n", "0", "8", "len", "levels", "0", "len", "levels", "1", "shifts", "np", "linspace", "0", "w", "w", "n", "n", "shifts", "shifts", "mean", "assert_series_equal", "res", "y", "df", "y", "assert_series_equal", "res", "width", "df", "width", "n", "for", "v2", "v3", "shift", "in", "zip", "product", "levels", "shifts", "rows", "df", "grp2", "v2", "df", "grp3", "v3", "assert_series_equal", "res", "loc", "rows", "x", "df", "loc", "rows", "x", "shift"], "doc_len": 84}
{"doc_id": "tests/_core/test_moves.py::TestStack.test_basic", "file_path": "tests/_core/test_moves.py", "class_name": "TestStack", "func_name": "test_basic", "text": "文件路径: tests/_core/test_moves.py, 类名: TestStack\n    def test_basic(self, toy_df):\n\n        groupby = GroupBy([\"color\", \"group\"])\n        res = Stack()(toy_df, groupby, \"x\", {})\n\n        assert_array_equal(res[\"x\"], [0, 0, 1])\n        assert_array_equal(res[\"y\"], [1, 3, 3])\n        assert_array_equal(res[\"baseline\"], [0, 1, 0])\n", "tokens": ["tests", "_core", "test_moves", "py", "teststack", "def", "test_basic", "self", "toy_df", "groupby", "groupby", "color", "group", "res", "stack", "toy_df", "groupby", "x", "assert_array_equal", "res", "x", "0", "0", "1", "assert_array_equal", "res", "y", "1", "3", "3", "assert_array_equal", "res", "baseline", "0", "1", "0"], "doc_len": 36}
{"doc_id": "tests/_core/test_moves.py::TestStack.test_faceted", "file_path": "tests/_core/test_moves.py", "class_name": "TestStack", "func_name": "test_faceted", "text": "文件路径: tests/_core/test_moves.py, 类名: TestStack\n    def test_faceted(self, toy_df_facets):\n\n        groupby = GroupBy([\"color\", \"group\"])\n        res = Stack()(toy_df_facets, groupby, \"x\", {})\n\n        assert_array_equal(res[\"x\"], [0, 0, 1, 0, 1, 2])\n        assert_array_equal(res[\"y\"], [1, 3, 3, 1, 2, 3])\n        assert_array_equal(res[\"baseline\"], [0, 1, 0, 0, 0, 0])\n", "tokens": ["tests", "_core", "test_moves", "py", "teststack", "def", "test_faceted", "self", "toy_df_facets", "groupby", "groupby", "color", "group", "res", "stack", "toy_df_facets", "groupby", "x", "assert_array_equal", "res", "x", "0", "0", "1", "0", "1", "2", "assert_array_equal", "res", "y", "1", "3", "3", "1", "2", "3", "assert_array_equal", "res", "baseline", "0", "1", "0", "0", "0", "0"], "doc_len": 45}
{"doc_id": "tests/_core/test_moves.py::TestStack.test_misssing_data", "file_path": "tests/_core/test_moves.py", "class_name": "TestStack", "func_name": "test_misssing_data", "text": "文件路径: tests/_core/test_moves.py, 类名: TestStack\n    def test_misssing_data(self, toy_df):\n\n        df = pd.DataFrame({\n            \"x\": [0, 0, 0],\n            \"y\": [2, np.nan, 1],\n            \"baseline\": [0, 0, 0],\n        })\n        res = Stack()(df, None, \"x\", {})\n        assert_array_equal(res[\"y\"], [2, np.nan, 3])\n        assert_array_equal(res[\"baseline\"], [0, np.nan, 2])\n", "tokens": ["tests", "_core", "test_moves", "py", "teststack", "def", "test_misssing_data", "self", "toy_df", "df", "pd", "dataframe", "x", "0", "0", "0", "y", "2", "np", "nan", "1", "baseline", "0", "0", "0", "res", "stack", "df", "none", "x", "assert_array_equal", "res", "y", "2", "np", "nan", "3", "assert_array_equal", "res", "baseline", "0", "np", "nan", "2"], "doc_len": 44}
{"doc_id": "tests/_core/test_moves.py::TestStack.test_baseline_homogeneity_check", "file_path": "tests/_core/test_moves.py", "class_name": "TestStack", "func_name": "test_baseline_homogeneity_check", "text": "文件路径: tests/_core/test_moves.py, 类名: TestStack\n    def test_baseline_homogeneity_check(self, toy_df):\n\n        toy_df[\"baseline\"] = [0, 1, 2]\n        groupby = GroupBy([\"color\", \"group\"])\n        move = Stack()\n        err = \"Stack move cannot be used when baselines\"\n        with pytest.raises(RuntimeError, match=err):\n            move(toy_df, groupby, \"x\", {})\n", "tokens": ["tests", "_core", "test_moves", "py", "teststack", "def", "test_baseline_homogeneity_check", "self", "toy_df", "toy_df", "baseline", "0", "1", "2", "groupby", "groupby", "color", "group", "move", "stack", "err", "stack", "move", "cannot", "be", "used", "when", "baselines", "with", "pytest", "raises", "runtimeerror", "match", "err", "move", "toy_df", "groupby", "x"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestShift.test_default", "file_path": "tests/_core/test_moves.py", "class_name": "TestShift", "func_name": "test_default", "text": "文件路径: tests/_core/test_moves.py, 类名: TestShift\n    def test_default(self, toy_df):\n\n        gb = GroupBy([\"color\", \"group\"])\n        res = Shift()(toy_df, gb, \"x\", {})\n        for col in toy_df:\n            assert_series_equal(toy_df[col], res[col])\n", "tokens": ["tests", "_core", "test_moves", "py", "testshift", "def", "test_default", "self", "toy_df", "gb", "groupby", "color", "group", "res", "shift", "toy_df", "gb", "x", "for", "col", "in", "toy_df", "assert_series_equal", "toy_df", "col", "res", "col"], "doc_len": 27}
{"doc_id": "tests/_core/test_moves.py::TestShift.test_moves", "file_path": "tests/_core/test_moves.py", "class_name": "TestShift", "func_name": "test_moves", "text": "文件路径: tests/_core/test_moves.py, 类名: TestShift\n    def test_moves(self, toy_df, x, y):\n\n        gb = GroupBy([\"color\", \"group\"])\n        res = Shift(x=x, y=y)(toy_df, gb, \"x\", {})\n        assert_array_equal(res[\"x\"], toy_df[\"x\"] + x)\n        assert_array_equal(res[\"y\"], toy_df[\"y\"] + y)\n", "tokens": ["tests", "_core", "test_moves", "py", "testshift", "def", "test_moves", "self", "toy_df", "x", "y", "gb", "groupby", "color", "group", "res", "shift", "x", "x", "y", "y", "toy_df", "gb", "x", "assert_array_equal", "res", "x", "toy_df", "x", "x", "assert_array_equal", "res", "y", "toy_df", "y", "y"], "doc_len": 36}
{"doc_id": "tests/_core/test_moves.py::TestNorm.test_default_no_groups", "file_path": "tests/_core/test_moves.py", "class_name": "TestNorm", "func_name": "test_default_no_groups", "text": "文件路径: tests/_core/test_moves.py, 类名: TestNorm\n    def test_default_no_groups(self, df, orient):\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        gb = GroupBy([\"null\"])\n        res = Norm()(df, gb, orient, {})\n        assert res[other].max() == pytest.approx(1)\n", "tokens": ["tests", "_core", "test_moves", "py", "testnorm", "def", "test_default_no_groups", "self", "df", "orient", "other", "x", "y", "y", "x", "orient", "gb", "groupby", "null", "res", "norm", "df", "gb", "orient", "assert", "res", "other", "max", "pytest", "approx", "1"], "doc_len": 31}
{"doc_id": "tests/_core/test_moves.py::TestNorm.test_default_groups", "file_path": "tests/_core/test_moves.py", "class_name": "TestNorm", "func_name": "test_default_groups", "text": "文件路径: tests/_core/test_moves.py, 类名: TestNorm\n    def test_default_groups(self, df, orient):\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        gb = GroupBy([\"grp2\"])\n        res = Norm()(df, gb, orient, {})\n        for _, grp in res.groupby(\"grp2\"):\n            assert grp[other].max() == pytest.approx(1)\n", "tokens": ["tests", "_core", "test_moves", "py", "testnorm", "def", "test_default_groups", "self", "df", "orient", "other", "x", "y", "y", "x", "orient", "gb", "groupby", "grp2", "res", "norm", "df", "gb", "orient", "for", "_", "grp", "in", "res", "groupby", "grp2", "assert", "grp", "other", "max", "pytest", "approx", "1"], "doc_len": 38}
{"doc_id": "tests/_core/test_moves.py::TestNorm.test_sum", "file_path": "tests/_core/test_moves.py", "class_name": "TestNorm", "func_name": "test_sum", "text": "文件路径: tests/_core/test_moves.py, 类名: TestNorm\n    def test_sum(self, df):\n\n        gb = GroupBy([\"null\"])\n        res = Norm(\"sum\")(df, gb, \"x\", {})\n        assert res[\"y\"].sum() == pytest.approx(1)\n", "tokens": ["tests", "_core", "test_moves", "py", "testnorm", "def", "test_sum", "self", "df", "gb", "groupby", "null", "res", "norm", "sum", "df", "gb", "x", "assert", "res", "y", "sum", "pytest", "approx", "1"], "doc_len": 25}
{"doc_id": "tests/_core/test_moves.py::TestNorm.test_where", "file_path": "tests/_core/test_moves.py", "class_name": "TestNorm", "func_name": "test_where", "text": "文件路径: tests/_core/test_moves.py, 类名: TestNorm\n    def test_where(self, df):\n\n        gb = GroupBy([\"null\"])\n        res = Norm(where=\"x == 2\")(df, gb, \"x\", {})\n        assert res.loc[res[\"x\"] == 2, \"y\"].max() == pytest.approx(1)\n", "tokens": ["tests", "_core", "test_moves", "py", "testnorm", "def", "test_where", "self", "df", "gb", "groupby", "null", "res", "norm", "where", "x", "2", "df", "gb", "x", "assert", "res", "loc", "res", "x", "2", "y", "max", "pytest", "approx", "1"], "doc_len": 31}
{"doc_id": "tests/_core/test_moves.py::TestNorm.test_percent", "file_path": "tests/_core/test_moves.py", "class_name": "TestNorm", "func_name": "test_percent", "text": "文件路径: tests/_core/test_moves.py, 类名: TestNorm\n    def test_percent(self, df):\n\n        gb = GroupBy([\"null\"])\n        res = Norm(percent=True)(df, gb, \"x\", {})\n        assert res[\"y\"].max() == pytest.approx(100)\n", "tokens": ["tests", "_core", "test_moves", "py", "testnorm", "def", "test_percent", "self", "df", "gb", "groupby", "null", "res", "norm", "percent", "true", "df", "gb", "x", "assert", "res", "y", "max", "pytest", "approx", "100"], "doc_len": 26}
{"doc_id": "tests/_core/test_plot.py::assert_gridspec_shape", "file_path": "tests/_core/test_plot.py", "class_name": null, "func_name": "assert_gridspec_shape", "text": "文件路径: tests/_core/test_plot.py\ndef assert_gridspec_shape(ax, nrows=1, ncols=1):\n\n    gs = ax.get_gridspec()\n    if Version(mpl.__version__) < Version(\"3.2\"):\n        assert gs._nrows == nrows\n        assert gs._ncols == ncols\n    else:\n        assert gs.nrows == nrows\n        assert gs.ncols == ncols\n", "tokens": ["tests", "_core", "test_plot", "py", "def", "assert_gridspec_shape", "ax", "nrows", "1", "ncols", "1", "gs", "ax", "get_gridspec", "if", "version", "mpl", "__version__", "version", "3", "2", "assert", "gs", "_nrows", "nrows", "assert", "gs", "_ncols", "ncols", "else", "assert", "gs", "nrows", "nrows", "assert", "gs", "ncols", "ncols"], "doc_len": 38}
{"doc_id": "tests/_core/test_plot.py::MockMark.__init__", "file_path": "tests/_core/test_plot.py", "class_name": "MockMark", "func_name": "__init__", "text": "文件路径: tests/_core/test_plot.py, 类名: MockMark\n    def __init__(self, *args, **kwargs):\n\n        super().__init__(*args, **kwargs)\n        self.passed_keys = []\n        self.passed_data = []\n        self.passed_axes = []\n        self.passed_scales = None\n        self.passed_orient = None\n        self.n_splits = 0\n", "tokens": ["tests", "_core", "test_plot", "py", "mockmark", "def", "__init__", "self", "args", "kwargs", "super", "__init__", "args", "kwargs", "self", "passed_keys", "self", "passed_data", "self", "passed_axes", "self", "passed_scales", "none", "self", "passed_orient", "none", "self", "n_splits", "0"], "doc_len": 29}
{"doc_id": "tests/_core/test_plot.py::MockMark._plot", "file_path": "tests/_core/test_plot.py", "class_name": "MockMark", "func_name": "_plot", "text": "文件路径: tests/_core/test_plot.py, 类名: MockMark\n    def _plot(self, split_gen, scales, orient):\n\n        for keys, data, ax in split_gen():\n            self.n_splits += 1\n            self.passed_keys.append(keys)\n            self.passed_data.append(data)\n            self.passed_axes.append(ax)\n\n        self.passed_scales = scales\n        self.passed_orient = orient\n", "tokens": ["tests", "_core", "test_plot", "py", "mockmark", "def", "_plot", "self", "split_gen", "scales", "orient", "for", "keys", "data", "ax", "in", "split_gen", "self", "n_splits", "1", "self", "passed_keys", "append", "keys", "self", "passed_data", "append", "data", "self", "passed_axes", "append", "ax", "self", "passed_scales", "scales", "self", "passed_orient", "orient"], "doc_len": 38}
{"doc_id": "tests/_core/test_plot.py::MockMark._legend_artist", "file_path": "tests/_core/test_plot.py", "class_name": "MockMark", "func_name": "_legend_artist", "text": "文件路径: tests/_core/test_plot.py, 类名: MockMark\n    def _legend_artist(self, variables, value, scales):\n\n        a = mpl.lines.Line2D([], [])\n        a.variables = variables\n        a.value = value\n        return a\n", "tokens": ["tests", "_core", "test_plot", "py", "mockmark", "def", "_legend_artist", "self", "variables", "value", "scales", "a", "mpl", "lines", "line2d", "a", "variables", "variables", "a", "value", "value", "return", "a"], "doc_len": 23}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_empty", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_empty", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_empty(self):\n\n        p = Plot()\n        assert p._data.source_data is None\n        assert p._data.source_vars == {}\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_empty", "self", "p", "plot", "assert", "p", "_data", "source_data", "is", "none", "assert", "p", "_data", "source_vars"], "doc_len": 20}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_data_only", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_data_only", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_data_only(self, long_df):\n\n        p = Plot(long_df)\n        assert p._data.source_data is long_df\n        assert p._data.source_vars == {}\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_data_only", "self", "long_df", "p", "plot", "long_df", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "p", "_data", "source_vars"], "doc_len": 22}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_df_and_named_variables", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_df_and_named_variables", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_df_and_named_variables(self, long_df):\n\n        variables = {\"x\": \"a\", \"y\": \"z\"}\n        p = Plot(long_df, **variables)\n        for var, col in variables.items():\n            assert_vector_equal(p._data.frame[var], long_df[col])\n        assert p._data.source_data is long_df\n        assert p._data.source_vars.keys() == variables.keys()\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_df_and_named_variables", "self", "long_df", "variables", "x", "a", "y", "z", "p", "plot", "long_df", "variables", "for", "var", "col", "in", "variables", "items", "assert_vector_equal", "p", "_data", "frame", "var", "long_df", "col", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "p", "_data", "source_vars", "keys", "variables", "keys"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_df_and_mixed_variables", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_df_and_mixed_variables", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_df_and_mixed_variables(self, long_df):\n\n        variables = {\"x\": \"a\", \"y\": long_df[\"z\"]}\n        p = Plot(long_df, **variables)\n        for var, col in variables.items():\n            if isinstance(col, str):\n                assert_vector_equal(p._data.frame[var], long_df[col])\n            else:\n                assert_vector_equal(p._data.frame[var], col)\n        assert p._data.source_data is long_df\n        assert p._data.source_vars.keys() == variables.keys()\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_df_and_mixed_variables", "self", "long_df", "variables", "x", "a", "y", "long_df", "z", "p", "plot", "long_df", "variables", "for", "var", "col", "in", "variables", "items", "if", "isinstance", "col", "str", "assert_vector_equal", "p", "_data", "frame", "var", "long_df", "col", "else", "assert_vector_equal", "p", "_data", "frame", "var", "col", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "p", "_data", "source_vars", "keys", "variables", "keys"], "doc_len": 56}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_vector_variables_only", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_vector_variables_only", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_vector_variables_only(self, long_df):\n\n        variables = {\"x\": long_df[\"a\"], \"y\": long_df[\"z\"]}\n        p = Plot(**variables)\n        for var, col in variables.items():\n            assert_vector_equal(p._data.frame[var], col)\n        assert p._data.source_data is None\n        assert p._data.source_vars.keys() == variables.keys()\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_vector_variables_only", "self", "long_df", "variables", "x", "long_df", "a", "y", "long_df", "z", "p", "plot", "variables", "for", "var", "col", "in", "variables", "items", "assert_vector_equal", "p", "_data", "frame", "var", "col", "assert", "p", "_data", "source_data", "is", "none", "assert", "p", "_data", "source_vars", "keys", "variables", "keys"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_vector_variables_no_index", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_vector_variables_no_index", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_vector_variables_no_index(self, long_df):\n\n        variables = {\"x\": long_df[\"a\"].to_numpy(), \"y\": long_df[\"z\"].to_list()}\n        p = Plot(**variables)\n        for var, col in variables.items():\n            assert_vector_equal(p._data.frame[var], pd.Series(col))\n            assert p._data.names[var] is None\n        assert p._data.source_data is None\n        assert p._data.source_vars.keys() == variables.keys()\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_vector_variables_no_index", "self", "long_df", "variables", "x", "long_df", "a", "to_numpy", "y", "long_df", "z", "to_list", "p", "plot", "variables", "for", "var", "col", "in", "variables", "items", "assert_vector_equal", "p", "_data", "frame", "var", "pd", "series", "col", "assert", "p", "_data", "names", "var", "is", "none", "assert", "p", "_data", "source_data", "is", "none", "assert", "p", "_data", "source_vars", "keys", "variables", "keys"], "doc_len": 55}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_data_only_named", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_data_only_named", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_data_only_named(self, long_df):\n\n        p = Plot(data=long_df)\n        assert p._data.source_data is long_df\n        assert p._data.source_vars == {}\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_data_only_named", "self", "long_df", "p", "plot", "data", "long_df", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "p", "_data", "source_vars"], "doc_len": 23}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_and_named_data", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_and_named_data", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_and_named_data(self, long_df):\n\n        err = \"`data` given by both name and position\"\n        with pytest.raises(TypeError, match=err):\n            Plot(long_df, data=long_df)\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_and_named_data", "self", "long_df", "err", "data", "given", "by", "both", "name", "and", "position", "with", "pytest", "raises", "typeerror", "match", "err", "plot", "long_df", "data", "long_df"], "doc_len": 27}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_and_named_xy", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_and_named_xy", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_and_named_xy(self, long_df, var):\n\n        err = f\"`{var}` given by both name and position\"\n        with pytest.raises(TypeError, match=err):\n            Plot(long_df, \"a\", \"b\", **{var: \"c\"})\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_and_named_xy", "self", "long_df", "var", "err", "f", "var", "given", "by", "both", "name", "and", "position", "with", "pytest", "raises", "typeerror", "match", "err", "plot", "long_df", "a", "b", "var", "c"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_data_x_y", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_data_x_y", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_data_x_y(self, long_df):\n\n        p = Plot(long_df, \"a\", \"b\")\n        assert p._data.source_data is long_df\n        assert list(p._data.source_vars) == [\"x\", \"y\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_data_x_y", "self", "long_df", "p", "plot", "long_df", "a", "b", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "list", "p", "_data", "source_vars", "x", "y"], "doc_len": 27}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_x_y", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_x_y", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_x_y(self, long_df):\n\n        p = Plot(long_df[\"a\"], long_df[\"b\"])\n        assert p._data.source_data is None\n        assert list(p._data.source_vars) == [\"x\", \"y\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_x_y", "self", "long_df", "p", "plot", "long_df", "a", "long_df", "b", "assert", "p", "_data", "source_data", "is", "none", "assert", "list", "p", "_data", "source_vars", "x", "y"], "doc_len": 28}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_data_x", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_data_x", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_data_x(self, long_df):\n\n        p = Plot(long_df, \"a\")\n        assert p._data.source_data is long_df\n        assert list(p._data.source_vars) == [\"x\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_data_x", "self", "long_df", "p", "plot", "long_df", "a", "assert", "p", "_data", "source_data", "is", "long_df", "assert", "list", "p", "_data", "source_vars", "x"], "doc_len": 25}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_x", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_x", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_x(self, long_df):\n\n        p = Plot(long_df[\"a\"])\n        assert p._data.source_data is None\n        assert list(p._data.source_vars) == [\"x\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_x", "self", "long_df", "p", "plot", "long_df", "a", "assert", "p", "_data", "source_data", "is", "none", "assert", "list", "p", "_data", "source_vars", "x"], "doc_len": 25}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_positional_too_many", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_positional_too_many", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_positional_too_many(self, long_df):\n\n        err = r\"Plot\\(\\) accepts no more than 3 positional arguments \\(data, x, y\\)\"\n        with pytest.raises(TypeError, match=err):\n            Plot(long_df, \"x\", \"y\", \"z\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_positional_too_many", "self", "long_df", "err", "r", "plot", "accepts", "no", "more", "than", "3", "positional", "arguments", "data", "x", "y", "with", "pytest", "raises", "typeerror", "match", "err", "plot", "long_df", "x", "y", "z"], "doc_len": 33}
{"doc_id": "tests/_core/test_plot.py::TestInit.test_unknown_keywords", "file_path": "tests/_core/test_plot.py", "class_name": "TestInit", "func_name": "test_unknown_keywords", "text": "文件路径: tests/_core/test_plot.py, 类名: TestInit\n    def test_unknown_keywords(self, long_df):\n\n        err = r\"Plot\\(\\) got unexpected keyword argument\\(s\\): bad\"\n        with pytest.raises(TypeError, match=err):\n            Plot(long_df, bad=\"x\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testinit", "def", "test_unknown_keywords", "self", "long_df", "err", "r", "plot", "got", "unexpected", "keyword", "argument", "s", "bad", "with", "pytest", "raises", "typeerror", "match", "err", "plot", "long_df", "bad", "x"], "doc_len": 28}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_without_data", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_without_data", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_without_data(self, long_df):\n\n        p = Plot(long_df, x=\"x\", y=\"y\").add(MockMark()).plot()\n        layer, = p._layers\n        assert_frame_equal(p._data.frame, layer[\"data\"].frame, check_dtype=False)\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_without_data", "self", "long_df", "p", "plot", "long_df", "x", "x", "y", "y", "add", "mockmark", "plot", "layer", "p", "_layers", "assert_frame_equal", "p", "_data", "frame", "layer", "data", "frame", "check_dtype", "false"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_with_new_variable_by_name", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_with_new_variable_by_name", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_with_new_variable_by_name(self, long_df):\n\n        p = Plot(long_df, x=\"x\").add(MockMark(), y=\"y\").plot()\n        layer, = p._layers\n        assert layer[\"data\"].frame.columns.to_list() == [\"x\", \"y\"]\n        for var in \"xy\":\n            assert_vector_equal(layer[\"data\"].frame[var], long_df[var])\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_with_new_variable_by_name", "self", "long_df", "p", "plot", "long_df", "x", "x", "add", "mockmark", "y", "y", "plot", "layer", "p", "_layers", "assert", "layer", "data", "frame", "columns", "to_list", "x", "y", "for", "var", "in", "xy", "assert_vector_equal", "layer", "data", "frame", "var", "long_df", "var"], "doc_len": 41}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_with_new_variable_by_vector", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_with_new_variable_by_vector", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_with_new_variable_by_vector(self, long_df):\n\n        p = Plot(long_df, x=\"x\").add(MockMark(), y=long_df[\"y\"]).plot()\n        layer, = p._layers\n        assert layer[\"data\"].frame.columns.to_list() == [\"x\", \"y\"]\n        for var in \"xy\":\n            assert_vector_equal(layer[\"data\"].frame[var], long_df[var])\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_with_new_variable_by_vector", "self", "long_df", "p", "plot", "long_df", "x", "x", "add", "mockmark", "y", "long_df", "y", "plot", "layer", "p", "_layers", "assert", "layer", "data", "frame", "columns", "to_list", "x", "y", "for", "var", "in", "xy", "assert_vector_equal", "layer", "data", "frame", "var", "long_df", "var"], "doc_len": 42}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_with_late_data_definition", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_with_late_data_definition", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_with_late_data_definition(self, long_df):\n\n        p = Plot().add(MockMark(), data=long_df, x=\"x\", y=\"y\").plot()\n        layer, = p._layers\n        assert layer[\"data\"].frame.columns.to_list() == [\"x\", \"y\"]\n        for var in \"xy\":\n            assert_vector_equal(layer[\"data\"].frame[var], long_df[var])\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_with_late_data_definition", "self", "long_df", "p", "plot", "add", "mockmark", "data", "long_df", "x", "x", "y", "y", "plot", "layer", "p", "_layers", "assert", "layer", "data", "frame", "columns", "to_list", "x", "y", "for", "var", "in", "xy", "assert_vector_equal", "layer", "data", "frame", "var", "long_df", "var"], "doc_len": 42}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_with_new_data_definition", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_with_new_data_definition", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_with_new_data_definition(self, long_df):\n\n        long_df_sub = long_df.sample(frac=.5)\n\n        p = Plot(long_df, x=\"x\", y=\"y\").add(MockMark(), data=long_df_sub).plot()\n        layer, = p._layers\n        assert layer[\"data\"].frame.columns.to_list() == [\"x\", \"y\"]\n        for var in \"xy\":\n            assert_vector_equal(\n                layer[\"data\"].frame[var], long_df_sub[var].reindex(long_df.index)\n            )\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_with_new_data_definition", "self", "long_df", "long_df_sub", "long_df", "sample", "frac", "5", "p", "plot", "long_df", "x", "x", "y", "y", "add", "mockmark", "data", "long_df_sub", "plot", "layer", "p", "_layers", "assert", "layer", "data", "frame", "columns", "to_list", "x", "y", "for", "var", "in", "xy", "assert_vector_equal", "layer", "data", "frame", "var", "long_df_sub", "var", "reindex", "long_df", "index"], "doc_len": 51}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_drop_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_drop_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_drop_variable(self, long_df):\n\n        p = Plot(long_df, x=\"x\", y=\"y\").add(MockMark(), y=None).plot()\n        layer, = p._layers\n        assert layer[\"data\"].frame.columns.to_list() == [\"x\"]\n        assert_vector_equal(layer[\"data\"].frame[\"x\"], long_df[\"x\"], check_dtype=False)\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_drop_variable", "self", "long_df", "p", "plot", "long_df", "x", "x", "y", "y", "add", "mockmark", "y", "none", "plot", "layer", "p", "_layers", "assert", "layer", "data", "frame", "columns", "to_list", "x", "assert_vector_equal", "layer", "data", "frame", "x", "long_df", "x", "check_dtype", "false"], "doc_len": 40}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_stat_default", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_stat_default", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_stat_default(self):\n\n        class MarkWithDefaultStat(Mark):\n            default_stat = Stat\n\n        p = Plot().add(MarkWithDefaultStat())\n        layer, = p._layers\n        assert layer[\"stat\"].__class__ is Stat\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_stat_default", "self", "class", "markwithdefaultstat", "mark", "default_stat", "stat", "p", "plot", "add", "markwithdefaultstat", "layer", "p", "_layers", "assert", "layer", "stat", "__class__", "is", "stat"], "doc_len": 26}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_stat_nondefault", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_stat_nondefault", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_stat_nondefault(self):\n\n        class MarkWithDefaultStat(Mark):\n            default_stat = Stat\n\n        class OtherMockStat(Stat):\n            pass\n\n        p = Plot().add(MarkWithDefaultStat(), OtherMockStat())\n        layer, = p._layers\n        assert layer[\"stat\"].__class__ is OtherMockStat\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_stat_nondefault", "self", "class", "markwithdefaultstat", "mark", "default_stat", "stat", "class", "othermockstat", "stat", "pass", "p", "plot", "add", "markwithdefaultstat", "othermockstat", "layer", "p", "_layers", "assert", "layer", "stat", "__class__", "is", "othermockstat"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_orient", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_orient", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_orient(self, arg, expected):\n\n        class MockStatTrackOrient(Stat):\n            def __call__(self, data, groupby, orient, scales):\n                self.orient_at_call = orient\n                return data\n\n        class MockMoveTrackOrient(Move):\n            def __call__(self, data, groupby, orient, scales):\n                self.orient_at_call = orient\n                return data\n\n        s = MockStatTrackOrient()\n        m = MockMoveTrackOrient()\n        Plot(x=[1, 2, 3], y=[1, 2, 3]).add(MockMark(), s, m, orient=arg).plot()\n\n        assert s.orient_at_call == expected\n        assert m.orient_at_call == expected\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_orient", "self", "arg", "expected", "class", "mockstattrackorient", "stat", "def", "__call__", "self", "data", "groupby", "orient", "scales", "self", "orient_at_call", "orient", "return", "data", "class", "mockmovetrackorient", "move", "def", "__call__", "self", "data", "groupby", "orient", "scales", "self", "orient_at_call", "orient", "return", "data", "s", "mockstattrackorient", "m", "mockmovetrackorient", "plot", "x", "1", "2", "3", "y", "1", "2", "3", "add", "mockmark", "s", "m", "orient", "arg", "plot", "assert", "s", "orient_at_call", "expected", "assert", "m", "orient_at_call", "expected"], "doc_len": 68}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_variable_list", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_variable_list", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_variable_list(self, long_df):\n\n        p = Plot(long_df, x=\"x\", y=\"y\")\n        assert p._variables == [\"x\", \"y\"]\n\n        p = Plot(long_df).add(MockMark(), x=\"x\", y=\"y\")\n        assert p._variables == [\"x\", \"y\"]\n\n        p = Plot(long_df, y=\"x\", color=\"a\").add(MockMark(), x=\"y\")\n        assert p._variables == [\"y\", \"color\", \"x\"]\n\n        p = Plot(long_df, x=\"x\", y=\"y\", color=\"a\").add(MockMark(), color=None)\n        assert p._variables == [\"x\", \"y\", \"color\"]\n\n        p = (\n            Plot(long_df, x=\"x\", y=\"y\")\n            .add(MockMark(), color=\"a\")\n            .add(MockMark(), alpha=\"s\")\n        )\n        assert p._variables == [\"x\", \"y\", \"color\", \"alpha\"]\n\n        p = Plot(long_df, y=\"x\").pair(x=[\"a\", \"b\"])\n        assert p._variables == [\"y\", \"x0\", \"x1\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_variable_list", "self", "long_df", "p", "plot", "long_df", "x", "x", "y", "y", "assert", "p", "_variables", "x", "y", "p", "plot", "long_df", "add", "mockmark", "x", "x", "y", "y", "assert", "p", "_variables", "x", "y", "p", "plot", "long_df", "y", "x", "color", "a", "add", "mockmark", "x", "y", "assert", "p", "_variables", "y", "color", "x", "p", "plot", "long_df", "x", "x", "y", "y", "color", "a", "add", "mockmark", "color", "none", "assert", "p", "_variables", "x", "y", "color", "p", "plot", "long_df", "x", "x", "y", "y", "add", "mockmark", "color", "a", "add", "mockmark", "alpha", "s", "assert", "p", "_variables", "x", "y", "color", "alpha", "p", "plot", "long_df", "y", "x", "pair", "x", "a", "b", "assert", "p", "_variables", "y", "x0", "x1"], "doc_len": 108}
{"doc_id": "tests/_core/test_plot.py::TestLayerAddition.test_type_checks", "file_path": "tests/_core/test_plot.py", "class_name": "TestLayerAddition", "func_name": "test_type_checks", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLayerAddition\n    def test_type_checks(self):\n\n        p = Plot()\n        with pytest.raises(TypeError, match=\"mark must be a Mark instance\"):\n            p.add(MockMark)\n\n        class MockStat(Stat):\n            pass\n\n        class MockMove(Move):\n            pass\n\n        err = \"Transforms must have at most one Stat type\"\n\n        with pytest.raises(TypeError, match=err):\n            p.add(MockMark(), MockStat)\n\n        with pytest.raises(TypeError, match=err):\n            p.add(MockMark(), MockMove(), MockStat())\n\n        with pytest.raises(TypeError, match=err):\n            p.add(MockMark(), MockMark(), MockStat())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlayeraddition", "def", "test_type_checks", "self", "p", "plot", "with", "pytest", "raises", "typeerror", "match", "mark", "must", "be", "a", "mark", "instance", "p", "add", "mockmark", "class", "mockstat", "stat", "pass", "class", "mockmove", "move", "pass", "err", "transforms", "must", "have", "at", "most", "one", "stat", "type", "with", "pytest", "raises", "typeerror", "match", "err", "p", "add", "mockmark", "mockstat", "with", "pytest", "raises", "typeerror", "match", "err", "p", "add", "mockmark", "mockmove", "mockstat", "with", "pytest", "raises", "typeerror", "match", "err", "p", "add", "mockmark", "mockmark", "mockstat"], "doc_len": 73}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_inference", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_inference", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_inference(self, long_df):\n\n        for col, scale_type in zip(\"zat\", [\"Continuous\", \"Nominal\", \"Temporal\"]):\n            p = Plot(long_df, x=col, y=col).add(MockMark()).plot()\n            for var in \"xy\":\n                assert p._scales[var].__class__.__name__ == scale_type\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_inference", "self", "long_df", "for", "col", "scale_type", "in", "zip", "zat", "continuous", "nominal", "temporal", "p", "plot", "long_df", "x", "col", "y", "col", "add", "mockmark", "plot", "for", "var", "in", "xy", "assert", "p", "_scales", "var", "__class__", "__name__", "scale_type"], "doc_len": 39}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_inference_from_layer_data", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_inference_from_layer_data", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_inference_from_layer_data(self):\n\n        p = Plot().add(MockMark(), x=[\"a\", \"b\", \"c\"]).plot()\n        assert p._scales[\"x\"](\"b\") == 1\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_inference_from_layer_data", "self", "p", "plot", "add", "mockmark", "x", "a", "b", "c", "plot", "assert", "p", "_scales", "x", "b", "1"], "doc_len": 23}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_inference_joins", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_inference_joins", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_inference_joins(self):\n\n        p = (\n            Plot(y=pd.Series([1, 2, 3, 4]))\n            .add(MockMark(), x=pd.Series([1, 2]))\n            .add(MockMark(), x=pd.Series([\"a\", \"b\"], index=[2, 3]))\n            .plot()\n        )\n        assert p._scales[\"x\"](\"a\") == 2\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_inference_joins", "self", "p", "plot", "y", "pd", "series", "1", "2", "3", "4", "add", "mockmark", "x", "pd", "series", "1", "2", "add", "mockmark", "x", "pd", "series", "a", "b", "index", "2", "3", "plot", "assert", "p", "_scales", "x", "a", "2"], "doc_len": 41}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_inferred_categorical_converter", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_inferred_categorical_converter", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_inferred_categorical_converter(self):\n\n        p = Plot(x=[\"b\", \"c\", \"a\"]).add(MockMark()).plot()\n        ax = p._figure.axes[0]\n        assert ax.xaxis.convert_units(\"c\") == 1\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_inferred_categorical_converter", "self", "p", "plot", "x", "b", "c", "a", "add", "mockmark", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "xaxis", "convert_units", "c", "1"], "doc_len": 28}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_explicit_categorical_converter", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_explicit_categorical_converter", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_explicit_categorical_converter(self):\n\n        p = Plot(y=[2, 1, 3]).scale(y=Nominal()).add(MockMark()).plot()\n        ax = p._figure.axes[0]\n        assert ax.yaxis.convert_units(\"3\") == 2\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_explicit_categorical_converter", "self", "p", "plot", "y", "2", "1", "3", "scale", "y", "nominal", "add", "mockmark", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "yaxis", "convert_units", "3", "2"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_categorical_as_datetime", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_categorical_as_datetime", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_categorical_as_datetime(self):\n\n        dates = [\"1970-01-03\", \"1970-01-02\", \"1970-01-04\"]\n        p = Plot(x=dates).scale(...).add(MockMark()).plot()\n        p  # TODO\n        ...\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_categorical_as_datetime", "self", "dates", "1970", "01", "03", "1970", "01", "02", "1970", "01", "04", "p", "plot", "x", "dates", "scale", "add", "mockmark", "plot", "p", "todo"], "doc_len": 28}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_faceted_log_scale", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_faceted_log_scale", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_faceted_log_scale(self):\n\n        p = Plot(y=[1, 10]).facet(col=[\"a\", \"b\"]).scale(y=\"log\").plot()\n        for ax in p._figure.axes:\n            xfm = ax.yaxis.get_transform().transform\n            assert_array_equal(xfm([1, 10, 100]), [0, 1, 2])\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_faceted_log_scale", "self", "p", "plot", "y", "1", "10", "facet", "col", "a", "b", "scale", "y", "log", "plot", "for", "ax", "in", "p", "_figure", "axes", "xfm", "ax", "yaxis", "get_transform", "transform", "assert_array_equal", "xfm", "1", "10", "100", "0", "1", "2"], "doc_len": 40}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_paired_single_log_scale", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_paired_single_log_scale", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_paired_single_log_scale(self):\n\n        x0, x1 = [1, 2, 3], [1, 10, 100]\n        p = Plot().pair(x=[x0, x1]).scale(x1=\"log\").plot()\n        ax_lin, ax_log = p._figure.axes\n        xfm_lin = ax_lin.xaxis.get_transform().transform\n        assert_array_equal(xfm_lin([1, 10, 100]), [1, 10, 100])\n        xfm_log = ax_log.xaxis.get_transform().transform\n        assert_array_equal(xfm_log([1, 10, 100]), [0, 1, 2])\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_paired_single_log_scale", "self", "x0", "x1", "1", "2", "3", "1", "10", "100", "p", "plot", "pair", "x", "x0", "x1", "scale", "x1", "log", "plot", "ax_lin", "ax_log", "p", "_figure", "axes", "xfm_lin", "ax_lin", "xaxis", "get_transform", "transform", "assert_array_equal", "xfm_lin", "1", "10", "100", "1", "10", "100", "xfm_log", "ax_log", "xaxis", "get_transform", "transform", "assert_array_equal", "xfm_log", "1", "10", "100", "0", "1", "2"], "doc_len": 57}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_log_scale_name", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_log_scale_name", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_log_scale_name(self):\n\n        p = Plot().scale(x=\"log\").plot()\n        ax = p._figure.axes[0]\n        assert ax.get_xscale() == \"log\"\n        assert ax.get_yscale() == \"linear\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_log_scale_name", "self", "p", "plot", "scale", "x", "log", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_xscale", "log", "assert", "ax", "get_yscale", "linear"], "doc_len": 27}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_mark_data_log_transform_is_inverted", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_mark_data_log_transform_is_inverted", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_mark_data_log_transform_is_inverted(self, long_df):\n\n        col = \"z\"\n        m = MockMark()\n        Plot(long_df, x=col).scale(x=\"log\").add(m).plot()\n        assert_vector_equal(m.passed_data[0][\"x\"], long_df[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_mark_data_log_transform_is_inverted", "self", "long_df", "col", "z", "m", "mockmark", "plot", "long_df", "x", "col", "scale", "x", "log", "add", "m", "plot", "assert_vector_equal", "m", "passed_data", "0", "x", "long_df", "col"], "doc_len": 30}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_mark_data_log_transfrom_with_stat", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_mark_data_log_transfrom_with_stat", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_mark_data_log_transfrom_with_stat(self, long_df):\n\n        class Mean(Stat):\n            group_by_orient = True\n\n            def __call__(self, data, groupby, orient, scales):\n                other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n                return groupby.agg(data, {other: \"mean\"})\n\n        col = \"z\"\n        grouper = \"a\"\n        m = MockMark()\n        s = Mean()\n\n        Plot(long_df, x=grouper, y=col).scale(y=\"log\").add(m, s).plot()\n\n        expected = (\n            long_df[col]\n            .pipe(np.log)\n            .groupby(long_df[grouper], sort=False)\n            .mean()\n            .pipe(np.exp)\n            .reset_index(drop=True)\n        )\n        assert_vector_equal(m.passed_data[0][\"y\"], expected)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_mark_data_log_transfrom_with_stat", "self", "long_df", "class", "mean", "stat", "group_by_orient", "true", "def", "__call__", "self", "data", "groupby", "orient", "scales", "other", "x", "y", "y", "x", "orient", "return", "groupby", "agg", "data", "other", "mean", "col", "z", "grouper", "a", "m", "mockmark", "s", "mean", "plot", "long_df", "x", "grouper", "y", "col", "scale", "y", "log", "add", "m", "s", "plot", "expected", "long_df", "col", "pipe", "np", "log", "groupby", "long_df", "grouper", "sort", "false", "mean", "pipe", "np", "exp", "reset_index", "drop", "true", "assert_vector_equal", "m", "passed_data", "0", "y", "expected"], "doc_len": 78}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_mark_data_from_categorical", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_mark_data_from_categorical", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_mark_data_from_categorical(self, long_df):\n\n        col = \"a\"\n        m = MockMark()\n        Plot(long_df, x=col).add(m).plot()\n\n        levels = categorical_order(long_df[col])\n        level_map = {x: float(i) for i, x in enumerate(levels)}\n        assert_vector_equal(m.passed_data[0][\"x\"], long_df[col].map(level_map))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_mark_data_from_categorical", "self", "long_df", "col", "a", "m", "mockmark", "plot", "long_df", "x", "col", "add", "m", "plot", "levels", "categorical_order", "long_df", "col", "level_map", "x", "float", "i", "for", "i", "x", "in", "enumerate", "levels", "assert_vector_equal", "m", "passed_data", "0", "x", "long_df", "col", "map", "level_map"], "doc_len": 43}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_mark_data_from_datetime", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_mark_data_from_datetime", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_mark_data_from_datetime(self, long_df):\n\n        col = \"t\"\n        m = MockMark()\n        Plot(long_df, x=col).add(m).plot()\n\n        expected = long_df[col].map(mpl.dates.date2num)\n        if Version(mpl.__version__) < Version(\"3.3\"):\n            expected = expected + mpl.dates.date2num(np.datetime64('0000-12-31'))\n\n        assert_vector_equal(m.passed_data[0][\"x\"], expected)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_mark_data_from_datetime", "self", "long_df", "col", "t", "m", "mockmark", "plot", "long_df", "x", "col", "add", "m", "plot", "expected", "long_df", "col", "map", "mpl", "dates", "date2num", "if", "version", "mpl", "__version__", "version", "3", "3", "expected", "expected", "mpl", "dates", "date2num", "np", "datetime64", "0000", "12", "31", "assert_vector_equal", "m", "passed_data", "0", "x", "expected"], "doc_len": 50}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_computed_var_ticks", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_computed_var_ticks", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_computed_var_ticks(self, long_df):\n\n        class Identity(Stat):\n            def __call__(self, df, groupby, orient, scales):\n                other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n                return df.assign(**{other: df[orient]})\n\n        tick_locs = [1, 2, 5]\n        scale = Continuous().tick(at=tick_locs)\n        p = Plot(long_df, \"x\").add(MockMark(), Identity()).scale(y=scale).plot()\n        ax = p._figure.axes[0]\n        assert_array_equal(ax.get_yticks(), tick_locs)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_computed_var_ticks", "self", "long_df", "class", "identity", "stat", "def", "__call__", "self", "df", "groupby", "orient", "scales", "other", "x", "y", "y", "x", "orient", "return", "df", "assign", "other", "df", "orient", "tick_locs", "1", "2", "5", "scale", "continuous", "tick", "at", "tick_locs", "p", "plot", "long_df", "x", "add", "mockmark", "identity", "scale", "y", "scale", "plot", "ax", "p", "_figure", "axes", "0", "assert_array_equal", "ax", "get_yticks", "tick_locs"], "doc_len": 60}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_computed_var_transform", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_computed_var_transform", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_computed_var_transform(self, long_df):\n\n        class Identity(Stat):\n            def __call__(self, df, groupby, orient, scales):\n                other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n                return df.assign(**{other: df[orient]})\n\n        p = Plot(long_df, \"x\").add(MockMark(), Identity()).scale(y=\"log\").plot()\n        ax = p._figure.axes[0]\n        xfm = ax.yaxis.get_transform().transform\n        assert_array_equal(xfm([1, 10, 100]), [0, 1, 2])\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_computed_var_transform", "self", "long_df", "class", "identity", "stat", "def", "__call__", "self", "df", "groupby", "orient", "scales", "other", "x", "y", "y", "x", "orient", "return", "df", "assign", "other", "df", "orient", "p", "plot", "long_df", "x", "add", "mockmark", "identity", "scale", "y", "log", "plot", "ax", "p", "_figure", "axes", "0", "xfm", "ax", "yaxis", "get_transform", "transform", "assert_array_equal", "xfm", "1", "10", "100", "0", "1", "2"], "doc_len": 60}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_explicit_range_with_axis_scaling", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_explicit_range_with_axis_scaling", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_explicit_range_with_axis_scaling(self):\n\n        x = [1, 2, 3]\n        ymin = [10, 100, 1000]\n        ymax = [20, 200, 2000]\n        m = MockMark()\n        Plot(x=x, ymin=ymin, ymax=ymax).add(m).scale(y=\"log\").plot()\n        assert_vector_equal(m.passed_data[0][\"ymax\"], pd.Series(ymax, dtype=float))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_explicit_range_with_axis_scaling", "self", "x", "1", "2", "3", "ymin", "10", "100", "1000", "ymax", "20", "200", "2000", "m", "mockmark", "plot", "x", "x", "ymin", "ymin", "ymax", "ymax", "add", "m", "scale", "y", "log", "plot", "assert_vector_equal", "m", "passed_data", "0", "ymax", "pd", "series", "ymax", "dtype", "float"], "doc_len": 45}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_derived_range_with_axis_scaling", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_derived_range_with_axis_scaling", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_derived_range_with_axis_scaling(self):\n\n        class AddOne(Stat):\n            def __call__(self, df, *args):\n                return df.assign(ymax=df[\"y\"] + 1)\n\n        x = y = [1, 10, 100]\n\n        m = MockMark()\n        Plot(x, y).add(m, AddOne()).scale(y=\"log\").plot()\n        assert_vector_equal(m.passed_data[0][\"ymax\"], pd.Series([10., 100., 1000.]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_derived_range_with_axis_scaling", "self", "class", "addone", "stat", "def", "__call__", "self", "df", "args", "return", "df", "assign", "ymax", "df", "y", "1", "x", "y", "1", "10", "100", "m", "mockmark", "plot", "x", "y", "add", "m", "addone", "scale", "y", "log", "plot", "assert_vector_equal", "m", "passed_data", "0", "ymax", "pd", "series", "10", "100", "1000"], "doc_len": 50}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_facet_categories", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_facet_categories", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_facet_categories(self):\n\n        m = MockMark()\n        p = Plot(x=[\"a\", \"b\", \"a\", \"c\"]).facet(col=[\"x\", \"x\", \"y\", \"y\"]).add(m).plot()\n        ax1, ax2 = p._figure.axes\n        assert len(ax1.get_xticks()) == 3\n        assert len(ax2.get_xticks()) == 3\n        assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n        assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 2.], [2, 3]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_facet_categories", "self", "m", "mockmark", "p", "plot", "x", "a", "b", "a", "c", "facet", "col", "x", "x", "y", "y", "add", "m", "plot", "ax1", "ax2", "p", "_figure", "axes", "assert", "len", "ax1", "get_xticks", "3", "assert", "len", "ax2", "get_xticks", "3", "assert_vector_equal", "m", "passed_data", "0", "x", "pd", "series", "0", "1", "0", "1", "assert_vector_equal", "m", "passed_data", "1", "x", "pd", "series", "0", "2", "2", "3"], "doc_len": 63}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_facet_categories_unshared", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_facet_categories_unshared", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_facet_categories_unshared(self):\n\n        m = MockMark()\n        p = (\n            Plot(x=[\"a\", \"b\", \"a\", \"c\"])\n            .facet(col=[\"x\", \"x\", \"y\", \"y\"])\n            .share(x=False)\n            .add(m)\n            .plot()\n        )\n        ax1, ax2 = p._figure.axes\n        assert len(ax1.get_xticks()) == 2\n        assert len(ax2.get_xticks()) == 2\n        assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n        assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 1.], [2, 3]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_facet_categories_unshared", "self", "m", "mockmark", "p", "plot", "x", "a", "b", "a", "c", "facet", "col", "x", "x", "y", "y", "share", "x", "false", "add", "m", "plot", "ax1", "ax2", "p", "_figure", "axes", "assert", "len", "ax1", "get_xticks", "2", "assert", "len", "ax2", "get_xticks", "2", "assert_vector_equal", "m", "passed_data", "0", "x", "pd", "series", "0", "1", "0", "1", "assert_vector_equal", "m", "passed_data", "1", "x", "pd", "series", "0", "1", "2", "3"], "doc_len": 66}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_facet_categories_single_dim_shared", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_facet_categories_single_dim_shared", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_facet_categories_single_dim_shared(self):\n\n        data = [\n            (\"a\", 1, 1), (\"b\", 1, 1),\n            (\"a\", 1, 2), (\"c\", 1, 2),\n            (\"b\", 2, 1), (\"d\", 2, 1),\n            (\"e\", 2, 2), (\"e\", 2, 1),\n        ]\n        df = pd.DataFrame(data, columns=[\"x\", \"row\", \"col\"]).assign(y=1)\n        m = MockMark()\n        p = (\n            Plot(df, x=\"x\")\n            .facet(row=\"row\", col=\"col\")\n            .add(m)\n            .share(x=\"row\")\n            .plot()\n        )\n\n        axs = p._figure.axes\n        for ax in axs:\n            assert ax.get_xticks() == [0, 1, 2]\n\n        assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n        assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 2.], [2, 3]))\n        assert_vector_equal(m.passed_data[2][\"x\"], pd.Series([0., 1., 2.], [4, 5, 7]))\n        assert_vector_equal(m.passed_data[3][\"x\"], pd.Series([2.], [6]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_facet_categories_single_dim_shared", "self", "data", "a", "1", "1", "b", "1", "1", "a", "1", "2", "c", "1", "2", "b", "2", "1", "d", "2", "1", "e", "2", "2", "e", "2", "1", "df", "pd", "dataframe", "data", "columns", "x", "row", "col", "assign", "y", "1", "m", "mockmark", "p", "plot", "df", "x", "x", "facet", "row", "row", "col", "col", "add", "m", "share", "x", "row", "plot", "axs", "p", "_figure", "axes", "for", "ax", "in", "axs", "assert", "ax", "get_xticks", "0", "1", "2", "assert_vector_equal", "m", "passed_data", "0", "x", "pd", "series", "0", "1", "0", "1", "assert_vector_equal", "m", "passed_data", "1", "x", "pd", "series", "0", "2", "2", "3", "assert_vector_equal", "m", "passed_data", "2", "x", "pd", "series", "0", "1", "2", "4", "5", "7", "assert_vector_equal", "m", "passed_data", "3", "x", "pd", "series", "2", "6"], "doc_len": 120}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_pair_categories", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_pair_categories", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_pair_categories(self):\n\n        data = [(\"a\", \"a\"), (\"b\", \"c\")]\n        df = pd.DataFrame(data, columns=[\"x1\", \"x2\"]).assign(y=1)\n        m = MockMark()\n        p = Plot(df, y=\"y\").pair(x=[\"x1\", \"x2\"]).add(m).plot()\n\n        ax1, ax2 = p._figure.axes\n        assert ax1.get_xticks() == [0, 1]\n        assert ax2.get_xticks() == [0, 1]\n        assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n        assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 1.], [0, 1]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_pair_categories", "self", "data", "a", "a", "b", "c", "df", "pd", "dataframe", "data", "columns", "x1", "x2", "assign", "y", "1", "m", "mockmark", "p", "plot", "df", "y", "y", "pair", "x", "x1", "x2", "add", "m", "plot", "ax1", "ax2", "p", "_figure", "axes", "assert", "ax1", "get_xticks", "0", "1", "assert", "ax2", "get_xticks", "0", "1", "assert_vector_equal", "m", "passed_data", "0", "x", "pd", "series", "0", "1", "0", "1", "assert_vector_equal", "m", "passed_data", "1", "x", "pd", "series", "0", "1", "0", "1"], "doc_len": 74}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_pair_categories_shared", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_pair_categories_shared", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_pair_categories_shared(self):\n\n        data = [(\"a\", \"a\"), (\"b\", \"c\")]\n        df = pd.DataFrame(data, columns=[\"x1\", \"x2\"]).assign(y=1)\n        m = MockMark()\n        p = Plot(df, y=\"y\").pair(x=[\"x1\", \"x2\"]).add(m).share(x=True).plot()\n\n        for ax in p._figure.axes:\n            assert ax.get_xticks() == [0, 1, 2]\n        print(m.passed_data)\n        assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n        assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 2.], [0, 1]))\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_pair_categories_shared", "self", "data", "a", "a", "b", "c", "df", "pd", "dataframe", "data", "columns", "x1", "x2", "assign", "y", "1", "m", "mockmark", "p", "plot", "df", "y", "y", "pair", "x", "x1", "x2", "add", "m", "share", "x", "true", "plot", "for", "ax", "in", "p", "_figure", "axes", "assert", "ax", "get_xticks", "0", "1", "2", "print", "m", "passed_data", "assert_vector_equal", "m", "passed_data", "0", "x", "pd", "series", "0", "1", "0", "1", "assert_vector_equal", "m", "passed_data", "1", "x", "pd", "series", "0", "2", "0", "1"], "doc_len": 77}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_identity_mapping_linewidth", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_identity_mapping_linewidth", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_identity_mapping_linewidth(self):\n\n        m = MockMark()\n        x = y = [1, 2, 3, 4, 5]\n        lw = pd.Series([.5, .1, .1, .9, 3])\n        Plot(x=x, y=y, linewidth=lw).scale(linewidth=None).add(m).plot()\n        assert_vector_equal(m.passed_scales[\"linewidth\"](lw), lw)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_identity_mapping_linewidth", "self", "m", "mockmark", "x", "y", "1", "2", "3", "4", "5", "lw", "pd", "series", "5", "1", "1", "9", "3", "plot", "x", "x", "y", "y", "linewidth", "lw", "scale", "linewidth", "none", "add", "m", "plot", "assert_vector_equal", "m", "passed_scales", "linewidth", "lw", "lw"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_pair_single_coordinate_stat_orient", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_pair_single_coordinate_stat_orient", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_pair_single_coordinate_stat_orient(self, long_df):\n\n        class MockStat(Stat):\n            def __call__(self, data, groupby, orient, scales):\n                self.orient = orient\n                return data\n\n        s = MockStat()\n        Plot(long_df).pair(x=[\"x\", \"y\"]).add(MockMark(), s).plot()\n        assert s.orient == \"x\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_pair_single_coordinate_stat_orient", "self", "long_df", "class", "mockstat", "stat", "def", "__call__", "self", "data", "groupby", "orient", "scales", "self", "orient", "orient", "return", "data", "s", "mockstat", "plot", "long_df", "pair", "x", "x", "y", "add", "mockmark", "s", "plot", "assert", "s", "orient", "x"], "doc_len": 40}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_inferred_nominal_passed_to_stat", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_inferred_nominal_passed_to_stat", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_inferred_nominal_passed_to_stat(self):\n\n        class MockStat(Stat):\n            def __call__(self, data, groupby, orient, scales):\n                self.scales = scales\n                return data\n\n        s = MockStat()\n        y = [\"a\", \"a\", \"b\", \"c\"]\n        Plot(y=y).add(MockMark(), s).plot()\n        assert s.scales[\"y\"].__class__.__name__ == \"Nominal\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_inferred_nominal_passed_to_stat", "self", "class", "mockstat", "stat", "def", "__call__", "self", "data", "groupby", "orient", "scales", "self", "scales", "scales", "return", "data", "s", "mockstat", "y", "a", "a", "b", "c", "plot", "y", "y", "add", "mockmark", "s", "plot", "assert", "s", "scales", "y", "__class__", "__name__", "nominal"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_identity_mapping_color_strings", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_identity_mapping_color_strings", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_identity_mapping_color_strings(self):\n\n        m = MockMark()\n        x = y = [1, 2, 3]\n        c = [\"C0\", \"C2\", \"C1\"]\n        Plot(x=x, y=y, color=c).scale(color=None).add(m).plot()\n        expected = mpl.colors.to_rgba_array(c)[:, :3]\n        assert_array_equal(m.passed_scales[\"color\"](c), expected)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_identity_mapping_color_strings", "self", "m", "mockmark", "x", "y", "1", "2", "3", "c", "c0", "c2", "c1", "plot", "x", "x", "y", "y", "color", "c", "scale", "color", "none", "add", "m", "plot", "expected", "mpl", "colors", "to_rgba_array", "c", "3", "assert_array_equal", "m", "passed_scales", "color", "c", "expected"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_identity_mapping_color_tuples", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_identity_mapping_color_tuples", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_identity_mapping_color_tuples(self):\n\n        m = MockMark()\n        x = y = [1, 2, 3]\n        c = [(1, 0, 0), (0, 1, 0), (1, 0, 0)]\n        Plot(x=x, y=y, color=c).scale(color=None).add(m).plot()\n        expected = mpl.colors.to_rgba_array(c)[:, :3]\n        assert_array_equal(m.passed_scales[\"color\"](c), expected)\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_identity_mapping_color_tuples", "self", "m", "mockmark", "x", "y", "1", "2", "3", "c", "1", "0", "0", "0", "1", "0", "1", "0", "0", "plot", "x", "x", "y", "y", "color", "c", "scale", "color", "none", "add", "m", "plot", "expected", "mpl", "colors", "to_rgba_array", "c", "3", "assert_array_equal", "m", "passed_scales", "color", "c", "expected"], "doc_len": 50}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_undefined_variable_raises", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_undefined_variable_raises", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_undefined_variable_raises(self):\n\n        p = Plot(x=[1, 2, 3], color=[\"a\", \"b\", \"c\"]).scale(y=Continuous())\n        err = r\"No data found for variable\\(s\\) with explicit scale: {'y'}\"\n        with pytest.raises(RuntimeError, match=err):\n            p.plot()\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_undefined_variable_raises", "self", "p", "plot", "x", "1", "2", "3", "color", "a", "b", "c", "scale", "y", "continuous", "err", "r", "no", "data", "found", "for", "variable", "s", "with", "explicit", "scale", "y", "with", "pytest", "raises", "runtimeerror", "match", "err", "p", "plot"], "doc_len": 41}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_nominal_x_axis_tweaks", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_nominal_x_axis_tweaks", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_nominal_x_axis_tweaks(self):\n\n        p = Plot(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3])\n        ax1 = p.plot()._figure.axes[0]\n        assert ax1.get_xlim() == (-.5, 2.5)\n        assert not any(x.get_visible() for x in ax1.xaxis.get_gridlines())\n\n        lim = (-1, 2.1)\n        ax2 = p.limit(x=lim).plot()._figure.axes[0]\n        assert ax2.get_xlim() == lim\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_nominal_x_axis_tweaks", "self", "p", "plot", "x", "a", "b", "c", "y", "1", "2", "3", "ax1", "p", "plot", "_figure", "axes", "0", "assert", "ax1", "get_xlim", "5", "2", "5", "assert", "not", "any", "x", "get_visible", "for", "x", "in", "ax1", "xaxis", "get_gridlines", "lim", "1", "2", "1", "ax2", "p", "limit", "x", "lim", "plot", "_figure", "axes", "0", "assert", "ax2", "get_xlim", "lim"], "doc_len": 58}
{"doc_id": "tests/_core/test_plot.py::TestScaling.test_nominal_y_axis_tweaks", "file_path": "tests/_core/test_plot.py", "class_name": "TestScaling", "func_name": "test_nominal_y_axis_tweaks", "text": "文件路径: tests/_core/test_plot.py, 类名: TestScaling\n    def test_nominal_y_axis_tweaks(self):\n\n        p = Plot(x=[1, 2, 3], y=[\"a\", \"b\", \"c\"])\n        ax1 = p.plot()._figure.axes[0]\n        assert ax1.get_ylim() == (2.5, -.5)\n        assert not any(y.get_visible() for y in ax1.yaxis.get_gridlines())\n\n        lim = (-1, 2.1)\n        ax2 = p.limit(y=lim).plot()._figure.axes[0]\n        assert ax2.get_ylim() == lim\n", "tokens": ["tests", "_core", "test_plot", "py", "testscaling", "def", "test_nominal_y_axis_tweaks", "self", "p", "plot", "x", "1", "2", "3", "y", "a", "b", "c", "ax1", "p", "plot", "_figure", "axes", "0", "assert", "ax1", "get_ylim", "2", "5", "5", "assert", "not", "any", "y", "get_visible", "for", "y", "in", "ax1", "yaxis", "get_gridlines", "lim", "1", "2", "1", "ax2", "p", "limit", "y", "lim", "plot", "_figure", "axes", "0", "assert", "ax2", "get_ylim", "lim"], "doc_len": 58}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_matplotlib_object_creation", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_matplotlib_object_creation", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_matplotlib_object_creation(self):\n\n        p = Plot().plot()\n        assert isinstance(p._figure, mpl.figure.Figure)\n        for sub in p._subplots:\n            assert isinstance(sub[\"ax\"], mpl.axes.Axes)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_matplotlib_object_creation", "self", "p", "plot", "plot", "assert", "isinstance", "p", "_figure", "mpl", "figure", "figure", "for", "sub", "in", "p", "_subplots", "assert", "isinstance", "sub", "ax", "mpl", "axes", "axes"], "doc_len": 30}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_empty", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_empty", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_empty(self):\n\n        m = MockMark()\n        Plot().add(m).plot()\n        assert m.n_splits == 0\n        assert not m.passed_data\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_empty", "self", "m", "mockmark", "plot", "add", "m", "plot", "assert", "m", "n_splits", "0", "assert", "not", "m", "passed_data"], "doc_len": 22}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_no_orient_variance", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_no_orient_variance", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_no_orient_variance(self):\n\n        x, y = [0, 0], [1, 2]\n        m = MockMark()\n        Plot(x, y).add(m).plot()\n        assert_array_equal(m.passed_data[0][\"x\"], x)\n        assert_array_equal(m.passed_data[0][\"y\"], y)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_no_orient_variance", "self", "x", "y", "0", "0", "1", "2", "m", "mockmark", "plot", "x", "y", "add", "m", "plot", "assert_array_equal", "m", "passed_data", "0", "x", "x", "assert_array_equal", "m", "passed_data", "0", "y", "y"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_single_split_single_layer", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_single_split_single_layer", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_single_split_single_layer(self, long_df):\n\n        m = MockMark()\n        p = Plot(long_df, x=\"f\", y=\"z\").add(m).plot()\n        assert m.n_splits == 1\n\n        assert m.passed_keys[0] == {}\n        assert m.passed_axes == [sub[\"ax\"] for sub in p._subplots]\n        for col in p._data.frame:\n            assert_series_equal(m.passed_data[0][col], p._data.frame[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_single_split_single_layer", "self", "long_df", "m", "mockmark", "p", "plot", "long_df", "x", "f", "y", "z", "add", "m", "plot", "assert", "m", "n_splits", "1", "assert", "m", "passed_keys", "0", "assert", "m", "passed_axes", "sub", "ax", "for", "sub", "in", "p", "_subplots", "for", "col", "in", "p", "_data", "frame", "assert_series_equal", "m", "passed_data", "0", "col", "p", "_data", "frame", "col"], "doc_len": 54}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_single_split_multi_layer", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_single_split_multi_layer", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_single_split_multi_layer(self, long_df):\n\n        vs = [{\"color\": \"a\", \"linewidth\": \"z\"}, {\"color\": \"b\", \"pattern\": \"c\"}]\n\n        class NoGroupingMark(MockMark):\n            _grouping_props = []\n\n        ms = [NoGroupingMark(), NoGroupingMark()]\n        Plot(long_df).add(ms[0], **vs[0]).add(ms[1], **vs[1]).plot()\n\n        for m, v in zip(ms, vs):\n            for var, col in v.items():\n                assert_vector_equal(m.passed_data[0][var], long_df[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_single_split_multi_layer", "self", "long_df", "vs", "color", "a", "linewidth", "z", "color", "b", "pattern", "c", "class", "nogroupingmark", "mockmark", "_grouping_props", "ms", "nogroupingmark", "nogroupingmark", "plot", "long_df", "add", "ms", "0", "vs", "0", "add", "ms", "1", "vs", "1", "plot", "for", "m", "v", "in", "zip", "ms", "vs", "for", "var", "col", "in", "v", "items", "assert_vector_equal", "m", "passed_data", "0", "var", "long_df", "col"], "doc_len": 58}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.check_splits_single_var", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "check_splits_single_var", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def check_splits_single_var(\n        self, data, mark, data_vars, split_var, split_col, split_keys\n    ):\n\n        assert mark.n_splits == len(split_keys)\n        assert mark.passed_keys == [{split_var: key} for key in split_keys]\n\n        for i, key in enumerate(split_keys):\n\n            split_data = data[data[split_col] == key]\n            for var, col in data_vars.items():\n                assert_array_equal(mark.passed_data[i][var], split_data[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "check_splits_single_var", "self", "data", "mark", "data_vars", "split_var", "split_col", "split_keys", "assert", "mark", "n_splits", "len", "split_keys", "assert", "mark", "passed_keys", "split_var", "key", "for", "key", "in", "split_keys", "for", "i", "key", "in", "enumerate", "split_keys", "split_data", "data", "data", "split_col", "key", "for", "var", "col", "in", "data_vars", "items", "assert_array_equal", "mark", "passed_data", "i", "var", "split_data", "col"], "doc_len": 52}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.check_splits_multi_vars", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "check_splits_multi_vars", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def check_splits_multi_vars(\n        self, data, mark, data_vars, split_vars, split_cols, split_keys\n    ):\n\n        assert mark.n_splits == np.prod([len(ks) for ks in split_keys])\n\n        expected_keys = [\n            dict(zip(split_vars, level_keys))\n            for level_keys in itertools.product(*split_keys)\n        ]\n        assert mark.passed_keys == expected_keys\n\n        for i, keys in enumerate(itertools.product(*split_keys)):\n\n            use_rows = pd.Series(True, data.index)\n            for var, col, key in zip(split_vars, split_cols, keys):\n                use_rows &= data[col] == key\n            split_data = data[use_rows]\n            for var, col in data_vars.items():\n                assert_array_equal(mark.passed_data[i][var], split_data[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "check_splits_multi_vars", "self", "data", "mark", "data_vars", "split_vars", "split_cols", "split_keys", "assert", "mark", "n_splits", "np", "prod", "len", "ks", "for", "ks", "in", "split_keys", "expected_keys", "dict", "zip", "split_vars", "level_keys", "for", "level_keys", "in", "itertools", "product", "split_keys", "assert", "mark", "passed_keys", "expected_keys", "for", "i", "keys", "in", "enumerate", "itertools", "product", "split_keys", "use_rows", "pd", "series", "true", "data", "index", "for", "var", "col", "key", "in", "zip", "split_vars", "split_cols", "keys", "use_rows", "data", "col", "key", "split_data", "data", "use_rows", "for", "var", "col", "in", "data_vars", "items", "assert_array_equal", "mark", "passed_data", "i", "var", "split_data", "col"], "doc_len": 83}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_one_grouping_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_one_grouping_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_one_grouping_variable(self, long_df, split_var):\n\n        split_col = \"a\"\n        data_vars = {\"x\": \"f\", \"y\": \"z\", split_var: split_col}\n\n        m = MockMark()\n        p = Plot(long_df, **data_vars).add(m).plot()\n\n        split_keys = categorical_order(long_df[split_col])\n        sub, *_ = p._subplots\n        assert m.passed_axes == [sub[\"ax\"] for _ in split_keys]\n        self.check_splits_single_var(\n            long_df, m, data_vars, split_var, split_col, split_keys\n        )\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_one_grouping_variable", "self", "long_df", "split_var", "split_col", "a", "data_vars", "x", "f", "y", "z", "split_var", "split_col", "m", "mockmark", "p", "plot", "long_df", "data_vars", "add", "m", "plot", "split_keys", "categorical_order", "long_df", "split_col", "sub", "_", "p", "_subplots", "assert", "m", "passed_axes", "sub", "ax", "for", "_", "in", "split_keys", "self", "check_splits_single_var", "long_df", "m", "data_vars", "split_var", "split_col", "split_keys"], "doc_len": 53}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_two_grouping_variables", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_two_grouping_variables", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_two_grouping_variables(self, long_df):\n\n        split_vars = [\"color\", \"group\"]\n        split_cols = [\"a\", \"b\"]\n        data_vars = {\"y\": \"z\", **{var: col for var, col in zip(split_vars, split_cols)}}\n\n        m = MockMark()\n        p = Plot(long_df, **data_vars).add(m).plot()\n\n        split_keys = [categorical_order(long_df[col]) for col in split_cols]\n        sub, *_ = p._subplots\n        assert m.passed_axes == [\n            sub[\"ax\"] for _ in itertools.product(*split_keys)\n        ]\n        self.check_splits_multi_vars(\n            long_df, m, data_vars, split_vars, split_cols, split_keys\n        )\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_two_grouping_variables", "self", "long_df", "split_vars", "color", "group", "split_cols", "a", "b", "data_vars", "y", "z", "var", "col", "for", "var", "col", "in", "zip", "split_vars", "split_cols", "m", "mockmark", "p", "plot", "long_df", "data_vars", "add", "m", "plot", "split_keys", "categorical_order", "long_df", "col", "for", "col", "in", "split_cols", "sub", "_", "p", "_subplots", "assert", "m", "passed_axes", "sub", "ax", "for", "_", "in", "itertools", "product", "split_keys", "self", "check_splits_multi_vars", "long_df", "m", "data_vars", "split_vars", "split_cols", "split_keys"], "doc_len": 67}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_specified_width", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_specified_width", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_specified_width(self, long_df):\n\n        m = MockMark()\n        Plot(long_df, x=\"x\", y=\"y\").add(m, width=\"z\").plot()\n        assert_array_almost_equal(m.passed_data[0][\"width\"], long_df[\"z\"])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_specified_width", "self", "long_df", "m", "mockmark", "plot", "long_df", "x", "x", "y", "y", "add", "m", "width", "z", "plot", "assert_array_almost_equal", "m", "passed_data", "0", "width", "long_df", "z"], "doc_len": 29}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_facets_no_subgroups", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_facets_no_subgroups", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_facets_no_subgroups(self, long_df):\n\n        split_var = \"col\"\n        split_col = \"b\"\n        data_vars = {\"x\": \"f\", \"y\": \"z\"}\n\n        m = MockMark()\n        p = Plot(long_df, **data_vars).facet(**{split_var: split_col}).add(m).plot()\n\n        split_keys = categorical_order(long_df[split_col])\n        assert m.passed_axes == list(p._figure.axes)\n        self.check_splits_single_var(\n            long_df, m, data_vars, split_var, split_col, split_keys\n        )\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_facets_no_subgroups", "self", "long_df", "split_var", "col", "split_col", "b", "data_vars", "x", "f", "y", "z", "m", "mockmark", "p", "plot", "long_df", "data_vars", "facet", "split_var", "split_col", "add", "m", "plot", "split_keys", "categorical_order", "long_df", "split_col", "assert", "m", "passed_axes", "list", "p", "_figure", "axes", "self", "check_splits_single_var", "long_df", "m", "data_vars", "split_var", "split_col", "split_keys"], "doc_len": 49}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_facets_one_subgroup", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_facets_one_subgroup", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_facets_one_subgroup(self, long_df):\n\n        facet_var, facet_col = fx = \"col\", \"a\"\n        group_var, group_col = gx = \"group\", \"b\"\n        split_vars, split_cols = zip(*[fx, gx])\n        data_vars = {\"x\": \"f\", \"y\": \"z\", group_var: group_col}\n\n        m = MockMark()\n        p = (\n            Plot(long_df, **data_vars)\n            .facet(**{facet_var: facet_col})\n            .add(m)\n            .plot()\n        )\n\n        split_keys = [categorical_order(long_df[col]) for col in [facet_col, group_col]]\n        assert m.passed_axes == [\n            ax\n            for ax in list(p._figure.axes)\n            for _ in categorical_order(long_df[group_col])\n        ]\n        self.check_splits_multi_vars(\n            long_df, m, data_vars, split_vars, split_cols, split_keys\n        )\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_facets_one_subgroup", "self", "long_df", "facet_var", "facet_col", "fx", "col", "a", "group_var", "group_col", "gx", "group", "b", "split_vars", "split_cols", "zip", "fx", "gx", "data_vars", "x", "f", "y", "z", "group_var", "group_col", "m", "mockmark", "p", "plot", "long_df", "data_vars", "facet", "facet_var", "facet_col", "add", "m", "plot", "split_keys", "categorical_order", "long_df", "col", "for", "col", "in", "facet_col", "group_col", "assert", "m", "passed_axes", "ax", "for", "ax", "in", "list", "p", "_figure", "axes", "for", "_", "in", "categorical_order", "long_df", "group_col", "self", "check_splits_multi_vars", "long_df", "m", "data_vars", "split_vars", "split_cols", "split_keys"], "doc_len": 77}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_layer_specific_facet_disabling", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_layer_specific_facet_disabling", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_layer_specific_facet_disabling(self, long_df):\n\n        axis_vars = {\"x\": \"y\", \"y\": \"z\"}\n        row_var = \"a\"\n\n        m = MockMark()\n        p = Plot(long_df, **axis_vars).facet(row=row_var).add(m, row=None).plot()\n\n        col_levels = categorical_order(long_df[row_var])\n        assert len(p._figure.axes) == len(col_levels)\n\n        for data in m.passed_data:\n            for var, col in axis_vars.items():\n                assert_vector_equal(data[var], long_df[col])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_layer_specific_facet_disabling", "self", "long_df", "axis_vars", "x", "y", "y", "z", "row_var", "a", "m", "mockmark", "p", "plot", "long_df", "axis_vars", "facet", "row", "row_var", "add", "m", "row", "none", "plot", "col_levels", "categorical_order", "long_df", "row_var", "assert", "len", "p", "_figure", "axes", "len", "col_levels", "for", "data", "in", "m", "passed_data", "for", "var", "col", "in", "axis_vars", "items", "assert_vector_equal", "data", "var", "long_df", "col"], "doc_len": 57}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_paired_variables", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_paired_variables", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_paired_variables(self, long_df):\n\n        x = [\"x\", \"y\"]\n        y = [\"f\", \"z\"]\n\n        m = MockMark()\n        Plot(long_df).pair(x, y).add(m).plot()\n\n        var_product = itertools.product(x, y)\n\n        for data, (x_i, y_i) in zip(m.passed_data, var_product):\n            assert_vector_equal(data[\"x\"], long_df[x_i].astype(float))\n            assert_vector_equal(data[\"y\"], long_df[y_i].astype(float))\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_paired_variables", "self", "long_df", "x", "x", "y", "y", "f", "z", "m", "mockmark", "plot", "long_df", "pair", "x", "y", "add", "m", "plot", "var_product", "itertools", "product", "x", "y", "for", "data", "x_i", "y_i", "in", "zip", "m", "passed_data", "var_product", "assert_vector_equal", "data", "x", "long_df", "x_i", "astype", "float", "assert_vector_equal", "data", "y", "long_df", "y_i", "astype", "float"], "doc_len": 53}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_paired_one_dimension", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_paired_one_dimension", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_paired_one_dimension(self, long_df):\n\n        x = [\"y\", \"z\"]\n\n        m = MockMark()\n        Plot(long_df).pair(x).add(m).plot()\n\n        for data, x_i in zip(m.passed_data, x):\n            assert_vector_equal(data[\"x\"], long_df[x_i].astype(float))\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_paired_one_dimension", "self", "long_df", "x", "y", "z", "m", "mockmark", "plot", "long_df", "pair", "x", "add", "m", "plot", "for", "data", "x_i", "in", "zip", "m", "passed_data", "x", "assert_vector_equal", "data", "x", "long_df", "x_i", "astype", "float"], "doc_len": 36}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_paired_variables_one_subset", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_paired_variables_one_subset", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_paired_variables_one_subset(self, long_df):\n\n        x = [\"x\", \"y\"]\n        y = [\"f\", \"z\"]\n        group = \"a\"\n\n        long_df[\"x\"] = long_df[\"x\"].astype(float)  # simplify vector comparison\n\n        m = MockMark()\n        Plot(long_df, group=group).pair(x, y).add(m).plot()\n\n        groups = categorical_order(long_df[group])\n        var_product = itertools.product(x, y, groups)\n\n        for data, (x_i, y_i, g_i) in zip(m.passed_data, var_product):\n            rows = long_df[group] == g_i\n            assert_vector_equal(data[\"x\"], long_df.loc[rows, x_i])\n            assert_vector_equal(data[\"y\"], long_df.loc[rows, y_i])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_paired_variables_one_subset", "self", "long_df", "x", "x", "y", "y", "f", "z", "group", "a", "long_df", "x", "long_df", "x", "astype", "float", "simplify", "vector", "comparison", "m", "mockmark", "plot", "long_df", "group", "group", "pair", "x", "y", "add", "m", "plot", "groups", "categorical_order", "long_df", "group", "var_product", "itertools", "product", "x", "y", "groups", "for", "data", "x_i", "y_i", "g_i", "in", "zip", "m", "passed_data", "var_product", "rows", "long_df", "group", "g_i", "assert_vector_equal", "data", "x", "long_df", "loc", "rows", "x_i", "assert_vector_equal", "data", "y", "long_df", "loc", "rows", "y_i"], "doc_len": 76}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_paired_and_faceted", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_paired_and_faceted", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_paired_and_faceted(self, long_df):\n\n        x = [\"y\", \"z\"]\n        y = \"f\"\n        row = \"c\"\n\n        m = MockMark()\n        Plot(long_df, y=y).facet(row=row).pair(x).add(m).plot()\n\n        facets = categorical_order(long_df[row])\n        var_product = itertools.product(x, facets)\n\n        for data, (x_i, f_i) in zip(m.passed_data, var_product):\n            rows = long_df[row] == f_i\n            assert_vector_equal(data[\"x\"], long_df.loc[rows, x_i])\n            assert_vector_equal(data[\"y\"], long_df.loc[rows, y])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_paired_and_faceted", "self", "long_df", "x", "y", "z", "y", "f", "row", "c", "m", "mockmark", "plot", "long_df", "y", "y", "facet", "row", "row", "pair", "x", "add", "m", "plot", "facets", "categorical_order", "long_df", "row", "var_product", "itertools", "product", "x", "facets", "for", "data", "x_i", "f_i", "in", "zip", "m", "passed_data", "var_product", "rows", "long_df", "row", "f_i", "assert_vector_equal", "data", "x", "long_df", "loc", "rows", "x_i", "assert_vector_equal", "data", "y", "long_df", "loc", "rows", "y"], "doc_len": 66}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_theme_default", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_theme_default", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_theme_default(self):\n\n        p = Plot().plot()\n        assert mpl.colors.same_color(p._figure.axes[0].get_facecolor(), \"#EAEAF2\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_theme_default", "self", "p", "plot", "plot", "assert", "mpl", "colors", "same_color", "p", "_figure", "axes", "0", "get_facecolor", "eaeaf2"], "doc_len": 21}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_theme_params", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_theme_params", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_theme_params(self):\n\n        color = \".888\"\n        p = Plot().theme({\"axes.facecolor\": color}).plot()\n        assert mpl.colors.same_color(p._figure.axes[0].get_facecolor(), color)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_theme_params", "self", "color", "888", "p", "plot", "theme", "axes", "facecolor", "color", "plot", "assert", "mpl", "colors", "same_color", "p", "_figure", "axes", "0", "get_facecolor", "color"], "doc_len": 27}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_theme_error", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_theme_error", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_theme_error(self):\n\n        p = Plot()\n        with pytest.raises(TypeError, match=r\"theme\\(\\) takes 1 positional\"):\n            p.theme(\"arg1\", \"arg2\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_theme_error", "self", "p", "plot", "with", "pytest", "raises", "typeerror", "match", "r", "theme", "takes", "1", "positional", "p", "theme", "arg1", "arg2"], "doc_len": 24}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_stat", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_stat", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_stat(self, long_df):\n\n        orig_df = long_df.copy(deep=True)\n\n        m = MockMark()\n        Plot(long_df, x=\"a\", y=\"z\").add(m, Agg()).plot()\n\n        expected = long_df.groupby(\"a\", sort=False)[\"z\"].mean().reset_index(drop=True)\n        assert_vector_equal(m.passed_data[0][\"y\"], expected)\n\n        assert_frame_equal(long_df, orig_df)   # Test data was not mutated\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_stat", "self", "long_df", "orig_df", "long_df", "copy", "deep", "true", "m", "mockmark", "plot", "long_df", "x", "a", "y", "z", "add", "m", "agg", "plot", "expected", "long_df", "groupby", "a", "sort", "false", "z", "mean", "reset_index", "drop", "true", "assert_vector_equal", "m", "passed_data", "0", "y", "expected", "assert_frame_equal", "long_df", "orig_df", "test", "data", "was", "not", "mutated"], "doc_len": 51}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_move", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_move", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_move(self, long_df):\n\n        orig_df = long_df.copy(deep=True)\n\n        m = MockMark()\n        Plot(long_df, x=\"z\", y=\"z\").add(m, Shift(x=1)).plot()\n        assert_vector_equal(m.passed_data[0][\"x\"], long_df[\"z\"] + 1)\n        assert_vector_equal(m.passed_data[0][\"y\"], long_df[\"z\"])\n\n        assert_frame_equal(long_df, orig_df)   # Test data was not mutated\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_move", "self", "long_df", "orig_df", "long_df", "copy", "deep", "true", "m", "mockmark", "plot", "long_df", "x", "z", "y", "z", "add", "m", "shift", "x", "1", "plot", "assert_vector_equal", "m", "passed_data", "0", "x", "long_df", "z", "1", "assert_vector_equal", "m", "passed_data", "0", "y", "long_df", "z", "assert_frame_equal", "long_df", "orig_df", "test", "data", "was", "not", "mutated"], "doc_len": 51}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_stat_and_move", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_stat_and_move", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_stat_and_move(self, long_df):\n\n        m = MockMark()\n        Plot(long_df, x=\"a\", y=\"z\").add(m, Agg(), Shift(y=1)).plot()\n\n        expected = long_df.groupby(\"a\", sort=False)[\"z\"].mean().reset_index(drop=True)\n        assert_vector_equal(m.passed_data[0][\"y\"], expected + 1)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_stat_and_move", "self", "long_df", "m", "mockmark", "plot", "long_df", "x", "a", "y", "z", "add", "m", "agg", "shift", "y", "1", "plot", "expected", "long_df", "groupby", "a", "sort", "false", "z", "mean", "reset_index", "drop", "true", "assert_vector_equal", "m", "passed_data", "0", "y", "expected", "1"], "doc_len": 42}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_stat_log_scale", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_stat_log_scale", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_stat_log_scale(self, long_df):\n\n        orig_df = long_df.copy(deep=True)\n\n        m = MockMark()\n        Plot(long_df, x=\"a\", y=\"z\").add(m, Agg()).scale(y=\"log\").plot()\n\n        x = long_df[\"a\"]\n        y = np.log10(long_df[\"z\"])\n        expected = y.groupby(x, sort=False).mean().reset_index(drop=True)\n        assert_vector_equal(m.passed_data[0][\"y\"], 10 ** expected)\n\n        assert_frame_equal(long_df, orig_df)   # Test data was not mutated\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_stat_log_scale", "self", "long_df", "orig_df", "long_df", "copy", "deep", "true", "m", "mockmark", "plot", "long_df", "x", "a", "y", "z", "add", "m", "agg", "scale", "y", "log", "plot", "x", "long_df", "a", "y", "np", "log10", "long_df", "z", "expected", "y", "groupby", "x", "sort", "false", "mean", "reset_index", "drop", "true", "assert_vector_equal", "m", "passed_data", "0", "y", "10", "expected", "assert_frame_equal", "long_df", "orig_df", "test", "data", "was", "not", "mutated"], "doc_len": 62}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_move_log_scale", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_move_log_scale", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_move_log_scale(self, long_df):\n\n        m = MockMark()\n        Plot(\n            long_df, x=\"z\", y=\"z\"\n        ).scale(x=\"log\").add(m, Shift(x=-1)).plot()\n        assert_vector_equal(m.passed_data[0][\"x\"], long_df[\"z\"] / 10)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_move_log_scale", "self", "long_df", "m", "mockmark", "plot", "long_df", "x", "z", "y", "z", "scale", "x", "log", "add", "m", "shift", "x", "1", "plot", "assert_vector_equal", "m", "passed_data", "0", "x", "long_df", "z", "10"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_multi_move", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_multi_move", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_multi_move(self, long_df):\n\n        m = MockMark()\n        move_stack = [Shift(1), Shift(2)]\n        Plot(long_df, x=\"x\", y=\"y\").add(m, *move_stack).plot()\n        assert_vector_equal(m.passed_data[0][\"x\"], long_df[\"x\"] + 3)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_multi_move", "self", "long_df", "m", "mockmark", "move_stack", "shift", "1", "shift", "2", "plot", "long_df", "x", "x", "y", "y", "add", "m", "move_stack", "plot", "assert_vector_equal", "m", "passed_data", "0", "x", "long_df", "x", "3"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_multi_move_with_pairing", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_multi_move_with_pairing", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_multi_move_with_pairing(self, long_df):\n        m = MockMark()\n        move_stack = [Shift(1), Shift(2)]\n        Plot(long_df, x=\"x\").pair(y=[\"y\", \"z\"]).add(m, *move_stack).plot()\n        for frame in m.passed_data:\n            assert_vector_equal(frame[\"x\"], long_df[\"x\"] + 3)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_multi_move_with_pairing", "self", "long_df", "m", "mockmark", "move_stack", "shift", "1", "shift", "2", "plot", "long_df", "x", "x", "pair", "y", "y", "z", "add", "m", "move_stack", "plot", "for", "frame", "in", "m", "passed_data", "assert_vector_equal", "frame", "x", "long_df", "x", "3"], "doc_len": 39}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_move_with_range", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_move_with_range", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_move_with_range(self, long_df):\n\n        x = [0, 0, 1, 1, 2, 2]\n        group = [0, 1, 0, 1, 0, 1]\n        ymin = np.arange(6)\n        ymax = np.arange(6) * 2\n\n        m = MockMark()\n        Plot(x=x, group=group, ymin=ymin, ymax=ymax).add(m, Dodge()).plot()\n\n        signs = [-1, +1]\n        for i, df in m.passed_data[0].groupby(\"group\"):\n            assert_array_equal(df[\"x\"], np.arange(3) + signs[i] * 0.2)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_move_with_range", "self", "long_df", "x", "0", "0", "1", "1", "2", "2", "group", "0", "1", "0", "1", "0", "1", "ymin", "np", "arange", "6", "ymax", "np", "arange", "6", "2", "m", "mockmark", "plot", "x", "x", "group", "group", "ymin", "ymin", "ymax", "ymax", "add", "m", "dodge", "plot", "signs", "1", "1", "for", "i", "df", "in", "m", "passed_data", "0", "groupby", "group", "assert_array_equal", "df", "x", "np", "arange", "3", "signs", "i", "0", "2"], "doc_len": 69}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_methods_clone", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_methods_clone", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_methods_clone(self, long_df):\n\n        p1 = Plot(long_df, \"x\", \"y\")\n        p2 = p1.add(MockMark()).facet(\"a\")\n\n        assert p1 is not p2\n        assert not p1._layers\n        assert not p1._facet_spec\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_methods_clone", "self", "long_df", "p1", "plot", "long_df", "x", "y", "p2", "p1", "add", "mockmark", "facet", "a", "assert", "p1", "is", "not", "p2", "assert", "not", "p1", "_layers", "assert", "not", "p1", "_facet_spec"], "doc_len": 33}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_default_is_no_pyplot", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_default_is_no_pyplot", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_default_is_no_pyplot(self):\n\n        p = Plot().plot()\n\n        assert not plt.get_fignums()\n        assert isinstance(p._figure, mpl.figure.Figure)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_default_is_no_pyplot", "self", "p", "plot", "plot", "assert", "not", "plt", "get_fignums", "assert", "isinstance", "p", "_figure", "mpl", "figure", "figure"], "doc_len": 22}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_with_pyplot", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_with_pyplot", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_with_pyplot(self):\n\n        p = Plot().plot(pyplot=True)\n\n        assert len(plt.get_fignums()) == 1\n        fig = plt.gcf()\n        assert p._figure is fig\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_with_pyplot", "self", "p", "plot", "plot", "pyplot", "true", "assert", "len", "plt", "get_fignums", "1", "fig", "plt", "gcf", "assert", "p", "_figure", "is", "fig"], "doc_len": 26}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_show", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_show", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_show(self):\n\n        p = Plot()\n\n        with warnings.catch_warnings(record=True) as msg:\n            out = p.show(block=False)\n        assert out is None\n        assert not hasattr(p, \"_figure\")\n\n        assert len(plt.get_fignums()) == 1\n        fig = plt.gcf()\n\n        gui_backend = (\n            # From https://github.com/matplotlib/matplotlib/issues/20281\n            fig.canvas.manager.show != mpl.backend_bases.FigureManagerBase.show\n        )\n        if not gui_backend:\n            assert msg\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_show", "self", "p", "plot", "with", "warnings", "catch_warnings", "record", "true", "as", "msg", "out", "p", "show", "block", "false", "assert", "out", "is", "none", "assert", "not", "hasattr", "p", "_figure", "assert", "len", "plt", "get_fignums", "1", "fig", "plt", "gcf", "gui_backend", "from", "https", "github", "com", "matplotlib", "matplotlib", "issues", "20281", "fig", "canvas", "manager", "show", "mpl", "backend_bases", "figuremanagerbase", "show", "if", "not", "gui_backend", "assert", "msg"], "doc_len": 61}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_png_repr", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_png_repr", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_png_repr(self):\n\n        p = Plot()\n        data, metadata = p._repr_png_()\n        img = Image.open(io.BytesIO(data))\n\n        assert not hasattr(p, \"_figure\")\n        assert isinstance(data, bytes)\n        assert img.format == \"PNG\"\n        assert sorted(metadata) == [\"height\", \"width\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_png_repr", "self", "p", "plot", "data", "metadata", "p", "_repr_png_", "img", "image", "open", "io", "bytesio", "data", "assert", "not", "hasattr", "p", "_figure", "assert", "isinstance", "data", "bytes", "assert", "img", "format", "png", "assert", "sorted", "metadata", "height", "width"], "doc_len": 38}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_save", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_save", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_save(self):\n\n        buf = io.BytesIO()\n\n        p = Plot().save(buf)\n        assert isinstance(p, Plot)\n        img = Image.open(buf)\n        assert img.format == \"PNG\"\n\n        buf = io.StringIO()\n        Plot().save(buf, format=\"svg\")\n        tag = xml.etree.ElementTree.fromstring(buf.getvalue()).tag\n        assert tag == \"{http://www.w3.org/2000/svg}svg\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_save", "self", "buf", "io", "bytesio", "p", "plot", "save", "buf", "assert", "isinstance", "p", "plot", "img", "image", "open", "buf", "assert", "img", "format", "png", "buf", "io", "stringio", "plot", "save", "buf", "format", "svg", "tag", "xml", "etree", "elementtree", "fromstring", "buf", "getvalue", "tag", "assert", "tag", "http", "www", "w3", "org", "2000", "svg", "svg"], "doc_len": 52}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_layout_size", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_layout_size", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_layout_size(self):\n\n        size = (4, 2)\n        p = Plot().layout(size=size).plot()\n        assert tuple(p._figure.get_size_inches()) == size\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_layout_size", "self", "size", "4", "2", "p", "plot", "layout", "size", "size", "plot", "assert", "tuple", "p", "_figure", "get_size_inches", "size"], "doc_len": 23}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_axes", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_axes", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_axes(self):\n\n        ax = mpl.figure.Figure().subplots()\n        m = MockMark()\n        p = Plot([1], [2]).on(ax).add(m).plot()\n        assert m.passed_axes == [ax]\n        assert p._figure is ax.figure\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_axes", "self", "ax", "mpl", "figure", "figure", "subplots", "m", "mockmark", "p", "plot", "1", "2", "on", "ax", "add", "m", "plot", "assert", "m", "passed_axes", "ax", "assert", "p", "_figure", "is", "ax", "figure"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_figure", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_figure", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_figure(self, facet):\n\n        f = mpl.figure.Figure()\n        m = MockMark()\n        p = Plot([1, 2], [3, 4]).on(f).add(m)\n        if facet:\n            p = p.facet([\"a\", \"b\"])\n        p = p.plot()\n        assert m.passed_axes == f.axes\n        assert p._figure is f\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_figure", "self", "facet", "f", "mpl", "figure", "figure", "m", "mockmark", "p", "plot", "1", "2", "3", "4", "on", "f", "add", "m", "if", "facet", "p", "p", "facet", "a", "b", "p", "p", "plot", "assert", "m", "passed_axes", "f", "axes", "assert", "p", "_figure", "is", "f"], "doc_len": 45}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_subfigure", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_subfigure", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_subfigure(self, facet):\n\n        sf1, sf2 = mpl.figure.Figure().subfigures(2)\n        sf1.subplots()\n        m = MockMark()\n        p = Plot([1, 2], [3, 4]).on(sf2).add(m)\n        if facet:\n            p = p.facet([\"a\", \"b\"])\n        p = p.plot()\n        assert m.passed_axes == sf2.figure.axes[1:]\n        assert p._figure is sf2.figure\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_subfigure", "self", "facet", "sf1", "sf2", "mpl", "figure", "figure", "subfigures", "2", "sf1", "subplots", "m", "mockmark", "p", "plot", "1", "2", "3", "4", "on", "sf2", "add", "m", "if", "facet", "p", "p", "facet", "a", "b", "p", "p", "plot", "assert", "m", "passed_axes", "sf2", "figure", "axes", "1", "assert", "p", "_figure", "is", "sf2", "figure"], "doc_len": 53}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_type_check", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_type_check", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_type_check(self):\n\n        p = Plot()\n        with pytest.raises(TypeError, match=\"The `Plot.on`.+<class 'list'>\"):\n            p.on([])\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_type_check", "self", "p", "plot", "with", "pytest", "raises", "typeerror", "match", "the", "plot", "on", "class", "list", "p", "on"], "doc_len": 22}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_axes_with_subplots_error", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_axes_with_subplots_error", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_axes_with_subplots_error(self):\n\n        ax = mpl.figure.Figure().subplots()\n\n        p1 = Plot().facet([\"a\", \"b\"]).on(ax)\n        with pytest.raises(RuntimeError, match=\"Cannot create multiple subplots\"):\n            p1.plot()\n\n        p2 = Plot().pair([[\"a\", \"b\"], [\"x\", \"y\"]]).on(ax)\n        with pytest.raises(RuntimeError, match=\"Cannot create multiple subplots\"):\n            p2.plot()\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_axes_with_subplots_error", "self", "ax", "mpl", "figure", "figure", "subplots", "p1", "plot", "facet", "a", "b", "on", "ax", "with", "pytest", "raises", "runtimeerror", "match", "cannot", "create", "multiple", "subplots", "p1", "plot", "p2", "plot", "pair", "a", "b", "x", "y", "on", "ax", "with", "pytest", "raises", "runtimeerror", "match", "cannot", "create", "multiple", "subplots", "p2", "plot"], "doc_len": 51}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_on_disables_layout_algo", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_on_disables_layout_algo", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_on_disables_layout_algo(self):\n\n        f = mpl.figure.Figure()\n        p = Plot().on(f).plot()\n        assert not p._figure.get_tight_layout()\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_on_disables_layout_algo", "self", "f", "mpl", "figure", "figure", "p", "plot", "on", "f", "plot", "assert", "not", "p", "_figure", "get_tight_layout"], "doc_len": 22}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_axis_labels_from_constructor", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_axis_labels_from_constructor", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_axis_labels_from_constructor(self, long_df):\n\n        ax, = Plot(long_df, x=\"a\", y=\"b\").plot()._figure.axes\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"b\"\n\n        ax, = Plot(x=long_df[\"a\"], y=long_df[\"b\"].to_numpy()).plot()._figure.axes\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_axis_labels_from_constructor", "self", "long_df", "ax", "plot", "long_df", "x", "a", "y", "b", "plot", "_figure", "axes", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel", "b", "ax", "plot", "x", "long_df", "a", "y", "long_df", "b", "to_numpy", "plot", "_figure", "axes", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel"], "doc_len": 46}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_axis_labels_from_layer", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_axis_labels_from_layer", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_axis_labels_from_layer(self, long_df):\n\n        m = MockMark()\n\n        ax, = Plot(long_df).add(m, x=\"a\", y=\"b\").plot()._figure.axes\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"b\"\n\n        p = Plot().add(m, x=long_df[\"a\"], y=long_df[\"b\"].to_list())\n        ax, = p.plot()._figure.axes\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_axis_labels_from_layer", "self", "long_df", "m", "mockmark", "ax", "plot", "long_df", "add", "m", "x", "a", "y", "b", "plot", "_figure", "axes", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel", "b", "p", "plot", "add", "m", "x", "long_df", "a", "y", "long_df", "b", "to_list", "ax", "p", "plot", "_figure", "axes", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel"], "doc_len": 54}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_axis_labels_are_first_name", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_axis_labels_are_first_name", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_axis_labels_are_first_name(self, long_df):\n\n        m = MockMark()\n        p = (\n            Plot(long_df, x=long_df[\"z\"].to_list(), y=\"b\")\n            .add(m, x=\"a\")\n            .add(m, x=\"x\", y=\"y\")\n        )\n        ax, = p.plot()._figure.axes\n        assert ax.get_xlabel() == \"a\"\n        assert ax.get_ylabel() == \"b\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_axis_labels_are_first_name", "self", "long_df", "m", "mockmark", "p", "plot", "long_df", "x", "long_df", "z", "to_list", "y", "b", "add", "m", "x", "a", "add", "m", "x", "x", "y", "y", "ax", "p", "plot", "_figure", "axes", "assert", "ax", "get_xlabel", "a", "assert", "ax", "get_ylabel", "b"], "doc_len": 43}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_limits", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_limits", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_limits(self, long_df):\n\n        limit = (-2, 24)\n        p = Plot(long_df, x=\"x\", y=\"y\").limit(x=limit).plot()\n        ax = p._figure.axes[0]\n        assert ax.get_xlim() == limit\n\n        limit = (np.datetime64(\"2005-01-01\"), np.datetime64(\"2008-01-01\"))\n        p = Plot(long_df, x=\"d\", y=\"y\").limit(x=limit).plot()\n        ax = p._figure.axes[0]\n        assert ax.get_xlim() == tuple(mpl.dates.date2num(limit))\n\n        limit = (\"b\", \"c\")\n        p = Plot(x=[\"a\", \"b\", \"c\", \"d\"], y=[1, 2, 3, 4]).limit(x=limit).plot()\n        ax = p._figure.axes[0]\n        assert ax.get_xlim() == (0.5, 2.5)\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_limits", "self", "long_df", "limit", "2", "24", "p", "plot", "long_df", "x", "x", "y", "y", "limit", "x", "limit", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_xlim", "limit", "limit", "np", "datetime64", "2005", "01", "01", "np", "datetime64", "2008", "01", "01", "p", "plot", "long_df", "x", "d", "y", "y", "limit", "x", "limit", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_xlim", "tuple", "mpl", "dates", "date2num", "limit", "limit", "b", "c", "p", "plot", "x", "a", "b", "c", "d", "y", "1", "2", "3", "4", "limit", "x", "limit", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_xlim", "0", "5", "2", "5"], "doc_len": 98}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_labels_axis", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_labels_axis", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_labels_axis(self, long_df):\n\n        label = \"Y axis\"\n        p = Plot(long_df, x=\"x\", y=\"y\").label(y=label).plot()\n        ax = p._figure.axes[0]\n        assert ax.get_ylabel() == label\n\n        label = str.capitalize\n        p = Plot(long_df, x=\"x\", y=\"y\").label(y=label).plot()\n        ax = p._figure.axes[0]\n        assert ax.get_ylabel() == \"Y\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_labels_axis", "self", "long_df", "label", "y", "axis", "p", "plot", "long_df", "x", "x", "y", "y", "label", "y", "label", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_ylabel", "label", "label", "str", "capitalize", "p", "plot", "long_df", "x", "x", "y", "y", "label", "y", "label", "plot", "ax", "p", "_figure", "axes", "0", "assert", "ax", "get_ylabel", "y"], "doc_len": 55}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_labels_legend", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_labels_legend", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_labels_legend(self, long_df):\n\n        m = MockMark()\n\n        label = \"A\"\n        p = Plot(long_df, x=\"x\", y=\"y\", color=\"a\").add(m).label(color=label).plot()\n        assert p._figure.legends[0].get_title().get_text() == label\n\n        func = str.capitalize\n        p = Plot(long_df, x=\"x\", y=\"y\", color=\"a\").add(m).label(color=func).plot()\n        assert p._figure.legends[0].get_title().get_text() == label\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_labels_legend", "self", "long_df", "m", "mockmark", "label", "a", "p", "plot", "long_df", "x", "x", "y", "y", "color", "a", "add", "m", "label", "color", "label", "plot", "assert", "p", "_figure", "legends", "0", "get_title", "get_text", "label", "func", "str", "capitalize", "p", "plot", "long_df", "x", "x", "y", "y", "color", "a", "add", "m", "label", "color", "func", "plot", "assert", "p", "_figure", "legends", "0", "get_title", "get_text", "label"], "doc_len": 62}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_labels_facets", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_labels_facets", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_labels_facets(self):\n\n        data = {\"a\": [\"b\", \"c\"], \"x\": [\"y\", \"z\"]}\n        p = Plot(data).facet(\"a\", \"x\").label(col=str.capitalize, row=\"$x$\").plot()\n        axs = np.reshape(p._figure.axes, (2, 2))\n        for (i, j), ax in np.ndenumerate(axs):\n            expected = f\"A {data['a'][j]} | $x$ {data['x'][i]}\"\n            assert ax.get_title() == expected\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_labels_facets", "self", "data", "a", "b", "c", "x", "y", "z", "p", "plot", "data", "facet", "a", "x", "label", "col", "str", "capitalize", "row", "x", "plot", "axs", "np", "reshape", "p", "_figure", "axes", "2", "2", "for", "i", "j", "ax", "in", "np", "ndenumerate", "axs", "expected", "f", "a", "data", "a", "j", "x", "data", "x", "i", "assert", "ax", "get_title", "expected"], "doc_len": 58}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_title_single", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_title_single", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_title_single(self):\n\n        label = \"A\"\n        p = Plot().label(title=label).plot()\n        assert p._figure.axes[0].get_title() == label\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_title_single", "self", "label", "a", "p", "plot", "label", "title", "label", "plot", "assert", "p", "_figure", "axes", "0", "get_title", "label"], "doc_len": 23}
{"doc_id": "tests/_core/test_plot.py::TestPlotting.test_title_facet_function", "file_path": "tests/_core/test_plot.py", "class_name": "TestPlotting", "func_name": "test_title_facet_function", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPlotting\n    def test_title_facet_function(self):\n\n        titles = [\"a\", \"b\"]\n        p = Plot().facet(titles).label(title=str.capitalize).plot()\n        for i, ax in enumerate(p._figure.axes):\n            assert ax.get_title() == titles[i].upper()\n\n        cols, rows = [\"a\", \"b\"], [\"x\", \"y\"]\n        p = Plot().facet(cols, rows).label(title=str.capitalize).plot()\n        for i, ax in enumerate(p._figure.axes):\n            expected = \" | \".join([cols[i % 2].upper(), rows[i // 2].upper()])\n            assert ax.get_title() == expected\n", "tokens": ["tests", "_core", "test_plot", "py", "testplotting", "def", "test_title_facet_function", "self", "titles", "a", "b", "p", "plot", "facet", "titles", "label", "title", "str", "capitalize", "plot", "for", "i", "ax", "in", "enumerate", "p", "_figure", "axes", "assert", "ax", "get_title", "titles", "i", "upper", "cols", "rows", "a", "b", "x", "y", "p", "plot", "facet", "cols", "rows", "label", "title", "str", "capitalize", "plot", "for", "i", "ax", "in", "enumerate", "p", "_figure", "axes", "expected", "join", "cols", "i", "2", "upper", "rows", "i", "2", "upper", "assert", "ax", "get_title", "expected"], "doc_len": 72}
{"doc_id": "tests/_core/test_plot.py::TestExceptions.test_scale_setup", "file_path": "tests/_core/test_plot.py", "class_name": "TestExceptions", "func_name": "test_scale_setup", "text": "文件路径: tests/_core/test_plot.py, 类名: TestExceptions\n    def test_scale_setup(self):\n\n        x = y = color = [\"a\", \"b\"]\n        bad_palette = \"not_a_palette\"\n        p = Plot(x, y, color=color).add(MockMark()).scale(color=bad_palette)\n\n        msg = \"Scale setup failed for the `color` variable.\"\n        with pytest.raises(PlotSpecError, match=msg) as err:\n            p.plot()\n        assert isinstance(err.value.__cause__, ValueError)\n        assert bad_palette in str(err.value.__cause__)\n", "tokens": ["tests", "_core", "test_plot", "py", "testexceptions", "def", "test_scale_setup", "self", "x", "y", "color", "a", "b", "bad_palette", "not_a_palette", "p", "plot", "x", "y", "color", "color", "add", "mockmark", "scale", "color", "bad_palette", "msg", "scale", "setup", "failed", "for", "the", "color", "variable", "with", "pytest", "raises", "plotspecerror", "match", "msg", "as", "err", "p", "plot", "assert", "isinstance", "err", "value", "__cause__", "valueerror", "assert", "bad_palette", "in", "str", "err", "value", "__cause__"], "doc_len": 57}
{"doc_id": "tests/_core/test_plot.py::TestExceptions.test_coordinate_scaling", "file_path": "tests/_core/test_plot.py", "class_name": "TestExceptions", "func_name": "test_coordinate_scaling", "text": "文件路径: tests/_core/test_plot.py, 类名: TestExceptions\n    def test_coordinate_scaling(self):\n\n        x = [\"a\", \"b\"]\n        y = [1, 2]\n        p = Plot(x, y).add(MockMark()).scale(x=Temporal())\n\n        msg = \"Scaling operation failed for the `x` variable.\"\n        with pytest.raises(PlotSpecError, match=msg) as err:\n            p.plot()\n        # Don't test the cause contents b/c matplotlib owns them here.\n        assert hasattr(err.value, \"__cause__\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testexceptions", "def", "test_coordinate_scaling", "self", "x", "a", "b", "y", "1", "2", "p", "plot", "x", "y", "add", "mockmark", "scale", "x", "temporal", "msg", "scaling", "operation", "failed", "for", "the", "x", "variable", "with", "pytest", "raises", "plotspecerror", "match", "msg", "as", "err", "p", "plot", "don", "t", "test", "the", "cause", "contents", "b", "c", "matplotlib", "owns", "them", "here", "assert", "hasattr", "err", "value", "__cause__"], "doc_len": 58}
{"doc_id": "tests/_core/test_plot.py::TestExceptions.test_semantic_scaling", "file_path": "tests/_core/test_plot.py", "class_name": "TestExceptions", "func_name": "test_semantic_scaling", "text": "文件路径: tests/_core/test_plot.py, 类名: TestExceptions\n    def test_semantic_scaling(self):\n\n        class ErrorRaising(Continuous):\n\n            def _setup(self, data, prop, axis=None):\n\n                def f(x):\n                    raise ValueError(\"This is a test\")\n\n                new = super()._setup(data, prop, axis)\n                new._pipeline = [f]\n                return new\n\n        x = y = color = [1, 2]\n        p = Plot(x, y, color=color).add(Dot()).scale(color=ErrorRaising())\n        msg = \"Scaling operation failed for the `color` variable.\"\n        with pytest.raises(PlotSpecError, match=msg) as err:\n            p.plot()\n        assert isinstance(err.value.__cause__, ValueError)\n        assert str(err.value.__cause__) == \"This is a test\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testexceptions", "def", "test_semantic_scaling", "self", "class", "errorraising", "continuous", "def", "_setup", "self", "data", "prop", "axis", "none", "def", "f", "x", "raise", "valueerror", "this", "is", "a", "test", "new", "super", "_setup", "data", "prop", "axis", "new", "_pipeline", "f", "return", "new", "x", "y", "color", "1", "2", "p", "plot", "x", "y", "color", "color", "add", "dot", "scale", "color", "errorraising", "msg", "scaling", "operation", "failed", "for", "the", "color", "variable", "with", "pytest", "raises", "plotspecerror", "match", "msg", "as", "err", "p", "plot", "assert", "isinstance", "err", "value", "__cause__", "valueerror", "assert", "str", "err", "value", "__cause__", "this", "is", "a", "test"], "doc_len": 87}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.dim", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "dim", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def dim(self, request):\n        return request.param\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "dim", "self", "request", "return", "request", "param"], "doc_len": 12}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.reorder", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "reorder", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def reorder(self, request):\n        return {\n            \"reverse\": lambda x: x[::-1],\n            \"subset\": lambda x: x[:-1],\n            \"expand\": lambda x: x + [\"z\"],\n        }[request.param]\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "reorder", "self", "request", "return", "reverse", "lambda", "x", "x", "1", "subset", "lambda", "x", "x", "1", "expand", "lambda", "x", "x", "z", "request", "param"], "doc_len": 27}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.check_facet_results_1d", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "check_facet_results_1d", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def check_facet_results_1d(self, p, df, dim, key, order=None):\n\n        p = p.plot()\n\n        order = categorical_order(df[key], order)\n        assert len(p._figure.axes) == len(order)\n\n        other_dim = {\"row\": \"col\", \"col\": \"row\"}[dim]\n\n        for subplot, level in zip(p._subplots, order):\n            assert subplot[dim] == level\n            assert subplot[other_dim] is None\n            assert subplot[\"ax\"].get_title() == f\"{level}\"\n            assert_gridspec_shape(subplot[\"ax\"], **{f\"n{dim}s\": len(order)})\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "check_facet_results_1d", "self", "p", "df", "dim", "key", "order", "none", "p", "p", "plot", "order", "categorical_order", "df", "key", "order", "assert", "len", "p", "_figure", "axes", "len", "order", "other_dim", "row", "col", "col", "row", "dim", "for", "subplot", "level", "in", "zip", "p", "_subplots", "order", "assert", "subplot", "dim", "level", "assert", "subplot", "other_dim", "is", "none", "assert", "subplot", "ax", "get_title", "f", "level", "assert_gridspec_shape", "subplot", "ax", "f", "n", "dim", "s", "len", "order"], "doc_len": 67}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_1d", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_1d", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_1d(self, long_df, dim):\n\n        key = \"a\"\n        p = Plot(long_df).facet(**{dim: key})\n        self.check_facet_results_1d(p, long_df, dim, key)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_1d", "self", "long_df", "dim", "key", "a", "p", "plot", "long_df", "facet", "dim", "key", "self", "check_facet_results_1d", "p", "long_df", "dim", "key"], "doc_len": 24}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_1d_as_vector", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_1d_as_vector", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_1d_as_vector(self, long_df, dim):\n\n        key = \"a\"\n        p = Plot(long_df).facet(**{dim: long_df[key]})\n        self.check_facet_results_1d(p, long_df, dim, key)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_1d_as_vector", "self", "long_df", "dim", "key", "a", "p", "plot", "long_df", "facet", "dim", "long_df", "key", "self", "check_facet_results_1d", "p", "long_df", "dim", "key"], "doc_len": 25}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_1d_with_order", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_1d_with_order", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_1d_with_order(self, long_df, dim, reorder):\n\n        key = \"a\"\n        order = reorder(categorical_order(long_df[key]))\n        p = Plot(long_df).facet(**{dim: key, \"order\": order})\n        self.check_facet_results_1d(p, long_df, dim, key, order)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_1d_with_order", "self", "long_df", "dim", "reorder", "key", "a", "order", "reorder", "categorical_order", "long_df", "key", "p", "plot", "long_df", "facet", "dim", "key", "order", "order", "self", "check_facet_results_1d", "p", "long_df", "dim", "key", "order"], "doc_len": 33}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.check_facet_results_2d", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "check_facet_results_2d", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def check_facet_results_2d(self, p, df, variables, order=None):\n\n        p = p.plot()\n\n        if order is None:\n            order = {dim: categorical_order(df[key]) for dim, key in variables.items()}\n\n        levels = itertools.product(*[order[dim] for dim in [\"row\", \"col\"]])\n        assert len(p._subplots) == len(list(levels))\n\n        for subplot, (row_level, col_level) in zip(p._subplots, levels):\n            assert subplot[\"row\"] == row_level\n            assert subplot[\"col\"] == col_level\n            assert subplot[\"axes\"].get_title() == (\n                f\"{col_level} | {row_level}\"\n            )\n            assert_gridspec_shape(\n                subplot[\"axes\"], len(levels[\"row\"]), len(levels[\"col\"])\n            )\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "check_facet_results_2d", "self", "p", "df", "variables", "order", "none", "p", "p", "plot", "if", "order", "is", "none", "order", "dim", "categorical_order", "df", "key", "for", "dim", "key", "in", "variables", "items", "levels", "itertools", "product", "order", "dim", "for", "dim", "in", "row", "col", "assert", "len", "p", "_subplots", "len", "list", "levels", "for", "subplot", "row_level", "col_level", "in", "zip", "p", "_subplots", "levels", "assert", "subplot", "row", "row_level", "assert", "subplot", "col", "col_level", "assert", "subplot", "axes", "get_title", "f", "col_level", "row_level", "assert_gridspec_shape", "subplot", "axes", "len", "levels", "row", "len", "levels", "col"], "doc_len": 81}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_2d", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_2d", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_2d(self, long_df):\n\n        variables = {\"row\": \"a\", \"col\": \"c\"}\n        p = Plot(long_df).facet(**variables)\n        self.check_facet_results_2d(p, long_df, variables)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_2d", "self", "long_df", "variables", "row", "a", "col", "c", "p", "plot", "long_df", "facet", "variables", "self", "check_facet_results_2d", "p", "long_df", "variables"], "doc_len": 24}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_2d_with_order", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_2d_with_order", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_2d_with_order(self, long_df, reorder):\n\n        variables = {\"row\": \"a\", \"col\": \"c\"}\n        order = {\n            dim: reorder(categorical_order(long_df[key]))\n            for dim, key in variables.items()\n        }\n\n        p = Plot(long_df).facet(**variables, order=order)\n        self.check_facet_results_2d(p, long_df, variables, order)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_2d_with_order", "self", "long_df", "reorder", "variables", "row", "a", "col", "c", "order", "dim", "reorder", "categorical_order", "long_df", "key", "for", "dim", "key", "in", "variables", "items", "p", "plot", "long_df", "facet", "variables", "order", "order", "self", "check_facet_results_2d", "p", "long_df", "variables", "order"], "doc_len": 40}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_layout_algo", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_layout_algo", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_layout_algo(self, algo):\n\n        if algo == \"constrained\" and Version(mpl.__version__) < Version(\"3.3.0\"):\n            pytest.skip(\"constrained_layout requires matplotlib>=3.3\")\n\n        p = Plot().facet([\"a\", \"b\"]).limit(x=(.1, .9))\n\n        p1 = p.layout(engine=algo).plot()\n        p2 = p.layout(engine=None).plot()\n\n        # Force a draw (we probably need a method for this)\n        p1.save(io.BytesIO())\n        p2.save(io.BytesIO())\n\n        bb11, bb12 = [ax.get_position() for ax in p1._figure.axes]\n        bb21, bb22 = [ax.get_position() for ax in p2._figure.axes]\n\n        sep1 = bb12.corners()[0, 0] - bb11.corners()[2, 0]\n        sep2 = bb22.corners()[0, 0] - bb21.corners()[2, 0]\n        assert sep1 < sep2\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_layout_algo", "self", "algo", "if", "algo", "constrained", "and", "version", "mpl", "__version__", "version", "3", "3", "0", "pytest", "skip", "constrained_layout", "requires", "matplotlib", "3", "3", "p", "plot", "facet", "a", "b", "limit", "x", "1", "9", "p1", "p", "layout", "engine", "algo", "plot", "p2", "p", "layout", "engine", "none", "plot", "force", "a", "draw", "we", "probably", "need", "a", "method", "for", "this", "p1", "save", "io", "bytesio", "p2", "save", "io", "bytesio", "bb11", "bb12", "ax", "get_position", "for", "ax", "in", "p1", "_figure", "axes", "bb21", "bb22", "ax", "get_position", "for", "ax", "in", "p2", "_figure", "axes", "sep1", "bb12", "corners", "0", "0", "bb11", "corners", "2", "0", "sep2", "bb22", "corners", "0", "0", "bb21", "corners", "2", "0", "assert", "sep1", "sep2"], "doc_len": 107}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_axis_sharing", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_axis_sharing", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_axis_sharing(self, long_df):\n\n        variables = {\"row\": \"a\", \"col\": \"c\"}\n\n        p = Plot(long_df).facet(**variables)\n\n        p1 = p.plot()\n        root, *other = p1._figure.axes\n        for axis in \"xy\":\n            shareset = getattr(root, f\"get_shared_{axis}_axes\")()\n            assert all(shareset.joined(root, ax) for ax in other)\n\n        p2 = p.share(x=False, y=False).plot()\n        root, *other = p2._figure.axes\n        for axis in \"xy\":\n            shareset = getattr(root, f\"get_shared_{axis}_axes\")()\n            assert not any(shareset.joined(root, ax) for ax in other)\n\n        p3 = p.share(x=\"col\", y=\"row\").plot()\n        shape = (\n            len(categorical_order(long_df[variables[\"row\"]])),\n            len(categorical_order(long_df[variables[\"col\"]])),\n        )\n        axes_matrix = np.reshape(p3._figure.axes, shape)\n\n        for (shared, unshared), vectors in zip(\n            [\"yx\", \"xy\"], [axes_matrix, axes_matrix.T]\n        ):\n            for root, *other in vectors:\n                shareset = {\n                    axis: getattr(root, f\"get_shared_{axis}_axes\")() for axis in \"xy\"\n                }\n                assert all(shareset[shared].joined(root, ax) for ax in other)\n                assert not any(shareset[unshared].joined(root, ax) for ax in other)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_axis_sharing", "self", "long_df", "variables", "row", "a", "col", "c", "p", "plot", "long_df", "facet", "variables", "p1", "p", "plot", "root", "other", "p1", "_figure", "axes", "for", "axis", "in", "xy", "shareset", "getattr", "root", "f", "get_shared_", "axis", "_axes", "assert", "all", "shareset", "joined", "root", "ax", "for", "ax", "in", "other", "p2", "p", "share", "x", "false", "y", "false", "plot", "root", "other", "p2", "_figure", "axes", "for", "axis", "in", "xy", "shareset", "getattr", "root", "f", "get_shared_", "axis", "_axes", "assert", "not", "any", "shareset", "joined", "root", "ax", "for", "ax", "in", "other", "p3", "p", "share", "x", "col", "y", "row", "plot", "shape", "len", "categorical_order", "long_df", "variables", "row", "len", "categorical_order", "long_df", "variables", "col", "axes_matrix", "np", "reshape", "p3", "_figure", "axes", "shape", "for", "shared", "unshared", "vectors", "in", "zip", "yx", "xy", "axes_matrix", "axes_matrix", "t", "for", "root", "other", "in", "vectors", "shareset", "axis", "getattr", "root", "f", "get_shared_", "axis", "_axes", "for", "axis", "in", "xy", "assert", "all", "shareset", "shared", "joined", "root", "ax", "for", "ax", "in", "other", "assert", "not", "any", "shareset", "unshared", "joined", "root", "ax", "for", "ax", "in", "other"], "doc_len": 160}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_unshared_spacing", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_unshared_spacing", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_unshared_spacing(self):\n\n        x = [1, 2, 10, 20]\n        y = [1, 2, 3, 4]\n        col = [1, 1, 2, 2]\n\n        m = MockMark()\n        Plot(x, y).facet(col).add(m).share(x=False).plot()\n        assert_array_almost_equal(m.passed_data[0][\"width\"], [0.8, 0.8])\n        assert_array_equal(m.passed_data[1][\"width\"], [8, 8])\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_unshared_spacing", "self", "x", "1", "2", "10", "20", "y", "1", "2", "3", "4", "col", "1", "1", "2", "2", "m", "mockmark", "plot", "x", "y", "facet", "col", "add", "m", "share", "x", "false", "plot", "assert_array_almost_equal", "m", "passed_data", "0", "width", "0", "8", "0", "8", "assert_array_equal", "m", "passed_data", "1", "width", "8", "8"], "doc_len": 52}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_col_wrapping", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_col_wrapping", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_col_wrapping(self):\n\n        cols = list(\"abcd\")\n        wrap = 3\n        p = Plot().facet(col=cols, wrap=wrap).plot()\n\n        assert len(p._figure.axes) == 4\n        assert_gridspec_shape(p._figure.axes[0], len(cols) // wrap + 1, wrap)\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_col_wrapping", "self", "cols", "list", "abcd", "wrap", "3", "p", "plot", "facet", "col", "cols", "wrap", "wrap", "plot", "assert", "len", "p", "_figure", "axes", "4", "assert_gridspec_shape", "p", "_figure", "axes", "0", "len", "cols", "wrap", "1", "wrap"], "doc_len": 37}
{"doc_id": "tests/_core/test_plot.py::TestFacetInterface.test_row_wrapping", "file_path": "tests/_core/test_plot.py", "class_name": "TestFacetInterface", "func_name": "test_row_wrapping", "text": "文件路径: tests/_core/test_plot.py, 类名: TestFacetInterface\n    def test_row_wrapping(self):\n\n        rows = list(\"abcd\")\n        wrap = 3\n        p = Plot().facet(row=rows, wrap=wrap).plot()\n\n        assert_gridspec_shape(p._figure.axes[0], wrap, len(rows) // wrap + 1)\n        assert len(p._figure.axes) == 4\n", "tokens": ["tests", "_core", "test_plot", "py", "testfacetinterface", "def", "test_row_wrapping", "self", "rows", "list", "abcd", "wrap", "3", "p", "plot", "facet", "row", "rows", "wrap", "wrap", "plot", "assert_gridspec_shape", "p", "_figure", "axes", "0", "wrap", "len", "rows", "wrap", "1", "assert", "len", "p", "_figure", "axes", "4"], "doc_len": 37}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.check_pair_grid", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "check_pair_grid", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def check_pair_grid(self, p, x, y):\n\n        xys = itertools.product(y, x)\n\n        for (y_i, x_j), subplot in zip(xys, p._subplots):\n\n            ax = subplot[\"ax\"]\n            assert ax.get_xlabel() == \"\" if x_j is None else x_j\n            assert ax.get_ylabel() == \"\" if y_i is None else y_i\n            assert_gridspec_shape(subplot[\"ax\"], len(y), len(x))\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "check_pair_grid", "self", "p", "x", "y", "xys", "itertools", "product", "y", "x", "for", "y_i", "x_j", "subplot", "in", "zip", "xys", "p", "_subplots", "ax", "subplot", "ax", "assert", "ax", "get_xlabel", "if", "x_j", "is", "none", "else", "x_j", "assert", "ax", "get_ylabel", "if", "y_i", "is", "none", "else", "y_i", "assert_gridspec_shape", "subplot", "ax", "len", "y", "len", "x"], "doc_len": 53}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_all_numeric", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_all_numeric", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_all_numeric(self, long_df, vector_type):\n\n        x, y = [\"x\", \"y\", \"z\"], [\"s\", \"f\"]\n        p = Plot(long_df).pair(vector_type(x), vector_type(y)).plot()\n        self.check_pair_grid(p, x, y)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_all_numeric", "self", "long_df", "vector_type", "x", "y", "x", "y", "z", "s", "f", "p", "plot", "long_df", "pair", "vector_type", "x", "vector_type", "y", "plot", "self", "check_pair_grid", "p", "x", "y"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_single_variable_key_raises", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_single_variable_key_raises", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_single_variable_key_raises(self, long_df):\n\n        p = Plot(long_df)\n        err = \"You must pass a sequence of variable keys to `y`\"\n        with pytest.raises(TypeError, match=err):\n            p.pair(x=[\"x\", \"y\"], y=\"z\")\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_single_variable_key_raises", "self", "long_df", "p", "plot", "long_df", "err", "you", "must", "pass", "a", "sequence", "of", "variable", "keys", "to", "y", "with", "pytest", "raises", "typeerror", "match", "err", "p", "pair", "x", "x", "y", "y", "z"], "doc_len": 36}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_single_dimension", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_single_dimension", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_single_dimension(self, long_df, dim):\n\n        variables = {\"x\": None, \"y\": None}\n        variables[dim] = [\"x\", \"y\", \"z\"]\n        p = Plot(long_df).pair(**variables).plot()\n        variables = {k: [v] if v is None else v for k, v in variables.items()}\n        self.check_pair_grid(p, **variables)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_single_dimension", "self", "long_df", "dim", "variables", "x", "none", "y", "none", "variables", "dim", "x", "y", "z", "p", "plot", "long_df", "pair", "variables", "plot", "variables", "k", "v", "if", "v", "is", "none", "else", "v", "for", "k", "v", "in", "variables", "items", "self", "check_pair_grid", "p", "variables"], "doc_len": 45}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_non_cross", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_non_cross", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_non_cross(self, long_df):\n\n        x = [\"x\", \"y\"]\n        y = [\"f\", \"z\"]\n\n        p = Plot(long_df).pair(x, y, cross=False).plot()\n\n        for i, subplot in enumerate(p._subplots):\n            ax = subplot[\"ax\"]\n            assert ax.get_xlabel() == x[i]\n            assert ax.get_ylabel() == y[i]\n            assert_gridspec_shape(ax, 1, len(x))\n\n        root, *other = p._figure.axes\n        for axis in \"xy\":\n            shareset = getattr(root, f\"get_shared_{axis}_axes\")()\n            assert not any(shareset.joined(root, ax) for ax in other)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_non_cross", "self", "long_df", "x", "x", "y", "y", "f", "z", "p", "plot", "long_df", "pair", "x", "y", "cross", "false", "plot", "for", "i", "subplot", "in", "enumerate", "p", "_subplots", "ax", "subplot", "ax", "assert", "ax", "get_xlabel", "x", "i", "assert", "ax", "get_ylabel", "y", "i", "assert_gridspec_shape", "ax", "1", "len", "x", "root", "other", "p", "_figure", "axes", "for", "axis", "in", "xy", "shareset", "getattr", "root", "f", "get_shared_", "axis", "_axes", "assert", "not", "any", "shareset", "joined", "root", "ax", "for", "ax", "in", "other"], "doc_len": 76}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_list_of_vectors", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_list_of_vectors", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_list_of_vectors(self, long_df):\n\n        x_vars = [\"x\", \"z\"]\n        p = Plot(long_df, y=\"y\").pair(x=[long_df[x] for x in x_vars]).plot()\n        assert len(p._figure.axes) == len(x_vars)\n        for ax, x_i in zip(p._figure.axes, x_vars):\n            assert ax.get_xlabel() == x_i\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_list_of_vectors", "self", "long_df", "x_vars", "x", "z", "p", "plot", "long_df", "y", "y", "pair", "x", "long_df", "x", "for", "x", "in", "x_vars", "plot", "assert", "len", "p", "_figure", "axes", "len", "x_vars", "for", "ax", "x_i", "in", "zip", "p", "_figure", "axes", "x_vars", "assert", "ax", "get_xlabel", "x_i"], "doc_len": 46}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_with_no_variables", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_with_no_variables", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_with_no_variables(self, long_df):\n\n        p = Plot(long_df).pair().plot()\n        assert len(p._figure.axes) == 1\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_with_no_variables", "self", "long_df", "p", "plot", "long_df", "pair", "plot", "assert", "len", "p", "_figure", "axes", "1"], "doc_len": 20}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_with_facets", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_with_facets", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_with_facets(self, long_df):\n\n        x = \"x\"\n        y = [\"y\", \"z\"]\n        col = \"a\"\n\n        p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n\n        facet_levels = categorical_order(long_df[col])\n        dims = itertools.product(y, facet_levels)\n\n        for (y_i, col_i), subplot in zip(dims, p._subplots):\n\n            ax = subplot[\"ax\"]\n            assert ax.get_xlabel() == x\n            assert ax.get_ylabel() == y_i\n            assert ax.get_title() == f\"{col_i}\"\n            assert_gridspec_shape(ax, len(y), len(facet_levels))\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_with_facets", "self", "long_df", "x", "x", "y", "y", "z", "col", "a", "p", "plot", "long_df", "x", "x", "facet", "col", "pair", "y", "y", "plot", "facet_levels", "categorical_order", "long_df", "col", "dims", "itertools", "product", "y", "facet_levels", "for", "y_i", "col_i", "subplot", "in", "zip", "dims", "p", "_subplots", "ax", "subplot", "ax", "assert", "ax", "get_xlabel", "x", "assert", "ax", "get_ylabel", "y_i", "assert", "ax", "get_title", "f", "col_i", "assert_gridspec_shape", "ax", "len", "y", "len", "facet_levels"], "doc_len": 67}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_error_on_facet_overlap", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_error_on_facet_overlap", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_error_on_facet_overlap(self, long_df, variables):\n\n        facet_dim, pair_axis = variables\n        p = Plot(long_df).facet(**{facet_dim[:3]: \"a\"}).pair(**{pair_axis: [\"x\", \"y\"]})\n        expected = f\"Cannot facet the {facet_dim} while pairing on `{pair_axis}`.\"\n        with pytest.raises(RuntimeError, match=expected):\n            p.plot()\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_error_on_facet_overlap", "self", "long_df", "variables", "facet_dim", "pair_axis", "variables", "p", "plot", "long_df", "facet", "facet_dim", "3", "a", "pair", "pair_axis", "x", "y", "expected", "f", "cannot", "facet", "the", "facet_dim", "while", "pairing", "on", "pair_axis", "with", "pytest", "raises", "runtimeerror", "match", "expected", "p", "plot"], "doc_len": 42}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_error_on_wrap_overlap", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_error_on_wrap_overlap", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_error_on_wrap_overlap(self, long_df, variables):\n\n        facet_dim, pair_axis = variables\n        p = (\n            Plot(long_df)\n            .facet(wrap=2, **{facet_dim[:3]: \"a\"})\n            .pair(**{pair_axis: [\"x\", \"y\"]})\n        )\n        expected = f\"Cannot wrap the {facet_dim} while pairing on `{pair_axis}``.\"\n        with pytest.raises(RuntimeError, match=expected):\n            p.plot()\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_error_on_wrap_overlap", "self", "long_df", "variables", "facet_dim", "pair_axis", "variables", "p", "plot", "long_df", "facet", "wrap", "2", "facet_dim", "3", "a", "pair", "pair_axis", "x", "y", "expected", "f", "cannot", "wrap", "the", "facet_dim", "while", "pairing", "on", "pair_axis", "with", "pytest", "raises", "runtimeerror", "match", "expected", "p", "plot"], "doc_len": 44}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_axis_sharing", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_axis_sharing", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_axis_sharing(self, long_df):\n\n        p = Plot(long_df).pair(x=[\"a\", \"b\"], y=[\"y\", \"z\"])\n        shape = 2, 2\n\n        p1 = p.plot()\n        axes_matrix = np.reshape(p1._figure.axes, shape)\n\n        for root, *other in axes_matrix:  # Test row-wise sharing\n            x_shareset = getattr(root, \"get_shared_x_axes\")()\n            assert not any(x_shareset.joined(root, ax) for ax in other)\n            y_shareset = getattr(root, \"get_shared_y_axes\")()\n            assert all(y_shareset.joined(root, ax) for ax in other)\n\n        for root, *other in axes_matrix.T:  # Test col-wise sharing\n            x_shareset = getattr(root, \"get_shared_x_axes\")()\n            assert all(x_shareset.joined(root, ax) for ax in other)\n            y_shareset = getattr(root, \"get_shared_y_axes\")()\n            assert not any(y_shareset.joined(root, ax) for ax in other)\n\n        p2 = p.share(x=False, y=False).plot()\n        root, *other = p2._figure.axes\n        for axis in \"xy\":\n            shareset = getattr(root, f\"get_shared_{axis}_axes\")()\n            assert not any(shareset.joined(root, ax) for ax in other)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_axis_sharing", "self", "long_df", "p", "plot", "long_df", "pair", "x", "a", "b", "y", "y", "z", "shape", "2", "2", "p1", "p", "plot", "axes_matrix", "np", "reshape", "p1", "_figure", "axes", "shape", "for", "root", "other", "in", "axes_matrix", "test", "row", "wise", "sharing", "x_shareset", "getattr", "root", "get_shared_x_axes", "assert", "not", "any", "x_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "y_shareset", "getattr", "root", "get_shared_y_axes", "assert", "all", "y_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "for", "root", "other", "in", "axes_matrix", "t", "test", "col", "wise", "sharing", "x_shareset", "getattr", "root", "get_shared_x_axes", "assert", "all", "x_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "y_shareset", "getattr", "root", "get_shared_y_axes", "assert", "not", "any", "y_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "p2", "p", "share", "x", "false", "y", "false", "plot", "root", "other", "p2", "_figure", "axes", "for", "axis", "in", "xy", "shareset", "getattr", "root", "f", "get_shared_", "axis", "_axes", "assert", "not", "any", "shareset", "joined", "root", "ax", "for", "ax", "in", "other"], "doc_len": 144}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_axis_sharing_with_facets", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_axis_sharing_with_facets", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_axis_sharing_with_facets(self, long_df):\n\n        p = Plot(long_df, y=\"y\").pair(x=[\"a\", \"b\"]).facet(row=\"c\").plot()\n        shape = 2, 2\n\n        axes_matrix = np.reshape(p._figure.axes, shape)\n\n        for root, *other in axes_matrix:  # Test row-wise sharing\n            x_shareset = getattr(root, \"get_shared_x_axes\")()\n            assert not any(x_shareset.joined(root, ax) for ax in other)\n            y_shareset = getattr(root, \"get_shared_y_axes\")()\n            assert all(y_shareset.joined(root, ax) for ax in other)\n\n        for root, *other in axes_matrix.T:  # Test col-wise sharing\n            x_shareset = getattr(root, \"get_shared_x_axes\")()\n            assert all(x_shareset.joined(root, ax) for ax in other)\n            y_shareset = getattr(root, \"get_shared_y_axes\")()\n            assert all(y_shareset.joined(root, ax) for ax in other)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_axis_sharing_with_facets", "self", "long_df", "p", "plot", "long_df", "y", "y", "pair", "x", "a", "b", "facet", "row", "c", "plot", "shape", "2", "2", "axes_matrix", "np", "reshape", "p", "_figure", "axes", "shape", "for", "root", "other", "in", "axes_matrix", "test", "row", "wise", "sharing", "x_shareset", "getattr", "root", "get_shared_x_axes", "assert", "not", "any", "x_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "y_shareset", "getattr", "root", "get_shared_y_axes", "assert", "all", "y_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "for", "root", "other", "in", "axes_matrix", "t", "test", "col", "wise", "sharing", "x_shareset", "getattr", "root", "get_shared_x_axes", "assert", "all", "x_shareset", "joined", "root", "ax", "for", "ax", "in", "other", "y_shareset", "getattr", "root", "get_shared_y_axes", "assert", "all", "y_shareset", "joined", "root", "ax", "for", "ax", "in", "other"], "doc_len": 108}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_x_wrapping", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_x_wrapping", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_x_wrapping(self, long_df):\n\n        x_vars = [\"f\", \"x\", \"y\", \"z\"]\n        wrap = 3\n        p = Plot(long_df, y=\"y\").pair(x=x_vars, wrap=wrap).plot()\n\n        assert_gridspec_shape(p._figure.axes[0], len(x_vars) // wrap + 1, wrap)\n        assert len(p._figure.axes) == len(x_vars)\n        for ax, var in zip(p._figure.axes, x_vars):\n            label = ax.xaxis.get_label()\n            assert label.get_visible()\n            assert label.get_text() == var\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_x_wrapping", "self", "long_df", "x_vars", "f", "x", "y", "z", "wrap", "3", "p", "plot", "long_df", "y", "y", "pair", "x", "x_vars", "wrap", "wrap", "plot", "assert_gridspec_shape", "p", "_figure", "axes", "0", "len", "x_vars", "wrap", "1", "wrap", "assert", "len", "p", "_figure", "axes", "len", "x_vars", "for", "ax", "var", "in", "zip", "p", "_figure", "axes", "x_vars", "label", "ax", "xaxis", "get_label", "assert", "label", "get_visible", "assert", "label", "get_text", "var"], "doc_len": 64}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_y_wrapping", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_y_wrapping", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_y_wrapping(self, long_df):\n\n        y_vars = [\"f\", \"x\", \"y\", \"z\"]\n        wrap = 3\n        p = Plot(long_df, x=\"x\").pair(y=y_vars, wrap=wrap).plot()\n\n        n_row, n_col = wrap, len(y_vars) // wrap + 1\n        assert_gridspec_shape(p._figure.axes[0], n_row, n_col)\n        assert len(p._figure.axes) == len(y_vars)\n        label_array = np.empty(n_row * n_col, object)\n        label_array[:len(y_vars)] = y_vars\n        label_array = label_array.reshape((n_row, n_col), order=\"F\")\n        label_array = [y for y in label_array.flat if y is not None]\n        for i, ax in enumerate(p._figure.axes):\n            label = ax.yaxis.get_label()\n            assert label.get_visible()\n            assert label.get_text() == label_array[i]\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_y_wrapping", "self", "long_df", "y_vars", "f", "x", "y", "z", "wrap", "3", "p", "plot", "long_df", "x", "x", "pair", "y", "y_vars", "wrap", "wrap", "plot", "n_row", "n_col", "wrap", "len", "y_vars", "wrap", "1", "assert_gridspec_shape", "p", "_figure", "axes", "0", "n_row", "n_col", "assert", "len", "p", "_figure", "axes", "len", "y_vars", "label_array", "np", "empty", "n_row", "n_col", "object", "label_array", "len", "y_vars", "y_vars", "label_array", "label_array", "reshape", "n_row", "n_col", "order", "f", "label_array", "y", "for", "y", "in", "label_array", "flat", "if", "y", "is", "not", "none", "for", "i", "ax", "in", "enumerate", "p", "_figure", "axes", "label", "ax", "yaxis", "get_label", "assert", "label", "get_visible", "assert", "label", "get_text", "label_array", "i"], "doc_len": 97}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_non_cross_wrapping", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_non_cross_wrapping", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_non_cross_wrapping(self, long_df):\n\n        x_vars = [\"a\", \"b\", \"c\", \"t\"]\n        y_vars = [\"f\", \"x\", \"y\", \"z\"]\n        wrap = 3\n\n        p = (\n            Plot(long_df, x=\"x\")\n            .pair(x=x_vars, y=y_vars, wrap=wrap, cross=False)\n            .plot()\n        )\n\n        assert_gridspec_shape(p._figure.axes[0], len(x_vars) // wrap + 1, wrap)\n        assert len(p._figure.axes) == len(x_vars)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_non_cross_wrapping", "self", "long_df", "x_vars", "a", "b", "c", "t", "y_vars", "f", "x", "y", "z", "wrap", "3", "p", "plot", "long_df", "x", "x", "pair", "x", "x_vars", "y", "y_vars", "wrap", "wrap", "cross", "false", "plot", "assert_gridspec_shape", "p", "_figure", "axes", "0", "len", "x_vars", "wrap", "1", "wrap", "assert", "len", "p", "_figure", "axes", "len", "x_vars"], "doc_len": 53}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_cross_mismatched_lengths", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_cross_mismatched_lengths", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_cross_mismatched_lengths(self, long_df):\n\n        p = Plot(long_df)\n        with pytest.raises(ValueError, match=\"Lengths of the `x` and `y`\"):\n            p.pair(x=[\"a\", \"b\"], y=[\"x\", \"y\", \"z\"], cross=False)\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_cross_mismatched_lengths", "self", "long_df", "p", "plot", "long_df", "with", "pytest", "raises", "valueerror", "match", "lengths", "of", "the", "x", "and", "y", "p", "pair", "x", "a", "b", "y", "x", "y", "z", "cross", "false"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_orient_inference", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_orient_inference", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_orient_inference(self, long_df):\n\n        orient_list = []\n\n        class CaptureOrientMove(Move):\n            def __call__(self, data, groupby, orient, scales):\n                orient_list.append(orient)\n                return data\n\n        (\n            Plot(long_df, x=\"x\")\n            .pair(y=[\"b\", \"z\"])\n            .add(MockMark(), CaptureOrientMove())\n            .plot()\n        )\n\n        assert orient_list == [\"y\", \"x\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_orient_inference", "self", "long_df", "orient_list", "class", "captureorientmove", "move", "def", "__call__", "self", "data", "groupby", "orient", "scales", "orient_list", "append", "orient", "return", "data", "plot", "long_df", "x", "x", "pair", "y", "b", "z", "add", "mockmark", "captureorientmove", "plot", "assert", "orient_list", "y", "x"], "doc_len": 41}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_computed_coordinate_orient_inference", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_computed_coordinate_orient_inference", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_computed_coordinate_orient_inference(self, long_df):\n\n        class MockComputeStat(Stat):\n            def __call__(self, df, groupby, orient, scales):\n                other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n                return df.assign(**{other: df[orient] * 2})\n\n        m = MockMark()\n        Plot(long_df, y=\"y\").add(m, MockComputeStat()).plot()\n        assert m.passed_orient == \"y\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_computed_coordinate_orient_inference", "self", "long_df", "class", "mockcomputestat", "stat", "def", "__call__", "self", "df", "groupby", "orient", "scales", "other", "x", "y", "y", "x", "orient", "return", "df", "assign", "other", "df", "orient", "2", "m", "mockmark", "plot", "long_df", "y", "y", "add", "m", "mockcomputestat", "plot", "assert", "m", "passed_orient", "y"], "doc_len": 46}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_two_variables_single_order_error", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_two_variables_single_order_error", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_two_variables_single_order_error(self, long_df):\n\n        p = Plot(long_df)\n        err = \"When faceting on both col= and row=, passing `order`\"\n        with pytest.raises(RuntimeError, match=err):\n            p.facet(col=\"a\", row=\"b\", order=[\"a\", \"b\", \"c\"])\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_two_variables_single_order_error", "self", "long_df", "p", "plot", "long_df", "err", "when", "faceting", "on", "both", "col", "and", "row", "passing", "order", "with", "pytest", "raises", "runtimeerror", "match", "err", "p", "facet", "col", "a", "row", "b", "order", "a", "b", "c"], "doc_len": 38}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_limits", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_limits", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_limits(self, long_df):\n\n        limit = (-2, 24)\n        p = Plot(long_df, y=\"y\").pair(x=[\"x\", \"z\"]).limit(x1=limit).plot()\n        ax1 = p._figure.axes[1]\n        assert ax1.get_xlim() == limit\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_limits", "self", "long_df", "limit", "2", "24", "p", "plot", "long_df", "y", "y", "pair", "x", "x", "z", "limit", "x1", "limit", "plot", "ax1", "p", "_figure", "axes", "1", "assert", "ax1", "get_xlim", "limit"], "doc_len": 34}
{"doc_id": "tests/_core/test_plot.py::TestPairInterface.test_labels", "file_path": "tests/_core/test_plot.py", "class_name": "TestPairInterface", "func_name": "test_labels", "text": "文件路径: tests/_core/test_plot.py, 类名: TestPairInterface\n    def test_labels(self, long_df):\n\n        label = \"Z\"\n        p = Plot(long_df, y=\"y\").pair(x=[\"x\", \"z\"]).label(x1=label).plot()\n        ax1 = p._figure.axes[1]\n        assert ax1.get_xlabel() == label\n", "tokens": ["tests", "_core", "test_plot", "py", "testpairinterface", "def", "test_labels", "self", "long_df", "label", "z", "p", "plot", "long_df", "y", "y", "pair", "x", "x", "z", "label", "x1", "label", "plot", "ax1", "p", "_figure", "axes", "1", "assert", "ax1", "get_xlabel", "label"], "doc_len": 33}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_single_subplot", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_single_subplot", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_single_subplot(self, long_df):\n\n        x, y = \"a\", \"z\"\n        p = Plot(long_df, x=x, y=y).plot()\n        subplot, *_ = p._subplots\n        ax = subplot[\"ax\"]\n        assert ax.xaxis.get_label().get_visible()\n        assert ax.yaxis.get_label().get_visible()\n        assert all(t.get_visible() for t in ax.get_xticklabels())\n        assert all(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_single_subplot", "self", "long_df", "x", "y", "a", "z", "p", "plot", "long_df", "x", "x", "y", "y", "plot", "subplot", "_", "p", "_subplots", "ax", "subplot", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 56}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_1d_column", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_1d_column", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_1d_column(self, long_df, facet_kws, pair_kws):\n\n        x = None if \"x\" in pair_kws else \"a\"\n        y = \"z\"\n        p = Plot(long_df, x=x, y=y).plot()\n        first, *other = p._subplots\n\n        ax = first[\"ax\"]\n        assert ax.xaxis.get_label().get_visible()\n        assert ax.yaxis.get_label().get_visible()\n        assert all(t.get_visible() for t in ax.get_xticklabels())\n        assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in other:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert not ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n            assert not any(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_1d_column", "self", "long_df", "facet_kws", "pair_kws", "x", "none", "if", "x", "in", "pair_kws", "else", "a", "y", "z", "p", "plot", "long_df", "x", "x", "y", "y", "plot", "first", "other", "p", "_subplots", "ax", "first", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "other", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "not", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 101}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_1d_row", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_1d_row", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_1d_row(self, long_df, facet_kws, pair_kws):\n\n        x = \"z\"\n        y = None if \"y\" in pair_kws else \"z\"\n        p = Plot(long_df, x=x, y=y).plot()\n        first, *other = p._subplots\n\n        ax = first[\"ax\"]\n        assert ax.xaxis.get_label().get_visible()\n        assert all(t.get_visible() for t in ax.get_xticklabels())\n        assert ax.yaxis.get_label().get_visible()\n        assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in other:\n            ax = s[\"ax\"]\n            assert not ax.xaxis.get_label().get_visible()\n            assert ax.yaxis.get_label().get_visible()\n            assert not any(t.get_visible() for t in ax.get_xticklabels())\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_1d_row", "self", "long_df", "facet_kws", "pair_kws", "x", "z", "y", "none", "if", "y", "in", "pair_kws", "else", "z", "p", "plot", "long_df", "x", "x", "y", "y", "plot", "first", "other", "p", "_subplots", "ax", "first", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "other", "ax", "s", "ax", "assert", "not", "ax", "xaxis", "get_label", "get_visible", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 101}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_1d_column_wrapped", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_1d_column_wrapped", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_1d_column_wrapped(self):\n\n        p = Plot().facet(col=[\"a\", \"b\", \"c\", \"d\"], wrap=3).plot()\n        subplots = list(p._subplots)\n\n        for s in [subplots[0], subplots[-1]]:\n            ax = s[\"ax\"]\n            assert ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in subplots[1:]:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in subplots[1:-1]:\n            ax = s[\"ax\"]\n            assert not ax.yaxis.get_label().get_visible()\n            assert not any(t.get_visible() for t in ax.get_yticklabels())\n\n        ax = subplots[0][\"ax\"]\n        assert not ax.xaxis.get_label().get_visible()\n        assert not any(t.get_visible() for t in ax.get_xticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_1d_column_wrapped", "self", "p", "plot", "facet", "col", "a", "b", "c", "d", "wrap", "3", "plot", "subplots", "list", "p", "_subplots", "for", "s", "in", "subplots", "0", "subplots", "1", "ax", "s", "ax", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "subplots", "1", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "1", "1", "ax", "s", "ax", "assert", "not", "ax", "yaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "ax", "subplots", "0", "ax", "assert", "not", "ax", "xaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels"], "doc_len": 114}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_1d_row_wrapped", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_1d_row_wrapped", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_1d_row_wrapped(self):\n\n        p = Plot().facet(row=[\"a\", \"b\", \"c\", \"d\"], wrap=3).plot()\n        subplots = list(p._subplots)\n\n        for s in subplots[:-1]:\n            ax = s[\"ax\"]\n            assert ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in subplots[-2:]:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in subplots[:-2]:\n            ax = s[\"ax\"]\n            assert not ax.xaxis.get_label().get_visible()\n            assert not any(t.get_visible() for t in ax.get_xticklabels())\n\n        ax = subplots[-1][\"ax\"]\n        assert not ax.yaxis.get_label().get_visible()\n        assert not any(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_1d_row_wrapped", "self", "p", "plot", "facet", "row", "a", "b", "c", "d", "wrap", "3", "plot", "subplots", "list", "p", "_subplots", "for", "s", "in", "subplots", "1", "ax", "s", "ax", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "not", "ax", "xaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "ax", "subplots", "1", "ax", "assert", "not", "ax", "yaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 111}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_1d_column_wrapped_non_cross", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_1d_column_wrapped_non_cross", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_1d_column_wrapped_non_cross(self, long_df):\n\n        p = (\n            Plot(long_df)\n            .pair(x=[\"a\", \"b\", \"c\"], y=[\"x\", \"y\", \"z\"], wrap=2, cross=False)\n            .plot()\n        )\n        for s in p._subplots:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n            assert ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_1d_column_wrapped_non_cross", "self", "long_df", "p", "plot", "long_df", "pair", "x", "a", "b", "c", "y", "x", "y", "z", "wrap", "2", "cross", "false", "plot", "for", "s", "in", "p", "_subplots", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 62}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_2d", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_2d", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_2d(self):\n\n        p = Plot().facet(col=[\"a\", \"b\"], row=[\"x\", \"y\"]).plot()\n        subplots = list(p._subplots)\n\n        for s in subplots[:2]:\n            ax = s[\"ax\"]\n            assert not ax.xaxis.get_label().get_visible()\n            assert not any(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in subplots[2:]:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in [subplots[0], subplots[2]]:\n            ax = s[\"ax\"]\n            assert ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in [subplots[1], subplots[3]]:\n            ax = s[\"ax\"]\n            assert not ax.yaxis.get_label().get_visible()\n            assert not any(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_2d", "self", "p", "plot", "facet", "col", "a", "b", "row", "x", "y", "plot", "subplots", "list", "p", "_subplots", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "not", "ax", "xaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "0", "subplots", "2", "ax", "s", "ax", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "subplots", "1", "subplots", "3", "ax", "s", "ax", "assert", "not", "ax", "yaxis", "get_label", "get_visible", "assert", "not", "any", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 118}
{"doc_id": "tests/_core/test_plot.py::TestLabelVisibility.test_2d_unshared", "file_path": "tests/_core/test_plot.py", "class_name": "TestLabelVisibility", "func_name": "test_2d_unshared", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLabelVisibility\n    def test_2d_unshared(self):\n\n        p = (\n            Plot()\n            .facet(col=[\"a\", \"b\"], row=[\"x\", \"y\"])\n            .share(x=False, y=False)\n            .plot()\n        )\n        subplots = list(p._subplots)\n\n        for s in subplots[:2]:\n            ax = s[\"ax\"]\n            assert not ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in subplots[2:]:\n            ax = s[\"ax\"]\n            assert ax.xaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_xticklabels())\n\n        for s in [subplots[0], subplots[2]]:\n            ax = s[\"ax\"]\n            assert ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n\n        for s in [subplots[1], subplots[3]]:\n            ax = s[\"ax\"]\n            assert not ax.yaxis.get_label().get_visible()\n            assert all(t.get_visible() for t in ax.get_yticklabels())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlabelvisibility", "def", "test_2d_unshared", "self", "p", "plot", "facet", "col", "a", "b", "row", "x", "y", "share", "x", "false", "y", "false", "plot", "subplots", "list", "p", "_subplots", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "not", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "2", "ax", "s", "ax", "assert", "ax", "xaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_xticklabels", "for", "s", "in", "subplots", "0", "subplots", "2", "ax", "s", "ax", "assert", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels", "for", "s", "in", "subplots", "1", "subplots", "3", "ax", "s", "ax", "assert", "not", "ax", "yaxis", "get_label", "get_visible", "assert", "all", "t", "get_visible", "for", "t", "in", "ax", "get_yticklabels"], "doc_len": 121}
{"doc_id": "tests/_core/test_plot.py::TestLegend.xy", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "xy", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def xy(self):\n        return dict(x=[1, 2, 3, 4], y=[1, 2, 3, 4])\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "xy", "self", "return", "dict", "x", "1", "2", "3", "4", "y", "1", "2", "3", "4"], "doc_len": 20}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_single_layer_single_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_single_layer_single_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_single_layer_single_variable(self, xy):\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        p = Plot(**xy).add(MockMark(), color=s).plot()\n        e, = p._legend_contents\n\n        labels = categorical_order(s)\n\n        assert e[0] == (s.name, s.name)\n        assert e[-1] == labels\n\n        artists = e[1]\n        assert len(artists) == len(labels)\n        for a, label in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert a.value == label\n            assert a.variables == [\"color\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_single_layer_single_variable", "self", "xy", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "p", "plot", "xy", "add", "mockmark", "color", "s", "plot", "e", "p", "_legend_contents", "labels", "categorical_order", "s", "assert", "e", "0", "s", "name", "s", "name", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "color"], "doc_len": 72}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_single_layer_common_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_single_layer_common_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_single_layer_common_variable(self, xy):\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        sem = dict(color=s, marker=s)\n        p = Plot(**xy).add(MockMark(), **sem).plot()\n        e, = p._legend_contents\n\n        labels = categorical_order(s)\n\n        assert e[0] == (s.name, s.name)\n        assert e[-1] == labels\n\n        artists = e[1]\n        assert len(artists) == len(labels)\n        for a, label in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert a.value == label\n            assert a.variables == list(sem)\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_single_layer_common_variable", "self", "xy", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "sem", "dict", "color", "s", "marker", "s", "p", "plot", "xy", "add", "mockmark", "sem", "plot", "e", "p", "_legend_contents", "labels", "categorical_order", "s", "assert", "e", "0", "s", "name", "s", "name", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "list", "sem"], "doc_len": 78}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_single_layer_common_unnamed_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_single_layer_common_unnamed_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_single_layer_common_unnamed_variable(self, xy):\n\n        s = np.array([\"a\", \"b\", \"a\", \"c\"])\n        sem = dict(color=s, marker=s)\n        p = Plot(**xy).add(MockMark(), **sem).plot()\n\n        e, = p._legend_contents\n\n        labels = list(np.unique(s))  # assumes sorted order\n\n        assert e[0] == (\"\", id(s))\n        assert e[-1] == labels\n\n        artists = e[1]\n        assert len(artists) == len(labels)\n        for a, label in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert a.value == label\n            assert a.variables == list(sem)\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_single_layer_common_unnamed_variable", "self", "xy", "s", "np", "array", "a", "b", "a", "c", "sem", "dict", "color", "s", "marker", "s", "p", "plot", "xy", "add", "mockmark", "sem", "plot", "e", "p", "_legend_contents", "labels", "list", "np", "unique", "s", "assumes", "sorted", "order", "assert", "e", "0", "id", "s", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "list", "sem"], "doc_len": 79}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_single_layer_multi_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_single_layer_multi_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_single_layer_multi_variable(self, xy):\n\n        s1 = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s1\")\n        s2 = pd.Series([\"m\", \"m\", \"p\", \"m\"], name=\"s2\")\n        sem = dict(color=s1, marker=s2)\n        p = Plot(**xy).add(MockMark(), **sem).plot()\n        e1, e2 = p._legend_contents\n\n        variables = {v.name: k for k, v in sem.items()}\n\n        for e, s in zip([e1, e2], [s1, s2]):\n            assert e[0] == (s.name, s.name)\n\n            labels = categorical_order(s)\n            assert e[-1] == labels\n\n            artists = e[1]\n            assert len(artists) == len(labels)\n            for a, label in zip(artists, labels):\n                assert isinstance(a, mpl.artist.Artist)\n                assert a.value == label\n                assert a.variables == [variables[s.name]]\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_single_layer_multi_variable", "self", "xy", "s1", "pd", "series", "a", "b", "a", "c", "name", "s1", "s2", "pd", "series", "m", "m", "p", "m", "name", "s2", "sem", "dict", "color", "s1", "marker", "s2", "p", "plot", "xy", "add", "mockmark", "sem", "plot", "e1", "e2", "p", "_legend_contents", "variables", "v", "name", "k", "for", "k", "v", "in", "sem", "items", "for", "e", "s", "in", "zip", "e1", "e2", "s1", "s2", "assert", "e", "0", "s", "name", "s", "name", "labels", "categorical_order", "s", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "variables", "s", "name"], "doc_len": 108}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_multi_layer_single_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_multi_layer_single_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_multi_layer_single_variable(self, xy):\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n        e1, e2 = p._legend_contents\n\n        labels = categorical_order(s)\n\n        for e in [e1, e2]:\n            assert e[0] == (s.name, s.name)\n\n            labels = categorical_order(s)\n            assert e[-1] == labels\n\n            artists = e[1]\n            assert len(artists) == len(labels)\n            for a, label in zip(artists, labels):\n                assert isinstance(a, mpl.artist.Artist)\n                assert a.value == label\n                assert a.variables == [\"color\"]\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_multi_layer_single_variable", "self", "xy", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "p", "plot", "xy", "color", "s", "add", "mockmark", "add", "mockmark", "plot", "e1", "e2", "p", "_legend_contents", "labels", "categorical_order", "s", "for", "e", "in", "e1", "e2", "assert", "e", "0", "s", "name", "s", "name", "labels", "categorical_order", "s", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "color"], "doc_len": 83}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_multi_layer_multi_variable", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_multi_layer_multi_variable", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_multi_layer_multi_variable(self, xy):\n\n        s1 = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s1\")\n        s2 = pd.Series([\"m\", \"m\", \"p\", \"m\"], name=\"s2\")\n        sem = dict(color=s1), dict(marker=s2)\n        variables = {\"s1\": \"color\", \"s2\": \"marker\"}\n        p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n        e1, e2 = p._legend_contents\n\n        for e, s in zip([e1, e2], [s1, s2]):\n            assert e[0] == (s.name, s.name)\n\n            labels = categorical_order(s)\n            assert e[-1] == labels\n\n            artists = e[1]\n            assert len(artists) == len(labels)\n            for a, label in zip(artists, labels):\n                assert isinstance(a, mpl.artist.Artist)\n                assert a.value == label\n                assert a.variables == [variables[s.name]]\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_multi_layer_multi_variable", "self", "xy", "s1", "pd", "series", "a", "b", "a", "c", "name", "s1", "s2", "pd", "series", "m", "m", "p", "m", "name", "s2", "sem", "dict", "color", "s1", "dict", "marker", "s2", "variables", "s1", "color", "s2", "marker", "p", "plot", "xy", "add", "mockmark", "sem", "0", "add", "mockmark", "sem", "1", "plot", "e1", "e2", "p", "_legend_contents", "for", "e", "s", "in", "zip", "e1", "e2", "s1", "s2", "assert", "e", "0", "s", "name", "s", "name", "labels", "categorical_order", "s", "assert", "e", "1", "labels", "artists", "e", "1", "assert", "len", "artists", "len", "labels", "for", "a", "label", "in", "zip", "artists", "labels", "assert", "isinstance", "a", "mpl", "artist", "artist", "assert", "a", "value", "label", "assert", "a", "variables", "variables", "s", "name"], "doc_len": 109}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_multi_layer_different_artists", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_multi_layer_different_artists", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_multi_layer_different_artists(self, xy):\n\n        class MockMark1(MockMark):\n            def _legend_artist(self, variables, value, scales):\n                return mpl.lines.Line2D([], [])\n\n        class MockMark2(MockMark):\n            def _legend_artist(self, variables, value, scales):\n                return mpl.patches.Patch()\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        p = Plot(**xy, color=s).add(MockMark1()).add(MockMark2()).plot()\n\n        legend, = p._figure.legends\n\n        names = categorical_order(s)\n        labels = [t.get_text() for t in legend.get_texts()]\n        assert labels == names\n\n        if Version(mpl.__version__) >= Version(\"3.2\"):\n            contents = legend.get_children()[0]\n            assert len(contents.findobj(mpl.lines.Line2D)) == len(names)\n            assert len(contents.findobj(mpl.patches.Patch)) == len(names)\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_multi_layer_different_artists", "self", "xy", "class", "mockmark1", "mockmark", "def", "_legend_artist", "self", "variables", "value", "scales", "return", "mpl", "lines", "line2d", "class", "mockmark2", "mockmark", "def", "_legend_artist", "self", "variables", "value", "scales", "return", "mpl", "patches", "patch", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "p", "plot", "xy", "color", "s", "add", "mockmark1", "add", "mockmark2", "plot", "legend", "p", "_figure", "legends", "names", "categorical_order", "s", "labels", "t", "get_text", "for", "t", "in", "legend", "get_texts", "assert", "labels", "names", "if", "version", "mpl", "__version__", "version", "3", "2", "contents", "legend", "get_children", "0", "assert", "len", "contents", "findobj", "mpl", "lines", "line2d", "len", "names", "assert", "len", "contents", "findobj", "mpl", "patches", "patch", "len", "names"], "doc_len": 101}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_three_layers", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_three_layers", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_three_layers(self, xy):\n\n        class MockMarkLine(MockMark):\n            def _legend_artist(self, variables, value, scales):\n                return mpl.lines.Line2D([], [])\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        p = Plot(**xy, color=s)\n        for _ in range(3):\n            p = p.add(MockMarkLine())\n        p = p.plot()\n        texts = p._figure.legends[0].get_texts()\n        assert len(texts) == len(s.unique())\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_three_layers", "self", "xy", "class", "mockmarkline", "mockmark", "def", "_legend_artist", "self", "variables", "value", "scales", "return", "mpl", "lines", "line2d", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "p", "plot", "xy", "color", "s", "for", "_", "in", "range", "3", "p", "p", "add", "mockmarkline", "p", "p", "plot", "texts", "p", "_figure", "legends", "0", "get_texts", "assert", "len", "texts", "len", "s", "unique"], "doc_len": 60}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_identity_scale_ignored", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_identity_scale_ignored", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_identity_scale_ignored(self, xy):\n\n        s = pd.Series([\"r\", \"g\", \"b\", \"g\"])\n        p = Plot(**xy).add(MockMark(), color=s).scale(color=None).plot()\n        assert not p._legend_contents\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_identity_scale_ignored", "self", "xy", "s", "pd", "series", "r", "g", "b", "g", "p", "plot", "xy", "add", "mockmark", "color", "s", "scale", "color", "none", "plot", "assert", "not", "p", "_legend_contents"], "doc_len": 31}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_suppression_in_add_method", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_suppression_in_add_method", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_suppression_in_add_method(self, xy):\n\n        s = pd.Series([\"a\", \"b\", \"a\", \"c\"], name=\"s\")\n        p = Plot(**xy).add(MockMark(), color=s, legend=False).plot()\n        assert not p._legend_contents\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_suppression_in_add_method", "self", "xy", "s", "pd", "series", "a", "b", "a", "c", "name", "s", "p", "plot", "xy", "add", "mockmark", "color", "s", "legend", "false", "plot", "assert", "not", "p", "_legend_contents"], "doc_len": 32}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_anonymous_title", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_anonymous_title", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_anonymous_title(self, xy):\n\n        p = Plot(**xy, color=[\"a\", \"b\", \"c\", \"d\"]).add(MockMark()).plot()\n        legend, = p._figure.legends\n        assert legend.get_title().get_text() == \"\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_anonymous_title", "self", "xy", "p", "plot", "xy", "color", "a", "b", "c", "d", "add", "mockmark", "plot", "legend", "p", "_figure", "legends", "assert", "legend", "get_title", "get_text"], "doc_len": 28}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_legendless_mark", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_legendless_mark", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_legendless_mark(self, xy):\n\n        class NoLegendMark(MockMark):\n            def _legend_artist(self, variables, value, scales):\n                return None\n\n        p = Plot(**xy, color=[\"a\", \"b\", \"c\", \"d\"]).add(NoLegendMark()).plot()\n        assert not p._figure.legends\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_legendless_mark", "self", "xy", "class", "nolegendmark", "mockmark", "def", "_legend_artist", "self", "variables", "value", "scales", "return", "none", "p", "plot", "xy", "color", "a", "b", "c", "d", "add", "nolegendmark", "plot", "assert", "not", "p", "_figure", "legends"], "doc_len": 36}
{"doc_id": "tests/_core/test_plot.py::TestLegend.test_legend_has_no_offset", "file_path": "tests/_core/test_plot.py", "class_name": "TestLegend", "func_name": "test_legend_has_no_offset", "text": "文件路径: tests/_core/test_plot.py, 类名: TestLegend\n    def test_legend_has_no_offset(self, xy):\n\n        color = np.add(xy[\"x\"], 1e8)\n        p = Plot(**xy, color=color).add(MockMark()).plot()\n        legend = p._figure.legends[0]\n        assert legend.texts\n        for text in legend.texts:\n            assert float(text.get_text()) > 1e7\n", "tokens": ["tests", "_core", "test_plot", "py", "testlegend", "def", "test_legend_has_no_offset", "self", "xy", "color", "np", "add", "xy", "x", "1e8", "p", "plot", "xy", "color", "color", "add", "mockmark", "plot", "legend", "p", "_figure", "legends", "0", "assert", "legend", "texts", "for", "text", "in", "legend", "texts", "assert", "float", "text", "get_text", "1e7"], "doc_len": 41}
{"doc_id": "tests/_core/test_plot.py::TestDefaultObject.test_default_repr", "file_path": "tests/_core/test_plot.py", "class_name": "TestDefaultObject", "func_name": "test_default_repr", "text": "文件路径: tests/_core/test_plot.py, 类名: TestDefaultObject\n    def test_default_repr(self):\n\n        assert repr(Default()) == \"<default>\"\n", "tokens": ["tests", "_core", "test_plot", "py", "testdefaultobject", "def", "test_default_repr", "self", "assert", "repr", "default", "default"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.num_vector", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "num_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def num_vector(self, long_df):\n        return long_df[\"s\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "num_vector", "self", "long_df", "return", "long_df", "s"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.num_order", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "num_order", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def num_order(self, num_vector):\n        return categorical_order(num_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "num_order", "self", "num_vector", "return", "categorical_order", "num_vector"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.cat_vector", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "cat_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def cat_vector(self, long_df):\n        return long_df[\"a\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "cat_vector", "self", "long_df", "return", "long_df", "a"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.cat_order", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "cat_order", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def cat_order(self, cat_vector):\n        return categorical_order(cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "cat_order", "self", "cat_vector", "return", "categorical_order", "cat_vector"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.dt_num_vector", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "dt_num_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def dt_num_vector(self, long_df):\n        return long_df[\"t\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "dt_num_vector", "self", "long_df", "return", "long_df", "t"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.dt_cat_vector", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "dt_cat_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def dt_cat_vector(self, long_df):\n        return long_df[\"d\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "dt_cat_vector", "self", "long_df", "return", "long_df", "d"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::DataFixtures.vectors", "file_path": "tests/_core/test_properties.py", "class_name": "DataFixtures", "func_name": "vectors", "text": "文件路径: tests/_core/test_properties.py, 类名: DataFixtures\n    def vectors(self, num_vector, cat_vector):\n        return {\"num\": num_vector, \"cat\": cat_vector}\n", "tokens": ["tests", "_core", "test_properties", "py", "datafixtures", "def", "vectors", "self", "num_vector", "cat_vector", "return", "num", "num_vector", "cat", "cat_vector"], "doc_len": 15}
{"doc_id": "tests/_core/test_properties.py::TestCoordinate.test_bad_scale_arg_str", "file_path": "tests/_core/test_properties.py", "class_name": "TestCoordinate", "func_name": "test_bad_scale_arg_str", "text": "文件路径: tests/_core/test_properties.py, 类名: TestCoordinate\n    def test_bad_scale_arg_str(self, num_vector):\n\n        err = \"Unknown magic arg for x scale: 'xxx'.\"\n        with pytest.raises(ValueError, match=err):\n            Coordinate(\"x\").infer_scale(\"xxx\", num_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcoordinate", "def", "test_bad_scale_arg_str", "self", "num_vector", "err", "unknown", "magic", "arg", "for", "x", "scale", "xxx", "with", "pytest", "raises", "valueerror", "match", "err", "coordinate", "x", "infer_scale", "xxx", "num_vector"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestCoordinate.test_bad_scale_arg_type", "file_path": "tests/_core/test_properties.py", "class_name": "TestCoordinate", "func_name": "test_bad_scale_arg_type", "text": "文件路径: tests/_core/test_properties.py, 类名: TestCoordinate\n    def test_bad_scale_arg_type(self, cat_vector):\n\n        err = \"Magic arg for x scale must be str, not list.\"\n        with pytest.raises(TypeError, match=err):\n            Coordinate(\"x\").infer_scale([1, 2, 3], cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcoordinate", "def", "test_bad_scale_arg_type", "self", "cat_vector", "err", "magic", "arg", "for", "x", "scale", "must", "be", "str", "not", "list", "with", "pytest", "raises", "typeerror", "match", "err", "coordinate", "x", "infer_scale", "1", "2", "3", "cat_vector"], "doc_len": 33}
{"doc_id": "tests/_core/test_properties.py::TestColor.assert_same_rgb", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "assert_same_rgb", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def assert_same_rgb(self, a, b):\n        assert_array_equal(a[:, :3], b[:, :3])\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "assert_same_rgb", "self", "a", "b", "assert_array_equal", "a", "3", "b", "3"], "doc_len": 15}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_default_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_default_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_default_palette(self, cat_vector, cat_order):\n\n        m = Color().get_mapping(Nominal(), cat_vector)\n        n = len(cat_order)\n        actual = m(np.arange(n))\n        expected = color_palette(None, n)\n        for have, want in zip(actual, expected):\n            assert same_color(have, want)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_default_palette", "self", "cat_vector", "cat_order", "m", "color", "get_mapping", "nominal", "cat_vector", "n", "len", "cat_order", "actual", "m", "np", "arange", "n", "expected", "color_palette", "none", "n", "for", "have", "want", "in", "zip", "actual", "expected", "assert", "same_color", "have", "want"], "doc_len": 38}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_default_palette_large", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_default_palette_large", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_default_palette_large(self):\n\n        vector = pd.Series(list(\"abcdefghijklmnopqrstuvwxyz\"))\n        m = Color().get_mapping(Nominal(), vector)\n        actual = m(np.arange(26))\n        expected = color_palette(\"husl\", 26)\n        for have, want in zip(actual, expected):\n            assert same_color(have, want)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_default_palette_large", "self", "vector", "pd", "series", "list", "abcdefghijklmnopqrstuvwxyz", "m", "color", "get_mapping", "nominal", "vector", "actual", "m", "np", "arange", "26", "expected", "color_palette", "husl", "26", "for", "have", "want", "in", "zip", "actual", "expected", "assert", "same_color", "have", "want"], "doc_len": 38}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_named_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_named_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_named_palette(self, cat_vector, cat_order):\n\n        palette = \"Blues\"\n        m = Color().get_mapping(Nominal(palette), cat_vector)\n        n = len(cat_order)\n        actual = m(np.arange(n))\n        expected = color_palette(palette, n)\n        for have, want in zip(actual, expected):\n            assert same_color(have, want)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_named_palette", "self", "cat_vector", "cat_order", "palette", "blues", "m", "color", "get_mapping", "nominal", "palette", "cat_vector", "n", "len", "cat_order", "actual", "m", "np", "arange", "n", "expected", "color_palette", "palette", "n", "for", "have", "want", "in", "zip", "actual", "expected", "assert", "same_color", "have", "want"], "doc_len": 41}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_list_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_list_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_list_palette(self, cat_vector, cat_order):\n\n        palette = color_palette(\"Reds\", len(cat_order))\n        m = Color().get_mapping(Nominal(palette), cat_vector)\n        actual = m(np.arange(len(palette)))\n        expected = palette\n        for have, want in zip(actual, expected):\n            assert same_color(have, want)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_list_palette", "self", "cat_vector", "cat_order", "palette", "color_palette", "reds", "len", "cat_order", "m", "color", "get_mapping", "nominal", "palette", "cat_vector", "actual", "m", "np", "arange", "len", "palette", "expected", "palette", "for", "have", "want", "in", "zip", "actual", "expected", "assert", "same_color", "have", "want"], "doc_len": 40}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_dict_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_dict_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_dict_palette(self, cat_vector, cat_order):\n\n        colors = color_palette(\"Greens\")\n        palette = dict(zip(cat_order, colors))\n        m = Color().get_mapping(Nominal(palette), cat_vector)\n        n = len(cat_order)\n        actual = m(np.arange(n))\n        expected = colors\n        for have, want in zip(actual, expected):\n            assert same_color(have, want)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_dict_palette", "self", "cat_vector", "cat_order", "colors", "color_palette", "greens", "palette", "dict", "zip", "cat_order", "colors", "m", "color", "get_mapping", "nominal", "palette", "cat_vector", "n", "len", "cat_order", "actual", "m", "np", "arange", "n", "expected", "colors", "for", "have", "want", "in", "zip", "actual", "expected", "assert", "same_color", "have", "want"], "doc_len": 45}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_dict_with_missing_keys", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_dict_with_missing_keys", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_dict_with_missing_keys(self, cat_vector, cat_order):\n\n        palette = dict(zip(cat_order[1:], color_palette(\"Purples\")))\n        with pytest.raises(ValueError, match=\"No entry in color dict\"):\n            Color(\"color\").get_mapping(Nominal(palette), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_dict_with_missing_keys", "self", "cat_vector", "cat_order", "palette", "dict", "zip", "cat_order", "1", "color_palette", "purples", "with", "pytest", "raises", "valueerror", "match", "no", "entry", "in", "color", "dict", "color", "color", "get_mapping", "nominal", "palette", "cat_vector"], "doc_len": 33}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_list_too_short", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_list_too_short", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_list_too_short(self, cat_vector, cat_order):\n\n        n = len(cat_order) - 1\n        palette = color_palette(\"Oranges\", n)\n        msg = rf\"The edgecolor list has fewer values \\({n}\\) than needed \\({n + 1}\\)\"\n        with pytest.warns(UserWarning, match=msg):\n            Color(\"edgecolor\").get_mapping(Nominal(palette), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_list_too_short", "self", "cat_vector", "cat_order", "n", "len", "cat_order", "1", "palette", "color_palette", "oranges", "n", "msg", "rf", "the", "edgecolor", "list", "has", "fewer", "values", "n", "than", "needed", "n", "1", "with", "pytest", "warns", "userwarning", "match", "msg", "color", "edgecolor", "get_mapping", "nominal", "palette", "cat_vector"], "doc_len": 43}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_nominal_list_too_long", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_nominal_list_too_long", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_nominal_list_too_long(self, cat_vector, cat_order):\n\n        n = len(cat_order) + 1\n        palette = color_palette(\"Oranges\", n)\n        msg = rf\"The edgecolor list has more values \\({n}\\) than needed \\({n - 1}\\)\"\n        with pytest.warns(UserWarning, match=msg):\n            Color(\"edgecolor\").get_mapping(Nominal(palette), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_nominal_list_too_long", "self", "cat_vector", "cat_order", "n", "len", "cat_order", "1", "palette", "color_palette", "oranges", "n", "msg", "rf", "the", "edgecolor", "list", "has", "more", "values", "n", "than", "needed", "n", "1", "with", "pytest", "warns", "userwarning", "match", "msg", "color", "edgecolor", "get_mapping", "nominal", "palette", "cat_vector"], "doc_len": 43}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_continuous_default_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_continuous_default_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_continuous_default_palette(self, num_vector):\n\n        cmap = color_palette(\"ch:\", as_cmap=True)\n        m = Color().get_mapping(Continuous(), num_vector)\n        self.assert_same_rgb(m(num_vector), cmap(num_vector))\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_continuous_default_palette", "self", "num_vector", "cmap", "color_palette", "ch", "as_cmap", "true", "m", "color", "get_mapping", "continuous", "num_vector", "self", "assert_same_rgb", "m", "num_vector", "cmap", "num_vector"], "doc_len": 25}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_continuous_named_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_continuous_named_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_continuous_named_palette(self, num_vector):\n\n        pal = \"flare\"\n        cmap = color_palette(pal, as_cmap=True)\n        m = Color().get_mapping(Continuous(pal), num_vector)\n        self.assert_same_rgb(m(num_vector), cmap(num_vector))\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_continuous_named_palette", "self", "num_vector", "pal", "flare", "cmap", "color_palette", "pal", "as_cmap", "true", "m", "color", "get_mapping", "continuous", "pal", "num_vector", "self", "assert_same_rgb", "m", "num_vector", "cmap", "num_vector"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_continuous_tuple_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_continuous_tuple_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_continuous_tuple_palette(self, num_vector):\n\n        vals = (\"blue\", \"red\")\n        cmap = color_palette(\"blend:\" + \",\".join(vals), as_cmap=True)\n        m = Color().get_mapping(Continuous(vals), num_vector)\n        self.assert_same_rgb(m(num_vector), cmap(num_vector))\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_continuous_tuple_palette", "self", "num_vector", "vals", "blue", "red", "cmap", "color_palette", "blend", "join", "vals", "as_cmap", "true", "m", "color", "get_mapping", "continuous", "vals", "num_vector", "self", "assert_same_rgb", "m", "num_vector", "cmap", "num_vector"], "doc_len": 31}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_continuous_callable_palette", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_continuous_callable_palette", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_continuous_callable_palette(self, num_vector):\n\n        cmap = get_colormap(\"viridis\")\n        m = Color().get_mapping(Continuous(cmap), num_vector)\n        self.assert_same_rgb(m(num_vector), cmap(num_vector))\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_continuous_callable_palette", "self", "num_vector", "cmap", "get_colormap", "viridis", "m", "color", "get_mapping", "continuous", "cmap", "num_vector", "self", "assert_same_rgb", "m", "num_vector", "cmap", "num_vector"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_continuous_missing", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_continuous_missing", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_continuous_missing(self):\n\n        x = pd.Series([1, 2, np.nan, 4])\n        m = Color().get_mapping(Continuous(), x)\n        assert np.isnan(m(x)[2]).all()\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_continuous_missing", "self", "x", "pd", "series", "1", "2", "np", "nan", "4", "m", "color", "get_mapping", "continuous", "x", "assert", "np", "isnan", "m", "x", "2", "all"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_bad_scale_values_continuous", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_bad_scale_values_continuous", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_bad_scale_values_continuous(self, num_vector):\n\n        with pytest.raises(TypeError, match=\"Scale values for color with a Continuous\"):\n            Color().get_mapping(Continuous([\"r\", \"g\", \"b\"]), num_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_bad_scale_values_continuous", "self", "num_vector", "with", "pytest", "raises", "typeerror", "match", "scale", "values", "for", "color", "with", "a", "continuous", "color", "get_mapping", "continuous", "r", "g", "b", "num_vector"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_bad_scale_values_nominal", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_bad_scale_values_nominal", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_bad_scale_values_nominal(self, cat_vector):\n\n        with pytest.raises(TypeError, match=\"Scale values for color with a Nominal\"):\n            Color().get_mapping(Nominal(get_colormap(\"viridis\")), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_bad_scale_values_nominal", "self", "cat_vector", "with", "pytest", "raises", "typeerror", "match", "scale", "values", "for", "color", "with", "a", "nominal", "color", "get_mapping", "nominal", "get_colormap", "viridis", "cat_vector"], "doc_len": 27}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_bad_inference_arg", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_bad_inference_arg", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_bad_inference_arg(self, cat_vector):\n\n        with pytest.raises(TypeError, match=\"A single scale argument for color\"):\n            Color().infer_scale(123, cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_bad_inference_arg", "self", "cat_vector", "with", "pytest", "raises", "typeerror", "match", "a", "single", "scale", "argument", "for", "color", "color", "infer_scale", "123", "cat_vector"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_default", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_default", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_default(self, data_type, scale_class, vectors):\n\n        scale = Color().default_scale(vectors[data_type])\n        assert isinstance(scale, scale_class)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_default", "self", "data_type", "scale_class", "vectors", "scale", "color", "default_scale", "vectors", "data_type", "assert", "isinstance", "scale", "scale_class"], "doc_len": 20}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_default_numeric_data_category_dtype", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_default_numeric_data_category_dtype", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_default_numeric_data_category_dtype(self, num_vector):\n\n        scale = Color().default_scale(num_vector.astype(\"category\"))\n        assert isinstance(scale, Nominal)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_default_numeric_data_category_dtype", "self", "num_vector", "scale", "color", "default_scale", "num_vector", "astype", "category", "assert", "isinstance", "scale", "nominal"], "doc_len": 19}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_default_binary_data", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_default_binary_data", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_default_binary_data(self):\n\n        x = pd.Series([0, 0, 1, 0, 1], dtype=int)\n        scale = Color().default_scale(x)\n        assert isinstance(scale, Continuous)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_default_binary_data", "self", "x", "pd", "series", "0", "0", "1", "0", "1", "dtype", "int", "scale", "color", "default_scale", "x", "assert", "isinstance", "scale", "continuous"], "doc_len": 26}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_inference", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_inference", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_inference(self, values, data_type, scale_class, vectors):\n\n        scale = Color().infer_scale(values, vectors[data_type])\n        assert isinstance(scale, scale_class)\n        assert scale.values == values\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_inference", "self", "values", "data_type", "scale_class", "vectors", "scale", "color", "infer_scale", "values", "vectors", "data_type", "assert", "isinstance", "scale", "scale_class", "assert", "scale", "values", "values"], "doc_len": 26}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_inference_binary_data", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_inference_binary_data", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_inference_binary_data(self):\n\n        x = pd.Series([0, 0, 1, 0, 1], dtype=int)\n        scale = Color().infer_scale(\"viridis\", x)\n        assert isinstance(scale, Nominal)\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_inference_binary_data", "self", "x", "pd", "series", "0", "0", "1", "0", "1", "dtype", "int", "scale", "color", "infer_scale", "viridis", "x", "assert", "isinstance", "scale", "nominal"], "doc_len": 27}
{"doc_id": "tests/_core/test_properties.py::TestColor.test_standardization", "file_path": "tests/_core/test_properties.py", "class_name": "TestColor", "func_name": "test_standardization", "text": "文件路径: tests/_core/test_properties.py, 类名: TestColor\n    def test_standardization(self):\n\n        f = Color().standardize\n        assert f(\"C3\") == to_rgb(\"C3\")\n        assert f(\"dodgerblue\") == to_rgb(\"dodgerblue\")\n\n        assert f((.1, .2, .3)) == (.1, .2, .3)\n        assert f((.1, .2, .3, .4)) == (.1, .2, .3, .4)\n\n        assert f(\"#123456\") == to_rgb(\"#123456\")\n        assert f(\"#12345678\") == to_rgba(\"#12345678\")\n\n        if Version(mpl.__version__) >= Version(\"3.4.0\"):\n            assert f(\"#123\") == to_rgb(\"#123\")\n            assert f(\"#1234\") == to_rgba(\"#1234\")\n", "tokens": ["tests", "_core", "test_properties", "py", "testcolor", "def", "test_standardization", "self", "f", "color", "standardize", "assert", "f", "c3", "to_rgb", "c3", "assert", "f", "dodgerblue", "to_rgb", "dodgerblue", "assert", "f", "1", "2", "3", "1", "2", "3", "assert", "f", "1", "2", "3", "4", "1", "2", "3", "4", "assert", "f", "123456", "to_rgb", "123456", "assert", "f", "12345678", "to_rgba", "12345678", "if", "version", "mpl", "__version__", "version", "3", "4", "0", "assert", "f", "123", "to_rgb", "123", "assert", "f", "1234", "to_rgba", "1234"], "doc_len": 67}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.assert_equal", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "assert_equal", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def assert_equal(self, a, b):\n\n        assert self.unpack(a) == self.unpack(b)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "assert_equal", "self", "a", "b", "assert", "self", "unpack", "a", "self", "unpack", "b"], "doc_len": 17}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.unpack", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "unpack", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def unpack(self, x):\n        return x\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "unpack", "self", "x", "return", "x"], "doc_len": 11}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_default", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_default", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_default(self, data_type, vectors):\n\n        scale = self.prop().default_scale(vectors[data_type])\n        assert isinstance(scale, Nominal)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_default", "self", "data_type", "vectors", "scale", "self", "prop", "default_scale", "vectors", "data_type", "assert", "isinstance", "scale", "nominal"], "doc_len": 20}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_inference_list", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_inference_list", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_inference_list(self, data_type, vectors):\n\n        scale = self.prop().infer_scale(self.values, vectors[data_type])\n        assert isinstance(scale, Nominal)\n        assert scale.values == self.values\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_inference_list", "self", "data_type", "vectors", "scale", "self", "prop", "infer_scale", "self", "values", "vectors", "data_type", "assert", "isinstance", "scale", "nominal", "assert", "scale", "values", "self", "values"], "doc_len": 27}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_inference_dict", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_inference_dict", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_inference_dict(self, data_type, vectors):\n\n        x = vectors[data_type]\n        values = dict(zip(categorical_order(x), self.values))\n        scale = self.prop().infer_scale(values, x)\n        assert isinstance(scale, Nominal)\n        assert scale.values == values\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_inference_dict", "self", "data_type", "vectors", "x", "vectors", "data_type", "values", "dict", "zip", "categorical_order", "x", "self", "values", "scale", "self", "prop", "infer_scale", "values", "x", "assert", "isinstance", "scale", "nominal", "assert", "scale", "values", "values"], "doc_len": 34}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_dict_missing", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_dict_missing", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_dict_missing(self, cat_vector):\n\n        levels = categorical_order(cat_vector)\n        values = dict(zip(levels, self.values[:-1]))\n        scale = Nominal(values)\n        name = self.prop.__name__.lower()\n        msg = f\"No entry in {name} dictionary for {repr(levels[-1])}\"\n        with pytest.raises(ValueError, match=msg):\n            self.prop().get_mapping(scale, cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_dict_missing", "self", "cat_vector", "levels", "categorical_order", "cat_vector", "values", "dict", "zip", "levels", "self", "values", "1", "scale", "nominal", "values", "name", "self", "prop", "__name__", "lower", "msg", "f", "no", "entry", "in", "name", "dictionary", "for", "repr", "levels", "1", "with", "pytest", "raises", "valueerror", "match", "msg", "self", "prop", "get_mapping", "scale", "cat_vector"], "doc_len": 49}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_mapping_default", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_mapping_default", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_mapping_default(self, data_type, vectors):\n\n        x = vectors[data_type]\n        mapping = self.prop().get_mapping(Nominal(), x)\n        n = x.nunique()\n        for i, expected in enumerate(self.prop()._default_values(n)):\n            actual, = mapping([i])\n            self.assert_equal(actual, expected)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_mapping_default", "self", "data_type", "vectors", "x", "vectors", "data_type", "mapping", "self", "prop", "get_mapping", "nominal", "x", "n", "x", "nunique", "for", "i", "expected", "in", "enumerate", "self", "prop", "_default_values", "n", "actual", "mapping", "i", "self", "assert_equal", "actual", "expected"], "doc_len": 38}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_mapping_from_list", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_mapping_from_list", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_mapping_from_list(self, data_type, vectors):\n\n        x = vectors[data_type]\n        scale = Nominal(self.values)\n        mapping = self.prop().get_mapping(scale, x)\n        for i, expected in enumerate(self.standardized_values):\n            actual, = mapping([i])\n            self.assert_equal(actual, expected)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_mapping_from_list", "self", "data_type", "vectors", "x", "vectors", "data_type", "scale", "nominal", "self", "values", "mapping", "self", "prop", "get_mapping", "scale", "x", "for", "i", "expected", "in", "enumerate", "self", "standardized_values", "actual", "mapping", "i", "self", "assert_equal", "actual", "expected"], "doc_len": 37}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_mapping_from_dict", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_mapping_from_dict", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_mapping_from_dict(self, data_type, vectors):\n\n        x = vectors[data_type]\n        levels = categorical_order(x)\n        values = dict(zip(levels, self.values[::-1]))\n        standardized_values = dict(zip(levels, self.standardized_values[::-1]))\n\n        scale = Nominal(values)\n        mapping = self.prop().get_mapping(scale, x)\n        for i, level in enumerate(levels):\n            actual, = mapping([i])\n            expected = standardized_values[level]\n            self.assert_equal(actual, expected)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_mapping_from_dict", "self", "data_type", "vectors", "x", "vectors", "data_type", "levels", "categorical_order", "x", "values", "dict", "zip", "levels", "self", "values", "1", "standardized_values", "dict", "zip", "levels", "self", "standardized_values", "1", "scale", "nominal", "values", "mapping", "self", "prop", "get_mapping", "scale", "x", "for", "i", "level", "in", "enumerate", "levels", "actual", "mapping", "i", "expected", "standardized_values", "level", "self", "assert_equal", "actual", "expected"], "doc_len": 55}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_mapping_with_null_value", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_mapping_with_null_value", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_mapping_with_null_value(self, cat_vector):\n\n        mapping = self.prop().get_mapping(Nominal(self.values), cat_vector)\n        actual = mapping(np.array([0, np.nan, 2]))\n        v0, _, v2 = self.standardized_values\n        expected = [v0, self.prop.null_value, v2]\n        for a, b in zip(actual, expected):\n            self.assert_equal(a, b)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_mapping_with_null_value", "self", "cat_vector", "mapping", "self", "prop", "get_mapping", "nominal", "self", "values", "cat_vector", "actual", "mapping", "np", "array", "0", "np", "nan", "2", "v0", "_", "v2", "self", "standardized_values", "expected", "v0", "self", "prop", "null_value", "v2", "for", "a", "b", "in", "zip", "actual", "expected", "self", "assert_equal", "a", "b"], "doc_len": 47}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_unique_default_large_n", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_unique_default_large_n", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_unique_default_large_n(self):\n\n        n = 24\n        x = pd.Series(np.arange(n))\n        mapping = self.prop().get_mapping(Nominal(), x)\n        assert len({self.unpack(x_i) for x_i in mapping(x)}) == n\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_unique_default_large_n", "self", "n", "24", "x", "pd", "series", "np", "arange", "n", "mapping", "self", "prop", "get_mapping", "nominal", "x", "assert", "len", "self", "unpack", "x_i", "for", "x_i", "in", "mapping", "x", "n"], "doc_len": 33}
{"doc_id": "tests/_core/test_properties.py::ObjectPropertyBase.test_bad_scale_values", "file_path": "tests/_core/test_properties.py", "class_name": "ObjectPropertyBase", "func_name": "test_bad_scale_values", "text": "文件路径: tests/_core/test_properties.py, 类名: ObjectPropertyBase\n    def test_bad_scale_values(self, cat_vector):\n\n        var_name = self.prop.__name__.lower()\n        with pytest.raises(TypeError, match=f\"Scale values for a {var_name} variable\"):\n            self.prop().get_mapping(Nominal((\"o\", \"s\")), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "objectpropertybase", "def", "test_bad_scale_values", "self", "cat_vector", "var_name", "self", "prop", "__name__", "lower", "with", "pytest", "raises", "typeerror", "match", "f", "scale", "values", "for", "a", "var_name", "variable", "self", "prop", "get_mapping", "nominal", "o", "s", "cat_vector"], "doc_len": 33}
{"doc_id": "tests/_core/test_properties.py::TestMarker.unpack", "file_path": "tests/_core/test_properties.py", "class_name": "TestMarker", "func_name": "unpack", "text": "文件路径: tests/_core/test_properties.py, 类名: TestMarker\n    def unpack(self, x):\n        return (\n            x.get_path(),\n            x.get_joinstyle(),\n            x.get_transform().to_values(),\n            x.get_fillstyle(),\n        )\n", "tokens": ["tests", "_core", "test_properties", "py", "testmarker", "def", "unpack", "self", "x", "return", "x", "get_path", "x", "get_joinstyle", "x", "get_transform", "to_values", "x", "get_fillstyle"], "doc_len": 19}
{"doc_id": "tests/_core/test_properties.py::TestLineStyle.test_bad_type", "file_path": "tests/_core/test_properties.py", "class_name": "TestLineStyle", "func_name": "test_bad_type", "text": "文件路径: tests/_core/test_properties.py, 类名: TestLineStyle\n    def test_bad_type(self):\n\n        p = LineStyle()\n        with pytest.raises(TypeError, match=\"^Linestyle must be .+, not list.$\"):\n            p.standardize([1, 2])\n", "tokens": ["tests", "_core", "test_properties", "py", "testlinestyle", "def", "test_bad_type", "self", "p", "linestyle", "with", "pytest", "raises", "typeerror", "match", "linestyle", "must", "be", "not", "list", "p", "standardize", "1", "2"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestLineStyle.test_bad_style", "file_path": "tests/_core/test_properties.py", "class_name": "TestLineStyle", "func_name": "test_bad_style", "text": "文件路径: tests/_core/test_properties.py, 类名: TestLineStyle\n    def test_bad_style(self):\n\n        p = LineStyle()\n        with pytest.raises(ValueError, match=\"^Linestyle string must be .+, not 'o'.$\"):\n            p.standardize(\"o\")\n", "tokens": ["tests", "_core", "test_properties", "py", "testlinestyle", "def", "test_bad_style", "self", "p", "linestyle", "with", "pytest", "raises", "valueerror", "match", "linestyle", "string", "must", "be", "not", "o", "p", "standardize", "o"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestLineStyle.test_bad_dashes", "file_path": "tests/_core/test_properties.py", "class_name": "TestLineStyle", "func_name": "test_bad_dashes", "text": "文件路径: tests/_core/test_properties.py, 类名: TestLineStyle\n    def test_bad_dashes(self):\n\n        p = LineStyle()\n        with pytest.raises(TypeError, match=\"^Invalid dash pattern\"):\n            p.standardize((1, 2, \"x\"))\n", "tokens": ["tests", "_core", "test_properties", "py", "testlinestyle", "def", "test_bad_dashes", "self", "p", "linestyle", "with", "pytest", "raises", "typeerror", "match", "invalid", "dash", "pattern", "p", "standardize", "1", "2", "x"], "doc_len": 23}
{"doc_id": "tests/_core/test_properties.py::TestFill.vectors", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "vectors", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def vectors(self):\n\n        return {\n            \"cat\": pd.Series([\"a\", \"a\", \"b\"]),\n            \"num\": pd.Series([1, 1, 2]),\n            \"bool\": pd.Series([True, True, False])\n        }\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "vectors", "self", "return", "cat", "pd", "series", "a", "a", "b", "num", "pd", "series", "1", "1", "2", "bool", "pd", "series", "true", "true", "false"], "doc_len": 27}
{"doc_id": "tests/_core/test_properties.py::TestFill.cat_vector", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "cat_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def cat_vector(self, vectors):\n        return vectors[\"cat\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "cat_vector", "self", "vectors", "return", "vectors", "cat"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::TestFill.num_vector", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "num_vector", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def num_vector(self, vectors):\n        return vectors[\"num\"]\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "num_vector", "self", "vectors", "return", "vectors", "num"], "doc_len": 12}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_default", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_default", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_default(self, data_type, vectors):\n\n        x = vectors[data_type]\n        scale = Fill().default_scale(x)\n        assert isinstance(scale, Nominal)\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_default", "self", "data_type", "vectors", "x", "vectors", "data_type", "scale", "fill", "default_scale", "x", "assert", "isinstance", "scale", "nominal"], "doc_len": 21}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_inference_list", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_inference_list", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_inference_list(self, data_type, vectors):\n\n        x = vectors[data_type]\n        scale = Fill().infer_scale([True, False], x)\n        assert isinstance(scale, Nominal)\n        assert scale.values == [True, False]\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_inference_list", "self", "data_type", "vectors", "x", "vectors", "data_type", "scale", "fill", "infer_scale", "true", "false", "x", "assert", "isinstance", "scale", "nominal", "assert", "scale", "values", "true", "false"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_inference_dict", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_inference_dict", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_inference_dict(self, data_type, vectors):\n\n        x = vectors[data_type]\n        values = dict(zip(x.unique(), [True, False]))\n        scale = Fill().infer_scale(values, x)\n        assert isinstance(scale, Nominal)\n        assert scale.values == values\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_inference_dict", "self", "data_type", "vectors", "x", "vectors", "data_type", "values", "dict", "zip", "x", "unique", "true", "false", "scale", "fill", "infer_scale", "values", "x", "assert", "isinstance", "scale", "nominal", "assert", "scale", "values", "values"], "doc_len": 33}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_mapping_categorical_data", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_mapping_categorical_data", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_mapping_categorical_data(self, cat_vector):\n\n        mapping = Fill().get_mapping(Nominal(), cat_vector)\n        assert_array_equal(mapping([0, 1, 0]), [True, False, True])\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_mapping_categorical_data", "self", "cat_vector", "mapping", "fill", "get_mapping", "nominal", "cat_vector", "assert_array_equal", "mapping", "0", "1", "0", "true", "false", "true"], "doc_len": 22}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_mapping_numeric_data", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_mapping_numeric_data", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_mapping_numeric_data(self, num_vector):\n\n        mapping = Fill().get_mapping(Nominal(), num_vector)\n        assert_array_equal(mapping([0, 1, 0]), [True, False, True])\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_mapping_numeric_data", "self", "num_vector", "mapping", "fill", "get_mapping", "nominal", "num_vector", "assert_array_equal", "mapping", "0", "1", "0", "true", "false", "true"], "doc_len": 22}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_mapping_list", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_mapping_list", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_mapping_list(self, cat_vector):\n\n        mapping = Fill().get_mapping(Nominal([False, True]), cat_vector)\n        assert_array_equal(mapping([0, 1, 0]), [False, True, False])\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_mapping_list", "self", "cat_vector", "mapping", "fill", "get_mapping", "nominal", "false", "true", "cat_vector", "assert_array_equal", "mapping", "0", "1", "0", "false", "true", "false"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_mapping_truthy_list", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_mapping_truthy_list", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_mapping_truthy_list(self, cat_vector):\n\n        mapping = Fill().get_mapping(Nominal([0, 1]), cat_vector)\n        assert_array_equal(mapping([0, 1, 0]), [False, True, False])\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_mapping_truthy_list", "self", "cat_vector", "mapping", "fill", "get_mapping", "nominal", "0", "1", "cat_vector", "assert_array_equal", "mapping", "0", "1", "0", "false", "true", "false"], "doc_len": 24}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_mapping_dict", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_mapping_dict", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_mapping_dict(self, cat_vector):\n\n        values = dict(zip(cat_vector.unique(), [False, True]))\n        mapping = Fill().get_mapping(Nominal(values), cat_vector)\n        assert_array_equal(mapping([0, 1, 0]), [False, True, False])\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_mapping_dict", "self", "cat_vector", "values", "dict", "zip", "cat_vector", "unique", "false", "true", "mapping", "fill", "get_mapping", "nominal", "values", "cat_vector", "assert_array_equal", "mapping", "0", "1", "0", "false", "true", "false"], "doc_len": 30}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_cycle_warning", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_cycle_warning", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_cycle_warning(self):\n\n        x = pd.Series([\"a\", \"b\", \"c\"])\n        with pytest.warns(UserWarning, match=\"The variable assigned to fill\"):\n            Fill().get_mapping(Nominal(), x)\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_cycle_warning", "self", "x", "pd", "series", "a", "b", "c", "with", "pytest", "warns", "userwarning", "match", "the", "variable", "assigned", "to", "fill", "fill", "get_mapping", "nominal", "x"], "doc_len": 28}
{"doc_id": "tests/_core/test_properties.py::TestFill.test_values_error", "file_path": "tests/_core/test_properties.py", "class_name": "TestFill", "func_name": "test_values_error", "text": "文件路径: tests/_core/test_properties.py, 类名: TestFill\n    def test_values_error(self):\n\n        x = pd.Series([\"a\", \"b\"])\n        with pytest.raises(TypeError, match=\"Scale values for fill must be\"):\n            Fill().get_mapping(Nominal(\"bad_values\"), x)\n", "tokens": ["tests", "_core", "test_properties", "py", "testfill", "def", "test_values_error", "self", "x", "pd", "series", "a", "b", "with", "pytest", "raises", "typeerror", "match", "scale", "values", "for", "fill", "must", "be", "fill", "get_mapping", "nominal", "bad_values", "x"], "doc_len": 29}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.norm", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "norm", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def norm(self, x):\n        return (x - x.min()) / (x.max() - x.min())\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "norm", "self", "x", "return", "x", "x", "min", "x", "max", "x", "min"], "doc_len": 17}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_default", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_default", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_default(self, data_type, scale_class, vectors):\n\n        x = vectors[data_type]\n        scale = self.prop().default_scale(x)\n        assert isinstance(scale, scale_class)\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_default", "self", "data_type", "scale_class", "vectors", "x", "vectors", "data_type", "scale", "self", "prop", "default_scale", "x", "assert", "isinstance", "scale", "scale_class"], "doc_len": 23}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_inference", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_inference", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_inference(self, arg, data_type, scale_class, vectors):\n\n        x = vectors[data_type]\n        scale = self.prop().infer_scale(arg, x)\n        assert isinstance(scale, scale_class)\n        assert scale.values == arg\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_inference", "self", "arg", "data_type", "scale_class", "vectors", "x", "vectors", "data_type", "scale", "self", "prop", "infer_scale", "arg", "x", "assert", "isinstance", "scale", "scale_class", "assert", "scale", "values", "arg"], "doc_len": 29}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_mapped_interval_numeric", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_mapped_interval_numeric", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_mapped_interval_numeric(self, num_vector):\n\n        mapping = self.prop().get_mapping(Continuous(), num_vector)\n        assert_array_equal(mapping([0, 1]), self.prop().default_range)\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_mapped_interval_numeric", "self", "num_vector", "mapping", "self", "prop", "get_mapping", "continuous", "num_vector", "assert_array_equal", "mapping", "0", "1", "self", "prop", "default_range"], "doc_len": 22}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_mapped_interval_categorical", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_mapped_interval_categorical", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_mapped_interval_categorical(self, cat_vector):\n\n        mapping = self.prop().get_mapping(Nominal(), cat_vector)\n        n = cat_vector.nunique()\n        assert_array_equal(mapping([n - 1, 0]), self.prop().default_range)\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_mapped_interval_categorical", "self", "cat_vector", "mapping", "self", "prop", "get_mapping", "nominal", "cat_vector", "n", "cat_vector", "nunique", "assert_array_equal", "mapping", "n", "1", "0", "self", "prop", "default_range"], "doc_len": 26}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_bad_scale_values_numeric_data", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_bad_scale_values_numeric_data", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_bad_scale_values_numeric_data(self, num_vector):\n\n        prop_name = self.prop.__name__.lower()\n        err_stem = (\n            f\"Values for {prop_name} variables with Continuous scale must be 2-tuple\"\n        )\n\n        with pytest.raises(TypeError, match=f\"{err_stem}; not <class 'str'>.\"):\n            self.prop().get_mapping(Continuous(\"abc\"), num_vector)\n\n        with pytest.raises(TypeError, match=f\"{err_stem}; not 3-tuple.\"):\n            self.prop().get_mapping(Continuous((1, 2, 3)), num_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_bad_scale_values_numeric_data", "self", "num_vector", "prop_name", "self", "prop", "__name__", "lower", "err_stem", "f", "values", "for", "prop_name", "variables", "with", "continuous", "scale", "must", "be", "2", "tuple", "with", "pytest", "raises", "typeerror", "match", "f", "err_stem", "not", "class", "str", "self", "prop", "get_mapping", "continuous", "abc", "num_vector", "with", "pytest", "raises", "typeerror", "match", "f", "err_stem", "not", "3", "tuple", "self", "prop", "get_mapping", "continuous", "1", "2", "3", "num_vector"], "doc_len": 61}
{"doc_id": "tests/_core/test_properties.py::IntervalBase.test_bad_scale_values_categorical_data", "file_path": "tests/_core/test_properties.py", "class_name": "IntervalBase", "func_name": "test_bad_scale_values_categorical_data", "text": "文件路径: tests/_core/test_properties.py, 类名: IntervalBase\n    def test_bad_scale_values_categorical_data(self, cat_vector):\n\n        prop_name = self.prop.__name__.lower()\n        err_text = f\"Values for {prop_name} variables with Nominal scale\"\n        with pytest.raises(TypeError, match=err_text):\n            self.prop().get_mapping(Nominal(\"abc\"), cat_vector)\n", "tokens": ["tests", "_core", "test_properties", "py", "intervalbase", "def", "test_bad_scale_values_categorical_data", "self", "cat_vector", "prop_name", "self", "prop", "__name__", "lower", "err_text", "f", "values", "for", "prop_name", "variables", "with", "nominal", "scale", "with", "pytest", "raises", "typeerror", "match", "err_text", "self", "prop", "get_mapping", "nominal", "abc", "cat_vector"], "doc_len": 35}
{"doc_id": "tests/_core/test_properties.py::TestLineWidth.test_rcparam_default", "file_path": "tests/_core/test_properties.py", "class_name": "TestLineWidth", "func_name": "test_rcparam_default", "text": "文件路径: tests/_core/test_properties.py, 类名: TestLineWidth\n    def test_rcparam_default(self):\n\n        with mpl.rc_context({\"lines.linewidth\": 2}):\n            assert self.prop().default_range == (1, 4)\n", "tokens": ["tests", "_core", "test_properties", "py", "testlinewidth", "def", "test_rcparam_default", "self", "with", "mpl", "rc_context", "lines", "linewidth", "2", "assert", "self", "prop", "default_range", "1", "4"], "doc_len": 20}
{"doc_id": "tests/_core/test_properties.py::TestEdgeWidth.test_rcparam_default", "file_path": "tests/_core/test_properties.py", "class_name": "TestEdgeWidth", "func_name": "test_rcparam_default", "text": "文件路径: tests/_core/test_properties.py, 类名: TestEdgeWidth\n    def test_rcparam_default(self):\n\n        with mpl.rc_context({\"patch.linewidth\": 2}):\n            assert self.prop().default_range == (1, 4)\n", "tokens": ["tests", "_core", "test_properties", "py", "testedgewidth", "def", "test_rcparam_default", "self", "with", "mpl", "rc_context", "patch", "linewidth", "2", "assert", "self", "prop", "default_range", "1", "4"], "doc_len": 20}
{"doc_id": "tests/_core/test_properties.py::TestPointSize.test_areal_scaling_numeric", "file_path": "tests/_core/test_properties.py", "class_name": "TestPointSize", "func_name": "test_areal_scaling_numeric", "text": "文件路径: tests/_core/test_properties.py, 类名: TestPointSize\n    def test_areal_scaling_numeric(self, num_vector):\n\n        limits = 5, 10\n        scale = Continuous(limits)\n        mapping = self.prop().get_mapping(scale, num_vector)\n        x = np.linspace(0, 1, 6)\n        expected = np.sqrt(np.linspace(*np.square(limits), num=len(x)))\n        assert_array_equal(mapping(x), expected)\n", "tokens": ["tests", "_core", "test_properties", "py", "testpointsize", "def", "test_areal_scaling_numeric", "self", "num_vector", "limits", "5", "10", "scale", "continuous", "limits", "mapping", "self", "prop", "get_mapping", "scale", "num_vector", "x", "np", "linspace", "0", "1", "6", "expected", "np", "sqrt", "np", "linspace", "np", "square", "limits", "num", "len", "x", "assert_array_equal", "mapping", "x", "expected"], "doc_len": 42}
{"doc_id": "tests/_core/test_properties.py::TestPointSize.test_areal_scaling_categorical", "file_path": "tests/_core/test_properties.py", "class_name": "TestPointSize", "func_name": "test_areal_scaling_categorical", "text": "文件路径: tests/_core/test_properties.py, 类名: TestPointSize\n    def test_areal_scaling_categorical(self, cat_vector):\n\n        limits = (2, 4)\n        scale = Nominal(limits)\n        mapping = self.prop().get_mapping(scale, cat_vector)\n        assert_array_equal(mapping(np.arange(3)), [4, np.sqrt(10), 2])\n", "tokens": ["tests", "_core", "test_properties", "py", "testpointsize", "def", "test_areal_scaling_categorical", "self", "cat_vector", "limits", "2", "4", "scale", "nominal", "limits", "mapping", "self", "prop", "get_mapping", "scale", "cat_vector", "assert_array_equal", "mapping", "np", "arange", "3", "4", "np", "sqrt", "10", "2"], "doc_len": 31}
{"doc_id": "tests/_core/test_rules.py::test_vartype_object", "file_path": "tests/_core/test_rules.py", "class_name": null, "func_name": "test_vartype_object", "text": "文件路径: tests/_core/test_rules.py\ndef test_vartype_object():\n\n    v = VarType(\"numeric\")\n    assert v == \"numeric\"\n    assert v != \"categorical\"\n    with pytest.raises(AssertionError):\n        v == \"number\"\n    with pytest.raises(AssertionError):\n        VarType(\"date\")\n", "tokens": ["tests", "_core", "test_rules", "py", "def", "test_vartype_object", "v", "vartype", "numeric", "assert", "v", "numeric", "assert", "v", "categorical", "with", "pytest", "raises", "assertionerror", "v", "number", "with", "pytest", "raises", "assertionerror", "vartype", "date"], "doc_len": 27}
{"doc_id": "tests/_core/test_rules.py::test_variable_type", "file_path": "tests/_core/test_rules.py", "class_name": null, "func_name": "test_variable_type", "text": "文件路径: tests/_core/test_rules.py\ndef test_variable_type():\n\n    s = pd.Series([1., 2., 3.])\n    assert variable_type(s) == \"numeric\"\n    assert variable_type(s.astype(int)) == \"numeric\"\n    assert variable_type(s.astype(object)) == \"numeric\"\n    assert variable_type(s.to_numpy()) == \"numeric\"\n    assert variable_type(s.to_list()) == \"numeric\"\n\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == \"numeric\"\n\n    s = pd.Series([np.nan, np.nan])\n    # s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == \"numeric\"\n\n    s = pd.Series([\"1\", \"2\", \"3\"])\n    assert variable_type(s) == \"categorical\"\n    assert variable_type(s.to_numpy()) == \"categorical\"\n    assert variable_type(s.to_list()) == \"categorical\"\n\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == \"numeric\"\n    assert variable_type(s, boolean_type=\"categorical\") == \"categorical\"\n    s_cat = s.astype(\"category\")\n    assert variable_type(s_cat, boolean_type=\"categorical\") == \"categorical\"\n    assert variable_type(s_cat, boolean_type=\"numeric\") == \"categorical\"\n\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == \"datetime\"\n    assert variable_type(s.astype(object)) == \"datetime\"\n    assert variable_type(s.to_numpy()) == \"datetime\"\n    assert variable_type(s.to_list()) == \"datetime\"\n", "tokens": ["tests", "_core", "test_rules", "py", "def", "test_variable_type", "s", "pd", "series", "1", "2", "3", "assert", "variable_type", "s", "numeric", "assert", "variable_type", "s", "astype", "int", "numeric", "assert", "variable_type", "s", "astype", "object", "numeric", "assert", "variable_type", "s", "to_numpy", "numeric", "assert", "variable_type", "s", "to_list", "numeric", "s", "pd", "series", "1", "2", "3", "np", "nan", "dtype", "object", "assert", "variable_type", "s", "numeric", "s", "pd", "series", "np", "nan", "np", "nan", "s", "pd", "series", "pd", "na", "pd", "na", "assert", "variable_type", "s", "numeric", "s", "pd", "series", "1", "2", "3", "assert", "variable_type", "s", "categorical", "assert", "variable_type", "s", "to_numpy", "categorical", "assert", "variable_type", "s", "to_list", "categorical", "s", "pd", "series", "true", "false", "false", "assert", "variable_type", "s", "numeric", "assert", "variable_type", "s", "boolean_type", "categorical", "categorical", "s_cat", "s", "astype", "category", "assert", "variable_type", "s_cat", "boolean_type", "categorical", "categorical", "assert", "variable_type", "s_cat", "boolean_type", "numeric", "categorical", "s", "pd", "series", "pd", "timestamp", "1", "pd", "timestamp", "2", "assert", "variable_type", "s", "datetime", "assert", "variable_type", "s", "astype", "object", "datetime", "assert", "variable_type", "s", "to_numpy", "datetime", "assert", "variable_type", "s", "to_list", "datetime"], "doc_len": 151}
{"doc_id": "tests/_core/test_rules.py::test_categorical_order", "file_path": "tests/_core/test_rules.py", "class_name": null, "func_name": "test_categorical_order", "text": "文件路径: tests/_core/test_rules.py\ndef test_categorical_order():\n\n    x = pd.Series([\"a\", \"c\", \"c\", \"b\", \"a\", \"d\"])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = [\"a\", \"b\", \"c\", \"d\"]\n\n    out = categorical_order(x)\n    assert out == [\"a\", \"c\", \"b\", \"d\"]\n\n    out = categorical_order(x, order)\n    assert out == order\n\n    out = categorical_order(x, [\"b\", \"a\"])\n    assert out == [\"b\", \"a\"]\n\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n\n    x = pd.Series(x).astype(\"category\")\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n\n    out = categorical_order(x, [\"b\", \"a\"])\n    assert out == [\"b\", \"a\"]\n\n    x = pd.Series([\"a\", np.nan, \"c\", \"c\", \"b\", \"a\", \"d\"])\n    out = categorical_order(x)\n    assert out == [\"a\", \"c\", \"b\", \"d\"]\n", "tokens": ["tests", "_core", "test_rules", "py", "def", "test_categorical_order", "x", "pd", "series", "a", "c", "c", "b", "a", "d", "y", "pd", "series", "3", "2", "5", "1", "4", "order", "a", "b", "c", "d", "out", "categorical_order", "x", "assert", "out", "a", "c", "b", "d", "out", "categorical_order", "x", "order", "assert", "out", "order", "out", "categorical_order", "x", "b", "a", "assert", "out", "b", "a", "out", "categorical_order", "y", "assert", "out", "1", "2", "3", "4", "5", "out", "categorical_order", "pd", "series", "y", "assert", "out", "1", "2", "3", "4", "5", "y_cat", "pd", "series", "pd", "categorical", "y", "y", "out", "categorical_order", "y_cat", "assert", "out", "list", "y", "x", "pd", "series", "x", "astype", "category", "out", "categorical_order", "x", "assert", "out", "list", "x", "cat", "categories", "out", "categorical_order", "x", "b", "a", "assert", "out", "b", "a", "x", "pd", "series", "a", "np", "nan", "c", "c", "b", "a", "d", "out", "categorical_order", "x", "assert", "out", "a", "c", "b", "d"], "doc_len": 133}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.x", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "x", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def x(self):\n        return pd.Series([1, 3, 9], name=\"x\", dtype=float)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "x", "self", "return", "pd", "series", "1", "3", "9", "name", "x", "dtype", "float"], "doc_len": 18}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.setup_ticks", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "setup_ticks", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def setup_ticks(self, x, *args, **kwargs):\n\n        s = Continuous().tick(*args, **kwargs)._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        a.set_view_interval(0, 1)\n        return a\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "setup_ticks", "self", "x", "args", "kwargs", "s", "continuous", "tick", "args", "kwargs", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "a", "set_view_interval", "0", "1", "return", "a"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.setup_labels", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "setup_labels", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def setup_labels(self, x, *args, **kwargs):\n\n        s = Continuous().label(*args, **kwargs)._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        a.set_view_interval(0, 1)\n        locs = a.major.locator()\n        return a, locs\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "setup_labels", "self", "x", "args", "kwargs", "s", "continuous", "label", "args", "kwargs", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "a", "set_view_interval", "0", "1", "locs", "a", "major", "locator", "return", "a", "locs"], "doc_len": 34}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_coordinate_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_coordinate_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_coordinate_defaults(self, x):\n\n        s = Continuous()._setup(x, Coordinate())\n        assert_series_equal(s(x), x)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_coordinate_defaults", "self", "x", "s", "continuous", "_setup", "x", "coordinate", "assert_series_equal", "s", "x", "x"], "doc_len": 18}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_coordinate_transform", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_coordinate_transform", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_coordinate_transform(self, x):\n\n        s = Continuous(trans=\"log\")._setup(x, Coordinate())\n        assert_series_equal(s(x), np.log10(x))\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_coordinate_transform", "self", "x", "s", "continuous", "trans", "log", "_setup", "x", "coordinate", "assert_series_equal", "s", "x", "np", "log10", "x"], "doc_len": 22}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_coordinate_transform_with_parameter", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_coordinate_transform_with_parameter", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_coordinate_transform_with_parameter(self, x):\n\n        s = Continuous(trans=\"pow3\")._setup(x, Coordinate())\n        assert_series_equal(s(x), np.power(x, 3))\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_coordinate_transform_with_parameter", "self", "x", "s", "continuous", "trans", "pow3", "_setup", "x", "coordinate", "assert_series_equal", "s", "x", "np", "power", "x", "3"], "doc_len": 23}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_coordinate_transform_error", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_coordinate_transform_error", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_coordinate_transform_error(self, x):\n\n        s = Continuous(trans=\"bad\")\n        with pytest.raises(ValueError, match=\"Unknown value provided\"):\n            s._setup(x, Coordinate())\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_coordinate_transform_error", "self", "x", "s", "continuous", "trans", "bad", "with", "pytest", "raises", "valueerror", "match", "unknown", "value", "provided", "s", "_setup", "x", "coordinate"], "doc_len": 25}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_interval_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_interval_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_interval_defaults(self, x):\n\n        s = Continuous()._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [0, .25, 1])\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_interval_defaults", "self", "x", "s", "continuous", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "0", "25", "1"], "doc_len": 20}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_interval_with_range", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_interval_with_range", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_interval_with_range(self, x):\n\n        s = Continuous((1, 3))._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [1, 1.5, 3])\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_interval_with_range", "self", "x", "s", "continuous", "1", "3", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "1", "1", "5", "3"], "doc_len": 23}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_interval_with_norm", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_interval_with_norm", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_interval_with_norm(self, x):\n\n        s = Continuous(norm=(3, 7))._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [-.5, 0, 1.5])\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_interval_with_norm", "self", "x", "s", "continuous", "norm", "3", "7", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "5", "0", "1", "5"], "doc_len": 24}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_interval_with_range_norm_and_transform", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_interval_with_range_norm_and_transform", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_interval_with_range_norm_and_transform(self, x):\n\n        x = pd.Series([1, 10, 100])\n        # TODO param order?\n        s = Continuous((2, 3), (10, 100), \"log\")._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [1, 2, 3])\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_interval_with_range_norm_and_transform", "self", "x", "x", "pd", "series", "1", "10", "100", "todo", "param", "order", "s", "continuous", "2", "3", "10", "100", "log", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "1", "2", "3"], "doc_len": 34}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_defaults(self, x):\n\n        cmap = color_palette(\"ch:\", as_cmap=True)\n        s = Continuous()._setup(x, Color())\n        assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_defaults", "self", "x", "cmap", "color_palette", "ch", "as_cmap", "true", "s", "continuous", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "0", "25", "1", "3", "fixme", "rgba"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_named_values", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_named_values", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_named_values(self, x):\n\n        cmap = color_palette(\"viridis\", as_cmap=True)\n        s = Continuous(\"viridis\")._setup(x, Color())\n        assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_named_values", "self", "x", "cmap", "color_palette", "viridis", "as_cmap", "true", "s", "continuous", "viridis", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "0", "25", "1", "3", "fixme", "rgba"], "doc_len": 30}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_tuple_values", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_tuple_values", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_tuple_values(self, x):\n\n        cmap = color_palette(\"blend:b,g\", as_cmap=True)\n        s = Continuous((\"b\", \"g\"))._setup(x, Color())\n        assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_tuple_values", "self", "x", "cmap", "color_palette", "blend", "b", "g", "as_cmap", "true", "s", "continuous", "b", "g", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "0", "25", "1", "3", "fixme", "rgba"], "doc_len": 33}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_callable_values", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_callable_values", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_callable_values(self, x):\n\n        cmap = color_palette(\"light:r\", as_cmap=True)\n        s = Continuous(cmap)._setup(x, Color())\n        assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_callable_values", "self", "x", "cmap", "color_palette", "light", "r", "as_cmap", "true", "s", "continuous", "cmap", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "0", "25", "1", "3", "fixme", "rgba"], "doc_len": 31}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_with_norm", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_with_norm", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_with_norm(self, x):\n\n        cmap = color_palette(\"ch:\", as_cmap=True)\n        s = Continuous(norm=(3, 7))._setup(x, Color())\n        assert_array_equal(s(x), cmap([-.5, 0, 1.5])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_with_norm", "self", "x", "cmap", "color_palette", "ch", "as_cmap", "true", "s", "continuous", "norm", "3", "7", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "5", "0", "1", "5", "3", "fixme", "rgba"], "doc_len": 33}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_color_with_transform", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_color_with_transform", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_color_with_transform(self, x):\n\n        x = pd.Series([1, 10, 100], name=\"x\", dtype=float)\n        cmap = color_palette(\"ch:\", as_cmap=True)\n        s = Continuous(trans=\"log\")._setup(x, Color())\n        assert_array_equal(s(x), cmap([0, .5, 1])[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_color_with_transform", "self", "x", "x", "pd", "series", "1", "10", "100", "name", "x", "dtype", "float", "cmap", "color_palette", "ch", "as_cmap", "true", "s", "continuous", "trans", "log", "_setup", "x", "color", "assert_array_equal", "s", "x", "cmap", "0", "5", "1", "3", "fixme", "rgba"], "doc_len": 41}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_locator", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_locator", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_locator(self, x):\n\n        locs = [.2, .5, .8]\n        locator = mpl.ticker.FixedLocator(locs)\n        a = self.setup_ticks(x, locator)\n        assert_array_equal(a.major.locator(), locs)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_locator", "self", "x", "locs", "2", "5", "8", "locator", "mpl", "ticker", "fixedlocator", "locs", "a", "self", "setup_ticks", "x", "locator", "assert_array_equal", "a", "major", "locator", "locs"], "doc_len": 28}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_locator_input_check", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_locator_input_check", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_locator_input_check(self, x):\n\n        err = \"Tick locator must be an instance of .*?, not <class 'tuple'>.\"\n        with pytest.raises(TypeError, match=err):\n            Continuous().tick((1, 2))\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_locator_input_check", "self", "x", "err", "tick", "locator", "must", "be", "an", "instance", "of", "not", "class", "tuple", "with", "pytest", "raises", "typeerror", "match", "err", "continuous", "tick", "1", "2"], "doc_len": 30}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_upto", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_upto", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_upto(self, x):\n\n        for n in [2, 5, 10]:\n            a = self.setup_ticks(x, upto=n)\n            assert len(a.major.locator()) <= (n + 1)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_upto", "self", "x", "for", "n", "in", "2", "5", "10", "a", "self", "setup_ticks", "x", "upto", "n", "assert", "len", "a", "major", "locator", "n", "1"], "doc_len": 28}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_every", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_every", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_every(self, x):\n\n        for d in [.05, .2, .5]:\n            a = self.setup_ticks(x, every=d)\n            assert np.allclose(np.diff(a.major.locator()), d)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_every", "self", "x", "for", "d", "in", "05", "2", "5", "a", "self", "setup_ticks", "x", "every", "d", "assert", "np", "allclose", "np", "diff", "a", "major", "locator", "d"], "doc_len": 30}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_every_between", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_every_between", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_every_between(self, x):\n\n        lo, hi = .2, .8\n        for d in [.05, .2, .5]:\n            a = self.setup_ticks(x, every=d, between=(lo, hi))\n            expected = np.arange(lo, hi + d, d)\n            assert_array_equal(a.major.locator(), expected)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_every_between", "self", "x", "lo", "hi", "2", "8", "for", "d", "in", "05", "2", "5", "a", "self", "setup_ticks", "x", "every", "d", "between", "lo", "hi", "expected", "np", "arange", "lo", "hi", "d", "d", "assert_array_equal", "a", "major", "locator", "expected"], "doc_len": 40}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_at", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_at", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_at(self, x):\n\n        locs = [.2, .5, .9]\n        a = self.setup_ticks(x, at=locs)\n        assert_array_equal(a.major.locator(), locs)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_at", "self", "x", "locs", "2", "5", "9", "a", "self", "setup_ticks", "x", "at", "locs", "assert_array_equal", "a", "major", "locator", "locs"], "doc_len": 24}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_count", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_count", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_count(self, x):\n\n        n = 8\n        a = self.setup_ticks(x, count=n)\n        assert_array_equal(a.major.locator(), np.linspace(0, 1, n))\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_count", "self", "x", "n", "8", "a", "self", "setup_ticks", "x", "count", "n", "assert_array_equal", "a", "major", "locator", "np", "linspace", "0", "1", "n"], "doc_len": 26}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_count_between", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_count_between", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_count_between(self, x):\n\n        n = 5\n        lo, hi = .2, .7\n        a = self.setup_ticks(x, count=n, between=(lo, hi))\n        assert_array_equal(a.major.locator(), np.linspace(lo, hi, n))\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_count_between", "self", "x", "n", "5", "lo", "hi", "2", "7", "a", "self", "setup_ticks", "x", "count", "n", "between", "lo", "hi", "assert_array_equal", "a", "major", "locator", "np", "linspace", "lo", "hi", "n"], "doc_len": 33}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_tick_minor", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_tick_minor", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_tick_minor(self, x):\n\n        n = 3\n        a = self.setup_ticks(x, count=2, minor=n)\n        # I am not sure why matplotlib's minor ticks include the\n        # largest major location but exclude the smalllest one ...\n        expected = np.linspace(0, 1, n + 2)[1:]\n        assert_array_equal(a.minor.locator(), expected)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_tick_minor", "self", "x", "n", "3", "a", "self", "setup_ticks", "x", "count", "2", "minor", "n", "i", "am", "not", "sure", "why", "matplotlib", "s", "minor", "ticks", "include", "the", "largest", "major", "location", "but", "exclude", "the", "smalllest", "one", "expected", "np", "linspace", "0", "1", "n", "2", "1", "assert_array_equal", "a", "minor", "locator", "expected"], "doc_len": 51}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_log_tick_default", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_log_tick_default", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_log_tick_default(self, x):\n\n        s = Continuous(trans=\"log\")._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        a.set_view_interval(.5, 1050)\n        ticks = a.major.locator()\n        assert np.allclose(np.diff(np.log10(ticks)), 1)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_log_tick_default", "self", "x", "s", "continuous", "trans", "log", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "a", "set_view_interval", "5", "1050", "ticks", "a", "major", "locator", "assert", "np", "allclose", "np", "diff", "np", "log10", "ticks", "1"], "doc_len": 37}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_log_tick_upto", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_log_tick_upto", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_log_tick_upto(self, x):\n\n        n = 3\n        s = Continuous(trans=\"log\").tick(upto=n)._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        assert a.major.locator.numticks == n\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_log_tick_upto", "self", "x", "n", "3", "s", "continuous", "trans", "log", "tick", "upto", "n", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "assert", "a", "major", "locator", "numticks", "n"], "doc_len": 31}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_log_tick_count", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_log_tick_count", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_log_tick_count(self, x):\n\n        with pytest.raises(RuntimeError, match=\"`count` requires\"):\n            Continuous(trans=\"log\").tick(count=4)\n\n        s = Continuous(trans=\"log\").tick(count=4, between=(1, 1000))\n        a = PseudoAxis(s._setup(x, Coordinate())._matplotlib_scale)\n        a.set_view_interval(.5, 1050)\n        assert_array_equal(a.major.locator(), [1, 10, 100, 1000])\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_log_tick_count", "self", "x", "with", "pytest", "raises", "runtimeerror", "match", "count", "requires", "continuous", "trans", "log", "tick", "count", "4", "s", "continuous", "trans", "log", "tick", "count", "4", "between", "1", "1000", "a", "pseudoaxis", "s", "_setup", "x", "coordinate", "_matplotlib_scale", "a", "set_view_interval", "5", "1050", "assert_array_equal", "a", "major", "locator", "1", "10", "100", "1000"], "doc_len": 51}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_log_tick_format_disabled", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_log_tick_format_disabled", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_log_tick_format_disabled(self, x):\n\n        s = Continuous(trans=\"log\").label(base=None)._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        a.set_view_interval(20, 20000)\n        labels = a.major.formatter.format_ticks(a.major.locator())\n        for text in labels:\n            assert re.match(r\"^\\d+$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_log_tick_format_disabled", "self", "x", "s", "continuous", "trans", "log", "label", "base", "none", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "a", "set_view_interval", "20", "20000", "labels", "a", "major", "formatter", "format_ticks", "a", "major", "locator", "for", "text", "in", "labels", "assert", "re", "match", "r", "d", "text"], "doc_len": 45}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_log_tick_every", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_log_tick_every", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_log_tick_every(self, x):\n\n        with pytest.raises(RuntimeError, match=\"`every` not supported\"):\n            Continuous(trans=\"log\").tick(every=2)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_log_tick_every", "self", "x", "with", "pytest", "raises", "runtimeerror", "match", "every", "not", "supported", "continuous", "trans", "log", "tick", "every", "2"], "doc_len": 23}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_symlog_tick_default", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_symlog_tick_default", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_symlog_tick_default(self, x):\n\n        s = Continuous(trans=\"symlog\")._setup(x, Coordinate())\n        a = PseudoAxis(s._matplotlib_scale)\n        a.set_view_interval(-1050, 1050)\n        ticks = a.major.locator()\n        assert ticks[0] == -ticks[-1]\n        pos_ticks = np.sort(np.unique(np.abs(ticks)))\n        assert np.allclose(np.diff(np.log10(pos_ticks[1:])), 1)\n        assert pos_ticks[0] == 0\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_symlog_tick_default", "self", "x", "s", "continuous", "trans", "symlog", "_setup", "x", "coordinate", "a", "pseudoaxis", "s", "_matplotlib_scale", "a", "set_view_interval", "1050", "1050", "ticks", "a", "major", "locator", "assert", "ticks", "0", "ticks", "1", "pos_ticks", "np", "sort", "np", "unique", "np", "abs", "ticks", "assert", "np", "allclose", "np", "diff", "np", "log10", "pos_ticks", "1", "1", "assert", "pos_ticks", "0", "0"], "doc_len": 55}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_formatter", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_formatter", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_formatter(self, x):\n\n        fmt = mpl.ticker.FormatStrFormatter(\"%.3f\")\n        a, locs = self.setup_labels(x, fmt)\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels:\n            assert re.match(r\"^\\d\\.\\d{3}$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_formatter", "self", "x", "fmt", "mpl", "ticker", "formatstrformatter", "3f", "a", "locs", "self", "setup_labels", "x", "fmt", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "assert", "re", "match", "r", "d", "d", "3", "text"], "doc_len": 38}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_like_pattern", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_like_pattern", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_like_pattern(self, x):\n\n        a, locs = self.setup_labels(x, like=\".4f\")\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels:\n            assert re.match(r\"^\\d\\.\\d{4}$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_like_pattern", "self", "x", "a", "locs", "self", "setup_labels", "x", "like", "4f", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "assert", "re", "match", "r", "d", "d", "4", "text"], "doc_len": 34}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_like_string", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_like_string", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_like_string(self, x):\n\n        a, locs = self.setup_labels(x, like=\"x = {x:.1f}\")\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels:\n            assert re.match(r\"^x = \\d\\.\\d$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_like_string", "self", "x", "a", "locs", "self", "setup_labels", "x", "like", "x", "x", "1f", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "assert", "re", "match", "r", "x", "d", "d", "text"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_like_function", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_like_function", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_like_function(self, x):\n\n        a, locs = self.setup_labels(x, like=\"{:^5.1f}\".format)\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels:\n            assert re.match(r\"^ \\d\\.\\d $\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_like_function", "self", "x", "a", "locs", "self", "setup_labels", "x", "like", "5", "1f", "format", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "assert", "re", "match", "r", "d", "d", "text"], "doc_len": 35}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_base", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_base", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_base(self, x):\n\n        a, locs = self.setup_labels(100 * x, base=2)\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels[1:]:\n            assert not text or \"2^\" in text\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_base", "self", "x", "a", "locs", "self", "setup_labels", "100", "x", "base", "2", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "1", "assert", "not", "text", "or", "2", "in", "text"], "doc_len": 35}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_unit", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_unit", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_unit(self, x):\n\n        a, locs = self.setup_labels(1000 * x, unit=\"g\")\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels[1:-1]:\n            assert re.match(r\"^\\d+ mg$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_unit", "self", "x", "a", "locs", "self", "setup_labels", "1000", "x", "unit", "g", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "1", "1", "assert", "re", "match", "r", "d", "mg", "text"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_unit_with_sep", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_unit_with_sep", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_unit_with_sep(self, x):\n\n        a, locs = self.setup_labels(1000 * x, unit=(\"\", \"g\"))\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels[1:-1]:\n            assert re.match(r\"^\\d+mg$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_unit_with_sep", "self", "x", "a", "locs", "self", "setup_labels", "1000", "x", "unit", "g", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "1", "1", "assert", "re", "match", "r", "d", "mg", "text"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_empty_unit", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_empty_unit", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_empty_unit(self, x):\n\n        a, locs = self.setup_labels(1000 * x, unit=\"\")\n        labels = a.major.formatter.format_ticks(locs)\n        for text in labels[1:-1]:\n            assert re.match(r\"^\\d+m$\", text)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_empty_unit", "self", "x", "a", "locs", "self", "setup_labels", "1000", "x", "unit", "labels", "a", "major", "formatter", "format_ticks", "locs", "for", "text", "in", "labels", "1", "1", "assert", "re", "match", "r", "d", "m", "text"], "doc_len": 35}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_base_from_transform", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_base_from_transform", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_base_from_transform(self, x):\n\n        s = Continuous(trans=\"log\")\n        a = PseudoAxis(s._setup(x, Coordinate())._matplotlib_scale)\n        a.set_view_interval(10, 1000)\n        label, = a.major.formatter.format_ticks([100])\n        assert r\"10^{2}\" in label\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_base_from_transform", "self", "x", "s", "continuous", "trans", "log", "a", "pseudoaxis", "s", "_setup", "x", "coordinate", "_matplotlib_scale", "a", "set_view_interval", "10", "1000", "label", "a", "major", "formatter", "format_ticks", "100", "assert", "r", "10", "2", "in", "label"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestContinuous.test_label_type_checks", "file_path": "tests/_core/test_scales.py", "class_name": "TestContinuous", "func_name": "test_label_type_checks", "text": "文件路径: tests/_core/test_scales.py, 类名: TestContinuous\n    def test_label_type_checks(self):\n\n        s = Continuous()\n        with pytest.raises(TypeError, match=\"Label formatter must be\"):\n            s.label(\"{x}\")\n\n        with pytest.raises(TypeError, match=\"`like` must be\"):\n            s.label(like=2)\n", "tokens": ["tests", "_core", "test_scales", "py", "testcontinuous", "def", "test_label_type_checks", "self", "s", "continuous", "with", "pytest", "raises", "typeerror", "match", "label", "formatter", "must", "be", "s", "label", "x", "with", "pytest", "raises", "typeerror", "match", "like", "must", "be", "s", "label", "like", "2"], "doc_len": 34}
{"doc_id": "tests/_core/test_scales.py::TestNominal.x", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "x", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def x(self):\n        return pd.Series([\"a\", \"c\", \"b\", \"c\"], name=\"x\")\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "x", "self", "return", "pd", "series", "a", "c", "b", "c", "name", "x"], "doc_len": 17}
{"doc_id": "tests/_core/test_scales.py::TestNominal.y", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "y", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def y(self):\n        return pd.Series([1, -1.5, 3, -1.5], name=\"y\")\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "y", "self", "return", "pd", "series", "1", "1", "5", "3", "1", "5", "name", "y"], "doc_len": 19}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_defaults(self, x):\n\n        s = Nominal()._setup(x, Coordinate())\n        assert_array_equal(s(x), np.array([0, 1, 2, 1], float))\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_defaults", "self", "x", "s", "nominal", "_setup", "x", "coordinate", "assert_array_equal", "s", "x", "np", "array", "0", "1", "2", "1", "float"], "doc_len": 24}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_with_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_with_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_with_order(self, x):\n\n        s = Nominal(order=[\"a\", \"b\", \"c\"])._setup(x, Coordinate())\n        assert_array_equal(s(x), np.array([0, 2, 1, 2], float))\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_with_order", "self", "x", "s", "nominal", "order", "a", "b", "c", "_setup", "x", "coordinate", "assert_array_equal", "s", "x", "np", "array", "0", "2", "1", "2", "float"], "doc_len": 28}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_with_subset_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_with_subset_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_with_subset_order(self, x):\n\n        s = Nominal(order=[\"c\", \"a\"])._setup(x, Coordinate())\n        assert_array_equal(s(x), np.array([1, 0, np.nan, 0], float))\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_with_subset_order", "self", "x", "s", "nominal", "order", "c", "a", "_setup", "x", "coordinate", "assert_array_equal", "s", "x", "np", "array", "1", "0", "np", "nan", "0", "float"], "doc_len": 28}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_axis", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_axis", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_axis(self, x):\n\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n        assert_array_equal(s(x), np.array([0, 1, 2, 1], float))\n        f = ax.xaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2]) == [\"a\", \"c\", \"b\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_axis", "self", "x", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "_setup", "x", "coordinate", "ax", "xaxis", "assert_array_equal", "s", "x", "np", "array", "0", "1", "2", "1", "float", "f", "ax", "xaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "a", "c", "b"], "doc_len": 44}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_axis_with_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_axis_with_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_axis_with_order(self, x):\n\n        order = [\"a\", \"b\", \"c\"]\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n        assert_array_equal(s(x), np.array([0, 2, 1, 2], float))\n        f = ax.xaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2]) == order\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_axis_with_order", "self", "x", "order", "a", "b", "c", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "order", "order", "_setup", "x", "coordinate", "ax", "xaxis", "assert_array_equal", "s", "x", "np", "array", "0", "2", "1", "2", "float", "f", "ax", "xaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "order"], "doc_len": 48}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_axis_with_subset_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_axis_with_subset_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_axis_with_subset_order(self, x):\n\n        order = [\"c\", \"a\"]\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n        assert_array_equal(s(x), np.array([1, 0, np.nan, 0], float))\n        f = ax.xaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2]) == [*order, \"\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_axis_with_subset_order", "self", "x", "order", "c", "a", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "order", "order", "_setup", "x", "coordinate", "ax", "xaxis", "assert_array_equal", "s", "x", "np", "array", "1", "0", "np", "nan", "0", "float", "f", "ax", "xaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "order"], "doc_len": 48}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_axis_with_category_dtype", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_axis_with_category_dtype", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_axis_with_category_dtype(self, x):\n\n        order = [\"b\", \"a\", \"d\", \"c\"]\n        x = x.astype(pd.CategoricalDtype(order))\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n        assert_array_equal(s(x), np.array([1, 3, 0, 3], float))\n        f = ax.xaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2, 3]) == order\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_axis_with_category_dtype", "self", "x", "order", "b", "a", "d", "c", "x", "x", "astype", "pd", "categoricaldtype", "order", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "_setup", "x", "coordinate", "ax", "xaxis", "assert_array_equal", "s", "x", "np", "array", "1", "3", "0", "3", "float", "f", "ax", "xaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "3", "order"], "doc_len": 54}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_numeric_data", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_numeric_data", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_numeric_data(self, y):\n\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal()._setup(y, Coordinate(), ax.yaxis)\n        assert_array_equal(s(y), np.array([1, 0, 2, 0], float))\n        f = ax.yaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2]) == [\"-1.5\", \"1.0\", \"3.0\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_numeric_data", "self", "y", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "_setup", "y", "coordinate", "ax", "yaxis", "assert_array_equal", "s", "y", "np", "array", "1", "0", "2", "0", "float", "f", "ax", "yaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "1", "5", "1", "0", "3", "0"], "doc_len": 47}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_coordinate_numeric_data_with_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_coordinate_numeric_data_with_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_coordinate_numeric_data_with_order(self, y):\n\n        order = [1, 4, -1.5]\n        ax = mpl.figure.Figure().subplots()\n        s = Nominal(order=order)._setup(y, Coordinate(), ax.yaxis)\n        assert_array_equal(s(y), np.array([0, 2, np.nan, 2], float))\n        f = ax.yaxis.get_major_formatter()\n        assert f.format_ticks([0, 1, 2]) == [\"1.0\", \"4.0\", \"-1.5\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_coordinate_numeric_data_with_order", "self", "y", "order", "1", "4", "1", "5", "ax", "mpl", "figure", "figure", "subplots", "s", "nominal", "order", "order", "_setup", "y", "coordinate", "ax", "yaxis", "assert_array_equal", "s", "y", "np", "array", "0", "2", "np", "nan", "2", "float", "f", "ax", "yaxis", "get_major_formatter", "assert", "f", "format_ticks", "0", "1", "2", "1", "0", "4", "0", "1", "5"], "doc_len": 55}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_defaults(self, x):\n\n        s = Nominal()._setup(x, Color())\n        cs = color_palette()\n        assert_array_equal(s(x), [cs[0], cs[1], cs[2], cs[1]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_defaults", "self", "x", "s", "nominal", "_setup", "x", "color", "cs", "color_palette", "assert_array_equal", "s", "x", "cs", "0", "cs", "1", "cs", "2", "cs", "1"], "doc_len": 27}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_named_palette", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_named_palette", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_named_palette(self, x):\n\n        pal = \"flare\"\n        s = Nominal(pal)._setup(x, Color())\n        cs = color_palette(pal, 3)\n        assert_array_equal(s(x), [cs[0], cs[1], cs[2], cs[1]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_named_palette", "self", "x", "pal", "flare", "s", "nominal", "pal", "_setup", "x", "color", "cs", "color_palette", "pal", "3", "assert_array_equal", "s", "x", "cs", "0", "cs", "1", "cs", "2", "cs", "1"], "doc_len": 32}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_list_palette", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_list_palette", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_list_palette(self, x):\n\n        cs = color_palette(\"crest\", 3)\n        s = Nominal(cs)._setup(x, Color())\n        assert_array_equal(s(x), [cs[0], cs[1], cs[2], cs[1]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_list_palette", "self", "x", "cs", "color_palette", "crest", "3", "s", "nominal", "cs", "_setup", "x", "color", "assert_array_equal", "s", "x", "cs", "0", "cs", "1", "cs", "2", "cs", "1"], "doc_len": 30}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_dict_palette", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_dict_palette", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_dict_palette(self, x):\n\n        cs = color_palette(\"crest\", 3)\n        pal = dict(zip(\"bac\", cs))\n        s = Nominal(pal)._setup(x, Color())\n        assert_array_equal(s(x), [cs[1], cs[2], cs[0], cs[2]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_dict_palette", "self", "x", "cs", "color_palette", "crest", "3", "pal", "dict", "zip", "bac", "cs", "s", "nominal", "pal", "_setup", "x", "color", "assert_array_equal", "s", "x", "cs", "1", "cs", "2", "cs", "0", "cs", "2"], "doc_len": 35}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_numeric_data", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_numeric_data", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_numeric_data(self, y):\n\n        s = Nominal()._setup(y, Color())\n        cs = color_palette()\n        assert_array_equal(s(y), [cs[1], cs[0], cs[2], cs[0]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_numeric_data", "self", "y", "s", "nominal", "_setup", "y", "color", "cs", "color_palette", "assert_array_equal", "s", "y", "cs", "1", "cs", "0", "cs", "2", "cs", "0"], "doc_len": 27}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_numeric_with_order_subset", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_numeric_with_order_subset", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_numeric_with_order_subset(self, y):\n\n        s = Nominal(order=[-1.5, 1])._setup(y, Color())\n        c1, c2 = color_palette(n_colors=2)\n        null = (np.nan, np.nan, np.nan)\n        assert_array_equal(s(y), [c2, c1, null, c1])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_numeric_with_order_subset", "self", "y", "s", "nominal", "order", "1", "5", "1", "_setup", "y", "color", "c1", "c2", "color_palette", "n_colors", "2", "null", "np", "nan", "np", "nan", "np", "nan", "assert_array_equal", "s", "y", "c2", "c1", "null", "c1"], "doc_len": 37}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_numeric_int_float_mix", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_numeric_int_float_mix", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_numeric_int_float_mix(self):\n\n        z = pd.Series([1, 2], name=\"z\")\n        s = Nominal(order=[1.0, 2])._setup(z, Color())\n        c1, c2 = color_palette(n_colors=2)\n        null = (np.nan, np.nan, np.nan)\n        assert_array_equal(s(z), [c1, null, c2])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_numeric_int_float_mix", "self", "z", "pd", "series", "1", "2", "name", "z", "s", "nominal", "order", "1", "0", "2", "_setup", "z", "color", "c1", "c2", "color_palette", "n_colors", "2", "null", "np", "nan", "np", "nan", "np", "nan", "assert_array_equal", "s", "z", "c1", "null", "c2"], "doc_len": 42}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_alpha_in_palette", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_alpha_in_palette", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_alpha_in_palette(self, x):\n\n        cs = [(.2, .2, .3, .5), (.1, .2, .3, 1), (.5, .6, .2, 0)]\n        s = Nominal(cs)._setup(x, Color())\n        assert_array_equal(s(x), [cs[0], cs[1], cs[2], cs[1]])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_alpha_in_palette", "self", "x", "cs", "2", "2", "3", "5", "1", "2", "3", "1", "5", "6", "2", "0", "s", "nominal", "cs", "_setup", "x", "color", "assert_array_equal", "s", "x", "cs", "0", "cs", "1", "cs", "2", "cs", "1"], "doc_len": 39}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_color_unknown_palette", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_color_unknown_palette", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_color_unknown_palette(self, x):\n\n        pal = \"not_a_palette\"\n        err = f\"'{pal}' is not a valid palette name\"\n        with pytest.raises(ValueError, match=err):\n            Nominal(pal)._setup(x, Color())\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_color_unknown_palette", "self", "x", "pal", "not_a_palette", "err", "f", "pal", "is", "not", "a", "valid", "palette", "name", "with", "pytest", "raises", "valueerror", "match", "err", "nominal", "pal", "_setup", "x", "color"], "doc_len": 31}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_object_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_object_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_object_defaults(self, x):\n\n        class MockProperty(ObjectProperty):\n            def _default_values(self, n):\n                return list(\"xyz\"[:n])\n\n        s = Nominal()._setup(x, MockProperty())\n        assert s(x) == [\"x\", \"y\", \"z\", \"y\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_object_defaults", "self", "x", "class", "mockproperty", "objectproperty", "def", "_default_values", "self", "n", "return", "list", "xyz", "n", "s", "nominal", "_setup", "x", "mockproperty", "assert", "s", "x", "x", "y", "z", "y"], "doc_len": 32}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_object_list", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_object_list", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_object_list(self, x):\n\n        vs = [\"x\", \"y\", \"z\"]\n        s = Nominal(vs)._setup(x, ObjectProperty())\n        assert s(x) == [\"x\", \"y\", \"z\", \"y\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_object_list", "self", "x", "vs", "x", "y", "z", "s", "nominal", "vs", "_setup", "x", "objectproperty", "assert", "s", "x", "x", "y", "z", "y"], "doc_len": 26}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_object_dict", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_object_dict", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_object_dict(self, x):\n\n        vs = {\"a\": \"x\", \"b\": \"y\", \"c\": \"z\"}\n        s = Nominal(vs)._setup(x, ObjectProperty())\n        assert s(x) == [\"x\", \"z\", \"y\", \"z\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_object_dict", "self", "x", "vs", "a", "x", "b", "y", "c", "z", "s", "nominal", "vs", "_setup", "x", "objectproperty", "assert", "s", "x", "x", "z", "y", "z"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_object_order", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_object_order", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_object_order(self, x):\n\n        vs = [\"x\", \"y\", \"z\"]\n        s = Nominal(vs, order=[\"c\", \"a\", \"b\"])._setup(x, ObjectProperty())\n        assert s(x) == [\"y\", \"x\", \"z\", \"x\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_object_order", "self", "x", "vs", "x", "y", "z", "s", "nominal", "vs", "order", "c", "a", "b", "_setup", "x", "objectproperty", "assert", "s", "x", "y", "x", "z", "x"], "doc_len": 30}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_object_order_subset", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_object_order_subset", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_object_order_subset(self, x):\n\n        vs = [\"x\", \"y\"]\n        s = Nominal(vs, order=[\"a\", \"c\"])._setup(x, ObjectProperty())\n        assert s(x) == [\"x\", \"y\", None, \"y\"]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_object_order_subset", "self", "x", "vs", "x", "y", "s", "nominal", "vs", "order", "a", "c", "_setup", "x", "objectproperty", "assert", "s", "x", "x", "y", "none", "y"], "doc_len": 28}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_objects_that_are_weird", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_objects_that_are_weird", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_objects_that_are_weird(self, x):\n\n        vs = [(\"x\", 1), (None, None, 0), {}]\n        s = Nominal(vs)._setup(x, ObjectProperty())\n        assert s(x) == [vs[0], vs[1], vs[2], vs[1]]\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_objects_that_are_weird", "self", "x", "vs", "x", "1", "none", "none", "0", "s", "nominal", "vs", "_setup", "x", "objectproperty", "assert", "s", "x", "vs", "0", "vs", "1", "vs", "2", "vs", "1"], "doc_len": 32}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_alpha_default", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_alpha_default", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_alpha_default(self, x):\n\n        s = Nominal()._setup(x, Alpha())\n        assert_array_equal(s(x), [.95, .625, .3, .625])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_alpha_default", "self", "x", "s", "nominal", "_setup", "x", "alpha", "assert_array_equal", "s", "x", "95", "625", "3", "625"], "doc_len": 21}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_fill", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_fill", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_fill(self):\n\n        x = pd.Series([\"a\", \"a\", \"b\", \"a\"], name=\"x\")\n        s = Nominal()._setup(x, Fill())\n        assert_array_equal(s(x), [True, True, False, True])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_fill", "self", "x", "pd", "series", "a", "a", "b", "a", "name", "x", "s", "nominal", "_setup", "x", "fill", "assert_array_equal", "s", "x", "true", "true", "false", "true"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_fill_dict", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_fill_dict", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_fill_dict(self):\n\n        x = pd.Series([\"a\", \"a\", \"b\", \"a\"], name=\"x\")\n        vs = {\"a\": False, \"b\": True}\n        s = Nominal(vs)._setup(x, Fill())\n        assert_array_equal(s(x), [False, False, True, False])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_fill_dict", "self", "x", "pd", "series", "a", "a", "b", "a", "name", "x", "vs", "a", "false", "b", "true", "s", "nominal", "vs", "_setup", "x", "fill", "assert_array_equal", "s", "x", "false", "false", "true", "false"], "doc_len": 35}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_fill_nunique_warning", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_fill_nunique_warning", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_fill_nunique_warning(self):\n\n        x = pd.Series([\"a\", \"b\", \"c\", \"a\", \"b\"], name=\"x\")\n        with pytest.warns(UserWarning, match=\"The variable assigned to fill\"):\n            s = Nominal()._setup(x, Fill())\n        assert_array_equal(s(x), [True, False, True, True, False])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_fill_nunique_warning", "self", "x", "pd", "series", "a", "b", "c", "a", "b", "name", "x", "with", "pytest", "warns", "userwarning", "match", "the", "variable", "assigned", "to", "fill", "s", "nominal", "_setup", "x", "fill", "assert_array_equal", "s", "x", "true", "false", "true", "true", "false"], "doc_len": 41}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_defaults(self, x):\n\n        class MockProperty(IntervalProperty):\n            _default_range = (1, 2)\n\n        s = Nominal()._setup(x, MockProperty())\n        assert_array_equal(s(x), [2, 1.5, 1, 1.5])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_defaults", "self", "x", "class", "mockproperty", "intervalproperty", "_default_range", "1", "2", "s", "nominal", "_setup", "x", "mockproperty", "assert_array_equal", "s", "x", "2", "1", "5", "1", "1", "5"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_tuple", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_tuple", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_tuple(self, x):\n\n        s = Nominal((1, 2))._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [2, 1.5, 1, 1.5])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_tuple", "self", "x", "s", "nominal", "1", "2", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "2", "1", "5", "1", "1", "5"], "doc_len": 25}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_tuple_numeric", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_tuple_numeric", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_tuple_numeric(self, y):\n\n        s = Nominal((1, 2))._setup(y, IntervalProperty())\n        assert_array_equal(s(y), [1.5, 2, 1, 2])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_tuple_numeric", "self", "y", "s", "nominal", "1", "2", "_setup", "y", "intervalproperty", "assert_array_equal", "s", "y", "1", "5", "2", "1", "2"], "doc_len": 24}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_list", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_list", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_list(self, x):\n\n        vs = [2, 5, 4]\n        s = Nominal(vs)._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [2, 5, 4, 5])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_list", "self", "x", "vs", "2", "5", "4", "s", "nominal", "vs", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "2", "5", "4", "5"], "doc_len": 26}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_dict", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_dict", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_dict(self, x):\n\n        vs = {\"a\": 3, \"b\": 4, \"c\": 6}\n        s = Nominal(vs)._setup(x, IntervalProperty())\n        assert_array_equal(s(x), [3, 6, 4, 6])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_dict", "self", "x", "vs", "a", "3", "b", "4", "c", "6", "s", "nominal", "vs", "_setup", "x", "intervalproperty", "assert_array_equal", "s", "x", "3", "6", "4", "6"], "doc_len": 29}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_interval_with_transform", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_interval_with_transform", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_interval_with_transform(self, x):\n\n        class MockProperty(IntervalProperty):\n            _forward = np.square\n            _inverse = np.sqrt\n\n        s = Nominal((2, 4))._setup(x, MockProperty())\n        assert_array_equal(s(x), [4, np.sqrt(10), 2, np.sqrt(10)])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_interval_with_transform", "self", "x", "class", "mockproperty", "intervalproperty", "_forward", "np", "square", "_inverse", "np", "sqrt", "s", "nominal", "2", "4", "_setup", "x", "mockproperty", "assert_array_equal", "s", "x", "4", "np", "sqrt", "10", "2", "np", "sqrt", "10"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestNominal.test_empty_data", "file_path": "tests/_core/test_scales.py", "class_name": "TestNominal", "func_name": "test_empty_data", "text": "文件路径: tests/_core/test_scales.py, 类名: TestNominal\n    def test_empty_data(self):\n\n        x = pd.Series([], dtype=object, name=\"x\")\n        s = Nominal()._setup(x, Coordinate())\n        assert_array_equal(s(x), [])\n", "tokens": ["tests", "_core", "test_scales", "py", "testnominal", "def", "test_empty_data", "self", "x", "pd", "series", "dtype", "object", "name", "x", "s", "nominal", "_setup", "x", "coordinate", "assert_array_equal", "s", "x"], "doc_len": 23}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.t", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "t", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def t(self):\n        dates = pd.to_datetime([\"1972-09-27\", \"1975-06-24\", \"1980-12-14\"])\n        return pd.Series(dates, name=\"x\")\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "t", "self", "dates", "pd", "to_datetime", "1972", "09", "27", "1975", "06", "24", "1980", "12", "14", "return", "pd", "series", "dates", "name", "x"], "doc_len": 26}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.x", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "x", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def x(self, t):\n        return pd.Series(mpl.dates.date2num(t), name=t.name)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "x", "self", "t", "return", "pd", "series", "mpl", "dates", "date2num", "t", "name", "t", "name"], "doc_len": 19}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_coordinate_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_coordinate_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_coordinate_defaults(self, t, x):\n\n        s = Temporal()._setup(t, Coordinate())\n        assert_array_equal(s(t), x)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_coordinate_defaults", "self", "t", "x", "s", "temporal", "_setup", "t", "coordinate", "assert_array_equal", "s", "t", "x"], "doc_len": 19}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_interval_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_interval_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_interval_defaults(self, t, x):\n\n        s = Temporal()._setup(t, IntervalProperty())\n        normed = (x - x.min()) / (x.max() - x.min())\n        assert_array_equal(s(t), normed)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_interval_defaults", "self", "t", "x", "s", "temporal", "_setup", "t", "intervalproperty", "normed", "x", "x", "min", "x", "max", "x", "min", "assert_array_equal", "s", "t", "normed"], "doc_len": 27}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_interval_with_range", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_interval_with_range", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_interval_with_range(self, t, x):\n\n        values = (1, 3)\n        s = Temporal((1, 3))._setup(t, IntervalProperty())\n        normed = (x - x.min()) / (x.max() - x.min())\n        expected = normed * (values[1] - values[0]) + values[0]\n        assert_array_equal(s(t), expected)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_interval_with_range", "self", "t", "x", "values", "1", "3", "s", "temporal", "1", "3", "_setup", "t", "intervalproperty", "normed", "x", "x", "min", "x", "max", "x", "min", "expected", "normed", "values", "1", "values", "0", "values", "0", "assert_array_equal", "s", "t", "expected"], "doc_len": 40}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_interval_with_norm", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_interval_with_norm", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_interval_with_norm(self, t, x):\n\n        norm = t[1], t[2]\n        s = Temporal(norm=norm)._setup(t, IntervalProperty())\n        n = mpl.dates.date2num(norm)\n        normed = (x - n[0]) / (n[1] - n[0])\n        assert_array_equal(s(t), normed)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_interval_with_norm", "self", "t", "x", "norm", "t", "1", "t", "2", "s", "temporal", "norm", "norm", "_setup", "t", "intervalproperty", "n", "mpl", "dates", "date2num", "norm", "normed", "x", "n", "0", "n", "1", "n", "0", "assert_array_equal", "s", "t", "normed"], "doc_len": 39}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_color_defaults", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_color_defaults", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_color_defaults(self, t, x):\n\n        cmap = color_palette(\"ch:\", as_cmap=True)\n        s = Temporal()._setup(t, Color())\n        normed = (x - x.min()) / (x.max() - x.min())\n        assert_array_equal(s(t), cmap(normed)[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_color_defaults", "self", "t", "x", "cmap", "color_palette", "ch", "as_cmap", "true", "s", "temporal", "_setup", "t", "color", "normed", "x", "x", "min", "x", "max", "x", "min", "assert_array_equal", "s", "t", "cmap", "normed", "3", "fixme", "rgba"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_color_named_values", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_color_named_values", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_color_named_values(self, t, x):\n\n        name = \"viridis\"\n        cmap = color_palette(name, as_cmap=True)\n        s = Temporal(name)._setup(t, Color())\n        normed = (x - x.min()) / (x.max() - x.min())\n        assert_array_equal(s(t), cmap(normed)[:, :3])  # FIXME RGBA\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_color_named_values", "self", "t", "x", "name", "viridis", "cmap", "color_palette", "name", "as_cmap", "true", "s", "temporal", "name", "_setup", "t", "color", "normed", "x", "x", "min", "x", "max", "x", "min", "assert_array_equal", "s", "t", "cmap", "normed", "3", "fixme", "rgba"], "doc_len": 39}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_coordinate_axis", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_coordinate_axis", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_coordinate_axis(self, t, x):\n\n        ax = mpl.figure.Figure().subplots()\n        s = Temporal()._setup(t, Coordinate(), ax.xaxis)\n        assert_array_equal(s(t), x)\n        locator = ax.xaxis.get_major_locator()\n        formatter = ax.xaxis.get_major_formatter()\n        assert isinstance(locator, mpl.dates.AutoDateLocator)\n        assert isinstance(formatter, mpl.dates.AutoDateFormatter)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_coordinate_axis", "self", "t", "x", "ax", "mpl", "figure", "figure", "subplots", "s", "temporal", "_setup", "t", "coordinate", "ax", "xaxis", "assert_array_equal", "s", "t", "x", "locator", "ax", "xaxis", "get_major_locator", "formatter", "ax", "xaxis", "get_major_formatter", "assert", "isinstance", "locator", "mpl", "dates", "autodatelocator", "assert", "isinstance", "formatter", "mpl", "dates", "autodateformatter"], "doc_len": 46}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_tick_locator", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_tick_locator", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_tick_locator(self, t):\n\n        locator = mpl.dates.YearLocator(month=3, day=15)\n        s = Temporal().tick(locator)\n        a = PseudoAxis(s._setup(t, Coordinate())._matplotlib_scale)\n        a.set_view_interval(0, 365)\n        assert 73 in a.major.locator()\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_tick_locator", "self", "t", "locator", "mpl", "dates", "yearlocator", "month", "3", "day", "15", "s", "temporal", "tick", "locator", "a", "pseudoaxis", "s", "_setup", "t", "coordinate", "_matplotlib_scale", "a", "set_view_interval", "0", "365", "assert", "73", "in", "a", "major", "locator"], "doc_len": 38}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_tick_upto", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_tick_upto", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_tick_upto(self, t, x):\n\n        n = 8\n        ax = mpl.figure.Figure().subplots()\n        Temporal().tick(upto=n)._setup(t, Coordinate(), ax.xaxis)\n        locator = ax.xaxis.get_major_locator()\n        assert set(locator.maxticks.values()) == {n}\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_tick_upto", "self", "t", "x", "n", "8", "ax", "mpl", "figure", "figure", "subplots", "temporal", "tick", "upto", "n", "_setup", "t", "coordinate", "ax", "xaxis", "locator", "ax", "xaxis", "get_major_locator", "assert", "set", "locator", "maxticks", "values", "n"], "doc_len": 36}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_label_formatter", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_label_formatter", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_label_formatter(self, t):\n\n        formatter = mpl.dates.DateFormatter(\"%Y\")\n        s = Temporal().label(formatter)\n        a = PseudoAxis(s._setup(t, Coordinate())._matplotlib_scale)\n        a.set_view_interval(10, 1000)\n        label, = a.major.formatter.format_ticks([100])\n        assert label == \"1970\"\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_label_formatter", "self", "t", "formatter", "mpl", "dates", "dateformatter", "y", "s", "temporal", "label", "formatter", "a", "pseudoaxis", "s", "_setup", "t", "coordinate", "_matplotlib_scale", "a", "set_view_interval", "10", "1000", "label", "a", "major", "formatter", "format_ticks", "100", "assert", "label", "1970"], "doc_len": 38}
{"doc_id": "tests/_core/test_scales.py::TestTemporal.test_label_concise", "file_path": "tests/_core/test_scales.py", "class_name": "TestTemporal", "func_name": "test_label_concise", "text": "文件路径: tests/_core/test_scales.py, 类名: TestTemporal\n    def test_label_concise(self, t, x):\n\n        ax = mpl.figure.Figure().subplots()\n        Temporal().label(concise=True)._setup(t, Coordinate(), ax.xaxis)\n        formatter = ax.xaxis.get_major_formatter()\n        assert isinstance(formatter, mpl.dates.ConciseDateFormatter)\n", "tokens": ["tests", "_core", "test_scales", "py", "testtemporal", "def", "test_label_concise", "self", "t", "x", "ax", "mpl", "figure", "figure", "subplots", "temporal", "label", "concise", "true", "_setup", "t", "coordinate", "ax", "xaxis", "formatter", "ax", "xaxis", "get_major_formatter", "assert", "isinstance", "formatter", "mpl", "dates", "concisedateformatter"], "doc_len": 34}
{"doc_id": "tests/_core/test_subplots.py::TestSpecificationChecks.test_both_facets_and_wrap", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSpecificationChecks", "func_name": "test_both_facets_and_wrap", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSpecificationChecks\n    def test_both_facets_and_wrap(self):\n\n        err = \"Cannot wrap facets when specifying both `col` and `row`.\"\n        facet_spec = {\"wrap\": 3, \"variables\": {\"col\": \"a\", \"row\": \"b\"}}\n        with pytest.raises(RuntimeError, match=err):\n            Subplots({}, facet_spec, {})\n", "tokens": ["tests", "_core", "test_subplots", "py", "testspecificationchecks", "def", "test_both_facets_and_wrap", "self", "err", "cannot", "wrap", "facets", "when", "specifying", "both", "col", "and", "row", "facet_spec", "wrap", "3", "variables", "col", "a", "row", "b", "with", "pytest", "raises", "runtimeerror", "match", "err", "subplots", "facet_spec"], "doc_len": 34}
{"doc_id": "tests/_core/test_subplots.py::TestSpecificationChecks.test_cross_xy_pairing_and_wrap", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSpecificationChecks", "func_name": "test_cross_xy_pairing_and_wrap", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSpecificationChecks\n    def test_cross_xy_pairing_and_wrap(self):\n\n        err = \"Cannot wrap subplots when pairing on both `x` and `y`.\"\n        pair_spec = {\"wrap\": 3, \"structure\": {\"x\": [\"a\", \"b\"], \"y\": [\"y\", \"z\"]}}\n        with pytest.raises(RuntimeError, match=err):\n            Subplots({}, {}, pair_spec)\n", "tokens": ["tests", "_core", "test_subplots", "py", "testspecificationchecks", "def", "test_cross_xy_pairing_and_wrap", "self", "err", "cannot", "wrap", "subplots", "when", "pairing", "on", "both", "x", "and", "y", "pair_spec", "wrap", "3", "structure", "x", "a", "b", "y", "y", "z", "with", "pytest", "raises", "runtimeerror", "match", "err", "subplots", "pair_spec"], "doc_len": 37}
{"doc_id": "tests/_core/test_subplots.py::TestSpecificationChecks.test_col_facets_and_x_pairing", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSpecificationChecks", "func_name": "test_col_facets_and_x_pairing", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSpecificationChecks\n    def test_col_facets_and_x_pairing(self):\n\n        err = \"Cannot facet the columns while pairing on `x`.\"\n        facet_spec = {\"variables\": {\"col\": \"a\"}}\n        pair_spec = {\"structure\": {\"x\": [\"x\", \"y\"]}}\n        with pytest.raises(RuntimeError, match=err):\n            Subplots({}, facet_spec, pair_spec)\n", "tokens": ["tests", "_core", "test_subplots", "py", "testspecificationchecks", "def", "test_col_facets_and_x_pairing", "self", "err", "cannot", "facet", "the", "columns", "while", "pairing", "on", "x", "facet_spec", "variables", "col", "a", "pair_spec", "structure", "x", "x", "y", "with", "pytest", "raises", "runtimeerror", "match", "err", "subplots", "facet_spec", "pair_spec"], "doc_len": 35}
{"doc_id": "tests/_core/test_subplots.py::TestSpecificationChecks.test_wrapped_columns_and_y_pairing", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSpecificationChecks", "func_name": "test_wrapped_columns_and_y_pairing", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSpecificationChecks\n    def test_wrapped_columns_and_y_pairing(self):\n\n        err = \"Cannot wrap the columns while pairing on `y`.\"\n        facet_spec = {\"variables\": {\"col\": \"a\"}, \"wrap\": 2}\n        pair_spec = {\"structure\": {\"y\": [\"x\", \"y\"]}}\n        with pytest.raises(RuntimeError, match=err):\n            Subplots({}, facet_spec, pair_spec)\n", "tokens": ["tests", "_core", "test_subplots", "py", "testspecificationchecks", "def", "test_wrapped_columns_and_y_pairing", "self", "err", "cannot", "wrap", "the", "columns", "while", "pairing", "on", "y", "facet_spec", "variables", "col", "a", "wrap", "2", "pair_spec", "structure", "y", "x", "y", "with", "pytest", "raises", "runtimeerror", "match", "err", "subplots", "facet_spec", "pair_spec"], "doc_len": 37}
{"doc_id": "tests/_core/test_subplots.py::TestSpecificationChecks.test_wrapped_x_pairing_and_facetd_rows", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSpecificationChecks", "func_name": "test_wrapped_x_pairing_and_facetd_rows", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSpecificationChecks\n    def test_wrapped_x_pairing_and_facetd_rows(self):\n\n        err = \"Cannot wrap the columns while faceting the rows.\"\n        facet_spec = {\"variables\": {\"row\": \"a\"}}\n        pair_spec = {\"structure\": {\"x\": [\"x\", \"y\"]}, \"wrap\": 2}\n        with pytest.raises(RuntimeError, match=err):\n            Subplots({}, facet_spec, pair_spec)\n", "tokens": ["tests", "_core", "test_subplots", "py", "testspecificationchecks", "def", "test_wrapped_x_pairing_and_facetd_rows", "self", "err", "cannot", "wrap", "the", "columns", "while", "faceting", "the", "rows", "facet_spec", "variables", "row", "a", "pair_spec", "structure", "x", "x", "y", "wrap", "2", "with", "pytest", "raises", "runtimeerror", "match", "err", "subplots", "facet_spec", "pair_spec"], "doc_len": 37}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_single_subplot", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_single_subplot", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_single_subplot(self):\n\n        s = Subplots({}, {}, {})\n\n        assert s.n_subplots == 1\n        assert s.subplot_spec[\"ncols\"] == 1\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_single_subplot", "self", "s", "subplots", "assert", "s", "n_subplots", "1", "assert", "s", "subplot_spec", "ncols", "1", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 36}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_single_facet", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_single_facet", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_single_facet(self):\n\n        key = \"a\"\n        order = list(\"abc\")\n        spec = {\"variables\": {\"col\": key}, \"structure\": {\"col\": order}}\n        s = Subplots({}, spec, {})\n\n        assert s.n_subplots == len(order)\n        assert s.subplot_spec[\"ncols\"] == len(order)\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_single_facet", "self", "key", "a", "order", "list", "abc", "spec", "variables", "col", "key", "structure", "col", "order", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "order", "assert", "s", "subplot_spec", "ncols", "len", "order", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 51}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_two_facets", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_two_facets", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_two_facets(self):\n\n        col_key = \"a\"\n        row_key = \"b\"\n        col_order = list(\"xy\")\n        row_order = list(\"xyz\")\n        spec = {\n            \"variables\": {\"col\": col_key, \"row\": row_key},\n            \"structure\": {\"col\": col_order, \"row\": row_order},\n\n        }\n        s = Subplots({}, spec, {})\n\n        assert s.n_subplots == len(col_order) * len(row_order)\n        assert s.subplot_spec[\"ncols\"] == len(col_order)\n        assert s.subplot_spec[\"nrows\"] == len(row_order)\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_two_facets", "self", "col_key", "a", "row_key", "b", "col_order", "list", "xy", "row_order", "list", "xyz", "spec", "variables", "col", "col_key", "row", "row_key", "structure", "col", "col_order", "row", "row_order", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "col_order", "len", "row_order", "assert", "s", "subplot_spec", "ncols", "len", "col_order", "assert", "s", "subplot_spec", "nrows", "len", "row_order", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 63}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_col_facet_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_col_facet_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_col_facet_wrapped(self):\n\n        key = \"b\"\n        wrap = 3\n        order = list(\"abcde\")\n        spec = {\"variables\": {\"col\": key}, \"structure\": {\"col\": order}, \"wrap\": wrap}\n        s = Subplots({}, spec, {})\n\n        assert s.n_subplots == len(order)\n        assert s.subplot_spec[\"ncols\"] == wrap\n        assert s.subplot_spec[\"nrows\"] == len(order) // wrap + 1\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_col_facet_wrapped", "self", "key", "b", "wrap", "3", "order", "list", "abcde", "spec", "variables", "col", "key", "structure", "col", "order", "wrap", "wrap", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "order", "assert", "s", "subplot_spec", "ncols", "wrap", "assert", "s", "subplot_spec", "nrows", "len", "order", "wrap", "1", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 57}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_row_facet_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_row_facet_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_row_facet_wrapped(self):\n\n        key = \"b\"\n        wrap = 3\n        order = list(\"abcde\")\n        spec = {\"variables\": {\"row\": key}, \"structure\": {\"row\": order}, \"wrap\": wrap}\n        s = Subplots({}, spec, {})\n\n        assert s.n_subplots == len(order)\n        assert s.subplot_spec[\"ncols\"] == len(order) // wrap + 1\n        assert s.subplot_spec[\"nrows\"] == wrap\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_row_facet_wrapped", "self", "key", "b", "wrap", "3", "order", "list", "abcde", "spec", "variables", "row", "key", "structure", "row", "order", "wrap", "wrap", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "order", "assert", "s", "subplot_spec", "ncols", "len", "order", "wrap", "1", "assert", "s", "subplot_spec", "nrows", "wrap", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 57}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_col_facet_wrapped_single_row", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_col_facet_wrapped_single_row", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_col_facet_wrapped_single_row(self):\n\n        key = \"b\"\n        order = list(\"abc\")\n        wrap = len(order) + 2\n        spec = {\"variables\": {\"col\": key}, \"structure\": {\"col\": order}, \"wrap\": wrap}\n        s = Subplots({}, spec, {})\n\n        assert s.n_subplots == len(order)\n        assert s.subplot_spec[\"ncols\"] == len(order)\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_col_facet_wrapped_single_row", "self", "key", "b", "order", "list", "abc", "wrap", "len", "order", "2", "spec", "variables", "col", "key", "structure", "col", "order", "wrap", "wrap", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "order", "assert", "s", "subplot_spec", "ncols", "len", "order", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 57}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_x_and_y_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_x_and_y_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_x_and_y_paired(self):\n\n        x = [\"x\", \"y\", \"z\"]\n        y = [\"a\", \"b\"]\n        s = Subplots({}, {}, {\"structure\": {\"x\": x, \"y\": y}})\n\n        assert s.n_subplots == len(x) * len(y)\n        assert s.subplot_spec[\"ncols\"] == len(x)\n        assert s.subplot_spec[\"nrows\"] == len(y)\n        assert s.subplot_spec[\"sharex\"] == \"col\"\n        assert s.subplot_spec[\"sharey\"] == \"row\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_x_and_y_paired", "self", "x", "x", "y", "z", "y", "a", "b", "s", "subplots", "structure", "x", "x", "y", "y", "assert", "s", "n_subplots", "len", "x", "len", "y", "assert", "s", "subplot_spec", "ncols", "len", "x", "assert", "s", "subplot_spec", "nrows", "len", "y", "assert", "s", "subplot_spec", "sharex", "col", "assert", "s", "subplot_spec", "sharey", "row"], "doc_len": 51}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_x_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_x_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_x_paired(self):\n\n        x = [\"x\", \"y\", \"z\"]\n        s = Subplots({}, {}, {\"structure\": {\"x\": x}})\n\n        assert s.n_subplots == len(x)\n        assert s.subplot_spec[\"ncols\"] == len(x)\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] == \"col\"\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_x_paired", "self", "x", "x", "y", "z", "s", "subplots", "structure", "x", "x", "assert", "s", "n_subplots", "len", "x", "assert", "s", "subplot_spec", "ncols", "len", "x", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "col", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 44}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_y_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_y_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_y_paired(self):\n\n        y = [\"x\", \"y\", \"z\"]\n        s = Subplots({}, {}, {\"structure\": {\"y\": y}})\n\n        assert s.n_subplots == len(y)\n        assert s.subplot_spec[\"ncols\"] == 1\n        assert s.subplot_spec[\"nrows\"] == len(y)\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] == \"row\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_y_paired", "self", "y", "x", "y", "z", "s", "subplots", "structure", "y", "y", "assert", "s", "n_subplots", "len", "y", "assert", "s", "subplot_spec", "ncols", "1", "assert", "s", "subplot_spec", "nrows", "len", "y", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "row"], "doc_len": 44}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_x_paired_and_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_x_paired_and_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_x_paired_and_wrapped(self):\n\n        x = [\"a\", \"b\", \"x\", \"y\", \"z\"]\n        wrap = 3\n        s = Subplots({}, {}, {\"structure\": {\"x\": x}, \"wrap\": wrap})\n\n        assert s.n_subplots == len(x)\n        assert s.subplot_spec[\"ncols\"] == wrap\n        assert s.subplot_spec[\"nrows\"] == len(x) // wrap + 1\n        assert s.subplot_spec[\"sharex\"] is False\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_x_paired_and_wrapped", "self", "x", "a", "b", "x", "y", "z", "wrap", "3", "s", "subplots", "structure", "x", "x", "wrap", "wrap", "assert", "s", "n_subplots", "len", "x", "assert", "s", "subplot_spec", "ncols", "wrap", "assert", "s", "subplot_spec", "nrows", "len", "x", "wrap", "1", "assert", "s", "subplot_spec", "sharex", "is", "false", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 53}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_y_paired_and_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_y_paired_and_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_y_paired_and_wrapped(self):\n\n        y = [\"a\", \"b\", \"x\", \"y\", \"z\"]\n        wrap = 2\n        s = Subplots({}, {}, {\"structure\": {\"y\": y}, \"wrap\": wrap})\n\n        assert s.n_subplots == len(y)\n        assert s.subplot_spec[\"ncols\"] == len(y) // wrap + 1\n        assert s.subplot_spec[\"nrows\"] == wrap\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is False\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_y_paired_and_wrapped", "self", "y", "a", "b", "x", "y", "z", "wrap", "2", "s", "subplots", "structure", "y", "y", "wrap", "wrap", "assert", "s", "n_subplots", "len", "y", "assert", "s", "subplot_spec", "ncols", "len", "y", "wrap", "1", "assert", "s", "subplot_spec", "nrows", "wrap", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "false"], "doc_len": 53}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_y_paired_and_wrapped_single_row", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_y_paired_and_wrapped_single_row", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_y_paired_and_wrapped_single_row(self):\n\n        y = [\"x\", \"y\", \"z\"]\n        wrap = 1\n        s = Subplots({}, {}, {\"structure\": {\"y\": y}, \"wrap\": wrap})\n\n        assert s.n_subplots == len(y)\n        assert s.subplot_spec[\"ncols\"] == len(y)\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] is False\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_y_paired_and_wrapped_single_row", "self", "y", "x", "y", "z", "wrap", "1", "s", "subplots", "structure", "y", "y", "wrap", "wrap", "assert", "s", "n_subplots", "len", "y", "assert", "s", "subplot_spec", "ncols", "len", "y", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "is", "false"], "doc_len": 49}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_col_faceted_y_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_col_faceted_y_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_col_faceted_y_paired(self):\n\n        y = [\"x\", \"y\", \"z\"]\n        key = \"a\"\n        order = list(\"abc\")\n        facet_spec = {\"variables\": {\"col\": key}, \"structure\": {\"col\": order}}\n        pair_spec = {\"structure\": {\"y\": y}}\n        s = Subplots({}, facet_spec, pair_spec)\n\n        assert s.n_subplots == len(order) * len(y)\n        assert s.subplot_spec[\"ncols\"] == len(order)\n        assert s.subplot_spec[\"nrows\"] == len(y)\n        assert s.subplot_spec[\"sharex\"] is True\n        assert s.subplot_spec[\"sharey\"] == \"row\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_col_faceted_y_paired", "self", "y", "x", "y", "z", "key", "a", "order", "list", "abc", "facet_spec", "variables", "col", "key", "structure", "col", "order", "pair_spec", "structure", "y", "y", "s", "subplots", "facet_spec", "pair_spec", "assert", "s", "n_subplots", "len", "order", "len", "y", "assert", "s", "subplot_spec", "ncols", "len", "order", "assert", "s", "subplot_spec", "nrows", "len", "y", "assert", "s", "subplot_spec", "sharex", "is", "true", "assert", "s", "subplot_spec", "sharey", "row"], "doc_len": 62}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_row_faceted_x_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_row_faceted_x_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_row_faceted_x_paired(self):\n\n        x = [\"f\", \"s\"]\n        key = \"a\"\n        order = list(\"abc\")\n        facet_spec = {\"variables\": {\"row\": key}, \"structure\": {\"row\": order}}\n        pair_spec = {\"structure\": {\"x\": x}}\n        s = Subplots({}, facet_spec, pair_spec)\n\n        assert s.n_subplots == len(order) * len(x)\n        assert s.subplot_spec[\"ncols\"] == len(x)\n        assert s.subplot_spec[\"nrows\"] == len(order)\n        assert s.subplot_spec[\"sharex\"] == \"col\"\n        assert s.subplot_spec[\"sharey\"] is True\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_row_faceted_x_paired", "self", "x", "f", "s", "key", "a", "order", "list", "abc", "facet_spec", "variables", "row", "key", "structure", "row", "order", "pair_spec", "structure", "x", "x", "s", "subplots", "facet_spec", "pair_spec", "assert", "s", "n_subplots", "len", "order", "len", "x", "assert", "s", "subplot_spec", "ncols", "len", "x", "assert", "s", "subplot_spec", "nrows", "len", "order", "assert", "s", "subplot_spec", "sharex", "col", "assert", "s", "subplot_spec", "sharey", "is", "true"], "doc_len": 61}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_x_any_y_paired_non_cross", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_x_any_y_paired_non_cross", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_x_any_y_paired_non_cross(self):\n\n        x = [\"a\", \"b\", \"c\"]\n        y = [\"x\", \"y\", \"z\"]\n        spec = {\"structure\": {\"x\": x, \"y\": y}, \"cross\": False}\n        s = Subplots({}, {}, spec)\n\n        assert s.n_subplots == len(x)\n        assert s.subplot_spec[\"ncols\"] == len(y)\n        assert s.subplot_spec[\"nrows\"] == 1\n        assert s.subplot_spec[\"sharex\"] is False\n        assert s.subplot_spec[\"sharey\"] is False\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_x_any_y_paired_non_cross", "self", "x", "a", "b", "c", "y", "x", "y", "z", "spec", "structure", "x", "x", "y", "y", "cross", "false", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "x", "assert", "s", "subplot_spec", "ncols", "len", "y", "assert", "s", "subplot_spec", "nrows", "1", "assert", "s", "subplot_spec", "sharex", "is", "false", "assert", "s", "subplot_spec", "sharey", "is", "false"], "doc_len": 55}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_x_any_y_paired_non_cross_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_x_any_y_paired_non_cross_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_x_any_y_paired_non_cross_wrapped(self):\n\n        x = [\"a\", \"b\", \"c\"]\n        y = [\"x\", \"y\", \"z\"]\n        wrap = 2\n        spec = {\"structure\": {\"x\": x, \"y\": y}, \"cross\": False, \"wrap\": wrap}\n        s = Subplots({}, {}, spec)\n\n        assert s.n_subplots == len(x)\n        assert s.subplot_spec[\"ncols\"] == wrap\n        assert s.subplot_spec[\"nrows\"] == len(x) // wrap + 1\n        assert s.subplot_spec[\"sharex\"] is False\n        assert s.subplot_spec[\"sharey\"] is False\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_x_any_y_paired_non_cross_wrapped", "self", "x", "a", "b", "c", "y", "x", "y", "z", "wrap", "2", "spec", "structure", "x", "x", "y", "y", "cross", "false", "wrap", "wrap", "s", "subplots", "spec", "assert", "s", "n_subplots", "len", "x", "assert", "s", "subplot_spec", "ncols", "wrap", "assert", "s", "subplot_spec", "nrows", "len", "x", "wrap", "1", "assert", "s", "subplot_spec", "sharex", "is", "false", "assert", "s", "subplot_spec", "sharey", "is", "false"], "doc_len": 61}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotSpec.test_forced_unshared_facets", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotSpec", "func_name": "test_forced_unshared_facets", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotSpec\n    def test_forced_unshared_facets(self):\n\n        s = Subplots({\"sharex\": False, \"sharey\": \"row\"}, {}, {})\n        assert s.subplot_spec[\"sharex\"] is False\n        assert s.subplot_spec[\"sharey\"] == \"row\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotspec", "def", "test_forced_unshared_facets", "self", "s", "subplots", "sharex", "false", "sharey", "row", "assert", "s", "subplot_spec", "sharex", "is", "false", "assert", "s", "subplot_spec", "sharey", "row"], "doc_len": 25}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_single_subplot", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_single_subplot", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_single_subplot(self):\n\n        s = Subplots({}, {}, {})\n        f = s.init_figure({}, {})\n\n        assert len(s) == 1\n        for i, e in enumerate(s):\n            for side in [\"left\", \"right\", \"bottom\", \"top\"]:\n                assert e[side]\n            for dim in [\"col\", \"row\"]:\n                assert e[dim] is None\n            for axis in \"xy\":\n                assert e[axis] == axis\n            assert e[\"ax\"] == f.axes[i]\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_single_subplot", "self", "s", "subplots", "f", "s", "init_figure", "assert", "len", "s", "1", "for", "i", "e", "in", "enumerate", "s", "for", "side", "in", "left", "right", "bottom", "top", "assert", "e", "side", "for", "dim", "in", "col", "row", "assert", "e", "dim", "is", "none", "for", "axis", "in", "xy", "assert", "e", "axis", "axis", "assert", "e", "ax", "f", "axes", "i"], "doc_len": 57}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_single_facet_dim", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_single_facet_dim", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_single_facet_dim(self, dim):\n\n        key = \"a\"\n        order = list(\"abc\")\n        spec = {\"variables\": {dim: key}, \"structure\": {dim: order}}\n        s = Subplots({}, spec, {})\n        s.init_figure(spec, {})\n\n        assert len(s) == len(order)\n\n        for i, e in enumerate(s):\n            assert e[dim] == order[i]\n            for axis in \"xy\":\n                assert e[axis] == axis\n            assert e[\"top\"] == (dim == \"col\" or i == 0)\n            assert e[\"bottom\"] == (dim == \"col\" or i == len(order) - 1)\n            assert e[\"left\"] == (dim == \"row\" or i == 0)\n            assert e[\"right\"] == (dim == \"row\" or i == len(order) - 1)\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_single_facet_dim", "self", "dim", "key", "a", "order", "list", "abc", "spec", "variables", "dim", "key", "structure", "dim", "order", "s", "subplots", "spec", "s", "init_figure", "spec", "assert", "len", "s", "len", "order", "for", "i", "e", "in", "enumerate", "s", "assert", "e", "dim", "order", "i", "for", "axis", "in", "xy", "assert", "e", "axis", "axis", "assert", "e", "top", "dim", "col", "or", "i", "0", "assert", "e", "bottom", "dim", "col", "or", "i", "len", "order", "1", "assert", "e", "left", "dim", "row", "or", "i", "0", "assert", "e", "right", "dim", "row", "or", "i", "len", "order", "1"], "doc_len": 87}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_single_facet_dim_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_single_facet_dim_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_single_facet_dim_wrapped(self, dim):\n\n        key = \"b\"\n        order = list(\"abc\")\n        wrap = len(order) - 1\n        spec = {\"variables\": {dim: key}, \"structure\": {dim: order}, \"wrap\": wrap}\n        s = Subplots({}, spec, {})\n        s.init_figure(spec, {})\n\n        assert len(s) == len(order)\n\n        for i, e in enumerate(s):\n            assert e[dim] == order[i]\n            for axis in \"xy\":\n                assert e[axis] == axis\n\n            sides = {\n                \"col\": [\"top\", \"bottom\", \"left\", \"right\"],\n                \"row\": [\"left\", \"right\", \"top\", \"bottom\"],\n            }\n            tests = (\n                i < wrap,\n                i >= wrap or i >= len(s) % wrap,\n                i % wrap == 0,\n                i % wrap == wrap - 1 or i + 1 == len(s),\n            )\n\n            for side, expected in zip(sides[dim], tests):\n                assert e[side] == expected\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_single_facet_dim_wrapped", "self", "dim", "key", "b", "order", "list", "abc", "wrap", "len", "order", "1", "spec", "variables", "dim", "key", "structure", "dim", "order", "wrap", "wrap", "s", "subplots", "spec", "s", "init_figure", "spec", "assert", "len", "s", "len", "order", "for", "i", "e", "in", "enumerate", "s", "assert", "e", "dim", "order", "i", "for", "axis", "in", "xy", "assert", "e", "axis", "axis", "sides", "col", "top", "bottom", "left", "right", "row", "left", "right", "top", "bottom", "tests", "i", "wrap", "i", "wrap", "or", "i", "len", "s", "wrap", "i", "wrap", "0", "i", "wrap", "wrap", "1", "or", "i", "1", "len", "s", "for", "side", "expected", "in", "zip", "sides", "dim", "tests", "assert", "e", "side", "expected"], "doc_len": 102}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_both_facet_dims", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_both_facet_dims", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_both_facet_dims(self):\n\n        col = \"a\"\n        row = \"b\"\n        col_order = list(\"ab\")\n        row_order = list(\"xyz\")\n        facet_spec = {\n            \"variables\": {\"col\": col, \"row\": row},\n            \"structure\": {\"col\": col_order, \"row\": row_order},\n        }\n        s = Subplots({}, facet_spec, {})\n        s.init_figure(facet_spec, {})\n\n        n_cols = len(col_order)\n        n_rows = len(row_order)\n        assert len(s) == n_cols * n_rows\n        es = list(s)\n\n        for e in es[:n_cols]:\n            assert e[\"top\"]\n        for e in es[::n_cols]:\n            assert e[\"left\"]\n        for e in es[n_cols - 1::n_cols]:\n            assert e[\"right\"]\n        for e in es[-n_cols:]:\n            assert e[\"bottom\"]\n\n        for e, (row_, col_) in zip(es, itertools.product(row_order, col_order)):\n            assert e[\"col\"] == col_\n            assert e[\"row\"] == row_\n\n        for e in es:\n            assert e[\"x\"] == \"x\"\n            assert e[\"y\"] == \"y\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_both_facet_dims", "self", "col", "a", "row", "b", "col_order", "list", "ab", "row_order", "list", "xyz", "facet_spec", "variables", "col", "col", "row", "row", "structure", "col", "col_order", "row", "row_order", "s", "subplots", "facet_spec", "s", "init_figure", "facet_spec", "n_cols", "len", "col_order", "n_rows", "len", "row_order", "assert", "len", "s", "n_cols", "n_rows", "es", "list", "s", "for", "e", "in", "es", "n_cols", "assert", "e", "top", "for", "e", "in", "es", "n_cols", "assert", "e", "left", "for", "e", "in", "es", "n_cols", "1", "n_cols", "assert", "e", "right", "for", "e", "in", "es", "n_cols", "assert", "e", "bottom", "for", "e", "row_", "col_", "in", "zip", "es", "itertools", "product", "row_order", "col_order", "assert", "e", "col", "col_", "assert", "e", "row", "row_", "for", "e", "in", "es", "assert", "e", "x", "x", "assert", "e", "y", "y"], "doc_len": 114}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_single_paired_var", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_single_paired_var", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_single_paired_var(self, var):\n\n        other_var = {\"x\": \"y\", \"y\": \"x\"}[var]\n        pairings = [\"x\", \"y\", \"z\"]\n        pair_spec = {\n            \"variables\": {f\"{var}{i}\": v for i, v in enumerate(pairings)},\n            \"structure\": {var: [f\"{var}{i}\" for i, _ in enumerate(pairings)]},\n        }\n\n        s = Subplots({}, {}, pair_spec)\n        s.init_figure(pair_spec)\n\n        assert len(s) == len(pair_spec[\"structure\"][var])\n\n        for i, e in enumerate(s):\n            assert e[var] == f\"{var}{i}\"\n            assert e[other_var] == other_var\n            assert e[\"col\"] is e[\"row\"] is None\n\n        tests = i == 0, True, True, i == len(s) - 1\n        sides = {\n            \"x\": [\"left\", \"right\", \"top\", \"bottom\"],\n            \"y\": [\"top\", \"bottom\", \"left\", \"right\"],\n        }\n\n        for side, expected in zip(sides[var], tests):\n            assert e[side] == expected\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_single_paired_var", "self", "var", "other_var", "x", "y", "y", "x", "var", "pairings", "x", "y", "z", "pair_spec", "variables", "f", "var", "i", "v", "for", "i", "v", "in", "enumerate", "pairings", "structure", "var", "f", "var", "i", "for", "i", "_", "in", "enumerate", "pairings", "s", "subplots", "pair_spec", "s", "init_figure", "pair_spec", "assert", "len", "s", "len", "pair_spec", "structure", "var", "for", "i", "e", "in", "enumerate", "s", "assert", "e", "var", "f", "var", "i", "assert", "e", "other_var", "other_var", "assert", "e", "col", "is", "e", "row", "is", "none", "tests", "i", "0", "true", "true", "i", "len", "s", "1", "sides", "x", "left", "right", "top", "bottom", "y", "top", "bottom", "left", "right", "for", "side", "expected", "in", "zip", "sides", "var", "tests", "assert", "e", "side", "expected"], "doc_len": 111}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_single_paired_var_wrapped", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_single_paired_var_wrapped", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_single_paired_var_wrapped(self, var):\n\n        other_var = {\"x\": \"y\", \"y\": \"x\"}[var]\n        pairings = [\"x\", \"y\", \"z\", \"a\", \"b\"]\n        wrap = len(pairings) - 2\n        pair_spec = {\n            \"variables\": {f\"{var}{i}\": val for i, val in enumerate(pairings)},\n            \"structure\": {var: [f\"{var}{i}\" for i, _ in enumerate(pairings)]},\n            \"wrap\": wrap\n        }\n        s = Subplots({}, {}, pair_spec)\n        s.init_figure(pair_spec)\n\n        assert len(s) == len(pairings)\n\n        for i, e in enumerate(s):\n            assert e[var] == f\"{var}{i}\"\n            assert e[other_var] == other_var\n            assert e[\"col\"] is e[\"row\"] is None\n\n            tests = (\n                i < wrap,\n                i >= wrap or i >= len(s) % wrap,\n                i % wrap == 0,\n                i % wrap == wrap - 1 or i + 1 == len(s),\n            )\n            sides = {\n                \"x\": [\"top\", \"bottom\", \"left\", \"right\"],\n                \"y\": [\"left\", \"right\", \"top\", \"bottom\"],\n            }\n            for side, expected in zip(sides[var], tests):\n                assert e[side] == expected\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_single_paired_var_wrapped", "self", "var", "other_var", "x", "y", "y", "x", "var", "pairings", "x", "y", "z", "a", "b", "wrap", "len", "pairings", "2", "pair_spec", "variables", "f", "var", "i", "val", "for", "i", "val", "in", "enumerate", "pairings", "structure", "var", "f", "var", "i", "for", "i", "_", "in", "enumerate", "pairings", "wrap", "wrap", "s", "subplots", "pair_spec", "s", "init_figure", "pair_spec", "assert", "len", "s", "len", "pairings", "for", "i", "e", "in", "enumerate", "s", "assert", "e", "var", "f", "var", "i", "assert", "e", "other_var", "other_var", "assert", "e", "col", "is", "e", "row", "is", "none", "tests", "i", "wrap", "i", "wrap", "or", "i", "len", "s", "wrap", "i", "wrap", "0", "i", "wrap", "wrap", "1", "or", "i", "1", "len", "s", "sides", "x", "top", "bottom", "left", "right", "y", "left", "right", "top", "bottom", "for", "side", "expected", "in", "zip", "sides", "var", "tests", "assert", "e", "side", "expected"], "doc_len": 130}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_both_paired_variables", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_both_paired_variables", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_both_paired_variables(self):\n\n        x = [\"x0\", \"x1\"]\n        y = [\"y0\", \"y1\", \"y2\"]\n        pair_spec = {\"structure\": {\"x\": x, \"y\": y}}\n        s = Subplots({}, {}, pair_spec)\n        s.init_figure(pair_spec)\n\n        n_cols = len(x)\n        n_rows = len(y)\n        assert len(s) == n_cols * n_rows\n        es = list(s)\n\n        for e in es[:n_cols]:\n            assert e[\"top\"]\n        for e in es[::n_cols]:\n            assert e[\"left\"]\n        for e in es[n_cols - 1::n_cols]:\n            assert e[\"right\"]\n        for e in es[-n_cols:]:\n            assert e[\"bottom\"]\n\n        for e in es:\n            assert e[\"col\"] is e[\"row\"] is None\n\n        for i in range(len(y)):\n            for j in range(len(x)):\n                e = es[i * len(x) + j]\n                assert e[\"x\"] == f\"x{j}\"\n                assert e[\"y\"] == f\"y{i}\"\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_both_paired_variables", "self", "x", "x0", "x1", "y", "y0", "y1", "y2", "pair_spec", "structure", "x", "x", "y", "y", "s", "subplots", "pair_spec", "s", "init_figure", "pair_spec", "n_cols", "len", "x", "n_rows", "len", "y", "assert", "len", "s", "n_cols", "n_rows", "es", "list", "s", "for", "e", "in", "es", "n_cols", "assert", "e", "top", "for", "e", "in", "es", "n_cols", "assert", "e", "left", "for", "e", "in", "es", "n_cols", "1", "n_cols", "assert", "e", "right", "for", "e", "in", "es", "n_cols", "assert", "e", "bottom", "for", "e", "in", "es", "assert", "e", "col", "is", "e", "row", "is", "none", "for", "i", "in", "range", "len", "y", "for", "j", "in", "range", "len", "x", "e", "es", "i", "len", "x", "j", "assert", "e", "x", "f", "x", "j", "assert", "e", "y", "f", "y", "i"], "doc_len": 117}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_both_paired_non_cross", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_both_paired_non_cross", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_both_paired_non_cross(self):\n\n        pair_spec = {\n            \"structure\": {\"x\": [\"x0\", \"x1\", \"x2\"], \"y\": [\"y0\", \"y1\", \"y2\"]},\n            \"cross\": False\n        }\n        s = Subplots({}, {}, pair_spec)\n        s.init_figure(pair_spec)\n\n        for i, e in enumerate(s):\n            assert e[\"x\"] == f\"x{i}\"\n            assert e[\"y\"] == f\"y{i}\"\n            assert e[\"col\"] is e[\"row\"] is None\n            assert e[\"left\"] == (i == 0)\n            assert e[\"right\"] == (i == (len(s) - 1))\n            assert e[\"top\"]\n            assert e[\"bottom\"]\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_both_paired_non_cross", "self", "pair_spec", "structure", "x", "x0", "x1", "x2", "y", "y0", "y1", "y2", "cross", "false", "s", "subplots", "pair_spec", "s", "init_figure", "pair_spec", "for", "i", "e", "in", "enumerate", "s", "assert", "e", "x", "f", "x", "i", "assert", "e", "y", "f", "y", "i", "assert", "e", "col", "is", "e", "row", "is", "none", "assert", "e", "left", "i", "0", "assert", "e", "right", "i", "len", "s", "1", "assert", "e", "top", "assert", "e", "bottom"], "doc_len": 70}
{"doc_id": "tests/_core/test_subplots.py::TestSubplotElements.test_one_facet_one_paired", "file_path": "tests/_core/test_subplots.py", "class_name": "TestSubplotElements", "func_name": "test_one_facet_one_paired", "text": "文件路径: tests/_core/test_subplots.py, 类名: TestSubplotElements\n    def test_one_facet_one_paired(self, dim, var):\n\n        other_var = {\"x\": \"y\", \"y\": \"x\"}[var]\n        other_dim = {\"col\": \"row\", \"row\": \"col\"}[dim]\n        order = list(\"abc\")\n        facet_spec = {\"variables\": {dim: \"s\"}, \"structure\": {dim: order}}\n\n        pairings = [\"x\", \"y\", \"t\"]\n        pair_spec = {\n            \"variables\": {f\"{var}{i}\": val for i, val in enumerate(pairings)},\n            \"structure\": {var: [f\"{var}{i}\" for i, _ in enumerate(pairings)]},\n        }\n\n        s = Subplots({}, facet_spec, pair_spec)\n        s.init_figure(pair_spec)\n\n        n_cols = len(order) if dim == \"col\" else len(pairings)\n        n_rows = len(order) if dim == \"row\" else len(pairings)\n\n        assert len(s) == len(order) * len(pairings)\n\n        es = list(s)\n\n        for e in es[:n_cols]:\n            assert e[\"top\"]\n        for e in es[::n_cols]:\n            assert e[\"left\"]\n        for e in es[n_cols - 1::n_cols]:\n            assert e[\"right\"]\n        for e in es[-n_cols:]:\n            assert e[\"bottom\"]\n\n        if dim == \"row\":\n            es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n\n        for i, e in enumerate(es):\n            assert e[dim] == order[i % len(pairings)]\n            assert e[other_dim] is None\n            assert e[var] == f\"{var}{i // len(order)}\"\n            assert e[other_var] == other_var\n", "tokens": ["tests", "_core", "test_subplots", "py", "testsubplotelements", "def", "test_one_facet_one_paired", "self", "dim", "var", "other_var", "x", "y", "y", "x", "var", "other_dim", "col", "row", "row", "col", "dim", "order", "list", "abc", "facet_spec", "variables", "dim", "s", "structure", "dim", "order", "pairings", "x", "y", "t", "pair_spec", "variables", "f", "var", "i", "val", "for", "i", "val", "in", "enumerate", "pairings", "structure", "var", "f", "var", "i", "for", "i", "_", "in", "enumerate", "pairings", "s", "subplots", "facet_spec", "pair_spec", "s", "init_figure", "pair_spec", "n_cols", "len", "order", "if", "dim", "col", "else", "len", "pairings", "n_rows", "len", "order", "if", "dim", "row", "else", "len", "pairings", "assert", "len", "s", "len", "order", "len", "pairings", "es", "list", "s", "for", "e", "in", "es", "n_cols", "assert", "e", "top", "for", "e", "in", "es", "n_cols", "assert", "e", "left", "for", "e", "in", "es", "n_cols", "1", "n_cols", "assert", "e", "right", "for", "e", "in", "es", "n_cols", "assert", "e", "bottom", "if", "dim", "row", "es", "np", "reshape", "es", "n_rows", "n_cols", "t", "ravel", "for", "i", "e", "in", "enumerate", "es", "assert", "e", "dim", "order", "i", "len", "pairings", "assert", "e", "other_dim", "is", "none", "assert", "e", "var", "f", "var", "i", "len", "order", "assert", "e", "other_var", "other_var"], "doc_len": 169}
{"doc_id": "tests/_marks/test_area.py::TestArea.test_single_defaults", "file_path": "tests/_marks/test_area.py", "class_name": "TestArea", "func_name": "test_single_defaults", "text": "文件路径: tests/_marks/test_area.py, 类名: TestArea\n    def test_single_defaults(self):\n\n        x, y = [1, 2, 3], [1, 2, 1]\n        p = Plot(x=x, y=y).add(Area()).plot()\n        ax = p._figure.axes[0]\n        poly = ax.patches[0]\n        verts = poly.get_path().vertices.T\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n\n        expected_x = [1, 2, 3, 3, 2, 1, 1]\n        assert_array_equal(verts[0], expected_x)\n\n        expected_y = [0, 0, 0, 1, 2, 1, 0]\n        assert_array_equal(verts[1], expected_y)\n\n        fc = poly.get_facecolor()\n        assert_array_equal(fc, to_rgba(colors[0], .2))\n\n        ec = poly.get_edgecolor()\n        assert_array_equal(ec, to_rgba(colors[0], 1))\n\n        lw = poly.get_linewidth()\n        assert_array_equal(lw, mpl.rcParams[\"patch.linewidth\"] * 2)\n", "tokens": ["tests", "_marks", "test_area", "py", "testarea", "def", "test_single_defaults", "self", "x", "y", "1", "2", "3", "1", "2", "1", "p", "plot", "x", "x", "y", "y", "add", "area", "plot", "ax", "p", "_figure", "axes", "0", "poly", "ax", "patches", "0", "verts", "poly", "get_path", "vertices", "t", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "expected_x", "1", "2", "3", "3", "2", "1", "1", "assert_array_equal", "verts", "0", "expected_x", "expected_y", "0", "0", "0", "1", "2", "1", "0", "assert_array_equal", "verts", "1", "expected_y", "fc", "poly", "get_facecolor", "assert_array_equal", "fc", "to_rgba", "colors", "0", "2", "ec", "poly", "get_edgecolor", "assert_array_equal", "ec", "to_rgba", "colors", "0", "1", "lw", "poly", "get_linewidth", "assert_array_equal", "lw", "mpl", "rcparams", "patch", "linewidth", "2"], "doc_len": 98}
{"doc_id": "tests/_marks/test_area.py::TestArea.test_set_properties", "file_path": "tests/_marks/test_area.py", "class_name": "TestArea", "func_name": "test_set_properties", "text": "文件路径: tests/_marks/test_area.py, 类名: TestArea\n    def test_set_properties(self):\n\n        x, y = [1, 2, 3], [1, 2, 1]\n        mark = Area(\n            color=\".33\",\n            alpha=.3,\n            edgecolor=\".88\",\n            edgealpha=.8,\n            edgewidth=2,\n            edgestyle=(0, (2, 1)),\n        )\n        p = Plot(x=x, y=y).add(mark).plot()\n        ax = p._figure.axes[0]\n        poly = ax.patches[0]\n\n        fc = poly.get_facecolor()\n        assert_array_equal(fc, to_rgba(mark.color, mark.alpha))\n\n        ec = poly.get_edgecolor()\n        assert_array_equal(ec, to_rgba(mark.edgecolor, mark.edgealpha))\n\n        lw = poly.get_linewidth()\n        assert_array_equal(lw, mark.edgewidth * 2)\n\n        ls = poly.get_linestyle()\n        dash_on, dash_off = mark.edgestyle[1]\n        expected = (0, (mark.edgewidth * dash_on / 4, mark.edgewidth * dash_off / 4))\n        assert ls == expected\n", "tokens": ["tests", "_marks", "test_area", "py", "testarea", "def", "test_set_properties", "self", "x", "y", "1", "2", "3", "1", "2", "1", "mark", "area", "color", "33", "alpha", "3", "edgecolor", "88", "edgealpha", "8", "edgewidth", "2", "edgestyle", "0", "2", "1", "p", "plot", "x", "x", "y", "y", "add", "mark", "plot", "ax", "p", "_figure", "axes", "0", "poly", "ax", "patches", "0", "fc", "poly", "get_facecolor", "assert_array_equal", "fc", "to_rgba", "mark", "color", "mark", "alpha", "ec", "poly", "get_edgecolor", "assert_array_equal", "ec", "to_rgba", "mark", "edgecolor", "mark", "edgealpha", "lw", "poly", "get_linewidth", "assert_array_equal", "lw", "mark", "edgewidth", "2", "ls", "poly", "get_linestyle", "dash_on", "dash_off", "mark", "edgestyle", "1", "expected", "0", "mark", "edgewidth", "dash_on", "4", "mark", "edgewidth", "dash_off", "4", "assert", "ls", "expected"], "doc_len": 99}
{"doc_id": "tests/_marks/test_area.py::TestArea.test_mapped_properties", "file_path": "tests/_marks/test_area.py", "class_name": "TestArea", "func_name": "test_mapped_properties", "text": "文件路径: tests/_marks/test_area.py, 类名: TestArea\n    def test_mapped_properties(self):\n\n        x, y = [1, 2, 3, 2, 3, 4], [1, 2, 1, 1, 3, 2]\n        g = [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"]\n        cs = [\".2\", \".8\"]\n        p = Plot(x=x, y=y, color=g, edgewidth=g).scale(color=cs).add(Area()).plot()\n        ax = p._figure.axes[0]\n\n        expected_x = [1, 2, 3, 3, 2, 1, 1], [2, 3, 4, 4, 3, 2, 2]\n        expected_y = [0, 0, 0, 1, 2, 1, 0], [0, 0, 0, 2, 3, 1, 0]\n\n        for i, poly in enumerate(ax.patches):\n            verts = poly.get_path().vertices.T\n            assert_array_equal(verts[0], expected_x[i])\n            assert_array_equal(verts[1], expected_y[i])\n\n        fcs = [p.get_facecolor() for p in ax.patches]\n        assert_array_equal(fcs, to_rgba_array(cs, .2))\n\n        ecs = [p.get_edgecolor() for p in ax.patches]\n        assert_array_equal(ecs, to_rgba_array(cs, 1))\n\n        lws = [p.get_linewidth() for p in ax.patches]\n        assert lws[0] > lws[1]\n", "tokens": ["tests", "_marks", "test_area", "py", "testarea", "def", "test_mapped_properties", "self", "x", "y", "1", "2", "3", "2", "3", "4", "1", "2", "1", "1", "3", "2", "g", "a", "a", "a", "b", "b", "b", "cs", "2", "8", "p", "plot", "x", "x", "y", "y", "color", "g", "edgewidth", "g", "scale", "color", "cs", "add", "area", "plot", "ax", "p", "_figure", "axes", "0", "expected_x", "1", "2", "3", "3", "2", "1", "1", "2", "3", "4", "4", "3", "2", "2", "expected_y", "0", "0", "0", "1", "2", "1", "0", "0", "0", "0", "2", "3", "1", "0", "for", "i", "poly", "in", "enumerate", "ax", "patches", "verts", "poly", "get_path", "vertices", "t", "assert_array_equal", "verts", "0", "expected_x", "i", "assert_array_equal", "verts", "1", "expected_y", "i", "fcs", "p", "get_facecolor", "for", "p", "in", "ax", "patches", "assert_array_equal", "fcs", "to_rgba_array", "cs", "2", "ecs", "p", "get_edgecolor", "for", "p", "in", "ax", "patches", "assert_array_equal", "ecs", "to_rgba_array", "cs", "1", "lws", "p", "get_linewidth", "for", "p", "in", "ax", "patches", "assert", "lws", "0", "lws", "1"], "doc_len": 144}
{"doc_id": "tests/_marks/test_area.py::TestArea.test_unfilled", "file_path": "tests/_marks/test_area.py", "class_name": "TestArea", "func_name": "test_unfilled", "text": "文件路径: tests/_marks/test_area.py, 类名: TestArea\n    def test_unfilled(self):\n\n        x, y = [1, 2, 3], [1, 2, 1]\n        c = \".5\"\n        p = Plot(x=x, y=y).add(Area(fill=False, color=c)).plot()\n        ax = p._figure.axes[0]\n        poly = ax.patches[0]\n        assert poly.get_facecolor() == to_rgba(c, 0)\n", "tokens": ["tests", "_marks", "test_area", "py", "testarea", "def", "test_unfilled", "self", "x", "y", "1", "2", "3", "1", "2", "1", "c", "5", "p", "plot", "x", "x", "y", "y", "add", "area", "fill", "false", "color", "c", "plot", "ax", "p", "_figure", "axes", "0", "poly", "ax", "patches", "0", "assert", "poly", "get_facecolor", "to_rgba", "c", "0"], "doc_len": 46}
{"doc_id": "tests/_marks/test_area.py::TestBand.test_range", "file_path": "tests/_marks/test_area.py", "class_name": "TestBand", "func_name": "test_range", "text": "文件路径: tests/_marks/test_area.py, 类名: TestBand\n    def test_range(self):\n\n        x, ymin, ymax = [1, 2, 4], [2, 1, 4], [3, 3, 5]\n        p = Plot(x=x, ymin=ymin, ymax=ymax).add(Band()).plot()\n        ax = p._figure.axes[0]\n        verts = ax.patches[0].get_path().vertices.T\n\n        expected_x = [1, 2, 4, 4, 2, 1, 1]\n        assert_array_equal(verts[0], expected_x)\n\n        expected_y = [2, 1, 4, 5, 3, 3, 2]\n        assert_array_equal(verts[1], expected_y)\n", "tokens": ["tests", "_marks", "test_area", "py", "testband", "def", "test_range", "self", "x", "ymin", "ymax", "1", "2", "4", "2", "1", "4", "3", "3", "5", "p", "plot", "x", "x", "ymin", "ymin", "ymax", "ymax", "add", "band", "plot", "ax", "p", "_figure", "axes", "0", "verts", "ax", "patches", "0", "get_path", "vertices", "t", "expected_x", "1", "2", "4", "4", "2", "1", "1", "assert_array_equal", "verts", "0", "expected_x", "expected_y", "2", "1", "4", "5", "3", "3", "2", "assert_array_equal", "verts", "1", "expected_y"], "doc_len": 67}
{"doc_id": "tests/_marks/test_area.py::TestBand.test_auto_range", "file_path": "tests/_marks/test_area.py", "class_name": "TestBand", "func_name": "test_auto_range", "text": "文件路径: tests/_marks/test_area.py, 类名: TestBand\n    def test_auto_range(self):\n\n        x = [1, 1, 2, 2, 2]\n        y = [1, 2, 3, 4, 5]\n        p = Plot(x=x, y=y).add(Band()).plot()\n        ax = p._figure.axes[0]\n        verts = ax.patches[0].get_path().vertices.T\n\n        expected_x = [1, 2, 2, 1, 1]\n        assert_array_equal(verts[0], expected_x)\n\n        expected_y = [1, 3, 5, 2, 1]\n        assert_array_equal(verts[1], expected_y)\n", "tokens": ["tests", "_marks", "test_area", "py", "testband", "def", "test_auto_range", "self", "x", "1", "1", "2", "2", "2", "y", "1", "2", "3", "4", "5", "p", "plot", "x", "x", "y", "y", "add", "band", "plot", "ax", "p", "_figure", "axes", "0", "verts", "ax", "patches", "0", "get_path", "vertices", "t", "expected_x", "1", "2", "2", "1", "1", "assert_array_equal", "verts", "0", "expected_x", "expected_y", "1", "3", "5", "2", "1", "assert_array_equal", "verts", "1", "expected_y"], "doc_len": 61}
{"doc_id": "tests/_marks/test_bar.py::TestBar.plot_bars", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "plot_bars", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def plot_bars(self, variables, mark_kws, layer_kws):\n\n        p = Plot(**variables).add(Bar(**mark_kws), **layer_kws).plot()\n        ax = p._figure.axes[0]\n        return [bar for barlist in ax.containers for bar in barlist]\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "plot_bars", "self", "variables", "mark_kws", "layer_kws", "p", "plot", "variables", "add", "bar", "mark_kws", "layer_kws", "plot", "ax", "p", "_figure", "axes", "0", "return", "bar", "for", "barlist", "in", "ax", "containers", "for", "bar", "in", "barlist"], "doc_len": 35}
{"doc_id": "tests/_marks/test_bar.py::TestBar.check_bar", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "check_bar", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def check_bar(self, bar, x, y, width, height):\n\n        assert bar.get_x() == pytest.approx(x)\n        assert bar.get_y() == pytest.approx(y)\n        assert bar.get_width() == pytest.approx(width)\n        assert bar.get_height() == pytest.approx(height)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "check_bar", "self", "bar", "x", "y", "width", "height", "assert", "bar", "get_x", "pytest", "approx", "x", "assert", "bar", "get_y", "pytest", "approx", "y", "assert", "bar", "get_width", "pytest", "approx", "width", "assert", "bar", "get_height", "pytest", "approx", "height"], "doc_len": 37}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_categorical_positions_vertical", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_categorical_positions_vertical", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_categorical_positions_vertical(self):\n\n        x = [\"a\", \"b\"]\n        y = [1, 2]\n        w = .8\n        bars = self.plot_bars({\"x\": x, \"y\": y}, {}, {})\n        for i, bar in enumerate(bars):\n            self.check_bar(bar, i - w / 2, 0, w, y[i])\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_categorical_positions_vertical", "self", "x", "a", "b", "y", "1", "2", "w", "8", "bars", "self", "plot_bars", "x", "x", "y", "y", "for", "i", "bar", "in", "enumerate", "bars", "self", "check_bar", "bar", "i", "w", "2", "0", "w", "y", "i"], "doc_len": 39}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_categorical_positions_horizontal", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_categorical_positions_horizontal", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_categorical_positions_horizontal(self):\n\n        x = [1, 2]\n        y = [\"a\", \"b\"]\n        w = .8\n        bars = self.plot_bars({\"x\": x, \"y\": y}, {}, {})\n        for i, bar in enumerate(bars):\n            self.check_bar(bar, 0, i - w / 2, x[i], w)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_categorical_positions_horizontal", "self", "x", "1", "2", "y", "a", "b", "w", "8", "bars", "self", "plot_bars", "x", "x", "y", "y", "for", "i", "bar", "in", "enumerate", "bars", "self", "check_bar", "bar", "0", "i", "w", "2", "x", "i", "w"], "doc_len": 39}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_numeric_positions_vertical", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_numeric_positions_vertical", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_numeric_positions_vertical(self):\n\n        x = [1, 2]\n        y = [3, 4]\n        w = .8\n        bars = self.plot_bars({\"x\": x, \"y\": y}, {}, {})\n        for i, bar in enumerate(bars):\n            self.check_bar(bar, x[i] - w / 2, 0, w, y[i])\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_numeric_positions_vertical", "self", "x", "1", "2", "y", "3", "4", "w", "8", "bars", "self", "plot_bars", "x", "x", "y", "y", "for", "i", "bar", "in", "enumerate", "bars", "self", "check_bar", "bar", "x", "i", "w", "2", "0", "w", "y", "i"], "doc_len": 40}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_numeric_positions_horizontal", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_numeric_positions_horizontal", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_numeric_positions_horizontal(self):\n\n        x = [1, 2]\n        y = [3, 4]\n        w = .8\n        bars = self.plot_bars({\"x\": x, \"y\": y}, {}, {\"orient\": \"h\"})\n        for i, bar in enumerate(bars):\n            self.check_bar(bar, 0, y[i] - w / 2, x[i], w)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_numeric_positions_horizontal", "self", "x", "1", "2", "y", "3", "4", "w", "8", "bars", "self", "plot_bars", "x", "x", "y", "y", "orient", "h", "for", "i", "bar", "in", "enumerate", "bars", "self", "check_bar", "bar", "0", "y", "i", "w", "2", "x", "i", "w"], "doc_len": 42}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_set_properties", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_set_properties", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_set_properties(self):\n\n        x = [\"a\", \"b\", \"c\"]\n        y = [1, 3, 2]\n\n        mark = Bar(\n            color=\".8\",\n            alpha=.5,\n            edgecolor=\".3\",\n            edgealpha=.9,\n            edgestyle=(2, 1),\n            edgewidth=1.5,\n        )\n\n        p = Plot(x, y).add(mark).plot()\n        ax = p._figure.axes[0]\n        for bar in ax.patches:\n            assert bar.get_facecolor() == to_rgba(mark.color, mark.alpha)\n            assert bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha)\n            # See comments in plotting method for why we need these adjustments\n            assert bar.get_linewidth() == mark.edgewidth * 2\n            expected_dashes = (mark.edgestyle[0] / 2, mark.edgestyle[1] / 2)\n            assert bar.get_linestyle() == (0, expected_dashes)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_set_properties", "self", "x", "a", "b", "c", "y", "1", "3", "2", "mark", "bar", "color", "8", "alpha", "5", "edgecolor", "3", "edgealpha", "9", "edgestyle", "2", "1", "edgewidth", "1", "5", "p", "plot", "x", "y", "add", "mark", "plot", "ax", "p", "_figure", "axes", "0", "for", "bar", "in", "ax", "patches", "assert", "bar", "get_facecolor", "to_rgba", "mark", "color", "mark", "alpha", "assert", "bar", "get_edgecolor", "to_rgba", "mark", "edgecolor", "mark", "edgealpha", "see", "comments", "in", "plotting", "method", "for", "why", "we", "need", "these", "adjustments", "assert", "bar", "get_linewidth", "mark", "edgewidth", "2", "expected_dashes", "mark", "edgestyle", "0", "2", "mark", "edgestyle", "1", "2", "assert", "bar", "get_linestyle", "0", "expected_dashes"], "doc_len": 96}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_mapped_properties", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_mapped_properties", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_mapped_properties(self):\n\n        x = [\"a\", \"b\"]\n        y = [1, 2]\n        mark = Bar(alpha=.2)\n        p = Plot(x, y, color=x, edgewidth=y).add(mark).plot()\n        ax = p._figure.axes[0]\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_facecolor() == to_rgba(colors[i], mark.alpha)\n            assert bar.get_edgecolor() == to_rgba(colors[i], 1)\n        assert ax.patches[0].get_linewidth() < ax.patches[1].get_linewidth()\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_mapped_properties", "self", "x", "a", "b", "y", "1", "2", "mark", "bar", "alpha", "2", "p", "plot", "x", "y", "color", "x", "edgewidth", "y", "add", "mark", "plot", "ax", "p", "_figure", "axes", "0", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "for", "i", "bar", "in", "enumerate", "ax", "patches", "assert", "bar", "get_facecolor", "to_rgba", "colors", "i", "mark", "alpha", "assert", "bar", "get_edgecolor", "to_rgba", "colors", "i", "1", "assert", "ax", "patches", "0", "get_linewidth", "ax", "patches", "1", "get_linewidth"], "doc_len": 72}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_zero_height_skipped", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_zero_height_skipped", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_zero_height_skipped(self):\n\n        p = Plot([\"a\", \"b\", \"c\"], [1, 0, 2]).add(Bar()).plot()\n        ax = p._figure.axes[0]\n        assert len(ax.patches) == 2\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_zero_height_skipped", "self", "p", "plot", "a", "b", "c", "1", "0", "2", "add", "bar", "plot", "ax", "p", "_figure", "axes", "0", "assert", "len", "ax", "patches", "2"], "doc_len": 29}
{"doc_id": "tests/_marks/test_bar.py::TestBar.test_artist_kws_clip", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBar", "func_name": "test_artist_kws_clip", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBar\n    def test_artist_kws_clip(self):\n\n        p = Plot([\"a\", \"b\"], [1, 2]).add(Bar({\"clip_on\": False})).plot()\n        patch = p._figure.axes[0].patches[0]\n        assert patch.clipbox is None\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbar", "def", "test_artist_kws_clip", "self", "p", "plot", "a", "b", "1", "2", "add", "bar", "clip_on", "false", "plot", "patch", "p", "_figure", "axes", "0", "patches", "0", "assert", "patch", "clipbox", "is", "none"], "doc_len": 31}
{"doc_id": "tests/_marks/test_bar.py::TestBars.x", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "x", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def x(self):\n        return pd.Series([4, 5, 6, 7, 8], name=\"x\")\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "x", "self", "return", "pd", "series", "4", "5", "6", "7", "8", "name", "x"], "doc_len": 18}
{"doc_id": "tests/_marks/test_bar.py::TestBars.y", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "y", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def y(self):\n        return pd.Series([2, 8, 3, 5, 9], name=\"y\")\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "y", "self", "return", "pd", "series", "2", "8", "3", "5", "9", "name", "y"], "doc_len": 18}
{"doc_id": "tests/_marks/test_bar.py::TestBars.color", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "color", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def color(self):\n        return pd.Series([\"a\", \"b\", \"c\", \"a\", \"c\"], name=\"color\")\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "color", "self", "return", "pd", "series", "a", "b", "c", "a", "c", "name", "color"], "doc_len": 18}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_positions", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_positions", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_positions(self, x, y):\n\n        p = Plot(x, y).add(Bars()).plot()\n        ax = p._figure.axes[0]\n        paths = ax.collections[0].get_paths()\n        assert len(paths) == len(x)\n        for i, path in enumerate(paths):\n            verts = path.vertices\n            assert verts[0, 0] == pytest.approx(x[i] - .5)\n            assert verts[1, 0] == pytest.approx(x[i] + .5)\n            assert verts[0, 1] == 0\n            assert verts[3, 1] == y[i]\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_positions", "self", "x", "y", "p", "plot", "x", "y", "add", "bars", "plot", "ax", "p", "_figure", "axes", "0", "paths", "ax", "collections", "0", "get_paths", "assert", "len", "paths", "len", "x", "for", "i", "path", "in", "enumerate", "paths", "verts", "path", "vertices", "assert", "verts", "0", "0", "pytest", "approx", "x", "i", "5", "assert", "verts", "1", "0", "pytest", "approx", "x", "i", "5", "assert", "verts", "0", "1", "0", "assert", "verts", "3", "1", "y", "i"], "doc_len": 70}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_positions_horizontal", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_positions_horizontal", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_positions_horizontal(self, x, y):\n\n        p = Plot(x=y, y=x).add(Bars(), orient=\"h\").plot()\n        ax = p._figure.axes[0]\n        paths = ax.collections[0].get_paths()\n        assert len(paths) == len(x)\n        for i, path in enumerate(paths):\n            verts = path.vertices\n            assert verts[0, 1] == pytest.approx(x[i] - .5)\n            assert verts[3, 1] == pytest.approx(x[i] + .5)\n            assert verts[0, 0] == 0\n            assert verts[1, 0] == y[i]\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_positions_horizontal", "self", "x", "y", "p", "plot", "x", "y", "y", "x", "add", "bars", "orient", "h", "plot", "ax", "p", "_figure", "axes", "0", "paths", "ax", "collections", "0", "get_paths", "assert", "len", "paths", "len", "x", "for", "i", "path", "in", "enumerate", "paths", "verts", "path", "vertices", "assert", "verts", "0", "1", "pytest", "approx", "x", "i", "5", "assert", "verts", "3", "1", "pytest", "approx", "x", "i", "5", "assert", "verts", "0", "0", "0", "assert", "verts", "1", "0", "y", "i"], "doc_len": 74}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_width", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_width", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_width(self, x, y):\n\n        p = Plot(x, y).add(Bars(width=.4)).plot()\n        ax = p._figure.axes[0]\n        paths = ax.collections[0].get_paths()\n        for i, path in enumerate(paths):\n            verts = path.vertices\n            assert verts[0, 0] == pytest.approx(x[i] - .2)\n            assert verts[1, 0] == pytest.approx(x[i] + .2)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_width", "self", "x", "y", "p", "plot", "x", "y", "add", "bars", "width", "4", "plot", "ax", "p", "_figure", "axes", "0", "paths", "ax", "collections", "0", "get_paths", "for", "i", "path", "in", "enumerate", "paths", "verts", "path", "vertices", "assert", "verts", "0", "0", "pytest", "approx", "x", "i", "2", "assert", "verts", "1", "0", "pytest", "approx", "x", "i", "2"], "doc_len": 56}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_mapped_color_direct_alpha", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_mapped_color_direct_alpha", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_mapped_color_direct_alpha(self, x, y, color):\n\n        alpha = .5\n        p = Plot(x, y, color=color).add(Bars(alpha=alpha)).plot()\n        ax = p._figure.axes[0]\n        fcs = ax.collections[0].get_facecolors()\n        C0, C1, C2, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        expected = to_rgba_array([C0, C1, C2, C0, C2], alpha)\n        assert_array_equal(fcs, expected)\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_mapped_color_direct_alpha", "self", "x", "y", "color", "alpha", "5", "p", "plot", "x", "y", "color", "color", "add", "bars", "alpha", "alpha", "plot", "ax", "p", "_figure", "axes", "0", "fcs", "ax", "collections", "0", "get_facecolors", "c0", "c1", "c2", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "expected", "to_rgba_array", "c0", "c1", "c2", "c0", "c2", "alpha", "assert_array_equal", "fcs", "expected"], "doc_len": 55}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_mapped_edgewidth", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_mapped_edgewidth", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_mapped_edgewidth(self, x, y):\n\n        p = Plot(x, y, edgewidth=y).add(Bars()).plot()\n        ax = p._figure.axes[0]\n        lws = ax.collections[0].get_linewidths()\n        assert_array_equal(np.argsort(lws), np.argsort(y))\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_mapped_edgewidth", "self", "x", "y", "p", "plot", "x", "y", "edgewidth", "y", "add", "bars", "plot", "ax", "p", "_figure", "axes", "0", "lws", "ax", "collections", "0", "get_linewidths", "assert_array_equal", "np", "argsort", "lws", "np", "argsort", "y"], "doc_len": 36}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_auto_edgewidth", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_auto_edgewidth", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_auto_edgewidth(self):\n\n        x0 = np.arange(10)\n        x1 = np.arange(1000)\n\n        p0 = Plot(x0, x0).add(Bars()).plot()\n        p1 = Plot(x1, x1).add(Bars()).plot()\n\n        lw0 = p0._figure.axes[0].collections[0].get_linewidths()\n        lw1 = p1._figure.axes[0].collections[0].get_linewidths()\n\n        assert (lw0 > lw1).all()\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_auto_edgewidth", "self", "x0", "np", "arange", "10", "x1", "np", "arange", "1000", "p0", "plot", "x0", "x0", "add", "bars", "plot", "p1", "plot", "x1", "x1", "add", "bars", "plot", "lw0", "p0", "_figure", "axes", "0", "collections", "0", "get_linewidths", "lw1", "p1", "_figure", "axes", "0", "collections", "0", "get_linewidths", "assert", "lw0", "lw1", "all"], "doc_len": 50}
{"doc_id": "tests/_marks/test_bar.py::TestBars.test_unfilled", "file_path": "tests/_marks/test_bar.py", "class_name": "TestBars", "func_name": "test_unfilled", "text": "文件路径: tests/_marks/test_bar.py, 类名: TestBars\n    def test_unfilled(self, x, y):\n\n        p = Plot(x, y).add(Bars(fill=False, edgecolor=\"C4\")).plot()\n        ax = p._figure.axes[0]\n        fcs = ax.collections[0].get_facecolors()\n        ecs = ax.collections[0].get_edgecolors()\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        assert_array_equal(fcs, to_rgba_array([colors[0]] * len(x), 0))\n        assert_array_equal(ecs, to_rgba_array([colors[4]] * len(x), 1))\n", "tokens": ["tests", "_marks", "test_bar", "py", "testbars", "def", "test_unfilled", "self", "x", "y", "p", "plot", "x", "y", "add", "bars", "fill", "false", "edgecolor", "c4", "plot", "ax", "p", "_figure", "axes", "0", "fcs", "ax", "collections", "0", "get_facecolors", "ecs", "ax", "collections", "0", "get_edgecolors", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "assert_array_equal", "fcs", "to_rgba_array", "colors", "0", "len", "x", "0", "assert_array_equal", "ecs", "to_rgba_array", "colors", "4", "len", "x", "1"], "doc_len": 59}
{"doc_id": "tests/_marks/test_base.py::TestMappable.mark", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "mark", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def mark(self, **features):\n\n        @dataclass\n        class MockMark(Mark):\n            linewidth: float = Mappable(rc=\"lines.linewidth\")\n            pointsize: float = Mappable(4)\n            color: str = Mappable(\"C0\")\n            fillcolor: str = Mappable(depend=\"color\")\n            alpha: float = Mappable(1)\n            fillalpha: float = Mappable(depend=\"alpha\")\n\n        m = MockMark(**features)\n        return m\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "mark", "self", "features", "dataclass", "class", "mockmark", "mark", "linewidth", "float", "mappable", "rc", "lines", "linewidth", "pointsize", "float", "mappable", "4", "color", "str", "mappable", "c0", "fillcolor", "str", "mappable", "depend", "color", "alpha", "float", "mappable", "1", "fillalpha", "float", "mappable", "depend", "alpha", "m", "mockmark", "features", "return", "m"], "doc_len": 46}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_repr", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_repr", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_repr(self):\n\n        assert str(Mappable(.5)) == \"<0.5>\"\n        assert str(Mappable(\"CO\")) == \"<'CO'>\"\n        assert str(Mappable(rc=\"lines.linewidth\")) == \"<rc:lines.linewidth>\"\n        assert str(Mappable(depend=\"color\")) == \"<depend:color>\"\n        assert str(Mappable(auto=True)) == \"<auto>\"\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_repr", "self", "assert", "str", "mappable", "5", "0", "5", "assert", "str", "mappable", "co", "co", "assert", "str", "mappable", "rc", "lines", "linewidth", "rc", "lines", "linewidth", "assert", "str", "mappable", "depend", "color", "depend", "color", "assert", "str", "mappable", "auto", "true", "auto"], "doc_len": 41}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_input_checks", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_input_checks", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_input_checks(self):\n\n        with pytest.raises(AssertionError):\n            Mappable(rc=\"bogus.parameter\")\n        with pytest.raises(AssertionError):\n            Mappable(depend=\"nonexistent_feature\")\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_input_checks", "self", "with", "pytest", "raises", "assertionerror", "mappable", "rc", "bogus", "parameter", "with", "pytest", "raises", "assertionerror", "mappable", "depend", "nonexistent_feature"], "doc_len": 23}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_value", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_value", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_value(self):\n\n        val = 3\n        m = self.mark(linewidth=val)\n        assert m._resolve({}, \"linewidth\") == val\n\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n        assert_array_equal(m._resolve(df, \"linewidth\"), np.full(len(df), val))\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_value", "self", "val", "3", "m", "self", "mark", "linewidth", "val", "assert", "m", "_resolve", "linewidth", "val", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "assert_array_equal", "m", "_resolve", "df", "linewidth", "np", "full", "len", "df", "val"], "doc_len": 37}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_default", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_default", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_default(self):\n\n        val = 3\n        m = self.mark(linewidth=Mappable(val))\n        assert m._resolve({}, \"linewidth\") == val\n\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n        assert_array_equal(m._resolve(df, \"linewidth\"), np.full(len(df), val))\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_default", "self", "val", "3", "m", "self", "mark", "linewidth", "mappable", "val", "assert", "m", "_resolve", "linewidth", "val", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "assert_array_equal", "m", "_resolve", "df", "linewidth", "np", "full", "len", "df", "val"], "doc_len": 38}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_rcparam", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_rcparam", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_rcparam(self):\n\n        param = \"lines.linewidth\"\n        val = mpl.rcParams[param]\n\n        m = self.mark(linewidth=Mappable(rc=param))\n        assert m._resolve({}, \"linewidth\") == val\n\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n        assert_array_equal(m._resolve(df, \"linewidth\"), np.full(len(df), val))\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_rcparam", "self", "param", "lines", "linewidth", "val", "mpl", "rcparams", "param", "m", "self", "mark", "linewidth", "mappable", "rc", "param", "assert", "m", "_resolve", "linewidth", "val", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "assert_array_equal", "m", "_resolve", "df", "linewidth", "np", "full", "len", "df", "val"], "doc_len": 44}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_depends", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_depends", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_depends(self):\n\n        val = 2\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n\n        m = self.mark(pointsize=Mappable(val), linewidth=Mappable(depend=\"pointsize\"))\n        assert m._resolve({}, \"linewidth\") == val\n        assert_array_equal(m._resolve(df, \"linewidth\"), np.full(len(df), val))\n\n        m = self.mark(pointsize=val * 2, linewidth=Mappable(depend=\"pointsize\"))\n        assert m._resolve({}, \"linewidth\") == val * 2\n        assert_array_equal(m._resolve(df, \"linewidth\"), np.full(len(df), val * 2))\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_depends", "self", "val", "2", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "m", "self", "mark", "pointsize", "mappable", "val", "linewidth", "mappable", "depend", "pointsize", "assert", "m", "_resolve", "linewidth", "val", "assert_array_equal", "m", "_resolve", "df", "linewidth", "np", "full", "len", "df", "val", "m", "self", "mark", "pointsize", "val", "2", "linewidth", "mappable", "depend", "pointsize", "assert", "m", "_resolve", "linewidth", "val", "2", "assert_array_equal", "m", "_resolve", "df", "linewidth", "np", "full", "len", "df", "val", "2"], "doc_len": 69}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_mapped", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_mapped", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_mapped(self):\n\n        values = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n        def f(x):\n            return np.array([values[x_i] for x_i in x])\n\n        m = self.mark(linewidth=Mappable(2))\n        scales = {\"linewidth\": f}\n\n        assert m._resolve({\"linewidth\": \"c\"}, \"linewidth\", scales) == 3\n\n        df = pd.DataFrame({\"linewidth\": [\"a\", \"b\", \"c\"]})\n        expected = np.array([1, 2, 3], float)\n        assert_array_equal(m._resolve(df, \"linewidth\", scales), expected)\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_mapped", "self", "values", "a", "1", "b", "2", "c", "3", "def", "f", "x", "return", "np", "array", "values", "x_i", "for", "x_i", "in", "x", "m", "self", "mark", "linewidth", "mappable", "2", "scales", "linewidth", "f", "assert", "m", "_resolve", "linewidth", "c", "linewidth", "scales", "3", "df", "pd", "dataframe", "linewidth", "a", "b", "c", "expected", "np", "array", "1", "2", "3", "float", "assert_array_equal", "m", "_resolve", "df", "linewidth", "scales", "expected"], "doc_len": 65}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_color", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_color", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_color(self):\n\n        c, a = \"C1\", .5\n        m = self.mark(color=c, alpha=a)\n\n        assert resolve_color(m, {}) == mpl.colors.to_rgba(c, a)\n\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n        cs = [c] * len(df)\n        assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_color", "self", "c", "a", "c1", "5", "m", "self", "mark", "color", "c", "alpha", "a", "assert", "resolve_color", "m", "mpl", "colors", "to_rgba", "c", "a", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "cs", "c", "len", "df", "assert_array_equal", "resolve_color", "m", "df", "mpl", "colors", "to_rgba_array", "cs", "a"], "doc_len": 47}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_color_mapped_alpha", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_color_mapped_alpha", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_color_mapped_alpha(self):\n\n        c = \"r\"\n        values = {\"a\": .2, \"b\": .5, \"c\": .8}\n\n        m = self.mark(color=c, alpha=Mappable(1))\n        scales = {\"alpha\": lambda s: np.array([values[s_i] for s_i in s])}\n\n        assert resolve_color(m, {\"alpha\": \"b\"}, \"\", scales) == mpl.colors.to_rgba(c, .5)\n\n        df = pd.DataFrame({\"alpha\": list(values.keys())})\n\n        # Do this in two steps for mpl 3.2 compat\n        expected = mpl.colors.to_rgba_array([c] * len(df))\n        expected[:, 3] = list(values.values())\n\n        assert_array_equal(resolve_color(m, df, \"\", scales), expected)\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_color_mapped_alpha", "self", "c", "r", "values", "a", "2", "b", "5", "c", "8", "m", "self", "mark", "color", "c", "alpha", "mappable", "1", "scales", "alpha", "lambda", "s", "np", "array", "values", "s_i", "for", "s_i", "in", "s", "assert", "resolve_color", "m", "alpha", "b", "scales", "mpl", "colors", "to_rgba", "c", "5", "df", "pd", "dataframe", "alpha", "list", "values", "keys", "do", "this", "in", "two", "steps", "for", "mpl", "3", "2", "compat", "expected", "mpl", "colors", "to_rgba_array", "c", "len", "df", "expected", "3", "list", "values", "values", "assert_array_equal", "resolve_color", "m", "df", "scales", "expected"], "doc_len": 83}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_color_scaled_as_strings", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_color_scaled_as_strings", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_color_scaled_as_strings(self):\n\n        colors = [\"C1\", \"dodgerblue\", \"#445566\"]\n        m = self.mark()\n        scales = {\"color\": lambda s: colors}\n\n        actual = resolve_color(m, {\"color\": pd.Series([\"a\", \"b\", \"c\"])}, \"\", scales)\n        expected = mpl.colors.to_rgba_array(colors)\n        assert_array_equal(actual, expected)\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_color_scaled_as_strings", "self", "colors", "c1", "dodgerblue", "445566", "m", "self", "mark", "scales", "color", "lambda", "s", "colors", "actual", "resolve_color", "m", "color", "pd", "series", "a", "b", "c", "scales", "expected", "mpl", "colors", "to_rgba_array", "colors", "assert_array_equal", "actual", "expected"], "doc_len": 38}
{"doc_id": "tests/_marks/test_base.py::TestMappable.test_fillcolor", "file_path": "tests/_marks/test_base.py", "class_name": "TestMappable", "func_name": "test_fillcolor", "text": "文件路径: tests/_marks/test_base.py, 类名: TestMappable\n    def test_fillcolor(self):\n\n        c, a = \"green\", .8\n        fa = .2\n        m = self.mark(\n            color=c, alpha=a,\n            fillcolor=Mappable(depend=\"color\"), fillalpha=Mappable(fa),\n        )\n\n        assert resolve_color(m, {}) == mpl.colors.to_rgba(c, a)\n        assert resolve_color(m, {}, \"fill\") == mpl.colors.to_rgba(c, fa)\n\n        df = pd.DataFrame(index=pd.RangeIndex(10))\n        cs = [c] * len(df)\n        assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n        assert_array_equal(\n            resolve_color(m, df, \"fill\"), mpl.colors.to_rgba_array(cs, fa)\n        )\n", "tokens": ["tests", "_marks", "test_base", "py", "testmappable", "def", "test_fillcolor", "self", "c", "a", "green", "8", "fa", "2", "m", "self", "mark", "color", "c", "alpha", "a", "fillcolor", "mappable", "depend", "color", "fillalpha", "mappable", "fa", "assert", "resolve_color", "m", "mpl", "colors", "to_rgba", "c", "a", "assert", "resolve_color", "m", "fill", "mpl", "colors", "to_rgba", "c", "fa", "df", "pd", "dataframe", "index", "pd", "rangeindex", "10", "cs", "c", "len", "df", "assert_array_equal", "resolve_color", "m", "df", "mpl", "colors", "to_rgba_array", "cs", "a", "assert_array_equal", "resolve_color", "m", "df", "fill", "mpl", "colors", "to_rgba_array", "cs", "fa"], "doc_len": 75}
{"doc_id": "tests/_marks/test_dot.py::default_palette", "file_path": "tests/_marks/test_dot.py", "class_name": null, "func_name": "default_palette", "text": "文件路径: tests/_marks/test_dot.py\ndef default_palette():\n    with color_palette(\"deep\"):\n        yield\n", "tokens": ["tests", "_marks", "test_dot", "py", "def", "default_palette", "with", "color_palette", "deep", "yield"], "doc_len": 10}
{"doc_id": "tests/_marks/test_dot.py::DotBase.check_offsets", "file_path": "tests/_marks/test_dot.py", "class_name": "DotBase", "func_name": "check_offsets", "text": "文件路径: tests/_marks/test_dot.py, 类名: DotBase\n    def check_offsets(self, points, x, y):\n\n        offsets = points.get_offsets().T\n        assert_array_equal(offsets[0], x)\n        assert_array_equal(offsets[1], y)\n", "tokens": ["tests", "_marks", "test_dot", "py", "dotbase", "def", "check_offsets", "self", "points", "x", "y", "offsets", "points", "get_offsets", "t", "assert_array_equal", "offsets", "0", "x", "assert_array_equal", "offsets", "1", "y"], "doc_len": 23}
{"doc_id": "tests/_marks/test_dot.py::DotBase.check_colors", "file_path": "tests/_marks/test_dot.py", "class_name": "DotBase", "func_name": "check_colors", "text": "文件路径: tests/_marks/test_dot.py, 类名: DotBase\n    def check_colors(self, part, points, colors, alpha=None):\n\n        rgba = to_rgba_array(colors, alpha)\n\n        getter = getattr(points, f\"get_{part}colors\")\n        assert_array_equal(getter(), rgba)\n", "tokens": ["tests", "_marks", "test_dot", "py", "dotbase", "def", "check_colors", "self", "part", "points", "colors", "alpha", "none", "rgba", "to_rgba_array", "colors", "alpha", "getter", "getattr", "points", "f", "get_", "part", "colors", "assert_array_equal", "getter", "rgba"], "doc_len": 27}
{"doc_id": "tests/_marks/test_dot.py::TestDot.test_simple", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDot", "func_name": "test_simple", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDot\n    def test_simple(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        p = Plot(x=x, y=y).add(Dot()).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [C0] * 3, 1)\n        self.check_colors(\"edge\", points, [C0] * 3, 1)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdot", "def", "test_simple", "self", "x", "1", "2", "3", "y", "4", "5", "2", "p", "plot", "x", "x", "y", "y", "add", "dot", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "c0", "3", "1", "self", "check_colors", "edge", "points", "c0", "3", "1"], "doc_len": 60}
{"doc_id": "tests/_marks/test_dot.py::TestDot.test_filled_unfilled_mix", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDot", "func_name": "test_filled_unfilled_mix", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDot\n    def test_filled_unfilled_mix(self):\n\n        x = [1, 2]\n        y = [4, 5]\n        marker = [\"a\", \"b\"]\n        shapes = [\"o\", \"x\"]\n\n        mark = Dot(edgecolor=\"w\", stroke=2, edgewidth=1)\n        p = Plot(x=x, y=y).add(mark, marker=marker).scale(marker=shapes).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [C0, to_rgba(C0, 0)], None)\n        self.check_colors(\"edge\", points, [\"w\", C0], 1)\n\n        expected = [mark.edgewidth, mark.stroke]\n        assert_array_equal(points.get_linewidths(), expected)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdot", "def", "test_filled_unfilled_mix", "self", "x", "1", "2", "y", "4", "5", "marker", "a", "b", "shapes", "o", "x", "mark", "dot", "edgecolor", "w", "stroke", "2", "edgewidth", "1", "p", "plot", "x", "x", "y", "y", "add", "mark", "marker", "marker", "scale", "marker", "shapes", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "c0", "to_rgba", "c0", "0", "none", "self", "check_colors", "edge", "points", "w", "c0", "1", "expected", "mark", "edgewidth", "mark", "stroke", "assert_array_equal", "points", "get_linewidths", "expected"], "doc_len": 88}
{"doc_id": "tests/_marks/test_dot.py::TestDot.test_missing_coordinate_data", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDot", "func_name": "test_missing_coordinate_data", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDot\n    def test_missing_coordinate_data(self):\n\n        x = [1, float(\"nan\"), 3]\n        y = [5, 3, 4]\n\n        p = Plot(x=x, y=y).add(Dot()).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        self.check_offsets(points, [1, 3], [5, 4])\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdot", "def", "test_missing_coordinate_data", "self", "x", "1", "float", "nan", "3", "y", "5", "3", "4", "p", "plot", "x", "x", "y", "y", "add", "dot", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "self", "check_offsets", "points", "1", "3", "5", "4"], "doc_len": 41}
{"doc_id": "tests/_marks/test_dot.py::TestDot.test_missing_semantic_data", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDot", "func_name": "test_missing_semantic_data", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDot\n    def test_missing_semantic_data(self, prop):\n\n        x = [1, 2, 3]\n        y = [5, 3, 4]\n        z = [\"a\", float(\"nan\"), \"b\"]\n\n        p = Plot(x=x, y=y, **{prop: z}).add(Dot()).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        self.check_offsets(points, [1, 3], [5, 4])\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdot", "def", "test_missing_semantic_data", "self", "prop", "x", "1", "2", "3", "y", "5", "3", "4", "z", "a", "float", "nan", "b", "p", "plot", "x", "x", "y", "y", "prop", "z", "add", "dot", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "self", "check_offsets", "points", "1", "3", "5", "4"], "doc_len": 48}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_simple", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_simple", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_simple(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        p = Plot(x=x, y=y).add(Dots()).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [C0] * 3, .2)\n        self.check_colors(\"edge\", points, [C0] * 3, 1)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_simple", "self", "x", "1", "2", "3", "y", "4", "5", "2", "p", "plot", "x", "x", "y", "y", "add", "dots", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "c0", "3", "2", "self", "check_colors", "edge", "points", "c0", "3", "1"], "doc_len": 60}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_set_color", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_set_color", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_set_color(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        m = Dots(color=\".25\")\n        p = Plot(x=x, y=y).add(m).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [m.color] * 3, .2)\n        self.check_colors(\"edge\", points, [m.color] * 3, 1)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_set_color", "self", "x", "1", "2", "3", "y", "4", "5", "2", "m", "dots", "color", "25", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "m", "color", "3", "2", "self", "check_colors", "edge", "points", "m", "color", "3", "1"], "doc_len": 58}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_map_color", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_map_color", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_map_color(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        c = [\"a\", \"b\", \"a\"]\n        p = Plot(x=x, y=y, color=c).add(Dots()).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, C1, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [C0, C1, C0], .2)\n        self.check_colors(\"edge\", points, [C0, C1, C0], 1)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_map_color", "self", "x", "1", "2", "3", "y", "4", "5", "2", "c", "a", "b", "a", "p", "plot", "x", "x", "y", "y", "color", "c", "add", "dots", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "c1", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "c0", "c1", "c0", "2", "self", "check_colors", "edge", "points", "c0", "c1", "c0", "1"], "doc_len": 69}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_fill", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_fill", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_fill(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        c = [\"a\", \"b\", \"a\"]\n        p = Plot(x=x, y=y, color=c).add(Dots(fill=False)).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, C1, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [C0, C1, C0], 0)\n        self.check_colors(\"edge\", points, [C0, C1, C0], 1)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_fill", "self", "x", "1", "2", "3", "y", "4", "5", "2", "c", "a", "b", "a", "p", "plot", "x", "x", "y", "y", "color", "c", "add", "dots", "fill", "false", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "c1", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "c0", "c1", "c0", "0", "self", "check_colors", "edge", "points", "c0", "c1", "c0", "1"], "doc_len": 71}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_pointsize", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_pointsize", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_pointsize(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        s = 3\n        p = Plot(x=x, y=y).add(Dots(pointsize=s)).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        self.check_offsets(points, x, y)\n        assert_array_equal(points.get_sizes(), [s ** 2] * 3)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_pointsize", "self", "x", "1", "2", "3", "y", "4", "5", "2", "s", "3", "p", "plot", "x", "x", "y", "y", "add", "dots", "pointsize", "s", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "self", "check_offsets", "points", "x", "y", "assert_array_equal", "points", "get_sizes", "s", "2", "3"], "doc_len": 48}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_stroke", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_stroke", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_stroke(self):\n\n        x = [1, 2, 3]\n        y = [4, 5, 2]\n        s = 3\n        p = Plot(x=x, y=y).add(Dots(stroke=s)).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        self.check_offsets(points, x, y)\n        assert_array_equal(points.get_linewidths(), [s] * 3)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_stroke", "self", "x", "1", "2", "3", "y", "4", "5", "2", "s", "3", "p", "plot", "x", "x", "y", "y", "add", "dots", "stroke", "s", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "self", "check_offsets", "points", "x", "y", "assert_array_equal", "points", "get_linewidths", "s", "3"], "doc_len": 47}
{"doc_id": "tests/_marks/test_dot.py::TestDots.test_filled_unfilled_mix", "file_path": "tests/_marks/test_dot.py", "class_name": "TestDots", "func_name": "test_filled_unfilled_mix", "text": "文件路径: tests/_marks/test_dot.py, 类名: TestDots\n    def test_filled_unfilled_mix(self):\n\n        x = [1, 2]\n        y = [4, 5]\n        marker = [\"a\", \"b\"]\n        shapes = [\"o\", \"x\"]\n\n        mark = Dots(stroke=2)\n        p = Plot(x=x, y=y).add(mark, marker=marker).scale(marker=shapes).plot()\n        ax = p._figure.axes[0]\n        points, = ax.collections\n        C0, C1, *_ = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        self.check_offsets(points, x, y)\n        self.check_colors(\"face\", points, [to_rgba(C0, .2), to_rgba(C0, 0)], None)\n        self.check_colors(\"edge\", points, [C0, C0], 1)\n        assert_array_equal(points.get_linewidths(), [mark.stroke] * 2)\n", "tokens": ["tests", "_marks", "test_dot", "py", "testdots", "def", "test_filled_unfilled_mix", "self", "x", "1", "2", "y", "4", "5", "marker", "a", "b", "shapes", "o", "x", "mark", "dots", "stroke", "2", "p", "plot", "x", "x", "y", "y", "add", "mark", "marker", "marker", "scale", "marker", "shapes", "plot", "ax", "p", "_figure", "axes", "0", "points", "ax", "collections", "c0", "c1", "_", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "self", "check_offsets", "points", "x", "y", "self", "check_colors", "face", "points", "to_rgba", "c0", "2", "to_rgba", "c0", "0", "none", "self", "check_colors", "edge", "points", "c0", "c0", "1", "assert_array_equal", "points", "get_linewidths", "mark", "stroke", "2"], "doc_len": 84}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_xy_data(self):\n\n        x = [1, 5, 3, np.nan, 2]\n        y = [1, 4, 2, 5, 3]\n        g = [1, 2, 1, 1, 2]\n        p = Plot(x=x, y=y, group=g).add(Path()).plot()\n        line1, line2 = p._figure.axes[0].get_lines()\n\n        assert_array_equal(line1.get_xdata(), [1, 3, np.nan])\n        assert_array_equal(line1.get_ydata(), [1, 2, np.nan])\n        assert_array_equal(line2.get_xdata(), [5, 2])\n        assert_array_equal(line2.get_ydata(), [4, 3])\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_xy_data", "self", "x", "1", "5", "3", "np", "nan", "2", "y", "1", "4", "2", "5", "3", "g", "1", "2", "1", "1", "2", "p", "plot", "x", "x", "y", "y", "group", "g", "add", "path", "plot", "line1", "line2", "p", "_figure", "axes", "0", "get_lines", "assert_array_equal", "line1", "get_xdata", "1", "3", "np", "nan", "assert_array_equal", "line1", "get_ydata", "1", "2", "np", "nan", "assert_array_equal", "line2", "get_xdata", "5", "2", "assert_array_equal", "line2", "get_ydata", "4", "3"], "doc_len": 69}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_shared_colors_direct", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_shared_colors_direct", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_shared_colors_direct(self):\n\n        x = y = [1, 2, 3]\n        color = \".44\"\n        m = Path(color=color)\n        p = Plot(x=x, y=y).add(m).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert same_color(line.get_color(), color)\n        assert same_color(line.get_markeredgecolor(), color)\n        assert same_color(line.get_markerfacecolor(), color)\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_shared_colors_direct", "self", "x", "y", "1", "2", "3", "color", "44", "m", "path", "color", "color", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "same_color", "line", "get_color", "color", "assert", "same_color", "line", "get_markeredgecolor", "color", "assert", "same_color", "line", "get_markerfacecolor", "color"], "doc_len": 49}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_separate_colors_direct", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_separate_colors_direct", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_separate_colors_direct(self):\n\n        x = y = [1, 2, 3]\n        y = [1, 2, 3]\n        m = Path(color=\".22\", edgecolor=\".55\", fillcolor=\".77\")\n        p = Plot(x=x, y=y).add(m).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert same_color(line.get_color(), m.color)\n        assert same_color(line.get_markeredgecolor(), m.edgecolor)\n        assert same_color(line.get_markerfacecolor(), m.fillcolor)\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_separate_colors_direct", "self", "x", "y", "1", "2", "3", "y", "1", "2", "3", "m", "path", "color", "22", "edgecolor", "55", "fillcolor", "77", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "same_color", "line", "get_color", "m", "color", "assert", "same_color", "line", "get_markeredgecolor", "m", "edgecolor", "assert", "same_color", "line", "get_markerfacecolor", "m", "fillcolor"], "doc_len": 58}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_shared_colors_mapped", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_shared_colors_mapped", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_shared_colors_mapped(self):\n\n        x = y = [1, 2, 3, 4]\n        c = [\"a\", \"a\", \"b\", \"b\"]\n        m = Path()\n        p = Plot(x=x, y=y, color=c).add(m).plot()\n        ax = p._figure.axes[0]\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        for i, line in enumerate(ax.get_lines()):\n            assert same_color(line.get_color(), colors[i])\n            assert same_color(line.get_markeredgecolor(), colors[i])\n            assert same_color(line.get_markerfacecolor(), colors[i])\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_shared_colors_mapped", "self", "x", "y", "1", "2", "3", "4", "c", "a", "a", "b", "b", "m", "path", "p", "plot", "x", "x", "y", "y", "color", "c", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "for", "i", "line", "in", "enumerate", "ax", "get_lines", "assert", "same_color", "line", "get_color", "colors", "i", "assert", "same_color", "line", "get_markeredgecolor", "colors", "i", "assert", "same_color", "line", "get_markerfacecolor", "colors", "i"], "doc_len": 69}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_separate_colors_mapped", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_separate_colors_mapped", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_separate_colors_mapped(self):\n\n        x = y = [1, 2, 3, 4]\n        c = [\"a\", \"a\", \"b\", \"b\"]\n        d = [\"x\", \"y\", \"x\", \"y\"]\n        m = Path()\n        p = Plot(x=x, y=y, color=c, fillcolor=d).add(m).plot()\n        ax = p._figure.axes[0]\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n        for i, line in enumerate(ax.get_lines()):\n            assert same_color(line.get_color(), colors[i // 2])\n            assert same_color(line.get_markeredgecolor(), colors[i // 2])\n            assert same_color(line.get_markerfacecolor(), colors[i % 2])\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_separate_colors_mapped", "self", "x", "y", "1", "2", "3", "4", "c", "a", "a", "b", "b", "d", "x", "y", "x", "y", "m", "path", "p", "plot", "x", "x", "y", "y", "color", "c", "fillcolor", "d", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "for", "i", "line", "in", "enumerate", "ax", "get_lines", "assert", "same_color", "line", "get_color", "colors", "i", "2", "assert", "same_color", "line", "get_markeredgecolor", "colors", "i", "2", "assert", "same_color", "line", "get_markerfacecolor", "colors", "i", "2"], "doc_len": 79}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_color_with_alpha", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_color_with_alpha", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_color_with_alpha(self):\n\n        x = y = [1, 2, 3]\n        m = Path(color=(.4, .9, .2, .5), fillcolor=(.2, .2, .3, .9))\n        p = Plot(x=x, y=y).add(m).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert same_color(line.get_color(), m.color)\n        assert same_color(line.get_markeredgecolor(), m.color)\n        assert same_color(line.get_markerfacecolor(), m.fillcolor)\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_color_with_alpha", "self", "x", "y", "1", "2", "3", "m", "path", "color", "4", "9", "2", "5", "fillcolor", "2", "2", "3", "9", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "same_color", "line", "get_color", "m", "color", "assert", "same_color", "line", "get_markeredgecolor", "m", "color", "assert", "same_color", "line", "get_markerfacecolor", "m", "fillcolor"], "doc_len": 58}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_color_and_alpha", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_color_and_alpha", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_color_and_alpha(self):\n\n        x = y = [1, 2, 3]\n        m = Path(color=(.4, .9, .2), fillcolor=(.2, .2, .3), alpha=.5)\n        p = Plot(x=x, y=y).add(m).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert same_color(line.get_color(), to_rgba(m.color, m.alpha))\n        assert same_color(line.get_markeredgecolor(), to_rgba(m.color, m.alpha))\n        assert same_color(line.get_markerfacecolor(), to_rgba(m.fillcolor, m.alpha))\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_color_and_alpha", "self", "x", "y", "1", "2", "3", "m", "path", "color", "4", "9", "2", "fillcolor", "2", "2", "3", "alpha", "5", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "same_color", "line", "get_color", "to_rgba", "m", "color", "m", "alpha", "assert", "same_color", "line", "get_markeredgecolor", "to_rgba", "m", "color", "m", "alpha", "assert", "same_color", "line", "get_markerfacecolor", "to_rgba", "m", "fillcolor", "m", "alpha"], "doc_len": 67}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_other_props_direct", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_other_props_direct", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_other_props_direct(self):\n\n        x = y = [1, 2, 3]\n        m = Path(marker=\"s\", linestyle=\"--\", linewidth=3, pointsize=10, edgewidth=1)\n        p = Plot(x=x, y=y).add(m).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert line.get_marker() == m.marker\n        assert line.get_linestyle() == m.linestyle\n        assert line.get_linewidth() == m.linewidth\n        assert line.get_markersize() == m.pointsize\n        assert line.get_markeredgewidth() == m.edgewidth\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_other_props_direct", "self", "x", "y", "1", "2", "3", "m", "path", "marker", "s", "linestyle", "linewidth", "3", "pointsize", "10", "edgewidth", "1", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "line", "get_marker", "m", "marker", "assert", "line", "get_linestyle", "m", "linestyle", "assert", "line", "get_linewidth", "m", "linewidth", "assert", "line", "get_markersize", "m", "pointsize", "assert", "line", "get_markeredgewidth", "m", "edgewidth"], "doc_len": 64}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_other_props_mapped", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_other_props_mapped", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_other_props_mapped(self):\n\n        x = y = [1, 2, 3, 4]\n        g = [\"a\", \"a\", \"b\", \"b\"]\n        m = Path()\n        p = Plot(x=x, y=y, marker=g, linestyle=g, pointsize=g).add(m).plot()\n        line1, line2 = p._figure.axes[0].get_lines()\n        assert line1.get_marker() != line2.get_marker()\n        # Matplotlib bug in storing linestyle from dash pattern\n        # assert line1.get_linestyle() != line2.get_linestyle()\n        assert line1.get_markersize() != line2.get_markersize()\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_other_props_mapped", "self", "x", "y", "1", "2", "3", "4", "g", "a", "a", "b", "b", "m", "path", "p", "plot", "x", "x", "y", "y", "marker", "g", "linestyle", "g", "pointsize", "g", "add", "m", "plot", "line1", "line2", "p", "_figure", "axes", "0", "get_lines", "assert", "line1", "get_marker", "line2", "get_marker", "matplotlib", "bug", "in", "storing", "linestyle", "from", "dash", "pattern", "assert", "line1", "get_linestyle", "line2", "get_linestyle", "assert", "line1", "get_markersize", "line2", "get_markersize"], "doc_len": 66}
{"doc_id": "tests/_marks/test_line.py::TestPath.test_capstyle", "file_path": "tests/_marks/test_line.py", "class_name": "TestPath", "func_name": "test_capstyle", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPath\n    def test_capstyle(self):\n\n        x = y = [1, 2]\n        rc = {\"lines.solid_capstyle\": \"projecting\", \"lines.dash_capstyle\": \"round\"}\n\n        p = Plot(x, y).add(Path()).theme(rc).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert line.get_dash_capstyle() == \"projecting\"\n\n        p = Plot(x, y).add(Path(linestyle=\"--\")).theme(rc).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert line.get_dash_capstyle() == \"round\"\n\n        p = Plot(x, y).add(Path({\"solid_capstyle\": \"butt\"})).theme(rc).plot()\n        line, = p._figure.axes[0].get_lines()\n        assert line.get_solid_capstyle() == \"butt\"\n", "tokens": ["tests", "_marks", "test_line", "py", "testpath", "def", "test_capstyle", "self", "x", "y", "1", "2", "rc", "lines", "solid_capstyle", "projecting", "lines", "dash_capstyle", "round", "p", "plot", "x", "y", "add", "path", "theme", "rc", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "line", "get_dash_capstyle", "projecting", "p", "plot", "x", "y", "add", "path", "linestyle", "theme", "rc", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "line", "get_dash_capstyle", "round", "p", "plot", "x", "y", "add", "path", "solid_capstyle", "butt", "theme", "rc", "plot", "line", "p", "_figure", "axes", "0", "get_lines", "assert", "line", "get_solid_capstyle", "butt"], "doc_len": 79}
{"doc_id": "tests/_marks/test_line.py::TestLine.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestLine", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestLine\n    def test_xy_data(self):\n\n        x = [1, 5, 3, np.nan, 2]\n        y = [1, 4, 2, 5, 3]\n        g = [1, 2, 1, 1, 2]\n        p = Plot(x=x, y=y, group=g).add(Line()).plot()\n        line1, line2 = p._figure.axes[0].get_lines()\n\n        assert_array_equal(line1.get_xdata(), [1, 3])\n        assert_array_equal(line1.get_ydata(), [1, 2])\n        assert_array_equal(line2.get_xdata(), [2, 5])\n        assert_array_equal(line2.get_ydata(), [3, 4])\n", "tokens": ["tests", "_marks", "test_line", "py", "testline", "def", "test_xy_data", "self", "x", "1", "5", "3", "np", "nan", "2", "y", "1", "4", "2", "5", "3", "g", "1", "2", "1", "1", "2", "p", "plot", "x", "x", "y", "y", "group", "g", "add", "line", "plot", "line1", "line2", "p", "_figure", "axes", "0", "get_lines", "assert_array_equal", "line1", "get_xdata", "1", "3", "assert_array_equal", "line1", "get_ydata", "1", "2", "assert_array_equal", "line2", "get_xdata", "2", "5", "assert_array_equal", "line2", "get_ydata", "3", "4"], "doc_len": 65}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_xy_data(self):\n\n        x = [1, 5, 3, np.nan, 2]\n        y = [1, 4, 2, 5, 3]\n        g = [1, 2, 1, 1, 2]\n        p = Plot(x=x, y=y, group=g).add(Paths()).plot()\n        lines, = p._figure.axes[0].collections\n\n        verts = lines.get_paths()[0].vertices.T\n        assert_array_equal(verts[0], [1, 3, np.nan])\n        assert_array_equal(verts[1], [1, 2, np.nan])\n\n        verts = lines.get_paths()[1].vertices.T\n        assert_array_equal(verts[0], [5, 2])\n        assert_array_equal(verts[1], [4, 3])\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_xy_data", "self", "x", "1", "5", "3", "np", "nan", "2", "y", "1", "4", "2", "5", "3", "g", "1", "2", "1", "1", "2", "p", "plot", "x", "x", "y", "y", "group", "g", "add", "paths", "plot", "lines", "p", "_figure", "axes", "0", "collections", "verts", "lines", "get_paths", "0", "vertices", "t", "assert_array_equal", "verts", "0", "1", "3", "np", "nan", "assert_array_equal", "verts", "1", "1", "2", "np", "nan", "verts", "lines", "get_paths", "1", "vertices", "t", "assert_array_equal", "verts", "0", "5", "2", "assert_array_equal", "verts", "1", "4", "3"], "doc_len": 80}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_set_properties", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_set_properties", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_set_properties(self):\n\n        x = y = [1, 2, 3]\n        m = Paths(color=\".737\", linewidth=1, linestyle=(3, 1))\n        p = Plot(x=x, y=y).add(m).plot()\n        lines, = p._figure.axes[0].collections\n\n        assert same_color(lines.get_color().squeeze(), m.color)\n        assert lines.get_linewidth().item() == m.linewidth\n        assert lines.get_linestyle()[0] == (0, list(m.linestyle))\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_set_properties", "self", "x", "y", "1", "2", "3", "m", "paths", "color", "737", "linewidth", "1", "linestyle", "3", "1", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "lines", "p", "_figure", "axes", "0", "collections", "assert", "same_color", "lines", "get_color", "squeeze", "m", "color", "assert", "lines", "get_linewidth", "item", "m", "linewidth", "assert", "lines", "get_linestyle", "0", "0", "list", "m", "linestyle"], "doc_len": 58}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_mapped_properties", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_mapped_properties", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_mapped_properties(self):\n\n        x = y = [1, 2, 3, 4]\n        g = [\"a\", \"a\", \"b\", \"b\"]\n        p = Plot(x=x, y=y, color=g, linewidth=g, linestyle=g).add(Paths()).plot()\n        lines, = p._figure.axes[0].collections\n\n        assert not np.array_equal(lines.get_colors()[0], lines.get_colors()[1])\n        assert lines.get_linewidths()[0] != lines.get_linewidth()[1]\n        assert lines.get_linestyle()[0] != lines.get_linestyle()[1]\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_mapped_properties", "self", "x", "y", "1", "2", "3", "4", "g", "a", "a", "b", "b", "p", "plot", "x", "x", "y", "y", "color", "g", "linewidth", "g", "linestyle", "g", "add", "paths", "plot", "lines", "p", "_figure", "axes", "0", "collections", "assert", "not", "np", "array_equal", "lines", "get_colors", "0", "lines", "get_colors", "1", "assert", "lines", "get_linewidths", "0", "lines", "get_linewidth", "1", "assert", "lines", "get_linestyle", "0", "lines", "get_linestyle", "1"], "doc_len": 64}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_color_with_alpha", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_color_with_alpha", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_color_with_alpha(self):\n\n        x = y = [1, 2, 3]\n        m = Paths(color=(.2, .6, .9, .5))\n        p = Plot(x=x, y=y).add(m).plot()\n        lines, = p._figure.axes[0].collections\n        assert same_color(lines.get_colors().squeeze(), m.color)\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_color_with_alpha", "self", "x", "y", "1", "2", "3", "m", "paths", "color", "2", "6", "9", "5", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "lines", "p", "_figure", "axes", "0", "collections", "assert", "same_color", "lines", "get_colors", "squeeze", "m", "color"], "doc_len": 42}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_color_and_alpha", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_color_and_alpha", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_color_and_alpha(self):\n\n        x = y = [1, 2, 3]\n        m = Paths(color=(.2, .6, .9), alpha=.5)\n        p = Plot(x=x, y=y).add(m).plot()\n        lines, = p._figure.axes[0].collections\n        assert same_color(lines.get_colors().squeeze(), to_rgba(m.color, m.alpha))\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_color_and_alpha", "self", "x", "y", "1", "2", "3", "m", "paths", "color", "2", "6", "9", "alpha", "5", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "lines", "p", "_figure", "axes", "0", "collections", "assert", "same_color", "lines", "get_colors", "squeeze", "to_rgba", "m", "color", "m", "alpha"], "doc_len": 46}
{"doc_id": "tests/_marks/test_line.py::TestPaths.test_capstyle", "file_path": "tests/_marks/test_line.py", "class_name": "TestPaths", "func_name": "test_capstyle", "text": "文件路径: tests/_marks/test_line.py, 类名: TestPaths\n    def test_capstyle(self):\n\n        x = y = [1, 2]\n        rc = {\"lines.solid_capstyle\": \"projecting\"}\n\n        with mpl.rc_context(rc):\n            p = Plot(x, y).add(Paths()).plot()\n            lines = p._figure.axes[0].collections[0]\n            assert lines.get_capstyle() == \"projecting\"\n\n            p = Plot(x, y).add(Paths(linestyle=\"--\")).plot()\n            lines = p._figure.axes[0].collections[0]\n            assert lines.get_capstyle() == \"projecting\"\n\n            p = Plot(x, y).add(Paths({\"capstyle\": \"butt\"})).plot()\n            lines = p._figure.axes[0].collections[0]\n            assert lines.get_capstyle() == \"butt\"\n", "tokens": ["tests", "_marks", "test_line", "py", "testpaths", "def", "test_capstyle", "self", "x", "y", "1", "2", "rc", "lines", "solid_capstyle", "projecting", "with", "mpl", "rc_context", "rc", "p", "plot", "x", "y", "add", "paths", "plot", "lines", "p", "_figure", "axes", "0", "collections", "0", "assert", "lines", "get_capstyle", "projecting", "p", "plot", "x", "y", "add", "paths", "linestyle", "plot", "lines", "p", "_figure", "axes", "0", "collections", "0", "assert", "lines", "get_capstyle", "projecting", "p", "plot", "x", "y", "add", "paths", "capstyle", "butt", "plot", "lines", "p", "_figure", "axes", "0", "collections", "0", "assert", "lines", "get_capstyle", "butt"], "doc_len": 77}
{"doc_id": "tests/_marks/test_line.py::TestLines.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestLines", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestLines\n    def test_xy_data(self):\n\n        x = [1, 5, 3, np.nan, 2]\n        y = [1, 4, 2, 5, 3]\n        g = [1, 2, 1, 1, 2]\n        p = Plot(x=x, y=y, group=g).add(Lines()).plot()\n        lines, = p._figure.axes[0].collections\n\n        verts = lines.get_paths()[0].vertices.T\n        assert_array_equal(verts[0], [1, 3])\n        assert_array_equal(verts[1], [1, 2])\n\n        verts = lines.get_paths()[1].vertices.T\n        assert_array_equal(verts[0], [2, 5])\n        assert_array_equal(verts[1], [3, 4])\n", "tokens": ["tests", "_marks", "test_line", "py", "testlines", "def", "test_xy_data", "self", "x", "1", "5", "3", "np", "nan", "2", "y", "1", "4", "2", "5", "3", "g", "1", "2", "1", "1", "2", "p", "plot", "x", "x", "y", "y", "group", "g", "add", "lines", "plot", "lines", "p", "_figure", "axes", "0", "collections", "verts", "lines", "get_paths", "0", "vertices", "t", "assert_array_equal", "verts", "0", "1", "3", "assert_array_equal", "verts", "1", "1", "2", "verts", "lines", "get_paths", "1", "vertices", "t", "assert_array_equal", "verts", "0", "2", "5", "assert_array_equal", "verts", "1", "3", "4"], "doc_len": 76}
{"doc_id": "tests/_marks/test_line.py::TestLines.test_single_orient_value", "file_path": "tests/_marks/test_line.py", "class_name": "TestLines", "func_name": "test_single_orient_value", "text": "文件路径: tests/_marks/test_line.py, 类名: TestLines\n    def test_single_orient_value(self):\n\n        x = [1, 1, 1]\n        y = [1, 2, 3]\n        p = Plot(x, y).add(Lines()).plot()\n        lines, = p._figure.axes[0].collections\n        verts = lines.get_paths()[0].vertices.T\n        assert_array_equal(verts[0], x)\n        assert_array_equal(verts[1], y)\n", "tokens": ["tests", "_marks", "test_line", "py", "testlines", "def", "test_single_orient_value", "self", "x", "1", "1", "1", "y", "1", "2", "3", "p", "plot", "x", "y", "add", "lines", "plot", "lines", "p", "_figure", "axes", "0", "collections", "verts", "lines", "get_paths", "0", "vertices", "t", "assert_array_equal", "verts", "0", "x", "assert_array_equal", "verts", "1", "y"], "doc_len": 43}
{"doc_id": "tests/_marks/test_line.py::TestRange.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestRange", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestRange\n    def test_xy_data(self):\n\n        x = [1, 2]\n        ymin = [1, 4]\n        ymax = [2, 3]\n\n        p = Plot(x=x, ymin=ymin, ymax=ymax).add(Range()).plot()\n        lines, = p._figure.axes[0].collections\n\n        for i, path in enumerate(lines.get_paths()):\n            verts = path.vertices.T\n            assert_array_equal(verts[0], [x[i], x[i]])\n            assert_array_equal(verts[1], [ymin[i], ymax[i]])\n", "tokens": ["tests", "_marks", "test_line", "py", "testrange", "def", "test_xy_data", "self", "x", "1", "2", "ymin", "1", "4", "ymax", "2", "3", "p", "plot", "x", "x", "ymin", "ymin", "ymax", "ymax", "add", "range", "plot", "lines", "p", "_figure", "axes", "0", "collections", "for", "i", "path", "in", "enumerate", "lines", "get_paths", "verts", "path", "vertices", "t", "assert_array_equal", "verts", "0", "x", "i", "x", "i", "assert_array_equal", "verts", "1", "ymin", "i", "ymax", "i"], "doc_len": 59}
{"doc_id": "tests/_marks/test_line.py::TestRange.test_auto_range", "file_path": "tests/_marks/test_line.py", "class_name": "TestRange", "func_name": "test_auto_range", "text": "文件路径: tests/_marks/test_line.py, 类名: TestRange\n    def test_auto_range(self):\n\n        x = [1, 1, 2, 2, 2]\n        y = [1, 2, 3, 4, 5]\n\n        p = Plot(x=x, y=y).add(Range()).plot()\n        lines, = p._figure.axes[0].collections\n        paths = lines.get_paths()\n        assert_array_equal(paths[0].vertices, [(1, 1), (1, 2)])\n        assert_array_equal(paths[1].vertices, [(2, 3), (2, 5)])\n", "tokens": ["tests", "_marks", "test_line", "py", "testrange", "def", "test_auto_range", "self", "x", "1", "1", "2", "2", "2", "y", "1", "2", "3", "4", "5", "p", "plot", "x", "x", "y", "y", "add", "range", "plot", "lines", "p", "_figure", "axes", "0", "collections", "paths", "lines", "get_paths", "assert_array_equal", "paths", "0", "vertices", "1", "1", "1", "2", "assert_array_equal", "paths", "1", "vertices", "2", "3", "2", "5"], "doc_len": 54}
{"doc_id": "tests/_marks/test_line.py::TestRange.test_mapped_color", "file_path": "tests/_marks/test_line.py", "class_name": "TestRange", "func_name": "test_mapped_color", "text": "文件路径: tests/_marks/test_line.py, 类名: TestRange\n    def test_mapped_color(self):\n\n        x = [1, 2, 1, 2]\n        ymin = [1, 4, 3, 2]\n        ymax = [2, 3, 1, 4]\n        group = [\"a\", \"a\", \"b\", \"b\"]\n\n        p = Plot(x=x, ymin=ymin, ymax=ymax, color=group).add(Range()).plot()\n        lines, = p._figure.axes[0].collections\n        colors = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n\n        for i, path in enumerate(lines.get_paths()):\n            verts = path.vertices.T\n            assert_array_equal(verts[0], [x[i], x[i]])\n            assert_array_equal(verts[1], [ymin[i], ymax[i]])\n            assert same_color(lines.get_colors()[i], colors[i // 2])\n", "tokens": ["tests", "_marks", "test_line", "py", "testrange", "def", "test_mapped_color", "self", "x", "1", "2", "1", "2", "ymin", "1", "4", "3", "2", "ymax", "2", "3", "1", "4", "group", "a", "a", "b", "b", "p", "plot", "x", "x", "ymin", "ymin", "ymax", "ymax", "color", "group", "add", "range", "plot", "lines", "p", "_figure", "axes", "0", "collections", "colors", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "for", "i", "path", "in", "enumerate", "lines", "get_paths", "verts", "path", "vertices", "t", "assert_array_equal", "verts", "0", "x", "i", "x", "i", "assert_array_equal", "verts", "1", "ymin", "i", "ymax", "i", "assert", "same_color", "lines", "get_colors", "i", "colors", "i", "2"], "doc_len": 87}
{"doc_id": "tests/_marks/test_line.py::TestRange.test_direct_properties", "file_path": "tests/_marks/test_line.py", "class_name": "TestRange", "func_name": "test_direct_properties", "text": "文件路径: tests/_marks/test_line.py, 类名: TestRange\n    def test_direct_properties(self):\n\n        x = [1, 2]\n        ymin = [1, 4]\n        ymax = [2, 3]\n\n        m = Range(color=\".654\", linewidth=4)\n        p = Plot(x=x, ymin=ymin, ymax=ymax).add(m).plot()\n        lines, = p._figure.axes[0].collections\n\n        for i, path in enumerate(lines.get_paths()):\n            assert same_color(lines.get_colors()[i], m.color)\n            assert lines.get_linewidths()[i] == m.linewidth\n", "tokens": ["tests", "_marks", "test_line", "py", "testrange", "def", "test_direct_properties", "self", "x", "1", "2", "ymin", "1", "4", "ymax", "2", "3", "m", "range", "color", "654", "linewidth", "4", "p", "plot", "x", "x", "ymin", "ymin", "ymax", "ymax", "add", "m", "plot", "lines", "p", "_figure", "axes", "0", "collections", "for", "i", "path", "in", "enumerate", "lines", "get_paths", "assert", "same_color", "lines", "get_colors", "i", "m", "color", "assert", "lines", "get_linewidths", "i", "m", "linewidth"], "doc_len": 60}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_xy_data", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_xy_data", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_xy_data(self):\n\n        x = [0, 0, 1, 2]\n        y = [1, 2, 3, 4]\n\n        p = Plot(x=x, y=y).add(Dash()).plot()\n        lines, = p._figure.axes[0].collections\n\n        for i, path in enumerate(lines.get_paths()):\n            verts = path.vertices.T\n            assert_array_almost_equal(verts[0], [x[i] - .4, x[i] + .4])\n            assert_array_equal(verts[1], [y[i], y[i]])\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_xy_data", "self", "x", "0", "0", "1", "2", "y", "1", "2", "3", "4", "p", "plot", "x", "x", "y", "y", "add", "dash", "plot", "lines", "p", "_figure", "axes", "0", "collections", "for", "i", "path", "in", "enumerate", "lines", "get_paths", "verts", "path", "vertices", "t", "assert_array_almost_equal", "verts", "0", "x", "i", "4", "x", "i", "4", "assert_array_equal", "verts", "1", "y", "i", "y", "i"], "doc_len": 60}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_xy_data_grouped", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_xy_data_grouped", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_xy_data_grouped(self):\n\n        x = [0, 0, 1, 2]\n        y = [1, 2, 3, 4]\n        color = [\"a\", \"b\", \"a\", \"b\"]\n\n        p = Plot(x=x, y=y, color=color).add(Dash()).plot()\n        lines, = p._figure.axes[0].collections\n\n        idx = [0, 2, 1, 3]\n        for i, path in zip(idx, lines.get_paths()):\n            verts = path.vertices.T\n            assert_array_almost_equal(verts[0], [x[i] - .4, x[i] + .4])\n            assert_array_equal(verts[1], [y[i], y[i]])\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_xy_data_grouped", "self", "x", "0", "0", "1", "2", "y", "1", "2", "3", "4", "color", "a", "b", "a", "b", "p", "plot", "x", "x", "y", "y", "color", "color", "add", "dash", "plot", "lines", "p", "_figure", "axes", "0", "collections", "idx", "0", "2", "1", "3", "for", "i", "path", "in", "zip", "idx", "lines", "get_paths", "verts", "path", "vertices", "t", "assert_array_almost_equal", "verts", "0", "x", "i", "4", "x", "i", "4", "assert_array_equal", "verts", "1", "y", "i", "y", "i"], "doc_len": 73}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_set_properties", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_set_properties", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_set_properties(self):\n\n        x = [0, 0, 1, 2]\n        y = [1, 2, 3, 4]\n\n        m = Dash(color=\".8\", linewidth=4)\n        p = Plot(x=x, y=y).add(m).plot()\n        lines, = p._figure.axes[0].collections\n\n        for color in lines.get_color():\n            assert same_color(color, m.color)\n        for linewidth in lines.get_linewidth():\n            assert linewidth == m.linewidth\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_set_properties", "self", "x", "0", "0", "1", "2", "y", "1", "2", "3", "4", "m", "dash", "color", "8", "linewidth", "4", "p", "plot", "x", "x", "y", "y", "add", "m", "plot", "lines", "p", "_figure", "axes", "0", "collections", "for", "color", "in", "lines", "get_color", "assert", "same_color", "color", "m", "color", "for", "linewidth", "in", "lines", "get_linewidth", "assert", "linewidth", "m", "linewidth"], "doc_len": 58}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_mapped_properties", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_mapped_properties", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_mapped_properties(self):\n\n        x = [0, 1]\n        y = [1, 2]\n        color = [\"a\", \"b\"]\n        linewidth = [1, 2]\n\n        p = Plot(x=x, y=y, color=color, linewidth=linewidth).add(Dash()).plot()\n        lines, = p._figure.axes[0].collections\n        palette = p._theme[\"axes.prop_cycle\"].by_key()[\"color\"]\n\n        for color, line_color in zip(palette, lines.get_color()):\n            assert same_color(color, line_color)\n\n        linewidths = lines.get_linewidths()\n        assert linewidths[1] > linewidths[0]\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_mapped_properties", "self", "x", "0", "1", "y", "1", "2", "color", "a", "b", "linewidth", "1", "2", "p", "plot", "x", "x", "y", "y", "color", "color", "linewidth", "linewidth", "add", "dash", "plot", "lines", "p", "_figure", "axes", "0", "collections", "palette", "p", "_theme", "axes", "prop_cycle", "by_key", "color", "for", "color", "line_color", "in", "zip", "palette", "lines", "get_color", "assert", "same_color", "color", "line_color", "linewidths", "lines", "get_linewidths", "assert", "linewidths", "1", "linewidths", "0"], "doc_len": 66}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_width", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_width", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_width(self):\n\n        x = [0, 0, 1, 2]\n        y = [1, 2, 3, 4]\n\n        p = Plot(x=x, y=y).add(Dash(width=.4)).plot()\n        lines, = p._figure.axes[0].collections\n\n        for i, path in enumerate(lines.get_paths()):\n            verts = path.vertices.T\n            assert_array_almost_equal(verts[0], [x[i] - .2, x[i] + .2])\n            assert_array_equal(verts[1], [y[i], y[i]])\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_width", "self", "x", "0", "0", "1", "2", "y", "1", "2", "3", "4", "p", "plot", "x", "x", "y", "y", "add", "dash", "width", "4", "plot", "lines", "p", "_figure", "axes", "0", "collections", "for", "i", "path", "in", "enumerate", "lines", "get_paths", "verts", "path", "vertices", "t", "assert_array_almost_equal", "verts", "0", "x", "i", "2", "x", "i", "2", "assert_array_equal", "verts", "1", "y", "i", "y", "i"], "doc_len": 62}
{"doc_id": "tests/_marks/test_line.py::TestDash.test_dodge", "file_path": "tests/_marks/test_line.py", "class_name": "TestDash", "func_name": "test_dodge", "text": "文件路径: tests/_marks/test_line.py, 类名: TestDash\n    def test_dodge(self):\n\n        x = [0, 1]\n        y = [1, 2]\n        group = [\"a\", \"b\"]\n\n        p = Plot(x=x, y=y, group=group).add(Dash(), Dodge()).plot()\n        lines, = p._figure.axes[0].collections\n\n        paths = lines.get_paths()\n\n        v0 = paths[0].vertices.T\n        assert_array_almost_equal(v0[0], [-.4, 0])\n        assert_array_equal(v0[1], [y[0], y[0]])\n\n        v1 = paths[1].vertices.T\n        assert_array_almost_equal(v1[0], [1, 1.4])\n        assert_array_equal(v1[1], [y[1], y[1]])\n", "tokens": ["tests", "_marks", "test_line", "py", "testdash", "def", "test_dodge", "self", "x", "0", "1", "y", "1", "2", "group", "a", "b", "p", "plot", "x", "x", "y", "y", "group", "group", "add", "dash", "dodge", "plot", "lines", "p", "_figure", "axes", "0", "collections", "paths", "lines", "get_paths", "v0", "paths", "0", "vertices", "t", "assert_array_almost_equal", "v0", "0", "4", "0", "assert_array_equal", "v0", "1", "y", "0", "y", "0", "v1", "paths", "1", "vertices", "t", "assert_array_almost_equal", "v1", "0", "1", "1", "4", "assert_array_equal", "v1", "1", "y", "1", "y", "1"], "doc_len": 73}
{"doc_id": "tests/_marks/test_text.py::TestText.get_texts", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "get_texts", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def get_texts(self, ax):\n        if ax.texts:\n            return list(ax.texts)\n        else:\n            # Compatibility with matplotlib < 3.5 (I think)\n            return [a for a in ax.artists if isinstance(a, MPLText)]\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "get_texts", "self", "ax", "if", "ax", "texts", "return", "list", "ax", "texts", "else", "compatibility", "with", "matplotlib", "3", "5", "i", "think", "return", "a", "for", "a", "in", "ax", "artists", "if", "isinstance", "a", "mpltext"], "doc_len": 35}
{"doc_id": "tests/_marks/test_text.py::TestText.test_simple", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_simple", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_simple(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n\n        p = Plot(x, y, text=s).add(Text()).plot()\n        ax = p._figure.axes[0]\n        for i, text in enumerate(self.get_texts(ax)):\n            x_, y_ = text.get_position()\n            assert x_ == x[i]\n            assert y_ == y[i]\n            assert text.get_text() == s[i]\n            assert text.get_horizontalalignment() == \"center\"\n            assert text.get_verticalalignment() == \"center_baseline\"\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_simple", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "p", "plot", "x", "y", "text", "s", "add", "text", "plot", "ax", "p", "_figure", "axes", "0", "for", "i", "text", "in", "enumerate", "self", "get_texts", "ax", "x_", "y_", "text", "get_position", "assert", "x_", "x", "i", "assert", "y_", "y", "i", "assert", "text", "get_text", "s", "i", "assert", "text", "get_horizontalalignment", "center", "assert", "text", "get_verticalalignment", "center_baseline"], "doc_len": 63}
{"doc_id": "tests/_marks/test_text.py::TestText.test_set_properties", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_set_properties", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_set_properties(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        color = \"red\"\n        alpha = .6\n        fontsize = 6\n        valign = \"bottom\"\n\n        m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n        p = Plot(x, y, text=s).add(m).plot()\n        ax = p._figure.axes[0]\n        for i, text in enumerate(self.get_texts(ax)):\n            assert text.get_text() == s[i]\n            assert text.get_color() == to_rgba(m.color, m.alpha)\n            assert text.get_fontsize() == m.fontsize\n            assert text.get_verticalalignment() == m.valign\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_set_properties", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "color", "red", "alpha", "6", "fontsize", "6", "valign", "bottom", "m", "text", "color", "color", "alpha", "alpha", "fontsize", "fontsize", "valign", "valign", "p", "plot", "x", "y", "text", "s", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "for", "i", "text", "in", "enumerate", "self", "get_texts", "ax", "assert", "text", "get_text", "s", "i", "assert", "text", "get_color", "to_rgba", "m", "color", "m", "alpha", "assert", "text", "get_fontsize", "m", "fontsize", "assert", "text", "get_verticalalignment", "m", "valign"], "doc_len": 79}
{"doc_id": "tests/_marks/test_text.py::TestText.test_mapped_properties", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_mapped_properties", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_mapped_properties(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        color = list(\"aab\")\n        fontsize = [1, 2, 4]\n\n        p = Plot(x, y, color=color, fontsize=fontsize, text=s).add(Text()).plot()\n        ax = p._figure.axes[0]\n        texts = self.get_texts(ax)\n        assert texts[0].get_color() == texts[1].get_color()\n        assert texts[0].get_color() != texts[2].get_color()\n        assert (\n            texts[0].get_fontsize()\n            < texts[1].get_fontsize()\n            < texts[2].get_fontsize()\n        )\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_mapped_properties", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "color", "list", "aab", "fontsize", "1", "2", "4", "p", "plot", "x", "y", "color", "color", "fontsize", "fontsize", "text", "s", "add", "text", "plot", "ax", "p", "_figure", "axes", "0", "texts", "self", "get_texts", "ax", "assert", "texts", "0", "get_color", "texts", "1", "get_color", "assert", "texts", "0", "get_color", "texts", "2", "get_color", "assert", "texts", "0", "get_fontsize", "texts", "1", "get_fontsize", "texts", "2", "get_fontsize"], "doc_len": 69}
{"doc_id": "tests/_marks/test_text.py::TestText.test_mapped_alignment", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_mapped_alignment", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_mapped_alignment(self):\n\n        x = [1, 2]\n        p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n        ax = p._figure.axes[0]\n        t1, t2 = self.get_texts(ax)\n        assert t1.get_horizontalalignment() == \"left\"\n        assert t2.get_horizontalalignment() == \"right\"\n        assert t1.get_verticalalignment() == \"top\"\n        assert t2.get_verticalalignment() == \"bottom\"\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_mapped_alignment", "self", "x", "1", "2", "p", "plot", "x", "x", "y", "x", "halign", "x", "valign", "x", "text", "x", "add", "text", "plot", "ax", "p", "_figure", "axes", "0", "t1", "t2", "self", "get_texts", "ax", "assert", "t1", "get_horizontalalignment", "left", "assert", "t2", "get_horizontalalignment", "right", "assert", "t1", "get_verticalalignment", "top", "assert", "t2", "get_verticalalignment", "bottom"], "doc_len": 52}
{"doc_id": "tests/_marks/test_text.py::TestText.test_identity_fontsize", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_identity_fontsize", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_identity_fontsize(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        fs = [5, 8, 12]\n        p = Plot(x, y, text=s, fontsize=fs).add(Text()).scale(fontsize=None).plot()\n        ax = p._figure.axes[0]\n        for i, text in enumerate(self.get_texts(ax)):\n            assert text.get_fontsize() == fs[i]\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_identity_fontsize", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "fs", "5", "8", "12", "p", "plot", "x", "y", "text", "s", "fontsize", "fs", "add", "text", "scale", "fontsize", "none", "plot", "ax", "p", "_figure", "axes", "0", "for", "i", "text", "in", "enumerate", "self", "get_texts", "ax", "assert", "text", "get_fontsize", "fs", "i"], "doc_len": 52}
{"doc_id": "tests/_marks/test_text.py::TestText.test_offset_centered", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_offset_centered", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_offset_centered(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        p = Plot(x, y, text=s).add(Text()).plot()\n        ax = p._figure.axes[0]\n        ax_trans = ax.transData.get_matrix()\n        for text in self.get_texts(ax):\n            assert_array_almost_equal(text.get_transform().get_matrix(), ax_trans)\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_offset_centered", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "p", "plot", "x", "y", "text", "s", "add", "text", "plot", "ax", "p", "_figure", "axes", "0", "ax_trans", "ax", "transdata", "get_matrix", "for", "text", "in", "self", "get_texts", "ax", "assert_array_almost_equal", "text", "get_transform", "get_matrix", "ax_trans"], "doc_len": 45}
{"doc_id": "tests/_marks/test_text.py::TestText.test_offset_valign", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_offset_valign", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_offset_valign(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        m = Text(valign=\"bottom\", fontsize=5, offset=.1)\n        p = Plot(x, y, text=s).add(m).plot()\n        ax = p._figure.axes[0]\n        expected_shift_matrix = np.zeros((3, 3))\n        expected_shift_matrix[1, -1] = m.offset * ax.figure.dpi / 72\n        ax_trans = ax.transData.get_matrix()\n        for text in self.get_texts(ax):\n            shift_matrix = text.get_transform().get_matrix() - ax_trans\n            assert_array_almost_equal(shift_matrix, expected_shift_matrix)\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_offset_valign", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "m", "text", "valign", "bottom", "fontsize", "5", "offset", "1", "p", "plot", "x", "y", "text", "s", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "expected_shift_matrix", "np", "zeros", "3", "3", "expected_shift_matrix", "1", "1", "m", "offset", "ax", "figure", "dpi", "72", "ax_trans", "ax", "transdata", "get_matrix", "for", "text", "in", "self", "get_texts", "ax", "shift_matrix", "text", "get_transform", "get_matrix", "ax_trans", "assert_array_almost_equal", "shift_matrix", "expected_shift_matrix"], "doc_len": 70}
{"doc_id": "tests/_marks/test_text.py::TestText.test_offset_halign", "file_path": "tests/_marks/test_text.py", "class_name": "TestText", "func_name": "test_offset_halign", "text": "文件路径: tests/_marks/test_text.py, 类名: TestText\n    def test_offset_halign(self):\n\n        x = y = [1, 2, 3]\n        s = list(\"abc\")\n        m = Text(halign=\"right\", fontsize=10, offset=.5)\n        p = Plot(x, y, text=s).add(m).plot()\n        ax = p._figure.axes[0]\n        expected_shift_matrix = np.zeros((3, 3))\n        expected_shift_matrix[0, -1] = -m.offset * ax.figure.dpi / 72\n        ax_trans = ax.transData.get_matrix()\n        for text in self.get_texts(ax):\n            shift_matrix = text.get_transform().get_matrix() - ax_trans\n            assert_array_almost_equal(shift_matrix, expected_shift_matrix)\n", "tokens": ["tests", "_marks", "test_text", "py", "testtext", "def", "test_offset_halign", "self", "x", "y", "1", "2", "3", "s", "list", "abc", "m", "text", "halign", "right", "fontsize", "10", "offset", "5", "p", "plot", "x", "y", "text", "s", "add", "m", "plot", "ax", "p", "_figure", "axes", "0", "expected_shift_matrix", "np", "zeros", "3", "3", "expected_shift_matrix", "0", "1", "m", "offset", "ax", "figure", "dpi", "72", "ax_trans", "ax", "transdata", "get_matrix", "for", "text", "in", "self", "get_texts", "ax", "shift_matrix", "text", "get_transform", "get_matrix", "ax_trans", "assert_array_almost_equal", "shift_matrix", "expected_shift_matrix"], "doc_len": 70}
{"doc_id": "tests/_stats/test_aggregation.py::AggregationFixtures.df", "file_path": "tests/_stats/test_aggregation.py", "class_name": "AggregationFixtures", "func_name": "df", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: AggregationFixtures\n    def df(self, rng):\n\n        n = 30\n        return pd.DataFrame(dict(\n            x=rng.uniform(0, 7, n).round(),\n            y=rng.normal(size=n),\n            color=rng.choice([\"a\", \"b\", \"c\"], n),\n            group=rng.choice([\"x\", \"y\"], n),\n        ))\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "aggregationfixtures", "def", "df", "self", "rng", "n", "30", "return", "pd", "dataframe", "dict", "x", "rng", "uniform", "0", "7", "n", "round", "y", "rng", "normal", "size", "n", "color", "rng", "choice", "a", "b", "c", "n", "group", "rng", "choice", "x", "y", "n"], "doc_len": 40}
{"doc_id": "tests/_stats/test_aggregation.py::AggregationFixtures.get_groupby", "file_path": "tests/_stats/test_aggregation.py", "class_name": "AggregationFixtures", "func_name": "get_groupby", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: AggregationFixtures\n    def get_groupby(self, df, orient):\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        cols = [c for c in df if c != other]\n        return GroupBy(cols)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "aggregationfixtures", "def", "get_groupby", "self", "df", "orient", "other", "x", "y", "y", "x", "orient", "cols", "c", "for", "c", "in", "df", "if", "c", "other", "return", "groupby", "cols"], "doc_len": 28}
{"doc_id": "tests/_stats/test_aggregation.py::TestAgg.test_default", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestAgg", "func_name": "test_default", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestAgg\n    def test_default(self, df):\n\n        ori = \"x\"\n        df = df[[\"x\", \"y\"]]\n        gb = self.get_groupby(df, ori)\n        res = Agg()(df, gb, ori, {})\n\n        expected = df.groupby(\"x\", as_index=False)[\"y\"].mean()\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testagg", "def", "test_default", "self", "df", "ori", "x", "df", "df", "x", "y", "gb", "self", "get_groupby", "df", "ori", "res", "agg", "df", "gb", "ori", "expected", "df", "groupby", "x", "as_index", "false", "y", "mean", "assert_frame_equal", "res", "expected"], "doc_len": 36}
{"doc_id": "tests/_stats/test_aggregation.py::TestAgg.test_default_multi", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestAgg", "func_name": "test_default_multi", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestAgg\n    def test_default_multi(self, df):\n\n        ori = \"x\"\n        gb = self.get_groupby(df, ori)\n        res = Agg()(df, gb, ori, {})\n\n        grp = [\"x\", \"color\", \"group\"]\n        index = pd.MultiIndex.from_product(\n            [sorted(df[\"x\"].unique()), df[\"color\"].unique(), df[\"group\"].unique()],\n            names=[\"x\", \"color\", \"group\"]\n        )\n        expected = (\n            df\n            .groupby(grp)\n            .agg(\"mean\")\n            .reindex(index=index)\n            .dropna()\n            .reset_index()\n            .reindex(columns=df.columns)\n        )\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testagg", "def", "test_default_multi", "self", "df", "ori", "x", "gb", "self", "get_groupby", "df", "ori", "res", "agg", "df", "gb", "ori", "grp", "x", "color", "group", "index", "pd", "multiindex", "from_product", "sorted", "df", "x", "unique", "df", "color", "unique", "df", "group", "unique", "names", "x", "color", "group", "expected", "df", "groupby", "grp", "agg", "mean", "reindex", "index", "index", "dropna", "reset_index", "reindex", "columns", "df", "columns", "assert_frame_equal", "res", "expected"], "doc_len": 61}
{"doc_id": "tests/_stats/test_aggregation.py::TestAgg.test_func", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestAgg", "func_name": "test_func", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestAgg\n    def test_func(self, df, func):\n\n        ori = \"x\"\n        df = df[[\"x\", \"y\"]]\n        gb = self.get_groupby(df, ori)\n        res = Agg(func)(df, gb, ori, {})\n\n        expected = df.groupby(\"x\", as_index=False)[\"y\"].agg(func)\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testagg", "def", "test_func", "self", "df", "func", "ori", "x", "df", "df", "x", "y", "gb", "self", "get_groupby", "df", "ori", "res", "agg", "func", "df", "gb", "ori", "expected", "df", "groupby", "x", "as_index", "false", "y", "agg", "func", "assert_frame_equal", "res", "expected"], "doc_len": 39}
{"doc_id": "tests/_stats/test_aggregation.py::TestEst.test_mean_sd", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestEst", "func_name": "test_mean_sd", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestEst\n    def test_mean_sd(self, df, func):\n\n        ori = \"x\"\n        df = df[[\"x\", \"y\"]]\n        gb = self.get_groupby(df, ori)\n        res = Est(func, \"sd\")(df, gb, ori, {})\n\n        grouped = df.groupby(\"x\", as_index=False)[\"y\"]\n        est = grouped.mean()\n        err = grouped.std().fillna(0)  # fillna needed only on pinned tests\n        expected = est.assign(ymin=est[\"y\"] - err[\"y\"], ymax=est[\"y\"] + err[\"y\"])\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testest", "def", "test_mean_sd", "self", "df", "func", "ori", "x", "df", "df", "x", "y", "gb", "self", "get_groupby", "df", "ori", "res", "est", "func", "sd", "df", "gb", "ori", "grouped", "df", "groupby", "x", "as_index", "false", "y", "est", "grouped", "mean", "err", "grouped", "std", "fillna", "0", "fillna", "needed", "only", "on", "pinned", "tests", "expected", "est", "assign", "ymin", "est", "y", "err", "y", "ymax", "est", "y", "err", "y", "assert_frame_equal", "res", "expected"], "doc_len": 65}
{"doc_id": "tests/_stats/test_aggregation.py::TestEst.test_sd_single_obs", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestEst", "func_name": "test_sd_single_obs", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestEst\n    def test_sd_single_obs(self):\n\n        y = 1.5\n        ori = \"x\"\n        df = pd.DataFrame([{\"x\": \"a\", \"y\": y}])\n        gb = self.get_groupby(df, ori)\n        res = Est(\"mean\", \"sd\")(df, gb, ori, {})\n        expected = df.assign(ymin=y, ymax=y)\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testest", "def", "test_sd_single_obs", "self", "y", "1", "5", "ori", "x", "df", "pd", "dataframe", "x", "a", "y", "y", "gb", "self", "get_groupby", "df", "ori", "res", "est", "mean", "sd", "df", "gb", "ori", "expected", "df", "assign", "ymin", "y", "ymax", "y", "assert_frame_equal", "res", "expected"], "doc_len": 42}
{"doc_id": "tests/_stats/test_aggregation.py::TestEst.test_median_pi", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestEst", "func_name": "test_median_pi", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestEst\n    def test_median_pi(self, df):\n\n        ori = \"x\"\n        df = df[[\"x\", \"y\"]]\n        gb = self.get_groupby(df, ori)\n        res = Est(\"median\", (\"pi\", 100))(df, gb, ori, {})\n\n        grouped = df.groupby(\"x\", as_index=False)[\"y\"]\n        est = grouped.median()\n        expected = est.assign(ymin=grouped.min()[\"y\"], ymax=grouped.max()[\"y\"])\n        assert_frame_equal(res, expected)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testest", "def", "test_median_pi", "self", "df", "ori", "x", "df", "df", "x", "y", "gb", "self", "get_groupby", "df", "ori", "res", "est", "median", "pi", "100", "df", "gb", "ori", "grouped", "df", "groupby", "x", "as_index", "false", "y", "est", "grouped", "median", "expected", "est", "assign", "ymin", "grouped", "min", "y", "ymax", "grouped", "max", "y", "assert_frame_equal", "res", "expected"], "doc_len": 52}
{"doc_id": "tests/_stats/test_aggregation.py::TestEst.test_seed", "file_path": "tests/_stats/test_aggregation.py", "class_name": "TestEst", "func_name": "test_seed", "text": "文件路径: tests/_stats/test_aggregation.py, 类名: TestEst\n    def test_seed(self, df):\n\n        ori = \"x\"\n        gb = self.get_groupby(df, ori)\n        args = df, gb, ori, {}\n        res1 = Est(\"mean\", \"ci\", seed=99)(*args)\n        res2 = Est(\"mean\", \"ci\", seed=99)(*args)\n        assert_frame_equal(res1, res2)\n", "tokens": ["tests", "_stats", "test_aggregation", "py", "testest", "def", "test_seed", "self", "df", "ori", "x", "gb", "self", "get_groupby", "df", "ori", "args", "df", "gb", "ori", "res1", "est", "mean", "ci", "seed", "99", "args", "res2", "est", "mean", "ci", "seed", "99", "args", "assert_frame_equal", "res1", "res2"], "doc_len": 37}
{"doc_id": "tests/_stats/test_counting.py::TestCount.df", "file_path": "tests/_stats/test_counting.py", "class_name": "TestCount", "func_name": "df", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestCount\n    def df(self, rng):\n\n        n = 30\n        return pd.DataFrame(dict(\n            x=rng.uniform(0, 7, n).round(),\n            y=rng.normal(size=n),\n            color=rng.choice([\"a\", \"b\", \"c\"], n),\n            group=rng.choice([\"x\", \"y\"], n),\n        ))\n", "tokens": ["tests", "_stats", "test_counting", "py", "testcount", "def", "df", "self", "rng", "n", "30", "return", "pd", "dataframe", "dict", "x", "rng", "uniform", "0", "7", "n", "round", "y", "rng", "normal", "size", "n", "color", "rng", "choice", "a", "b", "c", "n", "group", "rng", "choice", "x", "y", "n"], "doc_len": 40}
{"doc_id": "tests/_stats/test_counting.py::TestCount.get_groupby", "file_path": "tests/_stats/test_counting.py", "class_name": "TestCount", "func_name": "get_groupby", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestCount\n    def get_groupby(self, df, orient):\n\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        cols = [c for c in df if c != other]\n        return GroupBy(cols)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testcount", "def", "get_groupby", "self", "df", "orient", "other", "x", "y", "y", "x", "orient", "cols", "c", "for", "c", "in", "df", "if", "c", "other", "return", "groupby", "cols"], "doc_len": 28}
{"doc_id": "tests/_stats/test_counting.py::TestCount.test_single_grouper", "file_path": "tests/_stats/test_counting.py", "class_name": "TestCount", "func_name": "test_single_grouper", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestCount\n    def test_single_grouper(self, df):\n\n        ori = \"x\"\n        df = df[[\"x\"]]\n        gb = self.get_groupby(df, ori)\n        res = Count()(df, gb, ori, {})\n        expected = df.groupby(\"x\").size()\n        assert_array_equal(res.sort_values(\"x\")[\"y\"], expected)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testcount", "def", "test_single_grouper", "self", "df", "ori", "x", "df", "df", "x", "gb", "self", "get_groupby", "df", "ori", "res", "count", "df", "gb", "ori", "expected", "df", "groupby", "x", "size", "assert_array_equal", "res", "sort_values", "x", "y", "expected"], "doc_len": 35}
{"doc_id": "tests/_stats/test_counting.py::TestCount.test_multiple_groupers", "file_path": "tests/_stats/test_counting.py", "class_name": "TestCount", "func_name": "test_multiple_groupers", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestCount\n    def test_multiple_groupers(self, df):\n\n        ori = \"x\"\n        df = df[[\"x\", \"group\"]].sort_values(\"group\")\n        gb = self.get_groupby(df, ori)\n        res = Count()(df, gb, ori, {})\n        expected = df.groupby([\"x\", \"group\"]).size()\n        assert_array_equal(res.sort_values([\"x\", \"group\"])[\"y\"], expected)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testcount", "def", "test_multiple_groupers", "self", "df", "ori", "x", "df", "df", "x", "group", "sort_values", "group", "gb", "self", "get_groupby", "df", "ori", "res", "count", "df", "gb", "ori", "expected", "df", "groupby", "x", "group", "size", "assert_array_equal", "res", "sort_values", "x", "group", "y", "expected"], "doc_len": 40}
{"doc_id": "tests/_stats/test_counting.py::TestHist.single_args", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "single_args", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def single_args(self):\n\n        groupby = GroupBy([\"group\"])\n\n        class Scale:\n            scale_type = \"continuous\"\n\n        return groupby, \"x\", {\"x\": Scale()}\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "single_args", "self", "groupby", "groupby", "group", "class", "scale", "scale_type", "continuous", "return", "groupby", "x", "x", "scale"], "doc_len": 20}
{"doc_id": "tests/_stats/test_counting.py::TestHist.triple_args", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "triple_args", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def triple_args(self):\n\n        groupby = GroupBy([\"group\", \"a\", \"s\"])\n\n        class Scale:\n            scale_type = \"continuous\"\n\n        return groupby, \"x\", {\"x\": Scale()}\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "triple_args", "self", "groupby", "groupby", "group", "a", "s", "class", "scale", "scale_type", "continuous", "return", "groupby", "x", "x", "scale"], "doc_len": 22}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_string_bins", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_string_bins", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_string_bins(self, long_df):\n\n        h = Hist(bins=\"sqrt\")\n        bin_kws = h._define_bin_params(long_df, \"x\", \"continuous\")\n        assert bin_kws[\"range\"] == (long_df[\"x\"].min(), long_df[\"x\"].max())\n        assert bin_kws[\"bins\"] == int(np.sqrt(len(long_df)))\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_string_bins", "self", "long_df", "h", "hist", "bins", "sqrt", "bin_kws", "h", "_define_bin_params", "long_df", "x", "continuous", "assert", "bin_kws", "range", "long_df", "x", "min", "long_df", "x", "max", "assert", "bin_kws", "bins", "int", "np", "sqrt", "len", "long_df"], "doc_len": 36}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_int_bins", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_int_bins", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_int_bins(self, long_df):\n\n        n = 24\n        h = Hist(bins=n)\n        bin_kws = h._define_bin_params(long_df, \"x\", \"continuous\")\n        assert bin_kws[\"range\"] == (long_df[\"x\"].min(), long_df[\"x\"].max())\n        assert bin_kws[\"bins\"] == n\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_int_bins", "self", "long_df", "n", "24", "h", "hist", "bins", "n", "bin_kws", "h", "_define_bin_params", "long_df", "x", "continuous", "assert", "bin_kws", "range", "long_df", "x", "min", "long_df", "x", "max", "assert", "bin_kws", "bins", "n"], "doc_len": 34}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_array_bins", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_array_bins", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_array_bins(self, long_df):\n\n        bins = [-3, -2, 1, 2, 3]\n        h = Hist(bins=bins)\n        bin_kws = h._define_bin_params(long_df, \"x\", \"continuous\")\n        assert_array_equal(bin_kws[\"bins\"], bins)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_array_bins", "self", "long_df", "bins", "3", "2", "1", "2", "3", "h", "hist", "bins", "bins", "bin_kws", "h", "_define_bin_params", "long_df", "x", "continuous", "assert_array_equal", "bin_kws", "bins", "bins"], "doc_len": 29}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_binwidth", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_binwidth", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_binwidth(self, long_df):\n\n        binwidth = .5\n        h = Hist(binwidth=binwidth)\n        bin_kws = h._define_bin_params(long_df, \"x\", \"continuous\")\n        n_bins = bin_kws[\"bins\"]\n        left, right = bin_kws[\"range\"]\n        assert (right - left) / n_bins == pytest.approx(binwidth)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_binwidth", "self", "long_df", "binwidth", "5", "h", "hist", "binwidth", "binwidth", "bin_kws", "h", "_define_bin_params", "long_df", "x", "continuous", "n_bins", "bin_kws", "bins", "left", "right", "bin_kws", "range", "assert", "right", "left", "n_bins", "pytest", "approx", "binwidth"], "doc_len": 35}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_binrange", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_binrange", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_binrange(self, long_df):\n\n        binrange = (-4, 4)\n        h = Hist(binrange=binrange)\n        bin_kws = h._define_bin_params(long_df, \"x\", \"continuous\")\n        assert bin_kws[\"range\"] == binrange\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_binrange", "self", "long_df", "binrange", "4", "4", "h", "hist", "binrange", "binrange", "bin_kws", "h", "_define_bin_params", "long_df", "x", "continuous", "assert", "bin_kws", "range", "binrange"], "doc_len": 26}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_discrete_bins", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_discrete_bins", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_discrete_bins(self, long_df):\n\n        h = Hist(discrete=True)\n        x = long_df[\"x\"].astype(int)\n        bin_kws = h._define_bin_params(long_df.assign(x=x), \"x\", \"continuous\")\n        assert bin_kws[\"range\"] == (x.min() - .5, x.max() + .5)\n        assert bin_kws[\"bins\"] == (x.max() - x.min() + 1)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_discrete_bins", "self", "long_df", "h", "hist", "discrete", "true", "x", "long_df", "x", "astype", "int", "bin_kws", "h", "_define_bin_params", "long_df", "assign", "x", "x", "x", "continuous", "assert", "bin_kws", "range", "x", "min", "5", "x", "max", "5", "assert", "bin_kws", "bins", "x", "max", "x", "min", "1"], "doc_len": 44}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_discrete_bins_from_nominal_scale", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_discrete_bins_from_nominal_scale", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_discrete_bins_from_nominal_scale(self, rng):\n\n        h = Hist()\n        x = rng.randint(0, 5, 10)\n        df = pd.DataFrame({\"x\": x})\n        bin_kws = h._define_bin_params(df, \"x\", \"nominal\")\n        assert bin_kws[\"range\"] == (x.min() - .5, x.max() + .5)\n        assert bin_kws[\"bins\"] == (x.max() - x.min() + 1)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_discrete_bins_from_nominal_scale", "self", "rng", "h", "hist", "x", "rng", "randint", "0", "5", "10", "df", "pd", "dataframe", "x", "x", "bin_kws", "h", "_define_bin_params", "df", "x", "nominal", "assert", "bin_kws", "range", "x", "min", "5", "x", "max", "5", "assert", "bin_kws", "bins", "x", "max", "x", "min", "1"], "doc_len": 45}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_count_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_count_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_count_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"count\")\n        out = h(long_df, *single_args)\n        assert out[\"y\"].sum() == len(long_df)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_count_stat", "self", "long_df", "single_args", "h", "hist", "stat", "count", "out", "h", "long_df", "single_args", "assert", "out", "y", "sum", "len", "long_df"], "doc_len": 24}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_probability_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_probability_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_probability_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"probability\")\n        out = h(long_df, *single_args)\n        assert out[\"y\"].sum() == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_probability_stat", "self", "long_df", "single_args", "h", "hist", "stat", "probability", "out", "h", "long_df", "single_args", "assert", "out", "y", "sum", "1"], "doc_len": 23}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_proportion_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_proportion_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_proportion_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"proportion\")\n        out = h(long_df, *single_args)\n        assert out[\"y\"].sum() == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_proportion_stat", "self", "long_df", "single_args", "h", "hist", "stat", "proportion", "out", "h", "long_df", "single_args", "assert", "out", "y", "sum", "1"], "doc_len": 23}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_percent_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_percent_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_percent_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"percent\")\n        out = h(long_df, *single_args)\n        assert out[\"y\"].sum() == 100\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_percent_stat", "self", "long_df", "single_args", "h", "hist", "stat", "percent", "out", "h", "long_df", "single_args", "assert", "out", "y", "sum", "100"], "doc_len": 23}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_density_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_density_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_density_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"density\")\n        out = h(long_df, *single_args)\n        assert (out[\"y\"] * out[\"space\"]).sum() == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_density_stat", "self", "long_df", "single_args", "h", "hist", "stat", "density", "out", "h", "long_df", "single_args", "assert", "out", "y", "out", "space", "sum", "1"], "doc_len": 25}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_frequency_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_frequency_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_frequency_stat(self, long_df, single_args):\n\n        h = Hist(stat=\"frequency\")\n        out = h(long_df, *single_args)\n        assert (out[\"y\"] * out[\"space\"]).sum() == len(long_df)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_frequency_stat", "self", "long_df", "single_args", "h", "hist", "stat", "frequency", "out", "h", "long_df", "single_args", "assert", "out", "y", "out", "space", "sum", "len", "long_df"], "doc_len": 26}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_invalid_stat", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_invalid_stat", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_invalid_stat(self):\n\n        with pytest.raises(ValueError, match=\"The `stat` parameter for `Hist`\"):\n            Hist(stat=\"invalid\")\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_invalid_stat", "self", "with", "pytest", "raises", "valueerror", "match", "the", "stat", "parameter", "for", "hist", "hist", "stat", "invalid"], "doc_len": 21}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_cumulative_count", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_cumulative_count", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_cumulative_count(self, long_df, single_args):\n\n        h = Hist(stat=\"count\", cumulative=True)\n        out = h(long_df, *single_args)\n        assert out[\"y\"].max() == len(long_df)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_cumulative_count", "self", "long_df", "single_args", "h", "hist", "stat", "count", "cumulative", "true", "out", "h", "long_df", "single_args", "assert", "out", "y", "max", "len", "long_df"], "doc_len": 26}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_cumulative_proportion", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_cumulative_proportion", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_cumulative_proportion(self, long_df, single_args):\n\n        h = Hist(stat=\"proportion\", cumulative=True)\n        out = h(long_df, *single_args)\n        assert out[\"y\"].max() == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_cumulative_proportion", "self", "long_df", "single_args", "h", "hist", "stat", "proportion", "cumulative", "true", "out", "h", "long_df", "single_args", "assert", "out", "y", "max", "1"], "doc_len": 25}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_cumulative_density", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_cumulative_density", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_cumulative_density(self, long_df, single_args):\n\n        h = Hist(stat=\"density\", cumulative=True)\n        out = h(long_df, *single_args)\n        assert out[\"y\"].max() == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_cumulative_density", "self", "long_df", "single_args", "h", "hist", "stat", "density", "cumulative", "true", "out", "h", "long_df", "single_args", "assert", "out", "y", "max", "1"], "doc_len": 25}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_norm_default", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_norm_default", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_norm_default(self, long_df, triple_args):\n\n        h = Hist(stat=\"percent\")\n        out = h(long_df, *triple_args)\n        assert out[\"y\"].sum() == pytest.approx(100)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_norm_default", "self", "long_df", "triple_args", "h", "hist", "stat", "percent", "out", "h", "long_df", "triple_args", "assert", "out", "y", "sum", "pytest", "approx", "100"], "doc_len": 25}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_norm_false", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_norm_false", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_norm_false(self, long_df, triple_args):\n\n        h = Hist(stat=\"percent\", common_norm=False)\n        out = h(long_df, *triple_args)\n        for _, out_part in out.groupby([\"a\", \"s\"]):\n            assert out_part[\"y\"].sum() == pytest.approx(100)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_norm_false", "self", "long_df", "triple_args", "h", "hist", "stat", "percent", "common_norm", "false", "out", "h", "long_df", "triple_args", "for", "_", "out_part", "in", "out", "groupby", "a", "s", "assert", "out_part", "y", "sum", "pytest", "approx", "100"], "doc_len": 35}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_norm_subset", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_norm_subset", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_norm_subset(self, long_df, triple_args):\n\n        h = Hist(stat=\"percent\", common_norm=[\"a\"])\n        out = h(long_df, *triple_args)\n        for _, out_part in out.groupby(\"a\"):\n            assert out_part[\"y\"].sum() == pytest.approx(100)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_norm_subset", "self", "long_df", "triple_args", "h", "hist", "stat", "percent", "common_norm", "a", "out", "h", "long_df", "triple_args", "for", "_", "out_part", "in", "out", "groupby", "a", "assert", "out_part", "y", "sum", "pytest", "approx", "100"], "doc_len": 34}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_norm_warning", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_norm_warning", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_norm_warning(self, long_df, triple_args):\n\n        h = Hist(common_norm=[\"b\"])\n        with pytest.warns(UserWarning, match=r\"Undefined variable\\(s\\)\"):\n            h(long_df, *triple_args)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_norm_warning", "self", "long_df", "triple_args", "h", "hist", "common_norm", "b", "with", "pytest", "warns", "userwarning", "match", "r", "undefined", "variable", "s", "h", "long_df", "triple_args"], "doc_len": 26}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_bins_default", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_bins_default", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_bins_default(self, long_df, triple_args):\n\n        h = Hist()\n        out = h(long_df, *triple_args)\n        bins = []\n        for _, out_part in out.groupby([\"a\", \"s\"]):\n            bins.append(tuple(out_part[\"x\"]))\n        assert len(set(bins)) == 1\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_bins_default", "self", "long_df", "triple_args", "h", "hist", "out", "h", "long_df", "triple_args", "bins", "for", "_", "out_part", "in", "out", "groupby", "a", "s", "bins", "append", "tuple", "out_part", "x", "assert", "len", "set", "bins", "1"], "doc_len": 35}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_bins_false", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_bins_false", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_bins_false(self, long_df, triple_args):\n\n        h = Hist(common_bins=False)\n        out = h(long_df, *triple_args)\n        bins = []\n        for _, out_part in out.groupby([\"a\", \"s\"]):\n            bins.append(tuple(out_part[\"x\"]))\n        assert len(set(bins)) == len(out.groupby([\"a\", \"s\"]))\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_bins_false", "self", "long_df", "triple_args", "h", "hist", "common_bins", "false", "out", "h", "long_df", "triple_args", "bins", "for", "_", "out_part", "in", "out", "groupby", "a", "s", "bins", "append", "tuple", "out_part", "x", "assert", "len", "set", "bins", "len", "out", "groupby", "a", "s"], "doc_len": 41}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_bins_subset", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_bins_subset", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_bins_subset(self, long_df, triple_args):\n\n        h = Hist(common_bins=False)\n        out = h(long_df, *triple_args)\n        bins = []\n        for _, out_part in out.groupby(\"a\"):\n            bins.append(tuple(out_part[\"x\"]))\n        assert len(set(bins)) == out[\"a\"].nunique()\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_bins_subset", "self", "long_df", "triple_args", "h", "hist", "common_bins", "false", "out", "h", "long_df", "triple_args", "bins", "for", "_", "out_part", "in", "out", "groupby", "a", "bins", "append", "tuple", "out_part", "x", "assert", "len", "set", "bins", "out", "a", "nunique"], "doc_len": 38}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_common_bins_warning", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_common_bins_warning", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_common_bins_warning(self, long_df, triple_args):\n\n        h = Hist(common_bins=[\"b\"])\n        with pytest.warns(UserWarning, match=r\"Undefined variable\\(s\\)\"):\n            h(long_df, *triple_args)\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_common_bins_warning", "self", "long_df", "triple_args", "h", "hist", "common_bins", "b", "with", "pytest", "warns", "userwarning", "match", "r", "undefined", "variable", "s", "h", "long_df", "triple_args"], "doc_len": 26}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_histogram_single", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_histogram_single", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_histogram_single(self, long_df, single_args):\n\n        h = Hist()\n        out = h(long_df, *single_args)\n        hist, edges = np.histogram(long_df[\"x\"], bins=\"auto\")\n        assert_array_equal(out[\"y\"], hist)\n        assert_array_equal(out[\"space\"], np.diff(edges))\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_histogram_single", "self", "long_df", "single_args", "h", "hist", "out", "h", "long_df", "single_args", "hist", "edges", "np", "histogram", "long_df", "x", "bins", "auto", "assert_array_equal", "out", "y", "hist", "assert_array_equal", "out", "space", "np", "diff", "edges"], "doc_len": 34}
{"doc_id": "tests/_stats/test_counting.py::TestHist.test_histogram_multiple", "file_path": "tests/_stats/test_counting.py", "class_name": "TestHist", "func_name": "test_histogram_multiple", "text": "文件路径: tests/_stats/test_counting.py, 类名: TestHist\n    def test_histogram_multiple(self, long_df, triple_args):\n\n        h = Hist()\n        out = h(long_df, *triple_args)\n        bins = np.histogram_bin_edges(long_df[\"x\"], \"auto\")\n        for (a, s), out_part in out.groupby([\"a\", \"s\"]):\n            x = long_df.loc[(long_df[\"a\"] == a) & (long_df[\"s\"] == s), \"x\"]\n            hist, edges = np.histogram(x, bins=bins)\n            assert_array_equal(out_part[\"y\"], hist)\n            assert_array_equal(out_part[\"space\"], np.diff(edges))\n", "tokens": ["tests", "_stats", "test_counting", "py", "testhist", "def", "test_histogram_multiple", "self", "long_df", "triple_args", "h", "hist", "out", "h", "long_df", "triple_args", "bins", "np", "histogram_bin_edges", "long_df", "x", "auto", "for", "a", "s", "out_part", "in", "out", "groupby", "a", "s", "x", "long_df", "loc", "long_df", "a", "a", "long_df", "s", "s", "x", "hist", "edges", "np", "histogram", "x", "bins", "bins", "assert_array_equal", "out_part", "y", "hist", "assert_array_equal", "out_part", "space", "np", "diff", "edges"], "doc_len": 58}
{"doc_id": "tests/_stats/test_density.py::TestKDE.df", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "df", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def df(self, rng):\n\n        n = 100\n        return pd.DataFrame(dict(\n            x=rng.uniform(0, 7, n).round(),\n            y=rng.normal(size=n),\n            color=rng.choice([\"a\", \"b\", \"c\"], n),\n            alpha=rng.choice([\"x\", \"y\"], n),\n        ))\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "df", "self", "rng", "n", "100", "return", "pd", "dataframe", "dict", "x", "rng", "uniform", "0", "7", "n", "round", "y", "rng", "normal", "size", "n", "color", "rng", "choice", "a", "b", "c", "n", "alpha", "rng", "choice", "x", "y", "n"], "doc_len": 40}
{"doc_id": "tests/_stats/test_density.py::TestKDE.get_groupby", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "get_groupby", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def get_groupby(self, df, orient):\n\n        cols = [c for c in df if c != orient]\n        return GroupBy([*cols, \"group\"])\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "get_groupby", "self", "df", "orient", "cols", "c", "for", "c", "in", "df", "if", "c", "orient", "return", "groupby", "cols", "group"], "doc_len": 23}
{"doc_id": "tests/_stats/test_density.py::TestKDE.integrate", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "integrate", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def integrate(self, y, x):\n        y = np.asarray(y)\n        x = np.asarray(x)\n        dx = np.diff(x)\n        return (dx * y[:-1] + dx * y[1:]).sum() / 2\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "integrate", "self", "y", "x", "y", "np", "asarray", "y", "x", "np", "asarray", "x", "dx", "np", "diff", "x", "return", "dx", "y", "1", "dx", "y", "1", "sum", "2"], "doc_len": 31}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_columns", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_columns", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_columns(self, df, ori):\n\n        df = df[[ori, \"alpha\"]]\n        gb = self.get_groupby(df, ori)\n        res = KDE()(df, gb, ori, {})\n        other = {\"x\": \"y\", \"y\": \"x\"}[ori]\n        expected = [ori, \"alpha\", \"density\", other]\n        assert list(res.columns) == expected\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_columns", "self", "df", "ori", "df", "df", "ori", "alpha", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "df", "gb", "ori", "other", "x", "y", "y", "x", "ori", "expected", "ori", "alpha", "density", "other", "assert", "list", "res", "columns", "expected"], "doc_len": 40}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_gridsize", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_gridsize", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_gridsize(self, df, gridsize):\n\n        ori = \"y\"\n        df = df[[ori]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(gridsize=gridsize)(df, gb, ori, {})\n        if gridsize is None:\n            assert_array_equal(res[ori], df[ori])\n        else:\n            assert len(res) == gridsize\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_gridsize", "self", "df", "gridsize", "ori", "y", "df", "df", "ori", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "gridsize", "gridsize", "df", "gb", "ori", "if", "gridsize", "is", "none", "assert_array_equal", "res", "ori", "df", "ori", "else", "assert", "len", "res", "gridsize"], "doc_len": 41}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_cut", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_cut", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_cut(self, df, cut):\n\n        ori = \"y\"\n        df = df[[ori]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(cut=cut, bw_method=1)(df, gb, ori, {})\n\n        vals = df[ori]\n        bw = vals.std()\n        assert res[ori].min() == pytest.approx(vals.min() - bw * cut, abs=1e-2)\n        assert res[ori].max() == pytest.approx(vals.max() + bw * cut, abs=1e-2)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_cut", "self", "df", "cut", "ori", "y", "df", "df", "ori", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "cut", "cut", "bw_method", "1", "df", "gb", "ori", "vals", "df", "ori", "bw", "vals", "std", "assert", "res", "ori", "min", "pytest", "approx", "vals", "min", "bw", "cut", "abs", "1e", "2", "assert", "res", "ori", "max", "pytest", "approx", "vals", "max", "bw", "cut", "abs", "1e", "2"], "doc_len": 61}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_common_grid", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_common_grid", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_common_grid(self, df, common_grid):\n\n        ori = \"y\"\n        df = df[[ori, \"alpha\"]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(common_grid=common_grid)(df, gb, ori, {})\n\n        vals = df[\"alpha\"].unique()\n        a = res.loc[res[\"alpha\"] == vals[0], ori].to_numpy()\n        b = res.loc[res[\"alpha\"] == vals[1], ori].to_numpy()\n        if common_grid:\n            assert_array_equal(a, b)\n        else:\n            assert np.not_equal(a, b).all()\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_common_grid", "self", "df", "common_grid", "ori", "y", "df", "df", "ori", "alpha", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "common_grid", "common_grid", "df", "gb", "ori", "vals", "df", "alpha", "unique", "a", "res", "loc", "res", "alpha", "vals", "0", "ori", "to_numpy", "b", "res", "loc", "res", "alpha", "vals", "1", "ori", "to_numpy", "if", "common_grid", "assert_array_equal", "a", "b", "else", "assert", "np", "not_equal", "a", "b", "all"], "doc_len": 62}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_common_norm", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_common_norm", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_common_norm(self, df, common_norm):\n\n        ori = \"y\"\n        df = df[[ori, \"alpha\"]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(common_norm=common_norm)(df, gb, ori, {})\n\n        areas = (\n            res.groupby(\"alpha\")\n            .apply(lambda x: self.integrate(x[\"density\"], x[ori]))\n        )\n\n        if common_norm:\n            assert areas.sum() == pytest.approx(1, abs=1e-3)\n        else:\n            assert_array_almost_equal(areas, [1, 1], decimal=3)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_common_norm", "self", "df", "common_norm", "ori", "y", "df", "df", "ori", "alpha", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "common_norm", "common_norm", "df", "gb", "ori", "areas", "res", "groupby", "alpha", "apply", "lambda", "x", "self", "integrate", "x", "density", "x", "ori", "if", "common_norm", "assert", "areas", "sum", "pytest", "approx", "1", "abs", "1e", "3", "else", "assert_array_almost_equal", "areas", "1", "1", "decimal", "3"], "doc_len": 59}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_common_norm_variables", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_common_norm_variables", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_common_norm_variables(self, df):\n\n        ori = \"y\"\n        df = df[[ori, \"alpha\", \"color\"]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(common_norm=[\"alpha\"])(df, gb, ori, {})\n\n        def integrate_by_color_and_sum(x):\n            return (\n                x.groupby(\"color\")\n                .apply(lambda y: self.integrate(y[\"density\"], y[ori]))\n                .sum()\n            )\n\n        areas = res.groupby(\"alpha\").apply(integrate_by_color_and_sum)\n        assert_array_almost_equal(areas, [1, 1], decimal=3)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_common_norm_variables", "self", "df", "ori", "y", "df", "df", "ori", "alpha", "color", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "common_norm", "alpha", "df", "gb", "ori", "def", "integrate_by_color_and_sum", "x", "return", "x", "groupby", "color", "apply", "lambda", "y", "self", "integrate", "y", "density", "y", "ori", "sum", "areas", "res", "groupby", "alpha", "apply", "integrate_by_color_and_sum", "assert_array_almost_equal", "areas", "1", "1", "decimal", "3"], "doc_len": 57}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_common_input_checks", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_common_input_checks", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_common_input_checks(self, df, param):\n\n        ori = \"y\"\n        df = df[[ori, \"alpha\"]]\n        gb = self.get_groupby(df, ori)\n        msg = rf\"Undefined variable\\(s\\) passed for KDE.common_{param}\"\n        with pytest.warns(UserWarning, match=msg):\n            KDE(**{f\"common_{param}\": [\"color\", \"alpha\"]})(df, gb, ori, {})\n\n        msg = f\"KDE.common_{param} must be a boolean or list of strings\"\n        with pytest.raises(TypeError, match=msg):\n            KDE(**{f\"common_{param}\": \"alpha\"})(df, gb, ori, {})\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_common_input_checks", "self", "df", "param", "ori", "y", "df", "df", "ori", "alpha", "gb", "self", "get_groupby", "df", "ori", "msg", "rf", "undefined", "variable", "s", "passed", "for", "kde", "common_", "param", "with", "pytest", "warns", "userwarning", "match", "msg", "kde", "f", "common_", "param", "color", "alpha", "df", "gb", "ori", "msg", "f", "kde", "common_", "param", "must", "be", "a", "boolean", "or", "list", "of", "strings", "with", "pytest", "raises", "typeerror", "match", "msg", "kde", "f", "common_", "param", "alpha", "df", "gb", "ori"], "doc_len": 73}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_bw_adjust", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_bw_adjust", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_bw_adjust(self, df):\n\n        ori = \"y\"\n        df = df[[ori]]\n        gb = self.get_groupby(df, ori)\n        res1 = KDE(bw_adjust=0.5)(df, gb, ori, {})\n        res2 = KDE(bw_adjust=2.0)(df, gb, ori, {})\n\n        mad1 = res1[\"density\"].diff().abs().mean()\n        mad2 = res2[\"density\"].diff().abs().mean()\n        assert mad1 > mad2\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_bw_adjust", "self", "df", "ori", "y", "df", "df", "ori", "gb", "self", "get_groupby", "df", "ori", "res1", "kde", "bw_adjust", "0", "5", "df", "gb", "ori", "res2", "kde", "bw_adjust", "2", "0", "df", "gb", "ori", "mad1", "res1", "density", "diff", "abs", "mean", "mad2", "res2", "density", "diff", "abs", "mean", "assert", "mad1", "mad2"], "doc_len": 50}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_bw_method_scalar", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_bw_method_scalar", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_bw_method_scalar(self, df):\n\n        ori = \"y\"\n        df = df[[ori]]\n        gb = self.get_groupby(df, ori)\n        res1 = KDE(bw_method=0.5)(df, gb, ori, {})\n        res2 = KDE(bw_method=2.0)(df, gb, ori, {})\n\n        mad1 = res1[\"density\"].diff().abs().mean()\n        mad2 = res2[\"density\"].diff().abs().mean()\n        assert mad1 > mad2\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_bw_method_scalar", "self", "df", "ori", "y", "df", "df", "ori", "gb", "self", "get_groupby", "df", "ori", "res1", "kde", "bw_method", "0", "5", "df", "gb", "ori", "res2", "kde", "bw_method", "2", "0", "df", "gb", "ori", "mad1", "res1", "density", "diff", "abs", "mean", "mad2", "res2", "density", "diff", "abs", "mean", "assert", "mad1", "mad2"], "doc_len": 50}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_cumulative", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_cumulative", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_cumulative(self, df, common_norm):\n\n        ori = \"y\"\n        df = df[[ori, \"alpha\"]]\n        gb = self.get_groupby(df, ori)\n        res = KDE(cumulative=True, common_norm=common_norm)(df, gb, ori, {})\n\n        for _, group_res in res.groupby(\"alpha\"):\n            assert (group_res[\"density\"].diff().dropna() >= 0).all()\n            if not common_norm:\n                assert group_res[\"density\"].max() == pytest.approx(1, abs=1e-3)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_cumulative", "self", "df", "common_norm", "ori", "y", "df", "df", "ori", "alpha", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "cumulative", "true", "common_norm", "common_norm", "df", "gb", "ori", "for", "_", "group_res", "in", "res", "groupby", "alpha", "assert", "group_res", "density", "diff", "dropna", "0", "all", "if", "not", "common_norm", "assert", "group_res", "density", "max", "pytest", "approx", "1", "abs", "1e", "3"], "doc_len": 57}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_cumulative_requires_scipy", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_cumulative_requires_scipy", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_cumulative_requires_scipy(self):\n\n        if _no_scipy:\n            err = \"Cumulative KDE evaluation requires scipy\"\n            with pytest.raises(RuntimeError, match=err):\n                KDE(cumulative=True)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_cumulative_requires_scipy", "self", "if", "_no_scipy", "err", "cumulative", "kde", "evaluation", "requires", "scipy", "with", "pytest", "raises", "runtimeerror", "match", "err", "kde", "cumulative", "true"], "doc_len": 25}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_singular", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_singular", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_singular(self, df, vals):\n\n        df1 = pd.DataFrame({\"y\": vals, \"alpha\": [\"z\"] * len(vals)})\n        gb = self.get_groupby(df1, \"y\")\n        res = KDE()(df1, gb, \"y\", {})\n        assert res.empty\n\n        df2 = pd.concat([df[[\"y\", \"alpha\"]], df1], ignore_index=True)\n        gb = self.get_groupby(df2, \"y\")\n        res = KDE()(df2, gb, \"y\", {})\n        assert set(res[\"alpha\"]) == set(df[\"alpha\"])\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_singular", "self", "df", "vals", "df1", "pd", "dataframe", "y", "vals", "alpha", "z", "len", "vals", "gb", "self", "get_groupby", "df1", "y", "res", "kde", "df1", "gb", "y", "assert", "res", "empty", "df2", "pd", "concat", "df", "y", "alpha", "df1", "ignore_index", "true", "gb", "self", "get_groupby", "df2", "y", "res", "kde", "df2", "gb", "y", "assert", "set", "res", "alpha", "set", "df", "alpha"], "doc_len": 58}
{"doc_id": "tests/_stats/test_density.py::TestKDE.test_missing", "file_path": "tests/_stats/test_density.py", "class_name": "TestKDE", "func_name": "test_missing", "text": "文件路径: tests/_stats/test_density.py, 类名: TestKDE\n    def test_missing(self, df, col):\n\n        val, ori = \"xy\"\n        df[\"weight\"] = 1\n        df = df[[ori, \"weight\"]]\n        df.loc[:4, col] = np.nan\n        gb = self.get_groupby(df, ori)\n        res = KDE()(df, gb, ori, {})\n        assert self.integrate(res[val], res[ori]) == pytest.approx(1, abs=1e-3)\n", "tokens": ["tests", "_stats", "test_density", "py", "testkde", "def", "test_missing", "self", "df", "col", "val", "ori", "xy", "df", "weight", "1", "df", "df", "ori", "weight", "df", "loc", "4", "col", "np", "nan", "gb", "self", "get_groupby", "df", "ori", "res", "kde", "df", "gb", "ori", "assert", "self", "integrate", "res", "val", "res", "ori", "pytest", "approx", "1", "abs", "1e", "3"], "doc_len": 49}
{"doc_id": "tests/_stats/test_order.py::Fixtures.df", "file_path": "tests/_stats/test_order.py", "class_name": "Fixtures", "func_name": "df", "text": "文件路径: tests/_stats/test_order.py, 类名: Fixtures\n    def df(self, rng):\n        return pd.DataFrame(dict(x=\"\", y=rng.normal(size=30)))\n", "tokens": ["tests", "_stats", "test_order", "py", "fixtures", "def", "df", "self", "rng", "return", "pd", "dataframe", "dict", "x", "y", "rng", "normal", "size", "30"], "doc_len": 19}
{"doc_id": "tests/_stats/test_order.py::Fixtures.get_groupby", "file_path": "tests/_stats/test_order.py", "class_name": "Fixtures", "func_name": "get_groupby", "text": "文件路径: tests/_stats/test_order.py, 类名: Fixtures\n    def get_groupby(self, df, orient):\n        # TODO note, copied from aggregation\n        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n        cols = [c for c in df if c != other]\n        return GroupBy(cols)\n", "tokens": ["tests", "_stats", "test_order", "py", "fixtures", "def", "get_groupby", "self", "df", "orient", "todo", "note", "copied", "from", "aggregation", "other", "x", "y", "y", "x", "orient", "cols", "c", "for", "c", "in", "df", "if", "c", "other", "return", "groupby", "cols"], "doc_len": 33}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_int_k", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_int_k", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_int_k(self, df):\n\n        ori = \"x\"\n        gb = self.get_groupby(df, ori)\n        res = Perc(3)(df, gb, ori, {})\n        percentiles = [0, 50, 100]\n        assert_array_equal(res[\"percentile\"], percentiles)\n        assert_array_equal(res[\"y\"], np.percentile(df[\"y\"], percentiles))\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_int_k", "self", "df", "ori", "x", "gb", "self", "get_groupby", "df", "ori", "res", "perc", "3", "df", "gb", "ori", "percentiles", "0", "50", "100", "assert_array_equal", "res", "percentile", "percentiles", "assert_array_equal", "res", "y", "np", "percentile", "df", "y", "percentiles"], "doc_len": 38}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_list_k", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_list_k", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_list_k(self, df):\n\n        ori = \"x\"\n        gb = self.get_groupby(df, ori)\n        percentiles = [0, 20, 100]\n        res = Perc(k=percentiles)(df, gb, ori, {})\n        assert_array_equal(res[\"percentile\"], percentiles)\n        assert_array_equal(res[\"y\"], np.percentile(df[\"y\"], percentiles))\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_list_k", "self", "df", "ori", "x", "gb", "self", "get_groupby", "df", "ori", "percentiles", "0", "20", "100", "res", "perc", "k", "percentiles", "df", "gb", "ori", "assert_array_equal", "res", "percentile", "percentiles", "assert_array_equal", "res", "y", "np", "percentile", "df", "y", "percentiles"], "doc_len": 39}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_orientation", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_orientation", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_orientation(self, df):\n\n        df = df.rename(columns={\"x\": \"y\", \"y\": \"x\"})\n        ori = \"y\"\n        gb = self.get_groupby(df, ori)\n        res = Perc(k=3)(df, gb, ori, {})\n        assert_array_equal(res[\"x\"], np.percentile(df[\"x\"], [0, 50, 100]))\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_orientation", "self", "df", "df", "df", "rename", "columns", "x", "y", "y", "x", "ori", "y", "gb", "self", "get_groupby", "df", "ori", "res", "perc", "k", "3", "df", "gb", "ori", "assert_array_equal", "res", "x", "np", "percentile", "df", "x", "0", "50", "100"], "doc_len": 41}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_method", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_method", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_method(self, df):\n\n        ori = \"x\"\n        gb = self.get_groupby(df, ori)\n        method = \"nearest\"\n        res = Perc(k=5, method=method)(df, gb, ori, {})\n        percentiles = [0, 25, 50, 75, 100]\n        if Version(np.__version__) < Version(\"1.22.0\"):\n            expected = np.percentile(df[\"y\"], percentiles, interpolation=method)\n        else:\n            expected = np.percentile(df[\"y\"], percentiles, method=method)\n        assert_array_equal(res[\"y\"], expected)\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_method", "self", "df", "ori", "x", "gb", "self", "get_groupby", "df", "ori", "method", "nearest", "res", "perc", "k", "5", "method", "method", "df", "gb", "ori", "percentiles", "0", "25", "50", "75", "100", "if", "version", "np", "__version__", "version", "1", "22", "0", "expected", "np", "percentile", "df", "y", "percentiles", "interpolation", "method", "else", "expected", "np", "percentile", "df", "y", "percentiles", "method", "method", "assert_array_equal", "res", "y", "expected"], "doc_len": 62}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_grouped", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_grouped", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_grouped(self, df, rng):\n\n        ori = \"x\"\n        df = df.assign(x=rng.choice([\"a\", \"b\", \"c\"], len(df)))\n        gb = self.get_groupby(df, ori)\n        k = [10, 90]\n        res = Perc(k)(df, gb, ori, {})\n        for x, res_x in res.groupby(\"x\"):\n            assert_array_equal(res_x[\"percentile\"], k)\n            expected = np.percentile(df.loc[df[\"x\"] == x, \"y\"], k)\n            assert_array_equal(res_x[\"y\"], expected)\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_grouped", "self", "df", "rng", "ori", "x", "df", "df", "assign", "x", "rng", "choice", "a", "b", "c", "len", "df", "gb", "self", "get_groupby", "df", "ori", "k", "10", "90", "res", "perc", "k", "df", "gb", "ori", "for", "x", "res_x", "in", "res", "groupby", "x", "assert_array_equal", "res_x", "percentile", "k", "expected", "np", "percentile", "df", "loc", "df", "x", "x", "y", "k", "assert_array_equal", "res_x", "y", "expected"], "doc_len": 62}
{"doc_id": "tests/_stats/test_order.py::TestPerc.test_with_na", "file_path": "tests/_stats/test_order.py", "class_name": "TestPerc", "func_name": "test_with_na", "text": "文件路径: tests/_stats/test_order.py, 类名: TestPerc\n    def test_with_na(self, df):\n\n        ori = \"x\"\n        df.loc[:5, \"y\"] = np.nan\n        gb = self.get_groupby(df, ori)\n        k = [10, 90]\n        res = Perc(k)(df, gb, ori, {})\n        expected = np.percentile(df[\"y\"].dropna(), k)\n        assert_array_equal(res[\"y\"], expected)\n", "tokens": ["tests", "_stats", "test_order", "py", "testperc", "def", "test_with_na", "self", "df", "ori", "x", "df", "loc", "5", "y", "np", "nan", "gb", "self", "get_groupby", "df", "ori", "k", "10", "90", "res", "perc", "k", "df", "gb", "ori", "expected", "np", "percentile", "df", "y", "dropna", "k", "assert_array_equal", "res", "y", "expected"], "doc_len": 42}
{"doc_id": "tests/_stats/test_regression.py::TestPolyFit.df", "file_path": "tests/_stats/test_regression.py", "class_name": "TestPolyFit", "func_name": "df", "text": "文件路径: tests/_stats/test_regression.py, 类名: TestPolyFit\n    def df(self, rng):\n\n        n = 100\n        return pd.DataFrame(dict(\n            x=rng.normal(0, 1, n),\n            y=rng.normal(0, 1, n),\n            color=rng.choice([\"a\", \"b\", \"c\"], n),\n            group=rng.choice([\"x\", \"y\"], n),\n        ))\n", "tokens": ["tests", "_stats", "test_regression", "py", "testpolyfit", "def", "df", "self", "rng", "n", "100", "return", "pd", "dataframe", "dict", "x", "rng", "normal", "0", "1", "n", "y", "rng", "normal", "0", "1", "n", "color", "rng", "choice", "a", "b", "c", "n", "group", "rng", "choice", "x", "y", "n"], "doc_len": 40}
{"doc_id": "tests/_stats/test_regression.py::TestPolyFit.test_no_grouper", "file_path": "tests/_stats/test_regression.py", "class_name": "TestPolyFit", "func_name": "test_no_grouper", "text": "文件路径: tests/_stats/test_regression.py, 类名: TestPolyFit\n    def test_no_grouper(self, df):\n\n        groupby = GroupBy([\"group\"])\n        res = PolyFit(order=1, gridsize=100)(df[[\"x\", \"y\"]], groupby, \"x\", {})\n\n        assert_array_equal(res.columns, [\"x\", \"y\"])\n\n        grid = np.linspace(df[\"x\"].min(), df[\"x\"].max(), 100)\n        assert_array_equal(res[\"x\"], grid)\n        assert_array_almost_equal(\n            res[\"y\"].diff().diff().dropna(), np.zeros(grid.size - 2)\n        )\n", "tokens": ["tests", "_stats", "test_regression", "py", "testpolyfit", "def", "test_no_grouper", "self", "df", "groupby", "groupby", "group", "res", "polyfit", "order", "1", "gridsize", "100", "df", "x", "y", "groupby", "x", "assert_array_equal", "res", "columns", "x", "y", "grid", "np", "linspace", "df", "x", "min", "df", "x", "max", "100", "assert_array_equal", "res", "x", "grid", "assert_array_almost_equal", "res", "y", "diff", "diff", "dropna", "np", "zeros", "grid", "size", "2"], "doc_len": 53}
{"doc_id": "tests/_stats/test_regression.py::TestPolyFit.test_one_grouper", "file_path": "tests/_stats/test_regression.py", "class_name": "TestPolyFit", "func_name": "test_one_grouper", "text": "文件路径: tests/_stats/test_regression.py, 类名: TestPolyFit\n    def test_one_grouper(self, df):\n\n        groupby = GroupBy([\"group\"])\n        gridsize = 50\n        res = PolyFit(gridsize=gridsize)(df, groupby, \"x\", {})\n\n        assert res.columns.to_list() == [\"x\", \"y\", \"group\"]\n\n        ngroups = df[\"group\"].nunique()\n        assert_array_equal(res.index, np.arange(ngroups * gridsize))\n\n        for _, part in res.groupby(\"group\"):\n            grid = np.linspace(part[\"x\"].min(), part[\"x\"].max(), gridsize)\n            assert_array_equal(part[\"x\"], grid)\n            assert part[\"y\"].diff().diff().dropna().abs().gt(0).all()\n", "tokens": ["tests", "_stats", "test_regression", "py", "testpolyfit", "def", "test_one_grouper", "self", "df", "groupby", "groupby", "group", "gridsize", "50", "res", "polyfit", "gridsize", "gridsize", "df", "groupby", "x", "assert", "res", "columns", "to_list", "x", "y", "group", "ngroups", "df", "group", "nunique", "assert_array_equal", "res", "index", "np", "arange", "ngroups", "gridsize", "for", "_", "part", "in", "res", "groupby", "group", "grid", "np", "linspace", "part", "x", "min", "part", "x", "max", "gridsize", "assert_array_equal", "part", "x", "grid", "assert", "part", "y", "diff", "diff", "dropna", "abs", "gt", "0", "all"], "doc_len": 70}
{"doc_id": "tests/_stats/test_regression.py::TestPolyFit.test_missing_data", "file_path": "tests/_stats/test_regression.py", "class_name": "TestPolyFit", "func_name": "test_missing_data", "text": "文件路径: tests/_stats/test_regression.py, 类名: TestPolyFit\n    def test_missing_data(self, df):\n\n        groupby = GroupBy([\"group\"])\n        df.iloc[5:10] = np.nan\n        res1 = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n        res2 = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n        assert_frame_equal(res1, res2)", "tokens": ["tests", "_stats", "test_regression", "py", "testpolyfit", "def", "test_missing_data", "self", "df", "groupby", "groupby", "group", "df", "iloc", "5", "10", "np", "nan", "res1", "polyfit", "df", "x", "y", "groupby", "x", "res2", "polyfit", "df", "x", "y", "dropna", "groupby", "x", "assert_frame_equal", "res1", "res2"], "doc_len": 36}
